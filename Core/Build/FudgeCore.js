"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        /**
         * Merge the given message and arguments into a single string, separated by ', '
         */
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["SOURCE"] = 512] = "SOURCE";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "‚úì",
        [DEBUG_FILTER.LOG]: "‚úé",
        [DEBUG_FILTER.WARN]: "‚ö†",
        [DEBUG_FILTER.ERROR]: "‚ùå",
        [DEBUG_FILTER.FUDGE]: "üé≤",
        [DEBUG_FILTER.SOURCE]: "üîó"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    class DebugConsole extends FudgeCore.DebugTarget {
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: console.info,
            [FudgeCore.DEBUG_FILTER.LOG]: console.log,
            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source
        }; }
        /**
         * Should be used to display uncritical state information of FUDGE, only visible in browser's verbose mode
         */
        static fudge(_message, ..._args) {
            console.debug(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE], _message, ..._args);
        }
        /**
         * Displays an extra line with information about the source of the debug message
         */
        static source(_message, ..._args) {
            console.log(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE], _message, ..._args);
        }
    }
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various {@link DebugTarget}s that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of {@link DebugTarget} and register them as their delegates
     */
    class Debug {
        /**
         * For each set filter, this associative array keeps references to the registered delegate functions of the chosen {@link DebugTarget}s
         */
        static { this.delegates = Debug.setupConsole(); }
        /**
         * De- / Activate a filter for the given DebugTarget.
         */
        static setFilter(_target, _filter) {
            for (let filter in Debug.delegates)
                Debug.delegates[filter].delete(_target);
            for (let filter in FudgeCore.DEBUG_FILTER) {
                let parsed = parseInt(filter);
                if (isNaN(parsed))
                    break;
                if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                    // dont delegate combos... 
                    continue;
                if (_filter & parsed)
                    Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
            }
        }
        /**
         * Get the filter(s) for the given DebugTarget.
         */
        static getFilter(_target) {
            let result = 0;
            for (let filter in _target.delegates)
                result |= parseInt(filter);
            return result;
        }
        /**
         * Add a filter to the given DebugTarget.
         */
        static addFilter(_target, _filter) {
            let current = Debug.getFilter(_target);
            Debug.setFilter(_target, current | _filter);
        }
        /**
         * Remove a filter from the given DebugTarget.
         */
        static removeFilter(_target, _filter) {
            let current = Debug.getFilter(_target);
            Debug.setFilter(_target, current ^ _filter);
        }
        /**
         * Info(...) displays additional information with low priority
         */
        static info(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
        }
        /**
         * Displays information with medium priority
         */
        static log(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
        }
        /**
         * Displays information about non-conformities in usage, which is emphasized e.g. by color
         */
        static warn(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
        }
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static error(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
        }
        /**
         * Displays messages from FUDGE
         */
        static fudge(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
        }
        /**
         * Clears the output and removes previous messages if possible
         */
        static clear() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
        }
        /**
         * Opens a new group for messages
         */
        static group(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
        }
        /**
         * Opens a new group for messages that is collapsed at first
         */
        static groupCollapsed(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
        }
        /**
         * Closes the youngest group
         */
        static groupEnd() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
        }
        /**
         * Log a branch of the node hierarchy
         */
        static branch(_branch) {
            if (_branch.nChildren > 0)
                Debug.group(_branch.name);
            else
                Debug.fudge(_branch.name);
            for (let child of _branch.getChildren())
                Debug.branch(child);
            if (_branch.nChildren > 0)
                Debug.groupEnd();
        }
        /**
         * Displays messages about the source of the debug call
         */
        static source(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.SOURCE, _message, _args);
        }
        /**
         * Lookup all delegates registered to the filter and call them using the given arguments
         */
        static delegate(_filter, _message, _args) {
            if (_filter == FudgeCore.DEBUG_FILTER.LOG || _filter == FudgeCore.DEBUG_FILTER.WARN || _filter == FudgeCore.DEBUG_FILTER.ERROR) {
                if (Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE])
                    for (let delegate of Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE].values())
                        if (delegate) {
                            let trace = new Error("Test").stack.split("\n");
                            delegate(trace[3]);
                        }
            }
            let delegates = Debug.delegates[_filter];
            for (let delegate of delegates.values())
                if (delegate)
                    if (_args && _args.length > 0)
                        delegate(_message, ..._args);
                    else
                        delegate(_message);
        }
        /**
         * setup routing to standard console
         */
        static setupConsole() {
            let result = {};
            let filters = [
                FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND,
                FudgeCore.DEBUG_FILTER.SOURCE
            ];
            for (let filter of filters)
                result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
            result[FudgeCore.DEBUG_FILTER.SOURCE].delete(FudgeCore.DebugConsole);
            return result;
        }
    }
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Extends EventTarget to work with {@link EventListenerUnified} and {@link EventUnified} */
    class EventTargetUnified extends EventTarget {
        /**
         * See {@link EventTarget.addEventListener} for reference. Works with {@link EventListenerUnified} and {@link EventUnified}
         */
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        /**
         * See {@link EventTarget.removeEventListener} for reference. Works with {@link EventListenerUnified} and {@link EventUnified}
         */
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        /**
         * See {@link EventTarget.dispatchEvent} for reference. Works with with {@link EventUnified}
         */
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTargetUnified = EventTargetUnified;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of FUDGE, such as the core loop
     */
    class EventTargetStatic extends EventTargetUnified {
        static { this.targetStatic = new EventTargetStatic(); }
        constructor() {
            super();
        }
        /**
         * Add an event listener to {@link targetStatic}.
         */
        static addEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.addEventListener(_type, _handler);
        }
        /**
         * Remove an event listener from {@link targetStatic}.
         */
        static removeEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
        }
        /**
         * Dispatch an event on {@link targetStatic}.
         */
        static dispatchEvent(_event) {
            EventTargetStatic.targetStatic.dispatchEvent(_event);
            return true;
        }
    }
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    /**
     * Base class for all types being mutable using {@link Mutator}-objects, thus providing and using interfaces created at runtime.
     * Mutables provide a {@link Mutator} that is build by collecting all object-properties that are either of a primitive type or again Mutable.
     * Subclasses can either reduce the standard {@link Mutator} built by this base class by deleting properties or implement an individual getMutator-method.
     * The provided properties of the {@link Mutator} must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored if not handled by an override of the mutate-method in the subclass and throw errors in an automatically generated user-interface for the object.
     */
    class Mutable extends FudgeCore.EventTargetUnified {
        /**
         * Decorator allows to attach {@link Mutable} functionality to existing classes.
         */
        // public static decorate(_constructor: Function): void {
        //   Object.defineProperty(_constructor.prototype, "useRenderData", {
        //     value: function getMutator(this: MutableForUserInterface): Mutator {
        //       return getMutatorOfArbitrary(this);
        //     }
        //   });
        // }
        static getMutatorFromPath(_mutator, _path) {
            let key = _path[0];
            let mutator = {};
            if (_mutator[key] == undefined) // if the path deviates from mutator structure, return the mutator
                return _mutator;
            mutator[key] = _mutator[key];
            if (_path.length > 1)
                mutator[key] = Mutable.getMutatorFromPath(mutator[key], _path.slice(1, _path.length));
            return mutator;
        }
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object.
         * By default, a mutator cannot be extended, since extensions are not available in the object the mutator belongs to.
         * A mutator may be reduced by the descendants of {@link Mutable} to contain only the properties needed.
         */
        getMutator(_extendable = false) {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable) && !(value instanceof FudgeCore.MutableArray) && !(value.hasOwnProperty("idResource")))
                    continue;
                mutator[attribute] = this[attribute];
            }
            if (!_extendable)
                // mutator can be reduced but not extended!
                Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to mutators
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
                if (value instanceof FudgeCore.MutableArray)
                    mutator[attribute] = value.map((_value) => _value.getMutator());
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values
         * Does not recurse into objects!
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let attribute in _mutator) {
                let type = null;
                let value = _mutator[attribute];
                if (_mutator[attribute] != undefined)
                    if (typeof (value) == "object")
                        type = this[attribute].constructor.name;
                    else if (typeof (value) == "function")
                        type = value["name"];
                    else
                        type = _mutator[attribute].constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                if (value instanceof Mutable)
                    _mutator[attribute] = value.getMutator();
                else
                    _mutator[attribute] = this[attribute];
            }
        }
        /**
         * Updates the attribute values of the instance according to the state of the mutator.
         * The mutation may be restricted to a subset of the mutator and the event dispatching suppressed.
         * Uses mutateBase, but can be overwritten in subclasses
         */
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await this.mutateBase(_mutator, _selection);
            if (_dispatchMutate)
                this.dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { bubbles: true, detail: { mutator: _mutator } }));
        }
        /**
         * Base method for mutation, always available to subclasses. Do not overwrite in subclasses!
         */
        async mutateBase(_mutator, _selection) {
            let mutator = {};
            if (!_selection)
                mutator = _mutator;
            else
                for (let attribute of _selection) // reduce the mutator to the selection
                    if (typeof (_mutator[attribute]) !== "undefined")
                        mutator[attribute] = _mutator[attribute];
            for (let attribute in mutator) {
                if (!Reflect.has(this, attribute))
                    continue;
                let mutant = Reflect.get(this, attribute);
                let value = mutator[attribute];
                if (mutant instanceof FudgeCore.MutableArray || mutant instanceof Mutable)
                    await mutant.mutate(value, null, false);
                else
                    Reflect.set(this, attribute, value);
            }
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the external serialization and deserialization of {@link Serializable} objects. The internal process is handled by the objects themselves.
     * A {@link Serialization} object can be created from a {@link Serializable} object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a {@link Serialization} which can be deserialized to a {@link Serializable} object.
     * ```text
     *  [Serializable] ‚Üí (serialize) ‚Üí [Serialization] ‚Üí (stringify) ‚Üí [String] ‚Üí (save or send)
     *                                        ‚Üì                            ‚Üì                  ‚Üì
     *                [Serializable] ‚Üê (deserialize) ‚Üê [Serialization] ‚Üê (parse) ‚Üê (load) ‚Üê [Medium]
     * ```
     * While the internal serialize/deserialize method1s of the objects care of the selection of information needed to recreate the object and its structure,
     * the {@link Serializer} keeps track of the namespaces and classes in order to recreate {@link Serializable} objects. The general structure of a {@link Serialization} is as follows
     * ```text
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    class Serializer {
        /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
        static { this.namespaces = { "∆í": FudgeCore }; }
        /**
         * Registers a namespace to the {@link Serializer}, to enable automatic instantiation of classes defined within
         * @param _namespace
         */
        static registerNamespace(_namespace) {
            for (let name in Serializer.namespaces)
                if (Serializer.namespaces[name] == _namespace)
                    return name;
            let name = Serializer.findNamespaceIn(_namespace, window);
            if (!name)
                for (let parentName in Serializer.namespaces) {
                    name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                    if (name) {
                        name = parentName + "." + name;
                        break;
                    }
                }
            if (!name)
                throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
            Serializer.namespaces[name] = _namespace;
            return name;
        }
        /**
         * Returns a javascript object representing the serializable FUDGE-object given,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serialize(_object) {
            let serialization = {};
            // TODO: save the namespace with the constructors name
            // serialization[_object.constructor.name] = _object.serialize();
            let path = this.getFullPath(_object);
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            serialization[path] = _object.serialize();
            return serialization;
            // return _object.serialize();
        }
        /**
         * Returns a FUDGE-object reconstructed from the information in the {@link Serialization} given,
         * including attached components, children, superclass-objects
         * @param _serialization
         */
        static async deserialize(_serialization) {
            let reconstruct;
            let path;
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (path in _serialization) {
                    reconstruct = Serializer.reconstruct(path);
                    reconstruct = await reconstruct.deserialize(_serialization[path]);
                    return reconstruct;
                }
            }
            catch (_error) {
                let message = `Deserialization of ${path}, ${reconstruct ? Reflect.get(reconstruct, "idResource") : ""} failed: ` + _error;
                throw new Error(message);
            }
            return null;
        }
        /**
         * Returns an Array of javascript object representing the serializable FUDGE-objects given in the array,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serializeArray(_type, _objects) {
            let serializations = [];
            let path = this.getFullPath(new _type());
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_type.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            for (let object of _objects)
                serializations.push(object.serialize());
            let serialization = {};
            serialization[path] = serializations;
            return serialization;
        }
        /**
         * Returns an Array of FUDGE-objects reconstructed from the information in the array of {@link Serialization}s given,
         * including attached components, children, superclass-objects
         * @param _serializations
         */
        static async deserializeArray(_serialization) {
            let serializables = [];
            let construct;
            let serializations = [];
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (let path in _serialization) {
                    construct = Serializer.getConstructor(path);
                    serializations = _serialization[path];
                    break;
                }
            }
            catch (_error) {
                throw new Error("Deserialization failed: " + _error);
            }
            for (let serialization of serializations) {
                let serializable = new construct();
                await serializable.deserialize(serialization);
                serializables.push(serializable);
            }
            return serializables;
        }
        //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
        /**
         * Prettify a JSON-String, to make it more readable.
         * not implemented yet
         */
        static prettify(_json) { return _json; }
        /**
         * Returns a formatted, human readable JSON-String, representing the given {@link Serialization} that may have been created by {@link Serializer}.serialize
         * @param _serialization
         */
        static stringify(_serialization) {
            // adjustments to serialization can be made here before stringification, if desired
            let json = JSON.stringify(_serialization, null, 2);
            let pretty = Serializer.prettify(json);
            return pretty;
        }
        /**
         * Returns a {@link Serialization} created from the given JSON-String. Result may be passed to {@link Serializer.deserialize}
         * @param _json
         */
        static parse(_json) {
            return JSON.parse(_json);
        }
        /**
         * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
         * @param _path
         */
        static reconstruct(_path) {
            let constructor = Serializer.getConstructor(_path);
            let reconstruction = new constructor();
            return reconstruction;
        }
        // public static getConstructor<T extends Serializable>(_type: string, _namespace: Object = FudgeCore): new () => T {
        /**
         * Returns the constructor from the given path to a class
         */
        static getConstructor(_path) {
            let typeName = _path.substring(_path.lastIndexOf(".") + 1);
            let namespace = Serializer.getNamespace(_path);
            if (!namespace)
                throw new Error(`Constructor of serializable object of type ${_path} not found. Maybe the namespace hasn't been registered?`);
            return namespace[typeName];
        }
        /**
         * Returns the full path to the class of the object, if found in the registered namespaces
         * @param _object
         */
        static getFullPath(_object) {
            let typeName = _object.constructor.name;
            // Debug.log("Searching namespace of: " + typeName);
            for (let namespaceName in Serializer.namespaces) {
                let found = Serializer.namespaces[namespaceName][typeName];
                if (found && _object instanceof found)
                    return namespaceName + "." + typeName;
            }
            return null;
        }
        /**
         * Returns the namespace-object defined within the full path, if registered
         * @param _path
         */
        static getNamespace(_path) {
            let namespaceName = _path.substr(0, _path.lastIndexOf("."));
            return Serializer.namespaces[namespaceName] || FudgeCore;
        }
        /**
         * Finds the namespace-object in properties of the parent-object (e.g. window), if present
         * @param _namespace
         * @param _parent
         */
        static findNamespaceIn(_namespace, _parent) {
            for (let prop in _parent)
                if (_parent[prop] == _namespace)
                    return prop;
            return null;
        }
    }
    FudgeCore.Serializer = Serializer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Graph
     */
    class Node extends FudgeCore.EventTargetUnified {
        #mtxWorldInverseUpdated;
        #mtxWorldInverse;
        /**
         * Creates a new node with a name and initializes all attributes
         */
        constructor(_name) {
            super();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.timestampUpdate = 0;
            /** The number of nodes of the whole branch including this node and all successors */
            this.nNodesInBranch = 0;
            /** The radius of the bounding sphere in world dimensions enclosing the geometry of this node and all successors in the branch */
            this.radius = 0;
            this.parent = null; // The parent of this node.
            this.children = []; // array of child nodes appended to this node.
            this.components = {};
            // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
            // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
            this.listeners = {};
            this.captures = {};
            this.active = true;
            /**
             * Simply calls {@link addChild}. This reference is here solely because appendChild is the equivalent method in DOM.
             * See and preferably use {@link addChild}
             */
            // eslint-disable-next-line @typescript-eslint/member-ordering
            this.appendChild = this.addChild;
            this.name = _name;
        }
        /**
         * Return the mutator path string to get from one node to another or null if no path is found e.g.:
         * ```typescript
         * "node/parent/children/1/components/ComponentSkeleton/0"
         * ```
         */
        static PATH_FROM_TO(_from, _to) {
            const from = _from instanceof FudgeCore.Component ? _from.node : _from;
            const to = _to instanceof FudgeCore.Component ? _to.node : _to;
            if (!from || !to)
                return null;
            // find paths to lowest common ancestor
            let pathFrom = from.getPath();
            let pathTo = to.getPath();
            let ancestor = null;
            while (pathFrom.length && pathTo.length && pathFrom[0] == pathTo[0]) {
                ancestor = pathFrom.shift();
                pathTo.shift();
            }
            pathTo.unshift(ancestor);
            if (!ancestor)
                return null;
            // create relative path
            let pathToAncestor = pathFrom.map(_node => "parent"); // TODO: use "keyof Node" as type
            let pathFromAncestor = pathTo
                .flatMap((_node, _index, _array) => ["children", _node.findChild(_array[_index + 1]).toString()])
                .slice(0, -2);
            if (_from instanceof FudgeCore.Component)
                pathToAncestor.unshift("node");
            if (_to instanceof FudgeCore.Component)
                pathFromAncestor.push("components", _to.type, to.components[_to.type].indexOf(_to).toString());
            return pathToAncestor.concat(pathFromAncestor).join("/"); // TODO: or maybe validate this string with node and component objects?
        }
        /**
         * Return the {@link Node} or {@link Component} found at the given path starting from the given node or undefined if not found
         */
        static FIND(_from, _path) {
            let path = _path.split("/");
            let to = _from;
            while (path.length && to)
                to = Reflect.get(to, path.shift());
            return to;
        }
        get isActive() {
            return this.active;
        }
        /**
         * Shortcut to retrieve this nodes {@link ComponentTransform}
         */
        get cmpTransform() {
            return this.getComponents(FudgeCore.ComponentTransform)?.[0];
        }
        /**
         * Shortcut to retrieve the local {@link Matrix4x4} attached to this nodes {@link ComponentTransform}
         * Fails if no {@link ComponentTransform} is attached
         */
        get mtxLocal() {
            return this.cmpTransform?.mtxLocal;
        }
        get mtxWorldInverse() {
            if (this.#mtxWorldInverseUpdated != this.timestampUpdate)
                this.#mtxWorldInverse = FudgeCore.Matrix4x4.INVERSION(this.mtxWorld);
            this.#mtxWorldInverseUpdated = this.timestampUpdate;
            return this.#mtxWorldInverse;
        }
        /**
         * Returns the number of children attached to this
         */
        get nChildren() {
            return this.children.length;
        }
        /**
         * Generator yielding the node and all decendants in the graph below for iteration
         * Inactive nodes and their descendants can be filtered
         */
        *getIterator(_active = false) {
            if (!_active || this.isActive) {
                yield this;
                for (let child of this.children)
                    yield* child.getIterator(_active);
            }
        }
        /**
         * Returns an iterator over this node and all its descendants in the graph below
         */
        [Symbol.iterator]() {
            return this.getIterator();
        }
        /**
         * De- / Activate this node. Inactive nodes will not be processed by the renderer.
         */
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "nodeActivate" /* EVENT.NODE_ACTIVATE */ : "nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, { bubbles: true }));
            this.broadcastEvent(new Event(_on ? "nodeActivate" /* EVENT.NODE_ACTIVATE */ : "nodeDeactivate" /* EVENT.NODE_DEACTIVATE */));
        }
        // #region Scenetree
        /**
         * Returns a reference to this nodes parent node
         */
        getParent() {
            return this.parent;
        }
        /**
         * Traces back the ancestors of this node and returns the first
         */
        getAncestor() {
            let ancestor = this;
            while (ancestor.getParent())
                ancestor = ancestor.getParent();
            return ancestor;
        }
        /**
         * Traces the hierarchy upwards to the first ancestor and returns the path through the graph to this node
         */
        getPath() {
            let ancestor = this;
            let path = [this];
            while (ancestor.getParent())
                path.unshift(ancestor = ancestor.getParent());
            return path;
        }
        /**
         * Returns child at the given index in the list of children
         */
        getChild(_index) {
            return this.children[_index];
        }
        /**
         * Returns a clone of the list of children
         */
        getChildren() {
            return this.children.slice(0);
        }
        /**
         * Returns an array of references to childnodes with the supplied name.
         */
        getChildrenByName(_name) {
            let found = [];
            found = this.children.filter((_node) => _node.name == _name);
            return found;
        }
        /**
         * Adds the given reference to a node to the list of children, if not already in
         * @throws Error when trying to add an ancestor of this
         */
        addChild(_child) {
            if (this.children.includes(_child))
                // _node is already a child of this
                return;
            let inAudioGraph = false;
            let graphListened = FudgeCore.AudioManager.default.getGraphListeningTo();
            let ancestor = this;
            while (ancestor) {
                ancestor.timestampUpdate = 0;
                inAudioGraph = inAudioGraph || (ancestor == graphListened);
                if (ancestor == _child)
                    throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                else
                    ancestor = ancestor.parent;
            }
            let previousParent = _child.parent;
            if (previousParent)
                previousParent.removeChild(_child);
            this.children.push(_child);
            _child.parent = this;
            _child.dispatchEvent(new Event("childAppend" /* EVENT.CHILD_APPEND */, { bubbles: true }));
            if (inAudioGraph)
                _child.broadcastEvent(new Event("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */));
        }
        /**
         * Removes the reference to the give node from the list of children
         */
        removeChild(_child) {
            let found = this.findChild(_child);
            if (found < 0)
                return;
            _child.dispatchEvent(new Event("childRemove" /* EVENT.CHILD_REMOVE */, { bubbles: true }));
            _child.broadcastEvent(new Event("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _child.broadcastEvent(new Event("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */));
            this.children.splice(found, 1);
            _child.parent = null;
        }
        /**
         * Removes all references in the list of children
         */
        removeAllChildren() {
            while (this.children.length)
                this.removeChild(this.children[0]);
        }
        /**
         * Returns the position of the node in the list of children or -1 if not found
         */
        findChild(_search) {
            return this.children.indexOf(_search);
        }
        /**
         * Replaces a child node with another, preserving the position in the list of children
         */
        replaceChild(_replace, _with) {
            let found = this.findChild(_replace);
            if (found < 0)
                return false;
            let previousParent = _with.getParent();
            if (previousParent)
                previousParent.removeChild(_with);
            _replace.parent = null;
            this.children[found] = _with;
            _with.parent = this;
            _with.dispatchEvent(new Event("childAppend" /* EVENT.CHILD_APPEND */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _with.broadcastEvent(new Event("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */));
            return true;
        }
        /**
         * Returns true if the given timestamp matches the last update timestamp this node underwent, else false
         */
        isUpdated(_timestampUpdate) {
            return (this.timestampUpdate == _timestampUpdate);
        }
        /**
         * Returns true if this node is a descendant of the given node, directly or indirectly, else false
         */
        isDescendantOf(_ancestor) {
            let node = this;
            while (node && node != _ancestor)
                node = node.parent;
            return (node != null);
        }
        /**
         * Applies a Mutator from {@link Animation} to all its components and transfers it to its children.
         */
        applyAnimation(_mutator) {
            if ("components" in _mutator) {
                for (const componentType in _mutator.components) {
                    let componentsOfType = this.components[componentType]; // TODO: add errors if node doesn't contain property
                    let mutatorsForType = _mutator.components[componentType];
                    if (componentsOfType != undefined && mutatorsForType != undefined) {
                        for (const i in mutatorsForType) {
                            componentsOfType[i].mutate(mutatorsForType[i], null, false);
                        }
                    }
                }
            }
            if ("children" in _mutator) {
                for (const childName in _mutator.children) {
                    for (const childNode of this.getChildrenByName(childName)) {
                        childNode.applyAnimation(_mutator.children[childName]);
                    }
                }
            }
        }
        // #endregion
        // #region Components
        /**
         * Returns a list of all components attached to this node, independent of type.
         */
        getAllComponents() {
            let all = [];
            for (let type in this.components) {
                all = all.concat(this.components[type]);
            }
            return all;
        }
        /**
         * Returns a clone of the list of components of the given class attached to this node.
         */
        getComponents(_class) {
            return (this.components[_class.name] || []).slice(0);
        }
        /**
         * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
         */
        getComponent(_class) {
            let list = this.components[_class.name];
            if (list)
                return list[0];
            return null;
        }
        /**
         * Attach the given component to this node. Identical to {@link addComponent}
         */
        attach(_component) {
            this.addComponent(_component);
        }
        /**
         * Attach the given component to this node
         */
        addComponent(_component) {
            if (_component.node == this)
                return;
            let cmpList = this.components[_component.type];
            if (cmpList === undefined)
                this.components[_component.type] = [_component];
            else if (cmpList.length && _component.isSingleton)
                throw new Error(`Component ${_component.type} is marked singleton and can't be attached, no more than one allowed`);
            else
                cmpList.push(_component);
            _component.attachToNode(this);
            _component.dispatchEvent(new Event("componentAdd" /* EVENT.COMPONENT_ADD */));
            this.dispatchEventToTargetOnly(new CustomEvent("componentAdd" /* EVENT.COMPONENT_ADD */, { detail: _component })); // TODO: see if this is be feasable
        }
        /**
         * Detach the given component from this node. Identical to {@link removeComponent}
         */
        detach(_component) {
            this.removeComponent(_component);
        }
        /**
         * Removes the given component from the node, if it was attached, and sets its parent to null.
         */
        removeComponent(_component) {
            try {
                let componentsOfType = this.components[_component.type];
                let foundAt = componentsOfType.indexOf(_component);
                if (foundAt < 0)
                    return;
                _component.dispatchEvent(new Event("componentRemove" /* EVENT.COMPONENT_REMOVE */));
                this.dispatchEventToTargetOnly(new CustomEvent("componentRemove" /* EVENT.COMPONENT_REMOVE */, { detail: _component })); // TODO: see if this would be feasable
                componentsOfType.splice(foundAt, 1);
                _component.attachToNode(null);
            }
            catch (_error) {
                throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
            }
        }
        // #endregion
        // #region Serialization
        serialize() {
            let serialization = {
                name: this.name,
                active: this.active
            };
            let components = {};
            for (let type in this.components) {
                components[type] = [];
                for (let component of this.components[type]) {
                    // components[type].push(component.serialize());
                    components[type].push(FudgeCore.Serializer.serialize(component));
                }
            }
            serialization["components"] = components;
            let children = [];
            for (let child of this.children) {
                children.push(FudgeCore.Serializer.serialize(child));
            }
            serialization["children"] = children;
            this.dispatchEvent(new Event("nodeSerialized" /* EVENT.NODE_SERIALIZED */));
            return serialization;
        }
        async deserialize(_serialization) {
            this.name = _serialization.name;
            // this.parent = is set when the nodes are added
            // deserialize components first so scripts can react to children being appended
            for (let type in _serialization.components) {
                for (let serializedComponent of _serialization.components[type]) {
                    let deserializedComponent = await FudgeCore.Serializer.deserialize(serializedComponent);
                    this.addComponent(deserializedComponent);
                }
            }
            if (_serialization.children)
                for (let serializedChild of _serialization.children) {
                    let deserializedChild = await FudgeCore.Serializer.deserialize(serializedChild);
                    this.appendChild(deserializedChild);
                }
            this.dispatchEvent(new Event("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */));
            for (let component of this.getAllComponents())
                component.dispatchEvent(new Event("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */));
            // TODO: consider if this is a good idea
            // const hndGraphDeserialized: EventListenerUnified = () => {
            //   for (let component of this.getAllComponents())
            //     component.dispatchEvent(new Event(EVENT.GRAPH_DESERIALIZED, { bubbles: false }));
            //   this.removeEventListener(EVENT.GRAPH_DESERIALIZED, hndGraphDeserialized, true);
            //   this.removeEventListener(EVENT.GRAPH_INSTANTIATED, hndGraphDeserialized, true);
            // };
            // this.addEventListener(EVENT.GRAPH_DESERIALIZED, hndGraphDeserialized, true);
            // this.addEventListener(EVENT.GRAPH_INSTANTIATED, hndGraphDeserialized, true);
            this.activate(_serialization.active);
            return this;
        }
        // #endregion
        /**
         * Creates a string as representation of this node and its descendants
         */
        toHierarchyString(_node = null, _level = 0) {
            // TODO: refactor for better readability
            if (!_node)
                _node = this;
            let prefix = "+".repeat(_level);
            let output = prefix + " " + _node.name + " | ";
            for (let type in _node.components)
                output += _node.components[type].length + " " + type.split("Component").pop() + ", ";
            output = output.slice(0, -2) + "</br>";
            for (let child of _node.children) {
                output += this.toHierarchyString(child, _level + 1);
            }
            return output;
        }
        // #region Events
        /**
         * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
         * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
         */
        addEventListener(_type, _handler, _capture = false) {
            let listListeners = _capture ? this.captures : this.listeners;
            if (!listListeners[_type])
                listListeners[_type] = [];
            listListeners[_type].push(_handler);
        }
        /**
         * Removes an event listener from the node. The signature must match the one used with addEventListener
         */
        removeEventListener(_type, _handler, _capture = false) {
            let listenersForType = _capture ? this.captures[_type] : this.listeners[_type];
            if (listenersForType)
                for (let i = listenersForType.length - 1; i >= 0; i--)
                    if (listenersForType[i] == _handler)
                        listenersForType.splice(i, 1);
        }
        /**
         * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
         * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
         * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
         */
        dispatchEvent(_event) {
            let ancestors = [];
            let upcoming = this;
            // overwrite event target
            Object.defineProperty(_event, "target", { writable: true, value: this });
            // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
            while (upcoming.parent)
                ancestors.push(upcoming = upcoming.parent);
            Object.defineProperty(_event, "path", { writable: true, value: new Array(this, ...ancestors) });
            // capture phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            for (let i = ancestors.length - 1; i >= 0; i--) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                this.callListeners(ancestor.captures[_event.type], _event);
            }
            // target phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            this.callListeners(this.captures[_event.type], _event);
            this.callListeners(this.listeners[_event.type], _event);
            if (!_event.bubbles)
                return true;
            // bubble phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
            for (let i = 0; i < ancestors.length; i++) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                this.callListeners(ancestor.listeners[_event.type], _event);
            }
            return true; //TODO: return a meaningful value, see documentation of dispatch event
        }
        /**
         * Dispatches a synthetic event to target without travelling through the graph hierarchy neither during capture nor bubbling phase
         */
        dispatchEventToTargetOnly(_event) {
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            this.callListeners(this.listeners[_event.type], _event); // TODO: examine if this should go to the captures instead of the listeners
            return true;
        }
        /**
         * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
         * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
         */
        broadcastEvent(_event) {
            // overwrite event target and phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            Object.defineProperty(_event, "target", { writable: true, value: this });
            this.broadcastEventRecursive(_event);
        }
        broadcastEventRecursive(_event) {
            // capture phase only
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let captures = this.captures[_event.type] || [];
            for (let handler of captures)
                // @ts-ignore
                handler(_event);
            // appears to be slower, astonishingly...
            // captures.forEach(function (handler: Function): void {
            //     handler(_event);
            // });
            // same for children
            for (let child of this.children) {
                child.broadcastEventRecursive(_event);
            }
        }
        callListeners(_listeners, _event) {
            if (_listeners?.length > 0)
                for (let handler of _listeners)
                    // @ts-ignore
                    handler(_event);
        }
    }
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all {@link Component}s that can be attached to {@link Node}s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karag√∂l, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class Component extends FudgeCore.Mutable {
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Component; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        #node;
        constructor() {
            super();
            this.singleton = true;
            this.active = true;
            this.#node = null;
            this.addEventListener("mutate" /* EVENT.MUTATE */, (_event) => {
                if (this.#node) {
                    // TODO: find the number of the component in the array if not singleton
                    _event.detail.component = this;
                    //@ts-ignore
                    _event.detail.componentIndex = this.node.getComponents(this.constructor).indexOf(this);
                    this.#node.dispatchEvent(_event);
                }
            });
        }
        static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
        get isActive() {
            return this.active;
        }
        /**
         * Is true, when only one instance of the component class can be attached to a node
         */
        get isSingleton() {
            return this.singleton;
        }
        /**
         * Retrieves the node, this component is currently attached to
         */
        get node() {
            return this.#node;
        }
        /**
         * De- / Activate this component. Inactive components will not be processed by the renderer.
         */
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* EVENT.COMPONENT_ACTIVATE */ : "componentDeactivate" /* EVENT.COMPONENT_DEACTIVATE */));
        }
        /**
         * Tries to attach the component to the given node, removing it from the node it was attached to if applicable
         */
        attachToNode(_container) {
            if (this.#node == _container)
                return;
            let previousContainer = this.#node;
            try {
                if (previousContainer)
                    previousContainer.removeComponent(this);
                this.#node = _container;
                if (this.#node)
                    this.#node.addComponent(this);
            }
            catch (_error) {
                this.#node = previousContainer;
            }
        }
        //#region Transfer
        serialize() {
            let serialization = {
                active: this.active
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.activate(_serialization.active);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            if (typeof (_mutator.active) !== "undefined")
                this.activate(_mutator.active);
        }
        reduceMutator(_mutator) {
            delete _mutator.singleton;
            delete _mutator.mtxWorld;
        }
    }
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Wraps a regular Javascript Array and offers very limited functionality geared solely towards avoiding garbage colletion.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Recycler
     */
    class RecycableArray {
        #length = 0;
        #array = new Array();
        // #type: new () => T;
        // //tslint:disable-next-line:no-any
        // constructor(_type: new (...args: any[]) => T) {
        //   this.#type = _type;
        // }
        get length() {
            return this.#length;
        }
        /**
         * Sets the virtual length of the array to zero but keeps the entries beyond.
         */
        reset() {
            this.#length = 0;
        }
        /**
         * Recycle this array
         */
        recycle() {
            this.reset();
        }
        /**
         * Appends a new entry to the end of the array, and returns the new length of the array.
         */
        push(_entry) {
            this.#array[this.#length] = _entry;
            this.#length++;
            return this.#length;
        }
        /**
         * Removes the last entry from the array and returns it.
         */
        pop() {
            this.#length--;
            return this.#array[this.#length];
        }
        /**
         * Recycles the object following the last in the array and increases the array length
         * It must be assured, that none of the objects in the array is still in any use of any kind!
         */
        // public recycle(): T {
        //   if (this.#length < this.#array.length) {
        //     this.#length++;
        //     return this.#array[this.#length++];
        //   }
        //   this.#array.push(Recycler.get(this.#type));
        //   return this.#array[this.#length++];
        // }
        *[Symbol.iterator]() {
            for (let i = 0; i < this.#length; i++)
                yield this.#array[i];
        }
        /**
         * Returns a copy of the array sorted according to the given compare function
         */
        getSorted(_sort) {
            let sorted = this.#array.slice(0, this.#length);
            sorted.sort(_sort);
            return sorted;
        }
    }
    FudgeCore.RecycableArray = RecycableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for {@link RenderInjectorCoat} and {@link RenderInjectorTexture}
     * @internal
     */
    class RenderInjector {
        /**
         * Injects the given constructor with the functionality of the given injector. Name of the constructor and the name of the injector method must match.
         * Used in subclasses of this class.
         */
        static inject(_constructor, _injector) {
            let injection = Reflect.get(_injector, "inject" + _constructor.name);
            if (!injection) {
                FudgeCore.Debug.error("No injection decorator defined for " + _constructor.name);
            }
            Object.defineProperty(_constructor.prototype, "useRenderData", {
                value: injection
            });
        }
    }
    FudgeCore.RenderInjector = RenderInjector;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Gives WebGL Buffer the data from the {@link Shader}
     * @internal
     */
    class RenderInjectorShader {
        /**
         * Injects the functionality of this class into the constructor of the given {@link Shader}-subclass
         */
        static decorate(_constructor) {
            Object.defineProperty(_constructor, "useProgram", {
                value: RenderInjectorShader.useProgram
            });
            Object.defineProperty(_constructor, "deleteProgram", {
                value: RenderInjectorShader.deleteProgram
            });
            Object.defineProperty(_constructor, "createProgram", {
                value: RenderInjectorShader.createProgram
            });
        }
        /**
         * Set this program to use as the active program in WebGL
         */
        static useProgram() {
            if (!this.program)
                this.createProgram();
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.useProgram(this.program);
        }
        /**
         * Deletes this program from WebGL, clearing the used memory on the GPU.
         */
        static deleteProgram() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.program) {
                crc3.deleteProgram(this.program);
                delete this.attributes;
                delete this.uniforms;
                delete this.program;
            }
        }
        static createProgram() {
            FudgeCore.Debug.fudge("Create shader program", this.name);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let program = crc3.createProgram();
            try {
                let shdVertex = compileShader(this.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER);
                let shdFragment = compileShader(this.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER);
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdVertex));
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdFragment));
                crc3.linkProgram(program);
                let error = FudgeCore.RenderWebGL.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                this.program = program;
                this.attributes = detectAttributes();
                this.uniforms = detectUniforms();
                if (this.define.includes("SKIN")) {
                    const blockIndex = crc3.getUniformBlockIndex(program, FudgeCore.UNIFORM_BLOCKS.SKIN.NAME);
                    crc3.uniformBlockBinding(program, blockIndex, FudgeCore.UNIFORM_BLOCKS.SKIN.BINDING);
                }
                if (this.define.includes("LIGHT")) {
                    if (!FudgeCore.RenderWebGL.uboLights)
                        FudgeCore.RenderWebGL.uboLights = createUBOLights();
                    if (!FudgeCore.RenderWebGL.uboLightsVariableOffsets)
                        FudgeCore.RenderWebGL.uboLightsVariableOffsets = detectUBOLightsVariableOffsets();
                    // bind lights UBO to shader program
                    const blockIndex = crc3.getUniformBlockIndex(program, FudgeCore.UNIFORM_BLOCKS.LIGHTS.NAME);
                    crc3.uniformBlockBinding(program, blockIndex, FudgeCore.UNIFORM_BLOCKS.LIGHTS.BINDING);
                }
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = FudgeCore.RenderWebGL.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    console.log(_shaderCode);
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectAttributes() {
                let detectedAttributes = {};
                let attributeCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < attributeCount; i++) {
                    let attributeInfo = FudgeCore.RenderWebGL.assert(crc3.getActiveAttrib(program, i));
                    if (!attributeInfo) {
                        break;
                    }
                    detectedAttributes[attributeInfo.name] = crc3.getAttribLocation(program, attributeInfo.name);
                }
                return detectedAttributes;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = FudgeCore.RenderWebGL.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    let location = crc3.getUniformLocation(program, info.name);
                    if (location)
                        detectedUniforms[info.name] = FudgeCore.RenderWebGL.assert(location);
                }
                return detectedUniforms;
            }
            function createUBOLights() {
                const blockIndex = crc3.getUniformBlockIndex(program, FudgeCore.UNIFORM_BLOCKS.LIGHTS.NAME);
                const blockSize = crc3.getActiveUniformBlockParameter(program, blockIndex, crc3.UNIFORM_BLOCK_DATA_SIZE);
                const ubo = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, ubo);
                crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, blockSize, crc3.DYNAMIC_DRAW);
                crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCKS.LIGHTS.BINDING, ubo);
                return ubo;
            }
            function detectUBOLightsVariableOffsets() {
                const uboVariableNames = [
                    "u_nLightsDirectional",
                    "u_nLightsPoint",
                    "u_nLightsSpot",
                    "u_ambient.vctColor",
                    "u_directional[0].vctColor",
                    "u_point[0].vctColor",
                    "u_spot[0].vctColor"
                ];
                const uboVariableIndices = crc3.getUniformIndices(program, uboVariableNames);
                const uboVariableOffsets = crc3.getActiveUniforms(program, uboVariableIndices, crc3.UNIFORM_OFFSET);
                const uboVariableNameToOffset = {};
                uboVariableNames.forEach((_name, _index) => uboVariableNameToOffset[_name] = uboVariableOffsets[_index]);
                return uboVariableNameToOffset;
            }
        }
    }
    FudgeCore.RenderInjectorShader = RenderInjectorShader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Gives WebGL Buffer the data from the {@link Coat}
     * @internal
     */
    class RenderInjectorCoat extends FudgeCore.RenderInjector {
        /**
         * Injects the functionality of this class into the constructor of the given {@link Coat}-subclass
         */
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorCoat);
        }
        static injectCoatColored(_shader, _cmpMaterial) {
            let uniform = _shader.uniforms["u_vctColor"];
            let color = FudgeCore.Color.MULTIPLY(this.color, _cmpMaterial.clrPrimary);
            FudgeCore.RenderWebGL.getRenderingContext().uniform4fv(uniform, color.getArray());
        }
        static injectCoatRemissive(_shader, _cmpMaterial) {
            RenderInjectorCoat.injectCoatColored.call(this, _shader, _cmpMaterial);
            let uniform;
            uniform = _shader.uniforms["u_fSpecular"];
            FudgeCore.RenderWebGL.getRenderingContext().uniform1f(uniform, this.specular);
            uniform = _shader.uniforms["u_fDiffuse"];
            FudgeCore.RenderWebGL.getRenderingContext().uniform1f(uniform, this.diffuse);
        }
        static injectCoatTextured(_shader, _cmpMaterial) {
            RenderInjectorCoat.injectCoatColored.call(this, _shader, _cmpMaterial);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            this.texture.useRenderData();
            crc3.uniform1i(_shader.uniforms["u_texture"], 0);
            crc3.uniformMatrix3fv(_shader.uniforms["u_mtxPivot"], false, _cmpMaterial.mtxPivot.get());
        }
        static injectCoatRemissiveTextured(_shader, _cmpMaterial) {
            RenderInjectorCoat.injectCoatRemissive.call(this, _shader, _cmpMaterial);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            this.texture.useRenderData();
            crc3.uniform1i(_shader.uniforms["u_texture"], 0);
            crc3.uniformMatrix3fv(_shader.uniforms["u_mtxPivot"], false, _cmpMaterial.mtxPivot.get());
        }
    }
    FudgeCore.RenderInjectorCoat = RenderInjectorCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the data from the {@link Mesh} into a WebGL Buffer
     * @internal
     */
    class RenderInjectorMesh {
        /**
         * Injects the functionality of this class into the constructor of the given {@link Mesh}-subclass
         */
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "getRenderBuffers", {
                value: RenderInjectorMesh.getRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static getRenderBuffers(_shader) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            this.renderMesh = this.renderMesh || new FudgeCore.RenderMesh(this);
            if (this.renderMesh.buffers == null)
                this.renderMesh.buffers = {
                    vertices: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.vertices),
                    indices: createBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderMesh.indices),
                    normals: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.normals),
                    textureUVs: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.textureUVs),
                    colors: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.colors),
                    nIndices: this.renderMesh.indices.length
                };
            return this.renderMesh.buffers;
            function createBuffer(_type, _array) {
                let buffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(_type, buffer);
                crc3.bufferData(_type, _array, WebGL2RenderingContext.STATIC_DRAW);
                return buffer;
            }
        }
        static useRenderBuffers(_shader, _mtxMeshToWorld, _mtxMeshToView, _id) {
            let renderBuffers = this.getRenderBuffers(_shader);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            function setBuffer(_name, _buffer, _size) {
                let attribute = _shader.attributes[_name];
                if (attribute == undefined)
                    return;
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, _buffer);
                crc3.enableVertexAttribArray(attribute);
                FudgeCore.RenderWebGL.setAttributeStructure(attribute, { size: _size, dataType: WebGL2RenderingContext.FLOAT, normalize: false, stride: 0, offset: 0 });
            }
            let uniform;
            uniform = _shader.uniforms["u_mtxMeshToView"];
            crc3.uniformMatrix4fv(uniform, false, _mtxMeshToView.get());
            uniform = _shader.uniforms["u_mtxMeshToWorld"];
            if (uniform)
                crc3.uniformMatrix4fv(uniform, false, _mtxMeshToWorld.get());
            uniform = _shader.uniforms["u_mtxNormalMeshToWorld"];
            if (uniform) {
                let normalMatrix = FudgeCore.Matrix4x4.TRANSPOSE(FudgeCore.Matrix4x4.INVERSION(_mtxMeshToWorld));
                crc3.uniformMatrix4fv(uniform, false, normalMatrix.get());
            }
            setBuffer("a_vctPosition", renderBuffers.vertices, 3);
            setBuffer("a_vctNormal", renderBuffers.normals, 3);
            setBuffer("a_vctColor", renderBuffers.colors, 4);
            // feed in texture coordinates if shader accepts a_vctTexture
            let attribute = _shader.attributes["a_vctTexture"];
            if (attribute) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.textureUVs);
                crc3.enableVertexAttribArray(attribute); // enable the buffer
                crc3.vertexAttribPointer(attribute, 2, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            // feed in an id of the node if shader accepts u_id. Used for picking
            uniform = _shader.uniforms["u_id"];
            if (uniform)
                FudgeCore.RenderWebGL.getRenderingContext().uniform1i(uniform, _id);
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, renderBuffers.indices);
            return renderBuffers;
        }
        static deleteRenderBuffers(_renderBuffers) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_renderBuffers) {
                // TODO: cleanup all buffers, flat/normals is missing...
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.vertices);
                crc3.deleteBuffer(_renderBuffers.textureUVs);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.indices);
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let ParticleData;
    (function (ParticleData) {
        let FUNCTION;
        (function (FUNCTION) {
            // VALUE = "value",
            FUNCTION["ADDITION"] = "addition";
            FUNCTION["SUBTRACTION"] = "subtraction";
            FUNCTION["MULTIPLICATION"] = "multiplication";
            FUNCTION["DIVISION"] = "division";
            FUNCTION["MODULO"] = "modulo";
            FUNCTION["POWER"] = "power";
            FUNCTION["POLYNOMIAL3"] = "polynomial3";
            FUNCTION["SQUARE_ROOT"] = "squareRoot";
            FUNCTION["RANDOM"] = "random";
            FUNCTION["RANDOM_RANGE"] = "randomRange";
        })(FUNCTION = ParticleData.FUNCTION || (ParticleData.FUNCTION = {}));
        ParticleData.FUNCTION_MINIMUM_PARAMETERS = {
            // [ParticleData.FUNCTION.VALUE]: 1,
            [ParticleData.FUNCTION.ADDITION]: 2,
            [ParticleData.FUNCTION.SUBTRACTION]: 2,
            [ParticleData.FUNCTION.MULTIPLICATION]: 2,
            [ParticleData.FUNCTION.DIVISION]: 2,
            [ParticleData.FUNCTION.MODULO]: 2,
            [ParticleData.FUNCTION.POWER]: 2,
            [ParticleData.FUNCTION.POLYNOMIAL3]: 5,
            [ParticleData.FUNCTION.SQUARE_ROOT]: 1,
            [ParticleData.FUNCTION.RANDOM]: 1,
            [ParticleData.FUNCTION.RANDOM_RANGE]: 3
        };
        ParticleData.PREDEFINED_VARIABLES = {
            systemDuration: "u_fParticleSystemDuration",
            systemSize: "u_fParticleSystemSize",
            systemTime: "u_fParticleSystemTime",
            particleId: "fParticleId"
        };
    })(ParticleData = FudgeCore.ParticleData || (FudgeCore.ParticleData = {}));
    /**
     * Compiles particle system shaders ({@link ShaderParticleSystem}) from shader universal derivates for WebGL
     * @authors Jonas Plotzky, HFU, 2022
     * @internal
     */
    class RenderInjectorShaderParticleSystem extends FudgeCore.RenderInjectorShader {
        static { this.FUNCTIONS = {
            // [ParticleData.FUNCTION.VALUE]: (_parameters: string[]) => {
            //   return `(${_parameters[0]})`;
            // },
            [ParticleData.FUNCTION.ADDITION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} + ${_value}`)})`;
            },
            [ParticleData.FUNCTION.SUBTRACTION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} - ${_value}`)})`;
            },
            [ParticleData.FUNCTION.MULTIPLICATION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} * ${_value}`)})`;
            },
            [ParticleData.FUNCTION.DIVISION]: (_parameters) => {
                return `(${_parameters[0]} / ${_parameters[1]})`;
            },
            [ParticleData.FUNCTION.MODULO]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `mod(${_accumulator}, ${_value})`)})`;
            },
            [ParticleData.FUNCTION.POWER]: (_parameters) => {
                return `pow(${_parameters[0]}, ${_parameters[1]})`;
            },
            [ParticleData.FUNCTION.POLYNOMIAL3]: (_parameters) => {
                let x = _parameters[0];
                let a = _parameters[1];
                let b = _parameters[2];
                let c = _parameters[3];
                let d = _parameters[4];
                return `(${a} * pow(${x}, 3.0) + ${b} * pow(${x}, 2.0) + ${c} * ${x} + ${d})`;
            },
            [ParticleData.FUNCTION.SQUARE_ROOT]: (_parameters) => {
                let x = _parameters[0];
                return `sqrt(${x})`;
            },
            [ParticleData.FUNCTION.RANDOM]: (_parameters) => {
                return `fetchRandomNumber(int(${_parameters[0]}), iParticleSystemRandomNumbersSize, iParticleSystemRandomNumbersLength)`;
            },
            [ParticleData.FUNCTION.RANDOM_RANGE]: (_parameters) => {
                return `(${RenderInjectorShaderParticleSystem.FUNCTIONS["random"](_parameters)} * (${_parameters[2]} - ${_parameters[1]}) + ${_parameters[1]})`;
            }
        }; }
        static decorate(_constructor) {
            super.decorate(_constructor.prototype);
            Object.defineProperty(_constructor.prototype, "getVertexShaderSource", {
                value: RenderInjectorShaderParticleSystem.getVertexShaderSource
            });
            Object.defineProperty(_constructor.prototype, "getFragmentShaderSource", {
                value: RenderInjectorShaderParticleSystem.getFragmentShaderSource
            });
        }
        /**
         * Generates the source code for the vertex shader of the {@link ShaderParticleSystem} from the set {@link ShaderParticleSystem.data} and the original {@link ShaderParticleSystem.vertexShaderSource}.
         */
        static getVertexShaderSource() {
            let data = this.data;
            let mtxLocal = data?.mtxLocal;
            let mtxWorld = data?.mtxWorld;
            let source = this.vertexShaderSource
                .replace("#version 300 es", `#version 300 es\n#define ${this.define[0]}${data.color ? "\n#define PARTICLE_COLOR" : ""}`)
                .replace("/*$variables*/", RenderInjectorShaderParticleSystem.generateVariables(data?.variables, data?.variableNames))
                .replace("/*$mtxLocal*/", RenderInjectorShaderParticleSystem.generateTransformations(mtxLocal, "Local"))
                .replace("/*$mtxLocal*/", mtxLocal && mtxLocal.length > 0 ? "* mtxLocal" : "")
                .replace("/*$mtxWorld*/", RenderInjectorShaderParticleSystem.generateTransformations(mtxWorld, "World"))
                .replace("/*$mtxWorld*/", mtxWorld && mtxWorld.length > 0 ? "mtxWorld *" : "")
                .replaceAll("/*$color*/", RenderInjectorShaderParticleSystem.generateColor(data?.color));
            return source;
        }
        /**
         * Generates the source code for the fragment shader of the {@link ShaderParticleSystem} from the set {@link ShaderParticleSystem.data} and the original {@link ShaderParticleSystem.fragmentShaderSource}.
         */
        static getFragmentShaderSource() {
            return this.fragmentShaderSource.replace("#version 300 es", `#version 300 es${this.data.color ? "\n#define PARTICLE_COLOR" : ""}`);
        }
        //#region code generation
        static generateVariables(_variables, _variableNames) {
            if (!_variables)
                return "";
            return _variables
                .map((_variable, _index) => ({ name: "fParticleSystemVariable_" + _variableNames[_index], value: RenderInjectorShaderParticleSystem.generateExpression(_variable) }))
                .map(_variable => `float ${_variable.name} = ${_variable.value};`)
                .reduce((_accumulator, _code) => `${_accumulator}\n${_code}`, "");
        }
        static generateTransformations(_transformations, _localOrWorld) {
            if (!_transformations || _transformations.length == 0)
                return "";
            let transformations = _transformations
                .map(_data => {
                let isScale = _data.transformation === "scale";
                let [x, y, z] = [_data.parameters[0], _data.parameters[1], _data.parameters[2]]
                    .map((_value) => _value ? RenderInjectorShaderParticleSystem.generateExpression(_value) : (isScale ? "1.0" : "0.0"));
                return [_data.transformation, x, y, z];
            });
            let code = "";
            code += transformations
                .map(([_transformation, _x, _y, _z], _index) => {
                let rotateId = _index + _localOrWorld;
                if (_transformation == "rotate") {
                    let toRadians = (_value) => `${_value} * ${FudgeCore.Calc.deg2rad}`;
                    return `float fXRadians${rotateId} = ${toRadians(_x)};
              float fYRadians${rotateId} = ${toRadians(_y)};
              float fZRadians${rotateId} = ${toRadians(_z)};
              float fSinX${rotateId} = sin(fXRadians${rotateId});
              float fCosX${rotateId} = cos(fXRadians${rotateId}); 
              float fSinY${rotateId} = sin(fYRadians${rotateId});
              float fCosY${rotateId} = cos(fYRadians${rotateId});
              float fSinZ${rotateId} = sin(fZRadians${rotateId});
              float fCosZ${rotateId} = cos(fZRadians${rotateId});\n`;
                }
                else
                    return "";
            })
                .filter((_transformation) => _transformation != "")
                .reduce((_accumulator, _code) => `${_accumulator}\n${_code}`, "");
            code += "\n";
            code += `mat4 mtx${_localOrWorld} = `;
            code += transformations
                .map(([_transformation, _x, _y, _z], _index) => {
                let rotateId = _index + _localOrWorld;
                switch (_transformation) {
                    case "translate":
                        return `mat4(
              1.0, 0.0, 0.0, 0.0,
              0.0, 1.0, 0.0, 0.0,
              0.0, 0.0, 1.0, 0.0,
              ${_x}, ${_y}, ${_z}, 1.0)`;
                    case "rotate":
                        return `mat4(
              fCosZ${rotateId} * fCosY${rotateId}, fSinZ${rotateId} * fCosY${rotateId}, -fSinY${rotateId}, 0.0,
              fCosZ${rotateId} * fSinY${rotateId} * fSinX${rotateId} - fSinZ${rotateId} * fCosX${rotateId}, fSinZ${rotateId} * fSinY${rotateId} * fSinX${rotateId} + fCosZ${rotateId} * fCosX${rotateId}, fCosY${rotateId} * fSinX${rotateId}, 0.0,
              fCosZ${rotateId} * fSinY${rotateId} * fCosX${rotateId} + fSinZ${rotateId} * fSinX${rotateId}, fSinZ${rotateId} * fSinY${rotateId} * fCosX${rotateId} - fCosZ${rotateId} * fSinX${rotateId}, fCosY${rotateId} * fCosX${rotateId}, 0.0,
              0.0, 0.0, 0.0, 1.0
              )`;
                    case "scale":
                        return `mat4(
              ${_x}, 0.0, 0.0, 0.0,
              0.0, ${_y}, 0.0, 0.0,
              0.0, 0.0, ${_z}, 0.0,
              0.0, 0.0, 0.0, 1.0
              )`;
                    default:
                        throw `Error in ${FudgeCore.ParticleSystem.name}: "${_transformation}" is not a transformation`;
                }
            })
                .reduce((_accumulator, _code) => `${_accumulator} * \n${_code}`);
            code += ";\n";
            return code;
        }
        static generateColor(_color) {
            if (!_color)
                return "";
            let rgba = [_color[0], _color[1], _color[2], _color[3]]
                .map((_value) => _value ? RenderInjectorShaderParticleSystem.generateExpression(_value) : "1.0")
                .join(", ");
            return `vec4(${rgba});`;
        }
        static generateExpression(_expression) {
            if (ParticleData.isFunction(_expression)) {
                let parameters = [];
                for (let param of _expression.parameters) {
                    parameters.push(RenderInjectorShaderParticleSystem.generateExpression(param));
                }
                return RenderInjectorShaderParticleSystem.generateFunction(_expression.function, parameters);
            }
            if (ParticleData.isVariable(_expression)) {
                return ParticleData.PREDEFINED_VARIABLES[_expression.value] || "fParticleSystemVariable_" + _expression.value;
            }
            if (ParticleData.isConstant(_expression)) {
                let value = _expression.value.toString();
                return `${value}${value.includes(".") ? "" : ".0"}`;
            }
            if (ParticleData.isCode(_expression)) {
                let code = _expression.code
                    .replaceAll(/\b[a-zA-z]+\w*(?!\()\b/g, (_match) => ParticleData.PREDEFINED_VARIABLES[_match] || "fParticleSystemVariable_" + _match)
                    .replaceAll(/(?<!\.)\b\d+\b(?!\.)/g, (_match) => _match + ".0");
                code = RenderInjectorShaderParticleSystem.replaceFunctions(code);
                return code;
            }
            throw `Error in ${FudgeCore.ParticleSystem.name}: invalid node structure in particle system serialization`;
        }
        static generateFunction(_function, _parameters) {
            if (_parameters.length < ParticleData.FUNCTION_MINIMUM_PARAMETERS[_function])
                throw `Error in ${FudgeCore.ParticleSystem.name}: "${_function}" needs at least ${ParticleData.FUNCTION_MINIMUM_PARAMETERS[_function]} parameters`;
            if (Object.values(ParticleData.FUNCTION).includes(_function))
                return RenderInjectorShaderParticleSystem.FUNCTIONS[_function](_parameters);
            else
                throw `Error in ${FudgeCore.ParticleSystem.name}: "${_function}" is not an operation`;
        }
        static replaceFunctions(_code) {
            let functionRegex = /\b[a-zA-z_]+\w*\(/g;
            let match;
            while ((match = functionRegex.exec(_code)) != null) {
                let functionGenerator = RenderInjectorShaderParticleSystem.FUNCTIONS[match[0].slice(0, -1)];
                if (!functionGenerator)
                    continue;
                let commaIndices = [];
                let openBrackets = 1;
                let argumentsLastIndex = functionRegex.lastIndex;
                while (openBrackets > 0) {
                    switch (_code[argumentsLastIndex]) {
                        case "(":
                            openBrackets++;
                            break;
                        case ")":
                            openBrackets--;
                            break;
                        case ",":
                            if (openBrackets == 1)
                                commaIndices.push(argumentsLastIndex);
                            break;
                    }
                    argumentsLastIndex++;
                }
                let args = [functionRegex.lastIndex - 1, ...commaIndices, argumentsLastIndex - 1].reduce((_accumulator, _position, _index, _positions) => {
                    return _index == _positions.length - 1 ?
                        _accumulator :
                        _accumulator.concat(_code.slice(_position + 1, _positions[_index + 1]).trim());
                }, []);
                functionRegex.lastIndex = match.index;
                _code = `${_code.slice(0, match.index)}(${functionGenerator(args)})${_code.slice(argumentsLastIndex)}`;
            }
            return _code;
        }
    }
    FudgeCore.RenderInjectorShaderParticleSystem = RenderInjectorShaderParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the random number data for the particle system ({@link ComponentParticleSystem}) into a WebGL Texture
     * @authors Jonas Plotzky, HFU, 2022
     * @internal
     */
    class RenderInjectorComponentParticleSystem {
        /**
         * Injects the functionality of this class into the constructor of the {@link ComponentParticleSystem}
         */
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderData", {
                value: RenderInjectorComponentParticleSystem.useRenderData
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderData", {
                value: RenderInjectorComponentParticleSystem.deleteRenderData
            });
        }
        static useRenderData() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE1); // ATTENTION!: changing this id requires changing of corresponding id in particle render method, use ctrl + shift + f search!
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData);
            }
            else {
                const texture = FudgeCore.Render.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                let textureSize = Math.ceil(Math.sqrt(this.size));
                textureSize = Math.min(textureSize, crc3.getParameter(crc3.MAX_TEXTURE_SIZE));
                // TODO: use internal random number generator, additionally maybe use a seed to make it possible to recreate the same random numbers
                let randomNumbers = [];
                for (let i = 0; i < textureSize * textureSize; i++)
                    randomNumbers.push(Math.random());
                try {
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.R32F, textureSize, textureSize, 0, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT, Float32Array.from(randomNumbers));
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                crc3.texParameteri(crc3.TEXTURE_2D, crc3.TEXTURE_MIN_FILTER, crc3.NEAREST);
                crc3.texParameteri(crc3.TEXTURE_2D, crc3.TEXTURE_MAG_FILTER, crc3.NEAREST);
                this.renderData = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData();
            }
        }
        static deleteRenderData() {
            if (!this.renderData)
                return;
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
            crc3.deleteTexture(this.renderData);
            delete this.renderData;
        }
    }
    FudgeCore.RenderInjectorComponentParticleSystem = RenderInjectorComponentParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using {@link Recycler} reduces load on the carbage collector and thus supports smooth performance.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Recycler
     */
    class Recycler {
        static { this.depot = {}; }
        /**
         * Fetches an object of the requested type from the depot, calls its recycle-method and returns it.
         * If the depot for that type is empty it returns a new object of the requested type
         * @param _t The class identifier of the desired object
         */
        static get(_t) {
            let key = _t.name;
            let instances = Recycler.depot[key];
            if (instances && instances.length > 0) {
                let instance = instances.pop();
                instance.recycle();
                return instance;
            }
            else
                return new _t();
        }
        /**
         * Returns a reference to an object of the requested type in the depot, but does not remove it there.
         * If no object of the requested type was in the depot, one is created, stored and borrowed.
         * For short term usage of objects in a local scope, when there will be no other call to Recycler.get or .borrow!
         * @param _t The class identifier of the desired object
         */
        static borrow(_t) {
            let t;
            let key = _t.name;
            let instances = Recycler.depot[key];
            if (!instances || instances.length == 0) {
                t = new _t();
                Recycler.store(t);
                return t;
            }
            let instance = instances[0];
            instance.recycle();
            return instance;
        }
        /**
         * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
         * @param _instance
         */
        static store(_instance) {
            let key = _instance.constructor.name;
            //Debug.log(key);
            let instances = Recycler.depot[key] || [];
            instances.push(_instance);
            Recycler.depot[key] = instances;
            // Debug.log(`ObjectManager.depot[${key}]: ${ObjectManager.depot[key].length}`);
            //Debug.log(this.depot);
        }
        /**
         * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
         * @param _t
         */
        static dump(_t) {
            let key = _t.name;
            Recycler.depot[key] = [];
        }
        /**
         * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
         */
        static dumpAll() {
            Recycler.depot = {};
        }
    }
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```text
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.data = new Float32Array([_x, _y]);
        }
        //#region Static
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(0, 0);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_scale, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(0, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_scale, 0);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         */
        static TRANSFORMATION(_vector, _mtxTransform, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector2);
            let m = _mtxTransform.get();
            let [x, y] = _vector.get();
            result.x = m[0] * x + m[3] * y;
            result.y = m[1] * x + m[4] * y;
            if (_includeTranslation) {
                result.add(_mtxTransform.translation);
            }
            return result;
        }
        /**
         * Normalizes a given vector to the given length without editing the original vector.
         * @param _vector the vector to normalize
         * @param _length the length of the resulting vector. defaults to 1
         * @returns a new vector representing the normalised vector scaled by the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let vector = Vector2.ZERO();
            try {
                let [x, y] = _vector.data;
                let factor = _length / Math.hypot(x, y);
                vector.set(_vector.x * factor, _vector.y * factor);
            }
            catch (_error) {
                FudgeCore.Debug.warn(_error);
            }
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scale) {
            let vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_vector.x * _scale, _vector.y * _scale);
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector2);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y;
            return scalarProduct;
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         * @param _a Vector to compute the cross product on
         * @param _b Vector to compute the cross product with
         * @returns A number representing result of the cross product.
         */
        static CROSS(_a, _b) {
            let crossProduct = _a.x * _b.y - _a.y * _b.x;
            return crossProduct;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```text
         * ‚Üë => ‚Üê => ‚Üì => ‚Üí => ‚Üë
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false) {
            let result = FudgeCore.Recycler.get(Vector2);
            if (_clockwise)
                result.set(_vector.y, -_vector.x);
            else
                result.set(-_vector.y, _vector.x);
            return result;
        }
        /**
         * Creates a cartesian vector from polar coordinates
         */
        static GEO(_angle = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.get(Vector2);
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.set(_angle, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        //#endregion
        //#region Accessors
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector2.DOT(this, this);
        }
        /**
         * Creates and returns a clone of this
         */
        get clone() {
            let clone = FudgeCore.Recycler.get(Vector2);
            clone.data.set(this.data);
            return clone;
        }
        /**
         * Returns a polar representation of this vector
         */
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.angle = 180 * Math.atan2(this.y / geo.magnitude, this.x / geo.magnitude) / Math.PI;
            return geo;
        }
        /**
         * Adjust the cartesian values of this vector to represent the given as polar coordinates
         */
        set geo(_geo) {
            this.set(_geo.magnitude, 0);
            this.transform(FudgeCore.Matrix3x3.ROTATION(_geo.angle));
        }
        //#endregion
        recycle() {
            this.data.set([0, 0]);
        }
        /**
         * Copies the values of the given vector into this
         */
        copy(_original) {
            this.data.set(_original.data);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Adds the given vector to the executing vector, changing the executor.
         * @param _addend The vector to add.
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y]);
        }
        /**
         * Subtracts the given vector from the executing vector, changing the executor.
         * @param _subtrahend The vector to subtract.
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y]);
        }
        /**
         * Scales the Vector by the given _scalar.
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector2.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0) {
            this.data[0] = _x;
            this.data[1] = _y;
        }
        /**
         * @returns An array of the data of the vector
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Transforms this vector by the given matrix, including or exluding the translation.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_mtxTransform, _includeTranslation = true) {
            this.data = Vector2.TRANSFORMATION(this, _mtxTransform, _includeTranslation).data;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
        }
        /**
         * Adds a z-component of the given magnitude (default=0) to the vector and returns a new Vector3
         */
        toVector3(_z = 0) {
            return new FudgeCore.Vector3(this.x, this.y, _z);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         * and return a new vector with the results
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector2);
            copy.data = this.data.map(_function);
            return copy;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
var FudgeCore;
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            let rect = FudgeCore.Recycler.get(Rectangle);
            rect.setPositionAndSize(_x, _y, _width, _height);
            return rect;
        }
        get x() {
            return this.position.x;
        }
        get y() {
            return this.position.y;
        }
        get width() {
            return this.size.x;
        }
        get height() {
            return this.size.y;
        }
        /**
         * Return the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        /**
         * Return the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        /**
         * Return the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        /**
         * Return the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set x(_x) {
            this.position.x = _x;
        }
        set y(_y) {
            this.position.y = _y;
        }
        set width(_width) {
            this.size.x = _width;
        }
        set height(_height) {
            this.size.y = _height;
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get clone() {
            return Rectangle.GET(this.x, this.y, this.width, this.height);
        }
        recycle() {
            this.setPositionAndSize();
        }
        /**
         * Set this rectangle to the values given by the rectangle provided
         */
        copy(_rect) {
            this.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
        }
        /**
         * Transforms the given point from this rectangles space to the target rectangles space
         */
        pointToRect(_point, _target) {
            let result = _point.clone;
            result.subtract(this.position);
            result.x *= _target.width / this.width;
            result.y *= _target.height / this.height;
            result.add(_target.position);
            return result;
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border
         * @param _point
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        /**
         * Returns true if this rectangle collides with the rectangle given
         * @param _rect
         */
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        /**
         * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
         */
        getIntersection(_rect) {
            if (!this.collides(_rect))
                return null;
            let intersection = new Rectangle();
            intersection.x = Math.max(this.left, _rect.left);
            intersection.y = Math.max(this.top, _rect.top);
            intersection.width = Math.min(this.right, _rect.right) - intersection.x;
            intersection.height = Math.min(this.bottom, _rect.bottom) - intersection.y;
            return intersection;
        }
        /**
     * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
     */
        covers(_rect) {
            if (this.left > _rect.left)
                return false;
            if (this.right < _rect.right)
                return false;
            if (this.top > _rect.top)
                return false;
            if (this.bottom < _rect.bottom)
                return false;
            return true;
        }
        /**
         * Creates a string representation of this rectangle
         */
        toString() {
            let result = `∆í.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}`;
            result += `, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)}`;
            return result;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="RenderInjectorShaderParticleSystem.ts"/>
///<reference path="RenderInjectorComponentParticleSystem.ts"/>
///<reference path="../Math/Rectangle.ts"/>
var FudgeCore;
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="RenderInjectorShaderParticleSystem.ts"/>
///<reference path="RenderInjectorComponentParticleSystem.ts"/>
///<reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    // export declare let fudgeConfig: General;
    let BLEND;
    (function (BLEND) {
        BLEND[BLEND["OPAQUE"] = 0] = "OPAQUE";
        BLEND[BLEND["TRANSPARENT"] = 1] = "TRANSPARENT";
        BLEND[BLEND["ADDITIVE"] = 2] = "ADDITIVE";
        BLEND[BLEND["SUBTRACTIVE"] = 3] = "SUBTRACTIVE";
        BLEND[BLEND["MODULATE"] = 4] = "MODULATE";
    })(BLEND = FudgeCore.BLEND || (FudgeCore.BLEND = {}));
    FudgeCore.UNIFORM_BLOCKS = {
        LIGHTS: {
            NAME: "Lights",
            BINDING: 0
        },
        SKIN: {
            NAME: "Skin",
            BINDING: 1
        }
    };
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through {@link Render}
     */
    class RenderWebGL extends FudgeCore.EventTargetStatic {
        static { this.crc3 = RenderWebGL.initialize(); }
        static { this.rectRender = RenderWebGL.getCanvasRect(); }
        /**
         * Initializes offscreen-canvas, renderingcontext and hardware viewport. Call once before creating any resources like meshes or shaders
         */
        static initialize(_antialias, _alpha) {
            let fudgeConfig = Reflect.get(globalThis, "fudgeConfig") || {};
            let contextAttributes = {
                alpha: (_alpha != undefined) ? _alpha : fudgeConfig.alpha || false,
                antialias: (_antialias != undefined) ? _antialias : fudgeConfig.antialias || false,
                premultipliedAlpha: false
            };
            FudgeCore.Debug.fudge("Initialize RenderWebGL", contextAttributes);
            let canvas = document.createElement("canvas");
            let crc3;
            crc3 = RenderWebGL.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
            RenderWebGL.crc3 = crc3;
            // Enable backface- and zBuffer-culling.
            crc3.enable(WebGL2RenderingContext.CULL_FACE);
            crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            crc3.enable(WebGL2RenderingContext.BLEND);
            crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
            RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            // RenderOperator.crc3.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, true);
            RenderWebGL.rectRender = RenderWebGL.getCanvasRect();
            return crc3;
        }
        /**
         * Wrapper function to utilize the bufferSpecification interface when passing data to the shader via a buffer.
         * @param _attributeLocation  The location of the attribute on the shader, to which they data will be passed.
         * @param _bufferSpecification  Interface passing datapullspecifications to the buffer.
         */
        static setAttributeStructure(_attributeLocation, _bufferSpecification) {
            RenderWebGL.crc3.vertexAttribPointer(_attributeLocation, _bufferSpecification.size, _bufferSpecification.dataType, _bufferSpecification.normalize, _bufferSpecification.stride, _bufferSpecification.offset);
        }
        /**
        * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
        * @param _value  value to check against null
        * @param _message  optional, additional message for the exception
        */
        static assert(_value, _message = "") {
            if (_value === null)
                throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderWebGL.crc3 ? RenderWebGL.crc3.getError() : ""}`);
            return _value;
        }
        /**
         * Return a reference to the offscreen-canvas
         */
        static getCanvas() {
            return RenderWebGL.crc3.canvas; // TODO: enable OffscreenCanvas
        }
        /**
         * Return a reference to the rendering context
         */
        static getRenderingContext() {
            return RenderWebGL.crc3;
        }
        /**
         * Return a rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
         */
        static getCanvasRect() {
            let canvas = RenderWebGL.crc3.canvas;
            return FudgeCore.Rectangle.GET(0, 0, canvas.width, canvas.height);
        }
        /**
         * Set the size of the offscreen-canvas.
         */
        static setCanvasSize(_width, _height) {
            RenderWebGL.crc3.canvas.width = _width;
            RenderWebGL.crc3.canvas.height = _height;
        }
        /**
         * Set the area on the offscreen-canvas to render the camera image to.
         * @param _rect
         */
        static setRenderRectangle(_rect) {
            RenderWebGL.rectRender.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
            RenderWebGL.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Clear the offscreen renderbuffer with the given {@link Color}
         */
        static clear(_color = null) {
            RenderWebGL.crc3.clearColor(_color.r, _color.g, _color.b, _color.a);
            RenderWebGL.crc3.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT);
        }
        /**
         * Reset the offscreen framebuffer to the original RenderingContext
         */
        static resetFrameBuffer(_frameBuffer = null) {
            RenderWebGL.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, _frameBuffer);
        }
        /**
         * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
         */
        static getRenderRectangle() {
            return RenderWebGL.rectRender;
        }
        /**
         * Enable / Disable WebGLs depth test
         */
        static setDepthTest(_test) {
            if (_test)
                RenderWebGL.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            else
                RenderWebGL.crc3.disable(WebGL2RenderingContext.DEPTH_TEST);
        }
        /**
         * Set the blend mode to render with
         */
        static setBlendMode(_mode) {
            switch (_mode) {
                case BLEND.OPAQUE:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO);
                    break;
                case BLEND.TRANSPARENT:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                    // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.DST_ALPHA, WebGL2RenderingContext.ONE_MINUS_DST_ALPHA);
                    break;
                case BLEND.ADDITIVE:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.DST_ALPHA);
                    break;
                case BLEND.SUBTRACTIVE:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_REVERSE_SUBTRACT);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.DST_ALPHA);
                    break;
                case BLEND.MODULATE: // color gets multiplied, tried to copy unitys "Particle Shader: Blending Option: Rendering Mode: Modulate"
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.DST_COLOR, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                default:
                    break;
            }
        }
        //#region Picking
        /**
         * Creates a texture buffer to be used as pick-buffer
         */
        static createPickTexture(_size) {
            // create to render to
            const targetTexture = FudgeCore.Render.crc3.createTexture();
            FudgeCore.Render.crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, targetTexture);
            {
                const internalFormat = WebGL2RenderingContext.RGBA32I;
                const format = WebGL2RenderingContext.RGBA_INTEGER;
                const type = WebGL2RenderingContext.INT;
                FudgeCore.Render.pickBuffer = new Int32Array(_size * _size * 4);
                FudgeCore.Render.crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, internalFormat, _size, _size, 0, format, type, FudgeCore.Render.pickBuffer);
                // set the filtering so we don't need mips
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
            }
            const framebuffer = FudgeCore.Render.crc3.createFramebuffer();
            FudgeCore.Render.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, framebuffer);
            const attachmentPoint = WebGL2RenderingContext.COLOR_ATTACHMENT0;
            FudgeCore.Render.crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, attachmentPoint, WebGL2RenderingContext.TEXTURE_2D, targetTexture, 0);
            RenderWebGL.sizePick = _size;
            return targetTexture;
        }
        static getPicks(_size, _cmpCamera) {
            // evaluate texture by reading pixels and extract, convert and store the information about each mesh hit
            let data = new Int32Array(_size * _size * 4);
            FudgeCore.Render.crc3.readPixels(0, 0, _size, _size, WebGL2RenderingContext.RGBA_INTEGER, WebGL2RenderingContext.INT, data);
            let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSION(_cmpCamera.mtxWorldToView);
            let picked = [];
            for (let i = 0; i < FudgeCore.Render.∆ípicked.length; i++) {
                let zBuffer = data[4 * i + 0] + data[4 * i + 1] / 256;
                if (zBuffer == 0) // discard misses 
                    continue;
                let pick = FudgeCore.Render.∆ípicked[i];
                pick.zBuffer = convertInt32toFloat32(data, 4 * i + 0) * 2 - 1;
                pick.color = convertInt32toColor(data, 4 * i + 1);
                pick.textureUV = FudgeCore.Recycler.get(FudgeCore.Vector2);
                pick.textureUV.set(convertInt32toFloat32(data, 4 * i + 2), convertInt32toFloat32(data, 4 * i + 3));
                pick.mtxViewToWorld = mtxViewToWorld;
                picked.push(pick);
            }
            return picked;
            function convertInt32toFloat32(_int32Array, _index) {
                let buffer = new ArrayBuffer(4);
                let view = new DataView(buffer);
                view.setInt32(0, _int32Array[_index]);
                return view.getFloat32(0);
            }
            function convertInt32toColor(_int32Array, _index) {
                let buffer = new ArrayBuffer(4);
                let view = new DataView(buffer);
                view.setInt32(0, _int32Array[_index]);
                let color = FudgeCore.Color.CSS(`rgb(${view.getUint8(0)}, ${view.getUint8(1)}, ${view.getUint8(2)})`, view.getUint8(3) / 255);
                return color;
            }
        }
        /**
        * The render function for picking a single node.
        * A cameraprojection with extremely narrow focus is used, so each pixel of the buffer would hold the same information from the node,
        * but the fragment shader renders only 1 pixel for each node into the render buffer, 1st node to 1st pixel, 2nd node to second pixel etc.
        */
        static pick(_node, _mtxMeshToWorld, _cmpCamera) {
            try {
                let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
                let coat = cmpMaterial.material.coat;
                let shader = coat instanceof FudgeCore.CoatTextured ? FudgeCore.ShaderPickTextured : FudgeCore.ShaderPick;
                shader.useProgram();
                coat.useRenderData(shader, cmpMaterial);
                let mtxMeshToView = this.calcMeshToView(_node, cmpMesh, _cmpCamera.mtxWorldToView, _cmpCamera.mtxWorld.translation);
                let sizeUniformLocation = shader.uniforms["u_vctSize"];
                RenderWebGL.getRenderingContext().uniform2fv(sizeUniformLocation, [RenderWebGL.sizePick, RenderWebGL.sizePick]);
                let mesh = cmpMesh.mesh;
                let renderBuffers = mesh.useRenderBuffers(shader, _mtxMeshToWorld, mtxMeshToView, FudgeCore.Render.∆ípicked.length);
                RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                let pick = new FudgeCore.Pick(_node);
                FudgeCore.Render.∆ípicked.push(pick);
            }
            catch (_error) {
                //
            }
        }
        //#endregion
        //#region Lights
        /**
         * Buffer the data from the lights in the scenegraph into the lights ubo
         */
        static updateLightsUBO(_lights) {
            if (!RenderWebGL.uboLights)
                return;
            RenderWebGL.crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGL.uboLights);
            // fill the buffer with the ambient light color
            let cmpLights = _lights.get(FudgeCore.LightAmbient);
            if (cmpLights) {
                let result = new FudgeCore.Color(0, 0, 0, 0);
                for (let cmpLight of cmpLights)
                    result.add(cmpLight.light.color);
                RenderWebGL.crc3.bufferSubData(RenderWebGL.crc3.UNIFORM_BUFFER, RenderWebGL.uboLightsVariableOffsets["u_ambient.vctColor"], // byte offset of the struct Light "u_ambient" inside the ubo
                new Float32Array(result.getArray()));
            }
            // fill the buffer with the light data for each light type
            // we are currently doing a maximum of 4 crc3.bufferSubData() calls, but we could do this in one call
            updateLights(FudgeCore.LightDirectional, "u_nLightsDirectional", "u_directional");
            updateLights(FudgeCore.LightPoint, "u_nLightsPoint", "u_point");
            updateLights(FudgeCore.LightSpot, "u_nLightsSpot", "u_spot");
            function updateLights(_type, _uniName, _uniStruct) {
                const cmpLights = _lights.get(_type);
                RenderWebGL.crc3.bufferSubData(RenderWebGL.crc3.UNIFORM_BUFFER, RenderWebGL.uboLightsVariableOffsets[_uniName], // byte offset of the uint "u_nLightsDirectional" inside the ubo
                new Uint8Array([cmpLights?.length ?? 0]));
                if (!cmpLights)
                    return;
                const lightDataSize = 4 + 16 + 16; // vctColor + mtxShape + mtxShapeInverse, as float32s
                const lightsData = new Float32Array(cmpLights.length * lightDataSize);
                let iLight = 0;
                for (let cmpLight of cmpLights) {
                    const lightDataOffset = iLight * lightDataSize;
                    // set vctColor
                    lightsData.set(cmpLight.light.color.getArray(), lightDataOffset + 0);
                    // set mtxShape
                    let mtxTotal = FudgeCore.Matrix4x4.MULTIPLICATION(cmpLight.node.mtxWorld, cmpLight.mtxPivot);
                    lightsData.set(mtxTotal.get(), lightDataOffset + 4); // offset + vctColor
                    // set mtxShapeInverse
                    if (_type != FudgeCore.LightDirectional) {
                        let mtxInverse = mtxTotal.inverse();
                        lightsData.set(mtxInverse.get(), lightDataOffset + 4 + 16); // offset + vctColor + mtxShape
                        FudgeCore.Recycler.store(mtxInverse);
                    }
                    FudgeCore.Recycler.store(mtxTotal);
                    iLight++;
                }
                RenderWebGL.crc3.bufferSubData(RenderWebGL.crc3.UNIFORM_BUFFER, RenderWebGL.uboLightsVariableOffsets[`${_uniStruct}[0].vctColor`], // byte offset of the struct Light array inside the ubo
                lightsData);
            }
        }
        //#endregion
        /**
         * Draw a mesh buffer using the given infos and the complete projection matrix
         */
        static drawNode(_node, _cmpCamera) {
            let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
            let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
            let coat = cmpMaterial.material.coat;
            let cmpParticleSystem = _node.getComponent(FudgeCore.ComponentParticleSystem);
            let drawParticles = cmpParticleSystem && cmpParticleSystem.isActive;
            let shader = cmpMaterial.material.getShader();
            if (drawParticles)
                shader = cmpParticleSystem.particleSystem.getShaderFrom(shader);
            shader.useProgram();
            coat.useRenderData(shader, cmpMaterial);
            let mtxMeshToView = this.calcMeshToView(_node, cmpMesh, _cmpCamera.mtxWorldToView, _cmpCamera.mtxWorld.translation);
            let renderBuffers = cmpMesh.mesh.useRenderBuffers(shader, cmpMesh.mtxWorld, mtxMeshToView);
            if (cmpMesh.skeleton && cmpMesh.skeleton.isActive)
                cmpMesh.skeleton.useRenderBuffer(shader);
            let uniform = shader.uniforms["u_vctCamera"];
            if (uniform)
                RenderWebGL.crc3.uniform3fv(uniform, _cmpCamera.mtxWorld.translation.get());
            uniform = shader.uniforms["u_mtxWorldToView"];
            if (uniform)
                RenderWebGL.crc3.uniformMatrix4fv(uniform, false, _cmpCamera.mtxWorldToView.get());
            uniform = shader.uniforms["u_mtxWorldToCamera"];
            if (uniform) {
                // let mtxWorldToCamera: Matrix4x4 = Matrix4x4.INVERSION(_cmpCamera.mtxWorld); // todo: optimize/store in camera
                RenderWebGL.crc3.uniformMatrix4fv(uniform, false, _cmpCamera.mtxCameraInverse.get());
            }
            if (drawParticles) {
                RenderWebGL.drawParticles(cmpParticleSystem, shader, renderBuffers, _node.getComponent(FudgeCore.ComponentFaceCamera), cmpMaterial.sortForAlpha);
            }
            else {
                RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
            }
        }
        static drawParticles(_cmpParticleSystem, _shader, _renderBuffers, _cmpFaceCamera, _sortForAlpha) {
            RenderWebGL.crc3.depthMask(_cmpParticleSystem.depthMask);
            RenderWebGL.setBlendMode(_cmpParticleSystem.blendMode);
            _cmpParticleSystem.useRenderData();
            RenderWebGL.crc3.uniform1f(_shader.uniforms["u_fParticleSystemDuration"], _cmpParticleSystem.duration);
            RenderWebGL.crc3.uniform1f(_shader.uniforms["u_fParticleSystemSize"], _cmpParticleSystem.size);
            RenderWebGL.crc3.uniform1f(_shader.uniforms["u_fParticleSystemTime"], _cmpParticleSystem.time);
            RenderWebGL.crc3.uniform1i(_shader.uniforms["u_fParticleSystemRandomNumbers"], 1); // ATTENTION!: changing this id (the second argument) requires changing of corresponding texture id in component particle system render injector
            let faceCamera = _cmpFaceCamera && _cmpFaceCamera.isActive;
            RenderWebGL.crc3.uniform1i(_shader.uniforms["u_bParticleSystemFaceCamera"], faceCamera ? 1 : 0);
            RenderWebGL.crc3.uniform1i(_shader.uniforms["u_bParticleSystemRestrict"], faceCamera && _cmpFaceCamera.restrict ? 1 : 0);
            RenderWebGL.crc3.drawElementsInstanced(WebGL2RenderingContext.TRIANGLES, _renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0, _cmpParticleSystem.size);
            RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            RenderWebGL.crc3.depthMask(true);
        }
        static calcMeshToView(_node, _cmpMesh, _mtxWorldToView, _target) {
            let cmpFaceCamera = _node.getComponent(FudgeCore.ComponentFaceCamera);
            if (cmpFaceCamera && cmpFaceCamera.isActive) {
                let mtxMeshToView;
                mtxMeshToView = _cmpMesh.mtxWorld.clone;
                mtxMeshToView.lookAt(_target, cmpFaceCamera.upLocal ? null : cmpFaceCamera.up, cmpFaceCamera.restrict);
                return FudgeCore.Matrix4x4.MULTIPLICATION(_mtxWorldToView, mtxMeshToView);
            }
            return FudgeCore.Matrix4x4.MULTIPLICATION(_mtxWorldToView, _cmpMesh.mtxWorld);
        }
    }
    FudgeCore.RenderWebGL = RenderWebGL;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Gives WebGL Buffer the data from the {@link Texture}
     * @internal
     */
    class RenderInjectorTexture extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorTexture);
            Object.defineProperty(_constructor.prototype, "deleteRenderData", {
                value: RenderInjectorTexture.deleteRenderData
            });
        }
        static injectTexture() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.Render.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texImageSource);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texImageSource);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                switch (this.mipmap) {
                    case FudgeCore.MIPMAP.CRISP:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                        break;
                    case FudgeCore.MIPMAP.MEDIUM:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR);
                        crc3.generateMipmap(crc3.TEXTURE_2D);
                        break;
                    case FudgeCore.MIPMAP.BLURRY:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR);
                        crc3.generateMipmap(crc3.TEXTURE_2D);
                        break;
                }
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData();
            }
        }
        static deleteRenderData() {
            if (!this.renderData)
                return;
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
            for (const textureKey in this.renderData)
                crc3.deleteTexture(this.renderData[textureKey]);
            this.renderData = null;
        }
    }
    FudgeCore.RenderInjectorTexture = RenderInjectorTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Special type of {@link Event} for physics.
     */
    class EventPhysics extends Event {
        /** Creates a new event customized for physics. Holding informations about impulses. Collision point and the body that is colliding */
        constructor(_type, _hitRigidbody, _normalImpulse, _tangentImpulse, _binormalImpulse, _collisionPoint = null, _collisionNormal = null) {
            super(_type);
            this.cmpRigidbody = _hitRigidbody;
            this.normalImpulse = _normalImpulse;
            this.tangentImpulse = _tangentImpulse;
            this.binomalImpulse = _binormalImpulse;
            this.collisionPoint = _collisionPoint;
            this.collisionNormal = _collisionNormal;
        }
    }
    FudgeCore.EventPhysics = EventPhysics;
    /**
    * Groups to place a node in, not every group should collide with every group. Use a Mask in to exclude collisions
    */
    let COLLISION_GROUP;
    (function (COLLISION_GROUP) {
        COLLISION_GROUP[COLLISION_GROUP["DEFAULT"] = 1] = "DEFAULT";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_1"] = 2] = "GROUP_1";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_2"] = 4] = "GROUP_2";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_3"] = 8] = "GROUP_3";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_4"] = 16] = "GROUP_4";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_5"] = 32] = "GROUP_5";
    })(COLLISION_GROUP = FudgeCore.COLLISION_GROUP || (FudgeCore.COLLISION_GROUP = {}));
    /**
    * Defines the type of the rigidbody which determines the way it interacts with the physical and the visual world
    */
    let BODY_TYPE;
    (function (BODY_TYPE) {
        /** The body ignores the hierarchy of the render graph, is completely controlled  by physics and takes its node with it  */
        BODY_TYPE[BODY_TYPE["DYNAMIC"] = 0] = "DYNAMIC";
        /** The body ignores the hierarchy of the render graph, is completely immoveble and keeps its node from moving  */
        BODY_TYPE[BODY_TYPE["STATIC"] = 1] = "STATIC";
        /** The body is controlled by its node and moves with it, while it impacts the physical world e.g. by collisions */
        BODY_TYPE[BODY_TYPE["KINEMATIC"] = 2] = "KINEMATIC"; // = OIMO.RigidBodyType.KINEMATIC
    })(BODY_TYPE = FudgeCore.BODY_TYPE || (FudgeCore.BODY_TYPE = {}));
    /**
    * Different types of collider shapes, with different options in scaling BOX = Vector3(length, height, depth),
    * SPHERE = Vector3(diameter, x, x), CAPSULE = Vector3(diameter, height, x), CYLINDER = Vector3(diameter, height, x),
    * CONE = Vector(diameter, height, x), PYRAMID = Vector3(length, height, depth); x == unused.
    * CONVEX = ComponentMesh needs to be available in the RB Property convexMesh, the points of that component are used to create a collider that matches,
    * the closest possible representation of that form, in form of a hull. Convex is experimental and can produce unexpected behaviour when vertices
    * are too close to one another and the given vertices do not form a in itself closed shape and having a genus of 0 (no holes). Vertices in the ComponentMesh can be scaled differently
    * for texturing/normal or other reasons, so the collider might be off compared to the visual shape, this can be corrected by changing the pivot scale of the ComponentRigidbody.
    */
    let COLLIDER_TYPE;
    (function (COLLIDER_TYPE) {
        COLLIDER_TYPE[COLLIDER_TYPE["CUBE"] = 0] = "CUBE";
        COLLIDER_TYPE[COLLIDER_TYPE["SPHERE"] = 1] = "SPHERE";
        COLLIDER_TYPE[COLLIDER_TYPE["CAPSULE"] = 2] = "CAPSULE";
        COLLIDER_TYPE[COLLIDER_TYPE["CYLINDER"] = 3] = "CYLINDER";
        COLLIDER_TYPE[COLLIDER_TYPE["CONE"] = 4] = "CONE";
        COLLIDER_TYPE[COLLIDER_TYPE["PYRAMID"] = 5] = "PYRAMID";
        COLLIDER_TYPE[COLLIDER_TYPE["CONVEX"] = 6] = "CONVEX";
    })(COLLIDER_TYPE = FudgeCore.COLLIDER_TYPE || (FudgeCore.COLLIDER_TYPE = {}));
    /** Displaying different types of debug information about different physic features. Default = JOINTS_AND_COLLIDER. */
    let PHYSICS_DEBUGMODE;
    (function (PHYSICS_DEBUGMODE) {
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["NONE"] = 0] = "NONE";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["COLLIDERS"] = 1] = "COLLIDERS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["JOINTS_AND_COLLIDER"] = 2] = "JOINTS_AND_COLLIDER";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["BOUNDING_BOXES"] = 3] = "BOUNDING_BOXES";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["CONTACTS"] = 4] = "CONTACTS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["PHYSIC_OBJECTS_ONLY"] = 5] = "PHYSIC_OBJECTS_ONLY";
    })(PHYSICS_DEBUGMODE = FudgeCore.PHYSICS_DEBUGMODE || (FudgeCore.PHYSICS_DEBUGMODE = {}));
    /** Info about Raycasts shot from the physics system. */
    class RayHitInfo {
        constructor() {
            this.hitPoint = FudgeCore.Vector3.ZERO();
            this.hitNormal = FudgeCore.Vector3.ZERO();
            this.rayEnd = FudgeCore.Vector3.ZERO();
            this.rayOrigin = FudgeCore.Vector3.ZERO();
            this.recycle();
        }
        recycle() {
            this.hit = false;
            this.hitDistance = 0;
            this.hitPoint.recycle();
            this.rigidbodyComponent = null;
            this.hitNormal.recycle();
            this.rayOrigin.recycle();
            this.rayEnd.recycle();
        }
    }
    FudgeCore.RayHitInfo = RayHitInfo;
    /** General settings for the physic simulation and the debug of it. */
    class PhysicsSettings {
        constructor(_defaultCollisionGroup, _defaultCollisionMask) {
            if (typeof OIMO == "undefined")
                return;
            this.defaultCollisionGroup = _defaultCollisionGroup;
            this.defaultCollisionMask = _defaultCollisionMask;
        }
        /** Change if rigidbodies are able to sleep (don't be considered in physical calculations) when their movement is below a threshold. Deactivation is decreasing performance for minor advantage in precision. */
        get disableSleeping() {
            return OIMO.Setting.disableSleeping;
        }
        set disableSleeping(_value) {
            OIMO.Setting.disableSleeping = _value;
        }
        /** Sleeping Threshold for Movement Veloctiy. */
        get sleepingVelocityThreshold() {
            return OIMO.Setting.sleepingVelocityThreshold;
        }
        set sleepingVelocityThreshold(_value) {
            OIMO.Setting.sleepingVelocityThreshold = _value;
        }
        /** Sleeping Threshold for Rotation Velocity. */
        get sleepingAngularVelocityThreshold() {
            return OIMO.Setting.sleepingAngularVelocityThreshold;
        }
        set sleepingAngularVelocityThreshold(_value) {
            OIMO.Setting.sleepingAngularVelocityThreshold = _value;
        }
        /** Threshold how long the Rigidbody must be below/above the threshold to count as sleeping. */
        get sleepingTimeThreshold() {
            return OIMO.Setting.sleepingTimeThreshold;
        }
        set sleepingTimeThreshold(_value) {
            OIMO.Setting.sleepingTimeThreshold = _value;
        }
        /** Error threshold. Default is 0.05. The higher the more likely collisions get detected before actual impact at high speeds but it's visually less accurate. */
        get defaultCollisionMargin() {
            return OIMO.Setting.defaultGJKMargin;
        }
        set defaultCollisionMargin(_thickness) {
            OIMO.Setting.defaultGJKMargin = _thickness;
        }
        /** The default applied friction between two rigidbodies with the default value. How much velocity is slowed down when moving accross this surface. */
        get defaultFriction() {
            return OIMO.Setting.defaultFriction;
        }
        set defaultFriction(_value) {
            OIMO.Setting.defaultFriction = _value;
        }
        /** Bounciness of rigidbodies. How much of the impact is restituted. */
        get defaultRestitution() {
            return OIMO.Setting.defaultRestitution;
        }
        set defaultRestitution(_value) {
            OIMO.Setting.defaultRestitution = _value;
        }
        /** Groups the default rigidbody will collide with. Set it like: (PHYSICS_GROUP.DEFAULT | PHYSICS_GROUP.GROUP_1 | PHYSICS_GROUP.GROUP_2 | PHYSICS_GROUP.GROUP_3)
         * to collide with multiple groups. Default is collision with everything but triggers.
        */
        get defaultCollisionMask() {
            return OIMO.Setting.defaultCollisionMask;
        }
        set defaultCollisionMask(_value) {
            OIMO.Setting.defaultCollisionMask = _value;
        }
        /** The group that this rigidbody belongs to. Default is the DEFAULT Group which means its just a normal Rigidbody not a trigger nor anything special. */
        get defaultCollisionGroup() {
            return OIMO.Setting.defaultCollisionGroup;
        }
        set defaultCollisionGroup(_value) {
            OIMO.Setting.defaultCollisionGroup = _value;
        }
        /** Change the type of joint solver algorithm. Default Iterative == 0, is faster but less stable. Direct == 1, slow but more stable, recommended for complex joint work. Change this setting only at the start of your game. */
        get defaultConstraintSolverType() {
            return OIMO.Setting.defaultJointConstraintSolverType;
        }
        set defaultConstraintSolverType(_value) {
            OIMO.Setting.defaultJointConstraintSolverType = _value;
        }
        /** The correction algorithm used to correct physics calculations. Change this only at the beginning of your game. Each has different approaches, so if you have problems test another
         *  Default 0 = Baumgarte (fast but less correct induces some energy errors), 1 = Split-Impulse (fast and no engery errors, but more inaccurate for joints), 2 = Non-linear Gauss Seidel (slowest but most accurate)*/
        get defaultCorrectionAlgorithm() {
            return OIMO.Setting.defaultJointPositionCorrectionAlgorithm;
        }
        set defaultCorrectionAlgorithm(_value) {
            OIMO.Setting.defaultJointPositionCorrectionAlgorithm = _value;
        }
        /** The precision of the simulation in form of number of iterations the simulations runs through until it accepts the result.
         *  10 Default - Higher means more precision but results in a performance decrease. This helps especially with joints,
         * but also the general stability of the simulation due to simulation steps being rechecked multiple times before being set.
         */
        get solverIterations() {
            return FudgeCore.Physics.activeInstance.getOimoWorld().getNumPositionIterations();
        }
        set solverIterations(_value) {
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumPositionIterations(_value);
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumVelocityIterations(_value);
        }
    }
    FudgeCore.PhysicsSettings = PhysicsSettings;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Acts as the physical representation of a connection between two {@link Node}'s.
       * The type of conncetion is defined by the subclasses like prismatic joint, cylinder joint etc.
       * A Rigidbody on the {@link Node} that this component is added to is needed. Setting the connectedRigidbody and
       * initializing the connection creates a physical connection between them. This differs from a connection through hierarchy
       * in the node structure of fudge. Joints can have different DOF's (Degrees Of Freedom), 1 Axis that can either twist or swing is a degree of freedom.
       * A joint typically consists of a motor that limits movement/rotation or is activly trying to move to a limit. And a spring which defines the rigidity.
       * @author Marko Fehrenbach, HFU 2020
       */
    class Joint extends FudgeCore.Component {
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Joint; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        #idBodyAnchor;
        #idBodyTied;
        #bodyAnchor;
        #bodyTied;
        #connected;
        #anchor;
        #internalCollision;
        #breakForce;
        #breakTorque;
        #nameChildToConnect;
        /** Create a joint connection between the two given RigidbodyComponents. */
        constructor(_bodyAnchor = null, _bodyTied = null) {
            super();
            // public static readonly iSubclass: number = Component.registerSubclass(ComponentJoint);
            this.singleton = false; //Multiple joints can be attached to one Node
            this.#idBodyAnchor = 0;
            this.#idBodyTied = 0;
            this.#connected = false;
            this.#internalCollision = false;
            this.#breakForce = 0;
            this.#breakTorque = 0;
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* EVENT.COMPONENT_ADD */:
                        this.node.addEventListener("disconnectJoint" /* EVENT.DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.dirtyStatus();
                        break;
                    case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                        this.node.removeEventListener("disconnectJoint" /* EVENT.DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.removeJoint();
                        break;
                }
            };
            this.#getMutator = () => {
                let mutator = {
                    nameChildToConnect: this.#nameChildToConnect,
                    internalCollision: this.#internalCollision,
                    breakForce: this.#breakForce,
                    breakTorque: this.#breakTorque
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["internalCollision", "breakForce", "breakTorque"]);
            };
            this.bodyAnchor = _bodyAnchor;
            this.bodyTied = _bodyTied;
            /*
              Tell the physics that there is a new joint and on the physics start the actual joint is first created. Values can be set but the
              actual constraint ain't existent until the game starts
            */
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
        }
        static registerSubclass(_subclass) { return Joint.subclasses.push(_subclass) - 1; }
        /** Get/Set the first ComponentRigidbody of this connection. It should always be the one that this component is attached too in the sceneTree. */
        get bodyAnchor() {
            return this.#bodyAnchor;
        }
        set bodyAnchor(_cmpRB) {
            this.#idBodyAnchor = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyAnchor = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /** Get/Set the second ComponentRigidbody of this connection. */
        get bodyTied() {
            return this.#bodyTied;
        }
        set bodyTied(_cmpRB) {
            this.#idBodyTied = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyTied = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The exact position where the two {@link Node}s are connected. When changed after initialization the joint needs to be reconnected.
         */
        get anchor() {
            return new FudgeCore.Vector3(this.#anchor.x, this.#anchor.y, this.#anchor.z);
        }
        set anchor(_value) {
            this.#anchor = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The amount of force needed to break the JOINT, while rotating, in Newton. 0 equals unbreakable (default)
        */
        get breakTorque() {
            return this.#breakTorque;
        }
        set breakTorque(_value) {
            this.#breakTorque = _value;
            if (this.joint != null)
                this.joint.setBreakTorque(this.#breakTorque);
        }
        /**
         * The amount of force needed to break the JOINT, in Newton. 0 equals unbreakable (default)
         */
        get breakForce() {
            return this.#breakForce;
        }
        set breakForce(_value) {
            this.#breakForce = _value;
            if (this.joint != null)
                this.joint.setBreakForce(this.#breakForce);
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
          * On a welding joint the connected bodies should not be colliding with each other,
          * for best results
         */
        get internalCollision() {
            return this.#internalCollision;
        }
        set internalCollision(_value) {
            this.#internalCollision = _value;
            if (this.joint != null)
                this.joint.setAllowCollision(this.#internalCollision);
        }
        /**
         * Connect a child node with the given name to the joint.
         */
        connectChild(_name) {
            this.#nameChildToConnect = _name;
            if (!this.node)
                return;
            let children = this.node.getChildrenByName(_name);
            if (children.length == 1)
                this.connectNode(children.pop());
            else
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails to connect child with non existent or ambigous name ${_name}`);
        }
        /**
         * Connect the given node to the joint. Tieing its rigidbody to the nodes rigidbody this component is attached to.
         */
        connectNode(_node) {
            if (!_node || !this.node)
                return;
            FudgeCore.Debug.fudge(`${this.constructor.name} connected ${this.node.name} and ${_node.name}`);
            let connectBody = _node.getComponent(FudgeCore.ComponentRigidbody);
            let thisBody = this.node.getComponent(FudgeCore.ComponentRigidbody);
            if (!connectBody || !thisBody) {
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails due to missing rigidbodies on ${this.node.name} or ${_node.name}`);
                return;
            }
            this.bodyAnchor = thisBody;
            this.bodyTied = connectBody;
        }
        /** Check if connection is dirty, so when either rb is changed disconnect and reconnect. Internally used no user interaction needed. */
        isConnected() {
            return this.#connected;
        }
        /**
         * Initializing and connecting the two rigidbodies with the configured joint properties
         * is automatically called by the physics system. No user interaction needed.
         */
        connect() {
            if (this.#connected == false) {
                if (this.#idBodyAnchor == -1 || this.#idBodyTied == -1) {
                    if (this.#nameChildToConnect)
                        this.connectChild(this.#nameChildToConnect);
                    return;
                }
                this.constructJoint();
                this.#connected = true;
                this.addJoint();
            }
        }
        /**
         * Disconnecting the two rigidbodies and removing them from the physics system,
         * is automatically called by the physics system. No user interaction needed.
         */
        disconnect() {
            if (this.#connected == true) {
                this.removeJoint();
                this.#connected = false;
            }
        }
        /**
         * Returns the original Joint used by the physics engine. Used internally no user interaction needed.
         * Only to be used when functionality that is not added within FUDGE is needed.
        */
        getOimoJoint() {
            return this.joint;
        }
        serialize() {
            let serialization = this.#getMutator();
            serialization.anchor = this.anchor.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.anchor = await new FudgeCore.Vector3().deserialize(_serialization.anchor);
            this.#mutate(_serialization);
            await super.deserialize(_serialization[super.constructor.name]);
            this.connectChild(_serialization.nameChildToConnect);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            Object.assign(mutator, this.#getMutator());
            mutator.anchor = this.anchor.getMutator();
            return mutator;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.anchor) !== "undefined")
                this.anchor = new FudgeCore.Vector3(...(Object.values(_mutator.anchor)));
            delete _mutator.anchor;
            if (typeof (_mutator.nameChildToConnect) !== "undefined")
                this.connectChild(_mutator.nameChildToConnect);
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        reduceMutator(_mutator) {
            delete _mutator.springDamper;
            delete _mutator.joint;
            delete _mutator.motor;
            super.reduceMutator(_mutator);
        }
        /** Tell the FudgePhysics system that this joint needs to be handled in the next frame. */
        dirtyStatus() {
            FudgeCore.Physics.changeJointStatus(this);
        }
        addJoint() {
            FudgeCore.Physics.addJoint(this);
        }
        removeJoint() {
            FudgeCore.Physics.removeJoint(this);
        }
        constructJoint(..._configParams) {
            let posBodyAnchor = this.bodyAnchor.node.mtxWorld.translation; //Setting the anchor position locally from the first rigidbody
            let worldAnchor = new OIMO.Vec3(posBodyAnchor.x + this.#anchor.x, posBodyAnchor.y + this.#anchor.y, posBodyAnchor.z + this.#anchor.z);
            // @ts-ignore    // unfortunately, method init is not a member of the base class OIMO.JointConfig
            this.config.init(this.#bodyAnchor.getOimoRigidbody(), this.#bodyTied.getOimoRigidbody(), worldAnchor, ..._configParams);
        }
        configureJoint() {
            this.joint.setBreakForce(this.breakForce);
            this.joint.setBreakTorque(this.breakTorque);
            this.joint.setAllowCollision(this.#internalCollision);
        }
        deleteFromMutator(_mutator, _delete) {
            for (let key in _delete)
                delete _mutator[key];
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.Joint = Joint;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Base class for joints operating with exactly one axis
       * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointAxial extends FudgeCore.Joint {
        //Internal Variables
        #maxMotor = 10;
        #minMotor = -10;
        #motorSpeed = 0;
        #axis;
        #springFrequency = 0;
        #springDamping = 0;
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.axis = _axis;
            this.anchor = _localAnchor;
            this.minMotor = -10;
            this.maxMotor = 10;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axis() {
            return new FudgeCore.Vector3(this.#axis.x, this.#axis.y, this.#axis.z);
        }
        set axis(_value) {
            this.#axis = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get maxMotor() {
            return this.#maxMotor;
        }
        set maxMotor(_value) {
            this.#maxMotor = _value;
            try {
                this.joint.getLimitMotor().upperLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get minMotor() {
            return this.#minMotor;
        }
        set minMotor(_value) {
            this.#minMotor = _value;
            try {
                this.joint.getLimitMotor().lowerLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            try {
                this.joint.getSpringDamper().dampingRatio = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The target speed of the motor in m/s.
         */
        get motorSpeed() {
            return this.#motorSpeed;
        }
        set motorSpeed(_value) {
            this.#motorSpeed = _value;
            try {
                this.joint.getLimitMotor().motorSpeed = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            try {
                this.joint.getSpringDamper().frequency = _value;
            }
            catch (_e) { /* */ }
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axis = this.axis.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axis = await new FudgeCore.Vector3().deserialize(_serialization.axis);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.axis) !== "undefined")
                this.axis = new FudgeCore.Vector3(...(Object.values(_mutator.axis)));
            delete _mutator.axis;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.axis = this.axis.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.springDamper = new OIMO.SpringDamper().setSpring(this.#springFrequency, this.#springDamping);
            super.constructJoint(this.#axis);
        }
        #getMutator = () => {
            let mutator = {
                springDamping: this.#springDamping,
                springFrequency: this.#springFrequency,
                maxMotor: this.#maxMotor,
                minMotor: this.#minMotor,
                motorSpeed: this.#motorSpeed
            };
            return mutator;
        };
        #mutate = (_mutator) => {
            this.mutateBase(_mutator, ["springDamping", "springFrequency", "maxMotor", "minMotor", "motorSpeed"]);
        };
    }
    FudgeCore.JointAxial = JointAxial;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Debug/Debug.ts"/>
// / <reference path="Time/Time.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Serialization/Mutable.ts"/>
/// <reference path="Serialization/Serializer.ts"/> 
/// <reference path="Graph/Node.ts"/>
/// <reference path="Component/Component.ts"/>
/// <reference path="Recycle/RecycableArray.ts"/>
/// <reference path="Render/RenderWebGL.ts"/>
/// <reference path="Render/RenderInjectorTexture.ts"/>
/// <reference path="Physics/HelpersPhysics.ts"/>
/// <reference path="Physics/Joint.ts"/>
/// <reference path="Physics/JointAxial.ts"/>
//global functions
function ifNumber(_check, _default) {
    return typeof _check == "undefined" ? _default : _check;
}
var FudgeCore;
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE["LOOP"] = "loop";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE["PLAY_ONCE"] = "playOnce";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE["PLAY_ONCE_RESET"] = "playOnceReset";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE["REVERSE_LOOP"] = "reverseLoop";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE["STOP"] = "stop";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_QUANTIZATION;
    (function (ANIMATION_QUANTIZATION) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the quantization. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_QUANTIZATION["CONTINOUS"] = "continous";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_QUANTIZATION["DISCRETE"] = "discrete";
        /** Advances the time each frame according to the FPS value of the animation, ignoring the actual duration of the frames. Doesn't skip any frames.*/
        ANIMATION_QUANTIZATION["FRAMES"] = "frames";
    })(ANIMATION_QUANTIZATION = FudgeCore.ANIMATION_QUANTIZATION || (FudgeCore.ANIMATION_QUANTIZATION = {}));
    /**
     * Describes and controls and animation by yielding mutators
     * according to the stored {@link AnimationStructure} and {@link AnimationSequence}s
     * Applied to a {@link Node} directly via script or {@link ComponentAnimator}.
     * @author Lukas Scheuerle, HFU, 21019 | Jirka Dell'Oro-Friedl, HFU, 2021-2023
     */
    class Animation extends FudgeCore.Mutable {
        // /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        // public static readonly baseClass: typeof Animation = Animation;
        // /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        static { this.iSubclass = Animation.registerSubclass(Animation); }
        #animationStructuresProcessed;
        constructor(_name = Animation.name, _animStructure = {}, _fps = 60) {
            super();
            this.idResource = undefined;
            this.totalTime = 0;
            this.labels = {}; // a label marks a specific time to conveniently jump to using a text identifier
            this.events = {};
            this.framesPerSecond = 60; // TODO: change this and its accessors to #framesPerSecond?
            // processed eventlist and animation strucutres for playback.
            this.eventsProcessed = new Map();
            this.#animationStructuresProcessed = new Map();
            this.name = _name;
            this.animationStructure = _animStructure;
            this.#animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
            this.framesPerSecond = _fps;
            this.calculateTotalTime();
            FudgeCore.Project.register(this);
        }
        static registerSubclass(_subClass) { return Animation.subclasses.push(_subClass) - 1; }
        get getLabels() {
            //TODO: this actually needs testing
            let en = new Enumerator(this.labels);
            return en;
        }
        get fps() {
            return this.framesPerSecond;
        }
        set fps(_fps) {
            this.framesPerSecond = _fps;
            this.eventsProcessed.clear();
            this.clearCache();
        }
        /**
         * Clear this animations cache.
         */
        clearCache() {
            this.#animationStructuresProcessed.clear();
        }
        /**
         * Generates and returns a {@link Mutator} with the information to apply to the {@link Node} to animate
         * in the state the animation is in at the given time, direction and quantization
         */
        getState(_time, _direction, _quantization) {
            let m = {};
            let animationStructure;
            if (_quantization == ANIMATION_QUANTIZATION.CONTINOUS)
                animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.REVERSE : ANIMATION_STRUCTURE_TYPE.NORMAL;
            else
                animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE : ANIMATION_STRUCTURE_TYPE.RASTERED;
            m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(animationStructure), _time);
            return m;
        }
        /**
         * Returns a list of the names of the events the {@link ComponentAnimator} needs to fire between _min and _max input values.
         * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
         * @returns a list of strings with the names of the custom events to fire.
         */
        getEventsToFire(_min, _max, _quantization, _direction) {
            let eventList = [];
            let minSection = Math.floor(_min / this.totalTime);
            let maxSection = Math.floor(_max / this.totalTime);
            _min = _min % this.totalTime;
            _max = _max % this.totalTime;
            while (minSection <= maxSection) {
                let eventTriggers = this.getCorrectEventList(_direction, _quantization);
                if (minSection == maxSection) {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, _max));
                }
                else {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, this.totalTime));
                    _min = 0;
                }
                minSection++;
            }
            return eventList;
        }
        /**
         * Adds an Event to the List of events.
         * @param _name The name of the event (needs to be unique per Animation).
         * @param _time The timestamp of the event (in milliseconds).
         */
        setEvent(_name, _time) {
            this.events[_name] = _time;
            this.eventsProcessed.clear();
        }
        /**
         * Removes the event with the given name from the list of events.
         * @param _name name of the event to remove.
         */
        removeEvent(_name) {
            delete this.events[_name];
            this.eventsProcessed.clear();
        }
        /**
         * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
         */
        calculateTotalTime() {
            this.totalTime = 0;
            this.traverseStructureForTime(this.animationStructure);
            if (this.totalTime == 0) // animations with one keyframe need a total time != 0 to work
                this.totalTime = 1;
        }
        /**
         * Returns the time to use for animation sampling when applying a playmode
         */
        getModalTime(_time, _playmode, _timeStop = _time) {
            switch (_playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    // return this.localTime.getOffset();
                    return _timeStop;
                case ANIMATION_PLAYMODE.PLAY_ONCE:
                    if (_time >= this.totalTime)
                        return this.totalTime - 0.01; //TODO: this might cause some issues
                case ANIMATION_PLAYMODE.PLAY_ONCE_RESET:
                    if (_time >= this.totalTime)
                        // TODO: return _timeStop instead?
                        return this.totalTime + 0.01; //TODO: this might cause some issues
            }
            return _time;
        }
        /**
         * Calculates and returns the direction the animation should currently be playing in.
         * @param _time the time at which to calculate the direction
         * @returns 1 if forward, 0 if stop, -1 if backwards
         */
        calculateDirection(_time, _playmode) {
            switch (_playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    return 0;
                // case ANIMATION_PLAYMODE.PINGPONG:
                //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                //     return 1;
                //   else
                //     return -1;
                case ANIMATION_PLAYMODE.REVERSE_LOOP:
                    return -1;
                case ANIMATION_PLAYMODE.PLAY_ONCE:
                case ANIMATION_PLAYMODE.PLAY_ONCE_RESET:
                    if (_time >= this.totalTime) {
                        return 0;
                    }
                default:
                    return 1;
            }
        }
        //#region transfer
        serialize() {
            let s = {
                idResource: this.idResource,
                name: this.name,
                labels: {},
                events: {},
                framesPerSecond: this.framesPerSecond
                // sps: this.stepsPerSecond
            };
            for (let name in this.labels) {
                s.labels[name] = this.labels[name];
            }
            for (let name in this.events) {
                s.events[name] = this.events[name];
            }
            s.animationStructure = this.traverseStructureForSerialization(this.animationStructure);
            return s;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            this.framesPerSecond = _serialization.framesPerSecond;
            // this.stepsPerSecond = _serialization.sps;
            this.labels = {};
            for (let name in _serialization.labels) {
                this.labels[name] = _serialization.labels[name];
            }
            this.events = {};
            for (let name in _serialization.events) {
                this.events[name] = _serialization.events[name];
            }
            this.eventsProcessed = new Map();
            this.animationStructure = await this.traverseStructureForDeserialization(_serialization.animationStructure);
            this.#animationStructuresProcessed = new Map();
            this.calculateTotalTime();
            return this;
        }
        // public getMutator(): Mutator {
        //   return this.serialize();
        // }
        reduceMutator(_mutator) {
            delete _mutator.totalTime;
        }
        /**
         * Traverses an AnimationStructure and returns the Serialization of said Structure.
         * @param _structure The Animation Structure at the current level to transform into the Serialization.
         * @returns the filled Serialization.
         */
        traverseStructureForSerialization(_structure) {
            let serialization = {};
            for (const property in _structure) {
                let structureOrSequence = _structure[property];
                if (structureOrSequence instanceof FudgeCore.AnimationSequence)
                    serialization[property] = structureOrSequence.serialize();
                else
                    serialization[property] = this.traverseStructureForSerialization(structureOrSequence);
            }
            return serialization;
        }
        /**
         * Traverses a Serialization to create a new AnimationStructure.
         * @param _serialization The serialization to transfer into an AnimationStructure
         * @returns the newly created AnimationStructure.
         */
        async traverseStructureForDeserialization(_serialization) {
            let structure = {};
            for (let n in _serialization) {
                if (_serialization[n].animationSequence) {
                    let animSeq = new FudgeCore.AnimationSequence();
                    structure[n] = (await animSeq.deserialize(_serialization[n]));
                }
                else {
                    structure[n] = await this.traverseStructureForDeserialization(_serialization[n]);
                }
            }
            return structure;
        }
        //#endregion
        /**
         * Finds and returns the list of events to be used with these settings.
         */
        getCorrectEventList(_direction, _quantization) {
            if (_quantization != ANIMATION_QUANTIZATION.FRAMES) {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                }
            }
            else {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                }
            }
        }
        /**
         * Traverses an {@link AnimationStructure} and returns a {@link Mutator} describing the state at the given time
         */
        traverseStructureForMutator(_structure, _time) {
            let newMutator = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newMutator[n] = _structure[n].evaluate(_time);
                }
                else {
                    newMutator[n] = this.traverseStructureForMutator(_structure[n], _time);
                }
            }
            return newMutator;
        }
        /**
         * Traverses the current AnimationStrcuture to find the totalTime of this animation.
         * @param _structure The structure to traverse
         */
        traverseStructureForTime(_structure) {
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    let sequence = _structure[n];
                    if (sequence.length > 0) {
                        let sequenceTime = sequence.getKey(sequence.length - 1).time;
                        this.totalTime = Math.max(sequenceTime, this.totalTime);
                    }
                }
                else {
                    this.traverseStructureForTime(_structure[n]);
                }
            }
        }
        /**
         * Ensures the existance of the requested {@link AnimationStrcuture} and returns it.
         * @param _type the type of the structure to get
         * @returns the requested [[@link AnimationStructure]]
         */
        getProcessedAnimationStructure(_type) {
            if (!this.#animationStructuresProcessed.has(_type)) {
                this.calculateTotalTime();
                let ae = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ae = this.animationStructure;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ae = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                        break;
                    default:
                        return {};
                }
                this.#animationStructuresProcessed.set(_type, ae);
            }
            return this.#animationStructuresProcessed.get(_type);
        }
        /**
         * Ensures the existance of the requested {@link AnimationEventTrigger} and returns it.
         * @param _type The type of AnimationEventTrigger to get
         * @returns the requested {@link AnimationEventTrigger}
         */
        getProcessedEventTrigger(_type) {
            if (!this.eventsProcessed.has(_type)) {
                this.calculateTotalTime();
                let ev = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ev = this.events;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ev = this.calculateReverseEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ev = this.calculateRasteredEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ev = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                        break;
                    default:
                        return {};
                }
                this.eventsProcessed.set(_type, ev);
            }
            return this.eventsProcessed.get(_type);
        }
        /**
         * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
         * @param _oldStructure The old structure to traverse
         * @param _functionToUse The function to use to recalculated the structure.
         * @returns A new Animation Structure with the recalulated Animation Sequences.
         */
        traverseStructureForNewStructure(_oldStructure, _functionToUse) {
            let newStructure = {};
            for (let n in _oldStructure) {
                if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                    newStructure[n] = _functionToUse(_oldStructure[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                }
            }
            return newStructure;
        }
        /**
         * Creates a reversed Animation Sequence out of a given Sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns The reversed Sequence
         */
        calculateReverseSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            for (let i = 0; i < _sequence.length; i++) {
                let oldKey = _sequence.getKey(i);
                let key = new FudgeCore.AnimationKey(this.totalTime - oldKey.time, oldKey.value, oldKey.interpolation, oldKey.slopeOut, oldKey.slopeIn);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a rastered {@link AnimationSequence} out of a given sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns the rastered sequence.
         */
        calculateRasteredSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            let frameTime = 1000 / this.framesPerSecond;
            for (let i = 0; i < this.totalTime; i += frameTime) {
                let key = new FudgeCore.AnimationKey(i, _sequence.evaluate(i), FudgeCore.ANIMATION_INTERPOLATION.CONSTANT, 0, 0);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a new reversed {@link AnimationEventTrigger} object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the reversed event object
         */
        calculateReverseEventTriggers(_events) {
            let ae = {};
            for (let name in _events) {
                ae[name] = this.totalTime - _events[name];
            }
            return ae;
        }
        /**
         * Creates a rastered {@link AnimationEventTrigger} object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the rastered event object
         */
        calculateRasteredEventTriggers(_events) {
            let ae = {};
            let frameTime = 1000 / this.framesPerSecond;
            for (let name in _events) {
                ae[name] = _events[name] - (_events[name] % frameTime);
            }
            return ae;
        }
        /**
         * Checks which events lay between two given times and returns the names of the ones that do.
         * @param _eventTriggers The event object to check the events inside of
         * @param _min the minimum of the range to check between (inclusive)
         * @param _max the maximum of the range to check between (exclusive)
         * @returns an array of the names of the events in the given range.
         */
        checkEventsBetween(_eventTriggers, _min, _max) {
            let eventsToTrigger = [];
            for (let name in _eventTriggers) {
                if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                    eventsToTrigger.push(name);
                }
            }
            return eventsToTrigger;
        }
    }
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Calculates the values between {@link AnimationKey}s.
     * Represented internally by a cubic function (`f(x) = ax¬≥ + bx¬≤ + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        set setKeyIn(_keyIn) {
            this.keyIn = _keyIn;
            this.calculate();
        }
        set setKeyOut(_keyOut) {
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Returns the parameter values of this cubic function. `f(x) = ax¬≥ + bx¬≤ + cx + d`
         * Used by editor.
         */
        getParameters() {
            return { a: this.a, b: this.b, c: this.c, d: this.d };
        }
        /**
         * Calculates the value of the function at the given time.
         * @param _time the point in time at which to evaluate the function in milliseconds. Will be corrected for offset internally.
         * @returns the value at the given time
         */
        evaluate(_time) {
            _time -= this.keyIn.time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        /**
         * (Re-)Calculates the parameters of the cubic function.
         * See https://math.stackexchange.com/questions/3173469/calculate-cubic-equation-from-two-points-and-two-slopes-variably
         * and https://jirkadelloro.github.io/FUDGE/Documentation/Logs/190410_Notizen_LS
         */
        calculate() {
            if (!this.keyIn) {
                this.d = this.c = this.b = this.a = 0;
                return;
            }
            if (!this.keyOut || this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.CONSTANT) {
                this.d = this.keyIn.value;
                this.c = this.b = this.a = 0;
                return;
            }
            let x1 = this.keyOut.time - this.keyIn.time;
            this.d = this.keyIn.value;
            if (this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.LINEAR) {
                this.c = (this.keyOut.value - this.keyIn.value) / x1;
                return;
            }
            this.c = this.keyIn.slopeOut;
            this.a = (-x1 * (this.keyIn.slopeOut + this.keyOut.slopeIn) - 2 * this.keyIn.value + 2 * this.keyOut.value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.slopeIn - this.keyIn.slopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let ANIMATION_INTERPOLATION;
    (function (ANIMATION_INTERPOLATION) {
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["CONSTANT"] = 0] = "CONSTANT";
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["LINEAR"] = 1] = "LINEAR";
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["CUBIC"] = 2] = "CUBIC";
    })(ANIMATION_INTERPOLATION = FudgeCore.ANIMATION_INTERPOLATION || (FudgeCore.ANIMATION_INTERPOLATION = {}));
    // type AnimationInterpolation = "constant" | "linear" | "cubic";
    /**
     * Holds information about continous points in time their accompanying values as well as their slopes.
     * Also holds a reference to the {@link AnimationFunction}s that come in and out of the sides.
     * The {@link AnimationFunction}s are handled by the {@link AnimationSequence}s.
     * If the property constant is true, the value does not change and wil not be interpolated between this and the next key in a sequence
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationKey extends FudgeCore.Mutable {
        #time;
        #value;
        #interpolation;
        #slopeIn = 0;
        #slopeOut = 0;
        constructor(_time = 0, _value = 0, _interpolation = ANIMATION_INTERPOLATION.CUBIC, _slopeIn = 0, _slopeOut = 0) {
            super();
            this.#time = _time;
            this.#value = _value;
            this.#interpolation = _interpolation;
            this.#slopeIn = _slopeIn;
            this.#slopeOut = _slopeOut;
            this.functionOut = new FudgeCore.AnimationFunction(this, null);
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        get time() {
            return this.#time;
        }
        set time(_time) {
            this.#time = _time;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get value() {
            return this.#value;
        }
        set value(_value) {
            this.#value = _value;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get interpolation() {
            return this.#interpolation;
        }
        set interpolation(_interpolation) {
            this.#interpolation = _interpolation;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get slopeIn() {
            return this.#slopeIn;
        }
        set slopeIn(_slope) {
            this.#slopeIn = _slope;
            this.functionIn.calculate();
        }
        get slopeOut() {
            return this.#slopeOut;
        }
        set slopeOut(_slope) {
            this.#slopeOut = _slope;
            this.functionOut.calculate();
        }
        //#region transfer
        serialize() {
            let serialization = {};
            serialization.time = this.#time;
            serialization.value = this.#value;
            serialization.interpolation = this.#interpolation;
            serialization.slopeIn = this.#slopeIn;
            serialization.slopeOut = this.#slopeOut;
            return serialization;
        }
        async deserialize(_serialization) {
            this.#time = _serialization.time;
            this.#value = _serialization.value;
            this.#interpolation = _serialization.interpolation;
            this.#slopeIn = _serialization.slopeIn;
            this.#slopeOut = _serialization.slopeOut;
            // if (_serialization.interpolation == undefined)
            //   if (_serialization.constant) // TODO: remove this when constant is removed
            //     this.#interpolation = "constant";
            //   else
            //     this.#interpolation = "cubic";
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of {@link AnimationKey}s that is mapped to an attribute of a {@link Node} or its {@link Component}s inside the {@link Animation}.
     * Provides functions to modify said keys
     * @authors Lukas Scheuerle, HFU, 2019 | Jonas Plotzky, HFU, 2022
     */
    class AnimationSequence extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.keys = [];
        }
        get length() {
            return this.keys.length;
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. undefined if there are no keys.
         */
        evaluate(_time) {
            if (this.keys.length == 0)
                return undefined; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            if (this.keys.length == 1 || this.keys[0].time >= _time)
                return this.keys[0].value;
            for (let i = 0; i < this.keys.length - 1; i++) {
                if (this.keys[i].time <= _time && _time < this.keys[i + 1].time) {
                    return this.keys[i].functionOut.evaluate(_time);
                }
                // if (this.keys[i].time == _time)
                //   return this.keys[i].value;
            }
            return this.keys[this.keys.length - 1].value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Modifys a given key in the sequence.
         * @param _key the key to add
         */
        modifyKey(_key, _time, _value) {
            if (_time != null)
                _key.time = _time;
            if (_value != null)
                _key.value = _value;
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Find a key in the sequence exactly matching the given time.
         */
        findKey(_time) {
            for (let key of this.keys)
                if (key.time == _time)
                    return key;
            return null;
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        /**
         * Returns this sequence's keys. This is not a copy, but the actual array used internally. Handle with care!
         * Used by Editor.
         */
        getKeys() {
            return this.keys;
        }
        //#region transfer
        serialize() {
            let s = {
                keys: [],
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        async deserialize(_serialization) {
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                await k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        reduceMutator(_mutator) { }
        //#endregion
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions() {
            for (let i = 0; i < this.keys.length; i++) {
                let f = new FudgeCore.AnimationFunction(this.keys[i]);
                this.keys[i].functionOut = f;
                if (i == this.keys.length - 1) {
                    //TODO: check if this is even useful. Maybe update the runcondition to length - 1 instead. Might be redundant if functionIn is removed, see TODO in AnimationKey.
                    f.setKeyOut = this.keys[0];
                    this.keys[0].functionIn = f;
                    break;
                }
                f.setKeyOut = this.keys[i + 1];
                this.keys[i + 1].functionIn = f;
            }
        }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class AnimationSprite extends FudgeCore.Animation {
        static { this.iSubclass = FudgeCore.Animation.registerSubclass(AnimationSprite); }
        // TODO: fps should be a parameter too
        constructor(_name = "AnimationSprite") {
            super(_name, {}, 1);
            this.texture = FudgeCore.TextureDefault.texture;
            this.frames = 25;
            this.wrapAfter = 5;
            this.start = new FudgeCore.Vector2(0, 0);
            this.size = new FudgeCore.Vector2(80, 80);
            this.next = new FudgeCore.Vector2(80, 0);
            this.wrap = new FudgeCore.Vector2(0, 80);
            this.framesPerSecond = this.frames;
            this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
        }
        /**
         * Sets the texture to be used as the spritesheet
         */
        setTexture(_texture) {
            this.texture = _texture;
            this.idTexture = _texture.idResource;
        }
        /**
         * Creates this animation sprite from the given arguments
         */
        create(_texture, _frames, _wrapAfter, _start, _size, _next, _wrap, _framesPerSecond) {
            this.setTexture(_texture);
            this.frames = _frames;
            this.wrapAfter = _wrapAfter;
            this.start = _start;
            this.size = _size;
            this.next = _next;
            this.wrap = _wrap;
            this.framesPerSecond = _framesPerSecond;
            let scale = this.getScale();
            let positions = this.getPositions();
            let xTranslation = new FudgeCore.AnimationSequence();
            let yTranslation = new FudgeCore.AnimationSequence();
            let xScale = new FudgeCore.AnimationSequence();
            let yScale = new FudgeCore.AnimationSequence();
            xScale.addKey(new FudgeCore.AnimationKey(0, scale.x));
            yScale.addKey(new FudgeCore.AnimationKey(0, scale.y));
            for (let frame = 0; frame <= this.frames; frame++) {
                let time = 1000 * frame / this.framesPerSecond;
                let position = positions[Math.min(frame, this.frames - 1)]; //repeat the last key to give the last frame some time
                xTranslation.addKey(new FudgeCore.AnimationKey(time, position.x / this.texture.texImageSource.width)); //, 0, 0, true))
                yTranslation.addKey(new FudgeCore.AnimationKey(time, position.y / this.texture.texImageSource.height)); //, 0, 0, true))
            }
            this.animationStructure = {
                "components": {
                    "ComponentMaterial": [{
                            "mtxPivot": {
                                "translation": {
                                    x: xTranslation,
                                    y: yTranslation
                                },
                                "scaling": {
                                    x: xScale,
                                    y: yScale
                                }
                            }
                        }]
                }
            };
            this.calculateTotalTime();
        }
        /**
         * Returns the scale of the spritesheet
         */
        getScale() {
            return new FudgeCore.Vector2(this.size.x / this.texture.texImageSource.width, this.size.y / this.texture.texImageSource.height);
        }
        /**
         * Returns the positions of the spritesheet
         */
        getPositions() {
            let iNext = 0;
            let iWrap = 0;
            let positions = [];
            for (let frame = 0; frame < this.frames; frame++) {
                positions.push(new FudgeCore.Vector2(this.start.x + iNext * this.next.x + iWrap * this.wrap.x, this.start.y + iNext * this.next.y + iWrap * this.wrap.y));
                iNext++;
                if (iNext >= this.wrapAfter) {
                    iNext = 0;
                    iWrap++;
                }
            }
            return positions;
        }
        //#region transfer
        async mutate(_mutator, _selection, _dispatchMutate) {
            super.mutate(_mutator);
            this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
        }
        serialize() {
            let serialization = {};
            serialization.idResource = this.idResource;
            serialization.idTexture = this.idTexture;
            serialization.frames = this.frames;
            serialization.wrapAfter = this.wrapAfter;
            for (let name of ["start", "size", "next", "wrap"])
                serialization[name] = Reflect.get(this, name).serialize();
            let animationsStructure = this.animationStructure;
            this.animationStructure = {}; // no need to serialize structure
            // let serialization: Serialization = super.serialize();
            serialization[super.constructor.name] = super.serialize();
            this.animationStructure = animationsStructure; // restore existent structure
            return serialization;
        }
        async deserialize(_s) {
            await super.deserialize(_s[super.constructor.name]);
            if (_s.idTexture)
                this.texture = await FudgeCore.Project.getResource(_s.idTexture);
            else
                this.texture = FudgeCore.TextureDefault.texture;
            for (let name of ["start", "size", "next", "wrap"])
                Reflect.get(this, name).deserialize(_s[name]);
            this.create(this.texture, _s.frames, _s.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
            return this;
        }
        //#endregion
        /**
         * Converts the {@link AnimationSprite} into an {@link Animation}
         */
        convertToAnimation() {
            let animation = new FudgeCore.Animation(this.name, this.animationStructure, this.framesPerSecond);
            return animation;
        }
    }
    FudgeCore.AnimationSprite = AnimationSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the {@link AudioManager}.default to be used with {@link ComponentAudio}
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Audio extends FudgeCore.Mutable {
        constructor(_url) {
            super();
            this.name = "Audio";
            this.idResource = undefined;
            this.buffer = undefined;
            this.path = undefined;
            this.url = undefined;
            this.ready = false;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get isReady() {
            return this.ready;
        }
        /**
         * Asynchronously loads the audio (mp3) from the given url
         */
        async load(_url) {
            FudgeCore.Debug.fudge("AudioLoad", _url);
            this.url = _url;
            this.ready = false;
            this.path = new URL(this.url.toString(), FudgeCore.Project.baseURL);
            const response = await window.fetch(this.path.toString());
            const arrayBuffer = await response.arrayBuffer();
            let buffer = await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer);
            this.buffer = buffer;
            this.ready = true;
            this.dispatchEvent(new Event("ready" /* EVENT_AUDIO.READY */));
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                idResource: this.idResource,
                name: this.name,
                type: this.type
            };
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            await this.load(_serialization.url);
            this.name = _serialization.name;
            return this;
        }
        async mutate(_mutator) {
            let url = _mutator.url; // save url for reconstruction after exclusion
            if (_mutator.url != this.url.toString())
                this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            super.mutate(_mutator);
            // reconstruct, for mutator may be kept by caller
            Reflect.set(_mutator, "url", url);
        }
        reduceMutator(_mutator) {
            // delete _mutator.idResource; 
            delete _mutator.ready;
        }
    }
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Event/EventAudio.ts"/>
var FudgeCore;
///<reference path="../Event/EventAudio.ts"/>
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with FUDGE-graphs.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    class AudioManager extends AudioContext {
        /** The default context that may be used throughout the project without the need to create others */
        static { this.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 }); }
        static { this.eventUpdate = new Event("updateAudioGraph" /* EVENT_AUDIO.UPDATE */); }
        constructor(_contextOptions) {
            super(_contextOptions);
            this.graph = null;
            this.cmpListener = null;
            /**
             * Determines FUDGE-graph to listen to. Each {@link ComponentAudio} in the graph will connect to this contexts master gain, all others disconnect.
             */
            this.listenTo = (_graph) => {
                if (this.graph)
                    this.graph.broadcastEvent(new Event("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */));
                if (!_graph)
                    return;
                this.graph = _graph;
                this.graph.broadcastEvent(new Event("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */));
            };
            /**
             * Retrieve the FUDGE-graph currently listening to
             */
            this.getGraphListeningTo = () => {
                return this.graph;
            };
            /**
             * Set the {@link ComponentAudioListener} that serves the spatial location and orientation for this contexts listener
             */
            this.listenWith = (_cmpListener) => {
                this.cmpListener = _cmpListener;
            };
            /**
             * Updates the spatial settings of the AudioNodes effected in the current FUDGE-graph
             */
            this.update = () => {
                // this.graph.broadcastEvent(new Event(EVENT_AUDIO.UPDATE));
                this.graph.broadcastEvent(AudioManager.eventUpdate);
                if (this.cmpListener)
                    this.cmpListener.update(this.listener);
            };
            this.gain = this.createGain();
            this.gain.connect(this.destination);
        }
        /**
         * Set the master volume
         */
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        /**
         * Get the master volume
         */
        get volume() {
            return this.gain.gain.value;
        }
    }
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an {@link AudioFilter} to an {@link Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds a reference to an {@link Animation} and controls it. Controls quantization and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2022
     */
    class ComponentAnimator extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimator); }
        #scale;
        #timeLocal;
        #previous;
        constructor(_animation, _playmode = FudgeCore.ANIMATION_PLAYMODE.LOOP, _quantization = FudgeCore.ANIMATION_QUANTIZATION.CONTINOUS) {
            super();
            this.scaleWithGameTime = true;
            this.animateInEditor = false;
            this.#scale = 1;
            this.#previous = 0;
            //#region updateAnimation
            /**
             * Updates the Animation.
             * Uses the built-in time unless a different time is specified.
             * May also be called from updateAnimation().
             */
            this.updateAnimationLoop = (_e, _time) => {
                if (this.animation.totalTime == 0)
                    return null;
                let time = _time || _time === 0 ? _time : this.#timeLocal.get();
                if (this.quantization == FudgeCore.ANIMATION_QUANTIZATION.FRAMES) {
                    time = this.#previous + (1000 / this.animation.fps);
                }
                let direction = this.animation.calculateDirection(time, this.playmode);
                time = this.animation.getModalTime(time, this.playmode, this.#timeLocal.getOffset());
                this.executeEvents(this.animation.getEventsToFire(this.#previous, time, this.quantization, direction));
                if (this.#previous != time) {
                    this.#previous = time;
                    time = time % this.animation.totalTime;
                    let mutator = this.animation.getState(time, direction, this.quantization);
                    if (this.node) {
                        this.node.applyAnimation(mutator);
                    }
                    return mutator;
                }
                return null;
            };
            /**
             * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
             */
            this.updateScale = () => {
                let newScale = this.#scale;
                if (this.scaleWithGameTime)
                    newScale *= FudgeCore.Time.game.getScale();
                this.#timeLocal.setScale(newScale);
            };
            this.playmode = _playmode;
            this.quantization = _quantization;
            this.animation = _animation;
            this.#timeLocal = new FudgeCore.Time();
            //TODO: update animation total time when loading a different animation?
            this.animation?.calculateTotalTime();
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, () => this.activate(false));
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, () => {
                this.node.addEventListener("childRemove" /* EVENT.CHILD_REMOVE */, () => this.activate(false));
                this.activate(true);
            });
        }
        set scale(_scale) {
            this.#scale = _scale;
            this.updateScale();
        }
        get scale() {
            return this.#scale;
        }
        /**
         * - get: return the current sample time of the animation
         * - set: jump to a certain sample time in the animation
         */
        get time() {
            return this.#timeLocal.get() % this.animation.totalTime;
        }
        set time(_time) {
            this.jumpTo(_time);
        }
        activate(_on) {
            super.activate(_on);
            if (!this.node)
                return;
            this.activateListeners(_on);
        }
        /**
         * Jumps to a certain time in the animation to play from there.
         */
        jumpTo(_time) {
            this.#timeLocal.set(_time);
            this.#previous = _time;
            _time = _time % this.animation.totalTime;
            let mutator = this.animation.getState(_time, this.animation.calculateDirection(_time, this.playmode), this.quantization);
            this.node.applyAnimation(mutator);
        }
        /**
         * Jumps to a certain label in the animation if defined
         */
        jumpToLabel(_label) {
            let time = this.animation.labels[_label];
            if (time)
                this.jumpTo(time);
        }
        /**
         * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
         * @param _time the (unscaled) time to update the animation with.
         * @returns the Mutator for Animation.
         */
        updateAnimation(_time) {
            this.#previous = undefined;
            return this.updateAnimationLoop(null, _time);
        }
        //#region transfer
        serialize() {
            let serialization = {};
            serialization[super.constructor.name] = super.serialize();
            serialization.idAnimation = this.animation.idResource;
            serialization.playmode = this.playmode;
            serialization.quantization = this.quantization;
            serialization.scale = this.scale;
            serialization.scaleWithGameTime = this.scaleWithGameTime;
            serialization.animateInEditor = this.animateInEditor;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            this.animation = await FudgeCore.Project.getResource(_serialization.idAnimation);
            this.playmode = _serialization.playmode;
            this.quantization = _serialization.quantization;
            this.scale = _serialization.scale;
            this.scaleWithGameTime = _serialization.scaleWithGameTime;
            this.animateInEditor = _serialization.animateInEditor;
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            if (typeof (_mutator.animateInEditor) !== "undefined") {
                this.updateAnimation(0);
                this.activateListeners(this.active);
            }
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.playmode)
                types.playmode = FudgeCore.ANIMATION_PLAYMODE;
            if (types.quantization)
                types.quantization = FudgeCore.ANIMATION_QUANTIZATION;
            return types;
        }
        //#endregion
        activateListeners(_on) {
            if (_on && (FudgeCore.Project.mode != FudgeCore.MODE.EDITOR || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR && this.animateInEditor)) {
                FudgeCore.Time.game.addEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateScale);
                this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.updateAnimationLoop);
            }
            else {
                FudgeCore.Time.game.removeEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateScale);
                this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.updateAnimationLoop);
            }
        }
        /**
         * Fires all custom events the Animation should have fired between the last frame and the current frame.
         * @param _events a list of names of custom events to fire
         */
        executeEvents(_events) {
            for (let i = 0; i < _events.length; i++) {
                this.dispatchEvent(new Event(_events[i]));
            }
        }
    }
    FudgeCore.ComponentAnimator = ComponentAnimator;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in {@link AudioManager}.default) and synchronizes it with the containing {@link Node}
     * ```text
     * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
     * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudio extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio); }
        constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
            super();
            /** places and directs the panner relative to the world transform of the {@link Node}  */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.singleton = false;
            this.playing = false;
            this.listened = false;
            //#endregion
            this.hndAudioReady = (_event) => {
                FudgeCore.Debug.fudge("Audio start", Reflect.get(_event.target, "url"));
                if (this.playing)
                    this.play(true);
            };
            this.hndAudioEnded = (_event) => {
                // Debug.fudge("Audio ended", Reflect.get(_event.target, "url"));
                this.playing = false;
            };
            /**
             * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
             * Therefore unused AudioNodes may be garbage collected when an unused component is collected
             */
            this.handleAttach = (_event) => {
                // Debug.log(_event);
                if (_event.type == "componentAdd" /* EVENT.COMPONENT_ADD */) {
                    this.node.addEventListener("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */, this.handleGraph, true);
                    this.node.addEventListener("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */, this.handleGraph, true);
                    this.node.addEventListener("updateAudioGraph" /* EVENT_AUDIO.UPDATE */, this.update, true);
                    this.listened = this.node.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo());
                }
                else {
                    this.node.removeEventListener("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */, this.handleGraph, true);
                    this.node.removeEventListener("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */, this.handleGraph, true);
                    this.node.removeEventListener("updateAudioGraph" /* EVENT_AUDIO.UPDATE */, this.update, true);
                    this.listened = false;
                }
                this.updateConnection();
            };
            /**
             * Automatically connects/disconnects AudioNodes when appending/removing the FUDGE-graph the component is in.
             */
            this.handleGraph = (_event) => {
                // Debug.log(_event);
                this.listened = (_event.type == "childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */);
                this.updateConnection();
            };
            /**
             * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
             */
            this.update = (_event) => {
                let mtxResult = this.mtxPivot;
                if (this.node)
                    mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
                // Debug.log(mtxResult.toString());
                let position = mtxResult.translation;
                let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                this.panner.positionX.value = position.x;
                this.panner.positionY.value = position.y;
                this.panner.positionZ.value = position.z;
                this.panner.orientationX.value = forward.x;
                this.panner.orientationY.value = forward.y;
                this.panner.orientationZ.value = forward.z;
                FudgeCore.Recycler.store(forward);
                // TODO: examine why the following produces erroneous results, see test "Spatial Audio"
                if (this.node)
                    FudgeCore.Recycler.store(mtxResult);
            };
            this.install(_audioManager);
            this.createSource(_audio, _loop);
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.handleAttach);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.handleAttach);
            if (_start)
                this.play(_start);
        }
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        get volume() {
            return this.gain.gain.value;
        }
        set loop(_on) {
            this.source.loop = _on;
        }
        get loop() {
            return this.source.loop;
        }
        set playbackRate(_value) {
            this.source.playbackRate.value = _value;
        }
        get playbackRate() {
            return this.source.playbackRate.value;
        }
        get isPlaying() {
            return this.playing;
        }
        get isAttached() {
            return this.node != null;
        }
        get isListened() {
            return this.listened;
        }
        /**
         * Sets the given {@link Audio} as the audio source
         */
        setAudio(_audio) {
            this.createSource(_audio, this.source.loop);
        }
        /**
         * Returns the {@link Audio} currently used as audio source
         */
        getAudio() {
            return this.audio;
        }
        /**
         * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
         */
        setPanner(_property, _value) {
            Reflect.set(this.panner, _property, _value);
        }
        // TODO: may be used for serialization of AudioNodes
        /**
         * Returns the mutator for the specified AudioNode of the standard graph
         */
        getMutatorOfNode(_type) {
            let node = this.getAudioNode(_type);
            let mutator = FudgeCore.getMutatorOfArbitrary(node);
            return mutator;
        }
        /**
         * Returns the specified AudioNode of the standard graph for further manipulation
         */
        getAudioNode(_type) {
            switch (_type) {
                case AUDIO_NODE_TYPE.SOURCE: return this.source;
                case AUDIO_NODE_TYPE.PANNER: return this.panner;
                case AUDIO_NODE_TYPE.GAIN: return this.gain;
            }
        }
        /**
         * Start or stop playing the audio
         */
        play(_on) {
            if (_on) {
                if (this.audio.isReady) {
                    this.createSource(this.audio, this.source.loop, this.playbackRate);
                    this.source.start(0, 0);
                }
                else {
                    this.audio.addEventListener("ready" /* EVENT_AUDIO.READY */, this.hndAudioReady);
                }
                this.source.addEventListener("ended" /* EVENT_AUDIO.ENDED */, this.hndAudioEnded);
            }
            else
                try {
                    this.source.stop();
                }
                catch (_error) { /* catch exception when source hasn't been started... */ }
            this.playing = _on;
        }
        /**
         * Inserts AudioNodes between the panner and the local gain of this {@link ComponentAudio}
         * _input and _output may be the same AudioNode, if there is only one to insert,
         * or may have multiple AudioNode between them to create an effect-graph.\
         * Note that {@link ComponentAudio} does not keep track of inserted AudioNodes!
         * ```text
         * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
         * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
         * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ_input‚îÇ ‚Üí ...  ‚Üí ‚îÇ_output‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
         * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
         * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
         * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         * ```
         */
        insertAudioNodes(_input, _output) {
            this.panner.disconnect(0);
            if (!_input && !_output) {
                this.panner.connect(this.gain);
                return;
            }
            this.panner.connect(_input);
            _output.connect(this.gain);
        }
        /**
         * Activate override. Connects or disconnects AudioNodes
         */
        activate(_on) {
            super.activate(_on);
            this.updateConnection();
        }
        /**
         * Connects this components gain-node to the gain node of the AudioManager this component runs on.
         * Only call this method if the component is not attached to a {@link Node} but needs to be heard.
         */
        connect(_on) {
            if (_on)
                this.gain.connect(this.audioManager.gain);
            else
                this.gain.disconnect(this.audioManager.gain);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idResource = this.audio.idResource;
            serialization.playing = this.playing;
            serialization.loop = this.loop;
            serialization.volume = this.volume;
            // console.log(this.getMutatorOfNode(AUDIO_NODE_TYPE.PANNER));
            // TODO: serialize panner parameters
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let audio = await FudgeCore.Project.getResource(_serialization.idResource);
            this.createSource(audio, _serialization.loop);
            this.volume = _serialization.volume;
            this.play(_serialization.playing);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            let audio = mutator.audio;
            delete mutator.audio; // just to rearrange in interfaces...
            mutator.loop = this.loop;
            mutator.volume = this.volume;
            mutator.audio = audio; //... so audio comes last
            return mutator;
        }
        // public async mutate(_mutator: Mutator): Promise<void> {
        //   await super.mutate(_mutator);
        //   // this.volume = _mutator.volume;
        //   // this.loop = _mutator.loop;
        // }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.listened;
        }
        install(_audioManager = FudgeCore.AudioManager.default) {
            let active = this.isActive;
            this.activate(false);
            this.audioManager = _audioManager;
            this.panner = _audioManager.createPanner();
            this.gain = _audioManager.createGain();
            this.panner.connect(this.gain);
            this.gain.connect(_audioManager.gain);
            this.activate(active);
        }
        createSource(_audio, _loop, _playbackRate = 1.0) {
            if (this.source) {
                this.source.disconnect();
                this.source.buffer = null;
            }
            this.source = this.audioManager.createBufferSource();
            this.source.connect(this.panner);
            if (_audio) {
                this.audio = _audio;
                this.source.buffer = _audio.buffer;
            }
            this.source.loop = _loop;
            this.playbackRate = _playbackRate;
        }
        updateConnection() {
            try {
                this.connect(this.isActive && this.isAttached && this.listened);
            }
            catch (_error) {
                // nop
            }
        }
    }
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the {@link Node} it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudioListener extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener); }
        /**
         * Updates the position and orientation of the given AudioListener
         */
        update(_listener) {
            let mtxResult = this.mtxPivot;
            if (this.node)
                mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            // Debug.log(mtxResult.toString());
            let position = mtxResult.translation;
            let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
            let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
            if (_listener.positionX != undefined) {
                _listener.positionX.value = position.x;
                _listener.positionY.value = position.y;
                _listener.positionZ.value = position.z;
                _listener.forwardX.value = forward.x;
                _listener.forwardY.value = forward.y;
                _listener.forwardZ.value = forward.z;
                _listener.upX.value = up.x;
                _listener.upY.value = up.y;
                _listener.upZ.value = up.z;
            }
            else {
                // Firefox still uses deprecated methods. TODO: delete as soon as possible!
                _listener.setPosition(position.x, position.y, position.z);
                _listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
            }
            FudgeCore.Recycler.store(forward);
            FudgeCore.Recycler.store(up);
            if (this.node)
                FudgeCore.Recycler.store(mtxResult);
            // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
        }
    }
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW["HORIZONTAL"] = "horizontal";
        FIELD_OF_VIEW["VERTICAL"] = "vertical";
        FIELD_OF_VIEW["DIAGONAL"] = "diagonal";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentCamera extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.clrBackground = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
            //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
            this.projection = PROJECTION.CENTRAL;
            this.fieldOfView = 45; // The camera's sensorangle.
            this.aspectRatio = 1.0;
            this.direction = FIELD_OF_VIEW.DIAGONAL;
            this.near = 1;
            this.far = 2000;
            this.backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered.
            this.#mtxProjection = new FudgeCore.Matrix4x4; // The matrix to multiply each scene objects transformation by, to determine where it will be drawn.
            //#endregion
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera); }
        // TODO: examine, if background should be an attribute of Camera or Viewport
        #mtxWorldToView;
        #mtxCameraInverse;
        #mtxProjection; // The matrix to multiply each scene objects transformation by, to determine where it will be drawn.
        /**
         * Returns the cameras worldtransformation matrix i.e. the transformation relative to the root of the graph
         */
        get mtxWorld() {
            let mtxCamera = this.mtxPivot.clone;
            try {
                mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            }
            catch (_error) {
                // no container node or no world transformation found -> continue with pivot only
            }
            return mtxCamera;
        }
        /**
         * Returns the multiplication of the worldtransformation of the camera container, the pivot of this camera and the inversion of the projection matrix
         * yielding the worldspace to viewspace matrix
         */
        get mtxWorldToView() {
            if (this.#mtxWorldToView)
                return this.#mtxWorldToView;
            //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
            this.#mtxWorldToView = FudgeCore.Matrix4x4.MULTIPLICATION(this.#mtxProjection, this.mtxCameraInverse);
            return this.#mtxWorldToView;
        }
        /**
         * Returns the inversion of this cameras worldtransformation
         */
        get mtxCameraInverse() {
            if (this.#mtxCameraInverse)
                return this.#mtxCameraInverse;
            //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
            this.#mtxCameraInverse = FudgeCore.Matrix4x4.INVERSION(this.mtxWorld);
            return this.#mtxCameraInverse;
        }
        /**
         * Returns the projectionmatrix of this camera
         */
        get mtxProjection() {
            if (this.#mtxProjection)
                return this.#mtxProjection;
            //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
            this.#mtxProjection = new FudgeCore.Matrix4x4;
            return this.#mtxProjection;
        }
        /**
         * Resets this cameras {@link mtxWorldToView} and {@link mtxCameraInverse} matrices
         */
        resetWorldToView() {
            if (this.#mtxWorldToView)
                FudgeCore.Recycler.store(this.#mtxWorldToView);
            if (this.#mtxCameraInverse)
                FudgeCore.Recycler.store(this.#mtxCameraInverse);
            this.#mtxWorldToView = null;
            this.#mtxCameraInverse = null;
        }
        /**
         * Returns the cameras {@link PROJECTION} mode
         */
        getProjection() {
            return this.projection;
        }
        /**
         * Returns true if the background of the camera should be rendered, false if not
         */
        getBackgroundEnabled() {
            return this.backgroundEnabled;
        }
        /**
         * Returns the cameras aspect ratio
         */
        getAspect() {
            return this.aspectRatio;
        }
        /**
         * Returns the cameras field of view in degrees
         */
        getFieldOfView() {
            return this.fieldOfView;
        }
        /**
         * Returns the cameras direction i.e. the plane on which the fieldOfView-Angle is given
         */
        getDirection() {
            return this.direction;
        }
        /**
         * Returns the cameras near value i.e. the minimum distance to render objects at
         */
        getNear() {
            return this.near;
        }
        /**
         * Returns the cameras far value i.e. the maximum distance to render objects at
         */
        getFar() {
            return this.far;
        }
        /**
         * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfView The field of view in Degrees. (Default = 45)
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        projectCentral(_aspect = this.aspectRatio, _fieldOfView = this.fieldOfView, _direction = this.direction, _near = this.near, _far = this.far) {
            this.aspectRatio = _aspect;
            this.fieldOfView = _fieldOfView;
            this.direction = _direction;
            this.projection = PROJECTION.CENTRAL;
            this.near = _near;
            this.far = _far;
            this.#mtxProjection = FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.fieldOfView, _near, _far, this.direction); // TODO: remove magic numbers
        }
        /**
         * Set the camera to orthographic projection. Default values are derived the canvas client dimensions
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         */
        projectOrthographic(_left = -FudgeCore.Render.getCanvas().clientWidth / 2, _right = FudgeCore.Render.getCanvas().clientWidth / 2, _bottom = FudgeCore.Render.getCanvas().clientHeight / 2, _top = -FudgeCore.Render.getCanvas().clientHeight / 2) {
            this.projection = PROJECTION.ORTHOGRAPHIC;
            this.#mtxProjection = FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400); // TODO: examine magic numbers!
        }
        /**
         * Return the calculated dimension of a projection surface in the hypothetical distance of 1 to the camera
         */
        getProjectionRectangle() {
            let tanFov = Math.tan(Math.PI * this.fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
            let tanHorizontal = 0;
            let tanVertical = 0;
            if (this.direction == FIELD_OF_VIEW.DIAGONAL) {
                let aspect = Math.sqrt(this.aspectRatio);
                tanHorizontal = tanFov * aspect;
                tanVertical = tanFov / aspect;
            }
            else if (this.direction == FIELD_OF_VIEW.VERTICAL) {
                tanVertical = tanFov;
                tanHorizontal = tanVertical * this.aspectRatio;
            }
            else { //FOV_DIRECTION.HORIZONTAL
                tanHorizontal = tanFov;
                tanVertical = tanHorizontal / this.aspectRatio;
            }
            return FudgeCore.Rectangle.GET(0, 0, tanHorizontal * 2, tanVertical * 2);
        }
        /**
         * Transforms the given point from world space to clip space
         */
        pointWorldToClip(_pointInWorldSpace) {
            let result;
            let m = this.mtxWorldToView.get();
            let w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
            result = FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.mtxWorldToView);
            result.scale(1 / w);
            return result;
        }
        /**
         * Transforms the given point from clip space to world space
         */
        pointClipToWorld(_pointInClipSpace) {
            let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSION(this.mtxWorldToView);
            let m = mtxViewToWorld.get();
            let rayWorld = FudgeCore.Vector3.TRANSFORMATION(_pointInClipSpace, mtxViewToWorld, true);
            let w = m[3] * _pointInClipSpace.x + m[7] * _pointInClipSpace.y + m[11] * _pointInClipSpace.z + m[15];
            rayWorld.scale(1 / w);
            return rayWorld;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                backgroundColor: this.clrBackground,
                backgroundEnabled: this.backgroundEnabled,
                projection: this.projection,
                fieldOfView: this.fieldOfView,
                direction: this.direction,
                near: this.near,
                far: this.far,
                aspect: this.aspectRatio,
                pivot: this.mtxPivot.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await this.clrBackground.deserialize(_serialization.backgroundColor);
            this.backgroundEnabled = _serialization.backgroundEnabled;
            this.projection = _serialization.projection;
            this.fieldOfView = _serialization.fieldOfView;
            this.aspectRatio = _serialization.aspect;
            this.direction = _serialization.direction;
            this.near = _serialization.near;
            this.far = _serialization.far;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            switch (this.projection) {
                case PROJECTION.ORTHOGRAPHIC:
                    this.projectOrthographic(); // TODO: serialize and deserialize parameters
                    break;
                case PROJECTION.CENTRAL:
                    this.projectCentral();
                    break;
            }
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.direction)
                types.direction = FIELD_OF_VIEW;
            if (types.projection)
                types.projection = PROJECTION;
            return types;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            switch (this.projection) {
                case PROJECTION.CENTRAL:
                    this.projectCentral(this.aspectRatio, this.fieldOfView, this.direction, this.near, this.far);
                    break;
            }
        }
        reduceMutator(_mutator) {
            delete _mutator.transform;
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Makes the node face the camera when rendering, respecting restrictions for rotation around specific axis
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentFaceCamera extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentFaceCamera); }
        constructor() {
            super();
            this.upLocal = true;
            this.up = FudgeCore.Vector3.Y(1);
            this.restrict = false;
            this.singleton = true;
        }
    }
    FudgeCore.ComponentFaceCamera = ComponentFaceCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Filters synchronization between a graph instance and the graph it is connected to. If active, no synchronization occurs.
     * Maybe more finegrained in the future...
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentGraphFilter extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentGraphFilter); }
        constructor() {
            super();
            this.singleton = true;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    FudgeCore.ComponentGraphFilter = ComponentGraphFilter;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of lights.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Light extends FudgeCore.Mutable {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super();
            this.color = _color;
        }
        /**
         * Returns the {@link TypeOfLight} of this light.
         */
        getType() {
            return this.constructor;
        }
        serialize() {
            let serialization = {
                color: this.color.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await this.color.deserialize(_serialization.color);
            return this;
        }
        reduceMutator() { }
    }
    FudgeCore.Light = Light;
    /**
     * Ambient light, coming from all directions, illuminating everything with its color independent of position and orientation (like a foggy day or in the shades)
     * Attached to a node by {@link ComponentLight}, the pivot matrix is ignored.
     * ```text
     * ~ ~ ~
     *  ~ ~ ~
     * ```
     */
    class LightAmbient extends Light {
    }
    FudgeCore.LightAmbient = LightAmbient;
    /**
     * Directional light, illuminating everything from a specified direction with its color (like standing in bright sunlight)
     * Attached to a node by {@link ComponentLight}, the pivot matrix specifies the direction of the light only.
     * ```text
     * --->
     * --->
     * --->
     * ```
     */
    class LightDirectional extends Light {
    }
    FudgeCore.LightDirectional = LightDirectional;
    /**
     * Omnidirectional light emitting from its position, illuminating objects depending on their position and distance with its color (like a colored light bulb)
     * Attached to a node by {@link ComponentLight}, the pivot matrix specifies the position of the light, it's shape and rotation.
     * So with uneven scaling, other shapes than a perfect sphere, such as an oval or a disc, are possible, which creates a visible effect of the rotation too.
     * The intensity of the light drops linearly from 1 in the center to 0 at the perimeter of the shape.
     * ```text
     *         .\|/.
     *        -- o --
     *         ¬¥/|\`
     * ```
     */
    class LightPoint extends Light {
    }
    FudgeCore.LightPoint = LightPoint;
    /**
     * Spot light emitting within a specified angle from its position, illuminating objects depending on their position and distance with its color
     * Attached to a node by {@link ComponentLight}, the pivot matrix specifies the position of the light, the direction and the size and angles of the cone.
     * The intensity of the light drops linearly from 1 in the center to 0 at the outer limits of the cone.
     * ```text
     *          o
     *         /|\
     *        / | \
     * ```
     */
    class LightSpot extends Light {
    }
    FudgeCore.LightSpot = LightSpot;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Light/Light.ts"/>
var FudgeCore;
///<reference path="../Light/Light.ts"/>
(function (FudgeCore) {
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export let LIGHT_TYPE: { [type: string]: string } = {
    let LIGHT_TYPE;
    (function (LIGHT_TYPE) {
        LIGHT_TYPE["AMBIENT"] = "LightAmbient";
        LIGHT_TYPE["DIRECTIONAL"] = "LightDirectional";
        LIGHT_TYPE["POINT"] = "LightPoint";
        LIGHT_TYPE["SPOT"] = "LightSpot";
    })(LIGHT_TYPE = FudgeCore.LIGHT_TYPE || (FudgeCore.LIGHT_TYPE = {}));
    /**
      * Attaches a {@link Light} to the node
      * The pivot matrix has different effects depending on the type of the {@link Light}. See there for details.
      * @authors Jirka Dell'Oro-Friedl, HFU, 2019
      */
    class ComponentLight extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentLight); }
        //TODO: since there is almost no functionality left in Light, eliminate it and put all in the component as with the camera...
        constructor(_light = new FudgeCore.LightAmbient()) {
            super();
            // private static constructors: { [type: string]: General } = { [LIGHT_TYPE.AMBIENT]: LightAmbient, [LIGHT_TYPE.DIRECTIONAL]: LightDirectional, [LIGHT_TYPE.POINT]: LightPoint, [LIGHT_TYPE.SPOT]: LightSpot };
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.light = null;
            this.singleton = false;
            this.light = _light;
        }
        // TODO: use TypeOfLight as return type?
        /**
         * Set the type of {@link Light} used by this component.
         */
        setType(_class) {
            let mtrOld = {};
            if (this.light)
                mtrOld = this.light.getMutator();
            this.light = new _class();
            this.light.mutate(mtrOld);
        }
        serialize() {
            let serialization = {
                pivot: this.mtxPivot.serialize(),
                light: FudgeCore.Serializer.serialize(this.light)
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxPivot.deserialize(_serialization.pivot);
            this.light = await FudgeCore.Serializer.deserialize(_serialization.light);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.type = this.light.getType().name;
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.type)
                types.type = LIGHT_TYPE;
            return types;
        }
        async mutate(_mutator) {
            let type = _mutator.type;
            if (typeof (type) !== "undefined" && type != this.light.constructor.name)
                this.setType(FudgeCore.Serializer.getConstructor(type));
            delete (_mutator.type); // exclude light type from further mutation
            super.mutate(_mutator);
            _mutator.type = type; // reconstruct mutator
        }
    }
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Material} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019 - 2021
     */
    class ComponentMaterial extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial); }
        // public mutatorCoat: MutatorForComponent;
        constructor(_material = null) {
            super();
            this.clrPrimary = FudgeCore.Color.CSS("white");
            this.clrSecondary = FudgeCore.Color.CSS("white");
            this.mtxPivot = FudgeCore.Matrix3x3.IDENTITY();
            /** Support sorting of objects with transparency when rendering, render objects in the back first. When this component is used as a part of a {@link ParticleSystem}, try enabling this when disabling {@link ComponentParticleSystem.depthMask} */
            this.sortForAlpha = false;
            this.material = _material;
            // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
        }
        //#region Transfer
        serialize() {
            let serialization = {
                sortForAlpha: this.sortForAlpha,
                clrPrimary: this.clrPrimary.serialize(),
                clrSecondary: this.clrSecondary.serialize(),
                pivot: this.mtxPivot.serialize(),
                [super.constructor.name]: super.serialize(),
                idMaterial: this.material.idResource
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.material = await FudgeCore.Project.getResource(_serialization.idMaterial);
            await this.clrPrimary.deserialize(_serialization.clrPrimary);
            await this.clrSecondary.deserialize(_serialization.clrSecondary);
            this.sortForAlpha = _serialization.sortForAlpha;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Mesh} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentMesh extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh); }
        constructor(_mesh, _skeleton) {
            super();
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.mesh = _mesh;
            this.skeleton = _skeleton;
        }
        get radius() {
            let scaling = this.mtxWorld.scaling;
            let scale = Math.max(Math.abs(scaling.x), Math.abs(scaling.y), Math.abs(scaling.z));
            return this.mesh.radius * scale;
        }
        // /**
        //  * Calculates the position of a vertex transformed by the skeleton
        //  * @param _index index of the vertex
        //  */
        // public getVertexPosition(_index: number): Vector3 {
        //   // extract the vertex data (vertices: 3D vectors, bone indices & weights: 4D vectors)
        //   const iVertex: number = _index * 3;
        //   const iBoneInfluence: number = _index * 4;
        //   const vertex: Vector3 = new Vector3(...Reflect.get(this.mesh, "renderMesh").vertices.slice(iVertex, iVertex + 3));
        //   if (!(this.mesh instanceof MeshSkin)) return vertex;
        //   const iBones: Uint8Array = this.mesh.iBones.slice(iBoneInfluence, iBoneInfluence + 4);
        //   const weights: Float32Array = this.mesh.weights.slice(iBoneInfluence, iBoneInfluence + 4);
        //   // get bone matrices
        //   const mtxBones: Array<Matrix4x4> = this.skeleton.mtxBones;
        //   // skin matrix S = sum_i=1^m{w_i * B_i}
        //   const skinMatrix: Matrix4x4 = new Matrix4x4();
        //   skinMatrix.set(Array
        //     .from(iBones)
        //     .map((iBone, iWeight) => mtxBones[iBone].get().map(value => value * weights[iWeight])) // apply weight on each matrix
        //     .reduce((mtxSum, mtxBone) => mtxSum.map((value, index) => value + mtxBone[index])) // sum up the matrices
        //   );
        //   // transform vertex
        //   vertex.transform(skinMatrix);
        //   return vertex;
        // }
        // TODO: remove or think if the transformed bounding box is of value or can be made to be
        // public get boundingBox(): Box {
        //   let box: Box = Recycler.get(Box);
        //   box.set(
        //     Vector3.TRANSFORMATION(this.mesh.boundingBox.min, this.mtxWorld, true),
        //     Vector3.TRANSFORMATION(this.mesh.boundingBox.max, this.mtxWorld, true)
        //   );
        //   return box;
        // }
        //#region Transfer
        serialize() {
            let serialization;
            /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
            let idMesh = this.mesh.idResource;
            if (idMesh)
                serialization = { idMesh: idMesh };
            else
                serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
            if (this.skeleton)
                serialization.skeleton = FudgeCore.Node.PATH_FROM_TO(this, this.skeleton);
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            let mesh;
            if (_serialization.idMesh)
                mesh = await FudgeCore.Project.getResource(_serialization.idMesh);
            else
                mesh = await FudgeCore.Serializer.deserialize(_serialization.mesh);
            this.mesh = mesh;
            if (_serialization.skeleton) {
                const hndNodeDeserialized = () => {
                    const hndGraphDeserialized = () => {
                        this.skeleton = FudgeCore.Node.FIND(this, _serialization.skeleton);
                        this.node.removeEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized);
                        this.node.removeEventListener("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */, hndGraphDeserialized);
                        this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                    };
                    this.node.addEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                    this.node.addEventListener("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */, hndGraphDeserialized, true);
                };
                this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
            }
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutatorForUserInterface() {
            let mutator = this.getMutator();
            // if (!this.mesh)
            //   mutator.mesh = Mesh;
            return mutator;
        }
    }
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var ComponentParticleSystem_1;
    let PARTICLE_SYSTEM_PLAYMODE;
    (function (PARTICLE_SYSTEM_PLAYMODE) {
        /**Plays particle system in a loop: it restarts once it hit the end.*/
        PARTICLE_SYSTEM_PLAYMODE[PARTICLE_SYSTEM_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays particle system once and stops at the last point in time.*/
        PARTICLE_SYSTEM_PLAYMODE[PARTICLE_SYSTEM_PLAYMODE["PLAY_ONCE"] = 1] = "PLAY_ONCE";
    })(PARTICLE_SYSTEM_PLAYMODE = FudgeCore.PARTICLE_SYSTEM_PLAYMODE || (FudgeCore.PARTICLE_SYSTEM_PLAYMODE = {}));
    /**
     * Attaches a {@link ParticleSystem} to the node.
     * Works in conjunction with {@link ComponentMesh} and {@link ComponentMaterial} to create a shader particle system.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the particles face the camera.
     * @author Jonas Plotzky, HFU, 2022
     */
    let ComponentParticleSystem = class ComponentParticleSystem extends FudgeCore.Component {
        static { ComponentParticleSystem_1 = this; }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentParticleSystem_1); }
        /** The number of particles */
        #size;
        #timeScale;
        #time;
        constructor(_particleSystem = null) {
            super();
            this.#timeScale = 1;
            //#endregion
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "nodeDeserialized" /* EVENT.NODE_DESERIALIZED */:
                    case "componentAdd" /* EVENT.COMPONENT_ADD */:
                        FudgeCore.Time.game.addEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateTimeScale);
                        this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update);
                        break;
                    case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                        FudgeCore.Time.game.removeEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateTimeScale);
                        this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update);
                }
            };
            this.update = () => {
                if (this.time > this.duration)
                    switch (this.playMode) {
                        default:
                        case PARTICLE_SYSTEM_PLAYMODE.LOOP:
                            this.time = 0;
                            break;
                        case PARTICLE_SYSTEM_PLAYMODE.PLAY_ONCE:
                            this.time = this.duration;
                            this.timeScale = 0;
                            break;
                    }
            };
            this.updateTimeScale = () => {
                let timeScale = this.#timeScale * FudgeCore.Time.game.getScale();
                this.#time.setScale(timeScale);
            };
            this.particleSystem = _particleSystem;
            this.depthMask = true;
            this.blendMode = FudgeCore.BLEND.ADDITIVE;
            this.playMode = PARTICLE_SYSTEM_PLAYMODE.LOOP;
            this.duration = 1000;
            this.size = 10;
            this.#time = new FudgeCore.Time();
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
            this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, this.hndEvent);
        }
        /**
         * Get the number of particles
         */
        get size() {
            return this.#size;
        }
        /**
         * Set the number of particles. Caution: Setting this will reinitialize the random numbers array(texture) used in the shader.
         */
        set size(_size) {
            this.#size = _size;
            this.deleteRenderData();
        }
        get time() {
            return this.#time.get();
        }
        set time(_time) {
            this.#time.set(_time);
        }
        get timeScale() {
            return this.#timeScale;
        }
        set timeScale(_scale) {
            this.#timeScale = _scale;
            this.updateTimeScale();
        }
        /**
         * Generates and binds the random numbers texture in WebGL
         * Injected by {@link RenderInjectorComponentParticleSystem}. Used by the render system.
         * @internal
         */
        useRenderData() { }
        /**
         * Deletes the random numbers texture in WebGL freeing the allocated gpu memory.
         * Injected by {@link RenderInjectorComponentParticleSystem}.
         * @internal
         */
        deleteRenderData() { }
        //#region transfer
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize(),
                idParticleSystem: this.particleSystem?.idResource,
                depthMask: this.depthMask,
                blendMode: this.blendMode,
                playMode: this.playMode,
                duration: this.duration,
                size: this.size
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            if (_serialization.idParticleSystem)
                this.particleSystem = await FudgeCore.Project.getResource(_serialization.idParticleSystem);
            this.depthMask = _serialization.depthMask;
            this.blendMode = _serialization.blendMode;
            this.playMode = _serialization.playMode;
            this.duration = _serialization.duration;
            this.size = _serialization.size;
            return this;
        }
        getMutator(_extendable) {
            let mutator = super.getMutator(true);
            mutator.size = this.size;
            return mutator;
        }
        getMutatorForUserInterface() {
            let mutator = this.getMutator(true);
            delete mutator.particleSystem;
            mutator.particleSystem = this.particleSystem?.getMutatorForUserInterface();
            return mutator;
        }
        getMutatorForAnimation() {
            let mutator = this.getMutator();
            delete mutator.particleSystem;
            delete mutator.size;
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.blendMode)
                types.blendMode = FudgeCore.BLEND;
            if (types.playMode)
                types.playMode = PARTICLE_SYSTEM_PLAYMODE;
            return types;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.randomNumbersRenderData;
            delete _mutator.time;
        }
    };
    ComponentParticleSystem = ComponentParticleSystem_1 = __decorate([
        FudgeCore.RenderInjectorComponentParticleSystem.decorate
    ], ComponentParticleSystem);
    FudgeCore.ComponentParticleSystem = ComponentParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let PICK;
    (function (PICK) {
        PICK["RADIUS"] = "radius";
        PICK["CAMERA"] = "camera";
        PICK["PHYSICS"] = "physics";
    })(PICK = FudgeCore.PICK || (FudgeCore.PICK = {}));
    /**
     * Attaches picking functionality to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class ComponentPick extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pick = PICK.RADIUS;
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentPick); }
        /**
         * Picks the node according to the given {@link Ray} and invokes events accordingly
         */
        pickAndDispatch(_ray, _event) {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let position = cmpMesh ? cmpMesh.mtxWorld.translation : this.node.mtxWorld.translation;
            switch (this.pick) {
                case PICK.RADIUS:
                    // TODO: should only be node.radius. Adjustment needed, if mesh was transformed...
                    if (_ray.getDistance(position).magnitude < this.node.radius) {
                        this.node.dispatchEvent(_event);
                    }
                    break;
                case PICK.PHYSICS:
                    let hitInfo = FudgeCore.Physics.raycast(_ray.origin, _ray.direction, FudgeCore.Vector3.DIFFERENCE(position, _ray.origin).magnitudeSquared);
                    if (hitInfo.hit)
                        this.node.dispatchEvent(_event);
                    break;
                //TODO: PICK.CAMERA
            }
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.pick)
                types.pick = PICK;
            return types;
        }
    }
    FudgeCore.ComponentPick = ComponentPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentScript extends FudgeCore.Component {
        // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
        // TODO: rethink & refactor
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript); }
        constructor() {
            super();
            this.singleton = false;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the bone data from the {@link ComponentSkeleton} into a WebGL Buffer
     * @internal
     */
    class RenderInjectorComponentSkeleton {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffer", {
                value: RenderInjectorComponentSkeleton.useRenderBuffer
            });
            Object.defineProperty(_constructor.prototype, "updateRenderBuffer", {
                value: RenderInjectorComponentSkeleton.updateRenderBuffer
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffer", {
                value: RenderInjectorComponentSkeleton.deleteRenderBuffer
            });
        }
        static useRenderBuffer(_shader) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderBuffer)
                crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCKS.SKIN.BINDING, this.renderBuffer);
        }
        static updateRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (!this.renderBuffer) {
                const bonesByteSize = 256 * 16 * 4; // CAUTION: this is dependent on the shader source code where 256 is the maximum number of bones
                this.renderBuffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.renderBuffer);
                crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, bonesByteSize, WebGL2RenderingContext.DYNAMIC_DRAW);
            }
            const data = new Float32Array(this.mtxBones.length * 16);
            for (let i = 0; i < this.mtxBones.length; i++)
                data.set(this.mtxBones[i].get(), i * 16);
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.renderBuffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, data);
        }
        static deleteRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderBuffer)
                crc3.deleteBuffer(this.renderBuffer);
        }
    }
    FudgeCore.RenderInjectorComponentSkeleton = RenderInjectorComponentSkeleton;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./../Render/RenderInjectorComponentSkeleton.ts"/>
var FudgeCore;
///<reference path="./../Render/RenderInjectorComponentSkeleton.ts"/>
(function (FudgeCore) {
    var ComponentSkeleton_1;
    /**
     * Holds an array of bones ({@link Node}s within a {@link Graph}). Referenced from a {@link ComponentMesh} it can be associated with a {@link MeshSkin} and enable skinning for the mesh.
     * @authors Matthias Roming, HFU, 2022-2023 | Jonas Plotzky, HFU, 2023
     */
    let ComponentSkeleton = ComponentSkeleton_1 = class ComponentSkeleton extends FudgeCore.Component {
        constructor(_bones = [], _mtxBoneInverses = []) {
            super();
            this.singleton = false;
            /** Contains the bone transformations applicable to the vertices of a {@link MeshSkin} */
            this.mtxBones = [];
            this.bones = _bones;
            this.mtxBindInverses = _mtxBoneInverses;
            for (let i = 0; i < this.bones.length; i++)
                if (this.mtxBindInverses[i] == null)
                    this.mtxBindInverses[i] = this.bones[i].mtxWorldInverse.clone;
        }
        /**
         * Injected by {@link RenderInjectorComponentSkeleton}.
         * Used by the render system.
         * @internal
         */
        useRenderBuffer(_shader) { return null; /* injected by RenderInjector*/ }
        /**
         * Injected by {@link RenderInjectorComponentSkeleton}.
         * Used by the render system.
         * @internal
         */
        updateRenderBuffer() { return null; /* injected by RenderInjector*/ }
        /**
         * Injected by {@link RenderInjectorComponentSkeleton}.
         * Used by the render system.
         * @internal
         */
        deleteRenderBuffer() { }
        /**
         * Adds a node as a bone with its bind inverse matrix
         */
        addBone(_bone, _mtxBindInverse = _bone.mtxWorldInverse.clone) {
            this.bones.push(_bone);
            this.mtxBindInverses.push(_mtxBindInverse);
        }
        indexOf(_name) {
            if (typeof (_name) == "string")
                return this.bones.findIndex((_bone) => _bone.name == _name);
            else
                return this.bones.indexOf(_name);
        }
        /**
         * Updates the bone matrices to be used by the shader
         */
        update() {
            for (const mtxBone of this.mtxBones)
                FudgeCore.Recycler.store(mtxBone);
            this.mtxBones.length = 0;
            for (let i = 0; i < this.bones.length; i++) {
                let mtxBone = FudgeCore.Matrix4x4.MULTIPLICATION(this.bones[i].mtxWorld, this.mtxBindInverses[i]);
                this.mtxBones.push(mtxBone);
            }
        }
        /**
         * Resets the pose of this skeleton to the default pose
         */
        resetPose() {
            for (let i = 0; i < this.bones.length; i++)
                this.bones[i].mtxLocal.set(FudgeCore.Matrix4x4.INVERSION(this.mtxBindInverses[i]));
        }
        serialize() {
            const serialization = {};
            serialization[super.constructor.name] = super.serialize();
            serialization.bones = this.bones.map(_bone => FudgeCore.Node.PATH_FROM_TO(this, _bone));
            serialization.mtxBindInverses = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxBindInverses);
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            const hndNodeDeserialized = () => {
                this.bones = _serialization.bones.map((_path) => {
                    let bone = FudgeCore.Node.FIND(this, _path);
                    if (!bone)
                        throw new Error(`${FudgeCore.Node.name} "${this.node.name}" ${ComponentSkeleton_1.name}: Could not find bone ${_path}`);
                    return bone;
                });
                this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
            };
            this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
            this.mtxBindInverses = await FudgeCore.Serializer.deserializeArray(_serialization.mtxBindInverses);
            return this;
        }
    };
    ComponentSkeleton = ComponentSkeleton_1 = __decorate([
        FudgeCore.RenderInjectorComponentSkeleton.decorate
    ], ComponentSkeleton);
    FudgeCore.ComponentSkeleton = ComponentSkeleton;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let BASE;
    (function (BASE) {
        BASE[BASE["SELF"] = 0] = "SELF";
        BASE[BASE["PARENT"] = 1] = "PARENT";
        BASE[BASE["WORLD"] = 2] = "WORLD";
        BASE[BASE["NODE"] = 3] = "NODE";
    })(BASE = FudgeCore.BASE || (FudgeCore.BASE = {}));
    /**
     * Attaches a transform-{@link Matrix4x4} to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentTransform extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform); }
        constructor(_mtxInit = FudgeCore.Matrix4x4.IDENTITY()) {
            super();
            this.mtxLocal = _mtxInit;
        }
        //#region Transformations respecting the hierarchy
        /**
         * recalculates this local matrix to yield the identical world matrix based on the given node.
         * Use rebase before appending the container of this component to another node while preserving its transformation in the world.
         */
        rebase(_node = null) {
            let mtxResult = this.mtxLocal;
            let container = this.node;
            if (container)
                mtxResult = container.mtxWorld;
            if (_node)
                mtxResult = FudgeCore.Matrix4x4.RELATIVE(mtxResult, null, _node.mtxWorldInverse);
            this.mtxLocal = mtxResult;
        }
        /**
         * Applies the given transformation relative to the selected base (SELF, PARENT, WORLD) or a particular other node (NODE)
         */
        transform(_mtxTransform, _base = BASE.SELF, _node = null) {
            switch (_base) {
                case BASE.SELF:
                    this.mtxLocal.multiply(_mtxTransform);
                    break;
                case BASE.PARENT:
                    this.mtxLocal.multiply(_mtxTransform, true);
                    break;
                case BASE.NODE:
                    if (!_node)
                        throw new Error("BASE.NODE requires a node given as base");
                case BASE.WORLD:
                    this.rebase(_node);
                    this.mtxLocal.multiply(_mtxTransform, true);
                    let node = this.node;
                    if (node) {
                        let mtxTemp;
                        if (_base == BASE.NODE) {
                            // fix mtxWorld of container for subsequent rebasing 
                            mtxTemp = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, node.mtxLocal);
                            node.mtxWorld.set(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                        let parent = node.getParent();
                        if (parent) {
                            // fix mtxLocal for current parent
                            this.rebase(node.getParent());
                            mtxTemp = FudgeCore.Matrix4x4.MULTIPLICATION(node.getParent().mtxWorld, node.mtxLocal);
                            node.mtxWorld.set(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                    }
                    break;
            }
        }
        //#endregion
        //#region Transfer
        serialize() {
            let serialization = {
                local: this.mtxLocal.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxLocal.deserialize(_serialization.local);
            return this;
        }
        // public mutate(_mutator: Mutator): void {
        //     this.local.mutate(_mutator);
        // }
        // public getMutator(): Mutator { 
        //     return this.local.getMutator();
        // }
        // public getMutatorAttributeTypes(_mutator: Mutator): MutatorAttributeTypes {
        //     let types: MutatorAttributeTypes = this.local.getMutatorAttributeTypes(_mutator);
        //     return types;
        // }
        reduceMutator(_mutator) {
            delete _mutator.world;
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.ComponentTransform = ComponentTransform;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a VR Controller and its capabilities.
     */
    class VRController {
        constructor() {
            this.cmpTransform = null;
            this.gamePad = null;
            this.thumbstickX = null;
            this.thumbstickY = null;
        }
    }
    FudgeCore.VRController = VRController;
    /**
     * VR Component Class, for Session Management, Controller Management and Reference Space Management.
     * @author Valentin Schmidberger, HFU, 2022
     */
    class ComponentVRDevice extends FudgeCore.ComponentCamera {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentVRDevice); }
        #mtxLocal;
        constructor() {
            super();
            this.rightCntrl = new VRController();
            this.leftCntrl = new VRController();
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.getMtxLocalFromCmpTransform);
        }
        /**
         * Returns the actual matrix of the vr - device.
         * Creators should use this for readonly purposes.
         */
        get mtxLocal() {
            return this.#mtxLocal;
        }
        /**
         * Sets a Vector3 as Position of the reference space.
         */
        set translation(_newPos) {
            let invTranslation = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.DIFFERENCE(_newPos, this.#mtxLocal.translation), -1);
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(invTranslation));
            this.#mtxLocal.translation = _newPos;
        }
        /**
         * Sets Vector3 Rotation of the reference space.
         * Rotation needs to be set in the Origin (0,0,0), otherwise the XR-Rig gets rotated around the origin.
         */
        set rotation(_newRot) {
            let newRot = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.SCALE(FudgeCore.Vector3.SUM(_newRot, this.#mtxLocal.rotation), -1), Math.PI / 180);
            let orientation = new FudgeCore.Quaternion();
            orientation.eulerAngles = newRot;
            //set xr - rig back to origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(this.#mtxLocal.translation, FudgeCore.Vector3.ZERO())));
            //rotate xr rig in origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.ZERO(), orientation));
            //set xr - rig back to last position 
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.ZERO(), this.#mtxLocal.translation)));
            this.#mtxLocal.rotation = FudgeCore.Vector3.SCALE(_newRot, -1);
        }
        /**
         * Adds a Vector3 in Position of the reference space.
         */
        translate(_by) {
            let invTranslation = FudgeCore.Vector3.SCALE(_by, -1);
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(invTranslation));
            this.#mtxLocal.translate(_by);
        }
        /**
         * Adds a Vector3 in Rotation of the reference space.
         * Rotation needs to be added in the Origin (0,0,0), otherwise the XR-Rig gets rotated around the origin.
         */
        rotate(_by) {
            let rotAmount = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.SCALE(_by, -1), Math.PI / 180);
            let orientation = new FudgeCore.Quaternion();
            orientation.eulerAngles = rotAmount;
            //set xr - rig back to origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(this.#mtxLocal.translation, FudgeCore.Vector3.ZERO())));
            //rotate xr rig in origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.ZERO(), orientation));
            //set xr - rig back to last position 
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.ZERO(), this.#mtxLocal.translation)));
            this.#mtxLocal.rotate(FudgeCore.Vector3.SCALE(_by, -1));
        }
        getMtxLocalFromCmpTransform() {
            this.#mtxLocal = this.node.getComponent(FudgeCore.ComponentTransform).mtxLocal;
        }
    }
    FudgeCore.ComponentVRDevice = ComponentVRDevice;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Processes input signals of type number and generates an output signal of the same type using
     * proportional, integral or differential mapping, an amplification factor and a linear dampening/delay
     * ```text
     *         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *         ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      pass through (Proportional)      ‚îÇ
     * Input ‚Üí ‚îÇ ‚Üí ‚îÇamplify‚îÇ ‚Üí ‚îÇdelay‚îÇ ‚Üí ‚öü sum up over time (Integral) ‚öû ‚Üí ‚îÇ ‚Üí Output
     *         ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      pass change  (Differential)      ‚îÇ
     *         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Control extends EventTarget {
        constructor(_name, _factor = 1, _type = 0 /* CONTROL_TYPE.PROPORTIONAL */, _delay = 0) {
            super();
            this.rateDispatchOutput = 0;
            this.valuePrevious = 0;
            this.outputBase = 0;
            this.outputTarget = 0;
            this.outputPrevious = 0;
            this.outputTargetPrevious = 0;
            this.factor = 0;
            this.time = FudgeCore.Time.game;
            this.timeValueDelay = 0;
            this.timeOutputTargetSet = 0;
            this.idTimer = undefined;
            this.dispatchOutput = (_eventOrValue) => {
                if (!this.active)
                    return;
                let timer = this.time.getTimer(this.idTimer);
                let output;
                if (typeof (_eventOrValue) == "number")
                    output = _eventOrValue;
                else
                    output = this.calculateOutput();
                let outputChanged = (output != this.outputPrevious);
                if (timer) {
                    timer.active = outputChanged;
                    if (!outputChanged)
                        return;
                }
                this.outputPrevious = output;
                let event = new CustomEvent("output" /* EVENT_CONTROL.OUTPUT */, {
                    detail: {
                        output: output
                    }
                });
                this.dispatchEvent(event);
            };
            this.factor = _factor;
            this.type = _type;
            this.active = true;
            this.name = _name;
            this.setDelay(_delay);
        }
        /**
         * Set the time-object to be used when calculating the output in {@link CONTROL_TYPE.INTEGRAL}
         */
        setTimebase(_time) {
            this.time = _time;
            this.calculateOutput();
        }
        /**
         * Feed an input value into this control and fire the events {@link EVENT_CONTROL.INPUT} and {@link EVENT_CONTROL.OUTPUT}
         */
        setInput(_input) {
            if (!this.active)
                return;
            this.outputBase = this.calculateOutput();
            this.valuePrevious = this.getValueDelayed();
            this.outputTarget = this.factor * _input;
            this.timeOutputTargetSet = this.time.get();
            if (this.type == 2 /* CONTROL_TYPE.DIFFERENTIAL */) {
                this.valuePrevious = this.outputTarget - this.outputTargetPrevious;
                this.outputTargetPrevious = this.outputTarget;
                this.outputTarget = 0;
            }
            this.dispatchEvent(new Event("input" /* EVENT_CONTROL.INPUT */));
            if (this.type == 2 /* CONTROL_TYPE.DIFFERENTIAL */)
                this.dispatchOutput(this.valuePrevious);
            else
                this.dispatchOutput(null);
        }
        /**
         * TODO: describe!
         */
        pulse(_input) {
            this.setInput(_input);
            this.setInput(0);
        }
        /**
         * Set the time to take for the internal linear dampening until the final ouput value is reached
         */
        setDelay(_time) {
            this.timeValueDelay = Math.max(0, _time);
        }
        /**
         * Set the number of output-events to dispatch per second.
         * At the default of 0, the control output must be polled and will only actively dispatched once each time input occurs and the output changes.
         */
        setRateDispatchOutput(_rateDispatchOutput = 0) {
            this.rateDispatchOutput = _rateDispatchOutput;
            this.time.deleteTimer(this.idTimer);
            this.idTimer = undefined;
            if (this.rateDispatchOutput)
                this.idTimer = this.time.setTimer(1000 / this.rateDispatchOutput, 0, this.dispatchOutput);
        }
        /**
         * Set the factor to multiply the input value given with {@link setInput} with
         */
        setFactor(_factor) {
            this.factor = _factor;
        }
        /**
         * Get the value from the output of this control
         */
        getOutput() {
            return this.calculateOutput();
        }
        /**
         * Calculates the output of this control
         */
        calculateOutput() {
            let output = 0;
            let value = this.getValueDelayed();
            switch (this.type) {
                case 1 /* CONTROL_TYPE.INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeOutputTargetSet;
                    output = this.outputBase;
                    if (this.timeValueDelay > 0) {
                        if (timeElapsedSinceInput < this.timeValueDelay) {
                            output += 0.5 * (this.valuePrevious + value) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            output += 0.5 * (this.valuePrevious + value) * this.timeValueDelay;
                            timeElapsedSinceInput -= this.timeValueDelay;
                        }
                    }
                    output += value * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* CONTROL_TYPE.DIFFERENTIAL */:
                case 0 /* CONTROL_TYPE.PROPORTIONAL */:
                default:
                    output = value;
                    break;
            }
            return output;
        }
        /**
         * calculates the output considering the time of the delay
         */
        getValueDelayed() {
            if (this.timeValueDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeOutputTargetSet;
                if (timeElapsedSinceInput < this.timeValueDelay)
                    return this.valuePrevious + (this.outputTarget - this.valuePrevious) * timeElapsedSinceInput / this.timeValueDelay;
            }
            return this.outputTarget;
        }
    }
    FudgeCore.Control = Control;
})(FudgeCore || (FudgeCore = {}));
///<reference path="Control.ts"/>
var FudgeCore;
///<reference path="Control.ts"/>
(function (FudgeCore) {
    /**
     * Handles multiple controls as inputs and creates an output from that.
     * As a subclass of {@link Control}, axis calculates the ouput summing up the inputs and processing the result using its own settings.
     * Dispatches {@link EVENT_CONTROL.OUTPUT} and {@link EVENT_CONTROL.INPUT} when one of the controls dispatches them.
     * ```text
     *           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ\                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò \                               ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  \‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ---‚îÇsum‚îÇ ‚Üí ‚îÇinternal control ‚îÇ ‚Üí ‚îÇ ‚Üí Output
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  /‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê /                               ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ/                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
     *           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Axis extends FudgeCore.Control {
        constructor() {
            super(...arguments);
            this.controls = new Map();
            this.sumPrevious = 0;
            this.hndOutputEvent = (_event) => {
                if (!this.active)
                    return;
                let control = _event.target;
                let event = new CustomEvent("output" /* EVENT_CONTROL.OUTPUT */, {
                    detail: {
                        control: control,
                        input: _event.detail.output,
                        output: this.getOutput()
                    }
                });
                this.dispatchEvent(event);
            };
            this.hndInputEvent = (_event) => {
                if (!this.active)
                    return;
                let event = new Event("input" /* EVENT_CONTROL.INPUT */, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Add the control given to the list of controls feeding into this axis
         */
        addControl(_control) {
            this.controls.set(_control.name, _control);
            _control.addEventListener("input" /* EVENT_CONTROL.INPUT */, this.hndInputEvent);
            _control.addEventListener("output" /* EVENT_CONTROL.OUTPUT */, this.hndOutputEvent);
        }
        /**
         * Returns the control with the given name
         */
        getControl(_name) {
            return this.controls.get(_name);
        }
        /**
         * Removes the control with the given name
         */
        removeControl(_name) {
            let control = this.getControl(_name);
            if (control) {
                control.removeEventListener("input" /* EVENT_CONTROL.INPUT */, this.hndInputEvent);
                control.removeEventListener("output" /* EVENT_CONTROL.OUTPUT */, this.hndOutputEvent);
                this.controls.delete(_name);
            }
        }
        /**
         * Returns the value of this axis after summing up all inputs and processing the sum according to the axis' settings
         */
        getOutput() {
            let sumInput = 0;
            for (let control of this.controls) {
                if (control[1].active)
                    sumInput += control[1].getOutput();
            }
            if (sumInput != this.sumPrevious)
                super.setInput(sumInput);
            this.sumPrevious = sumInput;
            return super.getOutput();
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Collects the keys pressed on the keyboard and stores their status.
     */
    class Keyboard {
        static { this.keysPressed = Keyboard.initialize(); }
        // private static code_en: Object;
        /**
         * Returns true if one of the given keys is is currently being pressed.
         */
        static isPressedOne(_keys) {
            for (let code of _keys) {
                if (Keyboard.keysPressed[code])
                    return true;
            }
            return false;
        }
        /**
         * Returns true if all of the given keys are currently being pressed
         */
        static isPressedCombo(_keys) {
            for (let code of _keys) {
                if (!Keyboard.keysPressed[code])
                    return false;
            }
            return true;
        }
        /**
         * Returns the value given as _active if one or, when _combo is true, all of the given keys are pressed.
         * Returns the value given as _inactive if not.
         */
        static mapToValue(_active, _inactive, _keys, _combo = false) {
            if (!_combo && Keyboard.isPressedOne(_keys))
                return _active;
            if (Keyboard.isPressedCombo(_keys))
                return _active;
            return _inactive;
        }
        /**
         * Returns a balanced ternary value (either -1, 0 or 1)
         * according to the match of the keys currently being pressed and the lists of keys given
         */
        static mapToTrit(_positive, _negative) {
            return Keyboard.mapToValue(-1, 0, _negative) + Keyboard.mapToValue(1, 0, _positive);
        }
        // public static locale(_keyboard: Object): void {
        //   if (!Keyboard.code_en) {
        //     // save original keyboard codes to be able to switch back later
        //     Keyboard.code_en = {};
        //     Object.assign(Keyboard.code_en, KEYBOARD_CODE);
        //   }
        //   for (let key in _keyboard) {
        //     let value: string = Reflect.get(_keyboard, key);
        //     for (let original in KEYBOARD_CODE)
        //       if (Reflect.get(KEYBOARD_CODE, original) == value)
        //         // remove original key the yields the value
        //         Reflect.deleteProperty(KEYBOARD_CODE, original);
        //     // add new key to yield that value
        //     Reflect.set(KEYBOARD_CODE, key, value);
        //   }
        // }
        static initialize() {
            let store = {};
            document.addEventListener("keydown", Keyboard.hndKeyInteraction);
            document.addEventListener("keyup", Keyboard.hndKeyInteraction);
            return store;
        }
        static hndKeyInteraction(_event) {
            Keyboard.keysPressed[_event.code] = (_event.type == "keydown");
        }
    }
    FudgeCore.Keyboard = Keyboard;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    class DebugAlert extends FudgeCore.DebugTarget {
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
        }; }
        /**
         * Returns a delegate-function expecting a message to log.
         */
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                let args = _args.map(_arg => _arg.toString());
                let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                alert(out);
            };
            return delegate;
        }
    }
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    class DebugTextArea extends FudgeCore.DebugTarget {
        static { this.textArea = document.createElement("textarea"); }
        static { this.autoScroll = true; }
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
            [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd,
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
        }; }
        static { this.groups = []; }
        /**
         * Clears the text area and the groups
         */
        static clear() {
            DebugTextArea.textArea.textContent = "";
            DebugTextArea.groups = [];
        }
        /**
         * Begins a new group with the given name
         */
        static group(_name) {
            DebugTextArea.print("‚ñº " + _name);
            DebugTextArea.groups.push(_name);
        }
        /**
         * Ends the last group
         */
        static groupEnd() {
            DebugTextArea.groups.pop();
        }
        /**
         * Returns a delegate-function expecting a message to log.
         */
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
            };
            return delegate;
        }
        static getIndentation(_level) {
            let result = "";
            for (let i = 0; i < _level; i++)
                result += "| ";
            return result;
        }
        static print(_text) {
            DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
            if (DebugTextArea.autoScroll)
                DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
        }
    }
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    let KEYBOARD_CODE_DE;
    (function (KEYBOARD_CODE_DE) {
        KEYBOARD_CODE_DE["Z"] = "KeyY";
        KEYBOARD_CODE_DE["Y"] = "KeyZ";
        KEYBOARD_CODE_DE["\u00D6"] = "Semicolon";
        KEYBOARD_CODE_DE["\u00C4"] = "Quote";
        KEYBOARD_CODE_DE["\u00DC"] = "BracketLeft";
        KEYBOARD_CODE_DE["HASH"] = "Backslash";
        KEYBOARD_CODE_DE["PLUS"] = "BracketRight";
        // eslint-disable-next-line 
        KEYBOARD_CODE_DE["\u00DF"] = "Minus";
        KEYBOARD_CODE_DE["ACUTE"] = "Equal";
        KEYBOARD_CODE_DE["LESS_THAN"] = "IntlBackSlash";
        KEYBOARD_CODE_DE["MINUS"] = "Slash";
    })(KEYBOARD_CODE_DE = FudgeCore.KEYBOARD_CODE_DE || (FudgeCore.KEYBOARD_CODE_DE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An event that represents a call from a {@link Timer}
     */
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* EVENT_TIMER.CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Custom touch events
     */
    let EVENT_TOUCH;
    (function (EVENT_TOUCH) {
        /** custom event fired in addition to the standard touchmove, details offset to starting touch */
        EVENT_TOUCH["MOVE"] = "touchMove";
        /** custom event fired when the touches haven't moved outside of the tap radius */
        EVENT_TOUCH["TAP"] = "touchTap";
        /** custom event fired when the touches have moved outside of the notch radius, details offset and cardinal direction */
        EVENT_TOUCH["NOTCH"] = "touchNotch";
        /** custom event fired when the touches haven't moved outside of the tap radius for some time */
        EVENT_TOUCH["LONG"] = "touchLong";
        /** custom event fired when two taps were detected in short succession */
        EVENT_TOUCH["DOUBLE"] = "touchDouble";
        /** custom event fired when the distance between the only two touches changes beyond a tolerance */
        EVENT_TOUCH["PINCH"] = "touchPinch";
        /** custom event not implemented yet */
        EVENT_TOUCH["ROTATE"] = "touchRotate";
    })(EVENT_TOUCH = FudgeCore.EVENT_TOUCH || (FudgeCore.EVENT_TOUCH = {}));
    /**
     * Dispatches CustomTouchEvents to the EventTarget given with the constructor.
     * When using touch events, make sure to set `touch-action: none` in CSS
     * @author Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class TouchEventDispatcher {
        constructor(_target, _radiusTap = 5, _radiusNotch = 50, _timeDouble = 200, _timerLong = 1000) {
            this.posStart = FudgeCore.Vector2.ZERO();
            this.posNotch = FudgeCore.Vector2.ZERO();
            this.posPrev = FudgeCore.Vector2.ZERO();
            this.moved = false;
            this.time = new FudgeCore.Time();
            this.pinchDistance = 0;
            this.pinchTolerance = 1;
            this.hndEvent = (_event) => {
                _event.preventDefault();
                let touchFirst = _event.touches[0];
                let position = this.calcAveragePosition(_event.touches); //new Vector2(touchFirst?.clientX, touchFirst?.clientY);
                let offset;
                switch (_event.type) {
                    case "touchstart":
                        this.moved = false;
                        this.startGesture(position);
                        if (_event.touches.length == 2) {
                            // reset pinch
                            let pinch = new FudgeCore.Vector2(_event.touches[1].clientX - touchFirst.clientX, _event.touches[1].clientY - touchFirst.clientY);
                            this.pinchDistance = pinch.magnitude;
                        }
                        let dispatchLong = (_eventTimer) => {
                            this.moved = true;
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.LONG, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        };
                        this.timerLong?.clear();
                        this.timerLong = new FudgeCore.Timer(this.time, this.timeLong, 1, dispatchLong);
                        break;
                    case "touchend":
                        this.timerLong?.clear();
                        if (_event.touches.length > 0) {
                            // still touches active
                            this.startGesture(position);
                            break;
                        }
                        let dispatchTap = (_eventTimer) => {
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.TAP, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        };
                        // check if there was a tap before and timer is still running -> double tap
                        if (this.timerDouble?.active) {
                            this.timerDouble.clear();
                            // this.timer = undefined;
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.DOUBLE, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        }
                        else if (!this.moved)
                            // check if there was movement, otherwise set timer to fire tap
                            this.timerDouble = new FudgeCore.Timer(this.time, this.timeDouble, 1, dispatchTap);
                        break;
                    case "touchmove":
                        this.detectPinch(_event, position);
                        offset = FudgeCore.Vector2.DIFFERENCE(this.posPrev, this.posStart);
                        this.moved ||= (offset.magnitude < this.radiusTap); // remember that touch moved over tap radius
                        let movement = FudgeCore.Vector2.DIFFERENCE(position, this.posPrev);
                        this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.MOVE, {
                            bubbles: true, detail: { position: position, touches: _event.touches, offset: offset, movement: movement }
                        }));
                        // fire notch when touches moved out of notch radius and reset notch
                        offset = FudgeCore.Vector2.DIFFERENCE(position, this.posNotch);
                        if (offset.magnitude > this.radiusNotch) {
                            let cardinal = Math.abs(offset.x) > Math.abs(offset.y) ?
                                FudgeCore.Vector2.X(offset.x < 0 ? -1 : 1) :
                                FudgeCore.Vector2.Y(offset.y < 0 ? -1 : 1);
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.NOTCH, {
                                bubbles: true, detail: { position: position, touches: _event.touches, offset: offset, cardinal: cardinal, movement: movement }
                            }));
                            this.posNotch = position;
                        }
                        //TODO: pinch, rotate...
                        break;
                    default:
                        break;
                }
                this.posPrev.set(position.x, position.y);
            };
            this.detectPinch = (_event, _position) => {
                if (_event.touches.length != 2)
                    return;
                let t = _event.touches;
                let pinch = new FudgeCore.Vector2(t[1].clientX - t[0].clientX, t[1].clientY - t[0].clientY);
                let pinchDistance = pinch.magnitude;
                let pinchDelta = pinchDistance - this.pinchDistance;
                if (Math.abs(pinchDelta) > this.pinchTolerance)
                    this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.PINCH, {
                        bubbles: true, detail: { position: _position, touches: _event.touches, pinch: pinch, pinchDelta: pinchDelta }
                    }));
                this.pinchDistance = pinchDistance;
            };
            this.target = _target;
            this.radiusTap = _radiusTap;
            this.radiusNotch = _radiusNotch;
            this.timeDouble = _timeDouble;
            this.timeLong = _timerLong;
            this.activate(true);
        }
        /**
         * De-/Activates the dispatch of CustomTouchEvents
         */
        activate(_on) {
            if (_on) {
                this.target.addEventListener("touchstart", this.hndEvent);
                this.target.addEventListener("touchend", this.hndEvent);
                this.target.addEventListener("touchmove", this.hndEvent);
                return;
            }
            this.target.removeEventListener("touchstart", this.hndEvent);
            this.target.removeEventListener("touchend", this.hndEvent);
            this.target.removeEventListener("touchmove", this.hndEvent);
        }
        startGesture(_position) {
            this.posNotch.set(_position.x, _position.y);
            this.posStart.set(_position.x, _position.y);
        }
        calcAveragePosition(_touches) {
            let average = FudgeCore.Vector2.ZERO();
            for (let touch of _touches) {
                average.x += touch.clientX;
                average.y += touch.clientY;
            }
            average.scale(1 / _touches.length);
            return average;
        }
    }
    FudgeCore.TouchEventDispatcher = TouchEventDispatcher;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by {@link Project} that functions as a template for {@link GraphInstance}s
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class Graph extends FudgeCore.Node {
        // #syncing: boolean = false;
        constructor(_name = "Graph") {
            super(_name);
            this.idResource = undefined;
            this.type = "Graph";
            this.hndMutate = async (_event) => {
                // TODO: if path contains a graph instance below this, don't dispatch!
                // let path: Node[] = Reflect.get(_event, "path");
                // for (let node of path)
                //   if (node instanceof GraphInstance && node.idSource != this.idResource)
                //     return;
                // console.log("Graph mutates", this.name);
                // this.#syncing = true;
                _event.detail.path = Reflect.get(_event, "path"); // save path to target in detail
                this.dispatchEvent(new CustomEvent("mutateGraph" /* EVENT.MUTATE_GRAPH */, { detail: _event.detail }));
                // this.dispatchEvent(new Event(EVENT.MUTATE_INSTANCE));
                // this.#syncing = false;
            };
            this.addEventListener("mutate" /* EVENT.MUTATE */, this.hndMutate);
        }
        serialize() {
            let serialization = super.serialize();
            serialization.idResource = this.idResource;
            serialization.type = this.type;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            FudgeCore.Project.register(this, _serialization.idResource);
            await FudgeCore.Project.resyncGraphInstances(this);
            this.broadcastEvent(new Event("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */));
            console.log("Deserialized", this.name);
            return this;
        }
    }
    FudgeCore.Graph = Graph;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let SYNC;
    (function (SYNC) {
        SYNC[SYNC["READY"] = 0] = "READY";
        SYNC[SYNC["GRAPH_SYNCED"] = 1] = "GRAPH_SYNCED";
        SYNC[SYNC["GRAPH_DONE"] = 2] = "GRAPH_DONE";
        SYNC[SYNC["INSTANCE"] = 3] = "INSTANCE";
    })(SYNC || (SYNC = {}));
    /**
     * An instance of a {@link Graph}.
     * This node keeps a reference to its resource an can thus optimize serialization
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class GraphInstance extends FudgeCore.Node {
        /** id of the resource that instance was created from */
        // TODO: examine, if this should be a direct reference to the Graph, instead of the id
        static { this.count = 0; }
        #idSource;
        #sync;
        #deserializeFromSource;
        /**
         * This constructor alone will not create a reconstruction, but only save the id.
         * To create an instance of the graph, call reset on this or set with a graph as parameter.
         * Prefer Project.createGraphInstance(_graph).
         */
        constructor(_graph) {
            super("GraphInstance");
            this.#idSource = undefined;
            this.#sync = SYNC.READY;
            this.#deserializeFromSource = true;
            /**
             * Source graph mutated, reflect mutation in this instance
             */
            this.hndMutationGraph = async (_event) => {
                // console.log("Reflect Graph-Mutation to Instance", SYNC[this.#sync], (<Graph>_event.currentTarget).name, this.getPath().map(_node => _node.name));
                // if (this.#sync != SYNC.READY) {
                //   // console.log("Sync aborted, switch to ready");
                //   this.#sync = SYNC.READY;
                //   return;
                // }
                if (this.isFiltered())
                    return;
                this.#sync = SYNC.GRAPH_SYNCED; // do not sync again, since mutation is already a synchronization
                await this.reflectMutation(_event, _event.currentTarget, this, _event.detail.path);
                this.dispatchEvent(new Event("mutateGraphDone" /* EVENT.MUTATE_INSTANCE */, { bubbles: true }));
            };
            /**
             * This instance mutated, reflect mutation in source graph
             */
            this.hndMutationInstance = async (_event) => {
                // console.log("Reflect Instance-Mutation to Graph", SYNC[this.#sync], this.getPath().map(_node => _node.name), this.get().name);
                // if (this.#sync != SYNC.READY) {
                //   // console.log("Sync aborted, switch to ready");
                //   this.#sync = SYNC.READY;
                //   return;
                // }
                // if (_event.target instanceof GraphInstance && _event.target != this) {
                //   // console.log("Sync aborted, target already synced");
                //   return;
                // }
                if (this.isFiltered())
                    return;
                this.#sync = SYNC.INSTANCE; // do not sync again, since mutation is already a synchronization
                await this.reflectMutation(_event, this, this.get(), Reflect.get(_event, "path"));
                this.get().dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { detail: _event.detail }));
            };
            this.addEventListener("mutate" /* EVENT.MUTATE */, this.hndMutationInstance);
            if (!_graph)
                return;
            this.#idSource = _graph.idResource;
        }
        get idSource() {
            return this.#idSource;
        }
        /**
         * Recreate this node from the {@link Graph} referenced
         */
        async reset() {
            let resource = await FudgeCore.Project.getResource(this.#idSource);
            await this.set(resource);
        }
        //TODO: optimize using the referenced Graph, serialize/deserialize only the differences
        serialize() {
            let filter = this.getComponent(FudgeCore.ComponentGraphFilter);
            let serialization = {};
            if (filter && filter.isActive) // if graph synchronisation is unfiltered, knowing the source is sufficient for serialization
                serialization = super.serialize();
            else
                serialization.deserializeFromSource = true;
            serialization.idSource = this.#idSource;
            return serialization;
        }
        async deserialize(_serialization) {
            this.#idSource = _serialization.idSource ?? _serialization.idResource;
            if (!_serialization.deserializeFromSource) {
                await super.deserialize(_serialization); // instance is deserialized from individual data
                this.#deserializeFromSource = false;
            }
            let graph = this.get();
            if (graph)
                // if (_serialization.deserializeFromSource) // no components-> assume synchronized GraphInstance
                //   await this.set(graph); // recreate complete instance from source graph
                // else {
                await this.connectToGraph(); // otherwise just connect
            // }
            else {
                console.log("Register for resync", _serialization.name, this.name);
                FudgeCore.Project.registerGraphInstanceForResync(this);
            }
            return this;
        }
        /**
         * Connects this graph instance to the graph referenced.
         */
        async connectToGraph() {
            let graph = this.get();
            if (this.#deserializeFromSource)
                await this.set(graph);
        }
        /**
         * Set this node to be a recreation of the {@link Graph} given
         */
        async set(_graph) {
            this.#idSource = _graph.idResource;
            let currentGraph = this.get();
            if (currentGraph) {
                //@ts-ignore
                // console.log("Before Remove", currentGraph.name, this.name, currentGraph.listeners);
                currentGraph.removeEventListener("mutateGraph" /* EVENT.MUTATE_GRAPH */, this.hndMutationGraph);
                //@ts-ignore
                // console.log("After Remove", currentGraph.name, this.name, currentGraph.listeners);
            }
            // TODO: examine, if the serialization should be stored in the Graph for optimization <- also useful for sync with instances
            let serialization = FudgeCore.Serializer.serialize(_graph);
            //Serializer.deserialize(serialization);
            for (let path in serialization) {
                await this.deserialize(serialization[path]);
                break;
            }
            console.log(this.name + GraphInstance.count++);
            // graph.addEventListener(EVENT.MUTATE, (_event: CustomEvent) => this.hndMutation, true);
            _graph.addEventListener("mutateGraph" /* EVENT.MUTATE_GRAPH */, this.hndMutationGraph);
            //@ts-ignore
            // console.log("Add", _graph.name, this.name, _graph.listeners);
            // graph.addEventListener(EVENT.MUTATE_GRAPH_DONE, () => { console.log("Done", this.name); /* this.#sync = true; */ });
            //@ts-ignore
            console.log(_graph?.listeners);
            this.broadcastEvent(new Event("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */));
        }
        /**
         * Retrieve the graph this instances refers to
         */
        get() {
            return FudgeCore.Project.resources[this.#idSource];
        }
        // reflect mutation from a source graph or instance to a destination instance or graph
        async reflectMutation(_event, _source, _destination, _path) {
            // console.log("Reflect mutation", _source, _destination);
            for (let node of _path) // iterate up the event path, which may contain regular Nodes or GraphInstances
                if (node instanceof GraphInstance) // until this GraphInstance is found (or no GraphInstance...)
                    if (node == this)
                        break;
                    else {
                        console.log("Sync aborted, target already synced");
                        return;
                    }
            // find the corresponding node in the destination hierarchy
            let index = _path.indexOf(_source);
            for (let i = index - 1; i >= 0; i--) {
                let childIndex = _path[i].getParent().findChild(_path[i]); // get the index of the childnode in the original path
                _destination = _destination.getChild(childIndex); // get the corresponding child in this path
                // TODO: respect index for non-singleton components...
            }
            // mutate the corresponding component in the destination
            let cmpMutate = _destination.getComponent(_event.detail.component.constructor);
            if (cmpMutate)
                await cmpMutate.mutate(_event.detail.mutator, null, false);
        }
        isFiltered() {
            let cmpFilter = this.getComponent(FudgeCore.ComponentGraphFilter);
            return (cmpFilter && cmpFilter.isActive);
        }
    }
    FudgeCore.GraphInstance = GraphInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a {@link Shader} to describe the surface of {@link Mesh}.
     * {@link Material}s reference {@link Coat} and {@link Shader}.
     * The method useRenderData will be injected by {@link RenderInjector} at runtime, extending the functionality of this class to deal with the renderer.
     */
    class Coat extends FudgeCore.Mutable {
        // public name: string = "Coat";
        // protected renderData: { [key: string]: unknown }; // this wasn't used anywhere...
        /**
         * Sets the render-parameters from this and the given material inside the given shader.
         * Injected by {@link RenderInjectorCoat}. Used by the render system.
         * @internal
         */
        useRenderData(_shader, _cmpMaterial) { }
        //#region Transfer
        serialize() {
            return {};
        }
        async deserialize(_serialization) {
            return this;
        }
        reduceMutator(_mutator) {
            delete _mutator.renderData;
        }
    }
    FudgeCore.Coat = Coat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The simplest {@link Coat} providing just a color
     */
    let CoatColored = class CoatColored extends FudgeCore.Coat {
        constructor(_color = new FudgeCore.Color()) {
            super();
            this.color = _color;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.color = this.color.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.color.deserialize(_serialization.color);
            return this;
        }
    };
    CoatColored = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatColored);
    FudgeCore.CoatColored = CoatColored;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The simplest {@link Coat} providing just a color
     */
    let CoatRemissive = class CoatRemissive extends FudgeCore.CoatColored {
        constructor(_color = new FudgeCore.Color(), _diffuse = 1, _specular = 0) {
            super(_color);
            this.diffuse = _diffuse;
            this.specular = _specular;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.color.deserialize(_serialization.color);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            return this;
        }
    };
    CoatRemissive = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatRemissive);
    FudgeCore.CoatRemissive = CoatRemissive;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatTextured = class CoatTextured extends FudgeCore.CoatColored {
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.texture) {
            super(_color);
            this.texture = null;
            this.texture = _texture;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idTexture = this.texture.idResource;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            if (_serialization.idTexture)
                this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
            return this;
        }
    };
    CoatTextured = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatTextured);
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
///<reference path="CoatTextured.ts"/>
var FudgeCore;
///<reference path="CoatTextured.ts"/>
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatRemissiveTextured = class CoatRemissiveTextured extends FudgeCore.CoatTextured {
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.texture, _diffuse = 1, _specular = 0) {
            super(_color, _texture);
            this.diffuse = _diffuse;
            this.specular = _specular;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            return this;
        }
    };
    CoatRemissiveTextured = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatRemissiveTextured);
    FudgeCore.CoatRemissiveTextured = CoatRemissiveTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    class Color extends FudgeCore.Mutable {
        // crc2 only used for converting colors from strings predefined by CSS
        static { this.crc2 = (() => {
            const crc2 = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
            crc2.globalCompositeOperation = "copy";
            return crc2;
        })(); }
        constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
            super();
            this.setNormRGBA(_r, _g, _b, _a);
        }
        // /**
        //  * Returns a hex-code representation, i.e. "#RRGGBBAA", of the given css color keyword.
        //  */
        // public static getHexFromCSSKeyword(_keyword: string): string {
        //   let hex: string = "#";
        //   for (let byte of Color.getBytesRGBAFromCSSKeyword(_keyword))
        //     hex += byte.toString(16).padStart(2, "0");
        //   return hex;
        // }
        /**
         * Returns a {@link Uint8ClampedArray} with the 8-bit color channel values in the order RGBA.
         */
        static getBytesRGBAFromCSSKeyword(_keyword) {
            Color.crc2.fillStyle = _keyword;
            Color.crc2.fillRect(0, 0, 1, 1);
            return Color.crc2.getImageData(0, 0, 1, 1).data;
        }
        /**
         * Returns a new {@link Color} object created from the given css color keyword.
         * Passing an _alpha value will override the alpha value specified in the keyword.
         */
        static CSS(_keyword, _alpha) {
            const bytesRGBA = Color.getBytesRGBAFromCSSKeyword(_keyword);
            // // conserve the input alpha value from keyword when rgba() or hsla() is used, otherwise "rgba(..., 0.3)" results in color.a = ~0.30196 conversion
            // if (_keyword.toLocaleLowerCase().match(/(rgba|hsla)\(.*\)/)) 
            //   _alpha = parseFloat(_keyword.match(/[^,]+(?=\))/)[0]);
            const color = new Color(bytesRGBA[0] / 255, bytesRGBA[1] / 255, bytesRGBA[2] / 255, _alpha ?? bytesRGBA[3] / 255);
            return color;
        }
        // TODO: rename to MULTIPLICATION like in Matarix3x3/Matrix4x4?
        /**
         * Computes and retruns the product of two colors.
         */
        static MULTIPLY(_color1, _color2) {
            return new Color(_color1.r * _color2.r, _color1.g * _color2.g, _color1.b * _color2.b, _color1.a * _color2.a);
        }
        // TODO: rename to setClampedRGBA? Norm is misleading, since it is not normalized but clamped
        /**
         * Clamps the given color channel values bewteen 0 and 1 and sets them.
         */
        setNormRGBA(_r, _g, _b, _a) {
            this.r = Math.min(1, Math.max(0, _r));
            this.g = Math.min(1, Math.max(0, _g));
            this.b = Math.min(1, Math.max(0, _b));
            this.a = Math.min(1, Math.max(0, _a));
        }
        /**
         * Sets this color from the given 8-bit values for the color channels.
         */
        setBytesRGBA(_r, _g, _b, _a) {
            this.setNormRGBA(_r / 255, _g / 255, _b / 255, _a / 255);
        }
        /**
         * Returns a new {@link Float32Array} with the color channel values in the order RGBA.
         */
        getArray() {
            return new Float32Array([this.r, this.g, this.b, this.a]);
        }
        /**
         * Clamps the given color channel values between 0 and 1 and sets them.
         */
        setArrayNormRGBA(_color) {
            this.setNormRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        /**
         * Sets this color from the given {@link Uint8ClampedArray}. Order of the channels is RGBA
         */
        setArrayBytesRGBA(_color) {
            this.setBytesRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        /**
         * Returns a new {@link Uint8ClampedArray} with the color channel values in the order RGBA.
         */
        getArrayBytesRGBA() {
            return new Uint8ClampedArray([this.r * 255, this.g * 255, this.b * 255, this.a * 255]);
        }
        /**
         * Adds the given color to this.
         */
        add(_color) {
            this.r += _color.r;
            this.g += _color.g;
            this.b += _color.b;
            this.a += _color.a;
        }
        /**
         * Returns the css color keyword representing this color.
         */
        getCSS() {
            let bytes = this.getArrayBytesRGBA();
            return `RGBA(${bytes[0]}, ${bytes[1]}, ${bytes[2]}, ${this.a})`;
        }
        /**
         * Returns the hex string representation of this color.
         */
        getHex() {
            let bytes = this.getArrayBytesRGBA();
            let hex = "";
            for (let byte of bytes)
                hex += byte.toString(16).padStart(2, "0");
            return hex;
        }
        /**
         * Sets this color from the given hex string color.
         */
        setHex(_hex) {
            let bytes = this.getArrayBytesRGBA();
            let channel = 0;
            for (let byte in bytes)
                bytes[byte] = parseInt(_hex.substr(channel++ * 2, 2), 16);
            this.setArrayBytesRGBA(bytes);
        }
        /**
         * Set this color to the values given by the color provided
         */
        copy(_color) {
            this.r = _color.r;
            this.g = _color.g;
            this.b = _color.b;
            this.a = _color.a;
        }
        /**
         * Returns a formatted string representation of this color
         */
        toString() {
            return `(r: ${this.r.toFixed(3)}, g: ${this.g.toFixed(3)}, b: ${this.b.toFixed(3)}, a: ${this.a.toFixed(3)})`;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator(true);
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.r}, ${this.g}, ${this.b}, ${this.a}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.r, this.g, this.b, this.a] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a {@link Shader} with a compatible {@link Coat}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Material extends FudgeCore.Mutable {
        #coat;
        constructor(_name, _shader, _coat) {
            super();
            this.idResource = undefined;
            this.name = _name;
            this.shaderType = _shader;
            if (_shader) {
                if (_coat)
                    this.coat = _coat;
                else
                    this.coat = this.createCoatMatchingShader();
            }
            FudgeCore.Project.register(this);
        }
        /**
         * Returns the currently referenced {@link Coat} instance
         */
        get coat() {
            return this.#coat;
        }
        /**
         * Makes this material reference the given {@link Coat} if it is compatible with the referenced {@link Shader}
         */
        set coat(_coat) {
            if (_coat.constructor != this.shaderType.getCoat())
                if (_coat instanceof this.shaderType.getCoat())
                    FudgeCore.Debug.fudge("Coat is extension of Coat required by shader");
                else
                    throw (new Error("Shader and coat don't match"));
            this.#coat = _coat;
        }
        /**
         * Creates a new {@link Coat} instance that is valid for the {@link Shader} referenced by this material
         */
        createCoatMatchingShader() {
            let coat = new (this.shaderType.getCoat())();
            return coat;
        }
        /**
         * Changes the materials reference to the given {@link Shader}, creates and references a new {@link Coat} instance
         * and mutates the new coat to preserve matching properties.
         * @param _shaderType
         */
        setShader(_shaderType) {
            this.shaderType = _shaderType;
            let coat = this.createCoatMatchingShader();
            coat.mutate(this.#coat.getMutator());
            this.coat = coat;
        }
        /**
         * Returns the {@link Shader} referenced by this material
         */
        getShader() {
            return this.shaderType;
        }
        //#region Transfer
        // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
        serialize() {
            let serialization = {
                name: this.name,
                idResource: this.idResource,
                shader: this.shaderType.name,
                coat: FudgeCore.Serializer.serialize(this.#coat)
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.name = _serialization.name;
            FudgeCore.Project.register(this, _serialization.idResource);
            this.shaderType = FudgeCore[_serialization.shader];
            let coat = await FudgeCore.Serializer.deserialize(_serialization.coat);
            this.coat = coat;
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.coat = this.coat.getMutator();
            return mutator;
        }
        reduceMutator(_mutator) {
            // delete _mutator.idResource;
        }
    }
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract class supporting various arithmetical helper functions
     */
    class Calc {
        /** factor multiplied with angle in degrees yields the angle in radian */
        static { this.deg2rad = Math.PI / 180; }
        /** factor multiplied with angle in radian yields the angle in degrees */
        static { this.rad2deg = 1 / Calc.deg2rad; }
        /**
         * Returns one of the values passed in, either _value if within _min and _max or the boundary being exceeded by _value
         */
        static clamp(_value, _min, _max, _isSmaller = (_value1, _value2) => { return _value1 < _value2; }) {
            if (_isSmaller(_value, _min))
                return _min;
            if (_isSmaller(_max, _value))
                return _max;
            return _value;
        }
    }
    FudgeCore.Calc = Calc;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle and vice versa
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Framing
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        /**
         * Sets this framing to the given width and height
         */
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        /**
         * Sets this framing to the given normed width and height
         */
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector2 as polar coordinates
     * ```text
     *  ‚Üï- angle (Angle to the x-axis)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo2 {
        constructor(_angle = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.angle = 0;
            this.set(_angle, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_angle = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.angle = _angle;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `angle: ${this.angle.toPrecision(5)},  magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo2 = Geo2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector3 as geographic coordinates as seen on a globe
     * ```text
     * ‚Üê|‚Üí Longitude (Angle to the z-axis)
     *  ‚Üï- Latitude (Angle to the equator)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo3 {
        constructor(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.latitude = 0;
            this.longitude = 0;
            this.set(_longitude, _latitude, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.latitude = _latitude;
            this.longitude = _longitude;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `longitude: ${this.longitude.toPrecision(5)}, latitude: ${this.latitude.toPrecision(5)}, magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo3 = Geo3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // From http://baagoe.com/en/RandomMusings/javascript/
    // Johannes Baag√∏e <baagoe@baagoe.com>, 2010
    function Mash() {
        let n = 0xefc8249d;
        let mash = function (_data) {
            _data = _data.toString();
            for (let i = 0; i < _data.length; i++) {
                n += _data.charCodeAt(i);
                let h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        // mash.version = 'Mash 0.9';
        return mash;
    }
    FudgeCore.Mash = Mash;
    // From http://baagoe.com/en/RandomMusings/javascript/
    function LFIB4() {
        // George Marsaglia's LFIB4,
        //http://groups.google.com/group/sci.crypt/msg/eb4ddde782b17051
        let args = Array.prototype.slice.call(arguments);
        let k0 = 0, k1 = 58, k2 = 119, k3 = 178;
        let s = [];
        let mash = Mash();
        if (args.length === 0) {
            args = [+new Date()];
        }
        for (let j = 0; j < 256; j++) {
            s[j] = mash(" ");
            s[j] -= mash(" ") * 4.76837158203125e-7; // 2^-21
            if (s[j] < 0) {
                s[j] += 1;
            }
        }
        for (let i = 0; i < args.length; i++) {
            for (let j = 0; j < 256; j++) {
                s[j] -= mash(args[i]);
                s[j] -= mash(args[i]) * 4.76837158203125e-7; // 2^-21
                if (s[j] < 0) {
                    s[j] += 1;
                }
            }
        }
        mash = null;
        let random = function () {
            let x;
            k0 = (k0 + 1) & 255;
            k1 = (k1 + 1) & 255;
            k2 = (k2 + 1) & 255;
            k3 = (k3 + 1) & 255;
            x = s[k0] - s[k1];
            if (x < 0) {
                x += 1;
            }
            x -= s[k2];
            if (x < 0) {
                x += 1;
            }
            x -= s[k3];
            if (x < 0) {
                x += 1;
            }
            return s[k0] = x;
        };
        // random.uint32 = function () {
        //   return random() * 0x100000000 >>> 0; // 2^32
        // };
        // random.fract53 = random;
        // random.version = "LFIB4 0.9";
        // random.args = args;
        return random;
    }
    FudgeCore.LFIB4 = LFIB4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(9); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.recycle();
            this.resetCache();
        }
        //TODO: figure out what this is used for
        /** TODO: describe! */
        static PROJECTION(_width, _height) {
            let mtxResult = new Matrix3x3;
            mtxResult.data.set([
                2 / _width, 0, 0,
                0, -2 / _height, 0,
                -1, 1, 1
            ]);
            return mtxResult;
        }
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            return mtxResult;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector2}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            mtxResult.data.set([
                1, 0, 0,
                0, 1, 0,
                _translate.x, _translate.y, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, sin, 0,
                -sin, cos, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector2}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            mtxResult.data.set([
                _scalar.x, 0, 0,
                0, _scalar.y, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        //#endregion
        /**
         * Computes and returns the product of two passed matrices.
         * @param _mtxLeft The matrix to multiply.
         * @param _mtxRight The matrix to multiply by.
         */
        static MULTIPLICATION(_mtxLeft, _mtxRight) {
            let a00 = _mtxLeft.data[0 * 3 + 0];
            let a01 = _mtxLeft.data[0 * 3 + 1];
            let a02 = _mtxLeft.data[0 * 3 + 2];
            let a10 = _mtxLeft.data[1 * 3 + 0];
            let a11 = _mtxLeft.data[1 * 3 + 1];
            let a12 = _mtxLeft.data[1 * 3 + 2];
            let a20 = _mtxLeft.data[2 * 3 + 0];
            let a21 = _mtxLeft.data[2 * 3 + 1];
            let a22 = _mtxLeft.data[2 * 3 + 2];
            let b00 = _mtxRight.data[0 * 3 + 0];
            let b01 = _mtxRight.data[0 * 3 + 1];
            let b02 = _mtxRight.data[0 * 3 + 2];
            let b10 = _mtxRight.data[1 * 3 + 0];
            let b11 = _mtxRight.data[1 * 3 + 1];
            let b12 = _mtxRight.data[1 * 3 + 2];
            let b20 = _mtxRight.data[2 * 3 + 0];
            let b21 = _mtxRight.data[2 * 3 + 1];
            let b22 = _mtxRight.data[2 * 3 + 2];
            let mtxResult = new Matrix3x3;
            mtxResult.data.set([
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtx The matrix to compute the inverse of.
         */
        static INVERSION(_mtx) {
            let m = _mtx.data;
            let m00 = m[0 * 3 + 0];
            let m01 = m[0 * 3 + 1];
            let m02 = m[0 * 3 + 2];
            let m10 = m[1 * 3 + 0];
            let m11 = m[1 * 3 + 1];
            let m12 = m[1 * 3 + 2];
            let m20 = m[2 * 3 + 0];
            let m21 = m[2 * 3 + 1];
            let m22 = m[2 * 3 + 2];
            let d = 1 /
                (m00 * (m11 * m22 - m21 * m12) -
                    m01 * (m10 * m22 - m12 * m20) +
                    m02 * (m10 * m21 - m11 * m20));
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            mtxResult.data.set([
                d * (m11 * m22 - m21 * m12),
                d * (m02 * m21 - m01 * m22),
                d * (m01 * m12 - m02 * m11),
                d * (m12 * m20 - m10 * m22),
                d * (m00 * m22 - m02 * m20),
                d * (m10 * m02 - m00 * m12),
                d * (m10 * m21 - m20 * m11),
                d * (m20 * m01 - m00 * m21),
                d * (m00 * m11 - m10 * m01) // [8]
            ]);
            return mtxResult;
        }
        /**
         * - get: return a vector representation of the translation {@link Vector2}.
         * **Caution!** Use immediately, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector2(this.data[6], this.data[7]);
            return this.vectors.translation; // .clone;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 6);
            // no full cache reset required
            this.vectors.translation = _translation;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation {@link Vector2}
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngle();
            return this.vectors.rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: return a vector representation of the scale {@link Vector3}.
         * **Caution!** Do not manipulate result, instead create a clone!
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector2(Math.hypot(this.data[0], this.data[1]) * (this.data[0] < 0 ? -1 : 1), Math.hypot(this.data[3], this.data[4]) * (this.data[4] < 0 ? -1 : 1));
            return this.vectors.scaling; // .clone;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        /**
         * Return a copy of this
         */
        get clone() {
            let mtxClone = FudgeCore.Recycler.get(Matrix3x3);
            mtxClone.set(this);
            return mtxClone;
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.data = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            this.resetCache();
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache.
         */
        reset() {
            this.recycle();
        }
        //#region Translation
        /**
         * Add a translation by the given {@link Vector2} to this matrix
         */
        translate(_by) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a translation along the x-Axis by the given amount to this matrix
         */
        translateX(_x) {
            this.data[6] += _x;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateY(_y) {
            this.data[7] += _y;
            this.mutator = null;
            this.vectors.translation = null;
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given {@link Vector2} to this matrix
         */
        scale(_by) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.SCALING(_by));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a scaling along the x-Axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(_by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the y-Axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotate(_angleInDegrees) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.ROTATION(_angleInDegrees));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_mtxRight) {
            let mtxResult = Matrix3x3.MULTIPLICATION(this, _mtxRight);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
            this.mutator = null;
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngle() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s3 = this.data[3] / scaling.y;
            let s4 = this.data[4] / scaling.y;
            let xSkew = Math.atan2(-s3, s4);
            let ySkew = Math.atan2(s0, s1);
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let rotation;
            if (!(sy > 1e-6))
                rotation = ySkew;
            else
                rotation = xSkew;
            rotation *= FudgeCore.Calc.rad2deg;
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_mtxTo) {
            // this.data = _to.get();
            this.data.set(_mtxTo.data);
            this.resetCache();
        }
        /**
         * Returns a formatted string representation of this matrix
         */
        toString() {
            return `∆í.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation,
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: _serialization.rotation,
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector2(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y);
            }
            vectors.rotation = (newRotation == undefined) ? oldRotation : newRotation;
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector2(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let mtxResult = Matrix3x3.IDENTITY();
            if (vectors.translation)
                mtxResult.translate(vectors.translation);
            if (vectors.rotation) {
                mtxResult.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                mtxResult.scale(vectors.scaling);
            this.set(mtxResult);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation != undefined)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```text
     * [ 0, 1, 2, 3 ] ‚Üê row vector x
     * [ 4, 5, 6, 7 ] ‚Üê row vector y
     * [ 8, 9,10,11 ] ‚Üê row vector z
     * [12,13,14,15 ] ‚Üê translation
     *            ‚Üë  homogeneous column
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019 | Jonas Plotzky, HFU, 2023
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        #translation;
        #scaling;
        #rotation;
        #quaternion;
        #translationDirty;
        #scalingDirty;
        #rotationDirty;
        #quaternionDirty;
        constructor() {
            super();
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.#translation = FudgeCore.Vector3.ZERO();
            this.#scaling = FudgeCore.Vector3.ZERO();
            this.#rotation = FudgeCore.Vector3.ONE();
            this.#quaternion = FudgeCore.Quaternion.IDENTITY();
            this.recycle();
        }
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            return mtxResult;
        }
        /**
         * Construct a new matrix according to the given translation, rotation and scaling.
         */
        static CONSTRUCTION(_translation, _rotation, _scaling) {
            let result = Matrix4x4.IDENTITY();
            result.mutate({ "translation": _translation, "rotation": _rotation, "scaling": _scaling });
            return result;
        }
        /**
         * Computes and returns the product of two passed matrices.
         * @param _mtxLeft The matrix to multiply.
         * @param _mtxRight The matrix to multiply by.
         */
        static MULTIPLICATION(_mtxLeft, _mtxRight) {
            let a = _mtxLeft.data;
            let b = _mtxRight.data;
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let a00 = a[0 * 4 + 0];
            let a01 = a[0 * 4 + 1];
            let a02 = a[0 * 4 + 2];
            let a03 = a[0 * 4 + 3];
            let a10 = a[1 * 4 + 0];
            let a11 = a[1 * 4 + 1];
            let a12 = a[1 * 4 + 2];
            let a13 = a[1 * 4 + 3];
            let a20 = a[2 * 4 + 0];
            let a21 = a[2 * 4 + 1];
            let a22 = a[2 * 4 + 2];
            let a23 = a[2 * 4 + 3];
            let a30 = a[3 * 4 + 0];
            let a31 = a[3 * 4 + 1];
            let a32 = a[3 * 4 + 2];
            let a33 = a[3 * 4 + 3];
            let b00 = b[0 * 4 + 0];
            let b01 = b[0 * 4 + 1];
            let b02 = b[0 * 4 + 2];
            let b03 = b[0 * 4 + 3];
            let b10 = b[1 * 4 + 0];
            let b11 = b[1 * 4 + 1];
            let b12 = b[1 * 4 + 2];
            let b13 = b[1 * 4 + 3];
            let b20 = b[2 * 4 + 0];
            let b21 = b[2 * 4 + 1];
            let b22 = b[2 * 4 + 2];
            let b23 = b[2 * 4 + 3];
            let b30 = b[3 * 4 + 0];
            let b31 = b[3 * 4 + 1];
            let b32 = b[3 * 4 + 2];
            let b33 = b[3 * 4 + 3];
            mtxResult.data.set([
                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns the transpose of a passed matrix.
         */
        static TRANSPOSE(_mtx) {
            let m = _mtx.data;
            let result = FudgeCore.Recycler.get(Matrix4x4);
            result.data.set([
                m[0], m[4], m[8], m[12],
                m[1], m[5], m[9], m[13],
                m[2], m[6], m[10], m[14],
                m[3], m[7], m[11], m[15]
            ]);
            return result;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtx The matrix to compute the inverse of.
         */
        static INVERSION(_mtx) {
            let m = _mtx.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly at the given target,
         * and a minimal angle between its y-axis and the given up-{@link Vector3}, respetively calculating yaw and pitch.
         * The pitch may be restricted to the up-vector to only calculate yaw.
         */
        static LOOK_AT(_translation, _target, _up = FudgeCore.Vector3.Y(), _restrict = false) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let vctCross = FudgeCore.Vector3.CROSS(_up, zAxis);
            if (vctCross.magnitudeSquared == 0) // experimental workaround: if z and up is parallel, there is no up to remain...
                vctCross.x = 0.001; // so tilt a little
            let xAxis = FudgeCore.Vector3.NORMALIZATION(vctCross);
            let yAxis = _restrict ? _up : FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            zAxis = _restrict ? FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(xAxis, _up)) : zAxis;
            mtxResult.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its y-axis matching the given up-{@link Vector3}
         * and its z-axis facing towards the given target at a minimal angle, respetively calculating yaw only.
         */
        // public static SHOW_TO(_translation: Vector3, _target: Vector3, _up: Vector3 = Vector3.Y()): Matrix4x4 {
        //   const mtxResult: Matrix4x4 = Recycler.get(Matrix4x4);
        //   let zAxis: Vector3 = Vector3.DIFFERENCE(_target, _translation);
        //   zAxis.normalize();
        //   let xAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(_up, zAxis));
        //   // let yAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(zAxis, xAxis));
        //   zAxis = Vector3.NORMALIZATION(Vector3.CROSS(xAxis, _up));
        //   mtxResult.data.set(
        //     [
        //       xAxis.x, xAxis.y, xAxis.z, 0,
        //       _up.x, _up.y, _up.z, 0,
        //       zAxis.x, zAxis.y, zAxis.z, 0,
        //       _translation.x,
        //       _translation.y,
        //       _translation.z,
        //       1
        //     ]);
        //   return mtxResult;
        // }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector3}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                _translate.x, _translate.y, _translate.z, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         */
        static ROTATION_X(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         */
        static ROTATION_Y(_angleInDegrees) {
            let mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         */
        static ROTATION_Z(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates when multiplied by, using the rotation euler angles or unit quaternion given.
         * Rotation occurs around the axis in the order Z-Y-X .
         */
        static ROTATION(_rotation) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            Matrix4x4.SET_ROTATION(mtxResult.data, _rotation);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector3}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                _scalar.x, 0, 0, 0,
                0, _scalar.y, 0, 0,
                0, 0, _scalar.z, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a representation of the given matrix relative to the given base.
         * If known, pass the inverse of the base to avoid unneccesary calculation
         */
        static RELATIVE(_mtx, _mtxBase, _mtxInverse) {
            if (_mtxInverse)
                return Matrix4x4.MULTIPLICATION(_mtxInverse, _mtx);
            let mtxInverse = Matrix4x4.INVERSION(_mtxBase);
            let mtxResult = Matrix4x4.MULTIPLICATION(mtxInverse, _mtx);
            FudgeCore.Recycler.store(mtxInverse);
            return mtxResult;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * FudgeCore.Calc.deg2rad;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                f, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (_near + _far) * rangeInv, -1,
                0, 0, _near * _far * rangeInv * 2, 0
            ]);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                mtxResult.data[0] = f / _aspect;
                mtxResult.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                mtxResult.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                mtxResult.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            mtxResult.rotateY(180);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                2 / (_right - _left), 0, 0, 0,
                0, -2 / (_top - _bottom), 0, 0,
                0, 0, 2 / (_far - _near), 0,
                (_left + _right) / (_left - _right),
                (_bottom + _top) / (_bottom - _top),
                (_near + _far) / (_near - _far),
                1
            ]);
            return mtxResult;
        }
        /**
         * Set the rotation part of the given matrixes data array to the given rotation.
         */
        static SET_ROTATION(_m, _rotation) {
            if (_rotation instanceof FudgeCore.Vector3) {
                const anglesInRadians = FudgeCore.Vector3.SCALE(_rotation, FudgeCore.Calc.deg2rad);
                const sinX = Math.sin(anglesInRadians.x);
                const cosX = Math.cos(anglesInRadians.x);
                const sinY = Math.sin(anglesInRadians.y);
                const cosY = Math.cos(anglesInRadians.y);
                const sinZ = Math.sin(anglesInRadians.z);
                const cosZ = Math.cos(anglesInRadians.z);
                FudgeCore.Recycler.store(anglesInRadians);
                _m[0] = cosZ * cosY; /**/
                _m[1] = sinZ * cosY; /**/
                _m[2] = -sinY;
                _m[4] = cosZ * sinY * sinX - sinZ * cosX;
                _m[5] = sinZ * sinY * sinX + cosZ * cosX;
                _m[6] = cosY * sinX;
                _m[8] = cosZ * sinY * cosX + sinZ * sinX;
                _m[9] = sinZ * sinY * cosX - cosZ * sinX;
                _m[10] = cosY * cosX;
            }
            else {
                const rotationNormalized = FudgeCore.Quaternion.NORMALIZATION(_rotation);
                const x = rotationNormalized.x, y = rotationNormalized.y, z = rotationNormalized.z, w = rotationNormalized.w;
                const xx = x * x, xy = x * y, xz = x * z, xw = x * w;
                const yy = y * y, yz = y * z, yw = y * w;
                const zz = z * z, zw = z * w;
                const ww = w * w;
                _m[0] = ww + xx - yy - zz;
                _m[1] = 2 * (xy + zw); /**/
                _m[2] = 2 * (xz - yw);
                _m[4] = 2 * (xy - zw); /**/
                _m[5] = ww - xx + yy - zz;
                _m[6] = 2 * (yz + xw);
                _m[8] = 2 * (xz + yw); /**/
                _m[9] = 2 * (yz - xw); /**/
                _m[10] = ww - xx - yy + zz;
                // _m[0] = 1 - 2 * (yy + zz); _m[1] = 2 * (xy + zw);/**/ _m[2] = 2 * (xz - yw);
                // _m[4] = 2 * (xy - zw);/**/ _m[5] = 1 - 2 * (xx + zz); _m[6] = 2 * (yz + xw);
                // _m[8] = 2 * (xz + yw);/**/ _m[9] = 2 * (yz - xw);/**/ _m[10] = 1 - 2 * (xx + yy);
                FudgeCore.Recycler.store(rotationNormalized);
            }
        }
        //#endregion
        //#region  Accessors
        /**
         * - get: return a vector representation of the translation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (this.#translationDirty) {
                this.#translation.set(this.data[12], this.data[13], this.data[14]);
                this.#translationDirty = false;
            }
            return this.#translation;
        }
        set translation(_translation) {
            this.mutate({ "translation": _translation });
        }
        /**
         * - get: return a vector representation of the rotation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get rotation() {
            if (this.#rotationDirty) {
                let scaling = this.scaling;
                let s0 = this.data[0] / scaling.x;
                let s1 = this.data[1] / scaling.x;
                let s2 = this.data[2] / scaling.x;
                let s6 = this.data[6] / scaling.y;
                let s10 = this.data[10] / scaling.z;
                let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
                let singular = sy < 1e-6; // If
                let x1, y1, z1;
                let x2, y2, z2;
                if (!singular) {
                    x1 = Math.atan2(s6, s10);
                    y1 = Math.atan2(-s2, sy);
                    z1 = Math.atan2(s1, s0);
                    x2 = Math.atan2(-s6, -s10);
                    y2 = Math.atan2(-s2, -sy);
                    z2 = Math.atan2(-s1, -s0);
                    if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                        x1 = x2;
                        y1 = y2;
                        z1 = z2;
                    }
                }
                else {
                    x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                    y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                    z1 = 0;
                }
                this.#rotation.set(x1, y1, z1);
                this.#rotation.scale(FudgeCore.Calc.rad2deg);
                this.#rotationDirty = false;
            }
            return this.#rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
        }
        /**
         * - get: return a vector representation of the scaling {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get scaling() {
            if (this.#scalingDirty) {
                this.#scaling.set(Math.hypot(this.data[0], this.data[1], this.data[2]), //* (this.data[0] < 0 ? -1 : 1),
                Math.hypot(this.data[4], this.data[5], this.data[6]), //* (this.data[5] < 0 ? -1 : 1),
                Math.hypot(this.data[8], this.data[9], this.data[10]) // * (this.data[10] < 0 ? -1 : 1)
                );
                this.#scalingDirty = false;
            }
            return this.#scaling;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
        }
        /**
         * - get: return a unit quaternion representing the rotation of this matrix.
         * **Caution!** Use immediately and readonly, since the quaternion is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get quaternion() {
            if (this.#quaternionDirty) {
                this.#quaternion.eulerAngles = this.rotation;
                this.#quaternionDirty = false;
            }
            return this.#quaternion;
        }
        set quaternion(_quaternion) {
            this.mutate({ "rotation": _quaternion });
        }
        /**
         * Return a copy of this
         */
        get clone() {
            let mtxClone = FudgeCore.Recycler.get(Matrix4x4);
            mtxClone.set(this);
            return mtxClone;
        }
        //#endregion
        /**
         * Resets the matrix to the identity-matrix and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            // TODO: think about this change: translation, rotation and scaling of a recycled matrix are actually 
            // known and need not be lazily recalculated. But most matrix manipulation logic assumes that a recycled matrix
            // will do this lazily. So, for now, we reset the cache here, but maybe we should rather reset the cache
            // everytime a matrix is changed i.e. use .set() instead of .data.set() when cache should be reset.
            // this.#translation.set(0, 0, 0);
            // this.#rotation.set(0, 0, 0);
            // this.#scaling.set(1, 1, 1);
            // this.#quaternion.set(0, 0, 0, 1);
            // this.#translationDirty = false;
            // this.#rotationDirty = false;
            // this.#scalingDirty = false;
            // this.#quaternionDirty = false;
            this.resetCache();
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache.
         */
        reset() {
            this.recycle();
        }
        //#region Rotation
        /**
         * Rotate this matrix by given {@link Vector3} in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * The rotation is appended to already applied transforms, thus multiplied from the right. Set _fromLeft to true to switch and put it in front.
         */
        rotate(_by, _fromLeft = false) {
            // this.rotateZ(_by.z, _fromLeft);
            // this.rotateY(_by.y, _fromLeft);
            // this.rotateX(_by.x, _fromLeft);
            let mtxRotation = Matrix4x4.ROTATION(_by);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Transpose this matrix
         */
        transpose() {
            let matrix = this.data;
            this.data.set([
                matrix[0], matrix[4], matrix[8], matrix[12],
                matrix[1], matrix[5], matrix[9], matrix[13],
                matrix[2], matrix[6], matrix[10], matrix[14],
                matrix[3], matrix[7], matrix[11], matrix[15]
            ]);
            return this;
        }
        /**
         * Invert this matrix
         */
        inverse() {
            let m = this.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return matrix;
        }
        /**
         * Adds a rotation around the x-axis to this matrix
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adds a rotation around the y-axis to this matrix
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adds a rotation around the z-axis to this matrix
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adjusts the rotation of this matrix to point the z-axis directly at the given target and tilts it to accord with the given up-{@link Vector3},
         * respectively calculating yaw and pitch. If no up-{@link Vector3} is given, the previous up-{@link Vector3} is used.
         * The pitch may be restricted to the up-vector to only calculate yaw.
         */
        lookAt(_target, _up, _restrict = false) {
            _up = _up ? FudgeCore.Vector3.NORMALIZATION(_up) : FudgeCore.Vector3.NORMALIZATION(this.getY());
            const mtxResult = Matrix4x4.LOOK_AT(this.translation, _target, _up, _restrict);
            mtxResult.scale(this.scaling);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Same as {@link Matrix4x4.lookAt}, but optimized and needs testing
         */
        // TODO: testing lookat that really just rotates the matrix rather than creating a new one
        // public lookAtRotate(_target: Vector3, _up?: Vector3, _preserveScaling: boolean = true): void {
        //   if (!_up)
        //     _up = this.getY();
        //   let scaling: Vector3 = this.scaling;
        //   let difference: Vector3 = Vector3.DIFFERENCE(_target, this.translation);
        //   difference.normalize();
        //   let cos: number = Vector3.DOT(Vector3.NORMALIZATION(this.getZ()), difference);
        //   let sin: number = Vector3.DOT(Vector3.NORMALIZATION(this.getX()), difference);
        //   // console.log(sin, cos);
        //   let mtxRotation: Matrix4x4 = Recycler.get(Matrix4x4);
        //   mtxRotation.data.set([
        //     cos, 0, -sin, 0,
        //     0, 1, 0, 0,
        //     sin, 0, cos, 0,
        //     0, 0, 0, 1
        //   ]);
        //   this.multiply(mtxRotation, false);
        //   cos = Vector3.DOT(Vector3.NORMALIZATION(this.getZ()), difference);
        //   sin = -Vector3.DOT(Vector3.NORMALIZATION(this.getY()), difference);
        //   // console.log(sin, cos);
        //   mtxRotation.data.set([
        //     1, 0, 0, 0,
        //     0, cos, sin, 0,
        //     0, -sin, cos, 0,
        //     0, 0, 0, 1
        //   ]);
        //   this.multiply(mtxRotation, false);
        //   this.scaling = scaling;
        //   Recycler.store(mtxRotation);
        // }
        //#endregion
        //#region Translation
        /**
         * Add a translation by the given {@link Vector3} to this matrix.
         * If _local is true, translation occurs according to the current rotation and scaling of this matrix,
         * according to the parent otherwise.
         */
        translate(_by, _local = true) {
            if (_local) {
                let mtxTranslation = Matrix4x4.TRANSLATION(_by);
                this.multiply(mtxTranslation);
                FudgeCore.Recycler.store(mtxTranslation);
            }
            else {
                this.data[12] += _by.x;
                this.data[13] += _by.y;
                this.data[14] += _by.z;
                this.mutator = null;
                this.#translationDirty = true;
            }
            // const matrix: Matrix4x4 = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // // TODO: possible optimization, translation may alter mutator instead of deleting it.
            // this.set(matrix);
            // Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-axis by the given amount to this matrix
         */
        translateX(_x, _local = true) {
            let translation = FudgeCore.Vector3.X(_x);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the y-axis by the given amount to this matrix
         */
        translateY(_y, _local = true) {
            let translation = FudgeCore.Vector3.Y(_y);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the z-axis by the given amount to this matrix
         */
        translateZ(_z, _local = true) {
            let translation = FudgeCore.Vector3.Z(_z);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given {@link Vector3} to this matrix
         */
        scale(_by) {
            const mtxResult = Matrix4x4.MULTIPLICATION(this, Matrix4x4.SCALING(_by));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a scaling along the x-axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(_by, 1, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the y-axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(1, _by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the z-axis by the given amount to this matrix
         */
        scaleZ(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(1, 1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix, _fromLeft = false) {
            const mtxResult = _fromLeft ? Matrix4x4.MULTIPLICATION(_matrix, this) : Matrix4x4.MULTIPLICATION(this, _matrix);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Transfer
        // public getEulerAnglesNew(): Vector3 {
        //   let scaling: Vector3 = this.scaling;
        //   let thetaX: number, thetaY: number, thetaZ: number;
        //   let r02: number = this.data[2] / scaling.z;
        //   let r11: number = this.data[5] / scaling.y;
        //   if (r02 < 1) {
        //     if (r02 > -1) {
        //       thetaY = Math.asin(-r02);
        //       thetaZ = Math.atan2(this.data[1] / scaling.y, this.data[0] / scaling.x);
        //       thetaX = Math.atan2(this.data[9] / scaling.z, this.data[10] / scaling.z);
        //     }
        //     else {
        //       thetaY = Math.PI / 2;
        //       thetaZ = -Math.atan2(this.data[6] / scaling.y, r11);
        //       thetaX = 0;
        //     }
        //   }
        //   else {
        //     thetaY = -Math.PI / 2;
        //     thetaZ = Math.atan2(-this.data[6] / scaling.y, r11);
        //     thetaX = 0;
        //   }
        //   this.#eulerAngles.set(-thetaX, thetaY, thetaZ);
        //   this.#eulerAngles.scale(Mathematic.rad2deg);
        //   return this.#eulerAngles;
        // }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_mtxTo) {
            if (_mtxTo instanceof Matrix4x4)
                this.data.set(_mtxTo.data);
            else
                this.data.set(_mtxTo);
            this.resetCache();
        }
        /**
         * Returns a formatted string representation of this matrix
         */
        toString() {
            return `∆í.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            // TODO: optimization, it shouldn't always return a copy, since this bloats memory
            return new Float32Array(this.data);
        }
        /**
         * Return cardinal x-axis
         */
        getX() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[0], this.data[1], this.data[2]);
            return result;
        }
        /**
         * Return cardinal y-axis
         */
        getY() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[4], this.data[5], this.data[6]);
            return result;
        }
        /**
         * Return cardinal z-axis
         */
        getZ() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[8], this.data[9], this.data[10]);
            return result;
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXY() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[4], this.data[5], this.data[6]], 0); // overwrite x-axis with y-axis
            this.data.set(temp, 4); // overwrite Y with temp
            this.data.set([-this.data[8], -this.data[9], -this.data[10]], 8); // reverse z-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXZ() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 0); // overwrite x-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[4], -this.data[5], -this.data[6]], 4); // reverse y-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapYZ() {
            let temp = [this.data[4], this.data[5], this.data[6]]; // store y-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 4); // overwrite y-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[0], -this.data[1], -this.data[2]], 0); // reverse x-axis
        }
        /**
         * Returns the tranlation from this matrix to the target matrix
         */
        getTranslationTo(_mtxTarget) {
            let difference = FudgeCore.Recycler.get(FudgeCore.Vector3);
            difference.set(_mtxTarget.data[12] - this.data[12], _mtxTarget.data[13] - this.data[13], _mtxTarget.data[14] - this.data[14]);
            return difference;
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation.serialize(),
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: await this.rotation.deserialize(_serialization.rotation),
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            const m = this.data;
            if (_mutator.translation) {
                let translation = this.translation;
                translation.mutate(_mutator.translation);
                m[12] = translation.x;
                m[13] = translation.y;
                m[14] = translation.z;
                this.#translationDirty = false;
            }
            if (_mutator.rotation || _mutator.scaling) {
                // TODO: imported animation uses "scale" instead of "scaling" -> rename our "scaling" to "scale"?
                // TODO: make full vector and quaternion mutators mandatory?
                let rotation = _mutator.rotation?.w != undefined ?
                    this.#quaternion : // using this.#quaternion assumes we get a full quaternion mutator with x, y, z and w set so we never need to recalculate the quaternion here. This might cause trouble if we ever want to mutate only a part of a quaternion...
                    isFullVectorMutator(_mutator.rotation) ? this.#rotation : this.rotation; // hack to avoid unnecessary recalculation of rotation and scaling. This recalculation is unnecessary when we get a full mutator i.e. with x, y and z set
                let scaling = isFullVectorMutator(_mutator.scaling) ? this.#scaling : this.scaling;
                if (_mutator.rotation)
                    rotation.mutate(_mutator.rotation);
                if (_mutator.scaling)
                    scaling.mutate(_mutator.scaling);
                Matrix4x4.SET_ROTATION(m, rotation);
                const isEulerRotation = rotation instanceof FudgeCore.Vector3;
                this.#rotationDirty = !isEulerRotation;
                this.#quaternionDirty = isEulerRotation;
                const sx = scaling.x, sy = scaling.y, sz = scaling.z;
                m[0] *= sx;
                m[1] *= sx;
                m[2] *= sx;
                m[4] *= sy;
                m[5] *= sy;
                m[6] *= sy;
                m[8] *= sz;
                m[9] *= sz;
                m[10] *= sz;
                this.#scalingDirty = false;
            }
            this.mutator = null;
            function isFullVectorMutator(_mutator) {
                return _mutator && _mutator.x != undefined && _mutator.y != undefined && _mutator.z != undefined;
            }
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.#translationDirty = true;
            this.#rotationDirty = true;
            this.#quaternionDirty = true;
            this.#scalingDirty = true;
            this.mutator = null;
        }
    }
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for Noise2, Noise3 and Noise4
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     */
    class Noise {
        constructor(_random = Math.random) {
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            const p = new Uint8Array(256);
            for (let i = 0; i < 256; i++)
                p[i] = i;
            let n;
            let q;
            for (let i = 255; i > 0; i--) {
                n = Math.floor((i + 1) * _random());
                q = p[i];
                p[i] = p[n];
                p[n] = q;
            }
            for (let i = 0; i < 512; i++) {
                this.perm[i] = p[i & 255];
                this.permMod12[i] = this.perm[i] % 12;
            }
        }
    }
    FudgeCore.Noise = Noise;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./Noise.ts"/>
var FudgeCore;
///<reference path="./Noise.ts"/>
(function (FudgeCore) {
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    class Noise2 extends FudgeCore.Noise {
        static { this.offset = (3.0 - Math.sqrt(3.0)) / 6.0; }
        static { this.gradient = [[1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [0, 1], [0, -1]]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y) => {
                return this.#sample(_x, _y);
            };
            this.#sample = (_x, _y) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const t = (i + j) * Noise2.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y) space
                const Y0 = j - t;
                const x0 = _x - X0; // The x,y distances from the cell origin
                const y0 = _y - Y0;
                // Determine which simplex we are in.
                const i1 = x0 > y0 ? 1 : 0;
                const j1 = x0 > y0 ? 0 : 1;
                // Offset:numbers for corners
                const x1 = x0 - i1 + Noise2.offset;
                const y1 = y0 - j1 + Noise2.offset;
                const x2 = x0 - 1.0 + 2.0 * Noise2.offset;
                const y2 = y0 - 1.0 + 2.0 * Noise2.offset;
                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const g0 = Noise2.gradient[this.permMod12[ii + this.perm[jj]]];
                const g1 = Noise2.gradient[this.permMod12[ii + i1 + this.perm[jj + j1]]];
                const g2 = Noise2.gradient[this.permMod12[ii + 1 + this.perm[jj + 1]]];
                // Calculate the contribution from the three corners
                const t0 = 0.5 - x0 * x0 - y0 * y0;
                const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0);
                const t1 = 0.5 - x1 * x1 - y1 * y1;
                const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1);
                const t2 = 0.5 - x2 * x2 - y2 * y2;
                const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1, 1]
                return 70.14805770653952 * (n0 + n1 + n2);
            };
        }
    }
    FudgeCore.Noise2 = Noise2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    // TODO: Test
    class Noise3 extends FudgeCore.Noise {
        static { this.offset = 1.0 / 6.0; }
        static { this.gradient = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]
        ]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z) => {
                return this.#sample(_x, _y, _z);
            };
            this.#sample = (_x, _y, _z) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y + _z) / 3.0; // Very nice and simple skew factor for 3D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const t = (i + j + k) * Noise3.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = _x - X0; // The x,y,z distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                // Deterine which simplex we are in
                let i1, j1, k1 // Offsets for second corner of simplex in (i,j,k) coords
                ;
                let i2, j2, k2 // Offsets for third corner of simplex in (i,j,k) coords
                ;
                if (x0 >= y0) {
                    if (y0 >= z0) {
                        i1 = i2 = j2 = 1;
                        j1 = k1 = k2 = 0;
                    }
                    else if (x0 >= z0) {
                        i1 = i2 = k2 = 1;
                        j1 = k1 = j2 = 0;
                    }
                    else {
                        k1 = i2 = k2 = 1;
                        i1 = j1 = j2 = 0;
                    }
                }
                else {
                    if (y0 < z0) {
                        k1 = j2 = k2 = 1;
                        i1 = j1 = i2 = 0;
                    }
                    else if (x0 < z0) {
                        j1 = j2 = k2 = 1;
                        i1 = k1 = i2 = 0;
                    }
                    else {
                        j1 = i2 = j2 = 1;
                        i1 = k1 = k2 = 0;
                    }
                }
                const x1 = x0 - i1 + Noise3.offset; // Offsets for second corner in (x,y,z) coords
                const y1 = y0 - j1 + Noise3.offset;
                const z1 = z0 - k1 + Noise3.offset;
                const x2 = x0 - i2 + 2.0 * Noise3.offset; // Offsets for third corner in (x,y,z) coords
                const y2 = y0 - j2 + 2.0 * Noise3.offset;
                const z2 = z0 - k2 + 2.0 * Noise3.offset;
                const x3 = x0 - 1.0 + 3.0 * Noise3.offset; // Offsets for last corner in (x,y,z) coords
                const y3 = y0 - 1.0 + 3.0 * Noise3.offset;
                const z3 = z0 - 1.0 + 3.0 * Noise3.offset;
                // Work :numberut the hashed gradient indices of the four simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const g0 = Noise3.gradient[this.permMod12[ii + this.perm[jj + this.perm[kk]]]];
                const g1 = Noise3.gradient[this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]]];
                const g2 = Noise3.gradient[this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]]];
                const g3 = Noise3.gradient[this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]]];
                // Calcu:numberate the contribution from the four corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to stay just inside [-1,1]
                return 94.68493150681972 * (n0 + n1 + n2 + n3);
            };
        }
    }
    FudgeCore.Noise3 = Noise3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // TODO: Test
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    class Noise4 extends FudgeCore.Noise {
        static { this.offset = (5.0 - Math.sqrt(5.0)) / 20.0; }
        static { this.gradient = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z, _w) => {
                return this.#sample(_x, _y, _z, _w);
            };
            this.#sample = (_x, _y, _z, _w) => {
                // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
                const s = (_x + _y + _z + _w) * (Math.sqrt(5.0) - 1.0) / 4.0; // Factor for 4D skewing
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const l = Math.floor(_w + s);
                const t = (i + j + k + l) * Noise4.offset; // Factor for 4D unskewing
                const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
                const Y0 = j - t;
                const Z0 = k - t;
                const W0 = l - t;
                const x0 = _x - X0; // The x,y,z,w distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                const w0 = _w - W0;
                // To find out which of the 24 possible simplices we're in, we need to determine the
                // magnitude ordering of x0, y0, z0 and w0. Six pair-wise comparisons are performed between
                // each possible pair of the four coordinates, and the results are used to rank the numbers.
                let rankx = 0;
                let ranky = 0;
                let rankz = 0;
                let rankw = 0;
                if (x0 > y0)
                    rankx++;
                else
                    ranky++;
                if (x0 > z0)
                    rankx++;
                else
                    rankz++;
                if (x0 > w0)
                    rankx++;
                else
                    rankw++;
                if (y0 > z0)
                    ranky++;
                else
                    rankz++;
                if (y0 > w0)
                    ranky++;
                else
                    rankw++;
                if (z0 > w0)
                    rankz++;
                else
                    rankw++;
                // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
                // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
                // impossible. Only the 24 indices which have non-zero entries make any sense.
                // We use a thresholding to set the coordinates in turn from the largest magnitude.
                // Rank 3 denotes the largest coordinate.
                const i1 = rankx >= 3 ? 1 : 0;
                const j1 = ranky >= 3 ? 1 : 0;
                const k1 = rankz >= 3 ? 1 : 0;
                const l1 = rankw >= 3 ? 1 : 0;
                // Rank : 2 denotes the second largest coordinate.
                const i2 = rankx >= 2 ? 1 : 0;
                const j2 = ranky >= 2 ? 1 : 0;
                const k2 = rankz >= 2 ? 1 : 0;
                const l2 = rankw >= 2 ? 1 : 0;
                // Rank : 1 denotes the second smallest coordinate.
                const i3 = rankx >= 1 ? 1 : 0;
                const j3 = ranky >= 1 ? 1 : 0;
                const k3 = rankz >= 1 ? 1 : 0;
                const l3 = rankw >= 1 ? 1 : 0;
                // The fifth corner has all coordinate offsets = 1, so no need to compute that.
                const x1 = x0 - i1 + Noise4.offset; // Offsets for second corner in (x,y,z,w) coords
                const y1 = y0 - j1 + Noise4.offset;
                const z1 = z0 - k1 + Noise4.offset;
                const w1 = w0 - l1 + Noise4.offset;
                const x2 = x0 - i2 + 2.0 * Noise4.offset; // Offsets for third corner in (x,y,z,w) coords
                const y2 = y0 - j2 + 2.0 * Noise4.offset;
                const z2 = z0 - k2 + 2.0 * Noise4.offset;
                const w2 = w0 - l2 + 2.0 * Noise4.offset;
                const x3 = x0 - i3 + 3.0 * Noise4.offset; // Offsets for fourth corner in (x,y,z,w) coords
                const y3 = y0 - j3 + 3.0 * Noise4.offset;
                const z3 = z0 - k3 + 3.0 * Noise4.offset;
                const w3 = w0 - l3 + 3.0 * Noise4.offset;
                const x4 = x0 - 1.0 + 4.0 * Noise4.offset; // Offsets for last corner in (x,y,z,w) coords
                const y4 = y0 - 1.0 + 4.0 * Noise4.offset;
                const z4 = z0 - 1.0 + 4.0 * Noise4.offset;
                const w4 = w0 - 1.0 + 4.0 * Noise4.offset;
                // Work out the hashed gradient indices of the five simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const ll = l & 255;
                const g0 = Noise4.gradient[this.perm[ii + this.perm[jj + this.perm[kk + this.perm[ll]]]] %
                    32];
                const g1 = Noise4.gradient[this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1 + this.perm[ll + l1]]]] % 32];
                const g2 = Noise4.gradient[this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2 + this.perm[ll + l2]]]] % 32];
                const g3 = Noise4.gradient[this.perm[ii + i3 + this.perm[jj + j3 + this.perm[kk + k3 + this.perm[ll + l3]]]] % 32];
                const g4 = Noise4.gradient[this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1 + this.perm[ll + 1]]]] % 32];
                // Calculate the contribution from the five corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0 + g0[3] * w0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1 + g1[3] * w1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2 + g2[3] * w2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3 + g3[3] * w3);
                const t4 = 0.5 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
                const n4 = t4 < 0
                    ? 0.0
                    : Math.pow(t4, 4) * (g4[0] * x4 + g4[1] * y4 + g4[2] * z4 + g4[3] * w4);
                // Sum up and scale the result to cover the range [-1,1]
                return 72.37855765153665 * (n0 + n1 + n2 + n3 + n4);
            };
        }
    }
    FudgeCore.Noise4 = Noise4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * Storing and manipulating rotations in the form of quaternions.
      * Constructed out of the 4 components: (x, y, z, w). Mathematical notation: w + xi + yj + zk.
      * A Quaternion can be described with an axis and angle: (x, y, z) = sin(angle/2)*axis; w = cos(angle/2).
      * roll: x, pitch: y, yaw: z. Note that operations are adapted to work with vectors where y is up and z is forward.
      * @authors Matthias Roming, HFU, 2023 | Marko Fehrenbach, HFU, 2020 | Jonas Plotzky, HFU, 2023
      */
    class Quaternion extends FudgeCore.Mutable {
        #eulerAngles; // euler angle representation of this quaternion in degrees.
        #eulerAnglesDirty;
        constructor(_x = 0, _y = 0, _z = 0, _w = 1) {
            super();
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.#eulerAngles = FudgeCore.Vector3.ZERO(); // euler angle representation of this quaternion in degrees.
            this.set(_x, _y, _z, _w);
        }
        //#region STATICS
        /**
         * Retrieve a new identity quaternion
         */
        static IDENTITY() {
            const result = FudgeCore.Recycler.get(Quaternion);
            return result;
        }
        static NORMALIZATION(_q) {
            const result = _q.clone;
            result.normalize();
            return result;
        }
        /**
         * Returns a quaternion that rotates coordinates when multiplied by, using the angles given.
         * Rotation occurs around the axis in the order Z-Y-X.
         */
        static ROTATION(_eulerAngles) {
            const result = FudgeCore.Recycler.get(Quaternion);
            result.eulerAngles = _eulerAngles;
            return result;
        }
        /**
         * Computes and returns the product of two passed quaternions.
         * @param _mtxLeft The quaternion to multiply.
         * @param _mtxRight The quaternion to multiply by.
         */
        static MULTIPLICATION(_qLeft, _qRight) {
            const result = _qLeft.clone;
            result.multiply(_qRight);
            return result;
        }
        /**
         * Computes and returns the inverse of a passed quaternion.
         * @param _mtx The quaternion to compute the inverse of.
         */
        static INVERSION(_q) {
            const result = _q.clone;
            result.inverse();
            return result;
        }
        /**
         * Computes and returns the conjugate of a passed quaternion.
         * @param _mtx The quaternion to compute the conjugate of.
         */
        static CONJUGATION(_q) {
            const result = _q.clone;
            result.conjugate();
            return result;
        }
        /**
         * Returns the dot product of two quaternions.
         */
        static DOT(_q1, _q2) {
            return _q1.x * _q2.x + _q1.y * _q2.y + _q1.z * _q2.z + _q1.w * _q2.w;
        }
        /**
         * Returns the normalized linear interpolation between two quaternions based on the given _factor. When _factor is 0 the result is _from, when _factor is 1 the result is _to.
         */
        static LERP(_from, _to, _factor) {
            let result = FudgeCore.Recycler.get(Quaternion);
            result.set((_from.x * (1 - _factor) + _to.x * _factor), (_from.y * (1 - _factor) + _to.y * _factor), (_from.z * (1 - _factor) + _to.z * _factor), (_from.w * (1 - _factor) + _to.w * _factor));
            result.normalize();
            return result;
        }
        /**
         * Returns the spherical linear interpolation between two quaternions based on the given _factor. When _factor is 0 the result is _from, when _factor is 1 the result is _to.
         */
        static SLERP(_from, _to, _factor) {
            // From: https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            let cosHalfTheta = _from.w * _to.w + _from.x * _to.x + _from.y * _to.y + _from.z * _to.z;
            if (Math.abs(cosHalfTheta) >= 1)
                return _from;
            let halfTheta = Math.acos(cosHalfTheta);
            let sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 0.001) {
                let result = FudgeCore.Recycler.get(Quaternion);
                result.set((_from.x * 0.5 + _to.x * 0.5), (_from.y * 0.5 + _to.y * 0.5), (_from.z * 0.5 + _to.z * 0.5), (_from.w * 0.5 + _to.w * 0.5));
                return result;
            }
            let ratioA = Math.sin((1 - _factor) * halfTheta) / sinHalfTheta;
            let ratioB = Math.sin(_factor * halfTheta) / sinHalfTheta;
            let result = FudgeCore.Recycler.get(Quaternion);
            result.set((_from.x * ratioA + _to.x * ratioB), (_from.y * ratioA + _to.y * ratioB), (_from.z * ratioA + _to.z * ratioB), (_from.w * ratioA + _to.w * ratioB));
            return result;
        }
        //#endregion
        /**
         * Return a copy of this
         */
        get clone() {
            let result = FudgeCore.Recycler.get(Quaternion);
            result.set(this.x, this.y, this.z, this.w);
            return result;
        }
        /**
         * - get: return the euler angle representation of the rotation in degrees.
         * - set: set the euler angle representation of the rotation in degrees.
         */
        get eulerAngles() {
            if (this.#eulerAnglesDirty) {
                this.#eulerAnglesDirty = false;
                if (this.x == 0 && this.y == 0 && this.z == 0 && this.w == 1) {
                    this.#eulerAngles.set(0, 0, 0);
                    return this.#eulerAngles;
                }
                // roll (x-axis rotation)
                let sinrcosp = 2 * (this.w * this.x + this.y * this.z);
                let cosrcosp = 1 - 2 * (this.x * this.x + this.y * this.y);
                this.#eulerAngles.x = Math.atan2(sinrcosp, cosrcosp);
                // pitch (y-axis rotation)
                let sinp = 2 * (this.w * this.y - this.z * this.x);
                if (Math.abs(sinp) >= 1)
                    this.#eulerAngles.y = sinp < 0 ? -Math.abs(Math.PI / 2) : Math.abs(Math.PI / 2); // use 90 degrees if out of range
                else
                    this.#eulerAngles.y = Math.asin(sinp);
                // yaw (z-axis rotation)
                let sinycosp = 2 * (this.w * this.z + this.x * this.y);
                let cosycosp = 1 - 2 * (this.y * this.y + this.z * this.z);
                this.#eulerAngles.z = Math.atan2(sinycosp, cosycosp);
                this.#eulerAngles.scale(FudgeCore.Calc.rad2deg);
            }
            return this.#eulerAngles;
        }
        set eulerAngles(_eulerAngles) {
            const halfAnglesInRadians = FudgeCore.Vector3.SCALE(_eulerAngles, FudgeCore.Calc.deg2rad / 2);
            const cosX = Math.cos(halfAnglesInRadians.x);
            const cosY = Math.cos(halfAnglesInRadians.y);
            const cosZ = Math.cos(halfAnglesInRadians.z);
            const sinX = Math.sin(halfAnglesInRadians.x);
            const sinY = Math.sin(halfAnglesInRadians.y);
            const sinZ = Math.sin(halfAnglesInRadians.z);
            this.set(sinX * cosY * cosZ - cosX * sinY * sinZ, cosX * sinY * cosZ + sinX * cosY * sinZ, cosX * cosY * sinZ - sinX * sinY * cosZ, cosX * cosY * cosZ + sinX * sinY * sinZ);
            this.#eulerAnglesDirty = false;
        }
        /**
         * Normalizes this quaternion to a length of 1 (a unit quaternion) making it a valid rotation representation
         */
        normalize() {
            let length = Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2 + this.w ** 2);
            this.x /= length;
            this.y /= length;
            this.z /= length;
            this.w /= length;
            this.resetCache();
            return this;
        }
        /**
         * Negate this quaternion and returns it
         */
        negate() {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            this.w *= -1;
            this.resetCache();
            return this;
        }
        /**
         * Resets the quaternion to the identity-quaternion and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.set(0, 0, 0, 1);
        }
        /**
         * Inverse this quaternion
         */
        inverse() {
            // quaternion is assumed to have unit length
            this.conjugate();
        }
        /**
         * Conjugates this quaternion and returns it
         */
        conjugate() {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            this.resetCache();
            return this;
        }
        /**
         * Multiply this quaternion with the given quaternion
         */
        multiply(_other, _fromLeft = false) {
            const a = _fromLeft ? _other : this;
            const b = _fromLeft ? this : _other;
            // from: http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            const ax = a.x;
            const ay = a.y;
            const az = a.z;
            const aw = a.w;
            const bx = b.x;
            const by = b.y;
            const bz = b.z;
            const bw = b.w;
            this.set(ax * bw + ay * bz - az * by + aw * bx, -ax * bz + ay * bw + az * bx + aw * by, ax * by - ay * bx + az * bw + aw * bz, -ax * bx - ay * by - az * bz + aw * bw);
        }
        /**
         * Sets the elements of this quaternion to the values of the given quaternion
         */
        set(_x, _y, _z, _w) {
            this.x = _x;
            this.y = _y;
            this.z = _z;
            this.w = _w;
            this.resetCache();
        }
        /**
         * Returns a formatted string representation of this quaternion
         */
        toString() {
            return `∆í.Quaternion(x: ${this.x}, y: ${this.y}, z: ${this.z}, w: ${this.w})`;
        }
        // currently quaternions are never serialized, so this is not needed. But maybe it will be in the future.
        serialize() {
            let serialization = this.getMutator();
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z, this.w] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (!this.mutator)
                this.mutator = { x: this.x, y: this.y, z: this.z, w: this.w };
            return this.mutator;
        }
        async mutate(_mutator) {
            this.x = _mutator.x ?? this.x;
            this.y = _mutator.y ?? this.y;
            this.z = _mutator.z ?? this.z;
            this.w = _mutator.w ?? this.w;
            this.resetCache();
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.#eulerAnglesDirty = true;
            this.mutator = null;
        }
    }
    FudgeCore.Quaternion = Quaternion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Random {
        static { this.default = new Random(); }
        /**
         * Create an instance of {@link Random}.
         * If a seed is given, LFIB4 is used as generator, reproducing a series of numbers from that seed.
         * If a function producing values between 0 and 1 is given, it will be used as generator.
         */
        constructor(_seedOrFunction) {
            this.generate = Math.random;
            if (_seedOrFunction instanceof Function)
                this.generate = _seedOrFunction;
            else if (_seedOrFunction == undefined)
                this.generate = Math.random;
            else
                //@ts-ignore
                this.generate = new FudgeCore.LFIB4(_seedOrFunction);
        }
        /**
         * Returns a normed random number, thus in the range of [0, 1[
         */
        getNorm() {
            return this.generate();
        }
        /**
         * Returns a random number in the range of given [_min, _max[
         */
        getRange(_min, _max) {
            return _min + this.generate() * (_max - _min);
        }
        /**
         * Returns a random integer number in the range of given floored [_min, _max[
         */
        getRangeFloored(_min, _max) {
            return Math.floor(this.getRange(_min, _max));
        }
        /**
         * Returns true or false randomly
         */
        getBoolean() {
            return this.generate() < 0.5;
        }
        /**
         * Returns -1 or 1 randomly
         */
        getSign() {
            return this.getBoolean() ? 1 : -1;
        }
        /**
         * Returns a randomly selected index into the given array
         */
        getIndex(_array) {
            if (_array.length > 0)
                return this.getRangeFloored(0, _array.length);
            return -1;
        }
        /**
         * Returns a randomly selected element of the given array
         */
        getElement(_array) {
            if (_array.length > 0)
                return _array[this.getIndex(_array)];
            return null;
        }
        /**
         * Removes a randomly selected element from the given array and returns it
         */
        splice(_array) {
            return _array.splice(this.getIndex(_array), 1)[0];
        }
        /**
         * Returns a randomly selected key from the given Map-instance
         */
        getKey(_map) {
            let keys = Array.from(_map.keys());
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected property name from the given object
         */
        getPropertyName(_object) {
            let keys = Object.getOwnPropertyNames(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected symbol from the given object, if symbols are used as keys
         */
        getPropertySymbol(_object) {
            let keys = Object.getOwnPropertySymbols(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a random three-dimensional vector in the limits of the box defined by the vectors given as [_corner0, _corner1[
         */
        getVector3(_corner0, _corner1) {
            return new FudgeCore.Vector3(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y), this.getRange(_corner0.z, _corner1.z));
        }
        /**
         * Returns a random two-dimensional vector in the limits of the rectangle defined by the vectors given as [_corner0, _corner1[
         */
        getVector2(_corner0, _corner1) {
            return new FudgeCore.Vector2(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y));
        }
    }
    FudgeCore.Random = Random;
    /**
     * Standard {@link Random}-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```text
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022 | Jonas Plotzky, HFU, 2023
     */
    class Vector3 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.data = new Float32Array([_x, _y, _z]);
        }
        //#region Static
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_scale, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(0, _scale, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, 0, _scale]);
            return vector;
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(0, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_scale, _scale, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix or rotation quaternion.
         */
        static TRANSFORMATION(_vector, _transform, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector3);
            let [x, y, z] = _vector.get();
            if (_transform instanceof FudgeCore.Matrix4x4) {
                let m = _transform.get();
                result.x = m[0] * x + m[4] * y + m[8] * z;
                result.y = m[1] * x + m[5] * y + m[9] * z;
                result.z = m[2] * x + m[6] * y + m[10] * z;
                if (_includeTranslation) {
                    result.add(_transform.translation);
                }
            }
            else {
                // From: https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/index.htm
                // result = q * quaternion(vector.x, vector.y, vector.z, 0) * conj(q)
                // const q: number[] = _transform.get();
                // q * quaternion(vector.x, vector.y, vector.z, 0) ...
                const qx = _transform.w * x + _transform.y * z - _transform.z * y;
                const qy = _transform.w * y + _transform.z * x - _transform.x * z;
                const qz = _transform.w * z + _transform.x * y - _transform.y * x;
                const qw = -_transform.x * x - _transform.y * y - _transform.z * z;
                // ... * conj(q)
                result.set(qx * _transform.w + qw * -_transform.x + qy * -_transform.z - qz * -_transform.y, qy * _transform.w + qw * -_transform.y + qz * -_transform.x - qx * -_transform.z, qz * _transform.w + qw * -_transform.z + qx * -_transform.y - qy * -_transform.x);
            }
            return result;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let magnitudeSquared = _vector.magnitudeSquared;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            let vector = _vector.clone;
            vector.scale(_length / Math.sqrt(magnitudeSquared));
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector3);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y, result.z + vector.z);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z);
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scaling) {
            let scaled = FudgeCore.Recycler.get(Vector3);
            scaled.set(_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling);
            return scaled;
        }
        /**
         * Computes the crossproduct of 2 vectors.
         */
        static CROSS(_a, _b) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_a.y * _b.z - _a.z * _b.y, _a.z * _b.x - _a.x * _b.z, _a.x * _b.y - _a.y * _b.x);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            return scalarProduct;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         *     __________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         *
         */
        static REFLECTION(_incoming, _normal) {
            let dot = -Vector3.DOT(_incoming, _normal);
            let reflection = Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * dot));
            return reflection;
        }
        /**
         * Divides the dividend by the divisor component by component and returns the result
         */
        static RATIO(_dividend, _divisor) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_dividend.x / _divisor.x, _dividend.y / _divisor.y, _dividend.z / _divisor.z);
            return vector;
        }
        /**
         * Creates a cartesian vector from geographic coordinates
         */
        static GEO(_longitude = 0, _latitude = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.get(Vector3);
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.set(_longitude, _latitude, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        /**
         * Return the angle in degrees between the two given vectors
         */
        static ANGLE(_from, _to) {
            let angle = Math.acos(Vector3.DOT(_from, _to) / (_from.magnitude * _to.magnitude));
            return angle * FudgeCore.Calc.rad2deg;
        }
        //#endregion
        //#region Accessors
        // TODO: implement equals-functions
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        get z() {
            return this.data[2];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        set z(_z) {
            this.data[2] = _z;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector3.DOT(this, this);
        }
        /**
         * Creates and returns a clone of this vector
         */
        get clone() {
            let clone = FudgeCore.Recycler.get(Vector3);
            clone.data.set(this.data);
            return clone;
        }
        /**
         * - get: returns a geographic representation of this vector
         * - set: adjust the cartesian values of this vector to represent the given as geographic coordinates
         */
        set geo(_geo) {
            this.set(0, 0, _geo.magnitude);
            this.transform(FudgeCore.Matrix4x4.ROTATION_X(-_geo.latitude));
            this.transform(FudgeCore.Matrix4x4.ROTATION_Y(_geo.longitude));
        }
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.longitude = 180 * Math.atan2(this.x / geo.magnitude, this.z / geo.magnitude) / Math.PI;
            geo.latitude = 180 * Math.asin(this.y / geo.magnitude) / Math.PI;
            return geo;
        }
        //#endregion
        recycle() {
            this.data.set([0, 0, 0]);
        }
        /**
         * Copies the values of the given vector into this
         */
        copy(_original) {
            this.data.set(_original.data);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a cube with the opposite corners 1 and 2
         */
        isInsideCube(_corner1, _corner2) {
            let diagonal = Vector3.DIFFERENCE(_corner2, _corner1);
            let relative = Vector3.DIFFERENCE(this, _corner1);
            let ratio = Vector3.RATIO(relative, diagonal);
            if (ratio.x > 1 || ratio.x < 0)
                return false;
            if (ratio.y > 1 || ratio.y < 0)
                return false;
            if (ratio.z > 1 || ratio.z < 0)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a sphere with the given center and radius
         */
        isInsideSphere(_center, _radius) {
            let difference = Vector3.DIFFERENCE(this, _center);
            return difference.magnitudeSquared < (_radius * _radius);
        }
        /**
         * Adds the given vector to this
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y, _addend.z + this.z]);
        }
        /**
         * Subtracts the given vector from this
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y, this.z - _subtrahend.z]);
        }
        /**
         * Scales this vector by the given scalar
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y, _scalar * this.z]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector3.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0, _z = 0) {
            this.data[0] = _x;
            this.data[1] = _y;
            this.data[2] = _z;
        }
        /**
         * Returns this vector as a new Float32Array (copy)
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Transforms this vector by the given matrix or rotation quaternion.
         * Including or exluding the translation if a matrix is passed.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_transform, _includeTranslation = true) {
            let transformed = Vector3.TRANSFORMATION(this, _transform, _includeTranslation);
            this.data.set(transformed.data);
            FudgeCore.Recycler.store(transformed);
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components
         */
        toVector2() {
            return new FudgeCore.Vector2(this.x, this.y);
        }
        /**
         * Reflects this vector at a given normal. See {@link Vector3.REFLECTION}
         */
        reflect(_normal) {
            const reflected = Vector3.REFLECTION(this, _normal);
            this.set(reflected.x, reflected.y, reflected.z);
            FudgeCore.Recycler.store(reflected);
        }
        /**
         * Shuffles the components of this vector
         */
        shuffle() {
            let a = Array.from(this.data);
            this.set(FudgeCore.Random.default.splice(a), FudgeCore.Random.default.splice(a), a[0]);
        }
        /**
         * Returns the distance bewtween this vector and the given vector
         */
        getDistance(_to) {
            let difference = Vector3.DIFFERENCE(this, _to);
            FudgeCore.Recycler.store(difference);
            return difference.magnitude;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            this.z = Math.min(this.z, _compare.z);
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            this.z = Math.max(this.z, _compare.z);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         * and return a new vector with the results
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data = this.data.map(_function);
            return copy;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        async mutate(_mutator) {
            this.data[0] = _mutator.x ?? this.data[0];
            this.data[1] = _mutator.y ?? this.data[1];
            this.data[2] = _mutator.z ?? this.data[2];
        }
        getMutator() {
            let mutator = { x: this.data[0], y: this.data[1], z: this.data[2] };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a face of a {@link Mesh} by referencing three {@link Vertices} with their indizes
     * and calculates face normals.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Face {
        constructor(_vertices, _index0, _index1, _index2) {
            this.indices = [];
            this.indices = [_index0, _index1, _index2];
            this.vertices = _vertices;
            this.calculateNormals();
        }
        /**
         * Returns the position of the vertex referenced by the given index
         */
        getPosition(_index) {
            return this.vertices.position(this.indices[_index]);
        }
        /**
         * must be coplanar
         */
        isInside(_point) {
            let diffs = [];
            for (let index of this.indices) {
                let diff = FudgeCore.Vector3.DIFFERENCE(this.vertices.position(index), _point);
                diffs.push(diff);
            }
            let n0 = FudgeCore.Vector3.CROSS(diffs[1], diffs[0]);
            let n1 = FudgeCore.Vector3.CROSS(diffs[2], diffs[1]);
            let n2 = FudgeCore.Vector3.CROSS(diffs[0], diffs[2]);
            let dot1 = FudgeCore.Vector3.DOT(n0, n1);
            let dot2 = FudgeCore.Vector3.DOT(n0, n2);
            return !(dot1 < 0 || dot2 < 0);
        }
        calculateNormals() {
            let trigon = this.indices.map((_index) => this.vertices.position(_index));
            let v1 = FudgeCore.Vector3.DIFFERENCE(trigon[1], trigon[0]);
            let v2 = FudgeCore.Vector3.DIFFERENCE(trigon[2], trigon[0]);
            this.normalUnscaled = FudgeCore.Vector3.CROSS(v1, v2);
            this.normal = FudgeCore.Vector3.NORMALIZATION(this.normalUnscaled);
        }
    }
    FudgeCore.Face = Face;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var Mesh_1;
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019/22
     */
    let Mesh = class Mesh extends FudgeCore.Mutable {
        static { Mesh_1 = this; }
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Mesh_1; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        constructor(_name = "Mesh") {
            super();
            // TODO: at this time, creating the buffers for flat shading is a brute force algorithm and should be optimized in the different subclasses
            // TODO: rename vertices to verticesSmooth or just cloud, and cloud to vertices
            // 
            this.idResource = undefined;
            this.name = "Mesh";
            // base structure for meshes in FUDGE
            this.vertices = new FudgeCore.Vertices();
            this.faces = [];
            this.name = _name;
            this.clear();
            FudgeCore.Project.register(this);
        }
        static registerSubclass(_subClass) { return Mesh_1.subclasses.push(_subClass) - 1; }
        get type() {
            return this.constructor.name;
        }
        get boundingBox() {
            if (this.∆íbox == null)
                this.∆íbox = this.createBoundingBox();
            return this.∆íbox;
        }
        get radius() {
            if (this.∆íradius == null)
                this.∆íradius = this.createRadius();
            return this.∆íradius;
        }
        /**
         * Injected by {@link RenderInjectorMesh}.
         * Used by the render system.
         * @internal
         */
        useRenderBuffers(_shader, _mtxMeshToWorld, _mtxMeshToView, _id) { return null; /* injected by RenderInjector*/ }
        /**
         * Injected by {@link RenderInjectorMesh}.
         * Used by the render system.
         * @internal
         */
        getRenderBuffers(_shader) { return null; /* injected by RenderInjector*/ }
        /**
         * Injected by {@link RenderInjectorMesh}.
         * Used by the render system.
         * @internal
         */
        deleteRenderBuffers(_shader) { }
        /**
         * Clears the bounds of this mesh aswell as the buffers of the associated {@link RenderMesh}.
         */
        clear() {
            this.∆íbox = undefined;
            this.∆íradius = undefined;
            this.renderMesh?.clear();
        }
        //#region Transfer
        // Serialize/Deserialize for all meshes that calculate without parameters
        serialize() {
            let serialization = {
                idResource: this.idResource,
                name: this.name,
                type: this.type // store for editor view
            }; // no data needed ...
            return serialization;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            // type is an accessor and must not be deserialized
            return this;
        }
        reduceMutator(_mutator) {
            // TODO: so much to delete... rather just gather what to mutate
            delete _mutator.∆íbox;
            delete _mutator.∆íradius;
            delete _mutator.renderBuffers;
        }
        //#endregion
        createRadius() {
            //TODO: radius and bounding box could be created on construction of vertex-array
            let radius = 0;
            for (let i = 0; i < this.vertices.length; i++) {
                radius = Math.max(radius, this.vertices.position(i).magnitudeSquared);
            }
            return Math.sqrt(radius);
        }
        createBoundingBox() {
            let box = FudgeCore.Recycler.get(FudgeCore.Box);
            box.set();
            for (let i = 0; i < this.vertices.length; i++) {
                let point = this.vertices.position(i);
                box.expand(point);
            }
            return box;
        }
    };
    Mesh = Mesh_1 = __decorate([
        FudgeCore.RenderInjectorMesh.decorate
    ], Mesh);
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```text
     *       (12) 4____7  (11)
     *       (8) 0/__3/| (10)
     *       (15) ||5_||6 (14)
     *       (9) 1|/_2|/ (13)
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshCube extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube); }
        constructor(_name = "MeshCube") {
            super(_name);
            // no shared vertices, corners need three normals for Phong and Gouraud
            this.vertices = new FudgeCore.Vertices(
            // front vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0.5), new FudgeCore.Vector2(0, 0)), // 0
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0.5), new FudgeCore.Vector2(0, 1)), // 1
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0.5), new FudgeCore.Vector2(1, 1)), // 2
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0.5), new FudgeCore.Vector2(1, 0)) //3
            );
            // generate vertices on sides
            for (let angle = 90; angle < 360; angle += 90) {
                let transform = FudgeCore.Matrix4x4.ROTATION(FudgeCore.Vector3.Y(angle));
                let side = this.vertices.slice(0, 4).map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, transform), _v.uv));
                this.vertices.push(...side);
            }
            // generate vertices for top and bottom
            for (let angle = 90; angle < 360; angle += 180) {
                let transform = FudgeCore.Matrix4x4.ROTATION(FudgeCore.Vector3.X(angle));
                let side = this.vertices.slice(0, 4).map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, transform), _v.uv));
                this.vertices.push(...side);
            }
            this.faces = [];
            for (let i = 0; i < 24; i += 4)
                // generate faces
                this.faces.push(...new FudgeCore.Quad(this.vertices, i + 0, i + 1, i + 2, i + 3).faces);
        }
    }
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a flat polygon. All trigons share vertex 0, so careful design is required to create concave polygons.
     * Vertex 0 is also associated with the face normal.
     * ```text
     *             0
     *           1‚ï±|‚ï≤  4 ...
     *            ‚ï≤|_‚ï≤‚ï±
     *            2   3
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshPolygon extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPolygon); }
        static { this.shapeDefault = [
            new FudgeCore.Vector2(-1, -1),
            new FudgeCore.Vector2(1, -1),
            new FudgeCore.Vector2(0, 1)
        ]; }
        constructor(_name = "MeshPolygon", _shape = MeshPolygon.shapeDefault, _fitTexture = true) {
            super(_name);
            this.shape = new FudgeCore.MutableArray(FudgeCore.Vector2);
            this.create(_shape, _fitTexture);
        }
        get minVertices() {
            return 3;
        }
        /**
         * Create this mesh from the given vertices.
         */
        create(_shape = [], _fitTexture = true) {
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.clear();
            this.fitTexture = _fitTexture;
            if (_shape.length < this.minVertices) {
                FudgeCore.Debug.warn(`At least ${this.minVertices} vertices needed to construct MeshPolygon, default trigon used`);
                this.create(MeshPolygon.shapeDefault, true);
                return;
            }
            let shape = _shape;
            let min = FudgeCore.Vector2.ZERO();
            let max = FudgeCore.Vector2.ZERO();
            this.vertices = new FudgeCore.Vertices();
            for (let vertex of shape) {
                this.vertices.push(new FudgeCore.Vertex(vertex.toVector3()));
                min.x = Math.min(min.x, vertex.x);
                max.x = Math.max(max.x, vertex.x);
                min.y = Math.min(min.y, vertex.y);
                max.y = Math.max(max.y, vertex.y);
            }
            let size = new FudgeCore.Vector2(max.x - min.x, max.y - min.y);
            if (this.fitTexture) {
                for (let i = 0; i < shape.length; i++) {
                    let textureUV = FudgeCore.Vector2.DIFFERENCE(shape[i], min);
                    this.vertices[i].uv = new FudgeCore.Vector2(textureUV.x / size.x, 1 - textureUV.y / size.y);
                }
            }
            else {
                _shape.forEach((_vertex, _i) => this.vertices[_i].uv = new FudgeCore.Vector2(_vertex.x, -_vertex.y));
            }
            this.faces = [];
            for (let i = 2; i < this.vertices.length; i++)
                this.faces.push(new FudgeCore.Face(this.vertices, i - 1, i, 0));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.fitTexture = this.fitTexture;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let vectors = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.create(vectors, _serialization.fitTexture);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.create(this.shape, this.fitTexture);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.MeshPolygon = MeshPolygon;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshPolygon.ts"/>
var FudgeCore;
///<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates an extrusion of a polygon by a series of transformations
     * ```text
     *                      ____
     * Polygon         ____‚ï±‚ï≤   ‚ï≤                             y
     * Transform 0  ‚Üí ‚ï± ‚ï≤__‚ï≤_‚ï≤___‚ï≤ ‚Üê Transform 2          z __‚îÇ
     * (base)         ‚ï≤_‚ï±__‚ï± ‚ï±   ‚ï±   (lid)                     ‚ï≤
     *     Transform 1  ‚Üí  ‚ï≤‚ï±___‚ï±                               x
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshExtrusion extends FudgeCore.MeshPolygon {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshExtrusion); }
        static { this.mtxDefaults = [
            FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(0.5)),
            FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(-0.5))
        ]; }
        constructor(_name = "MeshExtrusion", _vertices = FudgeCore.MeshPolygon.shapeDefault, _mtxTransforms = MeshExtrusion.mtxDefaults, _fitTexture = true) {
            super(_name, _vertices, _fitTexture);
            this.mtxTransforms = new FudgeCore.MutableArray(FudgeCore.Matrix4x4);
            this.extrude(_mtxTransforms);
            // console.log("Mutator", this.getMutator());
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.transforms = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxTransforms);
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let mtxTransforms;
            if (_serialization.transforms)
                mtxTransforms = await FudgeCore.Serializer.deserializeArray(_serialization.transforms);
            this.extrude(mtxTransforms);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.extrude(this.mtxTransforms);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
        //#endregion
        extrude(_mtxTransforms = MeshExtrusion.mtxDefaults) {
            this.mtxTransforms = FudgeCore.MutableArray.from(_mtxTransforms);
            let nTransforms = _mtxTransforms.length;
            let nVerticesShape = this.vertices.length;
            // create new vertex cloud, current cloud holds MeshPolygon
            let vertices = new FudgeCore.Vertices();
            // create base by transformation of polygon with first transform
            let base = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[0], true), _v.uv));
            vertices.push(...base);
            // create lid by transformation of polygon with last transform
            let lid = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[nTransforms - 1], true), _v.uv));
            vertices.push(...lid);
            // recreate base faces to recalculate normals
            this.faces = this.faces.map((_face) => new FudgeCore.Face(vertices, _face.indices[0], _face.indices[1], _face.indices[2]));
            // create the lid faces using the indices of the base faces, but with an index offset and reverse order of indices
            this.faces.push(...this.faces.map(_face => new FudgeCore.Face(vertices, _face.indices[2] + nVerticesShape, _face.indices[1] + nVerticesShape, _face.indices[0] + nVerticesShape)));
            for (let t = 0; t < nTransforms; t++) {
                let mtxTransform = _mtxTransforms[t];
                let referToClose = vertices.length;
                let wrap = this.vertices.map((_v, _i) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, mtxTransform, true), new FudgeCore.Vector2(_i / nVerticesShape, t / nTransforms)));
                vertices.push(...wrap);
                vertices.push(new FudgeCore.Vertex(referToClose, new FudgeCore.Vector2(1, t / nTransforms)));
                // if (i > 0 && i < nTransforms - 1)
                //   vertices.push(...wrap.map((_vector: Vector3) => _vector.clone)); <- no slicing for flat shading yet...
            }
            // create indizes for wrapper
            for (let t = 0; t < nTransforms - 1; t++)
                for (let i = 0; i < nVerticesShape; i++) {
                    let index = +2 * nVerticesShape // base & lid are offsets 
                        + t * (nVerticesShape + 1) // offset for each transformation
                        + i;
                    let quad = new FudgeCore.Quad(vertices, index, index + nVerticesShape + 1, index + nVerticesShape + 2, index + 1, FudgeCore.QUADSPLIT.AT_0);
                    this.faces.push(...quad.faces);
                }
            this.vertices = vertices;
            return;
        }
    }
    FudgeCore.MeshExtrusion = MeshExtrusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Allows to create custom meshes from given Data */
    class MeshFromData extends FudgeCore.Mesh {
        constructor(_vertices, _textureUVs, _indices, _faceNormals) {
            super();
            this.verticesToSet = _vertices;
            this.textureUVsToSet = _textureUVs;
            this.indicesToSet = _indices;
            this.faceNormalsToSet = _faceNormals;
        }
        createVertices() {
            return this.verticesToSet;
        }
        createTextureUVs() {
            return this.textureUVsToSet;
        }
        createIndices() {
            return this.indicesToSet;
        }
        createFlatNormals() {
            return this.faceNormalsToSet;
        }
    }
    FudgeCore.MeshFromData = MeshFromData;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Mesh loaded from a file
     * @author Matthias Roming, HFU, 2022-2023
     */
    class MeshImport extends FudgeCore.Mesh {
        serialize() {
            const serialization = super.serialize();
            serialization.url = this.url.toString();
            serialization.filetype = this.loader.name.replace(FudgeCore.MeshLoader.name, "");
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization);
            this.url = _serialization.url;
            this.loader = Reflect.get(FudgeCore, FudgeCore.MeshLoader.name.concat(_serialization.filetype));
            return this.load();
        }
        /**
         * Load mesh from file
         */
        async load(_loader = this.loader, _url = this.url, _data) {
            this.url = _url;
            this.loader = _loader;
            this.clear();
            if (!this.renderMesh)
                this.renderMesh = new FudgeCore.RenderMesh(this);
            return _loader.load(this, _data);
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            if (typeof (_mutator.url) !== "undefined")
                this.load(this.loader, _mutator.url);
        }
    }
    FudgeCore.MeshImport = MeshImport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```text
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshPyramid extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid); }
        constructor(_name = "MeshPyramid") {
            super(_name);
            // this.create();
            this.vertices = new FudgeCore.Vertices(
            // ground vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, 0.5), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, 0.5), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, -0.5), new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, -0.5), new FudgeCore.Vector2(0, 0)), 
            // tip (vertex #4)
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.0, 1.0, 0.0), new FudgeCore.Vector2(0.5, 0.5)), 
            // floor again for downside texture
            new FudgeCore.Vertex(0, new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(1, new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(2, new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(3, new FudgeCore.Vector2(0, 1)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 4, 0, 1),
                new FudgeCore.Face(this.vertices, 4, 1, 2),
                new FudgeCore.Face(this.vertices, 4, 2, 3),
                new FudgeCore.Face(this.vertices, 4, 3, 0),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 2, 5 + 1),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 3, 5 + 2)
            ];
        }
    }
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```text
     *        0 __ 3
     *         |_\|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019-2022
     */
    class MeshQuad extends FudgeCore.MeshPolygon {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad); }
        static { this.shape = [
            new FudgeCore.Vector2(-0.5, 0.5), new FudgeCore.Vector2(-0.5, -0.5), new FudgeCore.Vector2(0.5, -0.5), new FudgeCore.Vector2(0.5, 0.5)
        ]; }
        constructor(_name = "MeshQuad") {
            super(_name, MeshQuad.shape);
        }
        // // flat equals smooth
        // public get verticesFlat(): Float32Array { return this.vertices; }
        // public get indicesFlat(): Uint16Array { return this.indices; }
        // public get normalsFlat(): Float32Array { return this.normalsVertex; }
        //#region Transger
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(MeshQuad.shape, true); // this seems to be dispatched doubled while deserializing the resources
            return this;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
            delete _mutator.fitTexture;
        }
    }
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Information about the vertical projection of a given position onto the terrain
     */
    class TerrainInfo {
    }
    FudgeCore.TerrainInfo = TerrainInfo;
    /**
     * A terrain spreads out in the x-z-plane, y is the height derived from the heightmap function.
     * The terrain is always 1 in size in all dimensions, fitting into the unit-cube.
     * Resolution determines the number of quads in x and z dimension, scale the factor applied to the x,z-coordinates passed to the heightmap function.
     * Standard function is the simplex noise implemented with FUDGE, but another function can be given.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Simon Storl-Schulke, HFU, 2020 | Moritz Beaugrand, HFU, 2021
     */
    class MeshTerrain extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTerrain); }
        constructor(_name = "MeshTerrain", _resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            super(_name);
            this.heightMapFunction = null;
            this.create(_resolution, _scaleInput, _functionOrSeed);
        }
        /**
         * Create this mesh from the given parameters
         */
        create(_resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            this.clear();
            this.seed = undefined;
            this.resolution = new FudgeCore.Vector2(Math.round(_resolution.x), Math.round(_resolution.y));
            this.scale = _scaleInput.clone;
            if (_functionOrSeed instanceof Function)
                this.heightMapFunction = _functionOrSeed;
            else if (typeof (_functionOrSeed) == "number") {
                this.seed = _functionOrSeed;
                let prng = new FudgeCore.Random(this.seed);
                this.heightMapFunction = new FudgeCore.Noise2(() => prng.getNorm()).sample; // TODO call PRNG
            }
            else
                this.heightMapFunction = new FudgeCore.Noise2().sample;
            this.vertices = new FudgeCore.Vertices();
            //Iterate over each cell to generate grid of vertices
            for (let z = 0; z <= this.resolution.y; z++) {
                for (let x = 0; x <= this.resolution.x; x++) {
                    let xNorm = x / this.resolution.x;
                    let zNorm = z / this.resolution.y;
                    this.vertices.push(new FudgeCore.Vertex(new FudgeCore.Vector3(xNorm - 0.5, this.heightMapFunction(xNorm * this.scale.x, zNorm * this.scale.y), zNorm - 0.5), new FudgeCore.Vector2(xNorm, zNorm)));
                }
            }
            let quads = [];
            let split = FudgeCore.QUADSPLIT.AT_0;
            for (let z = 0; z < this.resolution.y; z++) {
                for (let x = 0; x < this.resolution.x; x++) {
                    quads.push(new FudgeCore.Quad(this.vertices, (x + 0) + (z + 0) * (this.resolution.x + 1), (x + 0) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 0) * (this.resolution.x + 1), split));
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
                }
                if (this.resolution.x % 2 == 0) // reverse last split change if x-resolution is even
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
            }
            this.faces = quads.flatMap((_quad) => _quad.faces);
        }
        /**
         * Returns information about the vertical projection of the given position onto the terrain.
         * Pass the overall world transformation of the terrain if the position is given in world coordinates.
         * If at hand, pass the inverse too to avoid unnecessary calculation.
         */
        getTerrainInfo(_position, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _mtxInverse) {
            if (!_mtxInverse)
                _mtxInverse = FudgeCore.Matrix4x4.INVERSION(_mtxWorld);
            let terrainInfo = new TerrainInfo;
            let posLocal = FudgeCore.Vector3.TRANSFORMATION(_position, _mtxInverse, true);
            let z = Math.floor((posLocal.z + 0.5) * this.resolution.y);
            let x = Math.floor((posLocal.x + 0.5) * this.resolution.x);
            if (z < 0 || z > this.resolution.y - 1 || x < 0 || x > this.resolution.x - 1)
                return null;
            let index = (z * this.resolution.x + x) * 2;
            let face = this.faces[index];
            let ray = new FudgeCore.Ray(FudgeCore.Vector3.Y(), posLocal);
            let point = ray.intersectFacePlane(face);
            if (!face.isInside(point)) {
                index++;
                face = this.faces[index];
                point = ray.intersectFacePlane(face);
            }
            terrainInfo.index = index;
            terrainInfo.positionFace = point;
            terrainInfo.position = FudgeCore.Vector3.TRANSFORMATION(point, _mtxWorld, true);
            terrainInfo.normal = FudgeCore.Vector3.TRANSFORMATION(face.normal, FudgeCore.Matrix4x4.TRANSPOSE(_mtxInverse), false);
            terrainInfo.distance = _position.y - terrainInfo.position.y;
            terrainInfo.grid = this.getGridFromFaceIndex(index);
            return terrainInfo;
        }
        /**
         * Returns the grid coordinates of the quad the given face belongs to.
         */
        getGridFromFaceIndex(_index) {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector2);
            let iQuad = Math.floor(_index / 2);
            result.set(iQuad % this.resolution.y, Math.floor(iQuad / this.resolution.x));
            return result;
        }
        /**
         * Returns the indices of the two faces forming the quad the given grid position belongs to.
         */
        getFaceIndicesFromGrid(_grid) {
            let iQuad = _grid.y * 2 * this.resolution.x + _grid.x * 2;
            return [iQuad, iQuad + 1];
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.seed = this.seed;
            serialization.scale = this.scale.serialize();
            serialization.resolution = this.resolution.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.resolution.deserialize(_serialization.resolution);
            await this.scale.deserialize(_serialization.scale);
            this.seed = _serialization.seed;
            this.create(this.resolution, this.scale, this.seed);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(this.resolution, this.scale, this.seed);
        }
    }
    FudgeCore.MeshTerrain = MeshTerrain;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshTerrain.ts"/>
var FudgeCore;
///<reference path="MeshTerrain.ts"/>
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021 | Moritz Beaugrand, HFU, 2020
     */
    class MeshRelief extends FudgeCore.MeshTerrain {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRelief); }
        constructor(_name = "MeshRelief", _texture = null) {
            super(_name, FudgeCore.Vector2.ONE(2), undefined, (_x, _z) => 0);
            this.texture = null;
            this.setTexture(_texture);
        }
        static createHeightMapFunction(_texture) {
            let array = MeshRelief.textureToClampedArray(_texture);
            let heightMapFunction = (_x, _z) => {
                let pixel = Math.round(_z * _texture.image.width + _x);
                return array[pixel * 4] / 255;
            };
            return heightMapFunction;
        }
        static textureToClampedArray(_texture) {
            let canvas = document.createElement("canvas");
            canvas.width = _texture.image.width;
            canvas.height = _texture.image.height;
            let crc = canvas.getContext("2d");
            crc.imageSmoothingEnabled = false;
            crc.drawImage(_texture.image, 0, 0);
            return crc.getImageData(0, 0, _texture.image.width, _texture.image.height).data;
        }
        /**
         * Sets the texture to be used as heightmap
         */
        setTexture(_texture = null) {
            if (!_texture)
                return;
            this.texture = _texture;
            let resolution = _texture ? new FudgeCore.Vector2(_texture.image.width - 1, _texture.image.height - 1) : undefined;
            super.create(resolution, resolution, MeshRelief.createHeightMapFunction(_texture));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            delete serialization.seed;
            delete serialization.scale;
            delete serialization.resolution;
            if (this.texture)
                serialization.idTexture = this.texture.idResource;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            if (_serialization.idTexture) {
                this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                this.setTexture(this.texture);
            }
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.texture) !== "undefined")
                this.setTexture(_mutator.texture);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.seed;
            delete _mutator.scale;
            delete _mutator.resolution;
        }
    }
    FudgeCore.MeshRelief = MeshRelief;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="MeshPolygon.ts"/>
var FudgeCore;
// /<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates a rotation of a polygon around the y-axis
     * ```text
     *                     y
     *                  _  ‚Üë 0_1
     *                 ‚îÇ   ‚îÇ‚Üíx ‚îÇ2
     *                  ‚ï≤  ‚îÇ  ‚ï±3
     *                  ‚ï±  ‚îÇ  ‚ï≤
     *                 ‚ï±___‚îÇ___‚ï≤4
     *                      5
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshRotation extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRotation); }
        static { this.verticesDefault = [
            new FudgeCore.Vector2(0.5, 0.5),
            new FudgeCore.Vector2(0.5, -0.5)
        ]; }
        constructor(_name = "MeshRotation", _shape = MeshRotation.verticesDefault, _longitudes = 3) {
            super(_name);
            this.shape = new FudgeCore.MutableArray(FudgeCore.Vector2);
            this.rotate(_shape, _longitudes);
            // console.log("Mutator", this.getMutator());
        }
        get minVertices() {
            return 2;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.longitudes = this.longitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let shape = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.longitudes = _serialization.longitudes;
            this.rotate(shape, this.longitudes);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.rotate(this.shape, this.longitudes);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        //#endregion
        rotate(_shape, _longitudes) {
            this.clear();
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.longitudes = Math.round(_longitudes);
            let angle = 360 / this.longitudes;
            let mtxRotate = FudgeCore.Matrix4x4.ROTATION_Y(angle);
            // copy original polygon as Vector3 array
            let polygon = [];
            let distances = [0];
            let total = 0;
            for (let i = 0; i < this.shape.length; i++) {
                polygon.push(this.shape[i].toVector3());
                if (i > 0) {
                    let distance = FudgeCore.Vector2.DIFFERENCE(this.shape[i], this.shape[i - 1]).magnitude;
                    total += distance;
                    distances.push(total);
                }
            }
            distances.forEach((_entry, _index) => { distances[_index] = _entry / total; });
            let nVerticesPolygon = polygon.length;
            let cloud = new FudgeCore.Vertices();
            for (let longitude = 0; longitude <= this.longitudes; longitude++) {
                for (let i = 0; i < nVerticesPolygon; i++) {
                    let uv = new FudgeCore.Vector2(longitude / this.longitudes, distances[i]);
                    // TODO: last sector should only be references to the first meridian
                    if (longitude == this.longitudes)
                        cloud.push(new FudgeCore.Vertex(i, uv));
                    else {
                        if (longitude > 0 && this.shape[i].x == 0) // use a single vertex when it's on the rotation axis
                            cloud.push(new FudgeCore.Vertex(i, uv));
                        else
                            cloud.push(new FudgeCore.Vertex(polygon[i].clone, uv));
                    }
                }
                polygon.forEach((_vector) => _vector.transform(mtxRotate));
            }
            // copy indices to new index array
            let faces = [];
            for (let longitude = 0; longitude < this.longitudes; longitude++) {
                for (let latitude = 0; latitude < nVerticesPolygon - 1; latitude++) {
                    let start = longitude * nVerticesPolygon + latitude;
                    let quad = new FudgeCore.Quad(cloud, start + 1, start + 1 + nVerticesPolygon, start + nVerticesPolygon, start);
                    faces.push(...quad.faces);
                    // TODO: catch invalid faces right here...
                }
            }
            this.vertices = cloud;
            this.faces = faces;
        }
    }
    FudgeCore.MeshRotation = MeshRotation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the data from the {@link MeshSkin} into a WebGL Buffer
     * @internal
     */
    class RenderInjectorMeshSkin extends FudgeCore.RenderInjectorMesh {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMeshSkin.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "getRenderBuffers", {
                value: RenderInjectorMeshSkin.getRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMeshSkin.deleteRenderBuffers
            });
        }
        static getRenderBuffers(_shader) {
            let renderBuffers = super.getRenderBuffers.call(this, _shader);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (!renderBuffers.bones) {
                renderBuffers.bones = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.bones);
                crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.bones, WebGL2RenderingContext.STATIC_DRAW);
            }
            if (!renderBuffers.weights) {
                renderBuffers.weights = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.weights);
                crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.weights, WebGL2RenderingContext.STATIC_DRAW);
            }
            return renderBuffers;
        }
        static useRenderBuffers(_shader, _mtxMeshToWorld, _mtxMeshToView, _id) {
            let renderBuffers = super.useRenderBuffers.call(this, _shader, _mtxMeshToWorld, _mtxMeshToView, _id);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const aBone = _shader.attributes["a_vctBones"];
            if (aBone) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.bones);
                crc3.enableVertexAttribArray(aBone);
                crc3.vertexAttribIPointer(aBone, 4, WebGL2RenderingContext.UNSIGNED_BYTE, 0, 0);
            }
            const aWeight = _shader.attributes["a_vctWeights"];
            if (aWeight) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.weights);
                crc3.enableVertexAttribArray(aWeight);
                crc3.vertexAttribPointer(aWeight, 4, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            return renderBuffers;
        }
        static deleteRenderBuffers(_renderBuffers) {
            super.deleteRenderBuffers(_renderBuffers);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_renderBuffers) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.bones);
                crc3.deleteBuffer(_renderBuffers.weights);
            }
        }
    }
    FudgeCore.RenderInjectorMeshSkin = RenderInjectorMeshSkin;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./../Render/RenderInjectorMeshSkin.ts"/>
///<reference path="./MeshImport.ts"/>
var FudgeCore;
///<reference path="./../Render/RenderInjectorMeshSkin.ts"/>
///<reference path="./MeshImport.ts"/>
(function (FudgeCore) {
    /**
     * Mesh influenced by a skeleton and loaded from a file
     * @authors Matthias Roming, HFU, 2022-2023 | Jonas Plotzky, HFU, 2023
     */
    let MeshSkin = class MeshSkin extends FudgeCore.MeshImport {
    };
    MeshSkin = __decorate([
        FudgeCore.RenderInjectorMeshSkin.decorate
    ], MeshSkin);
    FudgeCore.MeshSkin = MeshSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSphere extends FudgeCore.MeshRotation {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere); }
        constructor(_name = "MeshSphere", _longitudes = 8, _latitudes = 8) {
            super(_name);
            this.create(_longitudes, _latitudes);
        }
        /**
         * Create this sphere with a given number of longitudes and latitudes
         */
        create(_longitudes = 3, _latitudes = 2) {
            this.clear();
            //Clamp resolution to prevent performance issues
            this.longitudes = Math.min(Math.round(_longitudes), 128);
            this.latitudes = Math.min(Math.round(_latitudes), 128);
            if (_longitudes < 3 || _latitudes < 2) {
                FudgeCore.Debug.warn("UV Sphere must have at least 3 longitudes and 2 latitudes to form a 3-dimensional shape.");
                this.longitudes = Math.max(3, _longitudes);
                this.latitudes = Math.max(2, _latitudes);
            }
            let shape = [];
            let step = Math.PI / this.latitudes;
            for (let i = 0; i <= this.latitudes; ++i) {
                let angle = Math.PI / 2 - i * step;
                let x = Math.cos(angle);
                let y = Math.sin(angle);
                shape.push(new FudgeCore.Vector2(x / 2, y / 2));
            }
            // place first and last vertex exactly on rotation axis
            shape[0].x = 0;
            shape[shape.length - 1].x = 0;
            super.rotate(shape, _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            delete serialization.shape;
            serialization.latitudes = this.latitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```text
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSprite extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite); }
        constructor(_name = "MeshSprite") {
            super(_name);
            this.vertices = new FudgeCore.Vertices(new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0), new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0), new FudgeCore.Vector2(1, 0)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 1, 2, 0),
                new FudgeCore.Face(this.vertices, 2, 3, 0),
                new FudgeCore.Face(this.vertices, 0, 3, 1),
                new FudgeCore.Face(this.vertices, 3, 2, 1)
            ];
        }
        // flat is standard here
        get verticesFlat() { return this.renderMesh.vertices; }
        get indicesFlat() { return this.renderMesh.indices; }
    }
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a Torus with a given thickness and the number of major- and minor segments
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshTorus extends FudgeCore.MeshRotation {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTorus); }
        constructor(_name = "MeshTorus", _size = 0.25, _longitudes = 8, _latitudes = 6) {
            super(_name, MeshTorus.getShape(_size, Math.max(3, _latitudes)), _longitudes);
            this.size = 0.25;
            this.latitudes = 12;
            this.size = _size;
            this.longitudes = _longitudes;
            this.latitudes = Math.max(3, _latitudes);
        }
        static getShape(_size, _latitudes) {
            let shape = [];
            let radius = _size / 2;
            let center = new FudgeCore.Vector2(0.25 + radius, 0);
            for (let latitude = 0; latitude <= _latitudes; latitude++) {
                let angle = 2 * Math.PI * latitude / _latitudes;
                shape.push(FudgeCore.Vector2.SUM(center, new FudgeCore.Vector2(radius * -Math.cos(angle), radius * Math.sin(angle))));
            }
            return shape;
        }
        /**
         * Create this torus from the given parameters
         */
        create(_size = 0.25, _longitudes = 8, _latitudes = 6) {
            this.size = _size;
            this.latitudes = Math.max(3, _latitudes);
            super.rotate(MeshTorus.getShape(_size, _latitudes), _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.latitudes = this.latitudes;
            serialization.size = this.size;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.size, _serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(this.size, this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    FudgeCore.MeshTorus = MeshTorus;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let QUADSPLIT;
    (function (QUADSPLIT) {
        QUADSPLIT[QUADSPLIT["PLANAR"] = 0] = "PLANAR";
        QUADSPLIT[QUADSPLIT["AT_0"] = 1] = "AT_0";
        QUADSPLIT[QUADSPLIT["AT_1"] = 2] = "AT_1";
    })(QUADSPLIT = FudgeCore.QUADSPLIT || (FudgeCore.QUADSPLIT = {}));
    /**
     * A surface created with four vertices which immediately creates none, one or two {@link Face}s depending on vertices at identical positions.
     * ```text
     * QUADSPLIT:  PLANAR                  AT_0                     AT_1
     *             0 _ 3                   0 _ 3                    0 _ 3
     *              |\|                     |\|                      |/|
     *             1 ‚Äæ 2                   1 ‚Äæ 2                    1 ‚Äæ 2
     *  shared last vertex 2      last vertices 2 + 3      last vertices 3 + 0
     *
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Quad {
        #split;
        constructor(_vertices, _index0, _index1, _index2, _index3, _split = QUADSPLIT.PLANAR) {
            this.faces = [];
            this.#split = _split;
            try {
                if (_split != QUADSPLIT.AT_1)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index1, _index2));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index2, _index3));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
            try {
                if (_split == QUADSPLIT.PLANAR)
                    this.faces.push(new FudgeCore.Face(_vertices, _index3, _index0, _index2));
                else if (_split == QUADSPLIT.AT_0)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index2, _index3));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index3, _index0));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
        }
        get split() {
            return this.#split;
        }
    }
    FudgeCore.Quad = Quad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a vertex of a mesh with extended information such as the uv coordinates and the vertex normal.
     * It may refer to another vertex via an index into some array, in which case the position and the normal are stored there.
     * This way, vertex position and normal is a 1:1 association, vertex to texture coordinates a 1:n association.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertex {
        constructor(_positionOrIndex, _uv = undefined, _normal = FudgeCore.Vector3.ZERO(), _color = new FudgeCore.Color(1, 1, 1, 1), _bones = null) {
            if (_positionOrIndex instanceof FudgeCore.Vector3)
                this.position = _positionOrIndex;
            else
                this.referTo = _positionOrIndex;
            this.uv = _uv;
            this.normal = _normal;
            this.color = _color;
            this.bones = _bones;
        }
    }
    FudgeCore.Vertex = Vertex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Array with extended functionality to serve as a {@link Vertex}-cloud.
     * Accessors yield position or normal also for vertices referencing other vertices
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertices extends Array {
        // TODO: this class may become more powerful by hiding the array and add more service methods like calculating bounding box, radius etc.
        // see if a proxy of the array interfacing [] would do a good job -> tested: proxy is about 20 times slower!
        /**
         * Returns the subset of vertices that do not refer to other vertices
         */
        get originals() {
            return this.filter(_vertex => _vertex.referTo == undefined);
        }
        /**
         * returns the position associated with the vertex addressed, resolving references between vertices
         */
        position(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.position : this[vertex.referTo].position;
        }
        /**
         * returns the normal associated with the vertex addressed, resolving references between vertices
         */
        normal(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.normal : this[vertex.referTo].normal;
        }
        /**
         * returns the uv-coordinates associated with the vertex addressed
         */
        uv(_index) {
            return this[_index].uv;
        }
        /**
         * returns the color associated with the vertex addressed
         */
        color(_index) {
            return this[_index].color;
        }
        /**
         * returns the bones associated with the vertex addressed, resolving references between vertices
         */
        bones(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.bones : this[vertex.referTo].bones;
        }
    }
    FudgeCore.Vertices = Vertices;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for MeshImport-loaders
     * @author Matthias Roming, HFU, 2023
     */
    class MeshLoader {
        /**
         * Loads the given data into the given mesh
         */
        static async load(_mesh, _data) {
            return _mesh;
        }
    }
    FudgeCore.MeshLoader = MeshLoader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Filmbox mesh import
     * @authors Matthias Roming, HFU, 2023 | Jonas Plotzky, HFU, 2023
     * @ignore currently not working
     */
    class MeshLoaderFBX extends FudgeCore.MeshLoader {
        static async load(_mesh, _data) {
            const loader = await FudgeCore.FBXLoader.LOAD(_mesh.url.toString());
            const geometryFBX = (_data ||
                loader.fbx.objects.geometries.find(object => object.name == _mesh.name) ||
                loader.fbx.objects.models.find(object => object.name == _mesh.name && object.subtype == "Mesh").children[0]).load();
            if (_data)
                _mesh.name = _data.name.length > 0 ? _data.name : _data.parents[0].name;
            let positions = [];
            let vertexBuffer = geometryFBX.Vertices;
            for (let iVertex = 0; iVertex < vertexBuffer.length; iVertex += 3) {
                positions.push(new FudgeCore.Vector3(vertexBuffer[iVertex + 0], vertexBuffer[iVertex + 1], vertexBuffer[iVertex + 2]));
            }
            let uvs = [];
            if (geometryFBX.LayerElementUV) {
                let uvBuffer = geometryFBX.LayerElementUV.UV;
                for (let iuv = 0; iuv < uvBuffer.length; iuv += 2) {
                    uvs.push(new FudgeCore.Vector2(uvBuffer[iuv], 1 - uvBuffer[iuv + 1]));
                }
            }
            let normals = [];
            if (geometryFBX.LayerElementNormal) {
                let normalBuffer = geometryFBX.LayerElementNormal.Normals;
                for (let iNormal = 0; iNormal < normalBuffer.length; iNormal += 3) {
                    normals.push(new FudgeCore.Vector3(normalBuffer[iNormal], normalBuffer[iNormal + 1], normalBuffer[iNormal + 2]));
                }
            }
            let mapVertexToIndex = new Map();
            let newVertexIndices = [];
            let iPolygon = 0;
            let isEndOfPolygon = false;
            let polygon = [];
            geometryFBX.PolygonVertexIndex.forEach((_iVertex, _iPolygonVertex) => {
                if (_iVertex < 0) {
                    _iVertex = _iVertex ^ -1;
                    isEndOfPolygon = true;
                }
                let position = positions[_iVertex];
                let uv = uvs[getDataIndex(geometryFBX.LayerElementUV, _iVertex, iPolygon, _iPolygonVertex)];
                let vertexKey = position.toString() + uv.toString();
                if (!mapVertexToIndex.has(vertexKey)) {
                    let normal = normals[getDataIndex(geometryFBX.LayerElementNormal, _iVertex, iPolygon, _iPolygonVertex)];
                    _mesh.vertices.push(new FudgeCore.Vertex(position, uv, normal));
                    mapVertexToIndex.set(vertexKey, _mesh.vertices.length - 1);
                    if (!newVertexIndices[_iVertex])
                        newVertexIndices[_iVertex] = [];
                    newVertexIndices[_iVertex].push(_mesh.vertices.length - 1);
                }
                polygon.push(mapVertexToIndex.get(vertexKey));
                if (isEndOfPolygon) {
                    if (polygon.length == 3) {
                        _mesh.faces.push(new FudgeCore.Face(_mesh.vertices, polygon[0], polygon[1], polygon[2]));
                    }
                    else if (polygon.length == 4) {
                        let quad = new FudgeCore.Quad(_mesh.vertices, polygon[0], polygon[1], polygon[2], polygon[3]);
                        _mesh.faces.push(...quad.faces);
                    }
                    else {
                        for (let i = 2; i < polygon.length; i++)
                            _mesh.faces.push(new FudgeCore.Face(_mesh.vertices, polygon[0], polygon[i - 1], polygon[i - 0]));
                        // console.warn(`${MeshLoaderFBX.name}: Polygons with more than 4 vertices are not supported.`);
                    }
                    polygon = [];
                    isEndOfPolygon = false;
                    iPolygon++;
                }
            });
            if (_mesh instanceof FudgeCore.MeshSkin) {
                const fbxDeformer = geometryFBX.children[0];
                const skeleton = await loader.getSkeleton(fbxDeformer.children[0].children[0]); // Deformer.SubDeformer.LimbNode
                createBones(fbxDeformer, skeleton, _mesh.vertices, newVertexIndices);
            }
            return _mesh;
        }
    }
    FudgeCore.MeshLoaderFBX = MeshLoaderFBX;
    function getDataIndex(_layerElement, _iVertex, _iPolygon, _iPolygonVertex) {
        let index = _layerElement.MappingInformationType == "ByVertex" ?
            _iVertex :
            _layerElement.MappingInformationType == "ByPolygon" ?
                _iPolygon :
                _iPolygonVertex;
        if (_layerElement.ReferenceInformationType === 'IndexToDirect') {
            let indices = _layerElement.UVIndex || _layerElement.NormalsIndex;
            index = indices[index];
        }
        return index;
    }
    function createBones(_deformerFBX, _skeleton, _vertices, _newVertexIndices) {
        for (const fbxSubDeformer of _deformerFBX.children) {
            fbxSubDeformer.load();
            if (fbxSubDeformer.Indexes)
                for (let iBoneInfluence = 0; iBoneInfluence < fbxSubDeformer.Indexes.length; iBoneInfluence++) {
                    const iVertex = fbxSubDeformer.Indexes[iBoneInfluence];
                    for (const iVertexNew of _newVertexIndices ? _newVertexIndices[iVertex] : [iVertex]) {
                        (_vertices[iVertexNew].bones || (_vertices[iVertexNew].bones = [])).push({
                            index: _skeleton.indexOf(fbxSubDeformer.children[0].name),
                            weight: fbxSubDeformer.Weights[iBoneInfluence] || 1
                        });
                    }
                }
        }
    }
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * gl Transfer Format mesh import
     * @authors Matthias Roming, HFU, 2022-2023 | Jonas Plotzky, HFU, 2023
     */
    class MeshLoaderGLTF extends FudgeCore.MeshLoader {
        static async load(_mesh, _data) {
            const loader = await FudgeCore.GLTFLoader.LOAD(_mesh.url.toString());
            const gltfMesh = loader.gltf.meshes[_data.iMesh];
            const gltfPrimitive = gltfMesh.primitives[_data.iPrimitive];
            if (gltfPrimitive.indices == undefined)
                FudgeCore.Debug.warn(`${loader}: Mesh with index ${_data.iMesh} primitive ${_data.iPrimitive} has no indices. FUDGE does not support non-indexed meshes.`);
            if (gltfPrimitive.attributes.POSITION == undefined)
                FudgeCore.Debug.warn(`${loader}: Mesh with index ${_data.iMesh} primitive ${_data.iPrimitive} has no position attribute. Primitive will be ignored.`);
            if (gltfPrimitive.mode != undefined && gltfPrimitive.mode != GLTF.MESH_PRIMITIVE_MODE.TRIANGLES)
                FudgeCore.Debug.warn(`${loader}: Mesh with index ${_data.iMesh} primitive ${_data.iPrimitive} has topology type mode ${GLTF.MESH_PRIMITIVE_MODE[gltfPrimitive.mode]}. FUDGE only supports ${GLTF.MESH_PRIMITIVE_MODE[4]}.`);
            checkMaxSupport(gltfPrimitive.attributes, "TEXCOORD", 2);
            checkMaxSupport(gltfPrimitive.attributes, "COLOR", 1);
            checkMaxSupport(gltfPrimitive.attributes, "JOINTS", 1);
            checkMaxSupport(gltfPrimitive.attributes, "WEIGHTS", 1);
            _mesh.name = gltfMesh.name;
            let indices;
            let vertices;
            let normals;
            // let tangents: Float32Array;
            let textureUVs;
            let colors;
            let bones;
            let weights;
            if (gltfPrimitive.indices != undefined)
                indices = await loader.getVertexIndices(gltfPrimitive.indices); // maybe throw error instead
            if (gltfPrimitive.attributes.POSITION != undefined)
                vertices = await loader.getFloat32Array(gltfPrimitive.attributes.POSITION); // maybe throw error instead
            if (gltfPrimitive.attributes.NORMAL != undefined)
                normals = await loader.getFloat32Array(gltfPrimitive.attributes.NORMAL);
            // TODO: add tangents to RenderMesh
            // if (gltfPrimitive.attributes.TANGENT)
            //   tangents = await loader.getFloat32Array(gltfPrimitive.attributes.TANGENT);
            if (gltfPrimitive.attributes.TEXCOORD_1 != undefined)
                textureUVs = await loader.getFloat32Array(gltfPrimitive.attributes.TEXCOORD_1);
            else if (gltfPrimitive.attributes.TEXCOORD_0 != undefined)
                textureUVs = await loader.getFloat32Array(gltfPrimitive.attributes.TEXCOORD_0);
            if (gltfPrimitive.attributes.COLOR_0 != undefined)
                colors = await loader.getVertexColors(gltfPrimitive.attributes.COLOR_0);
            if (gltfPrimitive.attributes.JOINTS_0 != undefined && gltfPrimitive.attributes.WEIGHTS_0 != undefined) {
                bones = await loader.getBoneIndices(gltfPrimitive.attributes.JOINTS_0);
                weights = await loader.getFloat32Array(gltfPrimitive.attributes.WEIGHTS_0);
            }
            for (let iVertex = 0, iColor = 0, iTextureUV = 0, iBoneEntry = 0; iVertex < vertices?.length; iVertex += 3, iColor += 4, iTextureUV += 2, iBoneEntry += 4) {
                _mesh.vertices.push(new FudgeCore.Vertex(new FudgeCore.Vector3(vertices[iVertex + 0], vertices[iVertex + 1], vertices[iVertex + 2]), textureUVs ?
                    new FudgeCore.Vector2(textureUVs[iTextureUV + 0], textureUVs[iTextureUV + 1]) :
                    undefined, normals ?
                    new FudgeCore.Vector3(normals[iVertex + 0], normals[iVertex + 1], normals[iVertex + 2]) :
                    undefined, colors ?
                    new FudgeCore.Color(colors[iColor + 0], colors[iColor + 1], colors[iColor + 2], colors[iColor + 3]) :
                    undefined, bones && weights ?
                    [
                        { index: bones[iBoneEntry + 0], weight: weights[iBoneEntry + 0] },
                        { index: bones[iBoneEntry + 1], weight: weights[iBoneEntry + 1] },
                        { index: bones[iBoneEntry + 2], weight: weights[iBoneEntry + 2] },
                        { index: bones[iBoneEntry + 3], weight: weights[iBoneEntry + 3] }
                    ] :
                    undefined));
            }
            for (let iFaceVertexIndex = 0; iFaceVertexIndex < indices?.length; iFaceVertexIndex += 3) {
                try {
                    _mesh.faces.push(new FudgeCore.Face(_mesh.vertices, indices[iFaceVertexIndex + 0], indices[iFaceVertexIndex + 1], indices[iFaceVertexIndex + 2]));
                }
                catch (_e) {
                    FudgeCore.Debug.fudge("Face excluded", _e.message);
                }
            }
            const renderMesh = _mesh.renderMesh;
            renderMesh.indices = indices;
            renderMesh.vertices = vertices;
            renderMesh.normals = normals;
            // renderMesh.tangents = tangents;
            renderMesh.textureUVs = textureUVs;
            renderMesh.colors = colors;
            renderMesh.bones = bones;
            renderMesh.weights = weights;
            return _mesh;
            function checkMaxSupport(_gltfAttributes, _check, _max) {
                if (Object.keys(gltfPrimitive.attributes).filter((_key) => _key.startsWith(_check)).length > _max)
                    FudgeCore.Debug.warn(`${loader}: Mesh with index ${_data.iMesh} primitive ${_data.iPrimitive} has more than ${_max} sets of '${_check}' associated with it. FUGDE only supports up to ${_max} ${_check} sets per primitve.`);
            }
        }
    }
    FudgeCore.MeshLoaderGLTF = MeshLoaderGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple Wavefront OBJ import. Takes a wavefront obj string. To Load from a file url, use the
     * static LOAD Method. Currently only works with triangulated Meshes
     * (activate 'Geomentry ‚Üí Triangulate Faces' in Blenders obj exporter)
     * @todo Load Materials, Support Quads
     * @authors Simon Storl-Schulke 2021 | Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Matthias Roming, HFU, 2023
     */
    class MeshLoaderOBJ extends FudgeCore.MeshLoader {
        static async load(_mesh) {
            let url = new URL(_mesh.url.toString(), FudgeCore.Project.baseURL).toString();
            let data = await (await fetch(url)).text();
            _mesh.name = url.split("/").pop();
            parseObj(data, _mesh);
            return _mesh;
        }
    }
    FudgeCore.MeshLoaderOBJ = MeshLoaderOBJ;
    /** Splits up the obj string into separate arrays for each datatype */
    function parseObj(_data, _mesh) {
        const lines = _data.split("\n");
        let positions = [];
        let uvs = [];
        let normals = [];
        let faceInfo = [];
        for (let line of lines) {
            line = line.trim();
            if (!line || line.startsWith("#"))
                continue;
            const parts = line.split(" ");
            parts.shift();
            //Vertex - example: v 0.70 -0.45 -0.52
            if (line.startsWith("v "))
                positions.push(new FudgeCore.Vector3(...parts.map(_value => +_value)));
            //Normal - example: vn 0.00 0.00 1.00
            if (line.startsWith("vn "))
                normals.push(new FudgeCore.Vector3(...parts.map(_value => +_value)));
            //Texcoord - example: vt 0.545454 0.472382
            else if (line.startsWith("vt "))
                uvs.push(new FudgeCore.Vector2(...parts.map((_value, _index) => +_value * (_index == 1 ? -1 : 1))));
            /*Face Indices - example: f 1/1/1 2/2/1 3/3/1 -->
            vertex1/texcoord1/normal1 vertex2/texcoord2/normal2 vertex3/texcoord3/normal3*/
            else if (line.startsWith("f "))
                for (let i = 0; i < 3; i++) {
                    const indices = parts[i].split("/");
                    faceInfo.push({
                        iPosition: +indices[0] - 1,
                        iUV: +indices[1] - 1,
                        iNormal: +indices[2] - 1
                    });
                }
        }
        _mesh.vertices = new FudgeCore.Vertices();
        for (let i = 0; i < faceInfo.length; i += 3) {
            let indices = [];
            for (let v = 0; v < 3; v++) {
                let info = faceInfo[i + v];
                // A lot of vertices with duplicate positions are (probably) created here,
                // since in obj files the face defines the connectivity of the vertices, UV coordinates, and normals (see above).
                // However, in Fudge, each vertex has its own UV coordinates and normals directley associated with it.
                _mesh.vertices.push(new FudgeCore.Vertex(positions[info.iPosition], uvs[info.iUV], normals[info.iNormal]));
                indices.push(_mesh.vertices.length - 1);
            }
            try {
                _mesh.faces.push(new FudgeCore.Face(_mesh.vertices, indices[0], indices[1], indices[2]));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
        }
    }
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The namesapce for handling the particle data
     */
    let ParticleData;
    (function (ParticleData) {
        /**
         * Returns true if the given data is a {@link Expression}
         */
        function isExpression(_data) {
            return isFunction(_data) || isVariable(_data) || isConstant(_data) || isCode(_data);
        }
        ParticleData.isExpression = isExpression;
        /**
         * Returns true if the given data is a {@link Function}
         */
        function isFunction(_data) {
            return typeof _data == "object" && "function" in _data;
        }
        ParticleData.isFunction = isFunction;
        /**
         * Returns true if the given data is a {@link Variable}
         */
        function isVariable(_data) {
            return typeof _data == "object" && "value" in _data && typeof _data.value == "string";
        }
        ParticleData.isVariable = isVariable;
        /**
         * Returns true if the given data is a {@link Constant}
         */
        function isConstant(_data) {
            return typeof _data == "object" && "value" in _data && typeof _data.value == "number";
        }
        ParticleData.isConstant = isConstant;
        /**
         * Returns true if the given data is a {@link Code}
         */
        function isCode(_data) {
            return typeof _data == "object" && "code" in _data;
        }
        ParticleData.isCode = isCode;
        /**
         * Returns true if the given data is a {@link Transformation}
         */
        function isTransformation(_data) {
            return typeof _data == "object" && "transformation" in _data;
        }
        ParticleData.isTransformation = isTransformation;
    })(ParticleData = FudgeCore.ParticleData || (FudgeCore.ParticleData = {}));
    /**
     * Holds information on how to mutate the particles of a particle system.
     * A full particle system is composed by attaching a {@link ComponentParticleSystem}, {@link ComponentMesh} and {@link ComponentMaterial} to the same {@link Node}.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the particles face the camera.
     * @authors Jonas Plotzky, HFU, 2022
     */
    class ParticleSystem extends FudgeCore.Mutable {
        #data;
        /** Map of shader universal derivates to corresponding computed {@link ShaderParticleSystem}.
         * This way each particle system resource can be used in conjunction with multiple shader universal derivates */
        #shaderToShaderParticleSystem;
        constructor(_name = ParticleSystem.name, _data = {}) {
            super();
            this.idResource = undefined;
            /** Map of shader universal derivates to corresponding computed {@link ShaderParticleSystem}.
             * This way each particle system resource can be used in conjunction with multiple shader universal derivates */
            this.#shaderToShaderParticleSystem = new Map();
            this.name = _name;
            this.data = _data;
            FudgeCore.Project.register(this);
        }
        get data() {
            return this.#data;
        }
        set data(_data) {
            this.#data = _data;
            this.#shaderToShaderParticleSystem.forEach(_shader => _shader.deleteProgram());
            this.#shaderToShaderParticleSystem.clear();
        }
        /**
         * Returns a corresponding {@link ShaderParticleSystem} for the given shader universal derivate.
         * Used by the render system to render the particle system.
         * @returns the corresponding {@link ShaderParticleSystem}
         * @internal
         */
        getShaderFrom(_source) {
            if (!this.#shaderToShaderParticleSystem.has(_source)) {
                let particleShader = new FudgeCore.ShaderParticleSystem();
                particleShader.data = this.data;
                particleShader.define = [...particleShader.define, ..._source.define];
                particleShader.vertexShaderSource = _source.getVertexShaderSource();
                particleShader.fragmentShaderSource = _source.getFragmentShaderSource();
                this.#shaderToShaderParticleSystem.set(_source, particleShader);
            }
            return this.#shaderToShaderParticleSystem.get(_source);
        }
        //#region Transfer
        serialize() {
            let serialization = {
                idResource: this.idResource,
                name: this.name,
                data: this.data
            };
            return serialization;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            this.data = _serialization.data;
            return this;
        }
        getMutatorForUserInterface() {
            return super.getMutator(); // remove data from mutator
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.data = this.data;
            return mutator;
        }
        reduceMutator(_mutator) {
            delete _mutator.cachedMutators;
            delete _mutator.shaderMap;
        }
    }
    FudgeCore.ParticleSystem = ParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A WebGL shaderprogram for a particle system. Managed by a {@link ParticleSystem}. It uses {@link ParticleSystem.data} to generate and inject code into a shader universal derivate (GLSL) thus creating a shader particle system from a supplied {@link Shader}s vertex and fragment shader source code.
     * @author Jonas Plotzky, HFU, 2022
     * @internal
     */
    let ShaderParticleSystem = class ShaderParticleSystem {
        constructor() {
            this.define = ["PARTICLE"];
        }
        /**
         * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
         * @internal
         */
        getVertexShaderSource() { return ""; /* injected by decorator */ }
        /**
         * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
         * @internal
         */
        getFragmentShaderSource() { return ""; /* injected by decorator */ }
        /**
         * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
         * @internal
         */
        deleteProgram() { }
        /**
         * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
         * @internal
         */
        useProgram() { }
        /**
         * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
         * @internal
         */
        createProgram() { }
    };
    ShaderParticleSystem = __decorate([
        FudgeCore.RenderInjectorShaderParticleSystem.decorate
    ], ShaderParticleSystem);
    FudgeCore.ShaderParticleSystem = ShaderParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines automatic adjustment of the collider
     */
    let BODY_INIT;
    (function (BODY_INIT) {
        /** Collider uses the pivot of the mesh for initilialization */
        BODY_INIT[BODY_INIT["TO_MESH"] = 0] = "TO_MESH";
        /** Collider uses the transform of the node for initilialization */
        BODY_INIT[BODY_INIT["TO_NODE"] = 1] = "TO_NODE";
        /** Collider uses its own pivot for initilialization */
        BODY_INIT[BODY_INIT["TO_PIVOT"] = 2] = "TO_PIVOT";
    })(BODY_INIT = FudgeCore.BODY_INIT || (FudgeCore.BODY_INIT = {}));
    /**
     * Acts as the physical representation of the {@link Node} it's attached to.
     * It's the connection between the FUDGE rendered world and the Physics world.
     * For the physics to correctly get the transformations rotations need to be applied with from left = true.
     * Or rotations need to happen before scaling.
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class ComponentRigidbody extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentRigidbody); }
        static { this.mapBodyType = (typeof OIMO == "undefined") ?
            {
                [FudgeCore.BODY_TYPE.DYNAMIC]: FudgeCore.BODY_TYPE.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: FudgeCore.BODY_TYPE.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: FudgeCore.BODY_TYPE.KINEMATIC
            } : {
            [FudgeCore.BODY_TYPE.DYNAMIC]: OIMO.RigidBodyType.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: OIMO.RigidBodyType.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: OIMO.RigidBodyType.KINEMATIC
        }; }
        /** ID to reference this specific ComponentRigidbody */
        #id;
        //Private informations - Mostly OimoPhysics variables that should not be exposed to the FUDGE User and manipulated by them
        #collider;
        #colliderInfo;
        #collisionGroup;
        #typeCollider;
        #rigidbody;
        #rigidbodyInfo;
        #typeBody;
        #massData;
        #restitution;
        #friction;
        #dampingLinear;
        #dampingAngular;
        #effectRotation;
        #effectGravity;
        #isTrigger;
        #mtxPivotUnscaled;
        #mtxPivotInverse;
        #callbacks; //Callback Methods when within the oimoSystem a event is happening
        // #physics: Physics; //TODO: keep a pointer to the physics instance used by this component
        /** Creating a new rigidbody with a weight in kg, a physics type (default = dynamic), a collider type what physical form has the collider, to what group does it belong, is there a transform Matrix that should be used, and is the collider defined as a group of points that represent a convex mesh. */
        constructor(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            super();
            /** Transformation of the collider relative to the node's transform. Once set mostly remains constant.
             * If altered, {@link isInitialized} must be reset to false to recreate the collider in the next {@link Render.prepare}
             */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            /**
             * Vertices that build a convex mesh (form that is in itself closed). Needs to set in the construction of the rb if none of the standard colliders is used.
             * Untested and not yet fully supported by serialization and mutation.
             */
            this.convexMesh = null;
            /** Collisions with rigidbodies happening to this body, can be used to build a custom onCollisionStay functionality. */
            this.collisions = new Array();
            /** Triggers that are currently triggering this body */
            this.triggerings = new Array();
            /**
             * Automatic adjustment of the pivot when {@link Render.prepare} is called according to {@link BODY_INIT}
             */
            this.initialization = BODY_INIT.TO_PIVOT;
            /** Marks if collider was initialized. Reset to false to initialize again e.g. after manipulation of mtxPivot */
            this.isInitialized = false;
            /** ID to reference this specific ComponentRigidbody */
            this.#id = 0;
            this.#collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT;
            this.#typeCollider = FudgeCore.COLLIDER_TYPE.CUBE;
            this.#rigidbodyInfo = new OIMO.RigidBodyConfig();
            this.#typeBody = FudgeCore.BODY_TYPE.DYNAMIC;
            this.#massData = new OIMO.MassData();
            this.#dampingLinear = 0.1;
            this.#dampingAngular = 0.1;
            this.#effectRotation = FudgeCore.Vector3.ONE();
            this.#effectGravity = 1;
            this.#isTrigger = false;
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.IDENTITY();
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.IDENTITY();
            //#endregion
            // Activate the functions of this component as response to events
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* EVENT.COMPONENT_ADD */:
                        // this.addEventListener(EVENT.COMPONENT_ACTIVATE, this.addRigidbodyToWorld);
                        this.addEventListener("componentDeactivate" /* EVENT.COMPONENT_DEACTIVATE */, this.removeRigidbodyFromWorld);
                        // this.node.addEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.addEventListener("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, this.removeRigidbodyFromWorld, true);
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.warn("ComponentRigidbody attached to node missing ComponentTransform", this.node);
                        break;
                    case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                        // this.removeEventListener(EVENT.COMPONENT_ADD, this.addRigidbodyToWorld);
                        this.removeEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.removeRigidbodyFromWorld);
                        // this.node.removeEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.removeEventListener("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, this.removeRigidbodyFromWorld, true);
                        this.removeRigidbodyFromWorld();
                        break;
                    case "nodeDeserialized" /* EVENT.NODE_DESERIALIZED */:
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.error("ComponentRigidbody attached to node missing ComponentTransform", this.node);
                        break;
                }
            };
            /** Adding this ComponentRigidbody to the Physiscs.world giving the oimoPhysics system the information needed */
            this.addRigidbodyToWorld = () => {
                if (!this.#rigidbody._world)
                    FudgeCore.Physics.addRigidbody(this);
            };
            /** Removing this ComponentRigidbody from the Physiscs.world taking the informations from the oimoPhysics system */
            this.removeRigidbodyFromWorld = () => {
                FudgeCore.Physics.removeRigidbody(this);
                this.isInitialized = false;
            };
            this.create(_mass, _type, _colliderType, _group, _mtxTransform, _convexMesh);
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
            // this.addEventListener(EVENT.NODE_DESERIALIZED, this.hndEvent);
        }
        //#region Accessors
        get id() {
            return this.#id;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotInverse() {
            return this.#mtxPivotInverse;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotUnscaled() {
            return this.#mtxPivotUnscaled;
        }
        /** Retrieve the body type. See {@link BODY_TYPE} */
        get typeBody() {
            return this.#typeBody;
        }
        /** Set the body type. See {@link BODY_TYPE} */
        set typeBody(_value) {
            this.#typeBody = _value;
            this.#rigidbody.setType(ComponentRigidbody.mapBodyType[this.#typeBody]);
            this.#rigidbody.setMassData(this.#massData); //have to reset mass after changing the type, since Oimo is handling mass internally wrong when switching types
        }
        /** The shape that represents the {@link Node} in the physical world. Default is a Cube. */
        get typeCollider() {
            return this.#typeCollider;
        }
        set typeCollider(_value) {
            if (_value != this.#typeCollider && this.#rigidbody != null) {
                this.#typeCollider = _value;
                this.initialize();
            }
        }
        /** The collision group this {@link Node} belongs to it's the default group normally which means it physically collides with every group besides trigger. */
        get collisionGroup() {
            return this.#collisionGroup;
        }
        set collisionGroup(_value) {
            this.#collisionGroup = _value;
            if (this.#rigidbody != null)
                this.#rigidbody.getShapeList().setCollisionGroup(this.#collisionGroup);
        }
        /** Marking the Body as a trigger therefore not influencing the collision system but only sending triggerEvents */
        get isTrigger() {
            return this.#isTrigger;
        }
        set isTrigger(_value) {
            this.#isTrigger = _value;
            if (this.getOimoRigidbody() != null) {
                this.getOimoRigidbody()._isTrigger = this.#isTrigger;
            }
        }
        /**
         * Returns the physical weight of the {@link Node}
         */
        get mass() {
            return this.#rigidbody.getMass();
        }
        /**
         * Setting the physical weight of the {@link Node} in kg
         */
        set mass(_value) {
            this.#massData.mass = _value;
            if (this.node != null)
                if (this.#rigidbody != null)
                    this.#rigidbody.setMassData(this.#massData);
        }
        /** Drag of linear movement. A Body does slow down even on a surface without friction. */
        get dampTranslation() {
            return this.#rigidbody.getLinearDamping();
        }
        set dampTranslation(_value) {
            this.#dampingLinear = _value;
            this.#rigidbody.setLinearDamping(_value);
        }
        /** Drag of rotation. */
        get dampRotation() {
            return this.#rigidbody.getAngularDamping();
        }
        set dampRotation(_value) {
            this.#dampingAngular = _value;
            this.#rigidbody.setAngularDamping(_value);
        }
        /** The factor this rigidbody reacts rotations that happen in the physical world. 0 to lock rotation this axis. */
        get effectRotation() {
            return this.#effectRotation;
        }
        set effectRotation(_effect) {
            this.#effectRotation = _effect;
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** The factor this rigidbody reacts to world gravity. Default = 1 e.g. 1*9.81 m/s. */
        get effectGravity() {
            return this.#effectGravity;
        }
        set effectGravity(_effect) {
            this.#effectGravity = _effect;
            if (this.#rigidbody != null)
                this.#rigidbody.setGravityScale(this.#effectGravity);
        }
        /**
         * Get the friction of the rigidbody, which is the factor of sliding resistance of this rigidbody on surfaces
         */
        get friction() {
            return this.#friction;
        }
        /**
         * Set the friction of the rigidbody, which is the factor of  sliding resistance of this rigidbody on surfaces
         */
        set friction(_friction) {
            this.#friction = _friction;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setFriction(this.#friction);
        }
        /**
         * Get the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        get restitution() {
            return this.#restitution;
        }
        /**
         * Set the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        set restitution(_restitution) {
            this.#restitution = _restitution;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setRestitution(this.#restitution);
        }
        //#endregion
        //#region Transformation
        /**
         * Returns the rigidbody in the form the physics engine is using it, should not be used unless a functionality
         * is not provided through the FUDGE Integration.
         */
        getOimoRigidbody() {
            return this.#rigidbody;
        }
        /** Rotating the rigidbody therefore changing it's rotation over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incremental changing it instead of a direct rotation.  Although it's always prefered to use forces in physics.
         */
        rotateBody(_rotationChange) {
            this.#rigidbody.rotateXyz(new OIMO.Vec3(_rotationChange.x * FudgeCore.Calc.deg2rad, _rotationChange.y * FudgeCore.Calc.deg2rad, _rotationChange.z * FudgeCore.Calc.deg2rad));
        }
        /** Translating the rigidbody therefore changing it's place over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incrementally changing it instead of a direct position. Although it's always prefered to use forces in physics.
         */
        translateBody(_translationChange) {
            this.#rigidbody.translate(new OIMO.Vec3(_translationChange.x, _translationChange.y, _translationChange.z));
        }
        /**
         * Get the current POSITION of the {@link Node} in the physical space
         */
        getPosition() {
            let tmpPos = this.#rigidbody.getPosition();
            return new FudgeCore.Vector3(tmpPos.x, tmpPos.y, tmpPos.z);
        }
        /**
         * Sets the current POSITION of the {@link Node} in the physical space
         */
        setPosition(_value) {
            this.#rigidbody.setPosition(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Get the current ROTATION of the {@link Node} in the physical space. Note this range from -pi to pi, so -90 to 90.
         */
        getRotation() {
            let orientation = this.#rigidbody.getOrientation();
            let tmpQuat = FudgeCore.Recycler.get(FudgeCore.Quaternion);
            tmpQuat.set(orientation.x, orientation.y, orientation.z, orientation.w);
            let eulerAngles = tmpQuat.eulerAngles.clone;
            FudgeCore.Recycler.store(tmpQuat);
            return eulerAngles;
        }
        /**
         * Sets the current ROTATION of the {@link Node} in the physical space, in degree.
         */
        setRotation(_value) {
            let quat = new OIMO.Quat();
            let mtxRot = FudgeCore.Matrix4x4.IDENTITY();
            mtxRot.rotate(new FudgeCore.Vector3(_value.x, _value.y, _value.z));
            let array = mtxRot.get();
            let rot = new OIMO.Mat3(array[0], array[4], array[8], array[1], array[5], array[9], array[2], array[6], array[10]);
            quat.fromMat3(rot);
            // quat.normalize();
            this.#rigidbody.setOrientation(quat);
        }
        /** Get the current SCALING in the physical space. */
        getScaling() {
            let scaling = this.node.mtxWorld.scaling.clone;
            scaling.x *= this.mtxPivot.scaling.x;
            scaling.y *= this.mtxPivot.scaling.y;
            scaling.z *= this.mtxPivot.scaling.z;
            return scaling;
        }
        /** Scaling requires the collider to be completely recreated anew */
        setScaling(_value) {
            // let scaling: Vector3 = _value.clone;   
            this.createCollider(new OIMO.Vec3(_value.x / 2, _value.y / 2, _value.z / 2), this.#typeCollider); //recreate the collider
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            let oldCollider = this.#rigidbody.getShapeList();
            this.#rigidbody.addShape(this.#collider); //add new collider, before removing the old, so the rb is never active with 0 colliders
            this.#rigidbody.removeShape(oldCollider); //remove the old collider
            this.#collider.userData = this; //reset the extra information so that this collider knows to which FUDGE Component it's connected
            this.#collider.setCollisionGroup(this.collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#collider.setRestitution(this.#restitution);
            this.#collider.setFriction(this.#friction);
            this.#collider.setContactCallback(this.#callbacks);
        }
        /**
         * Initializes the rigidbody according to its initialization setting to match the mesh, the node or its own pivot matrix
         */
        initialize() {
            if (!this.node) // delay initialization until this rigidbody is attached to a node
                return;
            switch (Number(this.initialization)) {
                case BODY_INIT.TO_NODE:
                    this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                    break;
                case BODY_INIT.TO_MESH:
                    let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
                    if (cmpMesh)
                        this.mtxPivot = cmpMesh.mtxPivot.clone;
                    break;
                case BODY_INIT.TO_PIVOT:
                    break;
            }
            let mtxWorld = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            let position = mtxWorld.translation; //Adding the offsets from the pivot
            let rotation = mtxWorld.rotation;
            let scaling = mtxWorld.scaling;
            //scaling requires collider to be recreated
            this.setScaling(scaling);
            this.#rigidbody.setMassData(this.#massData);
            this.setPosition(position); //set the actual new rotation/position for this Rb again since it's now updated
            this.setRotation(rotation);
            let scalingInverse = this.node.mtxWorld.scaling.map(_i => 1 / _i);
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.CONSTRUCTION(this.mtxPivot.translation, this.mtxPivot.rotation, scalingInverse);
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.INVERSION(this.#mtxPivotUnscaled);
            this.addRigidbodyToWorld();
            this.isInitialized = true;
        }
        //#endregion
        //#region Velocity and Forces
        /**
        * Get the current VELOCITY of the {@link Node}
        */
        getVelocity() {
            let velocity = this.#rigidbody.getLinearVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current VELOCITY of the {@link Node}
         */
        setVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setLinearVelocity(velocity);
        }
        /**
         * Get the current ANGULAR - VELOCITY of the {@link Node}
         */
        getAngularVelocity() {
            let velocity = this.#rigidbody.getAngularVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current ANGULAR - VELOCITY of the {@link Node}
         */
        setAngularVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setAngularVelocity(velocity);
        }
        /**
        * Applies a continous FORCE at the center of the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS.
        * The force is measured in newton, 1kg needs about 10 Newton to fight against gravity.
        */
        applyForce(_force) {
            this.#rigidbody.applyForceToCenter(new OIMO.Vec3(_force.x, _force.y, _force.z));
        }
        /**
        * Applies a continous FORCE at a specific point in the world to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyForceAtPoint(_force, _worldPoint) {
            this.#rigidbody.applyForce(new OIMO.Vec3(_force.x, _force.y, _force.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a continous ROTATIONAL FORCE (Torque) to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyTorque(_rotationalForce) {
            this.#rigidbody.applyTorque(new OIMO.Vec3(_rotationalForce.x, _rotationalForce.y, _rotationalForce.z));
        }
        /**
        * Applies a instant FORCE at a point/rigidbodycenter to the RIGIDBODY in the three dimensions. Considering the rigidbod's MASS
        * Influencing the angular speed and the linear speed.
        */
        applyImpulseAtPoint(_impulse, _worldPoint = null) {
            _worldPoint = _worldPoint != null ? _worldPoint : this.getPosition();
            this.#rigidbody.applyImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a instant FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        * Only influencing it's speed not rotation.
        */
        applyLinearImpulse(_impulse) {
            this.#rigidbody.applyLinearImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z));
        }
        /**
         * Applies a instant ROTATIONAL-FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
         * Only influencing it's rotation.
         */
        applyAngularImpulse(_rotationalImpulse) {
            this.#rigidbody.applyAngularImpulse(new OIMO.Vec3(_rotationalImpulse.x, _rotationalImpulse.y, _rotationalImpulse.z));
        }
        /**
         * Changing the VELOCITY of the RIGIDBODY. Only influencing the linear speed not angular
         */
        addVelocity(_value) {
            this.#rigidbody.addLinearVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Changing the VELOCITY of the RIGIDBODY. Only influencing the angular speed not the linear
         */
        addAngularVelocity(_value) {
            this.#rigidbody.addAngularVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * De- / Activate the rigidbodies auto-sleeping function.
         * If activated the rigidbody will automatically sleep when needed, increasing performance.
         * If deactivated the rigidbody gets stopped from sleeping when movement is too minimal. Decreasing performance, for rarely more precise physics results
         */
        activateAutoSleep(_on) {
            this.#rigidbody.setAutoSleep(_on);
        }
        //#endregion
        //#region Collision
        /**
         * Checking for Collision with other Colliders and dispatches a custom event with information about the collider.
         * Automatically called in the RenderManager, no interaction needed.
         */
        checkCollisionEvents() {
            if (!this.isInitialized) // check collisions only if intialization completed
                return;
            let list = this.#rigidbody.getContactLinkList(); //all physical contacts between colliding bodies on this rb
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            let normalImpulse = 0;
            let binormalImpulse = 0;
            let tangentImpulse = 0;
            let colPoint;
            //ADD NEW Collision - That just happened
            for (let i = 0; i < this.#rigidbody.getNumContactLinks(); i++) {
                let collisionManifold = list.getContact().getManifold(); //Manifold = Additional informations about the contact
                objHit = list.getContact().getShape1().userData; //Userdata is used to transfer the ∆í.ComponentRigidbody, it's an empty OimoPhysics Variable
                //Only register the collision on the actual touch, not on "shadowCollide", to register in the moment of impulse calculation
                if (!objHit.isInitialized)
                    continue;
                if (objHit == null || list.getContact().isTouching() == false) // only act if the collision is actual touching, so right at the moment when a impulse is happening, not when shapes overlap
                    return;
                objHit2 = list.getContact().getShape2().userData;
                if (!objHit2.isInitialized)
                    continue;
                if (objHit2 == null || list.getContact().isTouching() == false)
                    return;
                let points = collisionManifold.getPoints(); //All points in the collision where the two bodies are touching, used to calculate the full impact
                let normal = collisionManifold.getNormal();
                if (objHit.getOimoRigidbody() != this.getOimoRigidbody() && this.collisions.indexOf(objHit) == -1) { //Fire, if the hit object is not the Body itself but another and it's not already fired.
                    let colPos = this.collisionCenterPoint(points, collisionManifold.getNumPoints()); //THE point of collision is the first touching point (EXTENSION: could be the center of all touching points combined)
                    colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                    points.forEach((_value) => {
                        normalImpulse += _value.getNormalImpulse();
                        binormalImpulse += _value.getBinormalImpulse();
                        tangentImpulse += _value.getTangentImpulse();
                    });
                    this.collisions.push(objHit); //Tell the object that the event for this object does not need to be fired again
                    event = new FudgeCore.EventPhysics("ColliderEnteredCollision" /* EVENT_PHYSICS.COLLISION_ENTER */, objHit, normalImpulse, tangentImpulse, binormalImpulse, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z)); //Building the actual event, with what object did collide and informations about it
                    this.dispatchEvent(event); //Sending the given event
                }
                if (objHit2 != this && this.collisions.indexOf(objHit2) == -1) { //Same as the above but for the case the SECOND hit object is not the body itself
                    let colPos = this.collisionCenterPoint(points, collisionManifold.getNumPoints());
                    colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                    points.forEach((_value) => {
                        normalImpulse += _value.getNormalImpulse();
                        binormalImpulse += _value.getBinormalImpulse();
                        tangentImpulse += _value.getTangentImpulse();
                    });
                    this.collisions.push(objHit2);
                    event = new FudgeCore.EventPhysics("ColliderEnteredCollision" /* EVENT_PHYSICS.COLLISION_ENTER */, objHit2, normalImpulse, tangentImpulse, binormalImpulse, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z));
                    this.dispatchEvent(event);
                }
                list = list.getNext(); //Start the same routine with the next collision in the list
            }
            //REMOVE OLD Collisions - That do not happen anymore
            this.collisions.forEach((_value) => {
                let isColliding = false;
                list = this.#rigidbody.getContactLinkList();
                for (let i = 0; i < this.#rigidbody.getNumContactLinks(); i++) {
                    objHit = list.getContact().getShape1().userData;
                    objHit2 = list.getContact().getShape2().userData;
                    if (_value == objHit || _value == objHit2) { //If the given object in the collisions list is still one of the objHit the collision is not CollisionEXIT
                        isColliding = true;
                    }
                    list = list.getNext();
                }
                if (isColliding == false) { //The collision is exiting but was in the collision list, then EXIT Event needs to be fired
                    let index = this.collisions.indexOf(_value); //Find object in the array
                    this.collisions.splice(index); //remove it from the array
                    event = new FudgeCore.EventPhysics("ColliderLeftCollision" /* EVENT_PHYSICS.COLLISION_EXIT */, _value, 0, 0, 0);
                    this.dispatchEvent(event);
                }
            });
        }
        /**
         * Sends a ray through this specific body ignoring the rest of the world and checks if this body was hit by the ray,
         * returning info about the hit. Provides the same functionality and information a regular raycast does but the ray is only testing against this specific body.
         */
        raycastThisBody(_origin, _direction, _length, _debugDraw = false) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let geometry = this.#rigidbody.getShapeList().getGeometry();
            let transform = this.#rigidbody.getTransform();
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, _origin.clone);
            let oimoRay = new OIMO.RayCastHit();
            let hit = geometry.rayCast(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z), transform, oimoRay); //the actual OimoPhysics Raycast
            if (hit) { //If hit return a bunch of informations about the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(oimoRay.position.x, oimoRay.position.y, oimoRay.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(oimoRay.normal.x, oimoRay.normal.y, oimoRay.normal.z);
                let dx = _origin.x - hitInfo.hitPoint.x; //calculate hit distance
                let dy = _origin.y - hitInfo.hitPoint.y;
                let dz = _origin.z - hitInfo.hitPoint.z;
                hitInfo.hitDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                hitInfo.rigidbodyComponent = this;
                hitInfo.rayOrigin = _origin;
                hitInfo.rayEnd = endpoint;
            }
            else { //Only tell the origin, and the hit point is the end of the ray.
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(endpoint.x, endpoint.y, endpoint.z);
            }
            if (_debugDraw) {
                FudgeCore.Physics.debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        //#endregion
        //#region Saving/Loading - Some properties might be missing, e.g. convexMesh (Float32Array)
        serialize() {
            let serialization = this.getMutator();
            delete serialization.mtxPivot;
            delete serialization.active;
            serialization.typeBody = FudgeCore.BODY_TYPE[this.#typeBody];
            serialization.typeCollider = FudgeCore.COLLIDER_TYPE[this.#typeCollider];
            serialization.initialization = BODY_INIT[this.initialization];
            serialization.id = this.#id;
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            this.mtxPivot.deserialize(_serialization.pivot);
            this.#id = _serialization.id;
            this.mass = ifNumber(_serialization.mass, this.mass);
            this.dampTranslation = ifNumber(_serialization.dampTranslation, this.dampTranslation);
            this.dampRotation = ifNumber(_serialization.dampRotation, this.dampRotation);
            this.collisionGroup = ifNumber(_serialization.collisionGroup, this.collisionGroup);
            this.effectRotation = _serialization.effectRotation || this.effectRotation;
            this.effectGravity = ifNumber(_serialization.effectGravity, this.effectGravity);
            this.friction = ifNumber(_serialization.friction, this.friction);
            this.restitution = ifNumber(_serialization.restitution, this.restitution);
            this.isTrigger = _serialization.isTrigger || this.isTrigger;
            this.initialization = _serialization.initialization;
            this.initialization = BODY_INIT[_serialization.initialization];
            this.typeBody = FudgeCore.BODY_TYPE[_serialization.typeBody];
            this.typeCollider = FudgeCore.COLLIDER_TYPE[_serialization.typeCollider];
            // this.create(this.mass, this.#typeBody, this.#typeCollider, this.collisionGroup, null, this.convexMesh);
            return this;
        }
        /** Change properties by an associative array */
        async mutate(_mutator) {
            if (_mutator.typeBody != undefined)
                _mutator.typeBody = parseInt(_mutator.typeBody);
            if (_mutator.typeCollider != undefined)
                _mutator.typeCollider = parseInt(_mutator.typeCollider);
            if (_mutator.initialization != undefined)
                _mutator.initialization = parseInt(_mutator.initialization);
            await super.mutate(_mutator);
            if (_mutator.initialization != undefined && this.isActive)
                this.initialize();
            // TODO: see if this alternative should be, at least partially, done with mutateSelection
            // let callIfExist: Function = (_key: string, _setter: Function) => {
            //   if (_mutator[_key])
            //     _setter(_mutator[_key]);
            // };
            // callIfExist("friction", (_value: number) => this.friction = _value);
            // callIfExist("restitution", (_value: number) => this.restitution = _value);
            // callIfExist("mass", (_value: number) => this.mass = _value);
            // callIfExist("dampTranslation", (_value: number) => this.dampTranslation = _value);
            // callIfExist("dampRotation", (_value: number) => this.dampRotation = _value);
            // callIfExist("effectGravity", (_value: number) => this.effectGravity = _value);
            // callIfExist("collisionGroup", (_value: COLLISION_GROUP) => this.collisionGroup = _value);
            // callIfExist("typeBody", (_value: string) => this.typeBody = parseInt(_value));
            // callIfExist("typeCollider", (_value: string) => this.typeCollider = parseInt(_value));
            // this.dispatchEvent(new Event(EVENT.MUTATE));
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.friction = this.friction;
            mutator.restitution = this.restitution;
            mutator.mass = this.mass;
            mutator.dampTranslation = this.dampTranslation;
            mutator.dampRotation = this.dampRotation;
            mutator.effectGravity = this.effectGravity;
            mutator.typeBody = this.#typeBody;
            mutator.typeCollider = this.#typeCollider;
            mutator.isTrigger = this.#isTrigger;
            // Object.preventExtensions(mutator);
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.typeBody)
                types.typeBody = FudgeCore.BODY_TYPE;
            if (types.typeCollider)
                types.typeCollider = FudgeCore.COLLIDER_TYPE;
            if (types.initialization)
                types.initialization = BODY_INIT;
            return types;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.convexMesh; //Convex Mesh can't be shown in the editor because float32Array is not a viable mutator
            delete _mutator.collisionMask;
            delete _mutator.isInitialized;
        }
        //#region Creation
        create(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            //Setting up all incoming values to be internal values
            this.convexMesh = _convexMesh;
            this.#typeBody = _type;
            this.#collisionGroup = _group;
            this.#typeCollider = _colliderType;
            this.mass = _mass;
            this.#restitution = FudgeCore.Physics.settings.defaultRestitution;
            this.#friction = FudgeCore.Physics.settings.defaultFriction;
            this.collisionMask = FudgeCore.Physics.settings.defaultCollisionMask;
            //Create the actual rigidbody in the OimoPhysics Space
            this.createRigidbody(_mass, _type, this.#typeCollider, _mtxTransform, this.#collisionGroup);
            this.#id = FudgeCore.Physics.distributeBodyID();
            // Event Callbacks directly from OIMO Physics
            this.#callbacks = new OIMO.ContactCallback(); //fehm
            this.#callbacks.beginTriggerContact = this.triggerEnter;
            this.#callbacks.endTriggerContact = this.triggerExit;
        }
        /** Creates the actual OimoPhysics Rigidbody out of informations the FUDGE Component has. */
        createRigidbody(_mass, _type, _colliderType, _mtxTransform, _collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let oimoType; //Need the conversion from simple enum to number because if enum is defined as Oimo.RigidyBodyType you have to include Oimo to use FUDGE at all
            switch (_type) {
                case FudgeCore.BODY_TYPE.DYNAMIC:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
                case FudgeCore.BODY_TYPE.STATIC:
                    oimoType = OIMO.RigidBodyType.STATIC;
                    break;
                case FudgeCore.BODY_TYPE.KINEMATIC:
                    oimoType = OIMO.RigidBodyType.KINEMATIC;
                    break;
                default:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
            }
            // remove all previous shapes from world. Necessary?
            // while (this.#rigidbody && this.#rigidbody.getShapeList() != null)
            //   this.#rigidbody.removeShape(this.#rigidbody.getShapeList());
            let tmpTransform = _mtxTransform == null ? super.node != null ? super.node.mtxWorld : FudgeCore.Matrix4x4.IDENTITY() : _mtxTransform; //Get transform informations from the world, since physics does not care about hierarchy
            //Convert informations from FUDGE to OimoPhysics and creating a collider with it, while also adding a pivot to derivate from the transform informations if needed
            let scale = new OIMO.Vec3((tmpTransform.scaling.x * this.mtxPivot.scaling.x) / 2, (tmpTransform.scaling.y * this.mtxPivot.scaling.y) / 2, (tmpTransform.scaling.z * this.mtxPivot.scaling.z) / 2);
            let position = new OIMO.Vec3(tmpTransform.translation.x + this.mtxPivot.translation.x, tmpTransform.translation.y + this.mtxPivot.translation.y, tmpTransform.translation.z + this.mtxPivot.translation.z);
            let rotation = new OIMO.Vec3(tmpTransform.rotation.x + this.mtxPivot.rotation.x, tmpTransform.rotation.y + this.mtxPivot.rotation.y, tmpTransform.rotation.z + this.mtxPivot.rotation.z);
            this.createCollider(scale, _colliderType);
            //Setting informations about mass, position/rotation and physical reaction type
            this.#massData.mass = _mass; //_type != PHYSICS_TYPE.STATIC ? _mass : 0; //If a object is static it acts as if it has no mass
            this.#rigidbodyInfo.type = oimoType;
            this.#rigidbodyInfo.position = position;
            this.#rigidbodyInfo.rotation.fromEulerXyz(new OIMO.Vec3(rotation.x, rotation.y, rotation.z)); //Convert eulerAngles in degree to the internally used quaternions
            //Creating the actual rigidbody and it's collider
            this.#rigidbody = new OIMO.RigidBody(this.#rigidbodyInfo);
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            //Filling the additional settings and informations the rigidbody needs. Who is colliding, how is the collision handled (damping, influence factors)
            this.#collider.userData = this;
            this.#collider.setCollisionGroup(_collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#rigidbody.addShape(this.#collider);
            this.#rigidbody.setMassData(this.#massData);
            this.#rigidbody.getShapeList().setRestitution(this.#restitution);
            this.#rigidbody.getShapeList().setFriction(this.#friction);
            this.#rigidbody.getShapeList().setContactCallback(this.#callbacks);
            this.#rigidbody.setLinearDamping(this.#dampingLinear);
            this.#rigidbody.setAngularDamping(this.#dampingAngular);
            this.#rigidbody.setGravityScale(this.#effectGravity);
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** Creates a collider a shape that represents the object in the physical world.  */
        createCollider(_scale, _colliderType) {
            let shapeConf = new OIMO.ShapeConfig(); //Collider with geometry and infos like friction/restitution and more
            let geometry;
            if (this.typeCollider != _colliderType) //If the collider type was changed set the internal one new, else don't so there is not infinite set calls
                this.typeCollider = _colliderType;
            switch (_colliderType) { //Create a different OimoPhysics geometry based on the given type. That is only the mathematical shape of the collider
                case FudgeCore.COLLIDER_TYPE.CUBE:
                    geometry = new OIMO.BoxGeometry(_scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.SPHERE:
                    geometry = new OIMO.SphereGeometry(_scale.x);
                    break;
                case FudgeCore.COLLIDER_TYPE.CAPSULE:
                    geometry = new OIMO.CapsuleGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CYLINDER:
                    geometry = new OIMO.CylinderGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONE:
                    geometry = new OIMO.ConeGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.PYRAMID:
                    geometry = this.createConvexGeometryCollider(this.createPyramidVertices(), _scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONVEX:
                    geometry = this.createConvexGeometryCollider(this.convexMesh, _scale);
                    break;
            }
            shapeConf.geometry = geometry;
            this.#colliderInfo = shapeConf; //the configuration informations that are used to add an actual collider to the rigidbody in createRigidbody
        }
        /** Creating a shape that represents a in itself closed form, out of the given vertices. */
        createConvexGeometryCollider(_vertices, _scale) {
            let verticesAsVec3 = new Array(); //Convert FUDGE Vector3 to OimoVec3
            for (let i = 0; i < _vertices.length; i += 3) { //3 Values for one point
                verticesAsVec3.push(new OIMO.Vec3(_vertices[i] * _scale.x, _vertices[i + 1] * _scale.y, _vertices[i + 2] * _scale.z));
            }
            return new OIMO.ConvexHullGeometry(verticesAsVec3); //Tell OimoPhysics to create a hull that involves all points but close it of. A convex shape can not have a hole in it.
        }
        /** Internal implementation of vertices that construct a pyramid. The vertices of the implemented pyramid mesh can be used too. But they are halfed and double sided, so it's more performant to use this. */
        createPyramidVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                /*4*/ 0, 2, 0
            ]);
            return vertices;
        }
        //#region private EVENT functions
        //Calculating the center of a collision as a singular point - in case there is more than one point - by getting the geometrical center of all colliding points
        collisionCenterPoint(_colPoints, _numPoints) {
            let center;
            let totalPoints = 0;
            let totalX = 0;
            let totalY = 0;
            let totalZ = 0;
            _colPoints.forEach((_value) => {
                if (totalPoints < _numPoints) {
                    totalPoints++;
                    totalX += _value.getPosition2().x;
                    totalY += _value.getPosition2().y;
                    totalZ += _value.getPosition2().z;
                }
            });
            center = new OIMO.Vec3(totalX / _numPoints, totalY / _numPoints, totalZ / _numPoints);
            return center;
        }
        //#endregion
        /**
        * Trigger EnteringEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the FUDGE OIMO Fork!)
        */
        triggerEnter(_contact) {
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            let colPoint;
            //ADD NEW Triggering - That just happened
            let collisionManifold = _contact.getManifold(); //Manifold = Additional informations about the contact
            objHit = _contact.getShape1().userData; //Userdata is used to transfer the ∆í.ComponentRigidbody, it's an empty OimoPhysics Variable
            //Only register the collision on the actual touch, not on "shadowCollide", to register in the moment of impulse calculation
            if (objHit == null || _contact.isTouching() == false) // only act if the collision is actual touching, so right at the moment when a impulse is happening, not when shapes overlap
                return;
            objHit2 = _contact.getShape2().userData;
            if (objHit2 == null || _contact.isTouching() == false)
                return;
            let points = collisionManifold.getPoints(); //All points in the collision where the two bodies are touching, used to calculate the full impact
            let normal = collisionManifold.getNormal();
            if (objHit2.triggerings.indexOf(objHit) == -1) { //Fire, if the hit object is not the Body itself but another and it's not already fired.
                let colPos = objHit2.collisionCenterPoint(points, collisionManifold.getNumPoints()); //THE point of collision is the first touching point (EXTENSION: could be the center of all touching points combined)
                colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                // Impulses are 0 since, there are no forces/impulses at work, else this would not be a trigger, but a collision
                objHit2.triggerings.push(objHit); //Tell the object that the event for this object does not need to be fired again
                event = new FudgeCore.EventPhysics("TriggerEnteredCollision" /* EVENT_PHYSICS.TRIGGER_ENTER */, objHit, 0, 0, 0, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z)); //Building the actual event, with what object did collide and informations about it
                objHit2.dispatchEvent(event); //Sending the given event
            }
            if (objHit.triggerings.indexOf(objHit2) == -1) { //Same as the above but for the case the SECOND hit object is not the body itself
                let colPos = objHit.collisionCenterPoint(points, collisionManifold.getNumPoints());
                colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                // Impulses are 0 since, there are no forces/impulses at work, else this would not be a trigger, but a collision,
                // also the event is handled before the actual solving impulse step in OIMO
                objHit.triggerings.push(objHit2);
                event = new FudgeCore.EventPhysics("TriggerEnteredCollision" /* EVENT_PHYSICS.TRIGGER_ENTER */, objHit2, 0, 0, 0, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z));
                objHit.dispatchEvent(event);
            }
        }
        /**
        * Trigger LeavingEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the FUDGE OIMO Fork!)
        */
        triggerExit(_contact) {
            //REMOVE OLD Triggering Body
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            objHit = _contact.getShape1().userData;
            objHit2 = _contact.getShape2().userData;
            // Remove both bodies in both cases, of self and other
            let index = objHit.triggerings.indexOf(objHit2); //Find object in the array
            if (index != -1) {
                objHit.triggerings.splice(index); //remove it from the array
                event = new FudgeCore.EventPhysics("TriggerLeftCollision" /* EVENT_PHYSICS.TRIGGER_EXIT */, objHit2, 0, 0, 0);
                objHit.dispatchEvent(event);
            }
            index = objHit2.triggerings.indexOf(objHit); //Find object in the array
            if (index != -1) {
                objHit2.triggerings.splice(index); //remove it from the array
                event = new FudgeCore.EventPhysics("TriggerLeftCollision" /* EVENT_PHYSICS.TRIGGER_EXIT */, objHit, 0, 0, 0);
                objHit2.dispatchEvent(event);
            }
        }
    }
    FudgeCore.ComponentRigidbody = ComponentRigidbody;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Internal class for holding data about physics debug vertices.*/
    class PhysicsDebugVertexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.numVertices = 0;
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data. Used at buffer initialization */
        setData(_array) {
            if (this.attribs == null)
                throw "set attributes first";
            this.numVertices = _array.length / (this.stride / 4);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(_array), this.gl.DYNAMIC_DRAW);
            //not necessary an in webgl2 anymore to rebind the same last buffer (which is achieved by giving a null buffer), after buffer is changed. Removed it on all other occasions
            // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); 
        }
        /** Set Shader Attributes informations by getting their position in the shader, setting the offset, stride and size. For later use in the binding process */
        setAttribs(_attribs) {
            this.attribs = _attribs;
            this.offsets = [];
            this.stride = 0;
            let n = _attribs.length;
            for (let i = 0; i < n; i++) {
                this.offsets.push(this.stride);
                this.stride += _attribs[i].float32Count * Float32Array.BYTES_PER_ELEMENT; // 32bit float Bytes are a constant of 4
            }
        }
        /** Get the position of the attribute in the shader */
        loadAttribIndices(_program) {
            this.indices = _program.getAttribIndices(this.attribs);
        }
        /** Enable a attribute in a shader for this context, */
        bindAttribs() {
            if (this.indices == null)
                throw "indices are not loaded";
            let n = this.attribs.length;
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer); //making the buffer of this class the current buffer
            for (let i = 0; i < n; i++) {
                this.gl.enableVertexAttribArray(this.indices[i]); //enable the Attribute
                this.gl.vertexAttribPointer(this.indices[i], this.attribs[i].float32Count, this.gl.FLOAT, false, this.stride, this.offsets[i]); //creates a pointer and structure for this attribute
            }
        }
    }
    FudgeCore.PhysicsDebugVertexBuffer = PhysicsDebugVertexBuffer;
    /** Internal class for holding data about PhysicsDebugVertexBuffers */
    class PhysicsDebugIndexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data amount. Used at buffer initialization */
        setData(_array) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(_array), this.gl.DYNAMIC_DRAW);
            this.count = _array.length;
        }
        /** The actual DrawCall for physicsDebugDraw Buffers. This is where the information from the debug is actually drawn. */
        draw(_mode = this.gl.TRIANGLES, _count = -1) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.drawElements(_mode, _count >= 0 ? _count : this.count, this.gl.UNSIGNED_SHORT, 0);
        }
    }
    FudgeCore.PhysicsDebugIndexBuffer = PhysicsDebugIndexBuffer;
    /** Internal class for managing data about webGL Attributes */
    class PhysicsDebugVertexAttribute {
        constructor(_float32Count, _name) {
            this.name = _name;
            this.float32Count = _float32Count;
        }
    }
    FudgeCore.PhysicsDebugVertexAttribute = PhysicsDebugVertexAttribute;
    /** Internal class for Shaders used only by the physics debugDraw */
    class PhysicsDebugShader {
        /** Introduce the FUDGE Rendering Context to this class, creating a program and vertex/fragment shader in this context */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.program = this.gl.createProgram();
            this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        }
        /** Take glsl shaders as strings and compile them, attaching the compiled shaders to a program thats used by this rendering context. */
        compile(_vertexSource, _fragmentSource) {
            this.uniformLocationMap = new Map();
            this.compileShader(this.vertexShader, _vertexSource);
            this.compileShader(this.fragmentShader, _fragmentSource);
            this.gl.attachShader(this.program, this.vertexShader);
            this.gl.attachShader(this.program, this.fragmentShader);
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) { //make sure the linking worked, so the program is valid, and shaders are working
                FudgeCore.Debug.log(this.gl.getProgramInfoLog(this.program));
            }
            this.gl.validateProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.VALIDATE_STATUS)) {
                console.error("ERROR validating program!", this.gl.getProgramInfoLog(this.program));
                return;
            }
        }
        /** Get index of a attribute in a shader in this program */
        getAttribIndex(_name) {
            return this.gl.getAttribLocation(this.program, _name);
        }
        /** Get the location of a uniform in a shader in this program */
        getUniformLocation(_name) {
            if (this.uniformLocationMap.has(_name))
                return this.uniformLocationMap.get(_name);
            let location = this.gl.getUniformLocation(this.program, _name);
            this.uniformLocationMap.set(_name, location);
            return location;
        }
        /** Get all indices for every attribute in the shaders of this program */
        getAttribIndices(_attribs) {
            let indices = [];
            _attribs.forEach(_value => {
                indices.push(this.getAttribIndex(_value.name));
            });
            return indices;
        }
        /** Tell the FUDGE Rendering Context to use this program to draw. */
        use() {
            this.gl.useProgram(this.program);
        }
        /** Compile a shader out of a string and validate it. */
        compileShader(_shader, _source) {
            this.gl.shaderSource(_shader, _source);
            this.gl.compileShader(_shader);
            if (!this.gl.getShaderParameter(_shader, this.gl.COMPILE_STATUS)) {
                FudgeCore.Debug.log(this.gl.getShaderInfoLog(_shader));
            }
        }
    }
    FudgeCore.PhysicsDebugShader = PhysicsDebugShader;
    /** Internal Class used to draw debugInformations about the physics simulation onto the renderContext. No user interaction needed.
     * @author Marko Fehrenbach, HFU 2020 //Based on OimoPhysics Haxe DebugDrawDemo
     */
    class PhysicsDebugDraw extends FudgeCore.RenderWebGL {
        /** Creating the debug for physics in FUDGE. Tell it to draw only wireframe objects, since FUDGE is handling rendering of the objects besides physics.
         * Override OimoPhysics Functions with own rendering. Initialize buffers and connect them with the context for later use. */
        constructor() {
            super();
            this.style = new OIMO.DebugDrawStyle();
            this.oimoDebugDraw = new OIMO.DebugDraw();
            this.oimoDebugDraw.wireframe = true; //Triangle Rendering is handled by FUDGE so, only the physics lines/points need to be rendered, although triangle is still implemented
            this.gl = FudgeCore.RenderWebGL.crc3;
            this.initializeOverride();
            this.shader = new PhysicsDebugShader(this.gl);
            this.shader.compile(this.vertexShaderSource(), this.fragmentShaderSource());
            this.initializeBuffers();
        }
        /** Receive the current DebugMode from the physics settings and set the OimoPhysics.DebugDraw booleans to show only certain informations.
         * Needed since some debug informations exclude others, and can't be drawn at the same time, by OimoPhysics. And for users it provides more readability
         * to debug only what they need and is commonly debugged.
         */
        setDebugMode(_mode = FudgeCore.PHYSICS_DEBUGMODE.NONE) {
            // tslint:disable-next-line
            let draw = { drawAabbs: false, drawBases: false, drawBvh: false, drawContactBases: false, drawContacts: false, drawJointLimits: false, drawJoints: false, drawPairs: false, drawShapes: false };
            switch (_mode) {
                case FudgeCore.PHYSICS_DEBUGMODE.COLLIDERS: //Colliders and Bases
                    draw.drawBases = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.JOINTS_AND_COLLIDER: //Colliders and joints
                    draw.drawJoints = draw.drawJointLimits = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY: //Physics Objects only, shows same as Collider / Joints but also hiding every other fudge object
                    draw.drawBases = draw.drawJointLimits = draw.drawJoints = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.CONTACTS: //Contacts
                    draw.drawBases = draw.drawContactBases = draw.drawContacts = draw.drawPairs = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.BOUNDING_BOXES: //Bounding Box / Broadphase Bvh / Bases
                    draw.drawAabbs = draw.drawBases = draw.drawBvh = true;
                    break;
            }
            Object.assign(this.oimoDebugDraw, draw);
        }
        /** Creating the empty render buffers. Defining the attributes used in shaders.
         * Needs to create empty buffers to already have them ready to draw later on, linking is only possible with existing buffers. */
        initializeBuffers() {
            let attribs = [
                new PhysicsDebugVertexAttribute(3, "aPosition"),
                new PhysicsDebugVertexAttribute(3, "aNormal"),
                new PhysicsDebugVertexAttribute(3, "aColor")
            ];
            this.pointVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.pointIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.pointVBO.setAttribs(attribs);
            this.pointVBO.loadAttribIndices(this.shader);
            this.lineVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.lineIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.lineVBO.setAttribs(attribs);
            this.lineVBO.loadAttribIndices(this.shader);
            this.triVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.triIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.triVBO.setAttribs(attribs);
            this.triVBO.loadAttribIndices(this.shader);
            this.clearBuffers();
        }
        /** Before OimoPhysics.world is filling the debug. Make sure the buffers are reset. Also receiving the debugMode from settings and updating the current projection for the vertexShader. */
        clearBuffers() {
            this.gl.lineWidth(2.0); //Does not affect anything because lineWidth is currently only supported by Microsoft Edge and FUDGE is optimized for Chrome
            this.pointData = []; //Resetting the data to be filled again
            this.lineData = [];
            this.triData = [];
            this.numPointData = 0; //Resetting the amount of data calls
            this.numLineData = 0;
            this.numTriData = 0;
        }
        /** After OimoPhysics.world filled the debug. Rendering calls. Setting this program to be used by the FUDGE rendering context. And draw each updated buffer and resetting them. */
        drawBuffers() {
            this.shader.use();
            let projection = FudgeCore.Physics.mainCam.mtxWorldToView.get();
            this.gl.uniformMatrix4fv(this.shader.getUniformLocation("u_mtxMeshToView"), false, projection);
            if (this.numPointData > 0) {
                this.pointIboData = []; //Buffer size matching to whats needed
                for (let i = 0; i < this.numPointData; i++) {
                    this.pointIboData.push(i);
                }
                this.pointIBO.setData(this.pointIboData); //Set Index buffer to correct size
                this.pointVBO.setData(this.pointData); //Set Vertex Buffer to current Data
                this.pointVBO.bindAttribs();
                this.pointIBO.draw(this.gl.POINTS, this.numPointData); //The actual draw call for each index in ibo
                this.numPointData = 0;
            }
            if (this.numLineData > 0) {
                this.lineIboData = [];
                for (let i = 0; i < this.numLineData; i++) {
                    this.lineIboData.push(i * 2);
                    this.lineIboData.push(i * 2 + 1);
                }
                this.lineIBO.setData(this.lineIboData);
                this.lineVBO.setData(this.lineData);
                this.lineVBO.bindAttribs();
                this.lineIBO.draw(this.gl.LINES, this.numLineData * 2);
                this.numLineData = 0;
            }
            if (this.numTriData > 0) {
                this.triIboData = [];
                for (let i = 0; i < this.numTriData; i++) {
                    this.triIboData.push(i * 3);
                    this.triIboData.push(i * 3 + 1);
                    this.triIboData.push(i * 3 + 2);
                }
                this.triIBO.setData(this.triIboData);
                this.triVBO.setData(this.triData);
                this.triVBO.bindAttribs();
                this.triIBO.draw(this.gl.TRIANGLES, this.numTriData * 3);
                this.numTriData = 0;
            }
        }
        /** Drawing the ray into the debugDraw Call. By using the overwritten line rendering functions and drawing a point (pointSize defined in the shader) at the end of the ray. */
        debugRay(_origin, _end, _color) {
            this.oimoDebugDraw.line(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
            this.oimoDebugDraw.point(new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
        }
        /** Overriding the existing functions from OimoPhysics.DebugDraw without actually inherit from the class, to avoid compiler problems.
         * Overriding them to receive debugInformations in the format the physic engine provides them but handling the rendering in the fudge context. */
        initializeOverride() {
            //Override point/line/triangle functions of OimoPhysics which are used to draw wireframes of objects, lines of raycasts or triangles when the objects are rendered by the physics not FUDGE (unused)
            OIMO.DebugDraw.prototype.point = function (_v, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw; //Get the custom physics debug class to have access to the data.
                if (FudgeCore.Physics.mainCam != null) { //only act when there is a camera that is rendering
                    let data = debugWrapper.pointData; //get the already written buffer informations
                    data.push(_v.x, _v.y, _v.z); //Coordinates of the point
                    data.push(0, 0, 0); //Point Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //Color of the point
                    debugWrapper.numPointData++;
                }
            };
            OIMO.DebugDraw.prototype.line = function (_v1, _v2, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.lineData;
                    data.push(_v1.x, _v1.y, _v1.z); //Point 1 Coordinates
                    data.push(0, 0, 0); //P1 Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //P1 Color
                    data.push(_v2.x, _v2.y, _v2.z); //Point 2 Coordinates
                    data.push(0, 0, 0);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numLineData++;
                }
            };
            OIMO.DebugDraw.prototype.triangle = function (_v1, _v2, _v3, _n1, _n2, _n3, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.triData;
                    data.push(_v1.x, _v1.y, _v1.z);
                    data.push(_n1.x, _n1.y, _n1.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v2.x, _v2.y, _v2.z);
                    data.push(_n2.x, _n2.y, _n2.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v3.x, _v3.y, _v3.z);
                    data.push(_n3.x, _n3.y, _n3.z);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numTriData++;
                }
            };
        }
        /** The source code (string) of the in physicsDebug used very simple vertexShader.
         *  Handling the projection (which includes, view/world[is always identity in this case]/projection in FUDGE). Increasing the size of single points drawn.
         *  And transfer position color to the fragmentShader. */
        vertexShaderSource() {
            return `
			precision mediump float;
			attribute vec3 aPosition;
			attribute vec3 aColor;
			attribute vec3 aNormal;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;
			uniform mat4 u_mtxMeshToView;

			void main() {
				vPosition = aPosition;
				vColor = aColor;
				vNormal = aNormal;
				gl_Position = u_mtxMeshToView * vec4(aPosition,1.0);
				gl_PointSize = 6.0;
			}`;
        }
        /** The source code (string) of the in physicsDebug used super simple fragmentShader. Unlit - only colorizing the drawn pixels, normals/position are given to make it expandable */
        fragmentShaderSource() {
            return `
      precision mediump float;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(vColor, 1.0);
			}`;
        }
    }
    FudgeCore.PhysicsDebugDraw = PhysicsDebugDraw;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A physical connection between two bodies with a defined axe of translation and rotation. Two Degrees of Freedom in the defined axis.
     * Two RigidBodies need to be defined to use it. A motor can be defined for rotation and translation, along with spring settings.
     *
     * ```text
     *          JointHolder - bodyAnchor
     *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
     *                    ‚îÇ   ‚îÇ
     *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on axis = 1st degree of freedom
     *                    ‚îÇ   ‚îÇ        rotating around axis = 2nd degree of freedom
     *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointCylindrical extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointCylindrical); }
        #springDampingRotation;
        #springFrequencyRotation;
        #motorForce;
        #maxRotor;
        #minRotor;
        #rotorTorque;
        #rotorSpeed;
        #rotor;
        #rotorSpringDamper;
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.CylindricalJointConfig();
            this.#springDampingRotation = 0;
            this.#springFrequencyRotation = 0;
            this.#motorForce = 0;
            this.#maxRotor = 360;
            this.#minRotor = 0;
            this.#rotorTorque = 0;
            this.#rotorSpeed = 0;
            this.#getMutator = () => {
                let mutator = {
                    motorForce: this.motorForce,
                    springDampingRotation: this.springDampingRotation,
                    springFrequencyRotation: this.springFrequencyRotation,
                    maxRotor: this.maxRotor,
                    minRotor: this.minRotor,
                    rotorTorque: this.rotorTorque,
                    rotorSpeed: this.rotorSpeed
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["motorForce", "rotorTorque", "rotorSpeed", "maxRotor", "minRotor", "springDampingRotation", "springFrequencyRotation", "springFrequency"]);
            };
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        set springDamping(_value) {
            super.springDamping = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        set springFrequency(_value) {
            super.springFrequency = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().frequency = _value;
        }
        /**
        * The damping of the spring. 1 equals completly damped. Influencing TORQUE / ROTATION
        */
        get springDampingRotation() {
            return this.#springDampingRotation;
        }
        set springDampingRotation(_value) {
            this.#springDampingRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. Influencing TORQUE / ROTATION
        */
        get springFrequencyRotation() {
            return this.#springFrequencyRotation;
        }
        set springFrequencyRotation(_value) {
            this.#springFrequencyRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotor() {
            return this.#maxRotor;
        }
        set maxRotor(_value) {
            this.#maxRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotor() {
            return this.#minRotor;
        }
        set minRotor(_value) {
            this.#minRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeed() {
            return this.#rotorSpeed;
        }
        set rotorSpeed(_value) {
            this.#rotorSpeed = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorque() {
            return this.#rotorTorque;
        }
        set rotorTorque(_value) {
            this.#rotorTorque = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorTorque = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().lowerLimit = _value;
        }
        set motorSpeed(_value) {
            super.motorSpeed = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#rotorSpringDamper = new OIMO.SpringDamper().setSpring(this.springFrequencyRotation, this.springDampingRotation);
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(super.minMotor, super.maxMotor);
            this.motor.setMotor(super.motorSpeed, this.motorForce);
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(this.minRotor * FudgeCore.Calc.deg2rad, this.maxRotor * FudgeCore.Calc.deg2rad);
            this.#rotor.setMotor(this.rotorSpeed, this.rotorTorque);
            this.config = new OIMO.CylindricalJointConfig();
            super.constructJoint();
            this.config.translationalSpringDamper = this.springDamper;
            this.config.translationalLimitMotor = this.motor;
            this.config.rotationalLimitMotor = this.#rotor;
            this.config.rotationalSpringDamper = this.#rotorSpringDamper;
            this.joint = new OIMO.CylindricalJoint(this.config);
            this.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointCylindrical = JointCylindrical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe movement.
       * Used to create a sliding joint along one axis. Two RigidBodies need to be defined to use it.
       * A motor can be defined to move the connected along the defined axis. Great to construct standard springs or physical sliders.
       *
       * ```text
       *          JointHolder - bodyAnchor
       *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
       *                    ‚îÇ   ‚îÇ
       *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on one Axis, 1 Degree of Freedom
       *                    ‚îÇ   ‚îÇ
       *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointPrismatic extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointPrismatic); }
        //Internally used variables - Joint Properties that are used even when no actual joint is currently existent
        #motorForce;
        /** Creating a prismatic joint between two ComponentRigidbodies only moving on one axis bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.PrismaticJointConfig();
            //Internally used variables - Joint Properties that are used even when no actual joint is currently existent
            this.#motorForce = 0;
            this.maxMotor = 10;
            this.minMotor = -10;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled. This is the force that the motor is using to hold the position, or reach it if a motorSpeed is defined.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorForce: this.motorForce,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorForce = _serialization.motorForce;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorForce = this.motorForce;
            return mutator;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.motorForce) !== "undefined")
                this.motorForce = _mutator.motorForce;
            delete _mutator.motorForce;
            super.mutate(_mutator);
        }
        //#endregion
        /** Actual creation of a joint in the OimoPhysics system */
        constructJoint() {
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(this.minMotor, this.maxMotor); //Create motor settings, to hold positions, set constraint min/max
            this.motor.setMotor(this.motorSpeed, this.motorForce);
            this.config = new OIMO.PrismaticJointConfig(); //Create a specific config for this joint type that is calculating the local axis for both bodies
            super.constructJoint();
            this.config.springDamper = this.springDamper; //Telling the config to use the motor/spring of the FUDGE Component
            this.config.limitMotor = this.motor;
            this.joint = new OIMO.PrismaticJoint(this.config);
            this.configureJoint();
        }
    }
    FudgeCore.JointPrismatic = JointPrismatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * A physical connection between two bodies, designed to simulate behaviour within a real body. It has two axis, a swing and twist axis, and also the perpendicular axis,
      * similar to a Spherical joint, but more restrictive in it's angles and only two degrees of freedom. Two RigidBodies need to be defined to use it. Mostly used to create humanlike joints that behave like a
      * lifeless body.
      * ```text
      *
      *                      anchor - it can twist on one axis and swing on another
      *                            ‚îÇ
      *         z            ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê
      *         ‚Üë            ‚îÇ   ‚îÇ ‚Üì ‚îÇ   ‚îÇ        e.g. z = TwistAxis, it can rotate in-itself around this axis
      *    -x ‚Üê‚îÄ‚îº‚îÄ‚Üí x        ‚îÇ   ‚îÇ x ‚îÇ   ‚îÇ        e.g. x = SwingAxis, it can rotate anchored around the base on this axis
      *         ‚Üì            ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
      *        -z            ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò         e.g. you can twist the leg in-itself to a certain degree,
      *                                                     but also rotate it forward/backward/left/right to a certain degree
      *                bodyAnchor          bodyTied
      *              (e.g. pelvis)         (e.g. upper-leg)
      *
      * ```
      * Twist equals a rotation around a point without moving on an axis.
      * Swing equals a rotation on a point with a moving local axis.
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
      */
    class JointRagdoll extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointRagdoll); }
        #springDampingTwist;
        #springFrequencyTwist;
        #springDampingSwing;
        #springFrequencySwing;
        #maxMotorTwist;
        #minMotorTwist;
        #motorTorqueTwist;
        #motorSpeedTwist;
        #motorTwist;
        #springDamperTwist;
        #springDamperSwing;
        #axisFirst;
        #axisSecond;
        #maxAngleFirst;
        #maxAngleSecond;
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.RagdollJointConfig();
            this.#springDampingTwist = 0;
            this.#springFrequencyTwist = 0;
            this.#springDampingSwing = 0;
            this.#springFrequencySwing = 0;
            this.#maxMotorTwist = 360;
            this.#minMotorTwist = 0;
            this.#motorTorqueTwist = 0;
            this.#motorSpeedTwist = 0;
            this.#maxAngleFirst = 0;
            this.#maxAngleSecond = 0;
            this.#getMutator = () => {
                let mutator = {
                    maxAngleFirst: this.#maxAngleFirst,
                    maxAngleSecond: this.#maxAngleSecond,
                    springDampingTwist: this.springDampingTwist,
                    springFrequencyTwist: this.springFrequencyTwist,
                    springDampingSwing: this.springDampingSwing,
                    springFrequencySwing: this.springFrequencySwing,
                    maxMotorTwist: this.#maxMotorTwist,
                    minMotorTwist: this.#minMotorTwist,
                    motorSpeedTwist: this.motorSpeedTwist,
                    motorTorqueTwist: this.motorTorqueTwist
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                if (typeof (_mutator.maxAngleFirst) !== "undefined")
                    this.#maxAngleFirst = _mutator.maxAngleFirst;
                if (typeof (_mutator.maxAngleSecond) !== "undefined")
                    this.#maxAngleSecond = _mutator.maxAngleSecond;
                this.mutateBase(_mutator, [
                    "springDampingTwist", "springFrequencyTwist", "springDampingSwing", "springFrequencySwing", "maxMotorTwist", "minMotorTwist", "motorSpeedTwist", "motorTorqueTwist"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the first axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleFirstAxis() {
            return this.#maxAngleFirst * FudgeCore.Calc.rad2deg;
        }
        set maxAngleFirstAxis(_value) {
            this.#maxAngleFirst = _value * FudgeCore.Calc.deg2rad;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the second axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleSecondAxis() {
            return this.#maxAngleSecond * FudgeCore.Calc.rad2deg;
        }
        set maxAngleSecondAxis(_value) {
            this.#maxAngleSecond = _value * FudgeCore.Calc.deg2rad;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingTwist() {
            return this.#springDampingTwist;
        }
        set springDampingTwist(_value) {
            this.#springDampingTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyTwist() {
            return this.#springFrequencyTwist;
        }
        set springFrequencyTwist(_value) {
            this.#springFrequencyTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSwing() {
            return this.#springDampingSwing;
        }
        set springDampingSwing(_value) {
            this.#springDampingSwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySwing() {
            return this.#springFrequencySwing;
        }
        set springFrequencySwing(_value) {
            this.#springFrequencySwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxMotorTwist() {
            return this.#maxMotorTwist * FudgeCore.Calc.rad2deg;
        }
        set maxMotorTwist(_value) {
            _value *= FudgeCore.Calc.deg2rad;
            this.#maxMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().upperLimit = _value;
        }
        /**
         * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minMotorTwist() {
            return this.#minMotorTwist * FudgeCore.Calc.rad2deg;
        }
        set minMotorTwist(_value) {
            _value *= FudgeCore.Calc.deg2rad;
            this.#minMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().lowerLimit = _value;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get motorSpeedTwist() {
            return this.#motorSpeedTwist;
        }
        set motorSpeedTwist(_value) {
            this.#motorSpeedTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get motorTorqueTwist() {
            return this.#motorTorqueTwist;
        }
        set motorTorqueTwist(_value) {
            this.#motorTorqueTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axisFirst = this.axisFirst.serialize();
            serialization.axisSecond = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await this.axisFirst.deserialize(_serialization.axisFirst);
            await this.axisSecond.deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#springDamperTwist = new OIMO.SpringDamper().setSpring(this.springFrequencyTwist, this.springDampingTwist);
            this.#springDamperSwing = new OIMO.SpringDamper().setSpring(this.springFrequencySwing, this.springDampingSwing);
            this.#motorTwist = new OIMO.RotationalLimitMotor().setLimits(this.minMotorTwist, this.maxMotorTwist);
            this.#motorTwist.setMotor(this.motorSpeedTwist, this.motorTorqueTwist);
            this.config = new OIMO.RagdollJointConfig();
            super.constructJoint(this.axisFirst, this.axisSecond);
            this.config.swingSpringDamper = this.#springDamperSwing;
            this.config.twistSpringDamper = this.#springDamperTwist;
            this.config.twistLimitMotor = this.#motorTwist;
            this.config.maxSwingAngle1 = this.#maxAngleFirst;
            this.config.maxSwingAngle2 = this.#maxAngleSecond;
            this.joint = new OIMO.RagdollJoint(this.config);
            super.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointRagdoll = JointRagdoll;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe of rotation. Also known as HINGE joint.
       * Two RigidBodies need to be defined to use it. A motor can be defined to rotate the connected along the defined axis.
       *
       * ```text
       *                  rotation axis, 1st Degree of freedom
       *                    ‚Üë
       *               ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       *                    ‚îÇ
       *      bodyAnchor         bodyTied
       *   (e.g. Doorhinge)       (e.g. Door)
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointRevolute extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointRevolute); }
        #motorTorque;
        #rotor;
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.RevoluteJointConfig();
            this.#motorTorque = 0;
            this.maxMotor = 360;
            this.minMotor = 0;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            _value *= FudgeCore.Calc.deg2rad;
            if (this.joint)
                this.joint.getLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint)
                this.joint.getLimitMotor().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorTorque() {
            return this.#motorTorque;
        }
        set motorTorque(_value) {
            this.#motorTorque = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorTorque: this.motorTorque,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorTorque = _serialization.motorTorque;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorTorque = this.motorTorque;
            return mutator;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.motorTorque) !== "undefined")
                this.motorTorque = _mutator.motorTorque;
            delete _mutator.motorTorque;
            super.mutate(_mutator);
        }
        //#endregion
        constructJoint() {
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(super.minMotor * FudgeCore.Calc.deg2rad, super.maxMotor * FudgeCore.Calc.deg2rad);
            this.#rotor.setMotor(this.motorSpeed, this.motorTorque);
            this.config = new OIMO.RevoluteJointConfig();
            super.constructJoint();
            this.config.springDamper = this.springDamper;
            this.config.limitMotor = this.#rotor;
            this.joint = new OIMO.RevoluteJoint(this.config);
            this.configureJoint();
        }
    }
    FudgeCore.JointRevolute = JointRevolute;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with three Degrees of Freedom, also known as ball and socket joint. Two bodies connected at their anchor but free to rotate.
       * Used for things like the connection of bones in the human shoulder (if simplified, else better use JointRagdoll). Two RigidBodies need to be defined to use it. Only spring settings can be defined.
       * 3 Degrees are swing horizontal, swing vertical and twist.
       *
       * ```text
       *              JointHolder
       *         z      bodyAnchor (e.g. Human-Shoulder)
       *      y  ‚Üë
       *        \|          ‚îÄ‚îÄ‚îÄ(‚óè‚îÄ‚îÄ‚îÄ
       *  -x <---|---> x           bodyTied
       *         |\                (e.g. Upper-Arm)
       *         ‚Üì -y
       *        -z
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointSpherical extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointSpherical); }
        #springDamping;
        #springFrequency;
        #springDamper;
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.SphericalJointConfig();
            this.#springDamping = 0;
            this.#springFrequency = 0;
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().frequency = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                springDamping: this.springDamping,
                springFrequency: this.springFrequency,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.springDamping = _serialization.springDamping;
            this.springFrequency = _serialization.springFrequency;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.springDamping = this.springDamping;
            mutator.springFrequency = this.springFrequency;
            return mutator;
        }
        async mutate(_mutator) {
            this.mutateBase(_mutator, ["springDamping", "springFrequency"]);
            delete _mutator.springDamping;
            delete _mutator.springFrequency;
            super.mutate(_mutator);
        }
        //#endregion
        constructJoint() {
            this.#springDamper = new OIMO.SpringDamper().setSpring(this.springFrequency, this.springDamping);
            this.config = new OIMO.SphericalJointConfig();
            super.constructJoint();
            this.config.springDamper = this.#springDamper;
            this.joint = new OIMO.SphericalJoint(this.config);
            super.configureJoint();
        }
    }
    FudgeCore.JointSpherical = JointSpherical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with two defined axis (normally e.g. (0,0,1) and rotation(1,0,0)), they share the same anchor and have free rotation, but transfer the twist.
       * In reality used in cars to transfer the more stable stationary force on the velocity axis to the bumping, damped moving wheel. Two RigidBodies need to be defined to use it.
       * The two motors can be defined for the two rotation axis, along with springs.
       * ```text
       *
       *                      anchor - twist is transfered between bodies
       *         z                   |
       *         ‚Üë            -----  |  ------------
       *         |           |     | ‚Üì |            |
       *  -x <---|---> x     |     | x |            |           e.g. wheel can still turn up/down,
       *         |           |     |   |            |           left right but transfering it's rotation on to the wheel-axis.
       *         ‚Üì            -----     ------------
       *        -z
       *                 attachedRB          connectedRB
       *                (e.g. wheel)       (e.g. wheel-axis)
       * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointUniversal extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointUniversal); }
        #springDampingFirst;
        #springFrequencyFirst;
        #springDampingSecond;
        #springFrequencySecond;
        #maxRotorFirst;
        #minRotorFirst;
        #rotorTorqueFirst;
        #rotorSpeedFirst;
        #maxRotorSecond;
        #minRotorSecond;
        #rotorTorqueSecond;
        #rotorSpeedSecond;
        #motorFirst;
        #motorSecond;
        #axisSpringDamperFirst;
        #axisSpringDamperSecond;
        #axisFirst;
        #axisSecond;
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.UniversalJointConfig();
            this.#springDampingFirst = 0;
            this.#springFrequencyFirst = 0;
            this.#springDampingSecond = 0;
            this.#springFrequencySecond = 0;
            this.#maxRotorFirst = 360;
            this.#minRotorFirst = 0;
            this.#rotorTorqueFirst = 0;
            this.#rotorSpeedFirst = 0;
            this.#maxRotorSecond = 360;
            this.#minRotorSecond = 0;
            this.#rotorTorqueSecond = 0;
            this.#rotorSpeedSecond = 0;
            this.#getMutator = () => {
                let mutator = {
                    springDampingFirst: this.#springDampingFirst,
                    springFrequencyFirst: this.#springFrequencyFirst,
                    springDampingSecond: this.#springDampingSecond,
                    springFrequencySecond: this.#springFrequencySecond,
                    maxRotorFirst: this.#maxRotorFirst,
                    minRotorFirst: this.#minRotorFirst,
                    rotorSpeedFirst: this.#rotorSpeedFirst,
                    rotorTorqueFirst: this.#rotorTorqueFirst,
                    maxRotorSecond: this.#maxRotorSecond,
                    minRotorSecond: this.#minRotorSecond,
                    rotorSpeedSecond: this.#rotorSpeedSecond,
                    rotorTorqueSecond: this.#rotorTorqueSecond
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, [
                    "springDampingFirst", "springFrequencyFirst", "springDampingSecond", "springFrequencySecond",
                    "maxRotorFirst", "minRotorFirst", "rotorSpeedFirst", "rotorTorqueFirst",
                    "maxRotorSecond", "minRotorSecond", "rotorSpeedSecond", ".rotorTorqueSecond"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingFirst() {
            return this.#springDampingFirst;
        }
        set springDampingFirst(_value) {
            this.#springDampingFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyFirst() {
            return this.#springFrequencyFirst;
        }
        set springFrequencyFirst(_value) {
            this.#springFrequencyFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSecond() {
            return this.#springDampingSecond;
        }
        set springDampingSecond(_value) {
            this.#springDampingSecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySecond() {
            return this.#springFrequencySecond;
        }
        set springFrequencySecond(_value) {
            this.#springFrequencySecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorFirst() {
            return this.#maxRotorFirst;
        }
        set maxRotorFirst(_value) {
            this.#maxRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorFirst() {
            return this.#minRotorFirst;
        }
        set minRotorFirst(_value) {
            this.#minRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedFirst() {
            return this.#rotorSpeedFirst;
        }
        set rotorSpeedFirst(_value) {
            this.#rotorSpeedFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorSpeed = _value;
        }
        /**
         * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueFirst() {
            return this.#rotorTorqueFirst;
        }
        set rotorTorqueFirst(_value) {
            this.#rotorTorqueFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorTorque = _value;
        }
        /**
         * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorSecond() {
            return this.#maxRotorSecond;
        }
        set maxRotorSecond(_value) {
            this.#maxRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorSecond() {
            return this.#minRotorSecond;
        }
        set minRotorSecond(_value) {
            this.#minRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedSecond() {
            return this.#rotorSpeedSecond;
        }
        set rotorSpeedSecond(_value) {
            this.#rotorSpeedSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueSecond() {
            return this.#rotorTorqueSecond;
        }
        set rotorTorqueSecond(_value) {
            this.#rotorTorqueSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.firstAxis = this.axisFirst.serialize();
            serialization.secondAxis = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axisFirst = await new FudgeCore.Vector3().deserialize(_serialization.axisFirst);
            this.axisSecond = await new FudgeCore.Vector3().deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#axisSpringDamperFirst = new OIMO.SpringDamper().setSpring(this.#springFrequencyFirst, this.#springDampingFirst);
            this.#axisSpringDamperSecond = new OIMO.SpringDamper().setSpring(this.#springFrequencySecond, this.#springDampingSecond);
            this.#motorFirst = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * FudgeCore.Calc.deg2rad, this.#maxRotorFirst * FudgeCore.Calc.deg2rad);
            this.#motorFirst.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.#motorSecond = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * FudgeCore.Calc.deg2rad, this.#maxRotorFirst * FudgeCore.Calc.deg2rad);
            this.#motorSecond.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.config = new OIMO.UniversalJointConfig();
            super.constructJoint(this.#axisFirst, this.#axisSecond);
            this.config.limitMotor1 = this.#motorFirst;
            this.config.limitMotor2 = this.#motorSecond;
            this.config.springDamper1 = this.#axisSpringDamperFirst;
            this.config.springDamper2 = this.#axisSpringDamperSecond;
            this.joint = new OIMO.UniversalJoint(this.config);
            super.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointUniversal = JointUniversal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with no movement.
       * Best way to simulate convex objects like a chair seat connected to chair legs.
       * The actual anchor point does not matter that much, only in very specific edge cases.
       * Because welding means they simply do not disconnect. (unless you add Breakability)
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointWelding extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointWelding); }
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.GenericJointConfig();
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        //#endregion
        constructJoint() {
            this.config = new OIMO.GenericJointConfig();
            super.constructJoint(new OIMO.Mat3(), new OIMO.Mat3());
            this.joint = new OIMO.GenericJoint(this.config);
            this.joint.setAllowCollision(this.internalCollision);
        }
    }
    FudgeCore.JointWelding = JointWelding;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="../../../Physics/OimoPhysics.d.ts"/>
var FudgeCore;
/// <reference path="../../../Physics/OimoPhysics.d.ts"/>
(function (FudgeCore) {
    /**
      * Manages the OIMO physics engine for FUDGE. Multiple instances may be created, one is active at a time.
      * All methods are static and use the currently active instance. At startup, a default instance is created and become the active instance
      * Attaching a {@link ComponentRigidbody} to a {@link Node} places a physics collider in the physics instance active at that time.
      * @author Marko Fehrenbach, HFU 2020
      */
    class Physics {
        /** The SETTINGS that apply to the physical world. Ranging from things like sleeping, collisionShapeThickness and others */
        static { this.settings = new FudgeCore.PhysicsSettings(FudgeCore.COLLISION_GROUP.DEFAULT, (FudgeCore.COLLISION_GROUP.DEFAULT | FudgeCore.COLLISION_GROUP.GROUP_1 | FudgeCore.COLLISION_GROUP.GROUP_2 | FudgeCore.COLLISION_GROUP.GROUP_3 | FudgeCore.COLLISION_GROUP.GROUP_4)); }
        static { this.∆íactive = new Physics(); }
        /** The rendering of physical debug informations. Used internally no interaction needed.*/
        #debugDraw;
        /** The camera/viewport the physics are debugged to. Used internally no interaction needed. */
        #mainCam;
        constructor() {
            this.bodyList = new Array();
            this.jointList = new Array();
            if (typeof OIMO == "undefined") { // Check if OIMO Namespace was loaded, else do not use any physics. Check is needed to ensure FUDGE can be used without Physics
                FudgeCore.Debug.error("OIMO physics engine not connected!");
                return null;
            }
            this.oimoWorld = new OIMO.World();
            this.#debugDraw = new FudgeCore.PhysicsDebugDraw(); //Create a FUDGE Physics debugging handling object
            this.oimoWorld.setDebugDraw(this.#debugDraw.oimoDebugDraw); //Tell OimoPhysics where to debug to and how it will be handled
        }
        /**
         * Define the currently active Physics instance
         */
        static set activeInstance(_physics) {
            Physics.∆íactive = _physics;
        }
        /** Get the currently active Physics instance */
        static get activeInstance() {
            return Physics.∆íactive;
        }
        static get debugDraw() {
            return Physics.∆íactive.#debugDraw;
        }
        static get mainCam() {
            return Physics.∆íactive.#mainCam;
        }
        /**
        * Cast a RAY into the physical world from a origin point in a certain direction. Receiving informations about the hit object and the
        * hit point. Do not specify a _group to raycast the whole world, else only bodies within the specific group can be hit.
        */
        static raycast(_origin, _direction, _length = 1, _debugDraw = false, _group = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let ray = new OIMO.RayCastClosest();
            let begin = new OIMO.Vec3(_origin.x, _origin.y, _origin.z);
            let end = this.getRayEndPoint(begin, new FudgeCore.Vector3(_direction.x, _direction.y, _direction.z), _length);
            ray.clear();
            if (_group == FudgeCore.COLLISION_GROUP.DEFAULT) { //Case 1: Raycasting the whole world, normal mode
                Physics.∆íactive.oimoWorld.rayCast(begin, end, ray);
            }
            else { //Case2: Raycasting on each body in a specific group
                let allHits = new Array();
                Physics.∆íactive.bodyList.forEach(function (_value) {
                    if (_value.collisionGroup == _group) {
                        hitInfo = _value.raycastThisBody(_origin, _direction, _length);
                        if (hitInfo.hit == true) { //Every hit is could potentially be the closest
                            allHits.push(hitInfo);
                        }
                    }
                });
                allHits.forEach(function (_value) {
                    if (_value.hitDistance < hitInfo.hitDistance || hitInfo.hit == false) {
                        hitInfo = _value;
                    }
                });
            }
            if (ray.hit) { //Fill in informations on the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(ray.position.x, ray.position.y, ray.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(ray.normal.x, ray.normal.y, ray.normal.z);
                hitInfo.hitDistance = this.getRayDistance(_origin, hitInfo.hitPoint);
                hitInfo.rigidbodyComponent = ray.shape.userData;
                hitInfo.rayEnd = new FudgeCore.Vector3(end.x, end.y, end.z);
                hitInfo.rayOrigin = _origin;
            }
            else {
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(end.x, end.y, end.z);
            }
            if (_debugDraw) { //Handle debugging
                Physics.∆íactive.#debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        /**
        * Simulates the physical world. _deltaTime is the amount of time between physical steps, default is about 17ms (assuming 60 frames per second).
        * The maximum value is 1/30 of a second, to have more consistent frame calculations.
        */
        static simulate(_deltaTime = 1 / 60) {
            if (Physics.∆íactive.jointList.length > 0)
                Physics.connectJoints(); //Connect joints if anything has happened between the last call to any of the two paired rigidbodies
            if (FudgeCore.Time.game.getScale() != 0) { //If time is stopped do not simulate to avoid misbehaviour
                _deltaTime = _deltaTime > 1 / 30 ? 1 / 30 : _deltaTime; //If instead of a fixed rate the game framerate is used, make sure irregular timings are fixed to 30fps
                Physics.∆íactive.oimoWorld.step(_deltaTime * FudgeCore.Time.game.getScale()); //Update the simulation by the given deltaTime and the FUDGE internal TimeScale
            }
        }
        /**
         * Draw information about the currently active instance using the {@link ComponentCamera} given
         */
        static draw(_cmpCamera, _mode) {
            Physics.∆íactive.#debugDraw.setDebugMode(_mode);
            Physics.∆íactive.#mainCam = _cmpCamera;
            Physics.∆íactive.oimoWorld.debugDraw(); //Filling the physics world debug informations into the debug rendering handler
            Physics.∆íactive.#debugDraw.drawBuffers();
            Physics.∆íactive.#debugDraw.clearBuffers(); //Updates info about the current projection, resetting the points/lines/triangles that need to be drawn from debug
        }
        /**
          * Adjusts the transforms of the {@link ComponentRigidbody}s in the given branch to match their nodes or meshes
          */
        static adjustTransforms(_branch, _toMesh = false) {
            FudgeCore.Render.prepare(_branch, { ignorePhysics: true });
            for (let node of FudgeCore.Render.nodesPhysics)
                node.getComponent(FudgeCore.ComponentRigidbody).initialize();
        }
        /**
        * Get the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static getGravity() {
            let tmpVec = Physics.∆íactive.oimoWorld.getGravity();
            return new FudgeCore.Vector3(tmpVec.x, tmpVec.y, tmpVec.z);
        }
        /**
        * Set the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static setGravity(_value) {
            let tmpVec = new OIMO.Vec3(_value.x, _value.y, _value.z);
            Physics.∆íactive.oimoWorld.setGravity(tmpVec);
        }
        /**
        * Add a new OIMO Rigidbody to the active instance, happens automatically when adding a FUDGE Rigidbody Component.
        */
        static addRigidbody(_cmpRB) {
            Physics.∆íactive.bodyList.push(_cmpRB);
            Physics.∆íactive.oimoWorld.addRigidBody(_cmpRB.getOimoRigidbody());
        }
        /**
        * Remove the OIMO Rigidbody to the active instance, happens automatically when removing a FUDGE Rigidbody Component
        */
        static removeRigidbody(_cmpRB) {
            // TODO: two lists are being managed, info might deviate. Cleanup!
            let oimoRigidBody = _cmpRB.getOimoRigidbody();
            if (oimoRigidBody._world)
                oimoRigidBody._world.removeRigidBody(oimoRigidBody);
            // what if the rigidbodys oimo-world does not belong to the active instance?
            let id = Physics.∆íactive.bodyList.indexOf(_cmpRB);
            Physics.∆íactive.bodyList.splice(id, 1);
        }
        /**
        * Add a new OIMO Joint/Constraint to the active instance, happens automatically when adding a FUDGE Joint Component
        */
        static addJoint(_cmpJoint) {
            Physics.∆íactive.oimoWorld.addJoint(_cmpJoint.getOimoJoint());
        }
        /**
        * Called internally to inform the physics system that a joint has a change of core properties and needs to be recreated.
        */
        static changeJointStatus(_cmpJoint) {
            if (Physics.∆íactive.jointList.indexOf(_cmpJoint) < 0)
                Physics.∆íactive.jointList.push(_cmpJoint);
        }
        /**
          * Remove the OIMO Joint/Constraint to the active instance, happens automatically when removing a FUDGE Joint Component
          */
        static removeJoint(_cmpJoint) {
            try {
                Physics.∆íactive.oimoWorld.removeJoint(_cmpJoint.getOimoJoint());
            }
            catch (_error) {
                FudgeCore.Debug.fudge(_error);
            }
        }
        /** Returns all the ComponentRigidbodies that are known to the active instance. */
        static getBodyList() {
            return Physics.∆íactive.bodyList;
        }
        /** Giving a ComponentRigidbody a specific identification number so it can be referenced in the loading process. And removed rb's can receive a new id. */
        static distributeBodyID() {
            let freeId = 0;
            let free = false;
            Physics.∆íactive.bodyList.forEach((_value) => {
                if (_value.id != freeId) {
                    free = true;
                }
                else {
                    free = false;
                }
                if (!free) {
                    freeId++;
                }
            });
            return freeId;
        }
        /**
         * Connect all joints that are not connected yet. Used internally no user interaction needed. This functionality is called and needed to make sure joints connect/disconnect
         * if any of the two paired ComponentRigidbodies change.
         */
        static connectJoints() {
            let jointsToConnect = Physics.∆íactive.jointList;
            Physics.∆íactive.jointList = [];
            jointsToConnect.forEach((_joint) => {
                if (_joint.isConnected() == false)
                    if (_joint.isActive)
                        _joint.connect();
                    else
                        Physics.∆íactive.jointList.push(_joint);
            });
        }
        /** Remove all oimo joints and rigidbodies, so that they can be reused in another world  */
        static cleanup() {
            let oimoWorld = Physics.∆íactive.oimoWorld;
            if (oimoWorld != null) {
                //Resetting the world so a new world can be created, fix for re-opening a project in editor, making sure there are no old things calculated
                let jointsWorld = oimoWorld.getNumJoints();
                let bodiesWorld = oimoWorld.getNumRigidBodies();
                for (let body of Physics.∆íactive.bodyList)
                    body.isInitialized = false;
                Physics.∆íactive.jointList = new Array(); // TODO: see if it would be smarter, do use these arrays. Definitely more intuitive...
                for (let i = 0; i < jointsWorld; i++) {
                    let oimoJoint = Physics.∆íactive.oimoWorld.getJointList();
                    oimoWorld.removeJoint(oimoJoint);
                }
                for (let i = 0; i < bodiesWorld; i++) {
                    let oimoBody = oimoWorld.getRigidBodyList();
                    oimoWorld.removeRigidBody(oimoBody);
                }
            }
        }
        // /** Returns the ComponentRigidbody with the given id. Used internally to reconnect joints on loading in the editor. */
        // private static getBodyByID(_id: number): ComponentRigidbody {
        //   let body: ComponentRigidbody = null;
        //   Physics.#activePhysics.bodyList.forEach((value: ComponentRigidbody): void => {
        //     if (value.id == _id) {
        //       body = value;
        //     }
        //   });
        //   return body;
        // }
        /** Internal function to calculate the endpoint of mathematical ray. By adding the multiplied direction to the origin.
           * Used because OimoPhysics defines ray by start/end. But GameEngines commonly use origin/direction.
           */
        static getRayEndPoint(_start, _direction, _length) {
            let origin = FudgeCore.Recycler.get(FudgeCore.Vector3);
            origin.set(_start.x, _start.y, _start.z);
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, origin);
            FudgeCore.Recycler.store(scaledDirection);
            FudgeCore.Recycler.store(endpoint);
            FudgeCore.Recycler.store(origin);
            return new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z);
        }
        /** Internal function to get the distance in which a ray hit by subtracting points from each other and get the square root of the squared product of each component. */
        static getRayDistance(_origin, _hitPoint) {
            let dx = _origin.x - _hitPoint.x;
            let dy = _origin.y - _hitPoint.y;
            let dz = _origin.z - _hitPoint.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        /** Returns the actual used world of the OIMO physics engine. No user interaction needed - Only for advanced users that need to access it directly */
        getOimoWorld() {
            return Physics.∆íactive.oimoWorld;
        }
    }
    FudgeCore.Physics = Physics;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a threedimensional box by two corner-points, one with minimal values and one with maximum values
     */
    class Box {
        constructor(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.set(_min, _max);
        }
        /**
         * Define the corners of this box, standard values are Infinity for min, and -Infinity for max,
         * creating an impossible inverted box that can not contain any points
         */
        set(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.min = _min;
            this.max = _max;
        }
        /**
         * Expand the box if necessary to include the given point
         */
        expand(_include) {
            this.min.min(_include);
            this.max.max(_include);
        }
        recycle() {
            this.min.set(Infinity, Infinity, Infinity);
            this.max.set(-Infinity, -Infinity, -Infinity);
        }
    }
    FudgeCore.Box = Box;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores information provided by {@link Render}-picking e.g. using {@link Picker} and provides methods for further calculation of positions and normals etc.
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Pick {
        #mtxViewToWorld;
        #posWorld;
        #posMesh;
        constructor(_node) {
            this.node = _node;
        }
        /**
         * Accessor to calculate and store world position of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posWorld() {
            if (this.#posWorld)
                return this.#posWorld;
            let pointInClipSpace = FudgeCore.Vector3.Z(this.zBuffer);
            let m = this.#mtxViewToWorld.get();
            let result = FudgeCore.Vector3.TRANSFORMATION(pointInClipSpace, this.#mtxViewToWorld, true);
            let w = m[3] * pointInClipSpace.x + m[7] * pointInClipSpace.y + m[11] * pointInClipSpace.z + m[15];
            result.scale(1 / w);
            this.#posWorld = result;
            return result;
        }
        /**
         * Accessor to calculate and store position in mesh-space of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posMesh() {
            if (this.#posMesh)
                return this.#posMesh;
            let mtxWorldToMesh = FudgeCore.Matrix4x4.INVERSION(this.node.getComponent(FudgeCore.ComponentMesh).mtxWorld);
            let posMesh = FudgeCore.Vector3.TRANSFORMATION(this.posWorld, mtxWorldToMesh);
            this.#posMesh = posMesh;
            return posMesh;
        }
        /**
         * Accessor to calculate and store the face normal in world-space at the point of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get normal() {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let result;
            for (let face of cmpMesh.mesh.faces) {
                if (face.isInside(this.posMesh)) {
                    result = face.normal.clone;
                    break;
                }
            }
            result.transform(cmpMesh.mtxWorld, false);
            result.normalize();
            return result;
        }
        /**
         * Called solely by the renderer to enable calculation of the world coordinates of this {@link Pick}
         */
        set mtxViewToWorld(_mtxViewToWorld) {
            this.#mtxViewToWorld = _mtxViewToWorld;
        }
    }
    FudgeCore.Pick = Pick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Provides static methods for picking using {@link Render}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Picker {
        /**
         * Takes a ray plus min and max values for the near and far planes to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickRay(_nodes, _ray, _min, _max) {
            let cmpCameraPick = new FudgeCore.ComponentCamera();
            cmpCameraPick.mtxPivot.translation = _ray.origin;
            cmpCameraPick.mtxPivot.lookAt(FudgeCore.Vector3.SUM(_ray.origin, _ray.direction));
            cmpCameraPick.projectCentral(1, 0.001, FudgeCore.FIELD_OF_VIEW.DIAGONAL, _min, _max);
            let picks = FudgeCore.Render.pickBranch(_nodes, cmpCameraPick);
            return picks;
        }
        /**
         * Takes a camera and a point on its virtual normed projection plane (distance 1) to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickCamera(_nodes, _cmpCamera, _posProjection) {
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-_posProjection.x, _posProjection.y, 1));
            let length = ray.direction.magnitude;
            if (_cmpCamera.node) {
                let mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.node.mtxWorld, _cmpCamera.mtxPivot);
                ray.transform(mtxCamera);
                FudgeCore.Recycler.store(mtxCamera);
            }
            else
                ray.transform(_cmpCamera.mtxPivot);
            let picks = Picker.pickRay(_nodes, ray, length * _cmpCamera.getNear(), length * _cmpCamera.getFar());
            return picks;
        }
        /**
         * Takes the camera of the given viewport and a point the client surface to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickViewport(_viewport, _posClient) {
            let posProjection = _viewport.pointClientToProjection(_posClient);
            let nodes = Array.from(_viewport.getBranch().getIterator(true));
            let picks = Picker.pickCamera(nodes, _viewport.camera, posProjection);
            return picks;
        }
    }
    FudgeCore.Picker = Picker;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defined by an origin and a direction of type {@link Pick}, rays are used to calculate picking and intersections
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by
         * the given point of origin and the planes normal. All values and calculations
         * must be relative to the same coordinate system, preferably the world
         */
        intersectPlane(_origin, _normal) {
            let difference = FudgeCore.Vector3.DIFFERENCE(_origin, this.origin);
            let factor = FudgeCore.Vector3.DOT(difference, _normal) / FudgeCore.Vector3.DOT(this.direction, _normal);
            let intersect = FudgeCore.Vector3.SUM(this.origin, FudgeCore.Vector3.SCALE(this.direction, factor));
            return intersect;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by the face.
         * All values and calculations must be relative to the same coordinate system, preferably the world
         */
        intersectFacePlane(_face) {
            return this.intersectPlane(_face.getPosition(0), _face.normal);
        }
        /**
         * Returns the shortest distance from the ray to the given target point.
         * All values and calculations must be relative to the same coordinate system, preferably the world.
         */
        getDistance(_target) {
            let originToTarget = FudgeCore.Vector3.DIFFERENCE(_target, this.origin);
            let raySection = FudgeCore.Vector3.NORMALIZATION(this.direction, 1);
            let projectedLength = FudgeCore.Vector3.DOT(originToTarget, raySection);
            raySection.scale(projectedLength);
            raySection.add(this.origin);
            let distance = FudgeCore.Vector3.DIFFERENCE(_target, raySection);
            return distance;
        }
        /**
         * Transform the ray by the given matrix
         */
        transform(_mtxTransform) {
            this.origin.transform(_mtxTransform);
            this.direction.transform(_mtxTransform, false);
        }
        /**
         * Returns a readable string representation of this ray
         */
        toString() {
            return `origin: ${this.origin.toString()}, direction: ${this.direction.toString()}, length: ${this.length.toPrecision(5)}`;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The main interface to the render engine, here WebGL (see superclass {@link RenderWebGL} and the RenderInjectors
     */
    class Render extends FudgeCore.RenderWebGL {
        static { this.rectClip = new FudgeCore.Rectangle(-1, 1, 2, -2); }
        static { this.nodesPhysics = new FudgeCore.RecycableArray(); }
        static { this.componentsPick = new FudgeCore.RecycableArray(); }
        static { this.lights = new Map(); }
        static { this.nodesSimple = new FudgeCore.RecycableArray(); }
        static { this.nodesAlpha = new FudgeCore.RecycableArray(); }
        static { this.componentsSkeleton = new FudgeCore.RecycableArray(); }
        // TODO: research if picking should be optimized using radius picking to filter
        //#region Prepare
        /**
         * Recursively iterates over the branch starting with the node given, recalculates all world transforms,
         * collects all lights and feeds all shaders used in the graph with these lights. Sorts nodes for different
         * render passes.
         */
        static prepare(_branch, _options = {}, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _shadersUsed = null) {
            let firstLevel = (_shadersUsed == null);
            if (firstLevel) {
                _shadersUsed = [];
                Render.timestampUpdate = performance.now();
                Render.nodesSimple.reset();
                Render.nodesAlpha.reset();
                Render.nodesPhysics.reset();
                Render.componentsPick.reset();
                Render.componentsSkeleton.reset();
                Render.lights.forEach(_array => _array.reset());
                _branch.dispatchEvent(new Event("renderPrepareStart" /* EVENT.RENDER_PREPARE_START */));
            }
            if (!_branch.isActive)
                return; // don't add branch to render list if not active
            _branch.nNodesInBranch = 1;
            _branch.radius = 0;
            _branch.dispatchEventToTargetOnly(new Event("renderPrepare" /* EVENT.RENDER_PREPARE */));
            _branch.timestampUpdate = Render.timestampUpdate;
            if (_branch.cmpTransform && _branch.cmpTransform.isActive) {
                let mtxWorldBranch = FudgeCore.Matrix4x4.MULTIPLICATION(_mtxWorld, _branch.cmpTransform.mtxLocal);
                _branch.mtxWorld.set(mtxWorldBranch);
                FudgeCore.Recycler.store(mtxWorldBranch);
            }
            else
                _branch.mtxWorld.set(_mtxWorld); // overwrite readonly mtxWorld of the current node
            let cmpRigidbody = _branch.getComponent(FudgeCore.ComponentRigidbody);
            if (cmpRigidbody && cmpRigidbody.isActive) { //TODO: support de-/activation throughout
                Render.nodesPhysics.push(_branch); // add this node to physics list
                if (!_options?.ignorePhysics)
                    this.transformByPhysics(_branch, cmpRigidbody);
            }
            let cmpPick = _branch.getComponent(FudgeCore.ComponentPick);
            if (cmpPick && cmpPick.isActive) {
                Render.componentsPick.push(cmpPick); // add this component to pick list
            }
            let cmpLights = _branch.getComponents(FudgeCore.ComponentLight);
            Render.addLights(cmpLights);
            let cmpMesh = _branch.getComponent(FudgeCore.ComponentMesh);
            let cmpMaterial = _branch.getComponent(FudgeCore.ComponentMaterial);
            if (cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive) {
                let mtxWorldMesh = FudgeCore.Matrix4x4.MULTIPLICATION(_branch.mtxWorld, cmpMesh.mtxPivot);
                cmpMesh.mtxWorld.set(mtxWorldMesh);
                FudgeCore.Recycler.store(mtxWorldMesh); // TODO: examine, why recycling this causes meshes to be misplaced...
                let shader = cmpMaterial.material.getShader();
                let cmpParticleSystem = _branch.getComponent(FudgeCore.ComponentParticleSystem);
                if (cmpParticleSystem && cmpParticleSystem.isActive && cmpParticleSystem.particleSystem != null)
                    shader = cmpParticleSystem.particleSystem.getShaderFrom(shader);
                if (_shadersUsed.indexOf(shader) < 0)
                    _shadersUsed.push(shader);
                _branch.radius = cmpMesh.radius;
                if (cmpMaterial.sortForAlpha)
                    Render.nodesAlpha.push(_branch); // add this node to render list
                else
                    Render.nodesSimple.push(_branch); // add this node to render list
            }
            let cmpSkeletons = _branch.getComponents(FudgeCore.ComponentSkeleton);
            for (let cmpSkeleton of cmpSkeletons)
                if (cmpSkeleton && cmpSkeleton.isActive)
                    Render.componentsSkeleton.push(cmpSkeleton);
            for (let child of _branch.getChildren()) {
                Render.prepare(child, _options, _branch.mtxWorld, _shadersUsed);
                _branch.nNodesInBranch += child.nNodesInBranch;
                let cmpMeshChild = child.getComponent(FudgeCore.ComponentMesh);
                let position = cmpMeshChild ? cmpMeshChild.mtxWorld.translation : child.mtxWorld.translation;
                position = position.clone;
                _branch.radius = Math.max(_branch.radius, position.getDistance(_branch.mtxWorld.translation) + child.radius);
                FudgeCore.Recycler.store(position);
            }
            if (firstLevel) {
                for (const cmpSkeleton of Render.componentsSkeleton) {
                    cmpSkeleton.update();
                    cmpSkeleton.updateRenderBuffer();
                }
                _branch.dispatchEvent(new Event("renderPrepareEnd" /* EVENT.RENDER_PREPARE_END */));
                Render.updateLightsUBO(Render.lights);
            }
        }
        /**
         * Add the given lights to the {@link Render.lights}-map, sorted by type.
         */
        static addLights(_cmpLights) {
            for (let cmpLight of _cmpLights) {
                if (!cmpLight.isActive)
                    continue;
                let type = cmpLight.light.getType();
                let lightsOfType = Render.lights.get(type);
                if (!lightsOfType) {
                    lightsOfType = new FudgeCore.RecycableArray();
                    Render.lights.set(type, lightsOfType);
                }
                lightsOfType.push(cmpLight);
            }
        }
        //#endregion
        //#region Picking
        /**
         * Used with a {@link Picker}-camera, this method renders one pixel with picking information
         * for each node in the line of sight and return that as an unsorted {@link Pick}-array
         */
        static pickBranch(_nodes, _cmpCamera) {
            Render.∆ípicked = [];
            let size = Math.ceil(Math.sqrt(_nodes.length));
            Render.createPickTexture(size);
            Render.setBlendMode(FudgeCore.BLEND.OPAQUE);
            for (let node of _nodes) {
                let cmpMesh = node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = node.getComponent(FudgeCore.ComponentMaterial);
                if (cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive) {
                    // let mtxMeshToView: Matrix4x4 = Matrix4x4.MULTIPLICATION(_cmpCamera.mtxWorldToView, cmpMesh.mtxWorld);
                    Render.pick(node, node.mtxWorld, _cmpCamera);
                    // RenderParticles.drawParticles();
                    // Recycler.store(mtxMeshToView);
                }
            }
            Render.setBlendMode(FudgeCore.BLEND.TRANSPARENT);
            let picks = Render.getPicks(size, _cmpCamera);
            Render.resetFrameBuffer();
            return picks;
        }
        //#endregion
        //#region Drawing
        /**
         * Draws the scene from the point of view of the given camera
         */
        static draw(_cmpCamera) {
            _cmpCamera.resetWorldToView();
            Render.drawList(_cmpCamera, this.nodesSimple);
            Render.drawListAlpha(_cmpCamera);
        }
        static drawListAlpha(_cmpCamera) {
            function sort(_a, _b) {
                return (Reflect.get(_a, "zCamera") < Reflect.get(_b, "zCamera")) ? 1 : -1;
            }
            for (let node of Render.nodesAlpha)
                Reflect.set(node, "zCamera", _cmpCamera.pointWorldToClip(node.getComponent(FudgeCore.ComponentMesh).mtxWorld.translation).z);
            let sorted = Render.nodesAlpha.getSorted(sort);
            Render.drawList(_cmpCamera, sorted);
        }
        static drawList(_cmpCamera, _list) {
            for (let node of _list) {
                Render.drawNode(node, _cmpCamera);
            }
        }
        //#region Physics
        static transformByPhysics(_node, _cmpRigidbody) {
            if (!_cmpRigidbody.isInitialized) // || Project.mode == MODE.EDITOR)
                _cmpRigidbody.initialize();
            if (!FudgeCore.Physics.getBodyList().length)
                return;
            if (!_node.mtxLocal) {
                throw (new Error("ComponentRigidbody requires ComponentTransform at the same Node"));
            }
            _cmpRigidbody.checkCollisionEvents();
            if (_cmpRigidbody.typeBody == FudgeCore.BODY_TYPE.KINEMATIC || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR) { //Case of Kinematic Rigidbody
                let mtxPivotWorld = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, _cmpRigidbody.mtxPivotUnscaled);
                _cmpRigidbody.setPosition(mtxPivotWorld.translation);
                _cmpRigidbody.setRotation(mtxPivotWorld.rotation);
                FudgeCore.Recycler.store(mtxPivotWorld);
                return;
            }
            let mtxWorld = FudgeCore.Matrix4x4.CONSTRUCTION(_cmpRigidbody.getPosition(), _cmpRigidbody.getRotation(), null);
            mtxWorld.multiply(_cmpRigidbody.mtxPivotInverse);
            _node.mtxWorld.translation = mtxWorld.translation;
            _node.mtxWorld.rotation = mtxWorld.rotation;
            let mtxLocal = _node.getParent() ? FudgeCore.Matrix4x4.RELATIVE(_node.mtxWorld, _node.getParent().mtxWorld) : _node.mtxWorld;
            _node.mtxLocal.set(mtxLocal);
            FudgeCore.Recycler.store(mtxWorld);
            FudgeCore.Recycler.store(mtxLocal);
        }
    }
    FudgeCore.Render = Render;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Inserted into a {@link Mesh}, an instance of this class calculates and represents the mesh data in the form needed by the render engine
     * @internal
     */
    class RenderMesh {
        constructor(_mesh) {
            this.buffers = null;
            this.mesh = _mesh;
        }
        get bones() {
            return this.∆íbones || ( // return cache or ...
            this.∆íbones = this.mesh.vertices.some(_vertex => _vertex.bones) ?
                new Uint8Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    const bones = this.mesh.vertices.bones(_index);
                    return [bones?.[0]?.index || 0, bones?.[1]?.index || 0, bones?.[2]?.index || 0, bones?.[3]?.index || 0];
                })) :
                undefined);
        }
        set bones(_iBones) {
            this.∆íbones = _iBones;
        }
        get weights() {
            return this.∆íweights || ( // return cache or ...
            this.∆íweights = this.mesh.vertices.some(_vertex => _vertex.bones) ?
                new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    const bones = this.mesh.vertices.bones(_index);
                    return [bones?.[0]?.weight || 0, bones?.[1]?.weight || 0, bones?.[2]?.weight || 0, bones?.[3]?.weight || 0];
                })) :
                undefined);
        }
        set weights(_weights) {
            this.∆íweights = _weights;
        }
        get vertices() {
            return this.∆ívertices || ( // return cache or ...
            // ... flatten all vertex positions from cloud into a typed array
            this.∆ívertices = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                return [...this.mesh.vertices.position(_index).get()];
            })));
        }
        set vertices(_vertices) {
            this.∆ívertices = _vertices;
        }
        get indices() {
            return this.∆íindices || ( // return cache or ...
            // ... flatten all indices from the faces into a typed array
            this.∆íindices = new Uint16Array(this.mesh.faces.flatMap((_face) => [..._face.indices])));
        }
        set indices(_indices) {
            this.∆íindices = _indices;
        }
        get normals() {
            if (this.∆ínormals == null) {
                // sum up all unscaled normals of faces connected to one vertex...
                this.mesh.vertices.forEach(_vertex => _vertex.normal.set(0, 0, 0));
                for (let face of this.mesh.faces)
                    for (let index of face.indices) {
                        this.mesh.vertices.normal(index).add(face.normalUnscaled);
                    }
                // ... and normalize them
                this.mesh.vertices.forEach(_vertex => {
                    // some vertices might be unused and yield a zero-normal...
                    if (_vertex.normal.magnitudeSquared > 0)
                        _vertex.normal.normalize();
                });
                // this.∆ínormalsVertex = new Float32Array(normalsVertex.flatMap((_normal: Vector3) => [..._normal.get()]));
                this.∆ínormals = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    return [...this.mesh.vertices.normal(_index).get()];
                }));
            }
            return this.∆ínormals;
        }
        set normals(_normals) {
            this.∆ínormals = _normals;
        }
        get textureUVs() {
            return this.∆ítextureUVs || ( // return cache or ...
            // ... flatten all uvs from the clous into a typed array
            this.∆ítextureUVs = new Float32Array(this.mesh.vertices
                .filter(_vertex => _vertex.uv)
                .flatMap((_vertex) => [..._vertex.uv.get()])));
        }
        set textureUVs(_textureUVs) {
            this.∆ítextureUVs = _textureUVs;
        }
        get colors() {
            return this.∆ícolors || (this.∆ícolors = new Float32Array(this.mesh.vertices
                .filter(_vertex => _vertex.color)
                .flatMap(_vertex => [..._vertex.color.getArray()])));
        }
        set colors(_colors) {
            this.∆ícolors = _colors;
        }
        /**
         * Clears this render mesh and all its buffers
         */
        clear() {
            this.buffers = null;
            this.∆ívertices = undefined;
            this.∆íindices = undefined;
            this.∆ítextureUVs = undefined;
            this.∆ínormals = undefined;
            this.∆ícolors = undefined;
            this.∆íbones = undefined;
            this.∆íweights = undefined;
        }
    }
    FudgeCore.RenderMesh = RenderMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Controls the rendering of a branch, using the given {@link ComponentCamera},
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of {@link Framing} objects. The stages involved are in order of rendering
     * {@link Render}.viewport -> {@link Viewport}.source -> {@link Viewport}.destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Viewport
     */
    class Viewport extends FudgeCore.EventTargetUnified {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the branch.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true;
            this.adjustingCamera = true;
            this.physicsDebugMode = FudgeCore.PHYSICS_DEBUGMODE.NONE;
            this.componentsPick = new FudgeCore.RecycableArray();
            this.#branch = null; // The to render with all its descendants.
            this.#crc2 = null;
            this.#canvas = null;
        }
        #branch; // The to render with all its descendants.
        #crc2;
        #canvas;
        //#endregion
        // #region Events (passing from canvas to viewport and from there into branch)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Retrieve the destination canvas
         */
        get canvas() {
            return this.#canvas;
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        get context() {
            return this.#crc2;
        }
        /**
         * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
         */
        initialize(_name, _branch, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.#canvas = _canvas;
            this.#crc2 = _canvas.getContext("2d");
            this.#canvas.tabIndex = 0; // can get focus and receive keyboard events
            this.rectSource = FudgeCore.Render.getCanvasRect();
            this.rectDestination = this.getClientRectangle();
            this.setBranch(_branch);
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.width, this.#canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
        }
        /**
         * Set the branch to be drawn in the viewport.
         */
        setBranch(_branch) {
            if (_branch)
                _branch.dispatchEvent(new Event("attachBranch" /* EVENT.ATTACH_BRANCH */));
            this.#branch = _branch;
        }
        /**
         * Retrieve the branch this viewport renders
         */
        getBranch() {
            return this.#branch;
        }
        // #region Drawing
        /**
         * Draw this viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         */
        draw(_calculateTransforms = true) {
            this.computeDrawing(_calculateTransforms);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY)
                FudgeCore.Render.draw(this.camera);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE) {
                FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
            }
            this.#crc2.imageSmoothingEnabled = false;
            this.#crc2.drawImage(FudgeCore.Render.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
        * The transforms in the branch are recalculated here.
        */
        computeDrawing(_calculateTransforms = true) {
            if (!this.#branch)
                return;
            FudgeCore.Render.resetFrameBuffer();
            if (!this.camera.isActive)
                return;
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            if (_calculateTransforms)
                this.calculateTransforms();
            FudgeCore.Render.clear(this.camera.clrBackground);
        }
        /**
         * Calculate the cascade of transforms in this branch and store the results as mtxWorld in the {@link Node}s and {@link ComponentMesh}es
         */
        calculateTransforms() {
            let mtxRoot = FudgeCore.Matrix4x4.IDENTITY();
            if (this.#branch.getParent())
                mtxRoot = this.#branch.getParent().mtxWorld;
            // this.dispatchEvent(new Event(EVENT.RENDER_PREPARE_START)); // TODO: these events seem to get fired in Render.prepare aswell, check where the should get fired
            // this.adjustFrames(); // TODO: this got called twice per computeDrawing, check if it's necessary
            FudgeCore.Render.prepare(this.#branch, null, mtxRoot);
            // this.dispatchEvent(new Event(EVENT.RENDER_PREPARE_END)); // TODO: these events seem to get fired in Render.prepare aswell, check where the should get fired
            this.componentsPick = FudgeCore.Render.componentsPick;
        }
        /**
         * Performs a pick on all {@link ComponentPick}s in the branch of this viewport
         * using a ray from its camera through the client coordinates given in the event.
         * Dispatches the event to all nodes hit.
         * If {@link PICK.CAMERA} was chosen as the method to pick, a pick property gets added to the event,
         * which holds the detailed information, but is overwritten for each node.
         */
        dispatchPointerEvent(_event) {
            let posClient = new FudgeCore.Vector2(_event.clientX, _event.clientY);
            let ray = this.getRayFromClient(posClient);
            // let cameraPicks: RecycableArray<Node> = Recycler.get(RecycableArray); //TODO: think about optimization later
            let cameraPicks = [];
            let otherPicks = [];
            for (let cmpPick of this.componentsPick)
                cmpPick.pick == FudgeCore.PICK.CAMERA ? cameraPicks.push(cmpPick.node) : otherPicks.push(cmpPick);
            if (cameraPicks.length) {
                let picks = FudgeCore.Picker.pickCamera(cameraPicks, this.camera, this.pointClientToProjection(posClient));
                for (let pick of picks) {
                    Reflect.set(_event, "pick", pick);
                    pick.node.dispatchEvent(_event);
                }
            }
            for (let cmpPick of otherPicks) {
                cmpPick.pickAndDispatch(ray, _event);
            }
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas
         */
        adjustFrames() {
            // get the rectangle of the canvas area as displayed (consider css)
            let rectClient = this.getClientRectangle();
            // adjust the canvas size according to the given framing applied to client
            let rectCanvas = this.frameClientToCanvas.getRect(rectClient);
            this.#canvas.width = rectCanvas.width;
            this.#canvas.height = rectCanvas.height;
            let rectTemp;
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            rectTemp = this.frameCanvasToDestination.getRect(rectCanvas);
            this.rectDestination.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            rectTemp = this.frameDestinationToSource.getRect(this.rectDestination);
            this.rectSource.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport. For now, it's always adjusted to the current viewport
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.Render.setRenderRectangle(rectRender);
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.Render.setCanvasSize(rectRender.width, rectRender.height);
            FudgeCore.Recycler.store(rectClient);
            FudgeCore.Recycler.store(rectCanvas);
            FudgeCore.Recycler.store(rectRender);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render vieport
         */
        adjustCamera() {
            let rect = FudgeCore.Render.getRenderRectangle();
            // if (this.camera.getProjection() == PROJECTION.ORTHOGRAPHIC)
            //   this.camera.projectOrthographic(-rect.width / 20, rect.width / 20, rect.height / 20, -rect.height / 20);
            // else
            this.camera.projectCentral(rect.width / rect.height, this.camera.getFieldOfView(), this.camera.getDirection(), this.camera.getNear(), this.camera.getFar());
        }
        // #endregion
        //#region Points
        /**
         * Returns a {@link Ray} in world coordinates from this camera through the point given in client space
         */
        getRayFromClient(_point) {
            let posProjection = this.pointClientToProjection(_point);
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-posProjection.x, posProjection.y, 1));
            // ray.direction.scale(camera.distance);
            ray.transform(this.camera.mtxPivot);
            let cameraNode = this.camera.node;
            if (cameraNode)
                ray.transform(cameraNode.mtxWorld);
            return ray;
        }
        /**
         * Returns a point on the client rectangle matching the projection of the given point in world space
         */
        pointWorldToClient(_position) {
            let projection = this.camera.pointWorldToClip(_position);
            let posClient = this.pointClipToClient(projection.toVector2());
            return posClient;
        }
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.getClientRectangle());
            result = this.frameCanvasToDestination.getPoint(result, this.getCanvasRectangle());
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            // console.log(projectionRectangle.toString());
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point on a projection surface in the hypothetical distance of 1 to the camera
         * matching the given point on the client rectangle
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.Render.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.Render.rectClip.pointToRect(_normed, this.getCanvasRectangle());
            return pointCanvas;
        }
        /**
         * Returns a point in the browser page matching the given point of the viewport
         */
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.#canvas.offsetLeft + _client.x, this.#canvas.offsetTop + _client.y);
            return screen;
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Different xr session modes available. Could be expand with more modes in the future.
     * @authors Valentin Schmidberger, HFU, 2022 | Jonas Plotzky, HFU, 2023
     */
    let XR_SESSION_MODE;
    (function (XR_SESSION_MODE) {
        XR_SESSION_MODE["IMMERSIVE_VR"] = "immersive-vr";
        //IMMERSIVE_AR = "immersive-ar",
        //INLINE = "inline"
    })(XR_SESSION_MODE = FudgeCore.XR_SESSION_MODE || (FudgeCore.XR_SESSION_MODE = {}));
    /**
     * Different reference vr-spaces available, creator has to check if the space is supported with its device.
     * Could be expand with more available space types in the future.
     */
    let XR_REFERENCE_SPACE;
    (function (XR_REFERENCE_SPACE) {
        XR_REFERENCE_SPACE["VIEWER"] = "viewer";
        XR_REFERENCE_SPACE["LOCAL"] = "local";
        // LOCAL_FLOOR = "local-floor",
        // BOUNDED_FLOOR = "bounded-floor",
        // UNBOUNDED = "unbounded"
    })(XR_REFERENCE_SPACE = FudgeCore.XR_REFERENCE_SPACE || (FudgeCore.XR_REFERENCE_SPACE = {}));
    /**
     * XRViewport (webXR)-extension of Viewport, to displaying its branch on Head Mounted and AR (not implemted yet) Devices
     */
    class XRViewport extends FudgeCore.Viewport {
        static { this.xrViewportInstance = null; }
        // private poseMtx: Matrix4x4 = new Matrix4x4();
        constructor() {
            super();
            this.vrDevice = null;
            this.session = null;
            this.referenceSpace = null;
            this.useVRController = false;
            this.crc3 = null;
            XRViewport.xrViewportInstance = this;
            this.crc3 = FudgeCore.RenderWebGL.getRenderingContext();
        }
        /**
         * To retrieve private static instance of xr viewport, readonly.
         */
        static get default() {
            return this.xrViewportInstance;
        }
        /**
          * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
          */
        initialize(_name, _branch, _cameraXR /* | ComponentCameraAR*/, _canvas) {
            super.initialize(_name, _branch, _cameraXR, _canvas);
            this.camera = _cameraXR;
        }
        /**
         * The VR Session is initialized here, also VR - Controller are initialized, if boolean is true.
         * Creator has to call FrameRequestXR after this Method to run the viewport in virtual reality.
         */
        async initializeVR(_vrSessionMode = XR_SESSION_MODE.IMMERSIVE_VR, _vrReferenceSpaceType = XR_REFERENCE_SPACE.LOCAL, _vrController = false) {
            let session = await navigator.xr.requestSession(_vrSessionMode);
            this.referenceSpace = await session.requestReferenceSpace(_vrReferenceSpaceType);
            await this.crc3.makeXRCompatible();
            let nativeScaleFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);
            //TODO:  Field of view k√∂nnte an der Stelle noch ver√§ndert werden.
            await session.updateRenderState({ baseLayer: new XRWebGLLayer(session, this.crc3, { framebufferScaleFactor: nativeScaleFactor }) });
            this.vrDevice = this.camera;
            this.initializeReferenceSpace();
            this.useVRController = _vrController;
            if (_vrController) {
                this.vrDevice.rightCntrl.cmpTransform = new FudgeCore.ComponentTransform();
                this.vrDevice.leftCntrl.cmpTransform = new FudgeCore.ComponentTransform();
            }
            this.session = session;
            this.calculateTransforms();
        }
        /**
         * The AR session could be initialized here. Up till now not implemented.
         */
        async initializeAR(_arSessionMode = null, _arReferenceSpaceType = null) {
            FudgeCore.Debug.error("NOT IMPLEMENTED YET! Check out initializeVR!");
        }
        /**
         * Draw the xr viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         * Called from loop method {@link Loop} again with the xrFrame parameter handover, as soon as FRAME_REQUEST_XR is called from creator.
         */
        draw(_calculateTransforms = true, _xrFrame = null) {
            if (!this.session) {
                super.draw(_calculateTransforms);
                return;
            }
            let pose = _xrFrame?.getViewerPose(this.referenceSpace);
            if (!pose)
                return;
            this.vrDevice.mtxLocal.set(pose.transform.matrix);
            super.computeDrawing(_calculateTransforms);
            let glLayer = this.session.renderState.baseLayer;
            FudgeCore.Render.resetFrameBuffer(glLayer.framebuffer);
            FudgeCore.Render.clear(this.camera.clrBackground);
            for (let view of pose.views) {
                let viewport = glLayer.getViewport(view);
                this.crc3.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                if (this.useVRController)
                    this.setControllerConfigs(_xrFrame);
                this.camera.mtxProjection.set(view.projectionMatrix);
                this.camera.mtxCameraInverse.set(view.transform.inverse.matrix);
                if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY)
                    FudgeCore.Render.draw(this.camera);
                if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE) {
                    FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
                }
            }
            FudgeCore.Render.setRenderRectangle(FudgeCore.Render.getRenderRectangle());
        }
        /**
         * Move the reference space to set the initial position/orientation of the vr device in accordance to the node the vr device is attached to.
         */
        initializeReferenceSpace() {
            let mtxWorld = this.vrDevice.node?.mtxWorld;
            if (!mtxWorld)
                return;
            mtxWorld = mtxWorld.clone;
            mtxWorld.rotateY(180); // rotate because the XR Rig is looking in the direction of negative z
            let invMtxTransfom = mtxWorld.inverse(); // inverse because we are moving the reference space
            // let invOrientation: Quaternion = new Quaternion();
            // invOrientation.eulerAngles = invMtxTransfom.eulerAngles;
            XRViewport.default.referenceSpace = XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(invMtxTransfom.translation, invMtxTransfom.quaternion));
        }
        //Sets controller matrices and thumbsticks movements.
        setControllerConfigs(_xrFrame) {
            if (_xrFrame) {
                if (XRViewport.default.session.inputSources.length > 0) {
                    XRViewport.default.session.inputSources.forEach(_controller => {
                        try {
                            switch (_controller.handedness) {
                                case ("right"):
                                    this.vrDevice.rightCntrl.cmpTransform.mtxLocal.set(_xrFrame.getPose(_controller.targetRaySpace, XRViewport.default.referenceSpace).transform.matrix);
                                    if (!this.vrDevice.rightCntrl.gamePad)
                                        this.vrDevice.rightCntrl.gamePad = _controller.gamepad;
                                    else {
                                        this.vrDevice.rightCntrl.thumbstickX = _controller.gamepad.axes[2];
                                        this.vrDevice.rightCntrl.thumbstickY = _controller.gamepad.axes[3];
                                    }
                                    break;
                                case ("left"):
                                    this.vrDevice.leftCntrl.cmpTransform.mtxLocal.set(_xrFrame.getPose(_controller.targetRaySpace, XRViewport.default.referenceSpace).transform.matrix);
                                    if (!this.vrDevice.leftCntrl.gamePad)
                                        this.vrDevice.leftCntrl.gamePad = _controller.gamepad;
                                    else {
                                        this.vrDevice.leftCntrl.thumbstickX = _controller.gamepad.axes[2];
                                        this.vrDevice.leftCntrl.thumbstickY = _controller.gamepad.axes[3];
                                    }
                                    break;
                            }
                        }
                        catch (e) {
                            FudgeCore.Debug.info("Input Sources Error: " + e);
                        }
                    });
                }
            }
        }
    }
    FudgeCore.XRViewport = XRViewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a FUDGE-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        /**
         * Open file select dialog to load files from local filesystem into browser application.
         */
        static async load(_multiple = false) {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = _multiple;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            return new Promise(_resolve => {
                function hndLoaded(_event) {
                    FileIoBrowserLocal.removeEventListener("fileLoaded" /* EVENT.FILE_LOADED */, hndLoaded);
                    _resolve(_event.detail.mapFilenameToContent);
                }
                FileIoBrowserLocal.addEventListener("fileLoaded" /* EVENT.FILE_LOADED */, hndLoaded);
                FileIoBrowserLocal.selector.click();
            });
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        /**
         * Open a file download dialog to save files to local filesystem.
         */
        static save(_toSave, _type = "text/plain") {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: _type });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            return new Promise(_resolve => {
                _resolve(_toSave);
                // function hndSaved(_event: Event): void {
                //   FileIoBrowserLocal.removeEventListener(EVENT.FILE_SAVED, hndSaved);
                //   _resolve((<CustomEvent>_event).detail);
                // }
                // FileIoBrowserLocal.addEventListener(EVENT.FILE_SAVED, hndSaved);
                // let event: CustomEvent = new CustomEvent(EVENT.FILE_SAVED, { detail: { mapFilenameToContent: _toSave } });
                // FileIoBrowserLocal.targetStatic.dispatchEvent(event);
            });
        }
        /**
         * Load the the files referenced in {@link FileList} into the provided {@link MapFilenameToContent}
         */
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* EVENT.FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Mutable array of {@link Mutable}s. The {@link Mutator}s of the entries are included as array in the {@link Mutator}
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class MutableArray extends Array {
        #type;
        constructor(_type, ..._args) {
            super(..._args);
            this.#type = _type;
        }
        get type() {
            return this.#type;
        }
        /**
         * Rearrange the entries of the array according to the given sequence of indices
         */
        rearrange(_sequence) {
            let length = this.length;
            for (let index of _sequence) {
                let original = this[index];
                // TODO: optimize, copy only double entries
                //@ts-ignore
                let copy = new original.constructor();
                copy.mutate(original.getMutator());
                this.push(copy);
            }
            this.splice(0, length);
        }
        /**
         * Returns an associative array with this arrays elements corresponding types as string-values
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let entry in this)
                types[entry] = this[entry].constructor.name;
            return types;
        }
        /**
         * Returns an array with each elements mutator by invoking {@link Mutable.getMutator} on them
         */
        getMutator() {
            return this.map((_value) => _value.getMutator());
        }
        /**
         * See {@link Mutable.getMutatorForUserInterface}
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Mutate each element of this array by invoking {@link Mutable.mutate} on it
         */
        async mutate(_mutator) {
            for (let entry in this)
                await this[entry].mutate(_mutator[entry]);
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         */
        updateMutator(_mutator) {
            for (let entry in this) {
                let mutatorValue = _mutator[entry];
                if (!mutatorValue)
                    continue;
                if (this[entry] instanceof FudgeCore.Mutable)
                    _mutator[entry] = this[entry].getMutator();
                else
                    _mutator[entry] = this[entry];
            }
        }
    }
    FudgeCore.MutableArray = MutableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MODE;
    (function (MODE) {
        MODE[MODE["EDITOR"] = 0] = "EDITOR";
        MODE[MODE["RUNTIME"] = 1] = "RUNTIME";
    })(MODE = FudgeCore.MODE || (FudgeCore.MODE = {}));
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    class Project extends FudgeCore.EventTargetStatic {
        static { this.resources = {}; }
        static { this.serialization = {}; }
        static { this.scriptNamespaces = {}; }
        static { this.baseURL = new URL(location.toString()); }
        static { this.mode = MODE.RUNTIME; }
        static { this.graphInstancesToResync = {}; }
        /**
         * Registers the resource and generates an id for it by default.
         * If the resource already has an id, thus having been registered, its deleted from the list and registered anew.
         * It's possible to pass an id, but should not be done except by the Serializer.
         */
        static register(_resource, _idResource) {
            if (_resource.idResource)
                if (_resource.idResource == _idResource)
                    return;
                else
                    this.deregister(_resource);
            _resource.idResource = _idResource || Project.generateId(_resource);
            Project.resources[_resource.idResource] = _resource;
        }
        /**
         * Removes the resource from the list of resources.
         */
        static deregister(_resource) {
            delete (Project.resources[_resource.idResource]);
            delete (Project.serialization[_resource.idResource]);
        }
        /**
         * Clears the list of resources and their serialization, thus removing all resources.
         */
        static clear() {
            Project.resources = {};
            Project.serialization = {};
            Project.clearScriptNamespaces();
            // Project.scriptNamespaces = {};
        }
        // <T extends Component>(_class: new () => T): T[] {
        //   return <T[]>(this.components[_class.name] || []).slice(0);
        // }
        /**
         * Returns an array of all resources of the requested type.
         */
        static getResourcesByType(_type) {
            let found = [];
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource instanceof _type)
                    found.push(resource);
            }
            return found;
        }
        /**
         * Returns an array of all resources with the requested name.
         */
        static getResourcesByName(_name) {
            let found = [];
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource.name == _name)
                    found.push(resource);
            }
            return found;
        }
        /**
         * Generate a user readable and unique id using the type of the resource, the date and random numbers
         * @param _resource
         */
        static generateId(_resource) {
            // TODO: build id and integrate info from resource, not just date
            let idResource;
            do
                idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
            while (Project.resources[idResource]);
            return idResource;
        }
        /**
         * Tests, if an object is a {@link SerializableResource}
         * @param _object The object to examine
         */
        static isResource(_object) {
            return (Reflect.has(_object, "idResource"));
        }
        /**
         * Retrieves the resource stored with the given id
         */
        static async getResource(_idResource) {
            let resource = Project.resources[_idResource];
            if (!resource) {
                let serialization = Project.serialization[_idResource];
                if (!serialization) {
                    FudgeCore.Debug.error("Resource not found", _idResource);
                    return null;
                }
                resource = await Project.deserializeResource(serialization);
            }
            return resource;
        }
        /**
         * Creates and registers a resource from a {@link Node}, copying the complete graph starting with it
         * @param _node A node to create the resource from
         * @param _replaceWithInstance if true (default), the node used as origin is replaced by a {@link GraphInstance} of the {@link Graph} created
         */
        static async registerAsGraph(_node, _replaceWithInstance = true) {
            let serialization = _node.serialize();
            let graph = new FudgeCore.Graph(_node.name);
            await graph.deserialize(serialization);
            Project.register(graph);
            if (_replaceWithInstance && _node.getParent()) {
                let instance = await Project.createGraphInstance(graph);
                _node.getParent().replaceChild(_node, instance);
            }
            return graph;
        }
        /**
         * Creates and returns a {@link GraphInstance} of the given {@link Graph}
         * and connects it to the graph for synchronisation of mutation.
         */
        static async createGraphInstance(_graph) {
            let instance = new FudgeCore.GraphInstance(_graph); // TODO: cleanup since creation moved here
            await instance.connectToGraph();
            return instance;
        }
        /**
         * Register the given {@link GraphInstance} to be resynced
         */
        static registerGraphInstanceForResync(_instance) {
            let instances = Project.graphInstancesToResync[_instance.idSource] || [];
            instances.push(_instance);
            Project.graphInstancesToResync[_instance.idSource] = instances;
        }
        /**
         * Resync all {@link GraphInstance} registered to the given {@link Graph}
         */
        static async resyncGraphInstances(_graph) {
            let instances = Project.graphInstancesToResync[_graph.idResource];
            if (!instances)
                return;
            for (let instance of instances)
                await instance.connectToGraph();
            delete (Project.graphInstancesToResync[_graph.idResource]);
        }
        /**
         * Register the given namespace to the list of script-namespaces.
         */
        static registerScriptNamespace(_namespace) {
            let name = FudgeCore.Serializer.registerNamespace(_namespace);
            if (!Project.scriptNamespaces[name])
                Project.scriptNamespaces[name] = _namespace;
        }
        /**
         * Clear the list of script-namespaces.
         */
        static clearScriptNamespaces() {
            for (let name in Project.scriptNamespaces) {
                Reflect.set(window, name, undefined);
                Project.scriptNamespaces[name] = undefined;
                delete Project.scriptNamespaces[name];
            }
        }
        /**
         * Collects all {@link ComponentScript}s registered in {@link Project.scriptNamespaces} and returns them.
         */
        static getComponentScripts() {
            let compoments = {};
            for (let namespace in Project.scriptNamespaces) {
                compoments[namespace] = [];
                for (let name in Project.scriptNamespaces[namespace]) {
                    let script = Reflect.get(Project.scriptNamespaces[namespace], name);
                    // Using Object.create doesn't call the constructor, but instanceof can be used. More elegant than the loop above, though maybe not as performant. 
                    try {
                        let o = Object.create(script);
                        if (o.prototype instanceof FudgeCore.ComponentScript)
                            compoments[namespace].push(script);
                    }
                    catch (_e) { /* */ }
                }
            }
            return compoments;
        }
        /**
         * Loads a script from the given URL and integrates it into a {@link HTMLScriptElement} in the {@link document.head}
         */
        static async loadScript(_url) {
            let script = document.createElement("script");
            script.type = "text/javascript";
            // script.type = "module";
            script.async = false;
            // script.addEventListener("load", handleLoadedScript)
            let head = document.head;
            head.appendChild(script);
            FudgeCore.Debug.log("Loading: ", _url);
            return new Promise((_resolve, _reject) => {
                script.addEventListener("load", () => _resolve());
                script.addEventListener("error", () => {
                    FudgeCore.Debug.error("Loading script", _url);
                    _reject();
                });
                script.src = _url.toString();
            });
        }
        /**
         * Load {@link Resources} from the given url
         */
        static async loadResources(_url) {
            const response = await fetch(_url);
            const resourceFileContent = await response.text();
            let serialization = FudgeCore.Serializer.parse(resourceFileContent);
            let reconstruction = await Project.deserialize(serialization);
            Project.dispatchEvent(new CustomEvent("resourcesLoaded" /* EVENT.RESOURCES_LOADED */, { detail: { url: _url, resources: reconstruction } }));
            return reconstruction;
        }
        /**
         * Load all resources from the {@link document.head}
         */
        static async loadResourcesFromHTML() {
            const head = document.head;
            let links = head.querySelectorAll("link[type=resources]");
            for (let link of links) {
                let url = link.getAttribute("src");
                await Project.loadResources(url);
            }
        }
        /**
         * Serialize all resources
         */
        static serialize() {
            let serialization = {};
            for (let idResource in Project.resources) {
                let resource = Project.resources[idResource];
                if (idResource != resource.idResource)
                    FudgeCore.Debug.error("Resource-id mismatch", resource);
                serialization[idResource] = FudgeCore.Serializer.serialize(resource);
            }
            return serialization;
        }
        /**
         * Create resources from a serialization, deleting all resources previously registered
         * @param _serialization
         */
        static async deserialize(_serialization) {
            Project.serialization = _serialization;
            Project.resources = {};
            for (let idResource in _serialization) {
                let serialization = _serialization[idResource];
                let resource = await Project.deserializeResource(serialization);
                if (resource)
                    Project.resources[idResource] = resource;
            }
            return Project.resources;
        }
        static async deserializeResource(_serialization) {
            return FudgeCore.Serializer.deserialize(_serialization);
        }
    }
    FudgeCore.Project = Project;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var FBX;
    (function (FBX) {
        /**
         * Reader to read data from an array buffer more conveniently.
         * It saves a current offset which is updated when data is read due to its bytelength.
         * despite getSequence it is mostly a copy of the reference: https://github.com/picode7/binary-reader
         * @author Matthias Roming, HFU, 2023
         */
        class BufferReader {
            constructor(_buffer) {
                this.view = new DataView(_buffer);
                this.offset = 0;
            }
            getChar(_offset = this.offset) {
                return String.fromCharCode(this.getUint8(_offset));
            }
            getBool(_offset = this.offset) {
                return this.getUint8(_offset) != 0;
            }
            getUint8(_offset = this.offset) {
                this.offset = _offset + 1;
                return this.view.getUint8(_offset);
            }
            getUint32(_offset = this.offset) {
                this.offset = _offset + 4;
                return this.view.getUint32(_offset, true);
            }
            getUint64(_offset = this.offset) {
                this.offset = _offset + 8;
                return this.view.getBigUint64(_offset, true);
            }
            getInt16(_offset = this.offset) {
                this.offset = _offset + 2;
                return this.view.getInt16(_offset, true);
            }
            getInt32(_offset = this.offset) {
                this.offset = _offset + 4;
                return this.view.getInt32(_offset, true);
            }
            getInt64(_offset = this.offset) {
                this.offset = _offset + 8;
                return this.view.getBigInt64(_offset, true);
            }
            getFloat32(_offset = this.offset) {
                this.offset = _offset + 4;
                return this.view.getFloat32(_offset, true);
            }
            getFloat64(_offset = this.offset) {
                this.offset = _offset + 8;
                return this.view.getFloat64(_offset, true);
            }
            getString(_length, _offset = this.offset) {
                return String.fromCharCode(...this.getSequence(this.getUint8, _length, _offset));
            }
            *getSequence(_getter, _length, _offset = this.offset) {
                this.offset = _offset;
                for (let i = 0; i < _length; i++) {
                    yield _getter.call(this);
                }
            }
        }
        FBX.BufferReader = BufferReader;
    })(FBX = FudgeCore.FBX || (FudgeCore.FBX = {}));
})(FudgeCore || (FudgeCore = {}));
/** @ignore currently not working */
var FudgeCore;
/** @ignore currently not working */
(function (FudgeCore) {
    var FBX;
    (function (FBX) {
        let MAPPING_INFORMATION_TYPE;
        (function (MAPPING_INFORMATION_TYPE) {
            MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_VERTEX"] = 0] = "BY_VERTEX";
            MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_POLYGON"] = 1] = "BY_POLYGON";
            MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_POLYGON_VERTEX"] = 2] = "BY_POLYGON_VERTEX";
            MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_EDGE"] = 3] = "BY_EDGE";
            MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["ALL_SAME"] = 4] = "ALL_SAME";
        })(MAPPING_INFORMATION_TYPE = FBX.MAPPING_INFORMATION_TYPE || (FBX.MAPPING_INFORMATION_TYPE = {}));
        let REFERENCE_INFORMATION_TYPE;
        (function (REFERENCE_INFORMATION_TYPE) {
            REFERENCE_INFORMATION_TYPE[REFERENCE_INFORMATION_TYPE["DIRECT"] = 0] = "DIRECT";
            REFERENCE_INFORMATION_TYPE[REFERENCE_INFORMATION_TYPE["INDEX_TO_DIRECT"] = 1] = "INDEX_TO_DIRECT";
        })(REFERENCE_INFORMATION_TYPE = FBX.REFERENCE_INFORMATION_TYPE || (FBX.REFERENCE_INFORMATION_TYPE = {}));
    })(FBX = FudgeCore.FBX || (FudgeCore.FBX = {}));
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Asset loader for Filmbox files.
     * @author Matthias Roming, HFU, 2023
     * @ignore currently not working
     */
    class FBXLoader {
        static #defaultMaterial;
        static #defaultSkinMaterial;
        #scenes;
        #nodes;
        #meshes;
        #materials;
        #skinMaterials = [];
        #textures;
        #skeletons;
        #animations;
        constructor(_buffer, _uri) {
            this.uri = _uri;
            this.nodes = FudgeCore.FBX.parseNodesFromBinary(_buffer);
            console.log(this.nodes);
            this.fbx = FudgeCore.FBX.loadFromNodes(this.nodes);
            console.log(this.fbx);
        }
        static get defaultMaterial() {
            return this.#defaultMaterial || (this.#defaultMaterial =
                new FudgeCore.Material("FBXDefaultMaterial", FudgeCore.ShaderGouraud, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"))));
        }
        static get defaultSkinMaterial() {
            return this.#defaultSkinMaterial || (this.#defaultSkinMaterial =
                new FudgeCore.Material("FBXDefaultSkinMaterial", FudgeCore.ShaderGouraudSkin, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"))));
        }
        static async LOAD(_uri) {
            if (!this.loaders)
                this.loaders = {};
            if (!this.loaders[_uri]) {
                const response = await fetch(_uri);
                const binary = await response.arrayBuffer();
                this.loaders[_uri] = new FBXLoader(binary, _uri);
            }
            return this.loaders[_uri];
        }
        async getScene(_index = 0) {
            if (!this.#scenes)
                this.#scenes = [];
            if (!this.#scenes[_index]) {
                const documentFBX = this.fbx.documents[_index].load();
                const scene = new FudgeCore.Graph(documentFBX.name);
                for (const childFBX of documentFBX.children) {
                    if (childFBX.type == "Model") {
                        scene.addChild(await this.getNode(this.fbx.objects.models.indexOf(childFBX)));
                    }
                }
                if (this.fbx.objects.animStacks && this.fbx.objects.animStacks.length > 0) {
                    const animation = await this.getAnimation(documentFBX.ActiveAnimStackName.length > 0 ?
                        this.fbx.objects.animStacks.findIndex(_animStack => _animStack.name == documentFBX.ActiveAnimStackName) : 0);
                    if (animation)
                        scene.addComponent(new FudgeCore.ComponentAnimator(animation));
                }
                for (const skeleton of this.#skeletons)
                    scene.addComponent(skeleton);
                FudgeCore.Project.register(scene);
                this.#scenes[_index] = scene;
            }
            return this.#scenes[_index];
        }
        async getNode(_index) {
            if (!this.#nodes)
                this.#nodes = [];
            if (!this.#nodes[_index]) {
                // create node with transform
                const modelFBX = this.fbx.objects.models[_index].load();
                const node = new FudgeCore.Node(modelFBX.name);
                await this.generateTransform(modelFBX, node);
                this.#nodes[_index] = node;
                // attach children and components
                if (modelFBX.children)
                    for (const childFBX of modelFBX.children) {
                        if (childFBX.type == "Model") {
                            node.addChild(await this.getNode(this.fbx.objects.models.indexOf(childFBX)));
                        }
                        else if (childFBX.type == "Geometry") {
                            const mesh = await this.getMesh(this.fbx.objects.geometries.indexOf(childFBX));
                            const cmpMesh = new FudgeCore.ComponentMesh(mesh);
                            node.addComponent(new FudgeCore.ComponentMaterial(FBXLoader.defaultMaterial));
                            if (mesh instanceof FudgeCore.MeshSkin) {
                                cmpMesh.skeleton = await this.getSkeleton(childFBX.children[0].children[0].children[0]);
                                // for (const subDeformerFBX of childFBX.children[0].children as FBX.SubDeformer[]) {
                                //   const bone: Node = cmpMesh.skeleton.bones[subDeformerFBX.children[0].name];
                                //   bone.mtxLocal.set(subDeformerFBX.TransformLink);
                                //   if (bone.getParent())
                                //     bone.mtxLocal.multiply(bone.getParent().mtxWorldInverse);
                                // }
                                node.getComponent(FudgeCore.ComponentMaterial).material = FBXLoader.defaultSkinMaterial;
                            }
                            node.addComponent(cmpMesh);
                        }
                        else if (childFBX.type == "Material") {
                            // TODO: additional skin materials get created here, check if the original material is still needed
                            const iMaterial = this.fbx.objects.materials.indexOf(childFBX);
                            const material = await this.getMaterial(iMaterial);
                            node.getComponent(FudgeCore.ComponentMaterial).material = node.getComponent(FudgeCore.ComponentMesh).mesh instanceof FudgeCore.MeshSkin ?
                                this.#skinMaterials[iMaterial] || (this.#skinMaterials[iMaterial] = new FudgeCore.Material(material.name, material.getShader() == FudgeCore.ShaderPhong ?
                                    FudgeCore.ShaderPhongSkin :
                                    FudgeCore.ShaderPhongTexturedSkin, material.coat)) :
                                material;
                        }
                    }
            }
            return this.#nodes[_index];
        }
        async getMesh(_index) {
            if (!this.#meshes)
                this.#meshes = [];
            if (!this.#meshes[_index])
                this.#meshes[_index] = await (this.fbx.objects.geometries[_index].children?.[0].type == "Deformer" ?
                    new FudgeCore.MeshSkin() :
                    new FudgeCore.MeshImport()).load(FudgeCore.MeshLoaderFBX, this.uri, this.fbx.objects.geometries[_index]);
            return this.#meshes[_index];
        }
        async getMaterial(_index) {
            if (!this.#materials)
                this.#materials = [];
            if (!this.#materials[_index]) {
                const materialFBX = this.fbx.objects.materials[_index].load();
                if (!(materialFBX.DiffuseColor instanceof FudgeCore.Vector3))
                    materialFBX.DiffuseColor?.children[0].load();
                // FBX supports lambert and phong shading, either way fudge has no lambert shader so we always use phong.
                // In DiffuseColor the texture of the material color is stored, if it's defined we use a texture shader.
                // TODO: materialFBX also contains additional values like shininess and reflectivity (and others) which are not suppported.
                this.#materials[_index] = new FudgeCore.Material(materialFBX.name, materialFBX.DiffuseColor && !(materialFBX.DiffuseColor instanceof FudgeCore.Vector3) ?
                    FudgeCore.ShaderPhongTextured :
                    FudgeCore.ShaderPhong, materialFBX.DiffuseColor && !(materialFBX.DiffuseColor instanceof FudgeCore.Vector3) ?
                    new FudgeCore.CoatRemissiveTextured(new FudgeCore.Color(...materialFBX.Diffuse.get()), await this.getTexture(this.fbx.objects.textures.indexOf(materialFBX.DiffuseColor)), materialFBX.DiffuseFactor ?? 1, materialFBX.SpecularFactor ?? average(materialFBX.Specular?.get()) ?? 0) :
                    new FudgeCore.CoatRemissive(new FudgeCore.Color(...(materialFBX.DiffuseColor ?? materialFBX.Diffuse).get()), materialFBX.DiffuseFactor ?? 1, materialFBX.SpecularFactor ?? average(materialFBX.Specular?.get()) ?? 0));
            }
            return this.#materials[_index];
            function average(_array) {
                if (_array)
                    return _array.reduce((_a, _b) => _a + _b) / _array.length;
                else
                    return undefined;
            }
        }
        async getTexture(_index) {
            return new Promise((_resolve, _reject) => {
                if (!this.#textures)
                    this.#textures = [];
                if (this.#textures[_index])
                    return _resolve(this.#textures[_index]);
                const videoFBX = this.fbx.objects.textures[_index].children[0];
                const texture = new FudgeCore.TextureImage();
                texture.image = new Image();
                texture.image.onload = () => _resolve(texture);
                texture.image.onerror = _reject;
                texture.image.src = URL.createObjectURL(new Blob([videoFBX.Content], { type: "image/png" }));
                this.#textures[_index] = texture;
                // TODO: get and set mipmap information ???
            });
        }
        // Problem: mehrere Deformer verweisen auf das selbe Skelett aber nutzen dabei nicht immer alle Knochen
        // => Problem besteht auch im GLTFLoader
        /**
         * Retriefs the skeleton containing the given limb node.
         */
        async getSkeleton(_fbxLimbNode) {
            if (!this.#skeletons)
                this.#skeletons = [];
            return this.#skeletons.find(_skeleton => _fbxLimbNode.name in _skeleton.bones) || await (async () => {
                const skeleton = new FudgeCore.ComponentSkeleton(); // new Skeleton(`Skeleton${this.#skeletons.length}`);
                let rootNode = _fbxLimbNode;
                while (rootNode.parents && rootNode.parents.some(_parent => _parent.subtype == "LimbNode"))
                    rootNode = rootNode.parents.find(_parent => _parent.subtype == "LimbNode");
                const iRootNode = this.fbx.objects.models.findIndex(_model => _model.name == rootNode.name);
                for (const node of await this.getNode(iRootNode)) {
                    // TODO: maybe move this into the component, as this is probably needed in gltf import aswell
                    if (this.fbx.objects.models[this.#nodes.indexOf(node)].subtype == "LimbNode") {
                        node.mtxWorld.set(node.cmpTransform ?
                            FudgeCore.Matrix4x4.MULTIPLICATION(node.getParent().mtxWorld, node.mtxLocal) :
                            node.getParent().mtxWorld);
                        node.mtxWorldInverse.set(FudgeCore.Matrix4x4.INVERSION(node.mtxWorld));
                        skeleton.addBone(node);
                    }
                }
                this.#skeletons.push(skeleton);
                return skeleton;
            })();
        }
        async getAnimation(_index) {
            if (!this.#animations)
                this.#animations = [];
            if (!this.#animations[_index]) {
                const animStack = this.fbx.objects.animStacks[_index];
                const animNodesFBX = animStack.children[0].children;
                let fbxAnimNodeGrouped = new Map();
                for (const fbxAnimNode of animNodesFBX) {
                    const key = fbxAnimNode.parents.find(_parent => _parent.type == "Model");
                    if (key == undefined)
                        continue;
                    if (!fbxAnimNodeGrouped.has(key))
                        fbxAnimNodeGrouped.set(key, []);
                    fbxAnimNodeGrouped.get(key).push(fbxAnimNode);
                }
                const animationStructure = {};
                for (const [fbxModel, fbxAnimNodes] of fbxAnimNodeGrouped) {
                    let currentStructure = animationStructure;
                    let parent = fbxModel.parents.find(_parent => _parent.type == "Model");
                    let path = [];
                    path.push(fbxModel);
                    while (parent != undefined) {
                        path.push(parent);
                        parent = parent.parents.find(_parent => _parent.type == "Model");
                    }
                    for (const fbxPathModel of path.reverse()) {
                        if (currentStructure.children == undefined)
                            currentStructure.children = {};
                        if (currentStructure.children[fbxPathModel.name] == undefined)
                            currentStructure.children[fbxPathModel.name] = {};
                        currentStructure = currentStructure.children[fbxPathModel.name];
                        if (fbxPathModel == fbxModel) {
                            const mtxLocal = {};
                            for (const fbxAnimNode of fbxAnimNodes)
                                mtxLocal[{
                                    T: "translation",
                                    R: "rotation",
                                    S: "scale"
                                }[fbxAnimNode.name]] = this.getAnimationVector3(fbxAnimNode, fbxPathModel);
                            currentStructure.components = {
                                ComponentTransform: [
                                    { mtxLocal: mtxLocal }
                                ]
                            };
                        }
                    }
                }
                this.#animations[_index] = new FudgeCore.Animation(animStack.name, animationStructure);
            }
            return this.#animations[_index];
        }
        /**
         * fetched from three.js, adapted to FUDGE and optimized
         * https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/FBXLoader.js
         * line 3950
         */
        async generateTransform(_modelFBX, _node) {
            const parentIndex = this.fbx.objects.models.indexOf(_modelFBX.parents.find(_parent => _parent.type == "Model"));
            const parent = parentIndex >= 0 ? await this.getNode(parentIndex) : undefined;
            const mtxLocalRotation = _modelFBX.PreRotation || _modelFBX.LclRotation || _modelFBX.PostRotation ?
                FudgeCore.Matrix4x4.IDENTITY() :
                undefined;
            if (_modelFBX.PreRotation) {
                mtxLocalRotation.rotate(this.getOrdered(_modelFBX.PreRotation, _modelFBX));
            }
            if (_modelFBX.LclRotation) {
                mtxLocalRotation.rotate(this.getOrdered(this.getTransformVector(_modelFBX.LclRotation, FudgeCore.Vector3.ZERO), _modelFBX));
            }
            if (_modelFBX.PostRotation) {
                let mtxPostRotationInverse = FudgeCore.Matrix4x4.ROTATION(this.getOrdered(_modelFBX.PostRotation, _modelFBX));
                mtxPostRotationInverse = FudgeCore.Matrix4x4.INVERSION(mtxPostRotationInverse);
                mtxLocalRotation.multiply(mtxPostRotationInverse);
            }
            const mtxLocalScaling = _modelFBX.LclScaling ?
                FudgeCore.Matrix4x4.SCALING(this.getTransformVector(_modelFBX.LclScaling, FudgeCore.Vector3.ONE)) :
                undefined;
            const mtxParentWorldRotation = parent ? FudgeCore.Matrix4x4.ROTATION(parent.mtxWorld.rotation) : undefined;
            const mtxParentWorldScale = parent ? (() => {
                const mtxParentWorldScale = FudgeCore.Matrix4x4.INVERSION(mtxParentWorldRotation);
                mtxParentWorldScale.translate(FudgeCore.Vector3.SCALE(parent.mtxWorld.translation, -1));
                mtxParentWorldScale.multiply(parent.mtxWorld);
                return mtxParentWorldScale;
            })() : undefined;
            const mtxWorldRotationScale = parent || mtxLocalRotation || mtxLocalScaling ? FudgeCore.Matrix4x4.IDENTITY() : undefined;
            if (parent || mtxLocalRotation || mtxLocalScaling) {
                const inheritType = _modelFBX.InheritType || 0;
                if (inheritType == 0) {
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
                else if (inheritType == 1) {
                    if (parent) {
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                    }
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
                else {
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (parent) {
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                        let mtxParentLocalScalingInverse = FudgeCore.Matrix4x4.SCALING(parent.mtxLocal.scaling);
                        mtxParentLocalScalingInverse = FudgeCore.Matrix4x4.INVERSION(mtxParentLocalScalingInverse);
                        mtxWorldRotationScale.multiply(mtxParentLocalScalingInverse);
                    }
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
            }
            // Calculate the local transform matrix
            let translation;
            translation = FudgeCore.Vector3.ZERO();
            if (_modelFBX.LclTranslation)
                translation.add(this.getTransformVector(_modelFBX.LclTranslation, FudgeCore.Vector3.ZERO));
            if (_modelFBX.RotationOffset)
                translation.add(_modelFBX.RotationOffset);
            if (_modelFBX.RotationPivot)
                translation.add(_modelFBX.RotationPivot);
            const mtxTransform = FudgeCore.Matrix4x4.TRANSLATION(translation);
            if (mtxLocalRotation)
                mtxTransform.multiply(mtxLocalRotation);
            translation = FudgeCore.Vector3.ZERO();
            if (_modelFBX.RotationPivot)
                translation.subtract(_modelFBX.RotationPivot);
            if (_modelFBX.ScalingOffset)
                translation.add(_modelFBX.ScalingOffset);
            if (_modelFBX.ScalingPivot)
                translation.add(_modelFBX.ScalingPivot);
            mtxTransform.translate(translation);
            if (mtxLocalScaling)
                mtxTransform.multiply(mtxLocalScaling);
            if (_modelFBX.ScalingPivot)
                mtxTransform.translate(FudgeCore.Vector3.SCALE(_modelFBX.ScalingPivot, -1));
            const mtxWorldTranslation = parent ?
                FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Matrix4x4.MULTIPLICATION(parent.mtxWorld, FudgeCore.Matrix4x4.TRANSLATION(mtxTransform.translation)).translation) :
                FudgeCore.Matrix4x4.TRANSLATION(mtxTransform.translation);
            mtxTransform.set(mtxWorldTranslation);
            mtxTransform.multiply(mtxWorldRotationScale);
            _node.mtxWorld.set(mtxTransform);
            if (parent)
                mtxTransform.multiply(FudgeCore.Matrix4x4.INVERSION(parent.mtxWorld), true);
            _node.addComponent(new FudgeCore.ComponentTransform(mtxTransform));
        }
        getTransformVector(_vector, _default) {
            return (_vector == undefined ?
                _default() :
                _vector instanceof FudgeCore.Vector3 ?
                    _vector :
                    new FudgeCore.Vector3(typeof (_vector = _vector.load()).dX == "number" ?
                        _vector.dX :
                        _vector.dX.load().Default, typeof _vector.dY == "number" ?
                        _vector.dY :
                        _vector.dY.load().Default, typeof _vector.dZ == "number" ?
                        _vector.dZ :
                        _vector.dZ.load().Default));
        }
        getAnimationVector3(_animNode, _target) {
            const vectorSequence = {};
            for (const valueName in _animNode)
                if (valueName == "dX" || valueName == "dY" || valueName == "dZ") {
                    const value = _animNode[valueName];
                    if (typeof value != "number") {
                        const sequence = new FudgeCore.AnimationSequence();
                        for (let i = 0; i < value.KeyTime.length; ++i) {
                            // According to the reference time is defined as a signed int64, unit being 1/46186158000 seconds
                            // ref: https://archive.blender.org/wiki/index.php/User:Mont29/Foundation/FBX_File_Structure/#Some_Specific_Property_Types
                            sequence.addKey(new FudgeCore.AnimationKey(Number((value.KeyTime[i] - value.KeyTime.reduce((_min, _v) => _v < _min ? _v : _min)) / BigInt("46186158")), value.KeyValueFloat[i]));
                        }
                        vectorSequence[valueName[1].toLowerCase()] = sequence;
                    }
                }
            if (_animNode.name == "R" && (_target.PreRotation || _target.PostRotation)) {
                let preRototation;
                if (_target.PreRotation)
                    preRototation = FudgeCore.Matrix4x4.ROTATION(_target.PreRotation);
                let postRotation;
                if (_target.PostRotation)
                    postRotation = FudgeCore.Matrix4x4.ROTATION(_target.PostRotation);
                [vectorSequence.x, vectorSequence.y, vectorSequence.z]
                    .flatMap(_seq => _seq?.getKeys())
                    .map(_key => _key?.time)
                    .sort((_timeA, _timeB) => _timeA - _timeB) // sort times
                    .filter((_time, _index, _times) => _time != _times[_index + 1]) // remove duplicates
                    .map(_time => {
                    return { x: findKey(vectorSequence.x), y: findKey(vectorSequence.y), z: findKey(vectorSequence.z) };
                    function findKey(_sequence) {
                        return _sequence?.getKeys().find(_key => _key.time == _time);
                    }
                })
                    .forEach(_frame => {
                    let vctEulerAngles = FudgeCore.Recycler.get(FudgeCore.Vector3);
                    vctEulerAngles.set(_frame.x?.value ?? 0, _frame.y?.value ?? 0, _frame.z?.value ?? 0);
                    const mtxRotation = FudgeCore.Matrix4x4.ROTATION(vctEulerAngles);
                    if (preRototation)
                        mtxRotation.multiply(preRototation, true);
                    if (postRotation)
                        mtxRotation.multiply(postRotation);
                    vctEulerAngles = mtxRotation.rotation;
                    if (_frame.x)
                        _frame.x.value = vctEulerAngles.x;
                    if (_frame.y)
                        _frame.y.value = vctEulerAngles.y;
                    if (_frame.z)
                        _frame.z.value = vctEulerAngles.z;
                });
            }
            return vectorSequence;
        }
        getOrdered(_rotation, _modelFBX) {
            if (!_modelFBX.EulerOrder)
                return _rotation;
            const data = _rotation.get();
            const result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(data[_modelFBX.EulerOrder.indexOf("Z")], data[_modelFBX.EulerOrder.indexOf("Y")], data[_modelFBX.EulerOrder.indexOf("X")]);
            return result;
        }
    }
    FudgeCore.FBXLoader = FBXLoader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var FBX;
    (function (FBX) {
        /**
         * Interface to represent fbx-nodes containing its name, children and properties.
         * Children and properites are lazy.
         * @author Matthias Roming, HFU, 2023
         */
        class Node {
            #children;
            #properties;
            constructor(_name, _loadProperties, _loadChildren) {
                this.name = _name;
                this.loadProperties = _loadProperties;
                this.loadChildren = _loadChildren;
            }
            get properties() {
                return this.#properties || (this.#properties = this.loadProperties());
            }
            get children() {
                return this.#children || (this.#children = this.loadChildren());
            }
        }
        FBX.Node = Node;
        let ARRAY_ENCODING;
        (function (ARRAY_ENCODING) {
            ARRAY_ENCODING[ARRAY_ENCODING["UNCOMPRESSED"] = 0] = "UNCOMPRESSED";
            ARRAY_ENCODING[ARRAY_ENCODING["COMPRESSED"] = 1] = "COMPRESSED";
        })(ARRAY_ENCODING = FBX.ARRAY_ENCODING || (FBX.ARRAY_ENCODING = {}));
    })(FBX = FudgeCore.FBX || (FudgeCore.FBX = {}));
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var FBX;
    (function (FBX) {
        /**
         * Loads an fbx file from its fbx-node array which may be retrieved by parseNodesFromBinary.
         * @author Matthias Roming, HFU, 2023
         */
        function loadFromNodes(_nodes) {
            const fbx = {
                documents: undefined,
                objects: {
                    all: undefined,
                    models: [],
                    geometries: [],
                    materials: [],
                    poses: [],
                    textures: [],
                    animStacks: []
                },
                connections: undefined
            };
            for (const node of _nodes) {
                if (node.name == "Documents")
                    fbx.documents = node.children
                        .filter(_documentNode => _documentNode.name == "Document")
                        .map(_documentNode => getDocument(_documentNode));
                else if (node.name == "Objects")
                    fbx.objects.all = node.children.map(_objectNode => getObject(_objectNode, fbx));
                else if (node.name == "Connections")
                    fbx.connections = node.children.map(_connectionNode => getConnection(_connectionNode));
                if (fbx.documents && fbx.objects.all && fbx.connections)
                    break;
            }
            groupObjects(fbx);
            applyConnections(fbx.connections, fbx.documents, fbx.objects.all);
            return fbx;
        }
        FBX.loadFromNodes = loadFromNodes;
        function getDocument(_node) {
            const document = {
                uid: _node.properties[0],
                name: _node.properties[2],
                loaded: false,
                load: () => loadObjectProperties(_node, document)
            };
            return document;
        }
        function getObject(_node, _fbx) {
            const nameAndType = _node.properties[1].split("::");
            const object = {
                uid: _node.properties[0],
                name: nameAndType[0],
                type: nameAndType[1],
                subtype: _node.properties[2],
                loaded: false,
                load: () => loadObjectProperties(_node, object)
            };
            return object;
        }
        function groupObjects(_fbx) {
            for (const object of _fbx.objects.all) {
                if (object.type == "Model")
                    _fbx.objects.models.push(object);
                else if (object.type == "Geometry")
                    _fbx.objects.geometries.push(object);
                else if (object.type == "Material")
                    _fbx.objects.materials.push(object);
                else if (object.type == "Pose")
                    _fbx.objects.poses.push(object);
                else if (object.type == "Texture")
                    _fbx.objects.textures.push(object);
                else if (object.type == "AnimStack")
                    _fbx.objects.animStacks.push(object);
            }
        }
        function getConnection(_node) {
            if (!(_node.properties[0] == "OO" || _node.properties[0] == "OP")) {
                console.warn(`Connection type ${_node.properties[0]} is not supported`);
                return null;
            }
            return {
                childUID: _node.properties[1],
                parentUID: _node.properties[2],
                propertyName: _node.properties[0] == "OP" ? _node.properties[3] : null
            };
        }
        function applyConnections(_connections, _documents, _objects) {
            for (const connection of _connections) {
                let parent = _documents.find(_document => _document.load().RootNode == connection.parentUID);
                let child;
                for (const object of _objects) {
                    if (parent == undefined && object.uid == connection.parentUID)
                        parent = object;
                    if (child == undefined && object.uid == connection.childUID)
                        child = object;
                    if (parent != undefined && child != undefined)
                        break;
                }
                if (child)
                    (child.parents || (child.parents = [])).push(parent);
                if (connection.propertyName == null)
                    (parent.children || (parent.children = [])).push(child);
                else
                    parent[formatPropertyName(connection.propertyName)] = child;
            }
        }
        function loadObjectProperties(_node, _object) {
            if (_object.loaded)
                return _object;
            for (const child of _node.children) {
                if (child.name == "Properties70")
                    for (const property70 of child.children) {
                        const name = formatPropertyName(property70.properties[0]);
                        if (!_object[name])
                            _object[name] = getProperty70Value(property70);
                    }
                else {
                    const name = formatPropertyName(child.name);
                    if (!_object[name])
                        _object[name] = getPropertyValue(child);
                }
            }
            _object.loaded = true;
            return _object;
        }
        function getPropertyValue(_node) {
            return _node.children.length > 0
                ? _node.children.reduce((_subProperties, _subProperty) => {
                    const name = formatPropertyName(_subProperty.name);
                    if (_subProperties[name] == undefined)
                        _subProperties[name] = getPropertyValue(_subProperty);
                    else {
                        if (!(_subProperties[name] instanceof Array))
                            _subProperties[name] = [_subProperties[name]];
                        _subProperties[name].push(getPropertyValue(_subProperty));
                    }
                    return _subProperties;
                }, {})
                : _node.properties[0];
        }
        function getProperty70Value(_node) {
            switch (_node.properties[1]) {
                case "bool":
                    return _node.properties[4];
                case "int":
                case "enum":
                case "ULongLong":
                case "double":
                case "Number":
                case "FieldOfView":
                    return _node.properties[4];
                case "Color":
                case "ColorRGB":
                case "Vector3D":
                case "Lcl Translation":
                case "Lcl Rotation":
                case "Lcl Scaling":
                    return new FudgeCore.Vector3(..._node.properties.slice(4, 7));
                case "KString":
                default:
                    return _node.properties[4];
            }
        }
        function formatPropertyName(_name) {
            return _name.replace(/[^a-zA-Z]/, "");
        }
    })(FBX = FudgeCore.FBX || (FudgeCore.FBX = {}));
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var FBX;
    (function (FBX) {
        /**
         * Parses fbx-nodes array from a binary fbx-file.
         * despite the lazy node implementation it is mostly a copy of the reference: https://github.com/picode7/fbx-parser
         * @author Matthias Roming, HFU, 2023
         */
        function parseNodesFromBinary(_buffer) {
            if (_buffer.byteLength < binaryStartChars.length)
                throw "Not a binary FBX file";
            const data = new FBX.BufferReader(_buffer);
            const firstChars = new Uint8Array(data.getSequence(data.getUint8, binaryStartChars.length));
            const matchesFBXBinaryFirstChars = firstChars.every((_value, _index) => _value == binaryStartChars[_index]);
            if (!matchesFBXBinaryFirstChars)
                throw "Not a binary FBX file";
            const version = data.getUint32();
            const nodeAttributesAsUInt64 = version >= 7500; // Warum >= 7500?
            const nodes = [];
            while (true) {
                const node = readNode(data, nodeAttributesAsUInt64);
                if (node == null)
                    break;
                nodes.push(node);
            }
            return nodes;
        }
        FBX.parseNodesFromBinary = parseNodesFromBinary;
        function readNode(_data, _attributesAsUint64) {
            const endOffset = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
            if (endOffset == 0)
                return null;
            const propertiesLength = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
            const propertiesByteLength = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
            const nameLength = _data.getUint8();
            const name = _data.getString(nameLength);
            const propertiesOffset = _data.offset;
            const childrenOffset = propertiesOffset + propertiesByteLength;
            const node = new FBX.Node(name, () => {
                _data.offset = propertiesOffset;
                const properties = [];
                for (let iProperty = 0; iProperty < propertiesLength; iProperty++) {
                    properties.push(readProperty(_data));
                }
                return properties;
            }, () => {
                _data.offset = childrenOffset;
                const children = [];
                while (endOffset - _data.offset > nullCountAtNodeEnd) {
                    const child = readNode(_data, _attributesAsUint64);
                    if (child)
                        children.push(child);
                }
                return children;
            });
            _data.offset = endOffset;
            return node;
        }
        function readProperty(_data) {
            const typeCode = _data.getChar();
            const value = {
                C: _data.getBool,
                Y: _data.getInt16,
                I: _data.getInt32,
                L: _data.getInt64,
                F: _data.getFloat32,
                D: _data.getFloat64,
                S: () => _data.getString(_data.getUint32()).replace("\x00\x01", "::"),
                s: () => _data.getString(_data.getUint32()).replace("\x00\x01", "::"),
                R: () => new Uint8Array(readRaw(_data, _data.getUint8)),
                r: () => new Uint8Array(readArray(_data, _data.getUint8)),
                b: () => new Uint8Array(readArray(_data, _data.getUint8)),
                i: () => new Int32Array(readArray(_data, _data.getInt32)),
                l: () => new BigInt64Array(readArray(_data, _data.getInt64)),
                f: () => new Float32Array(readArray(_data, _data.getFloat32)),
                d: () => new Float32Array(readArray(_data, _data.getFloat64))
            }[typeCode]?.call(_data);
            if (value == null)
                FudgeCore.Debug.warn(`Unknown property type ${typeCode.charCodeAt(0)}`);
            return value;
        }
        function readArray(_data, _getter) {
            const length = _data.getUint32();
            const encoding = _data.getUint32();
            const byteLength = _data.getUint32();
            const endOffset = _data.offset + byteLength;
            const iterable = encoding == FBX.ARRAY_ENCODING.COMPRESSED ?
                (() => {
                    const arrayData = new Uint8Array(_data.view.buffer, _data.offset, byteLength);
                    const inflatedData = (Reflect.get(globalThis, "pako") ? pako.inflate : fflate.inflateSync)(arrayData);
                    return new FBX.BufferReader(inflatedData.buffer).getSequence(_getter, length);
                })() :
                _data.getSequence(_getter, length);
            _data.offset = endOffset;
            return iterable;
        }
        function readRaw(_data, _getter) {
            // raw binary data needs to be interpreted in a special way see:
            // https://code.blender.org/2013/08/fbx-binary-file-format-specification/
            const length = _data.getUint32();
            return _data.getSequence(_getter, length);
            ;
        }
        const binaryStartChars = Uint8Array.from("Kaydara FBX Binary\x20\x20\x00\x1a\x00".split(""), _v => _v.charCodeAt(0));
        const nullCountAtNodeEnd = 13;
    })(FBX = FudgeCore.FBX || (FudgeCore.FBX = {}));
})(FudgeCore || (FudgeCore = {}));
var GLTF;
(function (GLTF) {
    /**
     * https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#accessor-data-types
     */
    let COMPONENT_TYPE;
    (function (COMPONENT_TYPE) {
        COMPONENT_TYPE[COMPONENT_TYPE["BYTE"] = 5120] = "BYTE";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        COMPONENT_TYPE[COMPONENT_TYPE["SHORT"] = 5122] = "SHORT";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        COMPONENT_TYPE[COMPONENT_TYPE["FLOAT"] = 5126] = "FLOAT";
    })(COMPONENT_TYPE = GLTF.COMPONENT_TYPE || (GLTF.COMPONENT_TYPE = {}));
    let ACCESSOR_TYPE;
    (function (ACCESSOR_TYPE) {
        ACCESSOR_TYPE["SCALAR"] = "SCALAR";
        ACCESSOR_TYPE["VEC2"] = "VEC2";
        ACCESSOR_TYPE["VEC3"] = "VEC3";
        ACCESSOR_TYPE["VEC4"] = "VEC4";
        ACCESSOR_TYPE["MAT2"] = "MAT2";
        ACCESSOR_TYPE["MAT3"] = "MAT3";
        ACCESSOR_TYPE["MAT4"] = "MAT4";
    })(ACCESSOR_TYPE = GLTF.ACCESSOR_TYPE || (GLTF.ACCESSOR_TYPE = {}));
    let MESH_PRIMITIVE_MODE;
    (function (MESH_PRIMITIVE_MODE) {
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["POINTS"] = 0] = "POINTS";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINES"] = 1] = "LINES";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINE_LOOP"] = 2] = "LINE_LOOP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINE_STRIP"] = 3] = "LINE_STRIP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLES"] = 4] = "TRIANGLES";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(MESH_PRIMITIVE_MODE = GLTF.MESH_PRIMITIVE_MODE || (GLTF.MESH_PRIMITIVE_MODE = {}));
})(GLTF || (GLTF = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Asset loader for gl Transfer Format files.
     * @authors Matthias Roming, HFU, 2022 | Jonas Plotzky, HFU, 2023
     */
    class GLTFLoader {
        static #defaultMaterial;
        static #defaultSkinMaterial;
        #scenes;
        #nodes = [];
        #cameras;
        #animations;
        #meshes;
        #materials;
        #skeletons;
        #textures;
        #buffers;
        constructor(_gltf, _url) {
            this.gltf = _gltf;
            this.url = _url;
        }
        static get defaultMaterial() {
            if (!this.#defaultMaterial)
                this.#defaultMaterial = new FudgeCore.Material("GLTFDefaultMaterial", FudgeCore.ShaderPhong, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"), 1, 0.5));
            return this.#defaultMaterial;
        }
        static get defaultSkinMaterial() {
            if (!this.#defaultSkinMaterial)
                this.#defaultSkinMaterial = new FudgeCore.Material("GLTFDefaultSkinMaterial", FudgeCore.ShaderPhongSkin, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"), 1, 0.5));
            return this.#defaultSkinMaterial;
        }
        /**
         * Returns a {@link GLTFLoader} instance for the given url.
         */
        static async LOAD(_url) {
            const url = new URL(_url, FudgeCore.Project.baseURL).toString();
            if (!this.loaders)
                GLTFLoader.loaders = {};
            if (!this.loaders[url]) {
                const response = await fetch(url);
                const gltf = await response.json();
                GLTFLoader.checkCompatibility(gltf, url);
                GLTFLoader.preProcess(gltf, url);
                GLTFLoader.loaders[url] = new GLTFLoader(gltf, url);
            }
            return GLTFLoader.loaders[url];
        }
        static checkCompatibility(_gltf, _url) {
            if (_gltf.asset.version != "2.0")
                FudgeCore.Debug.warn(`${GLTFLoader.name} | ${_url}: This loader was developed for glTF 2.0. It may not work as intended with version ${_gltf.asset.version}.`);
            if (_gltf.asset.minVersion != undefined && _gltf.asset.minVersion != "2.0")
                throw new Error(`${GLTFLoader.name} | ${_url}: This loader was developed for glTF 2.0. It does not work with required min version ${_gltf.asset.minVersion}.`);
            if (_gltf.extensionsUsed?.length > 0)
                FudgeCore.Debug.warn(`${GLTFLoader.name} | ${_url}: This loader does not support glTF extensions. It may not work as intended with extensions ${_gltf.extensionsUsed.toString()}.`);
            if (_gltf.extensionsRequired?.length > 0)
                throw new Error(`${GLTFLoader.name} | ${_url}: This loader does not support glTF extensions. It does not work with required extensions ${_gltf.extensionsRequired.toString()}.`);
        }
        static preProcess(_gltf, _url) {
            if (_gltf.nodes) {
                // mark all nodes that are animated
                _gltf.animations?.forEach(_animation => {
                    _animation.channels.forEach(_channel => {
                        const iNode = _channel.target.node;
                        if (iNode != undefined)
                            _gltf.nodes[iNode].isAnimated = true;
                    });
                });
                // mark parent of each node
                _gltf.nodes.forEach((_node, _iNode) => _node.children?.forEach(_iChild => _gltf.nodes[_iChild].parent = _iNode));
                _gltf.nodes.forEach((_node, _iNode) => {
                    // add names to nodes that don't have one
                    if (!_node.name)
                        _node.name = `Node${_iNode}`;
                    if (_node.isAnimated) {
                        // add path to each animated node
                        let iParent = _node.parent;
                        let path = [];
                        path.push(_iNode);
                        while (iParent != undefined) {
                            path.push(iParent);
                            iParent = _gltf.nodes[iParent].parent;
                        }
                        _node.path = path;
                    }
                });
            }
        }
        /**
         * Returns a {@link GraphInstance} for the given scene name or the default scene if no name is given.
         */
        async getScene(_name) {
            const iScene = _name ? this.gltf.scenes.findIndex(_scene => _scene.name == _name) : this.gltf.scene;
            if (iScene == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in gltf scenes.`);
            return await this.getSceneByIndex(iScene);
        }
        /**
         * Returns a {@link GraphInstance} for the given scene index or the default scene if no index is given.
         */
        async getSceneByIndex(_iScene = this.gltf.scene) {
            if (!this.#scenes)
                this.#scenes = [];
            if (!this.#scenes[_iScene]) {
                const gltfScene = this.gltf.scenes[_iScene];
                const scene = new FudgeCore.Graph(gltfScene.name);
                for (const iNode of gltfScene.nodes)
                    scene.addChild(await this.getNodeByIndex(iNode));
                if (this.gltf.animations?.length > 0)
                    scene.addComponent(new FudgeCore.ComponentAnimator(await this.getAnimationByIndex(0)));
                // TODO: load all animations, not just the first one
                // TODO: load only skeletons which belong to the scene???
                // if (this.gltf.skins?.length > 0)
                //   for (let iSkin: number = 0; iSkin < this.gltf.skins.length; iSkin++)
                //     scene.addComponent(await this.getSkeletonByIndex(iSkin));
                for (const skeleton of this.#skeletons)
                    scene.addComponent(skeleton);
                FudgeCore.Project.register(scene);
                this.#scenes[_iScene] = scene;
            }
            return this.#scenes[_iScene];
        }
        /**
         * Returns the first {@link Node} with the given name.
         */
        async getNode(_name) {
            const iNode = this.gltf.nodes.findIndex(_node => _node.name == _name);
            if (iNode == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in gltf nodes.`);
            return await this.getNodeByIndex(iNode);
        }
        /**
         * Returns the {@link Node} for the given index.
         */
        async getNodeByIndex(_iNode) {
            if (!this.#nodes[_iNode]) {
                const gltfNode = this.gltf.nodes[_iNode];
                const node = new FudgeCore.Node(gltfNode.name);
                this.#nodes[_iNode] = node;
                // check for children
                if (gltfNode.children)
                    for (const iNode of gltfNode.children)
                        node.addChild(await this.getNodeByIndex(iNode));
                // check for transformation
                if (gltfNode.matrix || gltfNode.rotation || gltfNode.scale || gltfNode.translation || gltfNode.isAnimated) {
                    node.addComponent(new FudgeCore.ComponentTransform());
                    if (gltfNode.matrix) {
                        node.mtxLocal.set(Float32Array.from(gltfNode.matrix));
                    }
                    else {
                        if (gltfNode.translation) {
                            const translation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                            translation.set(gltfNode.translation[0], gltfNode.translation[1], gltfNode.translation[2]);
                            node.mtxLocal.translation = translation;
                            FudgeCore.Recycler.store(translation);
                        }
                        if (gltfNode.rotation) {
                            const rotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
                            rotation.set(gltfNode.rotation[0], gltfNode.rotation[1], gltfNode.rotation[2], gltfNode.rotation[3]);
                            node.mtxLocal.rotation = rotation;
                            FudgeCore.Recycler.store(rotation);
                        }
                        if (gltfNode.scale) {
                            const scale = FudgeCore.Recycler.get(FudgeCore.Vector3);
                            scale.set(gltfNode.scale[0], gltfNode.scale[1], gltfNode.scale[2]);
                            node.mtxLocal.scaling = scale;
                            FudgeCore.Recycler.store(scale);
                        }
                    }
                }
                // check for camera
                if (gltfNode.camera != undefined) {
                    node.addComponent(await this.getCameraByIndex(gltfNode.camera));
                }
                // check for mesh and material
                if (gltfNode.mesh != undefined) {
                    const gltfMesh = this.gltf.meshes?.[gltfNode.mesh];
                    // TODO: review this
                    const subComponents = [];
                    for (let iPrimitive = 0; iPrimitive < gltfMesh.primitives.length; iPrimitive++) {
                        const cmpMesh = new FudgeCore.ComponentMesh(await this.getMeshByIndex(gltfNode.mesh, iPrimitive));
                        // check for skeleton
                        if (gltfNode.skin != undefined)
                            cmpMesh.skeleton = await this.getSkeletonByIndex(gltfNode.skin);
                        let cmpMaterial;
                        const iMaterial = gltfMesh.primitives?.[iPrimitive]?.material;
                        if (iMaterial == undefined) {
                            cmpMaterial = new FudgeCore.ComponentMaterial(cmpMesh.mesh instanceof FudgeCore.MeshSkin ?
                                GLTFLoader.defaultSkinMaterial :
                                GLTFLoader.defaultMaterial);
                        }
                        else {
                            cmpMaterial = new FudgeCore.ComponentMaterial(await this.getMaterialByIndex(iMaterial, cmpMesh.mesh instanceof FudgeCore.MeshSkin));
                        }
                        subComponents.push([cmpMesh, cmpMaterial]);
                    }
                    if (subComponents.length == 1) {
                        node.addComponent(subComponents[0][0]);
                        node.addComponent(subComponents[0][1]);
                    }
                    else {
                        subComponents.forEach(([_cmpMesh, _cmpMaterial], _i) => {
                            const nodePart = new FudgeCore.Node(node.name + "_primitive" + _i);
                            nodePart.addComponent(_cmpMesh);
                            nodePart.addComponent(_cmpMaterial);
                            node.addChild(nodePart);
                        });
                    }
                }
            }
            return this.#nodes[_iNode];
        }
        /**
         * Returns the first {@link ComponentCamera} with the given camera name.
         */
        async getCamera(_name) {
            const iCamera = this.gltf.cameras.findIndex(_camera => _camera.name == _name);
            if (iCamera == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in gltf cameras.`);
            return await this.getCameraByIndex(iCamera);
        }
        /**
         * Returns the {@link ComponentCamera} for the given camera index.
         */
        async getCameraByIndex(_iCamera) {
            if (!this.#cameras)
                this.#cameras = [];
            if (!this.#cameras[_iCamera]) {
                const gltfCamera = this.gltf.cameras[_iCamera];
                const camera = new FudgeCore.ComponentCamera();
                if (gltfCamera.perspective)
                    camera.projectCentral(gltfCamera.perspective.aspectRatio, gltfCamera.perspective.yfov * FudgeCore.Calc.rad2deg, null, gltfCamera.perspective.znear, gltfCamera.perspective.zfar);
                else
                    camera.projectOrthographic(-gltfCamera.orthographic.xmag, gltfCamera.orthographic.xmag, -gltfCamera.orthographic.ymag, gltfCamera.orthographic.ymag);
                return camera;
            }
            return this.#cameras[_iCamera];
        }
        /**
         * Returns the first {@link Animation} with the given animation name.
         */
        async getAnimation(_name) {
            const iAnimation = this.gltf.animations.findIndex(_animation => _animation.name == _name);
            if (iAnimation == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in gltf animations.`);
            return await this.getAnimationByIndex(iAnimation);
        }
        /**
         * Returns the {@link Animation} for the given animation index.
         */
        async getAnimationByIndex(_iAnimation) {
            if (!this.#animations)
                this.#animations = [];
            if (!this.#animations[_iAnimation]) {
                const gltfAnimation = this.gltf.animations?.[_iAnimation];
                if (!gltfAnimation)
                    throw new Error(`${this}: Couldn't find animation with index ${_iAnimation}.`);
                // group channels by node
                let gltfChannelsGrouped = []; // TODO: maybe change this to map or js object
                for (const gltfChannel of gltfAnimation.channels) {
                    const iNode = gltfChannel.target.node;
                    if (iNode == undefined)
                        continue;
                    if (!gltfChannelsGrouped[iNode])
                        gltfChannelsGrouped[iNode] = [];
                    gltfChannelsGrouped[iNode].push(gltfChannel);
                }
                // remove empty entries
                gltfChannelsGrouped = gltfChannelsGrouped.filter(_channels => _channels != undefined);
                const animationStructure = {};
                for (const gltfChannels of gltfChannelsGrouped) {
                    const gltfNode = this.gltf.nodes[gltfChannels[0].target.node];
                    let currentStructure = animationStructure;
                    for (const iPathNode of gltfNode.path.reverse()) {
                        const pathNode = this.gltf.nodes[iPathNode];
                        if (currentStructure.children == undefined)
                            currentStructure.children = {};
                        if (currentStructure.children[pathNode.name] == undefined)
                            currentStructure.children[pathNode.name] = {};
                        currentStructure = currentStructure.children[pathNode.name];
                        if (pathNode == gltfNode) {
                            const mtxLocal = {};
                            for (const gltfChannel of gltfChannels)
                                mtxLocal[toInternTransformation[gltfChannel.target.path]] =
                                    await this.getAnimationSequenceVector(gltfAnimation.samplers[gltfChannel.sampler], gltfChannel.target.path);
                            currentStructure.components = {
                                ComponentTransform: [
                                    { mtxLocal: mtxLocal }
                                ]
                            };
                        }
                    }
                }
                this.#animations[_iAnimation] = new FudgeCore.Animation(gltfAnimation.name, animationStructure);
            }
            return this.#animations[_iAnimation];
        }
        /**
         * Returns the first {@link MeshImport} with the given mesh name.
         */
        async getMesh(_name) {
            const iMesh = this.gltf.meshes.findIndex(_mesh => _mesh.name == _name);
            if (iMesh == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in gltf meshes.`);
            return await this.getMeshByIndex(iMesh);
        }
        /**
         * Returns the {@link MeshImport} for the given mesh index.
         */
        async getMeshByIndex(_iMesh, _iPrimitive = 0) {
            if (!this.#meshes)
                this.#meshes = [];
            if (!this.#meshes[_iMesh])
                this.#meshes[_iMesh] = [];
            if (!this.#meshes[_iMesh][_iPrimitive]) {
                const gltfMesh = this.gltf.meshes[_iMesh];
                this.#meshes[_iMesh][_iPrimitive] = await (gltfMesh.primitives[_iPrimitive].attributes.JOINTS_0 != undefined ?
                    new FudgeCore.MeshSkin() :
                    new FudgeCore.MeshImport()).load(FudgeCore.MeshLoaderGLTF, this.url, { iMesh: _iMesh, iPrimitive: _iPrimitive });
            }
            return this.#meshes[_iMesh][_iPrimitive];
        }
        /**
         * Returns the {@link Material} for the given material index.
         */
        async getMaterialByIndex(_iMaterial, _skin = false) {
            if (!this.#materials)
                this.#materials = [];
            if (!this.#materials[_iMaterial]) {
                // TODO: in the future create an appropriate shader based on the gltf material properties
                const gltfMaterial = this.gltf.materials[_iMaterial];
                if (!gltfMaterial)
                    throw new Error(`${this}: Couldn't find material with index ${_iMaterial}.`);
                // TODO: add support for other gltf material properties: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-material
                // e.g. normal, occlusion and emissive textures; alphaMode; alphaCutoff; doubleSided
                const gltfBaseColorTexture = gltfMaterial.pbrMetallicRoughness?.baseColorTexture;
                const color = new FudgeCore.Color(...gltfMaterial.pbrMetallicRoughness?.baseColorFactor || [1, 1, 1, 1]);
                const coat = gltfBaseColorTexture ?
                    new FudgeCore.CoatRemissiveTextured(color, await this.getTextureByIndex(gltfBaseColorTexture.index), 1, 1) :
                    new FudgeCore.CoatRemissive(color, 1, 0.5);
                const material = new FudgeCore.Material(gltfMaterial.name, gltfBaseColorTexture ?
                    (_skin ? FudgeCore.ShaderPhongTexturedSkin : FudgeCore.ShaderPhongTextured) :
                    (_skin ? FudgeCore.ShaderPhongSkin : FudgeCore.ShaderPhong), coat);
                this.#materials[_iMaterial] = material;
            }
            return this.#materials[_iMaterial];
        }
        /**
         * Returns the {@link Texture} for the given texture index.
         */
        async getTextureByIndex(_iTexture) {
            if (!this.#textures)
                this.#textures = [];
            if (!this.#textures[_iTexture]) {
                const gltfTexture = this.gltf.textures[_iTexture];
                const gltfSampler = this.gltf.samplers?.[gltfTexture.sampler];
                const gltfImage = this.gltf.images?.[gltfTexture.source];
                if (gltfImage == undefined) {
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has no image.`);
                    return FudgeCore.TextureDefault.texture;
                }
                if (gltfSampler?.wrapS != undefined && gltfSampler?.wrapS != WebGL2RenderingContext.REPEAT)
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has a wrapS of '${getWebGLParameterName(gltfSampler.wrapS)}'. FUDGE only supports the default behavior of '${getWebGLParameterName(WebGL2RenderingContext.REPEAT)}'.`);
                if (gltfSampler?.wrapT != undefined && gltfSampler?.wrapT != WebGL2RenderingContext.REPEAT)
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has a wrapT of '${getWebGLParameterName(gltfSampler.wrapT)}'. FUDGE only supports the default behavior of '${getWebGLParameterName(WebGL2RenderingContext.REPEAT)}'.`);
                let url = new URL(gltfImage.uri, this.url).toString();
                if (!gltfImage.uri && gltfImage.bufferView) {
                    // TODO: this is duplicate code from getBufferData, maybe refactor getBufferData to handle bufferViewIndex input
                    const gltfBufferView = this.gltf.bufferViews[gltfImage.bufferView];
                    const buffer = await this.getBuffer(gltfBufferView.buffer);
                    const byteOffset = gltfBufferView.byteOffset || 0;
                    const byteLength = gltfBufferView.byteLength || 0;
                    url = URL.createObjectURL(new Blob([new Uint8Array(buffer, byteOffset, byteLength / Uint8Array.BYTES_PER_ELEMENT)], { type: gltfImage.mimeType }));
                }
                const texture = new FudgeCore.TextureImage();
                await texture.load(url);
                if (gltfSampler && gltfSampler.magFilter == WebGL2RenderingContext.NEAREST && gltfSampler.minFilter == WebGL2RenderingContext.NEAREST)
                    texture.mipmap = FudgeCore.MIPMAP.CRISP;
                else if (gltfSampler && gltfSampler.magFilter == WebGL2RenderingContext.NEAREST && gltfSampler.minFilter == WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR)
                    texture.mipmap = FudgeCore.MIPMAP.MEDIUM;
                else if (gltfSampler && gltfSampler.magFilter == WebGL2RenderingContext.LINEAR && gltfSampler.minFilter == WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR)
                    texture.mipmap = FudgeCore.MIPMAP.BLURRY;
                else if (gltfSampler && (gltfSampler.magFilter != undefined || gltfSampler.minFilter != undefined))
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has a magFilter and minFilter of '${getWebGLParameterName(gltfSampler.magFilter)}' and '${getWebGLParameterName(gltfSampler.minFilter)}' respectively. FUDGE only supports the following combinations: NEAREST and NEAREST | NEAREST and NEAREST_MIPMAP_LINEAR | LINEAR and LINEAR_MIPMAP_LINEAR.`);
                this.#textures[_iTexture] = texture;
            }
            return this.#textures[_iTexture];
        }
        /**
        * Returns the first {@link ComponentSkeleton} with the given skeleton name.
        */
        async getSkeleton(_name) {
            const iSkeleton = this.gltf.skins.findIndex(_skeleton => _skeleton.name == _name);
            if (iSkeleton == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in gltf skins.`);
            return await this.getSkeletonByIndex(iSkeleton);
        }
        /**
         * Returns the {@link ComponentSkeleton} for the given skeleton index.
         */
        async getSkeletonByIndex(_iSkeleton) {
            if (!this.#skeletons)
                this.#skeletons = [];
            if (!this.#skeletons[_iSkeleton]) {
                const gltfSkin = this.gltf.skins[_iSkeleton];
                const bones = [];
                // convert float array to array of matrices and register bones
                let mtxData;
                if (gltfSkin.inverseBindMatrices != undefined)
                    mtxData = await this.getFloat32Array(gltfSkin.inverseBindMatrices);
                const mtxDataSpan = 16; // size of matrix
                const mtxBindInverses = [];
                // iterate over joints and get corresponding matrix from float array
                for (let iBone = 0; iBone < gltfSkin.joints.length; iBone++) {
                    let mtxBindInverse;
                    if (mtxData) {
                        mtxBindInverse = new FudgeCore.Matrix4x4();
                        mtxBindInverse.set(mtxData.subarray(iBone * mtxDataSpan, iBone * mtxDataSpan + mtxDataSpan));
                    }
                    bones.push(await this.getNodeByIndex(gltfSkin.joints[iBone]));
                    mtxBindInverses.push(mtxBindInverse);
                }
                this.#skeletons[_iSkeleton] = new FudgeCore.ComponentSkeleton(bones, mtxBindInverses);
            }
            return this.#skeletons[_iSkeleton];
        }
        /**
         * Returns a {@link Uint8Array} for the given accessor index.
         * @internal
         */
        async getBoneIndices(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const componentType = this.gltf.accessors[_iAccessor]?.componentType;
            if (componentType == GLTF.COMPONENT_TYPE.UNSIGNED_BYTE)
                return array;
            if (componentType == GLTF.COMPONENT_TYPE.UNSIGNED_SHORT) {
                FudgeCore.Debug.log(`${this}: Bone indices are stored as '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]}'. FUDGE will convert them to '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]}'. FUDGE only supports skeletons with up to 256 bones, so make sure your skeleton has no more than 256 bones.`);
                return Uint8Array.from(array);
            }
            throw new Error(`${this}: Invalid component type '${GLTF.COMPONENT_TYPE[componentType]}' for bone indices. Expected '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]}' or '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]}'.`);
        }
        /**
         * Returns a {@link Float32Array} for the given accessor index.
         * @internal
         */
        async getFloat32Array(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const gltfAccessor = this.gltf.accessors[_iAccessor];
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.FLOAT)
                return array;
            if (gltfAccessor.normalized) {
                switch (gltfAccessor.componentType) {
                    case GLTF.COMPONENT_TYPE.BYTE:
                        return Float32Array.from(array, _value => Math.max(_value / 127, -1));
                    case GLTF.COMPONENT_TYPE.UNSIGNED_BYTE:
                        return Float32Array.from(array, _value => _value / 255);
                    case GLTF.COMPONENT_TYPE.SHORT:
                        return Float32Array.from(array, _value => Math.max(_value / 32767, -1));
                    case GLTF.COMPONENT_TYPE.UNSIGNED_SHORT:
                        return Float32Array.from(array, _value => _value / 65535);
                    default:
                        throw new Error(`${this}: Invalid component type '${GLTF.COMPONENT_TYPE[gltfAccessor.componentType]}' for normalized accessor.`);
                    // https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_accessor_normalized
                }
            }
            FudgeCore.Debug.warn(`${this}: Expected component type '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.FLOAT]}' but was '${GLTF.COMPONENT_TYPE[gltfAccessor?.componentType]}'.`);
            return Float32Array.from(array);
        }
        /**
         * Returns a {@link Uint16Array} for the given accessor index. Only used to get the vertex indices.
         * @internal
         */
        async getVertexIndices(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const gltfAccessor = this.gltf.accessors[_iAccessor];
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_SHORT)
                return array;
            if (gltfAccessor.count > 65535 && gltfAccessor.type == "SCALAR")
                throw new Error(`${this}: File includes a mesh with more than 65535 vertices. FUDGE does not support meshes with more than 65535 vertices.`);
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_BYTE || gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_INT)
                return Uint16Array.from(array);
            FudgeCore.Debug.warn(`${this}: Expected an unsigned integer component type but was '${GLTF.COMPONENT_TYPE[this.gltf.accessors[_iAccessor]?.componentType]}'.`);
            return Uint16Array.from(array);
        }
        /**
         * Return a {@link Float32Array} for the given accessor index. The array contains the vertex colors in RGBA format.
         * @internal
         */
        async getVertexColors(_iAccessor) {
            const array = await this.getFloat32Array(_iAccessor);
            const gltfAccessor = this.gltf.accessors[_iAccessor];
            if (gltfAccessor.type == GLTF.ACCESSOR_TYPE.VEC3) {
                const rgbaArray = new Float32Array(array.length * 4 / 3);
                for (let iVec3 = 0, iVec4 = 0; iVec3 < array.length; iVec3 += 3, iVec4 += 4) {
                    rgbaArray[iVec4] = array[iVec3];
                    rgbaArray[iVec4 + 1] = array[iVec3 + 1];
                    rgbaArray[iVec4 + 2] = array[iVec3 + 2];
                    rgbaArray[iVec4 + 3] = 1;
                }
                return rgbaArray;
            }
            return array;
        }
        toString() {
            return `${GLTFLoader.name} | ${this.url}`;
        }
        async getBufferData(_iAccessor) {
            const gltfAccessor = this.gltf.accessors[_iAccessor];
            if (!gltfAccessor)
                throw new Error(`${this}: Couldn't find accessor with index ${_iAccessor}.`);
            let array;
            const componentType = gltfAccessor.componentType;
            const accessorType = gltfAccessor.type;
            if (gltfAccessor.bufferView != undefined)
                array = await this.getBufferViewData(this.gltf.bufferViews[gltfAccessor.bufferView], gltfAccessor.byteOffset, componentType, accessorType);
            if (gltfAccessor.sparse) {
                const gltfBufferViewIndices = this.gltf.bufferViews[gltfAccessor.sparse.indices.bufferView];
                const gltfBufferViewValues = this.gltf.bufferViews[gltfAccessor.sparse.values.bufferView];
                if (!gltfBufferViewIndices || !gltfBufferViewValues)
                    throw new Error(`${this}: Couldn't find buffer views for sparse indices or values of accessor with index ${_iAccessor}.`);
                const arrayIndices = await this.getBufferViewData(gltfBufferViewIndices, gltfAccessor.sparse.indices.byteOffset, gltfAccessor.sparse.indices.componentType, GLTF.ACCESSOR_TYPE.SCALAR);
                const arrayValues = await this.getBufferViewData(gltfBufferViewValues, gltfAccessor.sparse.values.byteOffset, componentType, accessorType);
                const accessorTypeLength = toAccessorTypeLength[gltfAccessor.type];
                if (gltfAccessor.bufferView == undefined)
                    array = new toArrayConstructor[gltfAccessor.componentType](gltfAccessor.count * accessorTypeLength);
                for (let i = 0; i < gltfAccessor.sparse.count; i++) {
                    array.set(arrayValues.slice(i * accessorTypeLength, (i + 1) * accessorTypeLength), arrayIndices[i] * accessorTypeLength);
                }
            }
            return array;
        }
        async getBufferViewData(_bufferView, _byteOffset, _componentType, _accessorType) {
            const buffer = await this.getBuffer(_bufferView.buffer);
            const byteOffset = (_bufferView.byteOffset ?? 0) + (_byteOffset ?? 0);
            const byteLength = _bufferView.byteLength ?? 0;
            const byteStride = _bufferView.byteStride;
            const arrayConstructor = toArrayConstructor[_componentType];
            const array = new arrayConstructor(buffer, byteOffset, byteLength / arrayConstructor.BYTES_PER_ELEMENT);
            if (byteStride != undefined) {
                // TODO: instead of creating new buffers maybe rather pass stride into the render mesh? and set it when data is passed to the gpu?
                const nComponentsPerElement = toAccessorTypeLength[_accessorType]; // amount of components per element of the accessor type, i.e. 3 for VEC3
                const nElements = byteLength / byteStride; // amount of elements, i.e. n*VEC3 
                const stride = byteStride / arrayConstructor.BYTES_PER_ELEMENT;
                const newArray = new arrayConstructor(nElements * nComponentsPerElement);
                for (let iNewElement = 0; iNewElement < nElements; iNewElement++) {
                    const iElement = iNewElement * stride;
                    // TODO: check if loop is faster than set + slice
                    for (let iComponent = 0; iComponent < nComponentsPerElement; iComponent++)
                        newArray[iNewElement * nComponentsPerElement + iComponent] = array[iElement + iComponent];
                    // newArray.set(array.slice(iElement, iElement + nComponentsPerElement), iNewElement * nComponentsPerElement);
                }
                return newArray;
            }
            return array;
        }
        async getBuffer(_iBuffer) {
            const gltfBuffer = this.gltf.buffers[_iBuffer];
            if (!gltfBuffer)
                throw new Error(`${this}: Couldn't find buffer with index ${_iBuffer}.`);
            if (!this.#buffers)
                this.#buffers = [];
            if (!this.#buffers[_iBuffer]) {
                const response = await fetch(new URL(gltfBuffer.uri, this.url));
                this.#buffers[_iBuffer] = await response.arrayBuffer();
            }
            return this.#buffers[_iBuffer];
        }
        async getAnimationSequenceVector(_sampler, _transformationType) {
            const input = await this.getFloat32Array(_sampler.input);
            const output = await this.getFloat32Array(_sampler.output);
            const millisPerSecond = 1000;
            const isRotation = _transformationType == "rotation";
            const vectorLength = isRotation ? 4 : 3; // rotation is stored as quaternion
            const interpolation = this.toInternInterpolation(_sampler.interpolation);
            const isCubic = interpolation == FudgeCore.ANIMATION_INTERPOLATION.CUBIC ? true : undefined;
            const vectorsPerInput = isCubic ? 3 : 1; // cubic interpolation uses 3 values per input: in-tangent, property value and out-tangent. https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
            // used only for rotation interpolation
            let lastRotation;
            let nextRotation;
            const sequenceVector = {};
            sequenceVector.x = new FudgeCore.AnimationSequence();
            sequenceVector.y = new FudgeCore.AnimationSequence();
            sequenceVector.z = new FudgeCore.AnimationSequence();
            if (isRotation) {
                sequenceVector.w = new FudgeCore.AnimationSequence();
                lastRotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
                nextRotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
            }
            for (let iInput = 0; iInput < input.length; iInput++) {
                const iOutput = iInput * vectorsPerInput * vectorLength + (isCubic ? vectorLength : 0);
                const iOutputSlopeIn = iOutput - vectorLength;
                const iOutputSlopeOut = iOutput + vectorLength;
                const time = millisPerSecond * input[iInput];
                if (isRotation) {
                    // Take the shortest path between two rotations, i.e. if the dot product is negative then the next quaternion needs to be negated.
                    // q and -q represent the same rotation but interpolation will take either the long way or the short way around the sphere depending on which we use.
                    nextRotation.set(output[iOutput + 0], output[iOutput + 1], output[iOutput + 2], output[iOutput + 3]);
                    if (FudgeCore.Quaternion.DOT(lastRotation, nextRotation) < 0)
                        nextRotation.negate();
                    output[iOutput + 0] = nextRotation.x;
                    output[iOutput + 1] = nextRotation.y;
                    output[iOutput + 2] = nextRotation.z;
                    output[iOutput + 3] = nextRotation.w;
                    lastRotation.set(nextRotation.x, nextRotation.y, nextRotation.z, nextRotation.w);
                }
                sequenceVector.x.addKey(new FudgeCore.AnimationKey(time, output[iOutput + 0], interpolation, isCubic && output[iOutputSlopeIn + 0] / millisPerSecond, isCubic && output[iOutputSlopeOut + 0] / millisPerSecond));
                sequenceVector.y.addKey(new FudgeCore.AnimationKey(time, output[iOutput + 1], interpolation, isCubic && output[iOutputSlopeIn + 1] / millisPerSecond, isCubic && output[iOutputSlopeOut + 1] / millisPerSecond));
                sequenceVector.z.addKey(new FudgeCore.AnimationKey(time, output[iOutput + 2], interpolation, isCubic && output[iOutputSlopeIn + 2] / millisPerSecond, isCubic && output[iOutputSlopeOut + 2] / millisPerSecond));
                sequenceVector.w?.addKey(new FudgeCore.AnimationKey(time, output[iOutput + 3], interpolation, isCubic && output[iOutputSlopeIn + 3] / millisPerSecond, isCubic && output[iOutputSlopeOut + 3] / millisPerSecond));
            }
            if (isRotation) {
                FudgeCore.Recycler.store(lastRotation);
                FudgeCore.Recycler.store(nextRotation);
            }
            return sequenceVector;
        }
        toInternInterpolation(_interpolation) {
            switch (_interpolation) {
                case "LINEAR":
                    return FudgeCore.ANIMATION_INTERPOLATION.LINEAR;
                case "STEP":
                    return FudgeCore.ANIMATION_INTERPOLATION.CONSTANT;
                case "CUBICSPLINE":
                    return FudgeCore.ANIMATION_INTERPOLATION.CUBIC;
                default:
                    if (_interpolation != undefined)
                        FudgeCore.Debug.warn(`${this}: Unknown interpolation type ${_interpolation}.`);
                    return FudgeCore.ANIMATION_INTERPOLATION.LINEAR;
            }
        }
    }
    FudgeCore.GLTFLoader = GLTFLoader;
    function getWebGLParameterName(_value) {
        return Object.keys(WebGL2RenderingContext).find(_key => Reflect.get(WebGL2RenderingContext, _key) == _value);
    }
    const toInternTransformation = {
        "translation": "translation",
        "rotation": "rotation",
        "scale": "scaling",
        "weights": "weights"
    };
    // number of components defined by 'type'
    const toAccessorTypeLength = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
    };
    const toArrayConstructor = {
        [GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]: Uint8Array,
        [GLTF.COMPONENT_TYPE.BYTE]: Int8Array,
        [GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]: Uint16Array,
        [GLTF.COMPONENT_TYPE.SHORT]: Int16Array,
        [GLTF.COMPONENT_TYPE.UNSIGNED_INT]: Uint32Array,
        [GLTF.COMPONENT_TYPE.FLOAT]: Float32Array
    };
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    FudgeCore.shaderSources = {};
    FudgeCore.shaderSources["ShaderPhong.frag"] = /*glsl*/ `#version 300 es
/**
* Phong shading
* @authors Jirka Dell'Oro-Friedl, HFU, 2022 | Jonas Plotzky, HFU, 2023
*/

precision mediump float;
precision highp int;

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

uniform vec4 u_vctColor;
uniform float u_fDiffuse;
uniform float u_fSpecular;
// uniform mat4 u_mtxMeshToWorld; // can't use this when skinning
uniform vec3 u_vctCamera;

in vec4 v_vctColor;
in vec3 v_vctPosition;

  #if defined(PHONG)
in vec3 v_vctNormal;
  #endif

  #if defined(FLAT)
flat in vec3 v_vctPositionFlat;
  #endif

out vec4 vctFrag;

struct Light {
  vec4 vctColor;
  mat4 mtxShape;
  mat4 mtxShapeInverse;
};

const uint MAX_LIGHTS_DIRECTIONAL = 15u;
const uint MAX_LIGHTS_POINT = 100u;
const uint MAX_LIGHTS_SPOT = 100u;

layout(std140) uniform Lights {
  uint u_nLightsDirectional;
  uint u_nLightsPoint;
  uint u_nLightsSpot;
  Light u_ambient;
  Light u_directional[MAX_LIGHTS_DIRECTIONAL];
  Light u_point[MAX_LIGHTS_POINT];
  Light u_spot[MAX_LIGHTS_SPOT];
};

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  // attempted BLINN 
  // vec3 halfway = normalize(_vctView + _vctLight);
  // float fHitCamera = dot(-halfway, _vctNormal);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}

vec4 illuminateDirected(vec3 _vctDirection, vec3 _vctNormal, vec4 _vctColor, vec3 _vctView, float _fSpecular) {
  vec4 vctResult = vec4(0, 0, 0, 1);
  vec3 vctDirection = normalize(_vctDirection);
  float fIllumination = -dot(_vctNormal, vctDirection);
  if(fIllumination > 0.0f) {
    vctResult += u_fDiffuse * fIllumination * _vctColor;
    float fReflection = calculateReflection(vctDirection, _vctView, _vctNormal, _fSpecular);
    vctResult += fReflection * _vctColor;
  }
  return vctResult;
}

void main() {
  vec3 vctPosition = v_vctPosition;

    #if defined(PHONG)
  vec3 vctNormal = normalize(v_vctNormal);
  vec3 vctView = normalize(v_vctPosition - u_vctCamera);
    #endif

    #if defined(FLAT)
  vec3 vctXTangent = dFdx(vctPosition);
  vec3 vctYTangent = dFdy(vctPosition);
  vec3 vctNormal = normalize(cross(vctXTangent, vctYTangent));
  vec3 vctView = normalize(v_vctPositionFlat - u_vctCamera);
    #endif

  vctFrag = u_fDiffuse * u_ambient.vctColor;
  
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    vec3 vctDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, 1.0, 1.0));
    vctFrag += illuminateDirected(vctDirection, vctNormal, u_directional[i].vctColor, vctView, u_fSpecular);
  }

  // calculate point light effect
  for(uint i = 0u; i < u_nLightsPoint; i++) {
    vec3 vctPositionLight = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vctPosition - vctPositionLight;
    float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctDirection);
    if(fIntensity < 0.0)
      continue;
    vctFrag += illuminateDirected(vctDirection, vctNormal, fIntensity * u_point[i].vctColor, vctView, u_fSpecular);
  }

  // calculate spot light effect
  for(uint i = 0u; i < u_nLightsSpot; i++) {
    vec3 vctPositionLight = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vctPosition - vctPositionLight;
    vec3 vctDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * vctDirection;
    if(vctDirectionInverted.z <= 0.0)
      continue;
    float fIntensity = 1.0 - min(1.0, 2.0 * length(vctDirectionInverted.xy) / vctDirectionInverted.z);
    fIntensity *= 1.0 - pow(vctDirectionInverted.z, 2.0);
    if(fIntensity < 0.0)
      continue;
    vctFrag += illuminateDirected(vctDirection, vctNormal, fIntensity * u_spot[i].vctColor, vctView, u_fSpecular);
  }

  // TEXTURE: multiply with texel color
    #if defined(TEXTURE)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif
    
  vctFrag *= u_vctColor * v_vctColor;
}`;
    FudgeCore.shaderSources["ShaderPick.frag"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform vec2 u_vctSize;
uniform vec4 u_vctColor;
out ivec4 vctFrag;

void main() {
    int pixel = int(trunc(gl_FragCoord.x) + u_vctSize.x * trunc(gl_FragCoord.y));

    if (pixel != u_id)
      discard;

    uint icolor = uint(u_vctColor.r * 255.0) << 24 | uint(u_vctColor.g * 255.0) << 16 | uint(u_vctColor.b * 255.0) << 8 | uint(u_vctColor.a * 255.0);
                
    vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, 0, 0);
}`;
    FudgeCore.shaderSources["ShaderPick.vert"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
in vec3 a_vctPosition;       
uniform mat4 u_mtxMeshToView;

void main() {   
    gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
}`;
    FudgeCore.shaderSources["ShaderPickTextured.frag"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform vec2 u_vctSize;
in vec2 v_vctTexture;
uniform vec4 u_vctColor;
uniform sampler2D u_texture;

out ivec4 vctFrag;

void main() {
    int pixel = int(trunc(gl_FragCoord.x) + u_vctSize.x * trunc(gl_FragCoord.y));

    if (pixel != u_id)
      discard;
    
    vec4 vctColor = u_vctColor * texture(u_texture, v_vctTexture);
    uint icolor = uint(vctColor.r * 255.0) << 24 | uint(vctColor.g * 255.0) << 16 | uint(vctColor.b * 255.0) << 8 | uint(vctColor.a * 255.0);
  
  vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, floatBitsToInt(v_vctTexture.x), floatBitsToInt(v_vctTexture.y));
}`;
    FudgeCore.shaderSources["ShaderPickTextured.vert"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
in vec3 a_vctPosition;       
in vec2 a_vctTexture;
uniform mat4 u_mtxMeshToView;
uniform mat3 u_mtxPivot;

out vec2 v_vctTexture;

void main() {   
    gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
    v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
}`;
    FudgeCore.shaderSources["ShaderUniversal.frag"] = /*glsl*/ `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;
precision highp int;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;
in vec4 v_vctColor;

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor * v_vctColor;

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}`;
    FudgeCore.shaderSources["ShaderUniversal.vert"] = /*glsl*/ `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2023
*/

precision mediump float;
precision highp int;

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;
// TODO: think about making vertex color optional
in vec4 a_vctColor;
out vec4 v_vctColor;

  // PARTICLE: offer buffer and functionality for in shader position calculation
  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA) || defined(PARTICLE)
uniform mat4 u_mtxMeshToWorld;
uniform vec3 u_vctCamera;
  #endif

  #if defined(CAMERA)
uniform float u_fSpecular;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct Light {
  vec4 vctColor;
  mat4 mtxShape;
  mat4 mtxShapeInverse;
};

const uint MAX_LIGHTS_DIRECTIONAL = 15u;
const uint MAX_LIGHTS_POINT = 100u;
const uint MAX_LIGHTS_SPOT = 100u;

layout(std140) uniform Lights {
  uint u_nLightsDirectional;
  uint u_nLightsPoint;
  uint u_nLightsSpot;
  Light u_ambient;
  Light u_directional[MAX_LIGHTS_DIRECTIONAL];
  Light u_point[MAX_LIGHTS_POINT];
  Light u_spot[MAX_LIGHTS_SPOT];
};

vec4 illuminateDirected(vec3 _vctDirection, vec3 _vctNormal, vec4 _vctColor, vec3 _vctView, float _fSpecular) {
  vec4 vctResult = vec4(0, 0, 0, 1);
  vec3 vctDirection = normalize(_vctDirection);
  float fIllumination = -dot(_vctNormal, vctDirection);
  if(fIllumination > 0.0f) {
    vctResult += u_fDiffuse * fIllumination * _vctColor;
        #if defined(CAMERA)
    float fReflection = calculateReflection(vctDirection, _vctView, _vctNormal, _fSpecular);
    vctResult += fReflection * _vctColor;
        #endif
  }
  return vctResult;
}
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
uniform mat4 u_mtxWorldToCamera;
out vec2 v_vctTexture;
  #endif

  #if defined(PHONG)
out vec3 v_vctNormal;
out vec3 v_vctPosition;
  #endif

  #if defined(FLAT)
out vec3 v_vctPosition;
flat out vec3 v_vctPositionFlat;
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxWorldToView; // 
// Bones
// https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js
in uvec4 a_vctBones;
in vec4 a_vctWeights;
const uint MAX_BONES = 256u; // CAUTION: this number must be the same as in RenderInjectorSkeletonInstance where the corresponding buffers are created
layout (std140) uniform Skin {
  mat4 u_mtxBones[MAX_BONES];
};
  #endif

  #if defined(PARTICLE)
uniform mat4 u_mtxWorldToView;
uniform float u_fParticleSystemDuration;
uniform float u_fParticleSystemSize;
uniform float u_fParticleSystemTime;
uniform sampler2D u_fParticleSystemRandomNumbers;
uniform bool u_bParticleSystemFaceCamera;
uniform bool u_bParticleSystemRestrict;

mat4 lookAt(vec3 _vctTranslation, vec3 _vctTarget) {
  vec3 vctUp = vec3(0.0, 1.0, 0.0);
  vec3 zAxis = normalize(_vctTarget - _vctTranslation);
  vec3 xAxis = normalize(cross(vctUp, zAxis));
  vec3 yAxis = u_bParticleSystemRestrict ? vctUp : normalize(cross(zAxis, xAxis));
  zAxis = u_bParticleSystemRestrict ? normalize(cross(xAxis, vctUp)) : zAxis;

  return mat4(
    xAxis.x, xAxis.y, xAxis.z, 0.0,
    yAxis.x, yAxis.y, yAxis.z, 0.0,
    zAxis.x, zAxis.y, zAxis.z, 0.0,
    _vctTranslation.x,  _vctTranslation.y,  _vctTranslation.z, 1.0
  );
}

float fetchRandomNumber(int _iIndex, int _iParticleSystemRandomNumbersSize, int _iParticleSystemRandomNumbersLength) {
  _iIndex = _iIndex % _iParticleSystemRandomNumbersLength;
  return texelFetch(u_fParticleSystemRandomNumbers, ivec2(_iIndex % _iParticleSystemRandomNumbersSize, _iIndex / _iParticleSystemRandomNumbersSize), 0).r;
}
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);

    #if defined(CAMERA) || defined(PARTICLE) || defined(SKIN) || defined(MATCAP)
  mat4 mtxMeshToWorld = u_mtxMeshToWorld;
    #endif

    #if defined(PARTICLE)
  float fParticleId = float(gl_InstanceID);
  int iParticleSystemRandomNumbersSize = textureSize(u_fParticleSystemRandomNumbers, 0).x; // the dimension of the quadratic texture
  int iParticleSystemRandomNumbersLength = iParticleSystemRandomNumbersSize * iParticleSystemRandomNumbersSize; // the total number of texels in the texture
  /*$variables*/
  /*$mtxLocal*/
  /*$mtxWorld*/
  mtxMeshToWorld = /*$mtxWorld*/ mtxMeshToWorld /*$mtxLocal*/;
  if (u_bParticleSystemFaceCamera) 
    mtxMeshToWorld = 
      lookAt(vec3(mtxMeshToWorld[3][0], mtxMeshToWorld[3][1], mtxMeshToWorld[3][2]), u_vctCamera) * 
      mat4(
        length(vec3(mtxMeshToWorld[0][0], mtxMeshToWorld[1][0], mtxMeshToWorld[2][0])), 0.0, 0.0, 0.0,
        0.0, length(vec3(mtxMeshToWorld[0][1], mtxMeshToWorld[1][1], mtxMeshToWorld[2][1])), 0.0, 0.0,
        0.0, 0.0, length(vec3(mtxMeshToWorld[0][2], mtxMeshToWorld[1][2], mtxMeshToWorld[2][2])), 0.0,
        0.0, 0.0, 0.0, 1.0
      );
  mat4 mtxMeshToView = u_mtxWorldToView * mtxMeshToWorld;
    #else
  mat4 mtxMeshToView = u_mtxMeshToView;
    #endif

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
      #if defined(PARTICLE)
  mat4 mtxNormalMeshToWorld = transpose(inverse(mtxMeshToWorld));
      #else
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #endif
    #endif

    #if defined(SKIN)
  mtxMeshToWorld = a_vctWeights.x * u_mtxBones[a_vctBones.x] +
    a_vctWeights.y * u_mtxBones[a_vctBones.y] +
    a_vctWeights.z * u_mtxBones[a_vctBones.z] +
    a_vctWeights.w * u_mtxBones[a_vctBones.w];
  
  mtxMeshToView = u_mtxWorldToView * mtxMeshToWorld;
  mtxNormalMeshToWorld = transpose(inverse(mtxMeshToWorld));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;
  v_vctColor = a_vctColor;

    #if defined(CAMERA) || defined(MATCAP)
  vec3 vctView = normalize(vec3(mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = mat3(mtxNormalMeshToWorld) * vctNormal;

      #if defined(PHONG)
  v_vctNormal = vctNormal; // pass normal to fragment shader
  v_vctPosition = vec3(mtxMeshToWorld * vctPosition);
      #endif

      #if defined(FLAT)
  v_vctPosition = vec3(mtxMeshToWorld * vctPosition);
  v_vctPositionFlat = v_vctPosition;
      #endif

    #if !defined(PHONG) && !defined(FLAT) // gouraud
  vctNormal = normalize(vctNormal);
  v_vctColor = u_fDiffuse * u_ambient.vctColor;

  // calculate directional light effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    vec3 vctDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, 1.0, 1.0));
    v_vctColor += illuminateDirected(vctDirection, vctNormal, u_directional[i].vctColor, vctView, u_fSpecular);
  }

  // calculate point light effect
  for(uint i = 0u; i < u_nLightsPoint; i++) {
    vec3 vctPositionLight = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vec3(mtxMeshToWorld * vctPosition) - vctPositionLight;
    float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctDirection);
    if(fIntensity < 0.0)
      continue;
    v_vctColor += illuminateDirected(vctDirection, vctNormal, fIntensity * u_point[i].vctColor, vctView, u_fSpecular);
  }

  // calculate spot light effect
  for(uint i = 0u; i < u_nLightsSpot; i++) {
    vec3 vctPositionLight = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vec3(mtxMeshToWorld * vctPosition) - vctPositionLight;
    vec3 vctDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * vctDirection;
    if(vctDirectionInverted.z <= 0.0)
      continue;
    float fIntensity = 1.0 - min(1.0, 2.0 * length(vctDirectionInverted.xy) / vctDirectionInverted.z);
    fIntensity *= 1.0 - pow(vctDirectionInverted.z, 2.0);
    if(fIntensity < 0.0)
      continue;
    v_vctColor += illuminateDirected(vctDirection, vctNormal, fIntensity * u_spot[i].vctColor, vctView, u_fSpecular);
  }
  
  v_vctColor *= a_vctColor;
      #endif // PHONG
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vec4 vctVertexInCamera = normalize(u_mtxWorldToCamera * vctPosition);
  vctVertexInCamera.xy *= -1.0;
  mat4 mtx_RotX = mat4(1, 0, 0, 0, 0, vctVertexInCamera.z, vctVertexInCamera.y, 0, 0, -vctVertexInCamera.y, vctVertexInCamera.z, 0, 0, 0, 0, 1);
  mat4 mtx_RotY = mat4(vctVertexInCamera.z, 0, -vctVertexInCamera.x, 0, 0, 1, 0, 0, vctVertexInCamera.x, 0, vctVertexInCamera.z, 0, 0, 0, 0, 1);

  vctNormal = mat3(u_mtxNormalMeshToWorld) * a_vctNormal;

  // adds correction for things being far and to the side, but distortion for things being close
  vctNormal = mat3(mtx_RotX * mtx_RotY) * vctNormal;
  
  vec3 vctReflection = normalize(mat3(u_mtxWorldToCamera) * normalize(vctNormal));
  vctReflection.y = -vctReflection.y;

  v_vctTexture = 0.5 * vctReflection.xy + 0.5;
    #endif

    #if defined(PARTICLE_COLOR)
  vec4 vctParticleColor = /*$color*/;
      #if defined(LIGHT)
  v_vctColor *= vctParticleColor;
  v_vctColor.a = vctParticleColor.a;
      #else
  v_vctColor = vctParticleColor;
      #endif
    #else
    // always full opacity for now...
      #if defined(LIGHT)
  v_vctColor.a = 1.0;
      #endif
    #endif
}`;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    var Shader_1;
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    // TODO: define attribute/uniforms as layout and use those consistently in shaders
    let Shader = class Shader {
        static { Shader_1 = this; }
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Shader_1; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        /** The type of coat that can be used with this shader to create a material */
        static getCoat() { return FudgeCore.CoatColored; }
        /** Returns the vertex shader source code for the render engine */
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderUniversal.vert"], this.define);
        }
        /** Returns the fragment shader source code for the render engine */
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderUniversal.frag"], this.define);
        }
        /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */
        static deleteProgram() { }
        /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */
        static useProgram() { }
        /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */ // TODO: maybe don't flag this as internal, so shaders can be precompiled in future FUDGE apps. Or create an API to precompile shaders, load textures etc.
        static createProgram() { }
        static registerSubclass(_subclass) { return Shader_1.subclasses.push(_subclass) - 1; }
        // replace the mandatory header of the shader with itself plus the definitions given
        static insertDefines(_shader, _defines) {
            if (!_defines)
                return _shader;
            let code = "#version 300 es\n";
            for (let define of _defines)
                code += `#define ${define}\n`;
            return _shader.replace("#version 300 es", code);
        }
    };
    Shader = Shader_1 = __decorate([
        FudgeCore.RenderInjectorShader.decorate
    ], Shader);
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlat extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "FLAT"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatSkin); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "FLAT",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderFlatSkin = ShaderFlatSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTextured); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "FLAT",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderFlatTextured = ShaderFlatTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTexturedSkin); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "FLAT",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderFlatTexturedSkin = ShaderFlatTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraud extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraud); }
        static { this.define = [
            "LIGHT",
            "CAMERA"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderGouraud = ShaderGouraud;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudSkin); }
        static { this.define = [
            "LIGHT",
            "SKIN",
            "CAMERA"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderGouraudSkin = ShaderGouraudSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTextured); }
        static { this.define = [
            "LIGHT",
            "TEXTURE",
            "CAMERA"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderGouraudTextured = ShaderGouraudTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTexturedSkin); }
        static { this.define = [
            "LIGHT",
            "TEXTURE",
            "CAMERA",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderGouraudTexturedSkin = ShaderGouraudTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLit extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLit); }
        static { this.define = []; }
    }
    FudgeCore.ShaderLit = ShaderLit;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitSkin); }
        static { this.define = [
            "SKIN"
        ]; }
    }
    FudgeCore.ShaderLitSkin = ShaderLitSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTextured); }
        static { this.define = [
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderLitTextured = ShaderLitTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTexturedSkin); }
        static { this.define = [
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderLitTexturedSkin = ShaderLitTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderMatCap extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap); }
        static { this.define = [
            "MATCAP",
            "CAMERA"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhong extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhong); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "PHONG"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderPhong = ShaderPhong;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongSkin); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "PHONG",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderPhongSkin = ShaderPhongSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTextured); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "PHONG",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderPhongTextured = ShaderPhongTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTexturedSkin); }
        static { this.define = [
            "LIGHT",
            "CAMERA",
            "PHONG",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPhong.frag"], this.define);
        }
    }
    FudgeCore.ShaderPhongTexturedSkin = ShaderPhongTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPick extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.frag"], this.define);
        }
    }
    FudgeCore.ShaderPick = ShaderPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPickTextured extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPickTextured.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPickTextured.frag"], this.define);
        }
    }
    FudgeCore.ShaderPickTextured = ShaderPickTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MIPMAP;
    (function (MIPMAP) {
        MIPMAP[MIPMAP["CRISP"] = 0] = "CRISP";
        MIPMAP[MIPMAP["MEDIUM"] = 1] = "MEDIUM";
        MIPMAP[MIPMAP["BLURRY"] = 2] = "BLURRY";
    })(MIPMAP = FudgeCore.MIPMAP || (FudgeCore.MIPMAP = {}));
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Texture = class Texture extends FudgeCore.Mutable {
        constructor(_name = "Texture") {
            super();
            this.idResource = undefined;
            this.mipmap = MIPMAP.CRISP;
            this.name = _name;
        }
        /**
         * Generates and binds the texture in WebGL from the {@link texImageSource}.
         * Injected by {@link RenderInjectorTexture}. Used by the render system.
         * @internal
         */
        useRenderData() { }
        /**
         * Deletes the texture in WebGL freeing the allocated gpu memory.
         * Injected by {@link RenderInjectorTexture}.
         * @internal
         */
        deleteRenderData() { }
        /**
         * Refreshes the image data in the render engine.
         */
        refresh() {
            this.deleteRenderData();
        }
        //#region Transfer
        serialize() {
            let serialization = {
                idResource: this.idResource,
                name: this.name,
                mipmap: MIPMAP[this.mipmap]
            };
            return serialization;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            this.mipmap = MIPMAP[_serialization.mipmap];
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.mipmap)
                types.mipmap = MIPMAP;
            return types;
        }
        reduceMutator(_mutator) {
            delete _mutator.idResource;
            delete _mutator.renderData;
        }
    };
    Texture = __decorate([
        FudgeCore.RenderInjectorTexture.decorate
    ], Texture);
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor(_url) {
            super();
            this.image = null;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get texImageSource() {
            return this.image;
        }
        /**
         * Asynchronously loads the image from the given url
         */
        async load(_url) {
            this.url = _url;
            this.image = new Image();
            // const response: Response = await window.fetch(this.url);
            // const blob: Blob = await response.blob();
            // let objectURL: string = URL.createObjectURL(blob);
            // this.image.src = objectURL;
            return new Promise((_resolve, _reject) => {
                this.image.addEventListener("load", () => {
                    this.renderData = null; // refresh render data on next draw call
                    _resolve();
                });
                this.image.addEventListener("error", () => _reject());
                this.image.src = new URL(this.url.toString(), FudgeCore.Project.baseURL).toString();
            });
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                type: this.type,
                [super.constructor.name]: super.serialize()
            };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.load(_serialization.url);
            // this.type is an accessor of Mutable doesn't need to be deserialized
            return this;
        }
        async mutate(_mutator) {
            if (_mutator.url != this.url.toString())
                await this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            super.mutate(_mutator);
            // TODO: examine necessity to reconstruct, if mutator is kept by caller
            // _mutator.url = this.url; 
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureBase64 extends Texture {
        constructor(_name, _base64, _mipmap = MIPMAP.CRISP) {
            super(_name);
            this.image = new Image();
            this.image.src = _base64;
            this.mipmap = _mipmap;
        }
        get texImageSource() {
            return this.image;
        }
    }
    FudgeCore.TextureBase64 = TextureBase64;
    /**
     * Texture created from a canvas
     */
    class TextureCanvas extends Texture {
        constructor(_name, _crc2) {
            super(_name);
            this.crc2 = _crc2;
        }
        get texImageSource() {
            return this.crc2.canvas;
        }
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class TextureDefault extends FudgeCore.TextureBase64 {
        static { this.texture = new TextureDefault("TextureDefault", TextureDefault.get(), FudgeCore.MIPMAP.MEDIUM); }
        static get() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADWLSURBVHhe7d0HnFTlvf/xH9uXZYGl9yrSRJpEUexYsJIba8Re498WNcZEb+41epOIsWs0Niyxm2g0duwaewO7oqJCAGnSt7H/8304B4dldpk5Z3b3zO7nzeu85pwzM8vMs7PPb35PO61qPBZjrVq18vfiKebFR/lFRPlFQ/lFE/fyy/FvAQBICwEEABAKAQQAEAp9IBHRhhoN5RcN5RdNSyg//YzCwkJr3bq1O169erXbMoEAEhF/wNFQftFQftE09/LLzc21Ll262E9+8hMbP368VVdX2+uvv27Tp093QSTq+yeARMQfcDSUXzSUXzTNtfxycnKspKTEBg0aZEceeaQdeuihtmLFCvvss89s3rx59vjjj9vDDz8cOROJHECqqqps9uzZtmzZMlu5cqVLldq1a2d9+/Z1+1HxAYyG8ouG8ouG8osmTPnl5+db9+7dbffdd7dTTz3V1cXvvvuuvfzyyy4DkVWrVtmNN95oS5YsccdhhQ4g5eXl9uyzz9qMGTNszZo1/tkfKQIq+u29995WWlrqn00fH8BoKL9oKL9oKL9o0ik/PbZNmza2xRZb2HHHHWeTJ0+2hQsX2pNPPmmLFy/2H7XOf/7zH7v11ltdPR5FqACyYMECu+eee1KKXmvXrrX99tvPRo8e7YJKuvgARkP5RROUnz67+iKUl5dnlZWVtnz58li8dj5/0TSn8lOT1b777msXXHCBde7c2V577TV78803k77Hb7/91u644w6rqKjwz4STdgBRtqHUJ4hoChCffPKJffXVV649rX379jZgwAC3BZQuTZo0ybbbbjuXXqWDD2A0lF80Qfl17NjRjjnmGOvUqZN988039sADD7gvUk39+vn8RdOcyq9r1642depU23rrre3RRx91X3JEdbSasIqLi23YsGHuXKYCSNopgXrvg+Ch/o/77rvPvVi9+J///Od29NFH29ChQ90LDGj4mNIlBZm4/8LQssycOdM1xb766qtJm2JF2UfPnj3t17/+tU2YMMF23XVXO/bYY11QQfM1f/58u+mmm1zfgfp44071sV6zPstB8FA9rC/8Tz31lOsXybS0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";
        }
    }
    FudgeCore.TextureDefault = TextureDefault;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles controlled by xrSession.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST_XR"] = "frameRequestXR";
        /** Loop cycles with the given framerate in {@link Time.game} */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of {@link Time.game} */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a FUDGE application. Initializes automatically and must be started explicitly.
     * It then fires {@link EVENT.LOOP_FRAME} to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Loop extends FudgeCore.EventTargetStatic {
        static { this.∆íTimeStartGame = 0; }
        static { this.∆íTimeStartReal = 0; }
        static { this.∆íTimeFrameGame = 0; }
        static { this.∆íTimeFrameReal = 0; }
        static { this.∆íTimeFrameStartGame = 0; }
        static { this.∆íTimeFrameStartReal = 0; }
        static { this.∆íTimeLastFrameGameAvg = 0; }
        static { this.∆íTimeLastFrameRealAvg = 0; }
        static { this.∆íFrames = 0; }
        static { this.running = false; }
        static { this.mode = LOOP_MODE.FRAME_REQUEST; }
        static { this.idIntervall = 0; }
        static { this.idRequest = 0; }
        static { this.fpsDesired = 30; }
        static { this.framesToAverage = 30; }
        static { this.syncWithAnimationFrame = false; }
        /** The gametime the loop was started, overwritten at each start */
        static get timeStartGame() { return Loop.∆íTimeStartGame; }
        /** The realtime the loop was started, overwritten at each start */
        static get timeStartReal() { return Loop.∆íTimeStartReal; }
        /** The gametime elapsed since the last loop cycle */
        static get timeFrameGame() { return Loop.∆íTimeFrameGame; }
        /** The realtime elapsed since the last loop cycle */
        static get timeFrameReal() { return Loop.∆íTimeFrameReal; }
        /** The gametime the last loop cycle started*/
        static get timeFrameStartGame() { return Loop.∆íTimeFrameStartGame; }
        /** The realtime the last loop cycle started*/
        static get timeFrameStartReal() { return Loop.∆íTimeFrameStartReal; }
        /** The average number of frames per second in gametime */
        static get fpsGameAverage() { return 1000 / Loop.∆íTimeLastFrameGameAvg; }
        /** The average number of frames per second in realtime */
        static get fpsRealAverage() { return 1000 / Loop.∆íTimeLastFrameRealAvg; }
        /** The number of frames triggered so far */
        static get frames() { return Loop.∆íFrames; }
        /**
         * Starts the loop with the given mode and fps.
         * The default for _mode is FRAME_REQUEST, see {@link LOOP_MODE}, hooking the loop to the browser's animation frame.
         * Is only applicable in TIME-modes.
         * _syncWithAnimationFrame is experimental and only applicable in TIME-modes, deferring the loop-cycle until the next possible animation frame.
         */
        static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
            Loop.stop();
            Loop.∆íTimeStartGame = FudgeCore.Time.game.get();
            Loop.∆íTimeStartReal = performance.now();
            Loop.∆íTimeFrameStartGame = Loop.∆íTimeStartGame;
            Loop.∆íTimeFrameStartReal = Loop.∆íTimeStartReal;
            Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
            Loop.framesToAverage = Loop.fpsDesired;
            Loop.∆íTimeLastFrameGameAvg = Loop.∆íTimeLastFrameRealAvg = 1000 / Loop.fpsDesired;
            Loop.mode = _mode;
            Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
            let log = `Loop starting in mode ${Loop.mode}`;
            if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                log += ` with attempted ${_fps} fps`;
            FudgeCore.Debug.fudge(log);
            switch (_mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    Loop.loopFrame();
                    break;
                case LOOP_MODE.FRAME_REQUEST_XR:
                    Loop.loopFrameXR();
                    break;
                case LOOP_MODE.TIME_REAL:
                    Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                    Loop.loopTime();
                    break;
                case LOOP_MODE.TIME_GAME:
                    Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                    Loop.loopTime();
                    break;
                default:
                    break;
            }
            Loop.running = true;
        }
        /**
         * Stops the loop
         */
        static stop() {
            if (!Loop.running)
                return;
            switch (Loop.mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.FRAME_REQUEST_XR:
                    FudgeCore.XRViewport.default.session.cancelAnimationFrame(Loop.idRequest);
                    FudgeCore.XRViewport.default.session = null;
                    break;
                case LOOP_MODE.TIME_REAL:
                    window.clearInterval(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_GAME:
                    FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                default:
                    break;
            }
            Loop.running = false;
            FudgeCore.Debug.fudge("Loop stopped!");
        }
        /**
         * Continue running the loop
         */
        static continue() {
            if (Loop.running)
                return;
            Loop.start(Loop.mode, Loop.fpsDesired, Loop.syncWithAnimationFrame);
        }
        static loop() {
            let time;
            time = performance.now();
            Loop.∆íTimeFrameReal = time - Loop.∆íTimeFrameStartReal;
            Loop.∆íTimeFrameStartReal = time;
            time = FudgeCore.Time.game.get();
            Loop.∆íTimeFrameGame = time - Loop.∆íTimeFrameStartGame;
            Loop.∆íTimeFrameStartGame = time;
            Loop.∆íTimeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameGameAvg + Loop.∆íTimeFrameGame) / Loop.framesToAverage;
            Loop.∆íTimeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameRealAvg + Loop.∆íTimeFrameReal) / Loop.framesToAverage;
            // TODO: consider LoopEvent which conveys information such as timeElapsed etc...
            Loop.∆íFrames++;
            let event = new Event("loopFrame" /* EVENT.LOOP_FRAME */);
            Loop.targetStatic.dispatchEvent(event);
        }
        static loopFrame() {
            Loop.loop();
            Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
        }
        static loopFrameXR(_time = null, _xrFrame = null) {
            Loop.loop();
            FudgeCore.XRViewport.default.draw(true, _xrFrame);
            Loop.idRequest = FudgeCore.XRViewport.default.session.requestAnimationFrame(Loop.loopFrameXR);
        }
        static loopTime() {
            if (Loop.syncWithAnimationFrame)
                Loop.idRequest = window.requestAnimationFrame(Loop.loop);
            else
                Loop.loop();
        }
    }
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports {@link Timer}s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Time extends FudgeCore.EventTargetUnified {
        /** Standard game time starting automatically with the application */
        static { this.game = new Time(); }
        constructor() {
            super();
            this.timers = {};
            this.idTimerAddedLast = 0;
            this.start = performance.now();
            this.scale = 1.0;
            this.offset = 0.0;
            this.lastCallToElapsed = 0.0;
        }
        /**
         * Returns representions of the time given in milliseconds in various formats defined in {@link TimeUnits}
         */
        static getUnits(_milliseconds) {
            let units = {};
            units.asSeconds = _milliseconds / 1000;
            units.asMinutes = units.asSeconds / 60;
            units.asHours = units.asMinutes / 60;
            units.hours = Math.floor(units.asHours);
            units.minutes = Math.floor(units.asMinutes) % 60;
            units.seconds = Math.floor(units.asSeconds) % 60;
            units.fraction = _milliseconds % 1000;
            units.thousands = _milliseconds % 10;
            units.hundreds = _milliseconds % 100 - units.thousands;
            units.tenths = units.fraction - units.hundreds - units.thousands;
            return units;
        }
        //#region Get/Set time and scaling
        /**
         * Retrieves the current scaled timestamp of this instance in milliseconds
         */
        get() {
            return this.offset + this.scale * (performance.now() - this.start);
        }
        /**
         * Returns the remaining time to the given point of time
         */
        getRemainder(_to) {
            return _to - this.get();
        }
        /**
         * (Re-) Sets the timestamp of this instance
         * @param _time The timestamp to represent the current time (default 0.0)
         */
        set(_time = 0) {
            this.offset = _time;
            this.start = performance.now();
            this.getElapsedSincePreviousCall();
        }
        /**
         * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
         * @param _scale The desired scaling (default 1.0)
         */
        setScale(_scale = 1.0) {
            this.set(this.get());
            this.scale = _scale;
            //TODO: catch scale=0
            this.rescaleAllTimers();
            this.getElapsedSincePreviousCall();
            this.dispatchEvent(new Event("timeScaled" /* EVENT.TIME_SCALED */));
        }
        /**
         * Retrieves the current scaling of this time
         */
        getScale() {
            return this.scale;
        }
        /**
         * Retrieves the offset of this time
         */
        getOffset() {
            return this.offset;
        }
        /**
         * Retrieves the scaled time in milliseconds passed since the last call to this method
         * Automatically reset at every call to set(...) and setScale(...)
         */
        getElapsedSincePreviousCall() {
            let current = this.get();
            let elapsed = current - this.lastCallToElapsed;
            this.lastCallToElapsed = current;
            return elapsed;
        }
        //#endregion
        //#region Timers
        /**
         * Returns a Promise<void> to be resolved after the time given. To be used with async/await
         */
        delay(_lapse) {
            return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
        }
        // TODO: examine if web-workers would enhance performance here!
        /**
         * Stops and deletes all {@link Timer}s attached. Should be called before this Time-object leaves scope
         */
        clearAllTimers() {
            for (let id in this.timers) {
                this.deleteTimer(Number(id));
            }
        }
        /**
         * Deletes {@link Timer} found using the internal id of the connected interval-object
         * @param _id
         */
        deleteTimerByItsInternalId(_id) {
            for (let id in this.timers) {
                let timer = this.timers[id];
                if (timer.id == _id) {
                    timer.clear();
                    delete this.timers[id];
                    // TODO: check if an early out is OK here... should be!
                }
            }
        }
        /**
         * Installs a timer at this time object
         * @param _lapse The object-time to elapse between the calls to _callback
         * @param _count The number of calls desired, 0 = Infinite
         * @param _handler The function to call each the given lapse has elapsed
         * @param _arguments Additional parameters to pass to callback function
         */
        setTimer(_lapse, _count, _handler, ..._arguments) {
            // tslint:disable-next-line: no-unused-expression
            new FudgeCore.Timer(this, _lapse, _count, _handler, _arguments);
            //this.addTimer(timer);
            return this.idTimerAddedLast;
        }
        /**
         * This method is called internally by {@link Time} and {@link Timer} and must not be called otherwise
         */
        addTimer(_timer) {
            this.timers[++this.idTimerAddedLast] = _timer;
            return this.idTimerAddedLast;
        }
        /**
         * Deletes the timer with the id given by this time object
         */
        deleteTimer(_id) {
            let timer = this.timers[_id];
            if (!timer)
                return;
            timer.clear();
            delete this.timers[_id];
        }
        /**
         * Returns a reference to the timer with the given id or null if not found.
         */
        getTimer(_id) {
            return this.timers[_id];
        }
        /**
         * Returns a copy of the list of timers currently installed on this time object
         */
        getTimers() {
            let result = {};
            return Object.assign(result, this.timers);
        }
        /**
         * Returns true if there are {@link Timers} installed to this
         */
        hasTimers() {
            return (Object.keys(this.timers).length > 0);
        }
        /**
         * Recreates {@link Timer}s when scaling changes
         */
        rescaleAllTimers() {
            for (let id in this.timers) {
                let timer = this.timers[id];
                timer.clear();
                delete this.timers[id];
                if (!this.scale)
                    // Time has stopped, no need to replace cleared timers
                    continue;
                /* this.timers[id] =  */
                timer = timer.installCopy(); // the timer is automatically added to this time instance
                delete this.timers[this.idTimerAddedLast]; // remove the copy again ...
                this.timers[id] = timer; // ... and place it at the id of the original
            }
        }
    }
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Timer}-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an {@link EventTimer}-instance with additional information and given arguments.
     * The frequency scales with the {@link Time}-instance the {@link Timer}-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a {@link Timer} instance.
         * @param _time The {@link Time} instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The {@link TimerHandler} instance to call
         * @param _arguments Additional arguments to pass to _handler
         *
         * TODO: for proper handling and deletion, use Time.setTimer instead of instantiating timers yourself.
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, _arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                if (!this.active)
                    return;
                this.event.count = this.count;
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, _arguments);
            this.active = true;
            _time.addTimer(this);
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same {@link Time}-instance. Used internally when rescaling {@link Time}
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0RlYnVnL0RlYnVnVGFyZ2V0LnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnSW50ZXJmYWNlcy50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0NvbnNvbGUudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWcudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnQudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9NdXRhYmxlLnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vU2VyaWFsaXplci50cyIsIi4uL1NvdXJjZS9HcmFwaC9Ob2RlLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnQudHMiLCIuLi9Tb3VyY2UvUmVjeWNsZS9SZWN5Y2FibGVBcnJheS50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3IudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yU2hhZGVyLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3RvckNvYXQudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yTWVzaC50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9SZWN5Y2xlL1JlY3ljbGVyLnRzIiwiLi4vU291cmNlL01hdGgvVmVjdG9yMi50cyIsIi4uL1NvdXJjZS9NYXRoL1JlY3RhbmdsZS50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVyV2ViR0wudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yVGV4dHVyZS50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0hlbHBlcnNQaHlzaWNzLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnQudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludEF4aWFsLnRzIiwiLi4vU291cmNlL1JlZmVyZW5jZXMudHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbi50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uRnVuY3Rpb24udHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbktleS50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uU2VxdWVuY2UudHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvblNwcml0ZS50cyIsIi4uL1NvdXJjZS9BdWRpby9BdWRpby50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0F1ZGlvL0F1ZGlvTWFuYWdlci50cyIsIi4uL1NvdXJjZS9BdWRpby9BdWRpb09zY2lsbGF0b3IudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudEFuaW1hdG9yLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpby50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50QXVkaW9MaXN0ZW5lci50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50Q2FtZXJhLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRGYWNlQ2FtZXJhLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRHcmFwaEZpbHRlci50cyIsIi4uL1NvdXJjZS9MaWdodC9MaWdodC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50TGlnaHQudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudE1hdGVyaWFsLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRNZXNoLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRQYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50UGljay50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50U2NyaXB0LnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRTa2VsZXRvbi50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50VHJhbnNmb3JtLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRWUkRldmljZS50cyIsIi4uL1NvdXJjZS9Db250cm9sL0NvbnRyb2wudHMiLCIuLi9Tb3VyY2UvQ29udHJvbC9BeGlzLnRzIiwiLi4vU291cmNlL0NvbnRyb2wvS2V5Ym9hcmQudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWdBbGVydC50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0RpYWxvZy50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z1RleHRBcmVhLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50S2V5Ym9hcmQudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRUaW1lci50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudFRvdWNoLnRzIiwiLi4vU291cmNlL0dyYXBoL0dyYXBoLnRzIiwiLi4vU291cmNlL0dyYXBoL0dyYXBoSW5zdGFuY2UudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvQ29hdC50cyIsIi4uL1NvdXJjZS9NYXRlcmlhbC9Db2F0Q29sb3JlZC50cyIsIi4uL1NvdXJjZS9NYXRlcmlhbC9Db2F0UmVtaXNzaXZlLnRzIiwiLi4vU291cmNlL01hdGVyaWFsL0NvYXRUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9NYXRlcmlhbC9Db2F0UmVtaXNzaXZlVGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvQ29sb3IudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvTWF0ZXJpYWwudHMiLCIuLi9Tb3VyY2UvTWF0aC9DYWxjLnRzIiwiLi4vU291cmNlL01hdGgvRnJhbWluZy50cyIsIi4uL1NvdXJjZS9NYXRoL0dlbzIudHMiLCIuLi9Tb3VyY2UvTWF0aC9HZW8zLnRzIiwiLi4vU291cmNlL01hdGgvTEZJQjQudHMiLCIuLi9Tb3VyY2UvTWF0aC9NYXRyaXgzeDMudHMiLCIuLi9Tb3VyY2UvTWF0aC9NYXRyaXg0eDQudHMiLCIuLi9Tb3VyY2UvTWF0aC9Ob2lzZS50cyIsIi4uL1NvdXJjZS9NYXRoL05vaXNlMi50cyIsIi4uL1NvdXJjZS9NYXRoL05vaXNlMy50cyIsIi4uL1NvdXJjZS9NYXRoL05vaXNlNC50cyIsIi4uL1NvdXJjZS9NYXRoL1F1YXRlcm5pb24udHMiLCIuLi9Tb3VyY2UvTWF0aC9SYW5kb20udHMiLCIuLi9Tb3VyY2UvTWF0aC9WZWN0b3IzLnRzIiwiLi4vU291cmNlL01lc2gvRmFjZS50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2gudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoQ3ViZS50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hQb2x5Z29uLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaEV4dHJ1c2lvbi50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hGcm9tRGF0YS50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hJbXBvcnQudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUHlyYW1pZC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hRdWFkLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFRlcnJhaW4udHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUmVsaWVmLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFJvdGF0aW9uLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3Rvck1lc2hTa2luLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFNraW4udHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoU3BoZXJlLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFNwcml0ZS50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hUb3J1cy50cyIsIi4uL1NvdXJjZS9NZXNoL1F1YWQudHMiLCIuLi9Tb3VyY2UvTWVzaC9WZXJ0ZXgudHMiLCIuLi9Tb3VyY2UvTWVzaC9WZXJ0aWNlcy50cyIsIi4uL1NvdXJjZS9NZXNoL0xvYWRlci9NZXNoTG9hZGVyLnRzIiwiLi4vU291cmNlL01lc2gvTG9hZGVyL01lc2hMb2FkZXJGQlgudHMiLCIuLi9Tb3VyY2UvTWVzaC9Mb2FkZXIvTWVzaExvYWRlckdMVEYudHMiLCIuLi9Tb3VyY2UvTWVzaC9Mb2FkZXIvTWVzaExvYWRlck9CSi50cyIsIi4uL1NvdXJjZS9QYXJ0aWNsZVN5c3RlbS9QYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9QYXJ0aWNsZVN5c3RlbS9TaGFkZXJQYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0NvbXBvbmVudFJpZ2lkYm9keS50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0RlYnVnUGh5c2ljc0RyYXcudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludEN5bGluZHJpY2FsLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnRQcmlzbWF0aWMudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludFJhZ2RvbGwudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludFJldm9sdXRlLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnRTcGhlcmljYWwudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludFVuaXZlcnNhbC50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0pvaW50V2VsZGluZy50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL1BoeXNpY3MudHMiLCIuLi9Tb3VyY2UvUmF5L0JveC50cyIsIi4uL1NvdXJjZS9SYXkvUGljay50cyIsIi4uL1NvdXJjZS9SYXkvUGlja2VyLnRzIiwiLi4vU291cmNlL1JheS9SYXkudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlci50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVyTWVzaC50cyIsIi4uL1NvdXJjZS9SZW5kZXIvVmlld3BvcnQudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1hSVmlld3BvcnQudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9GaWxlSW9Ccm93c2VyTG9jYWwudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9NdXRhYmxlQXJyYXkudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9Qcm9qZWN0LnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vRkJYL0J1ZmZlclJlYWRlci50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL0ZCWC9GQlgudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9GQlgvRkJYTG9hZGVyLnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vRkJYL0ZCWE5vZGUudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9GQlgvbG9hZEZyb21Ob2Rlcy50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL0ZCWC9wYXJzZU5vZGVzRnJvbUJpbmFyeS50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL0dMVEYvR0xURi50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL0dMVEYvR0xURkxvYWRlci50cyIsIi4uL1NvdXJjZS9TaGFkZXIvTWVyZ2VkU2hhZGVyU291cmNlcy50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJGbGF0LnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJGbGF0U2tpbi50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyRmxhdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJGbGF0VGV4dHVyZWRTa2luLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJHb3VyYXVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJHb3VyYXVkU2tpbi50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyR291cmF1ZFRleHR1cmVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJHb3VyYXVkVGV4dHVyZWRTa2luLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJMaXQudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlckxpdFNraW4udHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlckxpdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9TaGFkZXJMaXRUZXh0dXJlZFNraW4udHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlck1hdENhcC50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyUGhvbmcudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlclBob25nU2tpbi50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyUGhvbmdUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyUGhvbmdUZXh0dXJlZFNraW4udHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlclBpY2sudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL1NoYWRlclBpY2tUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9UZXh0dXJlL1RleHR1cmUudHMiLCIuLi9Tb3VyY2UvVGV4dHVyZS9UZXh0dXJlRGVmYXVsdC50cyIsIi4uL1NvdXJjZS9UaW1lL0xvb3AudHMiLCIuLi9Tb3VyY2UvVGltZS9UaW1lLnRzIiwiLi4vU291cmNlL1RpbWUvVGltZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQVUsU0FBUyxDQW9CbEI7QUFwQkQsV0FBVSxTQUFTO0lBQ2pCOztPQUVHO0lBQ0gsTUFBc0IsV0FBVztRQUcvQjs7V0FFRztRQUNJLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBZ0IsRUFBRSxHQUFHLEtBQWU7WUFDL0QsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsMkJBQTJCO1lBQ2xFLEtBQUssSUFBSSxHQUFHLElBQUksS0FBSztnQkFDbkIsSUFBSSxHQUFHLFlBQVksTUFBTTtvQkFDdkIsR0FBRyxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsK0JBQStCOztvQkFFNUUsR0FBRyxJQUFJLElBQUks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WUFDM0MsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FB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Q0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQ2hCO2dCQUNFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFH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QUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBRTlCLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ3JELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztZQUV6QyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNyRCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDekMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDdEQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzFDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ3RELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztZQUUxQyxJQUFJLENBQUMsR0FBVyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFFbEUsTUFBTSxTQUFTLEdBQWMsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JELFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNqQixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUUsT0FBTzthQUNyRyxDQUFDLENBQUM7WUFDSCxPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO1FBRUQ7Ozs7V0FJRztRQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBcUIsRUFBRSxPQUFnQixFQUFFLE1BQWUsVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsWUFBcUIsS0FBSztZQUNuSCxNQUFNLFNBQVMsR0FBYyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFD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SUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTztZQUNaLElBQUksQ0FBQyxHQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2hDLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBRTlCLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ3JELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztZQUV6QyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNyRCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDekMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDdEQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzFDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ3RELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztZQUUxQyxJQUFJLENBQUMsR0FBVyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFFbEUsTUFBTSxNQUFNLEdBQWMsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO2dCQUNkLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxFQUFFO2dCQUNOLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3JGLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3JGLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZGLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdB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QUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQ3JELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxDQUFDO29CQUN2QixDQUFDLENBQUMsR0FBRztvQkFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUM3RCxNQUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQ3JELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxDQUFDO29CQUN2QixDQUFDLENBQUMsR0FBRztvQkFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUM3RCxNQUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQ3JELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxDQUFDO29CQUN2QixDQUFDLENBQUMsR0FBRztvQkFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUU3RCxtRUFBbUU7Z0JBQ25FLGtEQUFrRDtnQkFDbEQsT0FBTyxpQkFBaUIsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ2pELENBQUMsQ0FBQztRQUNKLENBQUM7O0lBN0ZVLGdCQUFNLFNBa0dsQixDQUFBO0FBQ0gsQ0FBQyxFQWpIUyxTQUFTLEtBQVQsU0FBUyxRQWlIbEI7QUNqSEQsSUFBVSxTQUFTLENBOEpsQjtBQTlKRCxXQUFVLFNBQVM7SUFDakIsYUFBYTtJQUNiOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsTUFBYSxNQUFPLFNBQVEsVUFBQSxLQUFLO2lCQUNoQixXQUFNLEdBQVcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQUFBeEMsQ0FBeUM7aUJBQy9DLGFBQVEsR0FBZSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxF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O2dCQUMzQyxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQzNDLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQywrQ0FBK0M7Z0JBQ2pHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxnREFBZ0Q7Z0JBQ2xHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyw4Q0FBOEM7Z0JBQ2pHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2xELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2xELE1B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QUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDMUUsTUFBTSxFQUFFLEdBQVcsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQy9ELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxDQUFDO29CQUN2QixDQUFDLENBQUMsR0FBRztvQkFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzFFLE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUMvRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsQ0FBQztvQkFDdkIsQ0FBQyxDQUFDLEdBQUc7b0JBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxNQUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFFMUUsd0RBQXdEO2dCQUN4RCxPQUFPLGlCQUFpQixHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ3RELENBQUMsQ0FBQztRQUNKLENBQUM7O0lBMUlVLGdCQUFNLFNBK0lsQixDQUFBO0FBQ0gsQ0FBQyxFQTlKUyxTQUFTLEtBQVQsU0FBUyxRQThKbEI7QUM5SkQsSUFBVSxTQUFTLENBc1VsQjtBQXRVRCxXQUFVLFNBQVM7SUFDakI7Ozs7OztRQU1JO0lBQ0osTUFBYSxVQUFXLFNBQVEsVUFBQSxPQUFPO1FBTzVCLFlBQVksQ0FBMkIsQ0FBQyw0REFBNEQ7UUFDN0csaUJBQWlCLENBQVU7UUFFM0IsWUFBbUIsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDO1lBQy9FLEtBQUssRUFBRSxDQUFDO1lBTkYsWUFBTyxHQUFZLElBQUksQ0FBQyxDQUFDLDZIQUE2SDtZQUVySixpQkFBWSxHQUFZLFVBQUEsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsNERBQTREO1lBSzNHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUVELGlCQUFpQjtRQUNqQjs7V0FFRztRQUNJLE1BQU0sQ0FBQyxRQUFRO1lBQ3BCLE1BQU0sTUFBTSxHQUFlLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNwRCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRU0sTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFjO1lBQ3hDLE1BQU0sTUFBTSxHQUFlLEVBQUUsQ0FBQyxLQUFLLENBQUM7WUFDcEMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ25CLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLFlBQXFCO1lBQzFDLE1BQU0sTUFBTSxHQUFlLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNwRCxNQUFNLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQztZQUNsQyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7Ozs7V0FJRztRQUNJLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBa0IsRUFBRSxPQUFtQjtZQUNsRSxNQUFNLE1BQU0sR0FBZSxNQUFNLENBQUMsS0FBSyxDQUFDO1lBQ3hDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDekIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBYztZQUNwQyxNQUFNLE1BQU0sR0FBZSxFQUFFLENBQUMsS0FBSyxDQUFDO1lBQ3BDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNqQixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFjO1lBQ3RDLE1BQU0sTUFBTSxHQUFlLEVBQUUsQ0FBQyxLQUFLLENBQUM7WUFDcEMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ25CLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBZSxFQUFFLEdBQWU7WUFDaEQsT0FBTyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdkUsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFpQixFQUFFLEdBQWUsRUFBRSxPQUFlO1lBQ3BFLElBQUksTUFBTSxHQUFlLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNsRCxNQUFNLENBQUMsR0FBRyxDQUNSLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUMzQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFDM0MsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQzNDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUM1QyxDQUFDO1lBQ0YsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ25CLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBaUIsRUFBRSxHQUFlLEVBQUUsT0FBZTtZQUNyRSwwRkFBMEY7WUFDMUYsSUFBSSxZQUFZLEdBQVcsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2pHLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO2dCQUM3QixPQUFPLEtBQUssQ0FBQztZQUNmLElBQUksU0FBUyxHQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDaEQsSUFBSSxZQUFZLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsWUFBWSxHQUFHLFlBQVksQ0FBQyxDQUFDO1lBQ3RFLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxLQUFLLEVBQUU7Z0JBQ2xDLElBQUksTUFBTSxHQUFlLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDbEQsTUFBTSxDQUFDLEdBQUcsQ0FDUixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQzdCLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFDN0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUM3QixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQzlCLENBQUM7Z0JBQ0YsT0FBTyxNQUFNLENBQUM7YUFDZjtZQUNELElBQUksTUFBTSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsWUFBWSxDQUFDO1lBQ3hFLElBQUksTUFBTSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxHQUFHLFlBQVksQ0FBQztZQUNsRSxJQUFJLE1BQU0sR0FBZSxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEQsTUFBTSxDQUFDLEdBQUcsQ0FDUixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEVBQ25DLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsRUFDbkMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUNuQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQ3BDLENBQUM7WUFFRixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQsWUFBWTtRQUVaOztXQUVHO1FBQ0gsSUFBVyxLQUFLO1lBQ2QsSUFBSSxNQUFNLEdBQWUsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNDLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7O1dBR0c7UUFDSCxJQUFXLFdBQVc7WUFDcEIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7Z0JBQzFCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7Z0JBRS9CLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQzVELElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQy9CLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztpQkFDMUI7Z0JBRUQseUJBQXlCO2dCQUN6QixJQUFJLFFBQVEsR0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQy9ELElBQUksUUFBUSxHQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ25FLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUVyRCwwQkFBMEI7Z0JBQzFCLElBQUksSUFBSSxHQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0QsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7b0JBQ3JCLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQ0FBaUM7O29CQUVsSCxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUV4Qyx3QkFBd0I7Z0JBQ3hCLElBQUksUUFBUSxHQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0QsSUFBSSxRQUFRLEdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBRXJELElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLFVBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ3ZDO1lBRUQsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBQzNCLENBQUM7UUFFRCxJQUFXLFdBQVcsQ0FBQyxZQUFxQjtZQUMxQyxNQUFNLG1CQUFtQixHQUFZLFVBQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsVUFBQSxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ25GLE1BQU0sSUFBSSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckQsTUFBTSxJQUFJLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyRCxNQUFNLElBQUksR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JELE1BQU0sSUFBSSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckQsTUFBTSxJQUFJLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyRCxNQUFNLElBQUksR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXJELElBQUksQ0FBQyxHQUFHLENBQ04sSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEVBQ3ZDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxFQUN2QyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksRUFDdkMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQ3hDLENBQUM7WUFFRixJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO1FBQ2pDLENBQUM7UUFFRDs7V0FFRztRQUNJLFNBQVM7WUFDZCxJQUFJLE1BQU0sR0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDdEYsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7WUFDakIsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7WUFDakIsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7WUFDakIsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7WUFDakIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTTtZQUNYLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDYixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNiLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDYixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDbEIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxPQUFPO1lBQ1osSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN2QixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxPQUFPO1lBQ1osNENBQTRDO1lBQzVDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNuQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxTQUFTO1lBQ2QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNiLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDYixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUSxDQUFDLE1BQWtCLEVBQUUsWUFBcUIsS0FBSztZQUM1RCxNQUFNLENBQUMsR0FBZSxTQUFTLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxHQUFlLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDaEQsaUdBQWlHO1lBQ2pHLE1BQU0sRUFBRSxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxFQUFFLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QixNQUFNLEVBQUUsR0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU0sRUFBRSxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxFQUFFLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QixNQUFNLEVBQUUsR0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU0sRUFBRSxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxFQUFFLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV2QixJQUFJLENBQUMsR0FBRyxDQUNOLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQ3JDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFDdEMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFDckMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUN2QyxDQUFDO1FBQ0osQ0FBQztRQUVEOztXQUVHO1FBQ0ksR0FBRyxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVU7WUFDdkQsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDbkQsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVE7WUFDYixPQUFPLG1CQUFtQixJQUFJLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDaEYsQ0FBQztRQUVELHlHQUF5RztRQUNsRyxTQUFTO1lBQ2QsSUFBSSxhQUFhLEdBQWtCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNyRCxhQUFhLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEYsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7WUFDcEQsSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksUUFBUSxFQUFFO2dCQUN2QyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFrQixjQUFjLENBQUMsQ0FBQzthQUNoRjs7Z0JBQ0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUM5QixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFTSxVQUFVO1lBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPO2dCQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN0QixDQUFDO1FBRU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFpQjtZQUNuQyxJQUFJLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUVTLGFBQWEsQ0FBQyxRQUFpQixJQUFnQixDQUFDO1FBRWxELFVBQVU7WUFDaEIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQztZQUM5QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUN0QixDQUFDO0tBQ0Y7SUE3VFksb0JBQVUsYUE2VHRCLENBQUE7QUFDSCxDQUFDLEVBdFVTLFNBQVMsS0FBVCxTQUFTLFFBc1VsQjtBQ3RVRCxJQUFVLFNBQVMsQ0FpSWxCO0FBaklELFdBQVUsU0FBUztJQUNqQjs7Ozs7T0FLRztJQUNILE1BQWEsTUFBTTtpQkFDSCxZQUFPLEdBQVcsSUFBSSxNQUFNLEVBQUUsQUFBdkIsQ0FBd0I7UUFHN0M7Ozs7V0FJRztRQUNILFlBQW1CLGVBQW1DO1lBUDlDLGFBQVEsR0FBYSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBUXZDLElBQUksZUFBZSxZQUFZLFFBQVE7Z0JBQ3JDLElBQUksQ0FBQyxRQUFRLEdBQUcsZUFBZSxDQUFDO2lCQUM3QixJQUFJLGVBQWUsSUFBSSxTQUFTO2dCQUNuQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7O2dCQUU1QixZQUFZO2dCQUNaLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxVQUFBLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxPQUFPO1lBQ1osT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDekIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUSxDQUFDLElBQVksRUFBRSxJQUFZO1lBQ3hDLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNoRCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxlQUFlLENBQUMsSUFBWSxFQUFFLElBQVk7WUFDL0MsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDL0MsQ0FBQztRQUVEOztXQUVHO1FBQ0ksVUFBVTtZQUNmLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLEdBQUcsQ0FBQztRQUMvQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxPQUFPO1lBQ1osT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUSxDQUFJLE1BQWdCO1lBQ2pDLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDO2dCQUNuQixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNoRCxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ1osQ0FBQztRQUVEOztXQUVHO1FBQ0ksVUFBVSxDQUFJLE1BQWdCO1lBQ25DLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDO2dCQUNuQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDdkMsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUksTUFBZ0I7WUFDL0IsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEQsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFPLElBQWU7WUFDakMsSUFBSSxJQUFJLEdBQVksS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUM1QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksZUFBZSxDQUFJLE9BQVU7WUFDbEMsSUFBSSxJQUFJLEdBQWEsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pELE9BQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksaUJBQWlCLENBQUksT0FBVTtZQUNwQyxJQUFJLElBQUksR0FBYSxNQUFNLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDM0QsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUM7UUFFRDs7V0FFRztRQUNJLFVBQVUsQ0FBQyxRQUFpQixFQUFFLFFBQWlCO1lBQ3BELE9BQU8sSUFBSSxVQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFJLENBQUM7UUFFRDs7V0FFRztRQUNJLFVBQVUsQ0FBQyxRQUFpQixFQUFFLFFBQWlCO1lBQ3BELE9BQU8sSUFBSSxVQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuRyxDQUFDOztJQW5IVSxnQkFBTSxTQW9IbEIsQ0FBQTtJQUVEOztPQUVHO0lBQ1UsZ0JBQU0sR0FBVyxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQzdDLENBQUMsRUFqSVMsU0FBUyxLQUFULFNBQVMsUUFpSWxCO0FDaklELElBQVUsU0FBUyxDQTJkbEI7QUEzZEQsV0FBVSxTQUFTO0lBQ2pCOzs7Ozs7Ozs7T0FTRztJQUNILE1BQWEsT0FBUSxTQUFRLFVBQUEsT0FBTztRQUdsQyxZQUFtQixLQUFhLENBQUMsRUFBRSxLQUFhLENBQUMsRUFBRSxLQUFhLENBQUM7WUFDL0QsS0FBSyxFQUFFLENBQUM7WUFDUixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFFRCxnQkFBZ0I7UUFDaEI7O1dBRUc7UUFDSSxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQWlCLENBQUM7WUFDaEMsTUFBTSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN6QixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQWlCLENBQUM7WUFDaEMsTUFBTSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN6QixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQWlCLENBQUM7WUFDaEMsTUFBTSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2hDLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxJQUFJO1lBQ2hCLE1BQU0sTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5QyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDcEIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFpQixDQUFDO1lBQ2xDLE1BQU0sTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5QyxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDbkMsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUdEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFnQixFQUFFLFVBQWtDLEVBQUUsc0JBQStCLElBQUk7WUFDcEgsSUFBSSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUU5QixJQUFJLFVBQVUsWUFBWSxVQUFBLFNBQVMsRUFBRTtnQkFDbkMsSUFBSSxDQUFDLEdBQWlCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFFdkMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDMUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDMUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFFM0MsSUFBSSxtQkFBbUIsRUFBRTtvQkFDdkIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7aUJBQ3BDO2FBQ0Y7aUJBQU07Z0JBQ0wsd0dBQXdHO2dCQUN4RyxxRUFBcUU7Z0JBQ3JFLHdDQUF3QztnQkFFeEMsc0RBQXNEO2dCQUN0RCxNQUFNLEVBQUUsR0FBVyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDMUUsTUFBTSxFQUFFLEdBQVcsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzFFLE1BQU0sRUFBRSxHQUFXLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUMxRSxNQUFNLEVBQUUsR0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUUzRSxnQkFBZ0I7Z0JBQ2hCLE1BQU0sQ0FBQyxHQUFHLENBQ1IsRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBRSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQ25GLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFFLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBRSxVQUFVLENBQUMsQ0FBQyxFQUNuRixFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBRSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFFLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUUsVUFBVSxDQUFDLENBQUMsQ0FDcEYsQ0FBQzthQUNIO1lBRUQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLGFBQWEsQ0FBQyxPQUFnQixFQUFFLFVBQWtCLENBQUM7WUFDL0QsSUFBSSxnQkFBZ0IsR0FBVyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7WUFDeEQsSUFBSSxnQkFBZ0IsSUFBSSxDQUFDO2dCQUN2QixNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDO1lBQ3JELElBQUksTUFBTSxHQUFZLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDcEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7WUFDcEQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQW1CO1lBQ3RDLElBQUksTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM1QyxLQUFLLElBQUksTUFBTSxJQUFJLFFBQVE7Z0JBQ3pCLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1RSxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQWlCLEVBQUUsV0FBb0I7WUFDOUQsSUFBSSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvRixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQWdCLEVBQUUsUUFBZ0I7WUFDcEQsSUFBSSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztZQUM3RSxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQzFDLElBQUksTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM1QyxNQUFNLENBQUMsR0FBRyxDQUNSLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQ3pCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQ3pCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQzFCLENBQUM7WUFDRixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBQ0Q7O1dBRUc7UUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQ3hDLElBQUksYUFBYSxHQUFXLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3BFLE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFFRDs7Ozs7Ozs7V0FRRztRQUNJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBa0IsRUFBRSxPQUFnQjtZQUMzRCxJQUFJLEdBQUcsR0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ25ELElBQUksVUFBVSxHQUFZLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2xGLE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBa0IsRUFBRSxRQUFpQjtZQUN2RCxJQUFJLE1BQU0sR0FBWSxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDNUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pGLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBcUIsQ0FBQyxFQUFFLFlBQW9CLENBQUMsRUFBRSxhQUFxQixDQUFDO1lBQ3JGLElBQUksTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBUyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQSxJQUFJLENBQUMsQ0FBQztZQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDM0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDakIsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3BCLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBYyxFQUFFLEdBQVk7WUFDOUMsSUFBSSxLQUFLLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDM0YsT0FBTyxLQUFLLEdBQUcsVUFBQSxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzlCLENBQUM7UUFDRCxZQUFZO1FBRVosbUJBQW1CO1FBQ25CLG1DQUFtQztRQUNuQyxJQUFXLENBQUM7WUFDVixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsQ0FBQztRQUNELElBQVcsQ0FBQztZQUNWLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBQ0QsSUFBVyxDQUFDO1lBQ1YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLENBQUM7UUFFRCxJQUFXLENBQUMsQ0FBQyxFQUFVO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxJQUFXLENBQUMsQ0FBQyxFQUFVO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxJQUFXLENBQUMsQ0FBQyxFQUFVO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFFRDs7V0FFRztRQUNILElBQVcsU0FBUztZQUNsQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEMsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBVyxnQkFBZ0I7WUFDekIsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNqQyxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLEtBQUs7WUFDZCxJQUFJLEtBQUssR0FBWSxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDM0MsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzFCLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVEOzs7V0FHRztRQUNILElBQVcsR0FBRyxDQUFDLElBQVU7WUFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQUEsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3JELElBQUksQ0FBQyxTQUFTLENBQUMsVUFBQSxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELENBQUM7UUFDRCxJQUFXLEdBQUc7WUFDWixJQUFJLEdBQUcsR0FBUyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQSxJQUFJLENBQUMsQ0FBQztZQUNuQyxHQUFHLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7WUFFL0IsSUFBSSxHQUFHLENBQUMsU0FBUyxLQUFLLENBQUM7Z0JBQ3JCLE9BQU8sR0FBRyxDQUFDO1lBRWIsR0FBRyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUMzRixHQUFHLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDakUsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDO1FBQ0QsWUFBWTtRQUVMLE9BQU87WUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxJQUFJLENBQUMsU0FBa0I7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsUUFBaUIsRUFBRSxhQUFxQixNQUFNLENBQUMsT0FBTztZQUNsRSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVTtnQkFBRSxPQUFPLEtBQUssQ0FBQztZQUM3RCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVTtnQkFBRSxPQUFPLEtBQUssQ0FBQztZQUM3RCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVTtnQkFBRSxPQUFPLEtBQUssQ0FBQztZQUM3RCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLFlBQVksQ0FBQyxRQUFpQixFQUFFLFFBQWlCO1lBQ3RELElBQUksUUFBUSxHQUFZLE9BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQy9ELElBQUksUUFBUSxHQUFZLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzNELElBQUksS0FBSyxHQUFZLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZELElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO2dCQUM1QixPQUFPLEtBQUssQ0FBQztZQUNmLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO2dCQUM1QixPQUFPLEtBQUssQ0FBQztZQUNmLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDO2dCQUM1QixPQUFPLEtBQUssQ0FBQztZQUNmLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksY0FBYyxDQUFDLE9BQWdCLEVBQUUsT0FBZTtZQUNyRCxJQUFJLFVBQVUsR0FBWSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM1RCxPQUFPLFVBQVUsQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQztRQUMzRCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxHQUFHLENBQUMsT0FBZ0I7WUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUUsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUSxDQUFDLFdBQW9CO1lBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFGLENBQUM7UUFFRDs7V0FFRztRQUNJLEtBQUssQ0FBQyxPQUFlO1lBQzFCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hFLENBQUM7UUFFRDs7V0FFRztRQUNJLFNBQVMsQ0FBQyxVQUFrQixDQUFDO1lBQ2xDLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ3hELENBQUM7UUFFRDs7V0FFRztRQUNJLEdBQUcsQ0FBQyxLQUFhLENBQUMsRUFBRSxLQUFhLENBQUMsRUFBRSxLQUFhLENBQUM7WUFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksR0FBRztZQUNSLE9BQU8sSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRDs7OztXQUlHO1FBQ0ksU0FBUyxDQUFDLFVBQWtDLEVBQUUsc0JBQStCLElBQUk7WUFDdEYsSUFBSSxXQUFXLEdBQVksT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLG1CQUFtQixDQUFDLENBQUM7WUFDekYsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hDLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM5QixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxTQUFTO1lBQ2QsT0FBTyxJQUFJLFVBQUEsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRDs7V0FFRztRQUNJLE9BQU8sQ0FBQyxPQUFnQjtZQUM3QixNQUFNLFNBQVMsR0FBWSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM3RCxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEQsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzVCLENBQUM7UUFFRDs7V0FFRztRQUNJLE9BQU87WUFDWixJQUFJLENBQUMsR0FBYSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQUEsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBQSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxXQUFXLENBQUMsR0FBWTtZQUM3QixJQUFJLFVBQVUsR0FBWSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztZQUN4RCxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDM0IsT0FBTyxVQUFVLENBQUMsU0FBUyxDQUFDO1FBQzlCLENBQUM7UUFFRDs7V0FFRztRQUNJLEdBQUcsQ0FBQyxRQUFpQjtZQUMxQixJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QyxDQUFDO1FBQ0Q7O1dBRUc7UUFDSSxHQUFHLENBQUMsUUFBaUI7WUFDMUIsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUTtZQUNiLElBQUksTUFBTSxHQUFXLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztZQUN0RyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksR0FBRyxDQUFDLFNBQXdFO1lBQ2pGLElBQUksSUFBSSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMxQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELGtCQUFrQjtRQUNYLFNBQVM7WUFDZCxJQUFJLGFBQWEsR0FBa0IsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3JELGdIQUFnSDtZQUNoSCxhQUFhLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzdFLE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFFTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQTZCO1lBQ3BELElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLFFBQVEsRUFBRTtnQkFDdkMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQWtCLGNBQWMsQ0FBQyxDQUFDO2FBQ3hFOztnQkFDQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBaUI7WUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUVNLFVBQVU7WUFDZixJQUFJLE9BQU8sR0FBWSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDN0UsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQztRQUNTLGFBQWEsQ0FBQyxRQUFpQixJQUFnQixDQUFDO0tBRTNEO0lBL2NZLGlCQUFPLFVBK2NuQixDQUFBO0FBQ0gsQ0FBQyxFQTNkUyxTQUFTLEtBQVQsU0FBUyxRQTJkbEI7QUMzZEQsSUFBVSxTQUFTLENBb0RsQjtBQXBERCxXQUFVLFNBQVM7SUFDakI7Ozs7T0FJRztJQUNILE1BQWEsSUFBSTtRQU1mLFlBQW1CLFNBQW1CLEVBQUUsT0FBZSxFQUFFLE9BQWUsRUFBRSxPQUFlO1lBTGxGLFlBQU8sR0FBYSxFQUFFLENBQUM7WUFNNUIsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7WUFDMUIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDMUIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksV0FBVyxDQUFDLE1BQWM7WUFDL0IsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDdEQsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUSxDQUFDLE1BQWU7WUFDN0IsSUFBSSxLQUFLLEdBQWMsRUFBRSxDQUFDO1lBQzFCLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDOUIsSUFBSSxJQUFJLEdBQVksVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM5RSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2xCO1lBQ0QsSUFBSSxFQUFFLEdBQVksVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwRCxJQUFJLEVBQUUsR0FBWSxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BELElBQUksRUFBRSxHQUFZLFVBQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFcEQsSUFBSSxJQUFJLEdBQVcsVUFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN2QyxJQUFJLElBQUksR0FBVyxVQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRXZDLE9BQU8sQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLENBQUM7UUFFTyxnQkFBZ0I7WUFDdEIsSUFBSSxNQUFNLEdBQWMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDN0YsSUFBSSxFQUFFLEdBQVksVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRCxJQUFJLEVBQUUsR0FBWSxVQUFBLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNELElBQUksQ0FBQyxjQUFjLEdBQUcsVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM1QyxJQUFJLENBQUMsTUFBTSxHQUFHLFVBQUEsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDM0QsQ0FBQztLQUNGO0lBN0NZLGNBQUksT0E2Q2hCLENBQUE7QUFDSCxDQUFDLEVBcERTLFNBQVMsS0FBVCxTQUFTLFFBb0RsQjtBQ3BERCxJQUFVLFNBQVMsQ0F1SWxCO0FBdklELFdBQVUsU0FBUzs7SUFDakI7Ozs7O09BS0c7SUFFSCxJQUFzQixJQUFJLEdBQTFCLE1BQXNCLElBQUssU0FBUSxVQUFBLE9BQU87O1FBQ3hDLGtHQUFrRztpQkFDM0UsY0FBUyxHQUFnQixNQUFJLEFBQXBCLENBQXFCO1FBQ3JELHFGQUFxRjtpQkFDOUQsZUFBVSxHQUFrQixFQUFFLEFBQXBCLENBQXFCO1FBc0J0RCxZQUFtQixRQUFnQixNQUFNO1lBQ3ZDLEtBQUssRUFBRSxDQUFDO1lBckJWLDJJQUEySTtZQUMzSSwrRUFBK0U7WUFDL0UsR0FBRztZQUVJLGVBQVUsR0FBVyxTQUFTLENBQUM7WUFDL0IsU0FBSSxHQUFXLE1BQU0sQ0FBQztZQUM3QixxQ0FBcUM7WUFDOUIsYUFBUSxHQUFhLElBQUksVUFBQSxRQUFRLEVBQUUsQ0FBQztZQUNwQyxVQUFLLEdBQVcsRUFBRSxDQUFDO1lBY3hCLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNiLFVBQUEsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixDQUFDO1FBRVMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQXNCLElBQVksT0FBTyxNQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWpILElBQVcsSUFBSTtZQUNiLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7UUFDL0IsQ0FBQztRQUVELElBQVcsV0FBVztZQUNwQixJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSTtnQkFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUV2QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbkIsQ0FBQztRQUNELElBQVcsTUFBTTtZQUNmLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJO2dCQUN0QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUVyQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQztRQUVEOzs7O1dBSUc7UUFDSSxnQkFBZ0IsQ0FBQyxPQUF3QixFQUFFLGVBQTBCLEVBQUUsY0FBeUIsRUFBRSxHQUFZLElBQW1CLE9BQU8sSUFBSSxDQUFDLENBQUMsK0JBQStCLENBQUMsQ0FBQztRQUN0TDs7OztXQUlHO1FBQ0ksZ0JBQWdCLENBQUMsT0FBd0IsSUFBbUIsT0FBTyxJQUFJLENBQUMsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1FBQ2pIOzs7O1dBSUc7UUFDSSxtQkFBbUIsQ0FBQyxPQUF3QixJQUF5QyxDQUFDO1FBRTdGOztXQUVHO1FBQ0ksS0FBSztZQUNWLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDO1lBQ3RCLElBQUksQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO1lBRXpCLElBQUksQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLENBQUM7UUFDM0IsQ0FBQztRQUVELGtCQUFrQjtRQUNsQix5RUFBeUU7UUFDbEUsU0FBUztZQUNkLElBQUksYUFBYSxHQUFrQjtnQkFDakMsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO2dCQUMzQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7Z0JBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsd0JBQXdCO2FBQ3pDLENBQUMsQ0FBQyxxQkFBcUI7WUFDeEIsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUNNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7WUFDcEQsVUFBQSxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDO1lBQ2hDLG1EQUFtRDtZQUNuRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFUyxhQUFhLENBQUMsUUFBaUI7WUFDdkMsK0RBQStEO1lBQy9ELE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQztZQUNyQixPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUM7WUFFeEIsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDO1FBQ2hDLENBQUM7UUFDRCxZQUFZO1FBR0YsWUFBWTtZQUNwQixnRkFBZ0Y7WUFDaEYsSUFBSSxNQUFNLEdBQVcsQ0FBQyxDQUFDO1lBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDckQsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDdkU7WUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUVTLGlCQUFpQjtZQUN6QixJQUFJLEdBQUcsR0FBUSxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQSxHQUFHLENBQUMsQ0FBQztZQUNqQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDVixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JELElBQUksS0FBSyxHQUFZLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMvQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ25CO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDOztJQTdIbUIsSUFBSTtRQUR6QixVQUFBLGtCQUFrQixDQUFDLFFBQVE7T0FDTixJQUFJLENBOEh6QjtJQTlIcUIsY0FBSSxPQThIekIsQ0FBQTtBQUNILENBQUMsRUF2SVMsU0FBUyxLQUFULFNBQVMsUUF1SWxCO0FDdklELElBQVUsU0FBUyxDQStDbEI7QUEvQ0QsV0FBVSxTQUFTO0lBQ2pCOzs7Ozs7Ozs7T0FTRztJQUNILE1BQWEsUUFBUyxTQUFRLFVBQUEsSUFBSTtpQkFDVCxjQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFM0UsWUFBbUIsUUFBZ0IsVUFBVTtZQUMzQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFYix1RUFBdUU7WUFDdkUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFVBQUEsUUFBUTtZQUMxQixpQkFBaUI7WUFDakIsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUk7WUFDaEUsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUNqRSxJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUNoRSxJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUc7YUFDOUQsQ0FBQztZQUVGLDZCQUE2QjtZQUM3QixLQUFLLElBQUksS0FBSyxHQUFXLEVBQUUsRUFBRSxLQUFLLEdBQUcsR0FBRyxFQUFFLEtBQUssSUFBSSxFQUFFLEVBQUU7Z0JBQ3JELElBQUksU0FBUyxHQUFjLFVBQUEsU0FBUyxDQUFDLFFBQVEsQ0FBQyxVQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDaEUsSUFBSSxJQUFJLEdBQWEsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQVUsRUFBRSxFQUFFLENBQ2hFLElBQUksVUFBQSxNQUFNLENBQUMsVUFBQSxPQUFPLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7YUFDN0I7WUFDRCx1Q0FBdUM7WUFDdkMsS0FBSyxJQUFJLEtBQUssR0FBVyxFQUFFLEVBQUUsS0FBSyxHQUFHLEdBQUcsRUFBRSxLQUFLLElBQUksR0FBRyxFQUFFO2dCQUN0RCxJQUFJLFNBQVMsR0FBYyxVQUFBLFNBQVMsQ0FBQyxRQUFRLENBQUMsVUFBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ2hFLElBQUksSUFBSSxHQUFhLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFVLEVBQUUsRUFBRSxDQUNoRSxJQUFJLFVBQUEsTUFBTSxDQUFDLFVBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNyRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO2FBQzdCO1lBRUQsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7WUFDaEIsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQztnQkFDcEMsaUJBQWlCO2dCQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEYsQ0FBQzs7SUFsQ1Usa0JBQVEsV0FtQ3BCLENBQUE7QUFDSCxDQUFDLEVBL0NTLFNBQVMsS0FBVCxTQUFTLFFBK0NsQjtBQy9DRCxJQUFVLFNBQVMsQ0FtR2xCO0FBbkdELFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBYSxXQUFZLFNBQVEsVUFBQSxJQUFJO2lCQUNaLGNBQVMsR0FBVyxVQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQUFBN0MsQ0FBOEM7aUJBQzdELGlCQUFZLEdBQWM7WUFDekMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuQixJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNsQixJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDbEIsQUFKNEIsQ0FJM0I7UUFJRixZQUFtQixRQUFnQixhQUFhLEVBQUUsU0FBb0IsV0FBVyxDQUFDLFlBQVksRUFBRSxjQUF1QixJQUFJO1lBQ3pILEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUpMLFVBQUssR0FBMEIsSUFBSSxVQUFBLFlBQVksQ0FBVSxVQUFBLE9BQU8sQ0FBQyxDQUFDO1lBSzFFLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ25DLENBQUM7UUFFRCxJQUFjLFdBQVc7WUFDdkIsT0FBTyxDQUFDLENBQUM7UUFDWCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsU0FBb0IsRUFBRSxFQUFFLGNBQXVCLElBQUk7WUFDL0QsSUFBSSxDQUFDLEtBQUssR0FBMEIsVUFBQSxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM1RixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQztZQUU5QixJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDcEMsVUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFdBQVcsZ0VBQWdFLENBQUMsQ0FBQztnQkFDekcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUM1QyxPQUFPO2FBQ1I7WUFFRCxJQUFJLEtBQUssR0FBYyxNQUFNLENBQUM7WUFFOUIsSUFBSSxHQUFHLEdBQVksVUFBQSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbEMsSUFBSSxHQUFHLEdBQVksVUFBQSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFVBQUEsUUFBUSxFQUFFLENBQUM7WUFDL0IsS0FBSyxJQUFJLE1BQU0sSUFBSSxLQUFLLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFFbkQsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbEMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ25DO1lBQ0QsSUFBSSxJQUFJLEdBQVksSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFOUQsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNuQixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDN0MsSUFBSSxTQUFTLEdBQVksVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDM0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxVQUFBLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNuRjthQUNGO2lCQUFNO2dCQUNMLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLFVBQUEsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM1RjtZQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7Z0JBQ25ELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFELENBQUM7UUFFRCxrQkFBa0I7UUFDWCxTQUFTO1lBQ2QsSUFBSSxhQUFhLEdBQWtCLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyRCxhQUFhLENBQUMsS0FBSyxHQUFHLFVBQUEsVUFBVSxDQUFDLGNBQWMsQ0FBQyxVQUFBLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckUsYUFBYSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQzNDLE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFDTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQTZCO1lBQ3BELE1BQU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUN4QyxJQUFJLE9BQU8sR0FBeUIsTUFBTSxVQUFBLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDNUYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2hELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBaUI7WUFDbkMsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssNkJBQWMsQ0FBQyxDQUFDO1FBQzlDLENBQUM7UUFFUyxhQUFhLENBQUMsUUFBaUI7WUFDdkMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoQyxDQUFDOztJQXBGVSxxQkFBVyxjQXNGdkIsQ0FBQTtBQUNILENBQUMsRUFuR1MsU0FBUyxLQUFULFNBQVMsUUFtR2xCO0FDbkdELHFDQUFxQztBQUNyQyxJQUFVLFNBQVMsQ0F1SGxCO0FBeEhELHFDQUFxQztBQUNyQyxXQUFVLFNBQVM7SUFDakI7Ozs7Ozs7Ozs7T0FVRztJQUNILE1BQWEsYUFBYyxTQUFRLFVBQUEsV0FBVztpQkFDckIsY0FBUyxHQUFXLFVBQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxBQUEvQyxDQUFnRDtpQkFDL0QsZ0JBQVcsR0FBZ0I7WUFDMUMsVUFBQSxTQUFTLENBQUMsV0FBVyxDQUFDLFVBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQyxVQUFBLFNBQVMsQ0FBQyxXQUFXLENBQUMsVUFBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDdkMsQUFIMkIsQ0FHMUI7UUFHRixZQUFtQixRQUFnQixlQUFlLEVBQUUsWUFBdUIsVUFBQSxXQUFXLENBQUMsWUFBWSxFQUFFLGlCQUE4QixhQUFhLENBQUMsV0FBVyxFQUFFLGNBQXVCLElBQUk7WUFDdkwsS0FBSyxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFIL0Isa0JBQWEsR0FBNEIsSUFBSSxVQUFBLFlBQVksQ0FBQyxVQUFBLFNBQVMsQ0FBQyxDQUFDO1lBSTNFLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDN0IsNkNBQTZDO1FBQy9DLENBQUM7UUFFRCxrQkFBa0I7UUFDWCxTQUFTO1lBQ2QsSUFBSSxhQUFhLEdBQWtCLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyRCxhQUFhLENBQUMsVUFBVSxHQUFHLFVBQUEsVUFBVSxDQUFDLGNBQWMsQ0FBQyxVQUFBLFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDcEYsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7WUFDcEQsTUFBTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3hDLElBQUksYUFBMEIsQ0FBQztZQUMvQixJQUFJLGNBQWMsQ0FBQyxVQUFVO2dCQUMzQixhQUFhLEdBQWdCLE1BQU0sVUFBQSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzVGLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDNUIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFpQjtZQUNuQyxNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDakMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssNkJBQWMsQ0FBQyxDQUFDO1FBQzlDLENBQUM7UUFFUyxhQUFhLENBQUMsUUFBaUI7WUFDdkMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoQyxDQUFDO1FBQ0QsWUFBWTtRQUVKLE9BQU8sQ0FBQyxpQkFBOEIsYUFBYSxDQUFDLFdBQVc7WUFDckUsSUFBSSxDQUFDLGFBQWEsR0FBNEIsVUFBQSxZQUFZLENBQUMsSUFBSSxDQUEwQixjQUFjLENBQUMsQ0FBQztZQUN6RyxJQUFJLFdBQVcsR0FBVyxjQUFjLENBQUMsTUFBTSxDQUFDO1lBQ2hELElBQUksY0FBYyxHQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBRWxELDJEQUEyRDtZQUMzRCxJQUFJLFFBQVEsR0FBYSxJQUFJLFVBQUEsUUFBUSxFQUFFLENBQUM7WUFFeEMsZ0VBQWdFO1lBQ2hFLElBQUksSUFBSSxHQUFhLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLFVBQUEsTUFBTSxDQUFDLFVBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN4SSxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDdkIsOERBQThEO1lBQzlELElBQUksR0FBRyxHQUFhLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLFVBQUEsTUFBTSxDQUFDLFVBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDckosUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBRXRCLDZDQUE2QztZQUM3QyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBVyxFQUFFLEVBQUUsQ0FBQyxJQUFJLFVBQUEsSUFBSSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkgsa0hBQWtIO1lBQ2xILElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FDeEMsSUFBSSxVQUFBLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxjQUFjLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxjQUFjLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FDNUgsQ0FBQyxDQUFDO1lBRUgsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDNUMsSUFBSSxZQUFZLEdBQWMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLFlBQVksR0FBVyxRQUFRLENBQUMsTUFBTSxDQUFDO2dCQUMzQyxJQUFJLElBQUksR0FBYSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsRUFBRSxDQUNoRSxJQUFJLFVBQUEsTUFBTSxDQUFDLFVBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLEVBQUUsR0FBRyxjQUFjLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQ3ZILENBQUM7Z0JBQ0YsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO2dCQUN2QixRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxNQUFNLENBQUMsWUFBWSxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLG9DQUFvQztnQkFDcEMsMkdBQTJHO2FBQzVHO1lBRUQsNkJBQTZCO1lBQzdCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDOUMsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDL0MsSUFBSSxLQUFLLEdBQ1AsQ0FBRSxDQUFDLEdBQUcsY0FBYyxDQUFDLDBCQUEwQjswQkFDN0MsQ0FBQyxHQUFHLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDLGlDQUFpQzswQkFDMUQsQ0FBQyxDQUFDO29CQUNOLElBQUksSUFBSSxHQUFTLElBQUksVUFBQSxJQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEdBQUcsY0FBYyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsY0FBYyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUM5SCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDaEM7WUFFSCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUN6QixPQUFPO1FBQ1QsQ0FBQzs7SUF4RlUsdUJBQWEsZ0JBMEd6QixDQUFBO0FBQ0gsQ0FBQyxFQXZIUyxTQUFTLEtBQVQsU0FBUyxRQXVIbEI7QUN4SEQsSUFBVSxTQUFTLENBaUNsQjtBQWpDRCxXQUFVLFNBQVM7SUFFakIscURBQXFEO0lBQ3JELE1BQWEsWUFBYSxTQUFRLFVBQUEsSUFBSTtRQU1wQyxZQUFtQixTQUF1QixFQUFFLFdBQXlCLEVBQUUsUUFBcUIsRUFBRSxZQUEwQjtZQUN0SCxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDO1lBQy9CLElBQUksQ0FBQyxlQUFlLEdBQUcsV0FBVyxDQUFDO1lBQ25DLElBQUksQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDO1lBQzdCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxZQUFZLENBQUM7UUFDdkMsQ0FBQztRQUVTLGNBQWM7WUFDdEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzVCLENBQUM7UUFFUyxnQkFBZ0I7WUFDeEIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQzlCLENBQUM7UUFFUyxhQUFhO1lBQ3JCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztRQUMzQixDQUFDO1FBRVMsaUJBQWlCO1lBQ3pCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO1FBQy9CLENBQUM7S0FDRjtJQTdCWSxzQkFBWSxlQTZCeEIsQ0FBQTtBQUNILENBQUMsRUFqQ1MsU0FBUyxLQUFULFNBQVMsUUFpQ2xCO0FDakNELElBQVUsU0FBUyxDQTBDbEI7QUExQ0QsV0FBVSxTQUFTO0lBQ2pCOzs7T0FHRztJQUNILE1BQWEsVUFBVyxTQUFRLFVBQUEsSUFBSTtRQUkzQixTQUFTO1lBQ2QsTUFBTSxhQUFhLEdBQWtCLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN2RCxhQUFhLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDeEMsYUFBYSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBQSxVQUFVLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZFLE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFFTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQTZCO1lBQ3BELEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLEdBQUcsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDO1lBQzlCLElBQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsVUFBQSxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUN0RixPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQTZCLElBQUksQ0FBQyxNQUFNLEVBQUUsT0FBb0IsSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFjO1lBQ3RHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO1lBQ2hCLElBQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDO1lBQ3RCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVTtnQkFDbEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLFVBQUEsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3pDLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUVNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBaUI7WUFDbkMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN2QixJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssV0FBVztnQkFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QyxDQUFDO0tBRUY7SUFwQ1ksb0JBQVUsYUFvQ3RCLENBQUE7QUFDSCxDQUFDLEVBMUNTLFNBQVMsS0FBVCxTQUFTLFFBMENsQjtBQzFDRCxJQUFVLFNBQVMsQ0EwQ2xCO0FBMUNELFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7O09BU0c7SUFDSCxNQUFhLFdBQVksU0FBUSxVQUFBLElBQUk7aUJBQ1osY0FBUyxHQUFXLFVBQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTlFLFlBQW1CLFFBQWdCLGFBQWE7WUFDOUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2IsaUJBQWlCO1lBRWpCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxVQUFBLFFBQVE7WUFDMUIsa0JBQWtCO1lBQ2xCLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDMUQsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDekQsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUMxRCxJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDM0Qsa0JBQWtCO1lBQ2xCLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQzdELG1DQUFtQztZQUNuQyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUNoQyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUNoQyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUNoQyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUNqQyxDQUFDO1lBQ0YsSUFBSSxDQUFDLEtBQUssR0FBRztnQkFDWCxJQUFJLFVBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2hDLElBQUksVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxVQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLFVBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2hDLElBQUksVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDNUMsSUFBSSxVQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzdDLENBQUM7UUFDSixDQUFDOztJQTdCVSxxQkFBVyxjQThCdkIsQ0FBQTtBQUNILENBQUMsRUExQ1MsU0FBUyxLQUFULFNBQVMsUUEwQ2xCO0FDMUNELElBQVUsU0FBUyxDQXlDbEI7QUF6Q0QsV0FBVSxTQUFTO0lBQ2pCOzs7Ozs7OztPQVFHO0lBQ0gsTUFBYSxRQUFTLFNBQVEsVUFBQSxXQUFXO2lCQUNoQixjQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQzFELFVBQUssR0FBYztZQUNsQyxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQztTQUMvRixDQUFDO1FBRUYsWUFBbUIsUUFBZ0IsVUFBVTtZQUMzQyxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvQixDQUFDO1FBRUQsd0JBQXdCO1FBQ3hCLG9FQUFvRTtRQUNwRSxpRUFBaUU7UUFDakUsd0VBQXdFO1FBRXhFLGtCQUFrQjtRQUNYLFNBQVM7WUFDZCxJQUFJLGFBQWEsR0FBa0IsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3JELE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFDTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQTZCO1lBQ3BELE1BQU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUN4QyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyx3RUFBd0U7WUFDM0csT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBQ1MsYUFBYSxDQUFDLFFBQWlCO1lBQ3ZDLEtBQUssQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDOUIsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDO1lBQ3RCLE9BQU8sUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUM3QixDQUFDOztJQTdCVSxrQkFBUSxXQThCcEIsQ0FBQTtBQUNILENBQUMsRUF6Q1MsU0FBUyxLQUFULFNBQVMsUUF5Q2xCO0FDekNELElBQVUsU0FBUyxDQWtMbEI7QUFsTEQsV0FBVSxTQUFTO0lBVWpCOztPQUVHO0lBQ0gsTUFBYSxXQUFXO0tBYXZCO0lBYlkscUJBQVcsY0FhdkIsQ0FBQTtJQUVEOzs7Ozs7T0FNRztJQUNILE1BQWEsV0FBWSxTQUFRLFVBQUEsSUFBSTtpQkFDWixjQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLEFBQTdDLENBQThDO1FBTTlFLFlBQW1CLFFBQWdCLGFBQWEsRUFBRSxjQUF1QixVQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBdUIsVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsa0JBQThDLENBQUM7WUFDNUssS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBSEwsc0JBQWlCLEdBQXNCLElBQUksQ0FBQztZQUlwRCxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFDekQsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLGNBQXVCLFVBQUEsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxjQUF1QixVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxrQkFBOEMsQ0FBQztZQUN4SSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQztZQUN0QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksVUFBQSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwRixJQUFJLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUM7WUFFL0IsSUFBSSxlQUFlLFlBQVksUUFBUTtnQkFDckMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGVBQWUsQ0FBQztpQkFDdEMsSUFBSSxPQUFPLENBQUMsZUFBZSxDQUFDLElBQUksUUFBUSxFQUFFO2dCQUM3QyxJQUFJLENBQUMsSUFBSSxHQUFHLGVBQWUsQ0FBQztnQkFDNUIsSUFBSSxJQUFJLEdBQVcsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3pDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLFVBQUEsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGlCQUFpQjthQUNwRjs7Z0JBQ0MsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksVUFBQSxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUM7WUFFL0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFVBQUEsUUFBUSxFQUFFLENBQUM7WUFDL0IscURBQXFEO1lBQ3JELEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbkQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNuRCxJQUFJLEtBQUssR0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7b0JBQzFDLElBQUksS0FBSyxHQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztvQkFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLE1BQU0sQ0FDM0IsSUFBSSxVQUFBLE9BQU8sQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUN6RyxJQUFJLFVBQUEsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FDMUIsQ0FBQyxDQUFDO2lCQUNKO2FBQ0Y7WUFFRCxJQUFJLEtBQUssR0FBVyxFQUFFLENBQUM7WUFDdkIsSUFBSSxLQUFLLEdBQWMsVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDO1lBQ3RDLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbEQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNsRCxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxJQUFJLENBQ2pCLElBQUksQ0FBQyxRQUFRLEVBQ2IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsS0FBSyxDQUNOLENBQUMsQ0FBQztvQkFDSCxLQUFLLEdBQUcsQ0FBQyxLQUFLLElBQUksVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDO2lCQUNyRTtnQkFDRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsb0RBQW9EO29CQUNsRixLQUFLLEdBQUcsQ0FBQyxLQUFLLElBQUksVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDO2FBQ3ZFO1lBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBVyxFQUFFLEVBQUUs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QUFDLFFBQVEsQ0FBQztRQUN2QixDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLEtBQUs7WUFDZCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDckIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksV0FBVztZQUNoQixPQUFPLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMzRixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxLQUFLO1lBQ1YseUNBQXlDO1lBQ3pDLHVCQUF1QjtZQUN2Qix1RUFBdUU7WUFDdkUsMkdBQTJHO1lBQzNHLG9DQUFvQztZQUNwQyxJQUFJO1lBQ0osT0FBTztZQUNQLGtIQUFrSDtZQUNsSCxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNwQyxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUN0QixDQUFDO0tBQ0Y7SUE3RlksZUFBSyxRQTZGakIsQ0FBQTtBQUNILENBQUMsRUEzR1MsU0FBUyxLQUFULFNBQVMsUUEyR2xCIiwic291cmNlc0NvbnRlbnQiOlsibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIGZvciB0aGUgZGlmZmVyZW50IERlYnVnVGFyZ2V0cywgbWFpbmx5IGZvciB0ZWNobmljYWwgcHVycG9zZSBvZiBpbmhlcml0YW5jZVxuICAgKi9cbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIERlYnVnVGFyZ2V0IHtcbiAgICBwdWJsaWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGU7XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGUgZ2l2ZW4gbWVzc2FnZSBhbmQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgc3RyaW5nLCBzZXBhcmF0ZWQgYnkgJywgJ1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbWVyZ2VBcmd1bWVudHMoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogc3RyaW5nIHtcbiAgICAgIGxldCBvdXQ6IHN0cmluZyA9IF9tZXNzYWdlLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoX21lc3NhZ2UpO1xuICAgICAgZm9yIChsZXQgYXJnIG9mIF9hcmdzKVxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTnVtYmVyKVxuICAgICAgICAgIG91dCArPSBcIiwgXCIgKyBhcmcudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb3V0ICs9IFwiLCBcIiArIGFyZy50b1N0cmluZygpOyAvL0pTT04uc3RyaW5naWZ5KGFyZywgbnVsbCwgMik7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgfVxufSIsIi8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQWxlcnQudHNcIi8+XG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXJzIGNvcnJlc3BvbmRpbmcgdG8gZGVidWcgYWN0aXZpdGllcywgbW9yZSB0byBjb21lXG4gICAqL1xuICBleHBvcnQgZW51bSBERUJVR19GSUxURVIge1xuICAgIE5PTkUgPSAweDAwLFxuICAgIElORk8gPSAweDAxLFxuICAgIExPRyA9IDB4MDIsXG4gICAgV0FSTiA9IDB4MDQsXG4gICAgRVJST1IgPSAweDA4LFxuICAgIEZVREdFID0gMHgxMCxcbiAgICBDTEVBUiA9IDB4MTAwLFxuICAgIEdST1VQID0gMHgxMDEsXG4gICAgR1JPVVBDT0xMQVBTRUQgPSAweDEwMixcbiAgICBHUk9VUEVORCA9IDB4MTA0LFxuICAgIFNPVVJDRSA9IDB4MjAwLFxuICAgIE1FU1NBR0VTID0gSU5GTyB8IExPRyB8IFdBUk4gfCBFUlJPUiB8IEZVREdFLFxuICAgIEZPUk1BVCA9IENMRUFSIHwgR1JPVVAgfCBHUk9VUENPTExBUFNFRCB8IEdST1VQRU5ELFxuICAgIEFMTCA9IE1FU1NBR0VTIHwgRk9STUFUXG4gIH1cblxuICBleHBvcnQgY29uc3QgREVCVUdfU1lNQk9MOiB7IFtmaWx0ZXI6IG51bWJlcl06IHN0cmluZyB9ID0ge1xuICAgIFtERUJVR19GSUxURVIuSU5GT106IFwi4pyTXCIsXG4gICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBcIuKcjlwiLFxuICAgIFtERUJVR19GSUxURVIuV0FSTl06IFwi4pqgXCIsXG4gICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IFwi4p2MXCIsXG4gICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IFwi8J+OslwiLFxuICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogXCLwn5SXXCJcbiAgfTtcblxuICBleHBvcnQgdHlwZSBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBNYXA8RGVidWdUYXJnZXQsIEZ1bmN0aW9uPjtcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgeyBbZmlsdGVyOiBudW1iZXJdOiBGdW5jdGlvbiB9XG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogUm91dGluZyB0byB0aGUgc3RhbmRhcmQtY29uc29sZVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIERlYnVnQ29uc29sZSBleHRlbmRzIERlYnVnVGFyZ2V0IHtcbiAgICBwdWJsaWMgc3RhdGljIGRlbGVnYXRlczogTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlID0ge1xuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogY29uc29sZS5pbmZvLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBjb25zb2xlLmxvZyxcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IGNvbnNvbGUud2FybixcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBjb25zb2xlLmVycm9yLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQ29uc29sZS5mdWRnZSxcbiAgICAgIFtERUJVR19GSUxURVIuQ0xFQVJdOiBjb25zb2xlLmNsZWFyLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUF06IGNvbnNvbGUuZ3JvdXAsXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VEXTogY29uc29sZS5ncm91cENvbGxhcHNlZCxcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBFTkRdOiBjb25zb2xlLmdyb3VwRW5kLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdOiBEZWJ1Z0NvbnNvbGUuc291cmNlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCBiZSB1c2VkIHRvIGRpc3BsYXkgdW5jcml0aWNhbCBzdGF0ZSBpbmZvcm1hdGlvbiBvZiBGVURHRSwgb25seSB2aXNpYmxlIGluIGJyb3dzZXIncyB2ZXJib3NlIG1vZGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZ1ZGdlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xuICAgICAgY29uc29sZS5kZWJ1ZyhERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkZVREdFXSwgX21lc3NhZ2UsIC4uLl9hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBhbiBleHRyYSBsaW5lIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNvdXJjZSBvZiB0aGUgZGVidWcgbWVzc2FnZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc291cmNlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xuICAgICAgY29uc29sZS5sb2coREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdLCBfbWVzc2FnZSwgLi4uX2FyZ3MpO1xuICAgIH1cbiAgfVxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdJbnRlcmZhY2VzLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQ29uc29sZS50c1wiLz5cbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogVGhlIERlYnVnLUNsYXNzIG9mZmVycyBmdW5jdGlvbnMga25vd24gZnJvbSB0aGUgY29uc29sZS1vYmplY3QgYW5kIGFkZGl0aW9ucywgXG4gICAqIHJvdXRpbmcgdGhlIGluZm9ybWF0aW9uIHRvIHZhcmlvdXMge0BsaW5rIERlYnVnVGFyZ2V0fXMgdGhhdCBjYW4gYmUgZWFzaWx5IGRlZmluZWQgYnkgdGhlIGRldmVsb3BlcnMgYW5kIHJlZ2lzdGVyZCBieSB1c2Vyc1xuICAgKiBPdmVycmlkZSBmdW5jdGlvbnMgaW4gc3ViY2xhc3NlcyBvZiB7QGxpbmsgRGVidWdUYXJnZXR9IGFuZCByZWdpc3RlciB0aGVtIGFzIHRoZWlyIGRlbGVnYXRlc1xuICAgKi9cbiAgZXhwb3J0IGNsYXNzIERlYnVnIHtcbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBzZXQgZmlsdGVyLCB0aGlzIGFzc29jaWF0aXZlIGFycmF5IGtlZXBzIHJlZmVyZW5jZXMgdG8gdGhlIHJlZ2lzdGVyZWQgZGVsZWdhdGUgZnVuY3Rpb25zIG9mIHRoZSBjaG9zZW4ge0BsaW5rIERlYnVnVGFyZ2V0fXNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBkZWxlZ2F0ZXM6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSBEZWJ1Zy5zZXR1cENvbnNvbGUoKTtcblxuICAgIC8qKlxuICAgICAqIERlLSAvIEFjdGl2YXRlIGEgZmlsdGVyIGZvciB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc2V0RmlsdGVyKF90YXJnZXQ6IERlYnVnVGFyZ2V0LCBfZmlsdGVyOiBERUJVR19GSUxURVIpOiB2b2lkIHtcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBEZWJ1Zy5kZWxlZ2F0ZXMpXG4gICAgICAgIERlYnVnLmRlbGVnYXRlc1tmaWx0ZXJdLmRlbGV0ZShfdGFyZ2V0KTtcblxuICAgICAgZm9yIChsZXQgZmlsdGVyIGluIERFQlVHX0ZJTFRFUikge1xuICAgICAgICBsZXQgcGFyc2VkOiBudW1iZXIgPSBwYXJzZUludChmaWx0ZXIpO1xuICAgICAgICBpZiAoaXNOYU4ocGFyc2VkKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKFtERUJVR19GSUxURVIuTUVTU0FHRVMsIERFQlVHX0ZJTFRFUi5GT1JNQVQsIERFQlVHX0ZJTFRFUi5BTExdLmluZGV4T2YocGFyc2VkKSAhPSAtMSlcbiAgICAgICAgICAvLyBkb250IGRlbGVnYXRlIGNvbWJvcy4uLiBcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKF9maWx0ZXIgJiBwYXJzZWQpXG4gICAgICAgICAgRGVidWcuZGVsZWdhdGVzW3BhcnNlZF0uc2V0KF90YXJnZXQsIF90YXJnZXQuZGVsZWdhdGVzW3BhcnNlZF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlsdGVyKHMpIGZvciB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RmlsdGVyKF90YXJnZXQ6IERlYnVnVGFyZ2V0KTogREVCVUdfRklMVEVSIHtcbiAgICAgIGxldCByZXN1bHQ6IERFQlVHX0ZJTFRFUiA9IDA7XG4gICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gX3RhcmdldC5kZWxlZ2F0ZXMpXG4gICAgICAgIHJlc3VsdCB8PSBwYXJzZUludChmaWx0ZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBmaWx0ZXIgdG8gdGhlIGdpdmVuIERlYnVnVGFyZ2V0LiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFkZEZpbHRlcihfdGFyZ2V0OiBEZWJ1Z1RhcmdldCwgX2ZpbHRlcjogREVCVUdfRklMVEVSKTogdm9pZCB7XG4gICAgICBsZXQgY3VycmVudDogREVCVUdfRklMVEVSID0gRGVidWcuZ2V0RmlsdGVyKF90YXJnZXQpO1xuICAgICAgRGVidWcuc2V0RmlsdGVyKF90YXJnZXQsIGN1cnJlbnQgfCBfZmlsdGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBmaWx0ZXIgZnJvbSB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVGaWx0ZXIoX3RhcmdldDogRGVidWdUYXJnZXQsIF9maWx0ZXI6IERFQlVHX0ZJTFRFUik6IHZvaWQge1xuICAgICAgbGV0IGN1cnJlbnQ6IERFQlVHX0ZJTFRFUiA9IERlYnVnLmdldEZpbHRlcihfdGFyZ2V0KTtcbiAgICAgIERlYnVnLnNldEZpbHRlcihfdGFyZ2V0LCBjdXJyZW50IF4gX2ZpbHRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5mbyguLi4pIGRpc3BsYXlzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2l0aCBsb3cgcHJpb3JpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGluZm8oX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5JTkZPLCBfbWVzc2FnZSwgX2FyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBpbmZvcm1hdGlvbiB3aXRoIG1lZGl1bSBwcmlvcml0eVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbG9nKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuTE9HLCBfbWVzc2FnZSwgX2FyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBpbmZvcm1hdGlvbiBhYm91dCBub24tY29uZm9ybWl0aWVzIGluIHVzYWdlLCB3aGljaCBpcyBlbXBoYXNpemVkIGUuZy4gYnkgY29sb3JcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHdhcm4oX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5XQVJOLCBfbWVzc2FnZSwgX2FyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBjcml0aWNhbCBpbmZvcm1hdGlvbiBhYm91dCBmYWlsdXJlcywgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBlcnJvcihfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkVSUk9SLCBfbWVzc2FnZSwgX2FyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBtZXNzYWdlcyBmcm9tIEZVREdFXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmdWRnZShfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkZVREdFLCBfbWVzc2FnZSwgX2FyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIG91dHB1dCBhbmQgcmVtb3ZlcyBwcmV2aW91cyBtZXNzYWdlcyBpZiBwb3NzaWJsZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoKTogdm9pZCB7XG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuQ0xFQVIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIG5ldyBncm91cCBmb3IgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUCwgX25hbWUsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIG5ldyBncm91cCBmb3IgbWVzc2FnZXMgdGhhdCBpcyBjb2xsYXBzZWQgYXQgZmlyc3RcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwQ29sbGFwc2VkKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgX25hbWUsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHlvdW5nZXN0IGdyb3VwXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBncm91cEVuZCgpOiB2b2lkIHtcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUEVORCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBhIGJyYW5jaCBvZiB0aGUgbm9kZSBoaWVyYXJjaHlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJyYW5jaChfYnJhbmNoOiBOb2RlKTogdm9pZCB7XG4gICAgICBpZiAoX2JyYW5jaC5uQ2hpbGRyZW4gPiAwKVxuICAgICAgICBEZWJ1Zy5ncm91cChfYnJhbmNoLm5hbWUpO1xuICAgICAgZWxzZVxuICAgICAgICBEZWJ1Zy5mdWRnZShfYnJhbmNoLm5hbWUpO1xuXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBfYnJhbmNoLmdldENoaWxkcmVuKCkpIERlYnVnLmJyYW5jaChjaGlsZCk7XG5cbiAgICAgIGlmIChfYnJhbmNoLm5DaGlsZHJlbiA+IDApXG4gICAgICAgIERlYnVnLmdyb3VwRW5kKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgbWVzc2FnZXMgYWJvdXQgdGhlIHNvdXJjZSBvZiB0aGUgZGVidWcgY2FsbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc291cmNlKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuU09VUkNFLCBfbWVzc2FnZSwgX2FyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvb2t1cCBhbGwgZGVsZWdhdGVzIHJlZ2lzdGVyZWQgdG8gdGhlIGZpbHRlciBhbmQgY2FsbCB0aGVtIHVzaW5nIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBkZWxlZ2F0ZShfZmlsdGVyOiBERUJVR19GSUxURVIsIF9tZXNzYWdlOiB1bmtub3duLCBfYXJnczogdW5rbm93bltdKTogdm9pZCB7XG4gICAgICBpZiAoX2ZpbHRlciA9PSBERUJVR19GSUxURVIuTE9HIHx8IF9maWx0ZXIgPT0gREVCVUdfRklMVEVSLldBUk4gfHwgX2ZpbHRlciA9PSBERUJVR19GSUxURVIuRVJST1IpIHtcbiAgICAgICAgaWYgKERlYnVnLmRlbGVnYXRlc1tERUJVR19GSUxURVIuU09VUkNFXSlcbiAgICAgICAgICBmb3IgKGxldCBkZWxlZ2F0ZSBvZiBEZWJ1Zy5kZWxlZ2F0ZXNbREVCVUdfRklMVEVSLlNPVVJDRV0udmFsdWVzKCkpXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgbGV0IHRyYWNlOiBzdHJpbmdbXSA9IG5ldyBFcnJvcihcIlRlc3RcIikuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgIGRlbGVnYXRlKHRyYWNlWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBkZWxlZ2F0ZXM6IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSA9IERlYnVnLmRlbGVnYXRlc1tfZmlsdGVyXTtcbiAgICAgIGZvciAobGV0IGRlbGVnYXRlIG9mIGRlbGVnYXRlcy52YWx1ZXMoKSlcbiAgICAgICAgaWYgKGRlbGVnYXRlKVxuICAgICAgICAgIGlmIChfYXJncyAmJiBfYXJncy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UsIC4uLl9hcmdzKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxlZ2F0ZShfbWVzc2FnZSk7XG5cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0dXAgcm91dGluZyB0byBzdGFuZGFyZCBjb25zb2xlXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2V0dXBDb25zb2xlKCk6IHt9IHtcbiAgICAgIGxldCByZXN1bHQ6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSB7fTtcbiAgICAgIGxldCBmaWx0ZXJzOiBERUJVR19GSUxURVJbXSA9IFtcbiAgICAgICAgREVCVUdfRklMVEVSLklORk8sIERFQlVHX0ZJTFRFUi5MT0csIERFQlVHX0ZJTFRFUi5XQVJOLCBERUJVR19GSUxURVIuRVJST1IsIERFQlVHX0ZJTFRFUi5GVURHRSxcbiAgICAgICAgREVCVUdfRklMVEVSLkNMRUFSLCBERUJVR19GSUxURVIuR1JPVVAsIERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgREVCVUdfRklMVEVSLkdST1VQRU5ELFxuICAgICAgICBERUJVR19GSUxURVIuU09VUkNFXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGxldCBmaWx0ZXIgb2YgZmlsdGVycylcbiAgICAgICAgcmVzdWx0W2ZpbHRlcl0gPSBuZXcgTWFwKFtbRGVidWdDb25zb2xlLCBEZWJ1Z0NvbnNvbGUuZGVsZWdhdGVzW2ZpbHRlcl1dXSk7XG5cbiAgICAgIHJlc3VsdFtERUJVR19GSUxURVIuU09VUkNFXS5kZWxldGUoRGVidWdDb25zb2xlKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBFdmVudFR5cGVUb0xpc3RlbmVyIHtcbiAgICBbZXZlbnRUeXBlOiBzdHJpbmddOiBFdmVudExpc3RlbmVyVW5pZmllZFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFR5cGVzIG9mIGV2ZW50cyBzcGVjaWZpYyB0byBGVURHRSwgaW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIERPTS9Ccm93c2VyLVR5cGVzIGFuZCBjdXN0b20gc3RyaW5nc1xuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlQge1xuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHRhcmdldHMgcmVnaXN0ZXJlZCBhdCB7QGxpbmsgTG9vcH0sIHdoZW4gcmVxdWVzdGVkIGFuaW1hdGlvbiBmcmFtZSBzdGFydHMgKi9cbiAgICBMT09QX0ZSQU1FID0gXCJsb29wRnJhbWVcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGFkZGVkIHRvIGEge0BsaW5rIE5vZGV9ICovXG4gICAgQ09NUE9ORU5UX0FERCA9IFwiY29tcG9uZW50QWRkXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgQ29tcG9uZW50fSB3aGVuIGl0cyBiZWluZyByZW1vdmVkIGZyb20gYSB7QGxpbmsgTm9kZX0gKi9cbiAgICBDT01QT05FTlRfUkVNT1ZFID0gXCJjb21wb25lbnRSZW1vdmVcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGFjdGl2YXRlZCAqL1xuICAgIENPTVBPTkVOVF9BQ1RJVkFURSA9IFwiY29tcG9uZW50QWN0aXZhdGVcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGRlYWN0aXZhdGVkICovXG4gICAgQ09NUE9ORU5UX0RFQUNUSVZBVEUgPSBcImNvbXBvbmVudERlYWN0aXZhdGVcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBOb2RlfSwgaXQncyBzdWNjZXNzb3JzIGFuZCBhbmNlc3RvcnMgd2hlbiBpdHMgYmVpbmcgYWN0aXZhdGVkICovXG4gICAgTk9ERV9BQ1RJVkFURSA9IFwibm9kZUFjdGl2YXRlXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgTm9kZX0sIGl0J3Mgc3VjY2Vzc29ycyBhbmQgYW5jZXN0b3JzIHdoZW4gaXRzIGJlaW5nIGRlYWN0aXZhdGVkICovXG4gICAgTk9ERV9ERUFDVElWQVRFID0gXCJub2RlRGVhY3RpdmF0ZVwiLFxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQge0BsaW5rIE5vZGV9IGFuZCBpdHMgYW5jZXN0b3JzIGFmdGVyIGl0IHdhcyBhcHBlbmRlZCB0byBhIHBhcmVudCAqL1xuICAgIENISUxEX0FQUEVORCA9IFwiY2hpbGRBcHBlbmRcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIGNoaWxkIHtAbGluayBOb2RlfSBhbmQgaXRzIGFuY2VzdG9ycyBqdXN0IGJlZm9yZSBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgKi9cbiAgICBDSElMRF9SRU1PVkUgPSBcImNoaWxkUmVtb3ZlXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgTXV0YWJsZX0gd2hlbiBpdCBtdXRhdGVzICovXG4gICAgTVVUQVRFID0gXCJtdXRhdGVcIixcbiAgICAvKiogZGlzcGF0Y2hlZCBieSBhIHtAbGluayBHcmFwaH0gd2hlbiBpdCBtdXRhdGVzLCB7QGxpbmsgR3JhcGhJbnN0YW5jZX1zIGNvbm5lY3RlZCB0byB0aGUgZ3JhcGggbGlzdGVuICovXG4gICAgTVVUQVRFX0dSQVBIID0gXCJtdXRhdGVHcmFwaFwiLFxuICAgIC8qKiBkaXNwYXRjaGVkIGJ5IGEge0BsaW5rIEdyYXBoSW5zdGFuY2V9IHdoZW4gaXQgcmVmbGVjdGVkIHRoZSBtdXRhdGlvbiBvZiB0aGUge0BsaW5rIEdyYXBofSBpdCdzIGNvbm5lY3RlZCB0byAqL1xuICAgIE1VVEFURV9JTlNUQU5DRSA9IFwibXV0YXRlR3JhcGhEb25lXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIFZpZXdwb3J0fSB3aGVuIGl0IGdldHMgdGhlIGZvY3VzIHRvIHJlY2VpdmUga2V5Ym9hcmQgaW5wdXQgKi9cbiAgICBGT0NVU19JTiA9IFwiZm9jdXNpblwiLFxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBWaWV3cG9ydH0gd2hlbiBpdCBsb3NlcyB0aGUgZm9jdXMgdG8gcmVjZWl2ZSBrZXlib2FyZCBpbnB1dCAqL1xuICAgIEZPQ1VTX09VVCA9IFwiZm9jdXNvdXRcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gd2hlbiBpdCdzIGRvbmUgc2VyaWFsaXppbmcgKi9cbiAgICBOT0RFX1NFUklBTElaRUQgPSBcIm5vZGVTZXJpYWxpemVkXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIE5vZGV9IGFuZCBhbGwgaXRzIHtAbGluayBDb21wb25lbnR9cyB3aGVuIGl0J3MgZG9uZSBkZXNlcmlhbGl6aW5nLCBzbyBhbGwgY29tcG9uZW50cywgY2hpbGRyZW4gYW5kIGF0dHJpYnV0ZXMgYXJlIGF2YWlsYWJsZSAqL1xuICAgIE5PREVfREVTRVJJQUxJWkVEID0gXCJub2RlRGVzZXJpYWxpemVkXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIEdyYXBoSW5zdGFuY2V9IHdoZW4gaXQncyBjb250ZW50IGlzIHNldCBhY2NvcmRpbmcgdG8gYSBzZXJpYWxpemF0aW9uIG9mIGEge0BsaW5rIEdyYXBofSAgKi9cbiAgICBHUkFQSF9JTlNUQU5USUFURUQgPSBcImdyYXBoSW5zdGFudGlhdGVkXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgR3JhcGh9IHdoZW4gaXQncyBmaW5pc2hlZCBkZXNlcmlhbGl6aW5nICAqL1xuICAgIEdSQVBIX0RFU0VSSUFMSVpFRCA9IFwiZ3JhcGhEZXNlcmlhbGl6ZWRcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVGltZX0gd2hlbiBpdCdzIHNjYWxpbmcgY2hhbmdlZCAgKi9cbiAgICBUSU1FX1NDQUxFRCA9IFwidGltZVNjYWxlZFwiLFxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBGaWxlSW9Ccm93c2VyTG9jYWx9IHdoZW4gYSBsaXN0IG9mIGZpbGVzIGhhcyBiZWVuIGxvYWRlZCAgKi9cbiAgICBGSUxFX0xPQURFRCA9IFwiZmlsZUxvYWRlZFwiLFxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBGaWxlSW9Ccm93c2VyTG9jYWx9IHdoZW4gYSBsaXN0IG9mIGZpbGVzIGhhcyBiZWVuIHNhdmVkICovXG4gICAgRklMRV9TQVZFRCA9IFwiZmlsZVNhdmVkXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIE5vZGV9IHdoZW4gcmVjYWxjdWxhdGluZyB0cmFuc2Zvcm1zIGZvciByZW5kZXIgKi9cbiAgICBSRU5ERVJfUFJFUEFSRSA9IFwicmVuZGVyUHJlcGFyZVwiLFxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBWaWV3cG9ydH0gYW5kIHtAbGluayBOb2RlfSB3aGVuIHJlY2FsY3VsYXRpb24gb2YgdGhlIGJyYW5jaCB0byByZW5kZXIgc3RhcnRzLiAqL1xuICAgIFJFTkRFUl9QUkVQQVJFX1NUQVJUID0gXCJyZW5kZXJQcmVwYXJlU3RhcnRcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVmlld3BvcnR9IGFuZCB7QGxpbmsgTm9kZX0gd2hlbiByZWNhbGN1bGF0aW9uIG9mIHRoZSBicmFuY2ggdG8gcmVuZGVyIGVuZHMuIFRoZSBicmFuY2ggZGlzcGF0Y2hlcyBiZWZvcmUgdGhlIGxpZ2h0cyBhcmUgdHJhbnNtaXR0ZWQgdG8gdGhlIHNoYWRlcnMgICovXG4gICAgUkVOREVSX1BSRVBBUkVfRU5EID0gXCJyZW5kZXJQcmVwYXJlRW5kXCIsXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIEpvaW50fS1Db21wb25lbnRzIGluIG9yZGVyIHRvIGRpc2Nvbm5lY3QgKi9cbiAgICBESVNDT05ORUNUX0pPSU5UID0gXCJkaXNjb25uZWN0Sm9pbnRcIixcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gd2hlbiBpdCBnZXRzIGF0dGFjaGVkIHRvIGEgdmlld3BvcnQgZm9yIHJlbmRlcmluZyAqL1xuICAgIEFUVEFDSF9CUkFOQ0ggPSBcImF0dGFjaEJyYW5jaFwiLFxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBQcm9qZWN0fSB3aGVuIGl0J3MgZG9uZSBsb2FkaW5nIHJlc291cmNlcyBmcm9tIGEgdXJsICovXG4gICAgUkVTT1VSQ0VTX0xPQURFRCA9IFwicmVzb3VyY2VzTG9hZGVkXCJcbiAgfVxuXG4gIC8qKiBVbmlvbiB0eXBlIG9mIG90aGVyIGV2ZW50IHR5cGVzIHNlcnZpbmcgYXMgYW5ub3RhdGlvbiBmb3IgbGlzdGVuZXJzIGFuZCBoYW5kbGVycyAqL1xuICBleHBvcnQgdHlwZSBFdmVudFVuaWZpZWQgPSBFdmVudCB8IEN1c3RvbUV2ZW50IHwgRXZlbnRQaHlzaWNzO1xuXG4gIC8qKiBVbmlmaWVkIGxpc3RlbmVyIHR5cGUgZXh0ZW5kaW5nIEV2ZW50TGlzdGVuZXIgYW5kIEV2ZW50TGlzdGVuZXJPYmplY3QgZm9yIEN1c3RvbUV2ZW50IGFuZCBvdGhlcnMgKi9cbiAgZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lclVuaWZpZWQgPVxuICAgICgoX2V2ZW50OiBFdmVudCkgPT4gdm9pZCkgfFxuICAgICgoX2V2ZW50OiBDdXN0b21FdmVudCkgPT4gdm9pZCkgfFxuICAgICgoX2V2ZW50OiBFdmVudFBoeXNpY3MpID0+IHZvaWQpIHxcbiAgICAoKF9ldmVudDogRXZlbnRUaW1lcikgPT4gdm9pZCkgfFxuICAgIEV2ZW50TGlzdGVuZXIgfFxuICAgIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q7XG5cbiAgLyoqIEV4dGVuZHMgRXZlbnRUYXJnZXQgdG8gd29yayB3aXRoIHtAbGluayBFdmVudExpc3RlbmVyVW5pZmllZH0gYW5kIHtAbGluayBFdmVudFVuaWZpZWR9ICovXG4gIGV4cG9ydCBjbGFzcyBFdmVudFRhcmdldFVuaWZpZWQgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyfSBmb3IgcmVmZXJlbmNlLiBXb3JrcyB3aXRoIHtAbGluayBFdmVudExpc3RlbmVyVW5pZmllZH0gYW5kIHtAbGluayBFdmVudFVuaWZpZWR9XG4gICAgICovXG4gICAgcHVibGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXJVbmlmaWVkLCBfb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQge1xuICAgICAgc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgPEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q+X2hhbmRsZXIsIF9vcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUge0BsaW5rIEV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXJ9IGZvciByZWZlcmVuY2UuIFdvcmtzIHdpdGgge0BsaW5rIEV2ZW50TGlzdGVuZXJVbmlmaWVkfSBhbmQge0BsaW5rIEV2ZW50VW5pZmllZH1cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lclVuaWZpZWQsIF9vcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZCB7XG4gICAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdD5faGFuZGxlciwgX29wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSB7QGxpbmsgRXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudH0gZm9yIHJlZmVyZW5jZS4gV29ya3Mgd2l0aCB3aXRoIHtAbGluayBFdmVudFVuaWZpZWR9XG4gICAgICovXG4gICAgcHVibGljIGRpc3BhdGNoRXZlbnQoX2V2ZW50OiBFdmVudFVuaWZpZWQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBzdXBlci5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJhc2UgY2xhc3MgZm9yIEV2ZW50VGFyZ2V0IHNpbmdsZXRvbnMsIHdoaWNoIGFyZSBmaXhlZCBlbnRpdGllcyBpbiB0aGUgc3RydWN0dXJlIG9mIEZVREdFLCBzdWNoIGFzIHRoZSBjb3JlIGxvb3AgXG4gICAqL1xuICBleHBvcnQgY2xhc3MgRXZlbnRUYXJnZXRTdGF0aWMgZXh0ZW5kcyBFdmVudFRhcmdldFVuaWZpZWQge1xuICAgIHByb3RlY3RlZCBzdGF0aWMgdGFyZ2V0U3RhdGljOiBFdmVudFRhcmdldFN0YXRpYyA9IG5ldyBFdmVudFRhcmdldFN0YXRpYygpO1xuXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8ge0BsaW5rIHRhcmdldFN0YXRpY30uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhZGRFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyKTogdm9pZCB7XG4gICAgICBFdmVudFRhcmdldFN0YXRpYy50YXJnZXRTdGF0aWMuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB7QGxpbmsgdGFyZ2V0U3RhdGljfS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcbiAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYW4gZXZlbnQgb24ge0BsaW5rIHRhcmdldFN0YXRpY30uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcbiAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEludGVyZmFjZSBkZXNjcmliaW5nIHRoZSBkYXRhdHlwZXMgb2YgdGhlIGF0dHJpYnV0ZXMgYSBtdXRhdG9yIGFzIHN0cmluZ3MgXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogc3RyaW5nIHwgT2JqZWN0O1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgZGVzY3JpYmluZyBhIG11dGF0b3IsIHdoaWNoIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggbmFtZXMgb2YgYXR0cmlidXRlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvciB7XG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogR2VuZXJhbDtcbiAgfVxuXG4gIC8qXG4gICAqIEludGVyZmFjZXMgZGVkaWNhdGVkIGZvciBlYWNoIHB1cnBvc2UuIEV4dHJhIGF0dHJpYnV0ZSBuZWNlc3NhcnkgZm9yIGNvbXBpbGV0aW1lIHR5cGUgY2hlY2tpbmcsIG5vdCBleGlzdGVudCBhdCBydW50aW1lXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JBbmltYXRpb24gZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yQW5pbWF0aW9uOiBudWxsIH1cbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yRm9yVXNlckludGVyZmFjZSBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JVc2VySW50ZXJmYWNlOiBudWxsIH1cbiAgLy8gZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yRm9yQ29tcG9uZW50IGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvclVzZXJDb21wb25lbnQ6IG51bGw7IH1cblxuICAvKipcbiAgICogQ29sbGVjdCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3BpZXMgb2YgdGhlaXIgdmFsdWVzIGluIGEgTXV0YXRvci1vYmplY3RcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkoX29iamVjdDogT2JqZWN0KTogTXV0YXRvciB7XG4gICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7fTtcbiAgICBsZXQgYXR0cmlidXRlczogKHN0cmluZyB8IG51bWJlciB8IHN5bWJvbClbXSA9IFJlZmxlY3Qub3duS2V5cyhSZWZsZWN0LmdldFByb3RvdHlwZU9mKF9vYmplY3QpKTtcbiAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSBSZWZsZWN0LmdldChfb2JqZWN0LCBhdHRyaWJ1dGUpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmICEodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlKSlcbiAgICAgIC8vICAgY29udGludWU7XG4gICAgICBtdXRhdG9yW2F0dHJpYnV0ZS50b1N0cmluZygpXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgdHlwZXMgYmVpbmcgbXV0YWJsZSB1c2luZyB7QGxpbmsgTXV0YXRvcn0tb2JqZWN0cywgdGh1cyBwcm92aWRpbmcgYW5kIHVzaW5nIGludGVyZmFjZXMgY3JlYXRlZCBhdCBydW50aW1lLiAgXG4gICAqIE11dGFibGVzIHByb3ZpZGUgYSB7QGxpbmsgTXV0YXRvcn0gdGhhdCBpcyBidWlsZCBieSBjb2xsZWN0aW5nIGFsbCBvYmplY3QtcHJvcGVydGllcyB0aGF0IGFyZSBlaXRoZXIgb2YgYSBwcmltaXRpdmUgdHlwZSBvciBhZ2FpbiBNdXRhYmxlLlxuICAgKiBTdWJjbGFzc2VzIGNhbiBlaXRoZXIgcmVkdWNlIHRoZSBzdGFuZGFyZCB7QGxpbmsgTXV0YXRvcn0gYnVpbHQgYnkgdGhpcyBiYXNlIGNsYXNzIGJ5IGRlbGV0aW5nIHByb3BlcnRpZXMgb3IgaW1wbGVtZW50IGFuIGluZGl2aWR1YWwgZ2V0TXV0YXRvci1tZXRob2QuXG4gICAqIFRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9mIHRoZSB7QGxpbmsgTXV0YXRvcn0gbXVzdCBtYXRjaCBwdWJsaWMgcHJvcGVydGllcyBvciBnZXR0ZXJzL3NldHRlcnMgb2YgdGhlIG9iamVjdC5cbiAgICogT3RoZXJ3aXNlLCB0aGV5IHdpbGwgYmUgaWdub3JlZCBpZiBub3QgaGFuZGxlZCBieSBhbiBvdmVycmlkZSBvZiB0aGUgbXV0YXRlLW1ldGhvZCBpbiB0aGUgc3ViY2xhc3MgYW5kIHRocm93IGVycm9ycyBpbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCB1c2VyLWludGVyZmFjZSBmb3IgdGhlIG9iamVjdC5cbiAgICovXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNdXRhYmxlIGV4dGVuZHMgRXZlbnRUYXJnZXRVbmlmaWVkIHtcbiAgICAvKipcbiAgICAgKiBEZWNvcmF0b3IgYWxsb3dzIHRvIGF0dGFjaCB7QGxpbmsgTXV0YWJsZX0gZnVuY3Rpb25hbGl0eSB0byBleGlzdGluZyBjbGFzc2VzLiBcbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAvLyAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcInVzZVJlbmRlckRhdGFcIiwge1xuICAgIC8vICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXV0YXRvcih0aGlzOiBNdXRhYmxlRm9yVXNlckludGVyZmFjZSk6IE11dGF0b3Ige1xuICAgIC8vICAgICAgIHJldHVybiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkodGhpcyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0pO1xuICAgIC8vIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0TXV0YXRvckZyb21QYXRoKF9tdXRhdG9yOiBNdXRhdG9yLCBfcGF0aDogc3RyaW5nW10pOiBNdXRhdG9yIHtcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9wYXRoWzBdO1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7fTtcbiAgICAgIGlmIChfbXV0YXRvcltrZXldID09IHVuZGVmaW5lZCkgLy8gaWYgdGhlIHBhdGggZGV2aWF0ZXMgZnJvbSBtdXRhdG9yIHN0cnVjdHVyZSwgcmV0dXJuIHRoZSBtdXRhdG9yXG4gICAgICAgIHJldHVybiBfbXV0YXRvcjtcbiAgICAgIG11dGF0b3Jba2V5XSA9IF9tdXRhdG9yW2tleV07XG4gICAgICBpZiAoX3BhdGgubGVuZ3RoID4gMSlcbiAgICAgICAgbXV0YXRvcltrZXldID0gTXV0YWJsZS5nZXRNdXRhdG9yRnJvbVBhdGgobXV0YXRvcltrZXldLCBfcGF0aC5zbGljZSgxLCBfcGF0aC5sZW5ndGgpKTtcbiAgICAgIHJldHVybiBtdXRhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdHlwZSBvZiB0aGlzIG11dGFibGUgc3ViY2xhc3MgYXMgdGhlIG5hbWUgb2YgdGhlIHJ1bnRpbWUgY2xhc3NcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgbXV0YWJsZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGVjdCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3BpZXMgb2YgdGhlaXIgdmFsdWVzIGluIGEgTXV0YXRvci1vYmplY3QuXG4gICAgICogQnkgZGVmYXVsdCwgYSBtdXRhdG9yIGNhbm5vdCBiZSBleHRlbmRlZCwgc2luY2UgZXh0ZW5zaW9ucyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgb2JqZWN0IHRoZSBtdXRhdG9yIGJlbG9uZ3MgdG8uXG4gICAgICogQSBtdXRhdG9yIG1heSBiZSByZWR1Y2VkIGJ5IHRoZSBkZXNjZW5kYW50cyBvZiB7QGxpbmsgTXV0YWJsZX0gdG8gY29udGFpbiBvbmx5IHRoZSBwcm9wZXJ0aWVzIG5lZWRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TXV0YXRvcihfZXh0ZW5kYWJsZTogYm9vbGVhbiA9IGZhbHNlKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xuXG4gICAgICAvLyBjb2xsZWN0IHByaW1pdGl2ZSBhbmQgbXV0YWJsZSBhdHRyaWJ1dGVzXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gdGhpcykge1xuICAgICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IHRoaXNbYXR0cmlidXRlXTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGVBcnJheSkgJiYgISh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcImlkUmVzb3VyY2VcIikpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSB0aGlzW2F0dHJpYnV0ZV07XG4gICAgICB9XG5cbiAgICAgIGlmICghX2V4dGVuZGFibGUpXG4gICAgICAgIC8vIG11dGF0b3IgY2FuIGJlIHJlZHVjZWQgYnV0IG5vdCBleHRlbmRlZCFcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKG11dGF0b3IpO1xuICAgICAgLy8gZGVsZXRlIHVud2FudGVkIGF0dHJpYnV0ZXNcbiAgICAgIHRoaXMucmVkdWNlTXV0YXRvcihtdXRhdG9yKTtcblxuICAgICAgLy8gcmVwbGFjZSByZWZlcmVuY2VzIHRvIG11dGFibGUgb2JqZWN0cyB3aXRoIHJlZmVyZW5jZXMgdG8gbXV0YXRvcnNcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBtdXRhdG9yKSB7XG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gbXV0YXRvclthdHRyaWJ1dGVdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlKVxuICAgICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHZhbHVlLmdldE11dGF0b3IoKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZUFycmF5KVxuICAgICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHZhbHVlLm1hcCgoX3ZhbHVlKSA9PiBfdmFsdWUuZ2V0TXV0YXRvcigpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciBhbmltYXRpb24uXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIGdldE11dGF0b3J9LCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvckFuaW1hdGlvbigpOiBNdXRhdG9yRm9yQW5pbWF0aW9uIHtcbiAgICAgIHJldHVybiA8TXV0YXRvckZvckFuaW1hdGlvbj50aGlzLmdldE11dGF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciB0aGUgdXNlciBpbnRlcmZhY2UuXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIGdldE11dGF0b3J9LCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xuICAgICAgcmV0dXJuIDxNdXRhdG9yRm9yVXNlckludGVyZmFjZT50aGlzLmdldE11dGF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciBpbmRpdml1YWxpemF0aW9uIGJ5IHRoZSBjb21wb25lbnQuXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIGdldE11dGF0b3J9LCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpOiBNdXRhdG9yRm9yQ29tcG9uZW50IHtcbiAgICAvLyAgICAgcmV0dXJuIDxNdXRhdG9yRm9yQ29tcG9uZW50PnRoaXMuZ2V0TXV0YXRvcigpO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggdGhlIHNhbWUgYXR0cmlidXRlcyBhcyB0aGUgZ2l2ZW4gbXV0YXRvciwgYnV0IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXMgc3RyaW5nLXZhbHVlc1xuICAgICAqIERvZXMgbm90IHJlY3Vyc2UgaW50byBvYmplY3RzIVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xuICAgICAgICBsZXQgdHlwZTogc3RyaW5nID0gbnVsbDtcbiAgICAgICAgbGV0IHZhbHVlOiBudW1iZXIgfCBib29sZWFuIHwgc3RyaW5nIHwgb2JqZWN0ID0gX211dGF0b3JbYXR0cmlidXRlXTtcbiAgICAgICAgaWYgKF9tdXRhdG9yW2F0dHJpYnV0ZV0gIT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgdHlwZSA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdHlwZSA9IHZhbHVlW1wibmFtZVwiXTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0eXBlID0gX211dGF0b3JbYXR0cmlidXRlXS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0eXBlc1thdHRyaWJ1dGVdID0gdHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtdXRhdG9yIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xuICAgICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IF9tdXRhdG9yW2F0dHJpYnV0ZV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpXG4gICAgICAgICAgX211dGF0b3JbYXR0cmlidXRlXSA9IHZhbHVlLmdldE11dGF0b3IoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIF9tdXRhdG9yW2F0dHJpYnV0ZV0gPSAoPEdlbmVyYWw+dGhpcylbYXR0cmlidXRlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHRoZSBzdGF0ZSBvZiB0aGUgbXV0YXRvci5cbiAgICAgKiBUaGUgbXV0YXRpb24gbWF5IGJlIHJlc3RyaWN0ZWQgdG8gYSBzdWJzZXQgb2YgdGhlIG11dGF0b3IgYW5kIHRoZSBldmVudCBkaXNwYXRjaGluZyBzdXBwcmVzc2VkLlxuICAgICAqIFVzZXMgbXV0YXRlQmFzZSwgYnV0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBzdWJjbGFzc2VzXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBhd2FpdCB0aGlzLm11dGF0ZUJhc2UoX211dGF0b3IsIF9zZWxlY3Rpb24pO1xuICAgICAgaWYgKF9kaXNwYXRjaE11dGF0ZSlcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5NVVRBVEUsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IG11dGF0b3I6IF9tdXRhdG9yIH0gfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2UgbWV0aG9kIGZvciBtdXRhdGlvbiwgYWx3YXlzIGF2YWlsYWJsZSB0byBzdWJjbGFzc2VzLiBEbyBub3Qgb3ZlcndyaXRlIGluIHN1YmNsYXNzZXMhXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFzeW5jIG11dGF0ZUJhc2UoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb24/OiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7fTtcbiAgICAgIGlmICghX3NlbGVjdGlvbilcbiAgICAgICAgbXV0YXRvciA9IF9tdXRhdG9yO1xuICAgICAgZWxzZVxuICAgICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgX3NlbGVjdGlvbikgLy8gcmVkdWNlIHRoZSBtdXRhdG9yIHRvIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICBpZiAodHlwZW9mIChfbXV0YXRvclthdHRyaWJ1dGVdKSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IF9tdXRhdG9yW2F0dHJpYnV0ZV07XG5cbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBtdXRhdG9yKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5oYXModGhpcywgYXR0cmlidXRlKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG11dGFudDogT2JqZWN0ID0gUmVmbGVjdC5nZXQodGhpcywgYXR0cmlidXRlKTtcbiAgICAgICAgbGV0IHZhbHVlOiBNdXRhdG9yID0gPE11dGF0b3I+bXV0YXRvclthdHRyaWJ1dGVdO1xuICAgICAgICBpZiAobXV0YW50IGluc3RhbmNlb2YgTXV0YWJsZUFycmF5IHx8IG11dGFudCBpbnN0YW5jZW9mIE11dGFibGUpXG4gICAgICAgICAgYXdhaXQgbXV0YW50Lm11dGF0ZSh2YWx1ZSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVmbGVjdC5zZXQodGhpcywgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGdlbmVyYWwgbXV0YXRvciBhY2NvcmRpbmcgdG8gZGVzaXJlZCBvcHRpb25zIGZvciBtdXRhdGlvbi4gVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQ7XG4gIH1cbn1cbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBleHBvcnQgdHlwZSBHZW5lcmFsID0gYW55O1xuXG4gIC8qKlxuICAgKiBIb2xkcyBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcmVjcmVhdGUgYW4gb2JqZWN0IGlkZW50aWNhbCB0byB0aGUgb25lIGl0IG9yaWdpbmF0ZWQgZnJvbS4gXG4gICAqIEEgc2VyaWFsaXphdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBjb3BpZXMgb2YgZXhpc3Rpbmcgb2JqZWN0cyBhdCBydW50aW1lIG9yIHRvIHN0b3JlIG9iamVjdHMgYXMgc3RyaW5ncyBvciByZWNyZWF0ZSB0aGVtLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemF0aW9uIHtcbiAgICBbdHlwZTogc3RyaW5nXTogR2VuZXJhbDtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphYmxlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uO1xuICAgIC8qKlxuICAgICAqIFJlY3JlYXRlcyB0aGlzIGluc3RhbmNlIG9mIHtAbGluayBTZXJpYWxpemFibGV9IHdpdGggdGhlIGluZm9ybWF0aW9uIGZyb20gdGhlIGdpdmVuIHtAbGluayBTZXJpYWxpemF0aW9ufS5cbiAgICAgKi9cbiAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPjtcbiAgfVxuXG4gIGludGVyZmFjZSBOYW1lc3BhY2VSZWdpc3RlciB7XG4gICAgW25hbWU6IHN0cmluZ106IE9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBleHRlcm5hbCBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmlhbGl6YXRpb24gb2Yge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0cy4gVGhlIGludGVybmFsIHByb2Nlc3MgaXMgaGFuZGxlZCBieSB0aGUgb2JqZWN0cyB0aGVtc2VsdmVzLiAgXG4gICAqIEEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9iamVjdCBjYW4gYmUgY3JlYXRlZCBmcm9tIGEge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0IGFuZCBhIEpTT04tU3RyaW5nIG1heSBiZSBjcmVhdGVkIGZyb20gdGhhdC4gIFxuICAgKiBWaWNlIHZlcnNhLCBhIEpTT04tU3RyaW5nIGNhbiBiZSBwYXJzZWQgdG8gYSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gd2hpY2ggY2FuIGJlIGRlc2VyaWFsaXplZCB0byBhIHtAbGluayBTZXJpYWxpemFibGV9IG9iamVjdC5cbiAgICogYGBgdGV4dFxuICAgKiAgW1NlcmlhbGl6YWJsZV0g4oaSIChzZXJpYWxpemUpIOKGkiBbU2VyaWFsaXphdGlvbl0g4oaSIChzdHJpbmdpZnkpIOKGkiBbU3RyaW5nXSDihpIgKHNhdmUgb3Igc2VuZClcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaTICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkyAgICAgICAgICAgICAgICAgIOKGkyAgICAgICAgIFxuICAgKiAgICAgICAgICAgICAgICBbU2VyaWFsaXphYmxlXSDihpAgKGRlc2VyaWFsaXplKSDihpAgW1NlcmlhbGl6YXRpb25dIOKGkCAocGFyc2UpIOKGkCAobG9hZCkg4oaQIFtNZWRpdW1dXG4gICAqIGBgYCAgICAgIFxuICAgKiBXaGlsZSB0aGUgaW50ZXJuYWwgc2VyaWFsaXplL2Rlc2VyaWFsaXplIG1ldGhvZDFzIG9mIHRoZSBvYmplY3RzIGNhcmUgb2YgdGhlIHNlbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcmVjcmVhdGUgdGhlIG9iamVjdCBhbmQgaXRzIHN0cnVjdHVyZSwgIFxuICAgKiB0aGUge0BsaW5rIFNlcmlhbGl6ZXJ9IGtlZXBzIHRyYWNrIG9mIHRoZSBuYW1lc3BhY2VzIGFuZCBjbGFzc2VzIGluIG9yZGVyIHRvIHJlY3JlYXRlIHtAbGluayBTZXJpYWxpemFibGV9IG9iamVjdHMuIFRoZSBnZW5lcmFsIHN0cnVjdHVyZSBvZiBhIHtAbGluayBTZXJpYWxpemF0aW9ufSBpcyBhcyBmb2xsb3dzICBcbiAgICogYGBgdGV4dFxuICAgKiB7XG4gICAqICAgICAgbmFtZXNwYWNlTmFtZS5jbGFzc05hbWU6IHtcbiAgICogICAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eVZhbHVlLFxuICAgKiAgICAgICAgICAuLi4sXG4gICAqICAgICAgICAgIHByb3BlcnR5TmFtZU9mUmVmZXJlbmNlOiBTZXJpYWxpemF0aW9uT2ZUaGVSZWZlcmVuY2VkT2JqZWN0LFxuICAgKiAgICAgICAgICAuLi4sXG4gICAqICAgICAgICAgIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzczogU2VyaWFsaXphdGlvbk9mU3VwZXJDbGFzc1xuICAgKiAgICAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICogU2luY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBzdXBlcmNsYXNzIGlzIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGFuIG9iamVjdCBpcyBjcmVhdGVkLCBcbiAgICogdGhlIFNlcmlhbGl6YXRpb25PZlN1cGVyQ2xhc3Mgb21pdHMgdGhlIHRoZSBuYW1lc3BhY2VOYW1lLmNsYXNzTmFtZSBrZXkgYW5kIGNvbnNpc3RzIG9ubHkgb2YgaXRzIHZhbHVlLiBcbiAgICogVGhlIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzcyBpcyBnaXZlbiBpbnN0ZWFkIGFzIGEgcHJvcGVydHkgbmFtZSBpbiB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgc3ViY2xhc3MuXG4gICAqL1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2VyaWFsaXplciB7XG4gICAgLyoqIEluIG9yZGVyIGZvciB0aGUgU2VyaWFsaXplciB0byBjcmVhdGUgY2xhc3MgaW5zdGFuY2VzLCBpdCBuZWVkcyBhY2Nlc3MgdG8gdGhlIGFwcHJvcHJpYXRlIG5hbWVzcGFjZXMgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBuYW1lc3BhY2VzOiBOYW1lc3BhY2VSZWdpc3RlciA9IHsgXCLGklwiOiBGdWRnZUNvcmUgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5hbWVzcGFjZSB0byB0aGUge0BsaW5rIFNlcmlhbGl6ZXJ9LCB0byBlbmFibGUgYXV0b21hdGljIGluc3RhbnRpYXRpb24gb2YgY2xhc3NlcyBkZWZpbmVkIHdpdGhpblxuICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJOYW1lc3BhY2UoX25hbWVzcGFjZTogT2JqZWN0KTogc3RyaW5nIHtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gU2VyaWFsaXplci5uYW1lc3BhY2VzKVxuICAgICAgICBpZiAoU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVdID09IF9uYW1lc3BhY2UpXG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG5cbiAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCB3aW5kb3cpO1xuICAgICAgaWYgKCFuYW1lKVxuICAgICAgICBmb3IgKGxldCBwYXJlbnROYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcykge1xuICAgICAgICAgIG5hbWUgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCBTZXJpYWxpemVyLm5hbWVzcGFjZXNbcGFyZW50TmFtZV0pO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gcGFyZW50TmFtZSArIFwiLlwiICsgbmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBpZiAoIW5hbWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWVzcGFjZSBub3QgZm91bmQuIE1heWJlIHBhcmVudCBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBiZWZvcmU/XCIpO1xuXG4gICAgICBTZXJpYWxpemVyLm5hbWVzcGFjZXNbbmFtZV0gPSBfbmFtZXNwYWNlO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemFibGUgRlVER0Utb2JqZWN0IGdpdmVuLFxuICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzIGFsbCBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHJlY29uc3RydWN0aW9uXG4gICAgICogQHBhcmFtIF9vYmplY3QgQW4gb2JqZWN0IHRvIHNlcmlhbGl6ZSwgaW1wbGVtZW50aW5nIHRoZSB7QGxpbmsgU2VyaWFsaXphYmxlfSBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XG4gICAgICAvLyBUT0RPOiBzYXZlIHRoZSBuYW1lc3BhY2Ugd2l0aCB0aGUgY29uc3RydWN0b3JzIG5hbWVcbiAgICAgIC8vIHNlcmlhbGl6YXRpb25bX29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lXSA9IF9vYmplY3Quc2VyaWFsaXplKCk7XG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gdGhpcy5nZXRGdWxsUGF0aChfb2JqZWN0KTtcbiAgICAgIGlmICghcGF0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lc3BhY2Ugb2Ygc2VyaWFsaXphYmxlIG9iamVjdCBvZiB0eXBlICR7X29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lfSBub3QgZm91bmQuIE1heWJlIHRoZSBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCBvciB0aGUgY2xhc3Mgbm90IGV4cG9ydGVkP2ApO1xuICAgICAgc2VyaWFsaXphdGlvbltwYXRoXSA9IF9vYmplY3Quc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICAgIC8vIHJldHVybiBfb2JqZWN0LnNlcmlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBGVURHRS1vYmplY3QgcmVjb25zdHJ1Y3RlZCBmcm9tIHRoZSBpbmZvcm1hdGlvbiBpbiB0aGUge0BsaW5rIFNlcmlhbGl6YXRpb259IGdpdmVuLFxuICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgbGV0IHJlY29uc3RydWN0OiBTZXJpYWxpemFibGU7XG4gICAgICBsZXQgcGF0aDogc3RyaW5nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gbG9vcCBjb25zdHJ1Y3RlZCBzb2xlbHkgdG8gYWNjZXNzIHR5cGUtcHJvcGVydHkuIE9ubHkgb25lIGV4cGVjdGVkIVxuICAgICAgICBmb3IgKHBhdGggaW4gX3NlcmlhbGl6YXRpb24pIHtcbiAgICAgICAgICByZWNvbnN0cnVjdCA9IFNlcmlhbGl6ZXIucmVjb25zdHJ1Y3QocGF0aCk7XG4gICAgICAgICAgcmVjb25zdHJ1Y3QgPSBhd2FpdCByZWNvbnN0cnVjdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltwYXRoXSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U6IHN0cmluZyA9IGBEZXNlcmlhbGl6YXRpb24gb2YgJHtwYXRofSwgJHtyZWNvbnN0cnVjdCA/IFJlZmxlY3QuZ2V0KHJlY29uc3RydWN0LCBcImlkUmVzb3VyY2VcIikgOiBcIlwifSBmYWlsZWQ6IGAgKyBfZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQXJyYXkgb2YgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJpYWxpemFibGUgRlVER0Utb2JqZWN0cyBnaXZlbiBpbiB0aGUgYXJyYXksXG4gICAgICogaW5jbHVkaW5nIGF0dGFjaGVkIGNvbXBvbmVudHMsIGNoaWxkcmVuLCBzdXBlcmNsYXNzLW9iamVjdHMgYWxsIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgcmVjb25zdHJ1Y3Rpb25cbiAgICAgKiBAcGFyYW0gX29iamVjdCBBbiBvYmplY3QgdG8gc2VyaWFsaXplLCBpbXBsZW1lbnRpbmcgdGhlIHtAbGluayBTZXJpYWxpemFibGV9IGludGVyZmFjZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXplQXJyYXk8VCBleHRlbmRzIFNlcmlhbGl6YWJsZT4oX3R5cGU6IG5ldyAoKSA9PiBULCBfb2JqZWN0czogU2VyaWFsaXphYmxlW10pOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uczogU2VyaWFsaXphdGlvbltdID0gW107XG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gdGhpcy5nZXRGdWxsUGF0aChuZXcgX3R5cGUoKSk7XG4gICAgICBpZiAoIXBhdGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZXNwYWNlIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke190eXBlLm5hbWV9IG5vdCBmb3VuZC4gTWF5YmUgdGhlIG5hbWVzcGFjZSBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkIG9yIHRoZSBjbGFzcyBub3QgZXhwb3J0ZWQ/YCk7XG5cbiAgICAgIGZvciAobGV0IG9iamVjdCBvZiBfb2JqZWN0cylcbiAgICAgICAgc2VyaWFsaXphdGlvbnMucHVzaChvYmplY3Quc2VyaWFsaXplKCkpO1xuXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xuICAgICAgc2VyaWFsaXphdGlvbltwYXRoXSA9IHNlcmlhbGl6YXRpb25zO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBvZiBGVURHRS1vYmplY3RzIHJlY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IG9mIHtAbGluayBTZXJpYWxpemF0aW9ufXMgZ2l2ZW4sXG4gICAgICogaW5jbHVkaW5nIGF0dGFjaGVkIGNvbXBvbmVudHMsIGNoaWxkcmVuLCBzdXBlcmNsYXNzLW9iamVjdHNcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb25zIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlW10+IHtcbiAgICAgIGxldCBzZXJpYWxpemFibGVzOiBTZXJpYWxpemFibGVbXSA9IFtdO1xuICAgICAgbGV0IGNvbnN0cnVjdDogbmV3ICgpID0+IFNlcmlhbGl6YWJsZTtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uczogU2VyaWFsaXphdGlvbltdID0gW107XG4gICAgICB0cnkge1xuICAgICAgICAvLyBsb29wIGNvbnN0cnVjdGVkIHNvbGVseSB0byBhY2Nlc3MgdHlwZS1wcm9wZXJ0eS4gT25seSBvbmUgZXhwZWN0ZWQhXG4gICAgICAgIGZvciAobGV0IHBhdGggaW4gX3NlcmlhbGl6YXRpb24pIHtcbiAgICAgICAgICBjb25zdHJ1Y3QgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKHBhdGgpO1xuICAgICAgICAgIHNlcmlhbGl6YXRpb25zID0gX3NlcmlhbGl6YXRpb25bcGF0aF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZXNlcmlhbGl6YXRpb24gZmFpbGVkOiBcIiArIF9lcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IHNlcmlhbGl6YXRpb24gb2Ygc2VyaWFsaXphdGlvbnMpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6YWJsZTogU2VyaWFsaXphYmxlID0gbmV3IGNvbnN0cnVjdCgpO1xuICAgICAgICBhd2FpdCBzZXJpYWxpemFibGUuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XG4gICAgICAgIHNlcmlhbGl6YWJsZXMucHVzaChzZXJpYWxpemFibGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VyaWFsaXphYmxlcztcbiAgICB9XG5cbiAgICAvL1RPRE86IGltcGxlbWVudCBwcmV0dGlmaWVyIHRvIG1ha2UgSlNPTi1TdHJpbmdpZmljYXRpb24gb2Ygc2VyaWFsaXphdGlvbnMgbW9yZSByZWFkYWJsZSwgZS5nLiBwbGFjaW5nIHgsIHkgYW5kIHogaW4gb25lIGxpbmVcbiAgICAvKipcbiAgICAgKiBQcmV0dGlmeSBhIEpTT04tU3RyaW5nLCB0byBtYWtlIGl0IG1vcmUgcmVhZGFibGUuXG4gICAgICogbm90IGltcGxlbWVudGVkIHlldFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcHJldHRpZnkoX2pzb246IHN0cmluZyk6IHN0cmluZyB7IHJldHVybiBfanNvbjsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCwgaHVtYW4gcmVhZGFibGUgSlNPTi1TdHJpbmcsIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4ge0BsaW5rIFNlcmlhbGl6YXRpb259IHRoYXQgbWF5IGhhdmUgYmVlbiBjcmVhdGVkIGJ5IHtAbGluayBTZXJpYWxpemVyfS5zZXJpYWxpemVcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHN0cmluZ2lmeShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IHN0cmluZyB7XG4gICAgICAvLyBhZGp1c3RtZW50cyB0byBzZXJpYWxpemF0aW9uIGNhbiBiZSBtYWRlIGhlcmUgYmVmb3JlIHN0cmluZ2lmaWNhdGlvbiwgaWYgZGVzaXJlZFxuICAgICAgbGV0IGpzb246IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uLCBudWxsLCAyKTtcbiAgICAgIGxldCBwcmV0dHk6IHN0cmluZyA9IFNlcmlhbGl6ZXIucHJldHRpZnkoanNvbik7XG4gICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBKU09OLVN0cmluZy4gUmVzdWx0IG1heSBiZSBwYXNzZWQgdG8ge0BsaW5rIFNlcmlhbGl6ZXIuZGVzZXJpYWxpemV9XG4gICAgICogQHBhcmFtIF9qc29uIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2UoX2pzb246IHN0cmluZyk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoX2pzb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IG9mIHRoZSBjbGFzcyBkZWZpbmVkIHdpdGggdGhlIGZ1bGwgcGF0aCBpbmNsdWRpbmcgdGhlIG5hbWVzcGFjZU5hbWUocykgYW5kIHRoZSBjbGFzc05hbWUgc2VwZXJhdGVkIGJ5IGRvdHMoLikgXG4gICAgICogQHBhcmFtIF9wYXRoIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVjb25zdHJ1Y3QoX3BhdGg6IHN0cmluZyk6IFNlcmlhbGl6YWJsZSB7XG4gICAgICBsZXQgY29uc3RydWN0b3I6IG5ldyAoKSA9PiBTZXJpYWxpemFibGUgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKF9wYXRoKTtcbiAgICAgIGxldCByZWNvbnN0cnVjdGlvbjogU2VyaWFsaXphYmxlID0gbmV3IGNvbnN0cnVjdG9yKCk7XG4gICAgICByZXR1cm4gcmVjb25zdHJ1Y3Rpb247XG4gICAgfVxuXG4gICAgLy8gcHVibGljIHN0YXRpYyBnZXRDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgU2VyaWFsaXphYmxlPihfdHlwZTogc3RyaW5nLCBfbmFtZXNwYWNlOiBPYmplY3QgPSBGdWRnZUNvcmUpOiBuZXcgKCkgPT4gVCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uc3RydWN0b3IgZnJvbSB0aGUgZ2l2ZW4gcGF0aCB0byBhIGNsYXNzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgU2VyaWFsaXphYmxlPihfcGF0aDogc3RyaW5nKTogbmV3ICgpID0+IFQge1xuICAgICAgbGV0IHR5cGVOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHJpbmcoX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgICBsZXQgbmFtZXNwYWNlOiBPYmplY3QgPSBTZXJpYWxpemVyLmdldE5hbWVzcGFjZShfcGF0aCk7XG4gICAgICBpZiAoIW5hbWVzcGFjZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJ1Y3RvciBvZiBzZXJpYWxpemFibGUgb2JqZWN0IG9mIHR5cGUgJHtfcGF0aH0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQ/YCk7XG4gICAgICByZXR1cm4gKDxHZW5lcmFsPm5hbWVzcGFjZSlbdHlwZU5hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgY2xhc3Mgb2YgdGhlIG9iamVjdCwgaWYgZm91bmQgaW4gdGhlIHJlZ2lzdGVyZWQgbmFtZXNwYWNlc1xuICAgICAqIEBwYXJhbSBfb2JqZWN0IFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGdldEZ1bGxQYXRoKF9vYmplY3Q6IFNlcmlhbGl6YWJsZSk6IHN0cmluZyB7XG4gICAgICBsZXQgdHlwZU5hbWU6IHN0cmluZyA9IF9vYmplY3QuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIC8vIERlYnVnLmxvZyhcIlNlYXJjaGluZyBuYW1lc3BhY2Ugb2Y6IFwiICsgdHlwZU5hbWUpO1xuICAgICAgZm9yIChsZXQgbmFtZXNwYWNlTmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpIHtcbiAgICAgICAgbGV0IGZvdW5kOiBHZW5lcmFsID0gKDxHZW5lcmFsPlNlcmlhbGl6ZXIubmFtZXNwYWNlcylbbmFtZXNwYWNlTmFtZV1bdHlwZU5hbWVdO1xuICAgICAgICBpZiAoZm91bmQgJiYgX29iamVjdCBpbnN0YW5jZW9mIGZvdW5kKVxuICAgICAgICAgIHJldHVybiBuYW1lc3BhY2VOYW1lICsgXCIuXCIgKyB0eXBlTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzcGFjZS1vYmplY3QgZGVmaW5lZCB3aXRoaW4gdGhlIGZ1bGwgcGF0aCwgaWYgcmVnaXN0ZXJlZFxuICAgICAqIEBwYXJhbSBfcGF0aFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGdldE5hbWVzcGFjZShfcGF0aDogc3RyaW5nKTogT2JqZWN0IHtcbiAgICAgIGxldCBuYW1lc3BhY2VOYW1lOiBzdHJpbmcgPSBfcGF0aC5zdWJzdHIoMCwgX3BhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgIHJldHVybiBTZXJpYWxpemVyLm5hbWVzcGFjZXNbbmFtZXNwYWNlTmFtZV0gfHwgRnVkZ2VDb3JlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGluIHByb3BlcnRpZXMgb2YgdGhlIHBhcmVudC1vYmplY3QgKGUuZy4gd2luZG93KSwgaWYgcHJlc2VudFxuICAgICAqIEBwYXJhbSBfbmFtZXNwYWNlIFxuICAgICAqIEBwYXJhbSBfcGFyZW50IFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlOiBPYmplY3QsIF9wYXJlbnQ6IE9iamVjdCk6IHN0cmluZyB7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIF9wYXJlbnQpXG4gICAgICAgIGlmICgoPEdlbmVyYWw+X3BhcmVudClbcHJvcF0gPT0gX25hbWVzcGFjZSlcbiAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgaW50ZXJmYWNlIE1hcENsYXNzVG9Db21wb25lbnRzIHtcbiAgICBbY2xhc3NOYW1lOiBzdHJpbmddOiBDb21wb25lbnRbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgc2NlbmV0cmVlLlxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9HcmFwaFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE5vZGUgZXh0ZW5kcyBFdmVudFRhcmdldFVuaWZpZWQgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7IC8vIFRoZSBuYW1lIHRvIGNhbGwgdGhpcyBub2RlIGJ5LlxuICAgIHB1YmxpYyByZWFkb25seSBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XG4gICAgcHVibGljIHRpbWVzdGFtcFVwZGF0ZTogbnVtYmVyID0gMDtcbiAgICAvKiogVGhlIG51bWJlciBvZiBub2RlcyBvZiB0aGUgd2hvbGUgYnJhbmNoIGluY2x1ZGluZyB0aGlzIG5vZGUgYW5kIGFsbCBzdWNjZXNzb3JzICovXG4gICAgcHVibGljIG5Ob2Rlc0luQnJhbmNoOiBudW1iZXIgPSAwO1xuICAgIC8qKiBUaGUgcmFkaXVzIG9mIHRoZSBib3VuZGluZyBzcGhlcmUgaW4gd29ybGQgZGltZW5zaW9ucyBlbmNsb3NpbmcgdGhlIGdlb21ldHJ5IG9mIHRoaXMgbm9kZSBhbmQgYWxsIHN1Y2Nlc3NvcnMgaW4gdGhlIGJyYW5jaCAqL1xuICAgIHB1YmxpYyByYWRpdXM6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIHBhcmVudDogTm9kZSB8IG51bGwgPSBudWxsOyAvLyBUaGUgcGFyZW50IG9mIHRoaXMgbm9kZS5cbiAgICBwcml2YXRlIGNoaWxkcmVuOiBOb2RlW10gPSBbXTsgLy8gYXJyYXkgb2YgY2hpbGQgbm9kZXMgYXBwZW5kZWQgdG8gdGhpcyBub2RlLlxuICAgIHByaXZhdGUgY29tcG9uZW50czogTWFwQ2xhc3NUb0NvbXBvbmVudHMgPSB7fTtcbiAgICAvLyBwcml2YXRlIHRhZ3M6IHN0cmluZ1tdID0gW107IC8vIE5hbWVzIG9mIHRhZ3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhpcyBub2RlLiAoVE9ETzogQXMgb2YgeWV0IG5vIGZ1bmN0aW9uYWxpdHkpXG4gICAgLy8gcHJpdmF0ZSBsYXllcnM6IHN0cmluZ1tdID0gW107IC8vIE5hbWVzIG9mIHRoZSBsYXllcnMgdGhpcyBub2RlIGlzIG9uLiAoVE9ETzogQXMgb2YgeWV0IG5vIGZ1bmN0aW9uYWxpdHkpXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSB7fTtcbiAgICBwcml2YXRlIGNhcHR1cmVzOiBNYXBFdmVudFR5cGVUb0xpc3RlbmVyID0ge307XG4gICAgcHJpdmF0ZSBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQ6IG51bWJlcjtcbiAgICAjbXR4V29ybGRJbnZlcnNlOiBNYXRyaXg0eDQ7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBhIG5hbWUgYW5kIGluaXRpYWxpemVzIGFsbCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG11dGF0b3IgcGF0aCBzdHJpbmcgdG8gZ2V0IGZyb20gb25lIG5vZGUgdG8gYW5vdGhlciBvciBudWxsIGlmIG5vIHBhdGggaXMgZm91bmQgZS5nLjpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogXCJub2RlL3BhcmVudC9jaGlsZHJlbi8xL2NvbXBvbmVudHMvQ29tcG9uZW50U2tlbGV0b24vMFwiXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBQQVRIX0ZST01fVE8oX2Zyb206IE5vZGUgfCBDb21wb25lbnQsIF90bzogTm9kZSB8IENvbXBvbmVudCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgY29uc3QgZnJvbTogTm9kZSA9IF9mcm9tIGluc3RhbmNlb2YgQ29tcG9uZW50ID8gX2Zyb20ubm9kZSA6IF9mcm9tO1xuICAgICAgY29uc3QgdG86IE5vZGUgPSBfdG8gaW5zdGFuY2VvZiBDb21wb25lbnQgPyBfdG8ubm9kZSA6IF90bztcbiAgICAgIGlmICghZnJvbSB8fCAhdG8pXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBmaW5kIHBhdGhzIHRvIGxvd2VzdCBjb21tb24gYW5jZXN0b3JcbiAgICAgIGxldCBwYXRoRnJvbTogTm9kZVtdID0gZnJvbS5nZXRQYXRoKCk7XG4gICAgICBsZXQgcGF0aFRvOiBOb2RlW10gPSB0by5nZXRQYXRoKCk7XG4gICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSBudWxsO1xuICAgICAgd2hpbGUgKHBhdGhGcm9tLmxlbmd0aCAmJiBwYXRoVG8ubGVuZ3RoICYmIHBhdGhGcm9tWzBdID09IHBhdGhUb1swXSkge1xuICAgICAgICBhbmNlc3RvciA9IHBhdGhGcm9tLnNoaWZ0KCk7XG4gICAgICAgIHBhdGhUby5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgcGF0aFRvLnVuc2hpZnQoYW5jZXN0b3IpO1xuXG4gICAgICBpZiAoIWFuY2VzdG9yKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gY3JlYXRlIHJlbGF0aXZlIHBhdGhcbiAgICAgIGxldCBwYXRoVG9BbmNlc3Rvcjogc3RyaW5nW10gPSBwYXRoRnJvbS5tYXAoX25vZGUgPT4gXCJwYXJlbnRcIik7IC8vIFRPRE86IHVzZSBcImtleW9mIE5vZGVcIiBhcyB0eXBlXG4gICAgICBsZXQgcGF0aEZyb21BbmNlc3Rvcjogc3RyaW5nW10gPSBwYXRoVG9cbiAgICAgICAgLmZsYXRNYXAoKF9ub2RlLCBfaW5kZXgsIF9hcnJheSkgPT4gW1wiY2hpbGRyZW5cIiwgX25vZGUuZmluZENoaWxkKF9hcnJheVtfaW5kZXggKyAxXSkudG9TdHJpbmcoKV0pXG4gICAgICAgIC5zbGljZSgwLCAtMik7XG5cbiAgICAgIGlmIChfZnJvbSBpbnN0YW5jZW9mIENvbXBvbmVudClcbiAgICAgICAgcGF0aFRvQW5jZXN0b3IudW5zaGlmdChcIm5vZGVcIik7XG4gICAgICBpZiAoX3RvIGluc3RhbmNlb2YgQ29tcG9uZW50KVxuICAgICAgICBwYXRoRnJvbUFuY2VzdG9yLnB1c2goXCJjb21wb25lbnRzXCIsIF90by50eXBlLCB0by5jb21wb25lbnRzW190by50eXBlXS5pbmRleE9mKF90bykudG9TdHJpbmcoKSk7XG5cbiAgICAgIHJldHVybiBwYXRoVG9BbmNlc3Rvci5jb25jYXQocGF0aEZyb21BbmNlc3Rvcikuam9pbihcIi9cIik7IC8vIFRPRE86IG9yIG1heWJlIHZhbGlkYXRlIHRoaXMgc3RyaW5nIHdpdGggbm9kZSBhbmQgY29tcG9uZW50IG9iamVjdHM/XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB7QGxpbmsgTm9kZX0gb3Ige0BsaW5rIENvbXBvbmVudH0gZm91bmQgYXQgdGhlIGdpdmVuIHBhdGggc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gbm9kZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBGSU5EKF9mcm9tOiBOb2RlIHwgQ29tcG9uZW50LCBfcGF0aDogc3RyaW5nKTogTm9kZSB8IENvbXBvbmVudCB7XG4gICAgICBsZXQgcGF0aDogc3RyaW5nW10gPSBfcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICBsZXQgdG86IEdlbmVyYWwgPSBfZnJvbTtcblxuICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoICYmIHRvKVxuICAgICAgICB0byA9IFJlZmxlY3QuZ2V0KHRvLCBwYXRoLnNoaWZ0KCkpO1xuXG4gICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGlzIG5vZGVzIHtAbGluayBDb21wb25lbnRUcmFuc2Zvcm19XG4gICAgICovXG4gICAgcHVibGljIGdldCBjbXBUcmFuc2Zvcm0oKTogQ29tcG9uZW50VHJhbnNmb3JtIHtcbiAgICAgIHJldHVybiA8Q29tcG9uZW50VHJhbnNmb3JtPnRoaXMuZ2V0Q29tcG9uZW50cyhDb21wb25lbnRUcmFuc2Zvcm0pPy5bMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgdG8gcmV0cmlldmUgdGhlIGxvY2FsIHtAbGluayBNYXRyaXg0eDR9IGF0dGFjaGVkIHRvIHRoaXMgbm9kZXMge0BsaW5rIENvbXBvbmVudFRyYW5zZm9ybX0gIFxuICAgICAqIEZhaWxzIGlmIG5vIHtAbGluayBDb21wb25lbnRUcmFuc2Zvcm19IGlzIGF0dGFjaGVkXG4gICAgICovXG4gICAgcHVibGljIGdldCBtdHhMb2NhbCgpOiBNYXRyaXg0eDQge1xuICAgICAgcmV0dXJuIHRoaXMuY21wVHJhbnNmb3JtPy5tdHhMb2NhbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG10eFdvcmxkSW52ZXJzZSgpOiBNYXRyaXg0eDQge1xuICAgICAgaWYgKHRoaXMuI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQgIT0gdGhpcy50aW1lc3RhbXBVcGRhdGUpXG4gICAgICAgIHRoaXMuI210eFdvcmxkSW52ZXJzZSA9IE1hdHJpeDR4NC5JTlZFUlNJT04odGhpcy5tdHhXb3JsZCk7XG5cbiAgICAgIHRoaXMuI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQgPSB0aGlzLnRpbWVzdGFtcFVwZGF0ZTtcbiAgICAgIHJldHVybiB0aGlzLiNtdHhXb3JsZEludmVyc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGF0dGFjaGVkIHRvIHRoaXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG5DaGlsZHJlbigpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRvciB5aWVsZGluZyB0aGUgbm9kZSBhbmQgYWxsIGRlY2VuZGFudHMgaW4gdGhlIGdyYXBoIGJlbG93IGZvciBpdGVyYXRpb25cbiAgICAgKiBJbmFjdGl2ZSBub2RlcyBhbmQgdGhlaXIgZGVzY2VuZGFudHMgY2FuIGJlIGZpbHRlcmVkXG4gICAgICovXG4gICAgcHVibGljICogZ2V0SXRlcmF0b3IoX2FjdGl2ZTogYm9vbGVhbiA9IGZhbHNlKTogSXRlcmFibGVJdGVyYXRvcjxOb2RlPiB7XG4gICAgICBpZiAoIV9hY3RpdmUgfHwgdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICB5aWVsZCB0aGlzO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgIHlpZWxkKiBjaGlsZC5nZXRJdGVyYXRvcihfYWN0aXZlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhpcyBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzIGluIHRoZSBncmFwaCBiZWxvd1xuICAgICAqL1xuICAgIHB1YmxpYyBbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPE5vZGU+IHtcbiAgICAgIHJldHVybiB0aGlzLmdldEl0ZXJhdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGUtIC8gQWN0aXZhdGUgdGhpcyBub2RlLiBJbmFjdGl2ZSBub2RlcyB3aWxsIG5vdCBiZSBwcm9jZXNzZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gX29uO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5OT0RFX0FDVElWQVRFIDogRVZFTlQuTk9ERV9ERUFDVElWQVRFLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgdGhpcy5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuTk9ERV9BQ1RJVkFURSA6IEVWRU5ULk5PREVfREVBQ1RJVkFURSkpO1xuICAgIH1cblxuICAgIC8vICNyZWdpb24gU2NlbmV0cmVlXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGVzIHBhcmVudCBub2RlXG4gICAgICovXG4gICAgcHVibGljIGdldFBhcmVudCgpOiBOb2RlIHwgbnVsbCB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhY2VzIGJhY2sgdGhlIGFuY2VzdG9ycyBvZiB0aGlzIG5vZGUgYW5kIHJldHVybnMgdGhlIGZpcnN0XG4gICAgICovXG4gICAgcHVibGljIGdldEFuY2VzdG9yKCk6IE5vZGUgfCBudWxsIHtcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IuZ2V0UGFyZW50KCkpXG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCk7XG4gICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhY2VzIHRoZSBoaWVyYXJjaHkgdXB3YXJkcyB0byB0aGUgZmlyc3QgYW5jZXN0b3IgYW5kIHJldHVybnMgdGhlIHBhdGggdGhyb3VnaCB0aGUgZ3JhcGggdG8gdGhpcyBub2RlXG4gICAgICovXG4gICAgcHVibGljIGdldFBhdGgoKTogTm9kZVtdIHtcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XG4gICAgICBsZXQgcGF0aDogTm9kZVtdID0gW3RoaXNdO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yLmdldFBhcmVudCgpKVxuICAgICAgICBwYXRoLnVuc2hpZnQoYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKSk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDaGlsZChfaW5kZXg6IG51bWJlcik6IE5vZGUge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bX2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2hpbGRyZW4oKTogTm9kZVtdIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVmZXJlbmNlcyB0byBjaGlsZG5vZGVzIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDaGlsZHJlbkJ5TmFtZShfbmFtZTogc3RyaW5nKTogTm9kZVtdIHtcbiAgICAgIGxldCBmb3VuZDogTm9kZVtdID0gW107XG4gICAgICBmb3VuZCA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKChfbm9kZTogTm9kZSkgPT4gX25vZGUubmFtZSA9PSBfbmFtZSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltcGx5IGNhbGxzIHtAbGluayBhZGRDaGlsZH0uIFRoaXMgcmVmZXJlbmNlIGlzIGhlcmUgc29sZWx5IGJlY2F1c2UgYXBwZW5kQ2hpbGQgaXMgdGhlIGVxdWl2YWxlbnQgbWV0aG9kIGluIERPTS5cbiAgICAgKiBTZWUgYW5kIHByZWZlcmFibHkgdXNlIHtAbGluayBhZGRDaGlsZH1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIHB1YmxpYyByZWFkb25seSBhcHBlbmRDaGlsZDogKF9jaGlsZDogTm9kZSkgPT4gdm9pZCA9IHRoaXMuYWRkQ2hpbGQ7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiByZWZlcmVuY2UgdG8gYSBub2RlIHRvIHRoZSBsaXN0IG9mIGNoaWxkcmVuLCBpZiBub3QgYWxyZWFkeSBpblxuICAgICAqIEB0aHJvd3MgRXJyb3Igd2hlbiB0cnlpbmcgdG8gYWRkIGFuIGFuY2VzdG9yIG9mIHRoaXMgXG4gICAgICovXG4gICAgcHVibGljIGFkZENoaWxkKF9jaGlsZDogTm9kZSk6IHZvaWQge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaW5jbHVkZXMoX2NoaWxkKSlcbiAgICAgICAgLy8gX25vZGUgaXMgYWxyZWFkeSBhIGNoaWxkIG9mIHRoaXNcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBsZXQgaW5BdWRpb0dyYXBoOiBib29sZWFuID0gZmFsc2U7XG4gICAgICBsZXQgZ3JhcGhMaXN0ZW5lZDogTm9kZSA9IEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKTtcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgYW5jZXN0b3IudGltZXN0YW1wVXBkYXRlID0gMDtcbiAgICAgICAgaW5BdWRpb0dyYXBoID0gaW5BdWRpb0dyYXBoIHx8IChhbmNlc3RvciA9PSBncmFwaExpc3RlbmVkKTtcbiAgICAgICAgaWYgKGFuY2VzdG9yID09IF9jaGlsZClcbiAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiQ3ljbGljIHJlZmVyZW5jZSBwcm9oaWJpdGVkIGluIG5vZGUgaGllcmFyY2h5LCBhbmNlc3RvcnMgbXVzdCBub3QgYmUgYWRkZWQgYXMgY2hpbGRyZW5cIikpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGxldCBwcmV2aW91c1BhcmVudDogTm9kZSA9IF9jaGlsZC5wYXJlbnQ7XG4gICAgICBpZiAocHJldmlvdXNQYXJlbnQpXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF9jaGlsZCk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goX2NoaWxkKTtcbiAgICAgIF9jaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgX2NoaWxkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX0FQUEVORCwgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgIGlmIChpbkF1ZGlvR3JhcGgpXG4gICAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcmVmZXJlbmNlIHRvIHRoZSBnaXZlIG5vZGUgZnJvbSB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVDaGlsZChfY2hpbGQ6IE5vZGUpOiB2b2lkIHtcbiAgICAgIGxldCBmb3VuZDogbnVtYmVyID0gdGhpcy5maW5kQ2hpbGQoX2NoaWxkKTtcbiAgICAgIGlmIChmb3VuZCA8IDApXG4gICAgICAgIHJldHVybjtcblxuICAgICAgX2NoaWxkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX1JFTU9WRSwgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlQuTk9ERV9ERUFDVElWQVRFKSk7XG4gICAgICBpZiAodGhpcy5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCkpKVxuICAgICAgICBfY2hpbGQuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgX2NoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcmVmZXJlbmNlcyBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVBbGxDaGlsZHJlbigpOiB2b2lkIHtcbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlbiBvciAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBwdWJsaWMgZmluZENoaWxkKF9zZWFyY2g6IE5vZGUpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uaW5kZXhPZihfc2VhcmNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIG5vZGUgd2l0aCBhbm90aGVyLCBwcmVzZXJ2aW5nIHRoZSBwb3NpdGlvbiBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgICAqL1xuICAgIHB1YmxpYyByZXBsYWNlQ2hpbGQoX3JlcGxhY2U6IE5vZGUsIF93aXRoOiBOb2RlKTogYm9vbGVhbiB7XG4gICAgICBsZXQgZm91bmQ6IG51bWJlciA9IHRoaXMuZmluZENoaWxkKF9yZXBsYWNlKTtcbiAgICAgIGlmIChmb3VuZCA8IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgbGV0IHByZXZpb3VzUGFyZW50OiBOb2RlID0gX3dpdGguZ2V0UGFyZW50KCk7XG4gICAgICBpZiAocHJldmlvdXNQYXJlbnQpXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF93aXRoKTtcblxuICAgICAgX3JlcGxhY2UucGFyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuY2hpbGRyZW5bZm91bmRdID0gX3dpdGg7XG4gICAgICBfd2l0aC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICBfd2l0aC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DSElMRF9BUFBFTkQsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICBpZiAodGhpcy5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCkpKVxuICAgICAgICBfd2l0aC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdGltZXN0YW1wIG1hdGNoZXMgdGhlIGxhc3QgdXBkYXRlIHRpbWVzdGFtcCB0aGlzIG5vZGUgdW5kZXJ3ZW50LCBlbHNlIGZhbHNlXG4gICAgICovXG4gICAgcHVibGljIGlzVXBkYXRlZChfdGltZXN0YW1wVXBkYXRlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiAodGhpcy50aW1lc3RhbXBVcGRhdGUgPT0gX3RpbWVzdGFtcFVwZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG5vZGUgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBnaXZlbiBub2RlLCBkaXJlY3RseSBvciBpbmRpcmVjdGx5LCBlbHNlIGZhbHNlXG4gICAgICovXG4gICAgcHVibGljIGlzRGVzY2VuZGFudE9mKF9hbmNlc3RvcjogTm9kZSk6IGJvb2xlYW4ge1xuICAgICAgbGV0IG5vZGU6IE5vZGUgPSB0aGlzO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPSBfYW5jZXN0b3IpXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgIHJldHVybiAobm9kZSAhPSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgTXV0YXRvciBmcm9tIHtAbGluayBBbmltYXRpb259IHRvIGFsbCBpdHMgY29tcG9uZW50cyBhbmQgdHJhbnNmZXJzIGl0IHRvIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXBwbHlBbmltYXRpb24oX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIGlmIChcImNvbXBvbmVudHNcIiBpbiBfbXV0YXRvcikge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudFR5cGUgaW4gX211dGF0b3IuY29tcG9uZW50cykge1xuICAgICAgICAgIGxldCBjb21wb25lbnRzT2ZUeXBlOiBDb21wb25lbnRbXSA9IHRoaXMuY29tcG9uZW50c1tjb21wb25lbnRUeXBlXTsgLy8gVE9ETzogYWRkIGVycm9ycyBpZiBub2RlIGRvZXNuJ3QgY29udGFpbiBwcm9wZXJ0eVxuICAgICAgICAgIGxldCBtdXRhdG9yc0ZvclR5cGU6IE11dGF0b3JbXSA9IF9tdXRhdG9yLmNvbXBvbmVudHNbY29tcG9uZW50VHlwZV07XG4gICAgICAgICAgaWYgKGNvbXBvbmVudHNPZlR5cGUgIT0gdW5kZWZpbmVkICYmIG11dGF0b3JzRm9yVHlwZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBtdXRhdG9yc0ZvclR5cGUpIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50c09mVHlwZVtpXS5tdXRhdGUobXV0YXRvcnNGb3JUeXBlW2ldLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJjaGlsZHJlblwiIGluIF9tdXRhdG9yKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGROYW1lIGluIF9tdXRhdG9yLmNoaWxkcmVuKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgdGhpcy5nZXRDaGlsZHJlbkJ5TmFtZShjaGlsZE5hbWUpKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUuYXBwbHlBbmltYXRpb24oX211dGF0b3IuY2hpbGRyZW5bY2hpbGROYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cblxuICAgIC8vICNyZWdpb24gQ29tcG9uZW50c1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjb21wb25lbnRzIGF0dGFjaGVkIHRvIHRoaXMgbm9kZSwgaW5kZXBlbmRlbnQgb2YgdHlwZS4gXG4gICAgICovXG4gICAgcHVibGljIGdldEFsbENvbXBvbmVudHMoKTogQ29tcG9uZW50W10ge1xuICAgICAgbGV0IGFsbDogQ29tcG9uZW50W10gPSBbXTtcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgIGFsbCA9IGFsbC5jb25jYXQodGhpcy5jb21wb25lbnRzW3R5cGVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBsaXN0IG9mIGNvbXBvbmVudHMgb2YgdGhlIGdpdmVuIGNsYXNzIGF0dGFjaGVkIHRvIHRoaXMgbm9kZS4gXG4gICAgICovXG4gICAgcHVibGljIGdldENvbXBvbmVudHM8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IFRbXSB7XG4gICAgICByZXR1cm4gPFRbXT4odGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXSB8fCBbXSkuc2xpY2UoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvbXBvbnRlbnQgZm91bmQgb2YgdGhlIGdpdmVuIGNsYXNzIGF0dGFjaGVkIHRoaXMgbm9kZSBvciBudWxsLCBpZiBsaXN0IGlzIGVtcHR5IG9yIGRvZXNuJ3QgZXhpc3RcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUIHtcbiAgICAgIGxldCBsaXN0OiBUW10gPSA8VFtdPnRoaXMuY29tcG9uZW50c1tfY2xhc3MubmFtZV07XG4gICAgICBpZiAobGlzdClcbiAgICAgICAgcmV0dXJuIGxpc3RbMF07XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGdpdmVuIGNvbXBvbmVudCB0byB0aGlzIG5vZGUuIElkZW50aWNhbCB0byB7QGxpbmsgYWRkQ29tcG9uZW50fVxuICAgICAqL1xuICAgIHB1YmxpYyBhdHRhY2goX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICB0aGlzLmFkZENvbXBvbmVudChfY29tcG9uZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBjb21wb25lbnQgdG8gdGhpcyBub2RlXG4gICAgICovXG4gICAgcHVibGljIGFkZENvbXBvbmVudChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgIGlmIChfY29tcG9uZW50Lm5vZGUgPT0gdGhpcylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGNtcExpc3Q6IENvbXBvbmVudFtdID0gdGhpcy5jb21wb25lbnRzW19jb21wb25lbnQudHlwZV07XG4gICAgICBpZiAoY21wTGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXSA9IFtfY29tcG9uZW50XTtcbiAgICAgIGVsc2UgaWYgKGNtcExpc3QubGVuZ3RoICYmIF9jb21wb25lbnQuaXNTaW5nbGV0b24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50ICR7X2NvbXBvbmVudC50eXBlfSBpcyBtYXJrZWQgc2luZ2xldG9uIGFuZCBjYW4ndCBiZSBhdHRhY2hlZCwgbm8gbW9yZSB0aGFuIG9uZSBhbGxvd2VkYCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNtcExpc3QucHVzaChfY29tcG9uZW50KTtcblxuICAgICAgX2NvbXBvbmVudC5hdHRhY2hUb05vZGUodGhpcyk7XG4gICAgICBfY29tcG9uZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNPTVBPTkVOVF9BREQpKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuQ09NUE9ORU5UX0FERCwgeyBkZXRhaWw6IF9jb21wb25lbnQgfSkpOyAvLyBUT0RPOiBzZWUgaWYgdGhpcyBpcyBiZSBmZWFzYWJsZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUgZ2l2ZW4gY29tcG9uZW50IGZyb20gdGhpcyBub2RlLiBJZGVudGljYWwgdG8ge0BsaW5rIHJlbW92ZUNvbXBvbmVudH1cbiAgICAgKi9cbiAgICBwdWJsaWMgZGV0YWNoKF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgdGhpcy5yZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudCk7XG4gICAgfVxuICAgIC8qKiBcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjb21wb25lbnQgZnJvbSB0aGUgbm9kZSwgaWYgaXQgd2FzIGF0dGFjaGVkLCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuIFxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgY29tcG9uZW50c09mVHlwZTogQ29tcG9uZW50W10gPSB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXTtcbiAgICAgICAgbGV0IGZvdW5kQXQ6IG51bWJlciA9IGNvbXBvbmVudHNPZlR5cGUuaW5kZXhPZihfY29tcG9uZW50KTtcbiAgICAgICAgaWYgKGZvdW5kQXQgPCAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgX2NvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DT01QT05FTlRfUkVNT1ZFKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgeyBkZXRhaWw6IF9jb21wb25lbnQgfSkpOyAvLyBUT0RPOiBzZWUgaWYgdGhpcyB3b3VsZCBiZSBmZWFzYWJsZVxuICAgICAgICBjb21wb25lbnRzT2ZUeXBlLnNwbGljZShmb3VuZEF0LCAxKTtcbiAgICAgICAgX2NvbXBvbmVudC5hdHRhY2hUb05vZGUobnVsbCk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIGNvbXBvbmVudCAnJHtfY29tcG9uZW50fSdpbiBub2RlIG5hbWVkICcke3RoaXMubmFtZX0nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cblxuICAgIC8vICNyZWdpb24gU2VyaWFsaXphdGlvblxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBhY3RpdmU6IHRoaXMuYWN0aXZlXG4gICAgICB9O1xuXG4gICAgICBsZXQgY29tcG9uZW50czogU2VyaWFsaXphdGlvbiA9IHt9O1xuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgY29tcG9uZW50c1t0eXBlXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRzW3R5cGVdKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50c1t0eXBlXS5wdXNoKGNvbXBvbmVudC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgY29tcG9uZW50c1t0eXBlXS5wdXNoKFNlcmlhbGl6ZXIuc2VyaWFsaXplKGNvbXBvbmVudCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXJpYWxpemF0aW9uW1wiY29tcG9uZW50c1wiXSA9IGNvbXBvbmVudHM7XG5cbiAgICAgIGxldCBjaGlsZHJlbjogU2VyaWFsaXphdGlvbltdID0gW107XG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goU2VyaWFsaXplci5zZXJpYWxpemUoY2hpbGQpKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6YXRpb25bXCJjaGlsZHJlblwiXSA9IGNoaWxkcmVuO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfU0VSSUFMSVpFRCkpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XG4gICAgICAvLyB0aGlzLnBhcmVudCA9IGlzIHNldCB3aGVuIHRoZSBub2RlcyBhcmUgYWRkZWRcblxuICAgICAgLy8gZGVzZXJpYWxpemUgY29tcG9uZW50cyBmaXJzdCBzbyBzY3JpcHRzIGNhbiByZWFjdCB0byBjaGlsZHJlbiBiZWluZyBhcHBlbmRlZFxuICAgICAgZm9yIChsZXQgdHlwZSBpbiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHNlcmlhbGl6ZWRDb21wb25lbnQgb2YgX3NlcmlhbGl6YXRpb24uY29tcG9uZW50c1t0eXBlXSkge1xuICAgICAgICAgIGxldCBkZXNlcmlhbGl6ZWRDb21wb25lbnQ6IENvbXBvbmVudCA9IDxDb21wb25lbnQ+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ29tcG9uZW50KTtcbiAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChkZXNlcmlhbGl6ZWRDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5jaGlsZHJlbilcbiAgICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENoaWxkIG9mIF9zZXJpYWxpemF0aW9uLmNoaWxkcmVuKSB7XG4gICAgICAgICAgbGV0IGRlc2VyaWFsaXplZENoaWxkOiBOb2RlID0gPE5vZGU+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ2hpbGQpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZGVzZXJpYWxpemVkQ2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQpKTtcbiAgICAgIGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmdldEFsbENvbXBvbmVudHMoKSlcbiAgICAgICAgY29tcG9uZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfREVTRVJJQUxJWkVEKSk7XG5cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGlmIHRoaXMgaXMgYSBnb29kIGlkZWFcbiAgICAgIC8vIGNvbnN0IGhuZEdyYXBoRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcbiAgICAgIC8vICAgZm9yIChsZXQgY29tcG9uZW50IG9mIHRoaXMuZ2V0QWxsQ29tcG9uZW50cygpKVxuICAgICAgLy8gICAgIGNvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQsIHsgYnViYmxlczogZmFsc2UgfSkpO1xuICAgICAgLy8gICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfREVTRVJJQUxJWkVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XG4gICAgICAvLyAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9JTlNUQU5USUFURUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcbiAgICAgIC8vIH07XG4gICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfREVTRVJJQUxJWkVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XG4gICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfSU5TVEFOVElBVEVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuYWN0aXZhdGUoX3NlcmlhbGl6YXRpb24uYWN0aXZlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIGFzIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzXG4gICAgICovXG4gICAgcHVibGljIHRvSGllcmFyY2h5U3RyaW5nKF9ub2RlOiBOb2RlID0gbnVsbCwgX2xldmVsOiBudW1iZXIgPSAwKTogc3RyaW5nIHtcbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIGZvciBiZXR0ZXIgcmVhZGFiaWxpdHlcbiAgICAgIGlmICghX25vZGUpXG4gICAgICAgIF9ub2RlID0gdGhpcztcblxuICAgICAgbGV0IHByZWZpeDogc3RyaW5nID0gXCIrXCIucmVwZWF0KF9sZXZlbCk7XG5cbiAgICAgIGxldCBvdXRwdXQ6IHN0cmluZyA9IHByZWZpeCArIFwiIFwiICsgX25vZGUubmFtZSArIFwiIHwgXCI7XG4gICAgICBmb3IgKGxldCB0eXBlIGluIF9ub2RlLmNvbXBvbmVudHMpXG4gICAgICAgIG91dHB1dCArPSBfbm9kZS5jb21wb25lbnRzW3R5cGVdLmxlbmd0aCArIFwiIFwiICsgdHlwZS5zcGxpdChcIkNvbXBvbmVudFwiKS5wb3AoKSArIFwiLCBcIjtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zbGljZSgwLCAtMikgKyBcIjwvYnI+XCI7XG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBfbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBvdXRwdXQgKz0gdGhpcy50b0hpZXJhcmNoeVN0cmluZyhjaGlsZCwgX2xldmVsICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8vICNyZWdpb24gRXZlbnRzXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbm9kZS4gVGhlIGdpdmVuIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIG1hdGNoaW5nIGV2ZW50IGlzIHBhc3NlZCB0byB0aGUgbm9kZS5cbiAgICAgKiBEZXZpYXRpbmcgZnJvbSB0aGUgc3RhbmRhcmQgRXZlbnRUYXJnZXQsIGhlcmUgdGhlIF9oYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiBhbmQgX2NhcHR1cmUgaXMgdGhlIG9ubHkgb3B0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyKF90eXBlOiBFVkVOVCB8IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXJVbmlmaWVkLCBfY2FwdHVyZTogYm9vbGVhbiAvKnwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMqLyA9IGZhbHNlKTogdm9pZCB7XG4gICAgICBsZXQgbGlzdExpc3RlbmVyczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IF9jYXB0dXJlID8gdGhpcy5jYXB0dXJlcyA6IHRoaXMubGlzdGVuZXJzO1xuICAgICAgaWYgKCFsaXN0TGlzdGVuZXJzW190eXBlXSlcbiAgICAgICAgbGlzdExpc3RlbmVyc1tfdHlwZV0gPSBbXTtcbiAgICAgIGxpc3RMaXN0ZW5lcnNbX3R5cGVdLnB1c2goX2hhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gdGhlIG5vZGUuIFRoZSBzaWduYXR1cmUgbXVzdCBtYXRjaCB0aGUgb25lIHVzZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGU6IEVWRU5UIHwgc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lclVuaWZpZWQsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgIGxldCBsaXN0ZW5lcnNGb3JUeXBlOiBFdmVudExpc3RlbmVyVW5pZmllZFtdID0gX2NhcHR1cmUgPyB0aGlzLmNhcHR1cmVzW190eXBlXSA6IHRoaXMubGlzdGVuZXJzW190eXBlXTtcbiAgICAgIGlmIChsaXN0ZW5lcnNGb3JUeXBlKVxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBsaXN0ZW5lcnNGb3JUeXBlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgIGlmIChsaXN0ZW5lcnNGb3JUeXBlW2ldID09IF9oYW5kbGVyKVxuICAgICAgICAgICAgbGlzdGVuZXJzRm9yVHlwZS5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGFyZ2V0LiBUaGlzIGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXR1cm5zIHRydWUgKHN0YW5kYXJkOiByZXR1cm4gdHJ1ZSBvbmx5IGlmIGVpdGhlciBldmVudCdzIGNhbmNlbGFibGUgYXR0cmlidXRlIHZhbHVlIGlzIGZhbHNlIG9yIGl0cyBwcmV2ZW50RGVmYXVsdCgpIG1ldGhvZCB3YXMgbm90IGludm9rZWQpXG4gICAgICogVGhlIGV2ZW50IHRyYXZlbHMgaW50byB0aGUgaGllcmFyY2h5IHRvIHRoaXMgbm9kZSBkaXNwYXRjaGluZyB0aGUgZXZlbnQsIGludm9raW5nIG1hdGNoaW5nIGhhbmRsZXJzIG9mIHRoZSBub2RlcyBhbmNlc3RvcnMgbGlzdGVuaW5nIHRvIHRoZSBjYXB0dXJlIHBoYXNlLCBcbiAgICAgKiB0aGFuIHRoZSBtYXRjaGluZyBoYW5kbGVyIG9mIHRoZSB0YXJnZXQgbm9kZSBpbiB0aGUgdGFyZ2V0IHBoYXNlLCBhbmQgYmFjayBvdXQgb2YgdGhlIGhpZXJhcmNoeSBpbiB0aGUgYnViYmxpbmcgcGhhc2UsIGludm9raW5nIGFwcHJvcHJpYXRlIGhhbmRsZXJzIG9mIHRoZSBhbnZlc3RvcnNcbiAgICAgKi9cbiAgICBwdWJsaWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XG4gICAgICBsZXQgYW5jZXN0b3JzOiBOb2RlW10gPSBbXTtcbiAgICAgIGxldCB1cGNvbWluZzogTm9kZSA9IHRoaXM7XG4gICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcInRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIFJlZmxlY3QgaW5zdGVhZCBvZiBPYmplY3QgdGhyb3VnaG91dC4gU2VlIGFsc28gUmVuZGVyIGFuZCBNdXRhYmxlLi4uXG4gICAgICB3aGlsZSAodXBjb21pbmcucGFyZW50KVxuICAgICAgICBhbmNlc3RvcnMucHVzaCh1cGNvbWluZyA9IHVwY29taW5nLnBhcmVudCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcInBhdGhcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG5ldyBBcnJheTxOb2RlPih0aGlzLCAuLi5hbmNlc3RvcnMpIH0pO1xuXG4gICAgICAvLyBjYXB0dXJlIHBoYXNlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkNBUFRVUklOR19QSEFTRSB9KTtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSBhbmNlc3RvcnNbaV07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogYW5jZXN0b3IgfSk7XG4gICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyhhbmNlc3Rvci5jYXB0dXJlc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRhcmdldCBwaGFzZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5BVF9UQVJHRVQgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XG4gICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy5jYXB0dXJlc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7XG4gICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xuXG4gICAgICBpZiAoIV9ldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gYnViYmxlIHBoYXNlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkJVQkJMSU5HX1BIQVNFIH0pO1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSBhbmNlc3RvcnNbaV07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogYW5jZXN0b3IgfSk7XG4gICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyhhbmNlc3Rvci5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7IC8vVE9ETzogcmV0dXJuIGEgbWVhbmluZ2Z1bCB2YWx1ZSwgc2VlIGRvY3VtZW50YXRpb24gb2YgZGlzcGF0Y2ggZXZlbnRcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlcyBhIHN5bnRoZXRpYyBldmVudCB0byB0YXJnZXQgd2l0aG91dCB0cmF2ZWxsaW5nIHRocm91Z2ggdGhlIGdyYXBoIGhpZXJhcmNoeSBuZWl0aGVyIGR1cmluZyBjYXB0dXJlIG5vciBidWJibGluZyBwaGFzZVxuICAgICAqL1xuICAgIHB1YmxpYyBkaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQVRfVEFSR0VUIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xuICAgICAgdGhpcy5jYWxsTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzW19ldmVudC50eXBlXSwgX2V2ZW50KTsgLy8gVE9ETzogZXhhbWluZSBpZiB0aGlzIHNob3VsZCBnbyB0byB0aGUgY2FwdHVyZXMgaW5zdGVhZCBvZiB0aGUgbGlzdGVuZXJzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyBhIHN5bnRoZXRpYyBldmVudCB0byB0aGlzIG5vZGUgYW5kIGZyb20gdGhlcmUgdG8gYWxsIG5vZGVzIGRlZXBlciBpbiB0aGUgaGllcmFyY2h5LFxuICAgICAqIGludm9raW5nIG1hdGNoaW5nIGhhbmRsZXJzIG9mIHRoZSBub2RlcyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UuIFdhdGNoIHBlcmZvcm1hbmNlIHdoZW4gdGhlcmUgYXJlIG1hbnkgbm9kZXMgaW52b2x2ZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgYnJvYWRjYXN0RXZlbnQoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgICAgLy8gb3ZlcndyaXRlIGV2ZW50IHRhcmdldCBhbmQgcGhhc2VcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQ0FQVFVSSU5HX1BIQVNFIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJ0YXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBicm9hZGNhc3RFdmVudFJlY3Vyc2l2ZShfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgICAvLyBjYXB0dXJlIHBoYXNlIG9ubHlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcbiAgICAgIGxldCBjYXB0dXJlczogRXZlbnRMaXN0ZW5lclVuaWZpZWRbXSA9IHRoaXMuY2FwdHVyZXNbX2V2ZW50LnR5cGVdIHx8IFtdO1xuICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBjYXB0dXJlcylcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBoYW5kbGVyKF9ldmVudCk7XG4gICAgICAvLyBhcHBlYXJzIHRvIGJlIHNsb3dlciwgYXN0b25pc2hpbmdseS4uLlxuICAgICAgLy8gY2FwdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgIC8vICAgICBoYW5kbGVyKF9ldmVudCk7XG4gICAgICAvLyB9KTtcblxuICAgICAgLy8gc2FtZSBmb3IgY2hpbGRyZW5cbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGQuYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGxMaXN0ZW5lcnMoX2xpc3RlbmVyczogRXZlbnRMaXN0ZW5lclVuaWZpZWRbXSwgX2V2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgICAgaWYgKF9saXN0ZW5lcnM/Lmxlbmd0aCA+IDApXG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgX2xpc3RlbmVycylcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gIH1cbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+XG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqIFxuICAgKiBTdXBlcmNsYXNzIGZvciBhbGwge0BsaW5rIENvbXBvbmVudH1zIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHtAbGluayBOb2RlfXMuXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwIHwgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgIFxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvQ29tcG9uZW50XG4gICAqL1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XG4gICAgLyoqIHN1YmNsYXNzZXMgZ2V0IGEgaVN1YmNsYXNzIG51bWJlciBmb3IgaWRlbnRpZmljYXRpb24gKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyO1xuICAgIC8qKiByZWZlcnMgYmFjayB0byB0aGlzIGNsYXNzIGZyb20gYW55IHN1YmNsYXNzIGUuZy4gaW4gb3JkZXIgdG8gZmluZCBjb21wYXRpYmxlIG90aGVyIHJlc291cmNlcyovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIENvbXBvbmVudFtdID0gW107XG5cbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gdHJ1ZTtcbiAgICBwcm90ZWN0ZWQgYWN0aXZlOiBib29sZWFuID0gdHJ1ZTtcbiAgICAjbm9kZTogTm9kZSB8IG51bGwgPSBudWxsO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEUsIChfZXZlbnQ6IEN1c3RvbUV2ZW50KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiNub2RlKSB7XG4gICAgICAgICAgLy8gVE9ETzogZmluZCB0aGUgbnVtYmVyIG9mIHRoZSBjb21wb25lbnQgaW4gdGhlIGFycmF5IGlmIG5vdCBzaW5nbGV0b25cbiAgICAgICAgICBfZXZlbnQuZGV0YWlsLmNvbXBvbmVudCA9IHRoaXM7XG4gICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgX2V2ZW50LmRldGFpbC5jb21wb25lbnRJbmRleCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnRzKHRoaXMuY29uc3RydWN0b3IpLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgdGhpcy4jbm9kZS5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBDb21wb25lbnQpOiBudW1iZXIgeyByZXR1cm4gQ29tcG9uZW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxuXG5cbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRydWUsIHdoZW4gb25seSBvbmUgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBjbGFzcyBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlXG4gICAgICovXG4gICAgcHVibGljIGdldCBpc1NpbmdsZXRvbigpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5vZGUsIHRoaXMgY29tcG9uZW50IGlzIGN1cnJlbnRseSBhdHRhY2hlZCB0b1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbm9kZSgpOiBOb2RlIHwgbnVsbCB7XG4gICAgICByZXR1cm4gdGhpcy4jbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZSB0aGlzIGNvbXBvbmVudC4gSW5hY3RpdmUgY29tcG9uZW50cyB3aWxsIG5vdCBiZSBwcm9jZXNzZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gX29uO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5DT01QT05FTlRfQUNUSVZBVEUgOiBFVkVOVC5DT01QT05FTlRfREVBQ1RJVkFURSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoZSBnaXZlbiBub2RlLCByZW1vdmluZyBpdCBmcm9tIHRoZSBub2RlIGl0IHdhcyBhdHRhY2hlZCB0byBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgcHVibGljIGF0dGFjaFRvTm9kZShfY29udGFpbmVyOiBOb2RlIHwgbnVsbCk6IHZvaWQge1xuICAgICAgaWYgKHRoaXMuI25vZGUgPT0gX2NvbnRhaW5lcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHByZXZpb3VzQ29udGFpbmVyOiBOb2RlID0gdGhpcy4jbm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwcmV2aW91c0NvbnRhaW5lcilcbiAgICAgICAgICBwcmV2aW91c0NvbnRhaW5lci5yZW1vdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgIHRoaXMuI25vZGUgPSBfY29udGFpbmVyO1xuICAgICAgICBpZiAodGhpcy4jbm9kZSlcbiAgICAgICAgICB0aGlzLiNub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICB0aGlzLiNub2RlID0gcHJldmlvdXNDb250YWluZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xuICAgICAgICBhY3RpdmU6IHRoaXMuYWN0aXZlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICB0aGlzLmFjdGl2YXRlKF9zZXJpYWxpemF0aW9uLmFjdGl2ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLmFjdGl2ZSkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoX211dGF0b3IuYWN0aXZlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNpbmdsZXRvbjtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tdHhXb3JsZDtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFdyYXBzIGEgcmVndWxhciBKYXZhc2NyaXB0IEFycmF5IGFuZCBvZmZlcnMgdmVyeSBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkgZ2VhcmVkIHNvbGVseSB0b3dhcmRzIGF2b2lkaW5nIGdhcmJhZ2UgY29sbGV0aW9uLlxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZWN5Y2xlclxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlY3ljYWJsZUFycmF5PFQ+IHtcbiAgICAjbGVuZ3RoOiBudW1iZXIgPSAwO1xuICAgICNhcnJheTogQXJyYXk8VD4gPSBuZXcgQXJyYXk8VD4oKTtcbiAgICAvLyAjdHlwZTogbmV3ICgpID0+IFQ7XG5cbiAgICAvLyAvL3RzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAvLyBjb25zdHJ1Y3RvcihfdHlwZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVCkge1xuICAgIC8vICAgdGhpcy4jdHlwZSA9IF90eXBlO1xuICAgIC8vIH1cblxuICAgIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpcnR1YWwgbGVuZ3RoIG9mIHRoZSBhcnJheSB0byB6ZXJvIGJ1dCBrZWVwcyB0aGUgZW50cmllcyBiZXlvbmQuXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgICAgdGhpcy4jbGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN5Y2xlIHRoaXMgYXJyYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgbmV3IGVudHJ5IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgcHVibGljIHB1c2goX2VudHJ5OiBUKTogbnVtYmVyIHtcbiAgICAgIHRoaXMuI2FycmF5W3RoaXMuI2xlbmd0aF0gPSBfZW50cnk7XG4gICAgICB0aGlzLiNsZW5ndGgrKztcbiAgICAgIHJldHVybiB0aGlzLiNsZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBlbnRyeSBmcm9tIHRoZSBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcG9wKCk6IFQge1xuICAgICAgdGhpcy4jbGVuZ3RoLS07XG4gICAgICByZXR1cm4gdGhpcy4jYXJyYXlbdGhpcy4jbGVuZ3RoXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN5Y2xlcyB0aGUgb2JqZWN0IGZvbGxvd2luZyB0aGUgbGFzdCBpbiB0aGUgYXJyYXkgYW5kIGluY3JlYXNlcyB0aGUgYXJyYXkgbGVuZ3RoXG4gICAgICogSXQgbXVzdCBiZSBhc3N1cmVkLCB0aGF0IG5vbmUgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5IGlzIHN0aWxsIGluIGFueSB1c2Ugb2YgYW55IGtpbmQhXG4gICAgICovXG4gICAgLy8gcHVibGljIHJlY3ljbGUoKTogVCB7XG4gICAgLy8gICBpZiAodGhpcy4jbGVuZ3RoIDwgdGhpcy4jYXJyYXkubGVuZ3RoKSB7XG4gICAgLy8gICAgIHRoaXMuI2xlbmd0aCsrO1xuICAgIC8vICAgICByZXR1cm4gdGhpcy4jYXJyYXlbdGhpcy4jbGVuZ3RoKytdO1xuICAgIC8vICAgfVxuICAgIC8vICAgdGhpcy4jYXJyYXkucHVzaChSZWN5Y2xlci5nZXQodGhpcy4jdHlwZSkpO1xuICAgIC8vICAgcmV0dXJuIHRoaXMuI2FycmF5W3RoaXMuI2xlbmd0aCsrXTtcbiAgICAvLyB9XG5cbiAgICBwdWJsaWMgKltTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8VD4ge1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuI2xlbmd0aDsgaSsrKVxuICAgICAgICB5aWVsZCB0aGlzLiNhcnJheVtpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgYXJyYXkgc29ydGVkIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gY29tcGFyZSBmdW5jdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTb3J0ZWQoX3NvcnQ6IChhOiBULCBiOiBUKSA9PiBudW1iZXIpOiBUW10ge1xuICAgICAgbGV0IHNvcnRlZDogVFtdID0gdGhpcy4jYXJyYXkuc2xpY2UoMCwgdGhpcy4jbGVuZ3RoKTtcbiAgICAgIHNvcnRlZC5zb3J0KF9zb3J0KTtcbiAgICAgIHJldHVybiBzb3J0ZWQ7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIFxuICAvKipcbiAgICogQmFzZWNsYXNzIGZvciB7QGxpbmsgUmVuZGVySW5qZWN0b3JDb2F0fSBhbmQge0BsaW5rIFJlbmRlckluamVjdG9yVGV4dHVyZX1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3Ige1xuXG4gICAgLyoqXG4gICAgICogSW5qZWN0cyB0aGUgZ2l2ZW4gY29uc3RydWN0b3Igd2l0aCB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGUgZ2l2ZW4gaW5qZWN0b3IuIE5hbWUgb2YgdGhlIGNvbnN0cnVjdG9yIGFuZCB0aGUgbmFtZSBvZiB0aGUgaW5qZWN0b3IgbWV0aG9kIG11c3QgbWF0Y2guXG4gICAgICogVXNlZCBpbiBzdWJjbGFzc2VzIG9mIHRoaXMgY2xhc3MuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpbmplY3QoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbiwgX2luamVjdG9yOiB0eXBlb2YgUmVuZGVySW5qZWN0b3IpOiB2b2lkIHtcbiAgICAgIGxldCBpbmplY3Rpb246IEZ1bmN0aW9uID0gUmVmbGVjdC5nZXQoX2luamVjdG9yLCBcImluamVjdFwiICsgX2NvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgaWYgKCFpbmplY3Rpb24pIHtcbiAgICAgICAgRGVidWcuZXJyb3IoXCJObyBpbmplY3Rpb24gZGVjb3JhdG9yIGRlZmluZWQgZm9yIFwiICsgX2NvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwidXNlUmVuZGVyRGF0YVwiLCB7XG4gICAgICAgIHZhbHVlOiBpbmplY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIC8qKlxuICAgKiBHaXZlcyBXZWJHTCBCdWZmZXIgdGhlIGRhdGEgZnJvbSB0aGUge0BsaW5rIFNoYWRlcn1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JTaGFkZXIge1xuICAgIC8qKlxuICAgICAqIEluamVjdHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhpcyBjbGFzcyBpbnRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZ2l2ZW4ge0BsaW5rIFNoYWRlcn0tc3ViY2xhc3NcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIFwidXNlUHJvZ3JhbVwiLCB7XG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci51c2VQcm9ncmFtXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIFwiZGVsZXRlUHJvZ3JhbVwiLCB7XG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci5kZWxldGVQcm9ncmFtXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIFwiY3JlYXRlUHJvZ3JhbVwiLCB7XG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci5jcmVhdGVQcm9ncmFtXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhpcyBwcm9ncmFtIHRvIHVzZSBhcyB0aGUgYWN0aXZlIHByb2dyYW0gaW4gV2ViR0xcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHVzZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xuICAgICAgaWYgKCF0aGlzLnByb2dyYW0pXG4gICAgICAgIHRoaXMuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcbiAgICAgIGNyYzMudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhpcyBwcm9ncmFtIGZyb20gV2ViR0wsIGNsZWFyaW5nIHRoZSB1c2VkIG1lbW9yeSBvbiB0aGUgR1BVLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcbiAgICAgIGlmICh0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgY3JjMy5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuaWZvcm1zO1xuICAgICAgICBkZWxldGUgdGhpcy5wcm9ncmFtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XG4gICAgICBEZWJ1Zy5mdWRnZShcIkNyZWF0ZSBzaGFkZXIgcHJvZ3JhbVwiLCB0aGlzLm5hbWUpO1xuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgICBsZXQgcHJvZ3JhbTogV2ViR0xQcm9ncmFtID0gY3JjMy5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzaGRWZXJ0ZXg6IFdlYkdMU2hhZGVyID0gY29tcGlsZVNoYWRlcih0aGlzLmdldFZlcnRleFNoYWRlclNvdXJjZSgpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlZFUlRFWF9TSEFERVIpO1xuICAgICAgICBsZXQgc2hkRnJhZ21lbnQ6IFdlYkdMU2hhZGVyID0gY29tcGlsZVNoYWRlcih0aGlzLmdldEZyYWdtZW50U2hhZGVyU291cmNlKCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBR01FTlRfU0hBREVSKTtcblxuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xTaGFkZXI+KHNoZFZlcnRleCkpO1xuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xTaGFkZXI+KHNoZEZyYWdtZW50KSk7XG4gICAgICAgIGNyYzMubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgICAgbGV0IGVycm9yOiBzdHJpbmcgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8c3RyaW5nPihjcmMzLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgbGlua2luZyBTaGFkZXI6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gZGV0ZWN0QXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0gZGV0ZWN0VW5pZm9ybXMoKTtcblxuICAgICAgICBpZiAodGhpcy5kZWZpbmUuaW5jbHVkZXMoXCJTS0lOXCIpKSB7XG4gICAgICAgICAgY29uc3QgYmxvY2tJbmRleDogbnVtYmVyID0gY3JjMy5nZXRVbmlmb3JtQmxvY2tJbmRleChwcm9ncmFtLCBVTklGT1JNX0JMT0NLUy5TS0lOLk5BTUUpO1xuICAgICAgICAgIGNyYzMudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtLCBibG9ja0luZGV4LCBVTklGT1JNX0JMT0NLUy5TS0lOLkJJTkRJTkcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGVmaW5lLmluY2x1ZGVzKFwiTElHSFRcIikpIHtcbiAgICAgICAgICBpZiAoIVJlbmRlcldlYkdMLnVib0xpZ2h0cylcbiAgICAgICAgICAgIFJlbmRlcldlYkdMLnVib0xpZ2h0cyA9IGNyZWF0ZVVCT0xpZ2h0cygpO1xuICAgICAgICAgIGlmICghUmVuZGVyV2ViR0wudWJvTGlnaHRzVmFyaWFibGVPZmZzZXRzKVxuICAgICAgICAgICAgUmVuZGVyV2ViR0wudWJvTGlnaHRzVmFyaWFibGVPZmZzZXRzID0gZGV0ZWN0VUJPTGlnaHRzVmFyaWFibGVPZmZzZXRzKCk7XG4gIFxuICAgICAgICAgIC8vIGJpbmQgbGlnaHRzIFVCTyB0byBzaGFkZXIgcHJvZ3JhbVxuICAgICAgICAgIGNvbnN0IGJsb2NrSW5kZXg6IG51bWJlciA9IGNyYzMuZ2V0VW5pZm9ybUJsb2NrSW5kZXgocHJvZ3JhbSwgVU5JRk9STV9CTE9DS1MuTElHSFRTLk5BTUUpO1xuICAgICAgICAgIGNyYzMudW5pZm9ybUJsb2NrQmluZGluZyhwcm9ncmFtLCBibG9ja0luZGV4LCBVTklGT1JNX0JMT0NLUy5MSUdIVFMuQklORElORyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGlsZVNoYWRlcihfc2hhZGVyQ29kZTogc3RyaW5nLCBfc2hhZGVyVHlwZTogR0xlbnVtKTogV2ViR0xTaGFkZXIgfCBudWxsIHtcbiAgICAgICAgbGV0IHdlYkdMU2hhZGVyOiBXZWJHTFNoYWRlciA9IGNyYzMuY3JlYXRlU2hhZGVyKF9zaGFkZXJUeXBlKTtcbiAgICAgICAgY3JjMy5zaGFkZXJTb3VyY2Uod2ViR0xTaGFkZXIsIF9zaGFkZXJDb2RlKTtcbiAgICAgICAgY3JjMy5jb21waWxlU2hhZGVyKHdlYkdMU2hhZGVyKTtcbiAgICAgICAgbGV0IGVycm9yOiBzdHJpbmcgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8c3RyaW5nPihjcmMzLmdldFNoYWRlckluZm9Mb2cod2ViR0xTaGFkZXIpKTtcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coX3NoYWRlckNvZGUpO1xuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY29tcGlsaW5nIHNoYWRlcjogXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBjb21waWxhdGlvbiBlcnJvcnMuXG4gICAgICAgIGlmICghY3JjMy5nZXRTaGFkZXJQYXJhbWV0ZXIod2ViR0xTaGFkZXIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgYWxlcnQoY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlYkdMU2hhZGVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZXRlY3RBdHRyaWJ1dGVzKCk6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9IHtcbiAgICAgICAgbGV0IGRldGVjdGVkQXR0cmlidXRlczogeyBbbmFtZTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcbiAgICAgICAgbGV0IGF0dHJpYnV0ZUNvdW50OiBudW1iZXIgPSBjcmMzLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBhdHRyaWJ1dGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGF0dHJpYnV0ZUluZm86IFdlYkdMQWN0aXZlSW5mbyA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTEFjdGl2ZUluZm8+KGNyYzMuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpKTtcbiAgICAgICAgICBpZiAoIWF0dHJpYnV0ZUluZm8pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkQXR0cmlidXRlc1thdHRyaWJ1dGVJbmZvLm5hbWVdID0gY3JjMy5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGVJbmZvLm5hbWUpO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRldGVjdGVkQXR0cmlidXRlcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZWN0VW5pZm9ybXMoKTogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSB7XG4gICAgICAgIGxldCBkZXRlY3RlZFVuaWZvcm1zOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9ID0ge307XG4gICAgICAgIGxldCB1bmlmb3JtQ291bnQ6IG51bWJlciA9IGNyYzMuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFDVElWRV9VTklGT1JNUyk7XG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xuICAgICAgICAgIGxldCBpbmZvOiBXZWJHTEFjdGl2ZUluZm8gPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xBY3RpdmVJbmZvPihjcmMzLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSkpO1xuICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBsb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBjcmMzLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpO1xuICAgICAgICAgIGlmIChsb2NhdGlvbilcbiAgICAgICAgICAgIGRldGVjdGVkVW5pZm9ybXNbaW5mby5uYW1lXSA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFVuaWZvcm1Mb2NhdGlvbj4obG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRlY3RlZFVuaWZvcm1zO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVVQk9MaWdodHMoKTogV2ViR0xCdWZmZXIge1xuICAgICAgICBjb25zdCBibG9ja0luZGV4OiBudW1iZXIgPSBjcmMzLmdldFVuaWZvcm1CbG9ja0luZGV4KHByb2dyYW0sIFVOSUZPUk1fQkxPQ0tTLkxJR0hUUy5OQU1FKTtcbiAgICAgICAgY29uc3QgYmxvY2tTaXplOiBudW1iZXIgPSBjcmMzLmdldEFjdGl2ZVVuaWZvcm1CbG9ja1BhcmFtZXRlcihwcm9ncmFtLCBibG9ja0luZGV4LCBjcmMzLlVOSUZPUk1fQkxPQ0tfREFUQV9TSVpFKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHVibzogV2ViR0xCdWZmZXIgPSBSZW5kZXJXZWJHTC5hc3NlcnQoY3JjMy5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB1Ym8pO1xuICAgICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgYmxvY2tTaXplLCBjcmMzLkRZTkFNSUNfRFJBVyk7XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlckJhc2UoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgVU5JRk9STV9CTE9DS1MuTElHSFRTLkJJTkRJTkcsIHVibyk7XG5cbiAgICAgICAgcmV0dXJuIHVibztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0ZWN0VUJPTGlnaHRzVmFyaWFibGVPZmZzZXRzKCk6IHR5cGVvZiBSZW5kZXJXZWJHTC51Ym9MaWdodHNWYXJpYWJsZU9mZnNldHMge1xuICAgICAgICBjb25zdCB1Ym9WYXJpYWJsZU5hbWVzOiBzdHJpbmdbXSA9IFtcbiAgICAgICAgICBcInVfbkxpZ2h0c0RpcmVjdGlvbmFsXCIsXG4gICAgICAgICAgXCJ1X25MaWdodHNQb2ludFwiLFxuICAgICAgICAgIFwidV9uTGlnaHRzU3BvdFwiLFxuICAgICAgICAgIFwidV9hbWJpZW50LnZjdENvbG9yXCIsXG4gICAgICAgICAgXCJ1X2RpcmVjdGlvbmFsWzBdLnZjdENvbG9yXCIsXG4gICAgICAgICAgXCJ1X3BvaW50WzBdLnZjdENvbG9yXCIsXG4gICAgICAgICAgXCJ1X3Nwb3RbMF0udmN0Q29sb3JcIlxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHVib1ZhcmlhYmxlSW5kaWNlczogbnVtYmVyW10gPSA8bnVtYmVyW10+Y3JjMy5nZXRVbmlmb3JtSW5kaWNlcyhcbiAgICAgICAgICBwcm9ncmFtLFxuICAgICAgICAgIHVib1ZhcmlhYmxlTmFtZXNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB1Ym9WYXJpYWJsZU9mZnNldHM6IG51bWJlcltdID0gY3JjMy5nZXRBY3RpdmVVbmlmb3JtcyhcbiAgICAgICAgICBwcm9ncmFtLFxuICAgICAgICAgIHVib1ZhcmlhYmxlSW5kaWNlcyxcbiAgICAgICAgICBjcmMzLlVOSUZPUk1fT0ZGU0VUXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgdWJvVmFyaWFibGVOYW1lVG9PZmZzZXQ6IHR5cGVvZiBSZW5kZXJXZWJHTC51Ym9MaWdodHNWYXJpYWJsZU9mZnNldHMgPSB7fTtcbiAgICAgICAgdWJvVmFyaWFibGVOYW1lcy5mb3JFYWNoKChfbmFtZSwgX2luZGV4KSA9PiB1Ym9WYXJpYWJsZU5hbWVUb09mZnNldFtfbmFtZV0gPSB1Ym9WYXJpYWJsZU9mZnNldHNbX2luZGV4XSk7XG5cbiAgICAgICAgcmV0dXJuIHVib1ZhcmlhYmxlTmFtZVRvT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIC8qKlxuICAgKiBHaXZlcyBXZWJHTCBCdWZmZXIgdGhlIGRhdGEgZnJvbSB0aGUge0BsaW5rIENvYXR9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yQ29hdCBleHRlbmRzIFJlbmRlckluamVjdG9yIHtcbiAgICAvKipcbiAgICAgKiBJbmplY3RzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHRoaXMgY2xhc3MgaW50byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGdpdmVuIHtAbGluayBDb2F0fS1zdWJjbGFzc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgUmVuZGVySW5qZWN0b3IuaW5qZWN0KF9jb25zdHJ1Y3RvciwgUmVuZGVySW5qZWN0b3JDb2F0KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRDb2xvcmVkKHRoaXM6IENvYXRDb2xvcmVkLCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7XG4gICAgICBsZXQgdW5pZm9ybTogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBfc2hhZGVyLnVuaWZvcm1zW1widV92Y3RDb2xvclwiXTtcbiAgICAgIGxldCBjb2xvcjogQ29sb3IgPSBDb2xvci5NVUxUSVBMWSh0aGlzLmNvbG9yLCBfY21wTWF0ZXJpYWwuY2xyUHJpbWFyeSk7XG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTRmdih1bmlmb3JtLCBjb2xvci5nZXRBcnJheSgpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRSZW1pc3NpdmUodGhpczogQ29hdFJlbWlzc2l2ZSwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQge1xuICAgICAgUmVuZGVySW5qZWN0b3JDb2F0LmluamVjdENvYXRDb2xvcmVkLmNhbGwodGhpcywgX3NoYWRlciwgX2NtcE1hdGVyaWFsKTtcbiAgICAgIGxldCB1bmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9mU3BlY3VsYXJcIl07XG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTFmKHVuaWZvcm0sIHRoaXMuc3BlY3VsYXIpO1xuICAgICAgdW5pZm9ybSA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2ZEaWZmdXNlXCJdO1xuICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm0xZih1bmlmb3JtLCB0aGlzLmRpZmZ1c2UpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5qZWN0Q29hdFRleHR1cmVkKHRoaXM6IENvYXRUZXh0dXJlZCwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQge1xuICAgICAgUmVuZGVySW5qZWN0b3JDb2F0LmluamVjdENvYXRDb2xvcmVkLmNhbGwodGhpcywgX3NoYWRlciwgX2NtcE1hdGVyaWFsKTtcblxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgICB0aGlzLnRleHR1cmUudXNlUmVuZGVyRGF0YSgpO1xuICAgICAgY3JjMy51bmlmb3JtMWkoX3NoYWRlci51bmlmb3Jtc1tcInVfdGV4dHVyZVwiXSwgMCk7XG4gICAgICBjcmMzLnVuaWZvcm1NYXRyaXgzZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4UGl2b3RcIl0sIGZhbHNlLCBfY21wTWF0ZXJpYWwubXR4UGl2b3QuZ2V0KCkpO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRSZW1pc3NpdmVUZXh0dXJlZCh0aGlzOiBDb2F0UmVtaXNzaXZlVGV4dHVyZWQsIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwpOiB2b2lkIHtcbiAgICAgIFJlbmRlckluamVjdG9yQ29hdC5pbmplY3RDb2F0UmVtaXNzaXZlLmNhbGwodGhpcywgX3NoYWRlciwgX2NtcE1hdGVyaWFsKTtcblxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgICB0aGlzLnRleHR1cmUudXNlUmVuZGVyRGF0YSgpO1xuICAgICAgY3JjMy51bmlmb3JtMWkoX3NoYWRlci51bmlmb3Jtc1tcInVfdGV4dHVyZVwiXSwgMCk7XG4gICAgICBjcmMzLnVuaWZvcm1NYXRyaXgzZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4UGl2b3RcIl0sIGZhbHNlLCBfY21wTWF0ZXJpYWwubXR4UGl2b3QuZ2V0KCkpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIC8qKlxuICAgKiBCdWZmZXJzIHRoZSBkYXRhIGZyb20gdGhlIHtAbGluayBNZXNofSBpbnRvIGEgV2ViR0wgQnVmZmVyXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yTWVzaCB7XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3RzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHRoaXMgY2xhc3MgaW50byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGdpdmVuIHtAbGluayBNZXNofS1zdWJjbGFzc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwidXNlUmVuZGVyQnVmZmVyc1wiLCB7XG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2gudXNlUmVuZGVyQnVmZmVyc1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJnZXRSZW5kZXJCdWZmZXJzXCIsIHtcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC5nZXRSZW5kZXJCdWZmZXJzXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImRlbGV0ZVJlbmRlckJ1ZmZlcnNcIiwge1xuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLmRlbGV0ZVJlbmRlckJ1ZmZlcnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgZ2V0UmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoLCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyKTogUmVuZGVyQnVmZmVycyB7XG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcblxuICAgICAgdGhpcy5yZW5kZXJNZXNoID0gdGhpcy5yZW5kZXJNZXNoIHx8IG5ldyBSZW5kZXJNZXNoKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5yZW5kZXJNZXNoLmJ1ZmZlcnMgPT0gbnVsbClcbiAgICAgICAgdGhpcy5yZW5kZXJNZXNoLmJ1ZmZlcnMgPSB7XG4gICAgICAgICAgdmVydGljZXM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLnZlcnRpY2VzKSxcbiAgICAgICAgICBpbmRpY2VzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLmluZGljZXMpLFxuICAgICAgICAgIG5vcm1hbHM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLm5vcm1hbHMpLFxuICAgICAgICAgIHRleHR1cmVVVnM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLnRleHR1cmVVVnMpLFxuICAgICAgICAgIGNvbG9yczogY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2guY29sb3JzKSxcbiAgICAgICAgICBuSW5kaWNlczogdGhpcy5yZW5kZXJNZXNoLmluZGljZXMubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLmJ1ZmZlcnM7XG5cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKF90eXBlOiBHTGVudW0sIF9hcnJheTogRmxvYXQzMkFycmF5IHwgVWludDE2QXJyYXkpOiBXZWJHTEJ1ZmZlciB7XG4gICAgICAgIGxldCBidWZmZXI6IFdlYkdMQnVmZmVyID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMQnVmZmVyPihjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKF90eXBlLCBidWZmZXIpO1xuICAgICAgICBjcmMzLmJ1ZmZlckRhdGEoX3R5cGUsIF9hcnJheSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB1c2VSZW5kZXJCdWZmZXJzKHRoaXM6IE1lc2gsIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9tdHhNZXNoVG9Xb3JsZDogTWF0cml4NHg0LCBfbXR4TWVzaFRvVmlldzogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIpOiBSZW5kZXJCdWZmZXJzIHtcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gdGhpcy5nZXRSZW5kZXJCdWZmZXJzKF9zaGFkZXIpO1xuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldEJ1ZmZlcihfbmFtZTogc3RyaW5nLCBfYnVmZmVyOiBXZWJHTEJ1ZmZlciwgX3NpemU6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgYXR0cmlidXRlOiBudW1iZXIgPSBfc2hhZGVyLmF0dHJpYnV0ZXNbX25hbWVdO1xuICAgICAgICBpZiAoYXR0cmlidXRlID09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgX2J1ZmZlcik7XG4gICAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlKTtcbiAgICAgICAgUmVuZGVyV2ViR0wuc2V0QXR0cmlidXRlU3RydWN0dXJlKFxuICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICB7IHNpemU6IF9zaXplLCBkYXRhVHlwZTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgbm9ybWFsaXplOiBmYWxzZSwgc3RyaWRlOiAwLCBvZmZzZXQ6IDAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgdW5pZm9ybTogV2ViR0xVbmlmb3JtTG9jYXRpb247XG5cbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhNZXNoVG9WaWV3XCJdO1xuICAgICAgY3JjMy51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm0sIGZhbHNlLCBfbXR4TWVzaFRvVmlldy5nZXQoKSk7XG5cbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhNZXNoVG9Xb3JsZFwiXTtcbiAgICAgIGlmICh1bmlmb3JtKVxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybSwgZmFsc2UsIF9tdHhNZXNoVG9Xb3JsZC5nZXQoKSk7XG5cbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhOb3JtYWxNZXNoVG9Xb3JsZFwiXTtcbiAgICAgIGlmICh1bmlmb3JtKSB7XG4gICAgICAgIGxldCBub3JtYWxNYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5UUkFOU1BPU0UoTWF0cml4NHg0LklOVkVSU0lPTihfbXR4TWVzaFRvV29ybGQpKTtcbiAgICAgICAgY3JjMy51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm0sIGZhbHNlLCBub3JtYWxNYXRyaXguZ2V0KCkpO1xuICAgICAgfVxuXG4gICAgICBzZXRCdWZmZXIoXCJhX3ZjdFBvc2l0aW9uXCIsIHJlbmRlckJ1ZmZlcnMudmVydGljZXMsIDMpO1xuICAgICAgc2V0QnVmZmVyKFwiYV92Y3ROb3JtYWxcIiwgcmVuZGVyQnVmZmVycy5ub3JtYWxzLCAzKTtcbiAgICAgIHNldEJ1ZmZlcihcImFfdmN0Q29sb3JcIiwgcmVuZGVyQnVmZmVycy5jb2xvcnMsIDQpO1xuXG4gICAgICAvLyBmZWVkIGluIHRleHR1cmUgY29vcmRpbmF0ZXMgaWYgc2hhZGVyIGFjY2VwdHMgYV92Y3RUZXh0dXJlXG4gICAgICBsZXQgYXR0cmlidXRlOiBudW1iZXIgPSBfc2hhZGVyLmF0dHJpYnV0ZXNbXCJhX3ZjdFRleHR1cmVcIl07XG4gICAgICBpZiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgcmVuZGVyQnVmZmVycy50ZXh0dXJlVVZzKTtcbiAgICAgICAgY3JjMy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGUpOyAvLyBlbmFibGUgdGhlIGJ1ZmZlclxuICAgICAgICBjcmMzLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmlidXRlLCAyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZlZWQgaW4gYW4gaWQgb2YgdGhlIG5vZGUgaWYgc2hhZGVyIGFjY2VwdHMgdV9pZC4gVXNlZCBmb3IgcGlja2luZ1xuICAgICAgdW5pZm9ybSA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2lkXCJdO1xuICAgICAgaWYgKHVuaWZvcm0pXG4gICAgICAgIFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKS51bmlmb3JtMWkodW5pZm9ybSwgX2lkKTtcblxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHJlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XG4gICAgICByZXR1cm4gcmVuZGVyQnVmZmVycztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMpOiB2b2lkIHtcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xuICAgICAgaWYgKF9yZW5kZXJCdWZmZXJzKSB7XG4gICAgICAgIC8vIFRPRE86IGNsZWFudXAgYWxsIGJ1ZmZlcnMsIGZsYXQvbm9ybWFscyBpcyBtaXNzaW5nLi4uXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICAgIGNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLnZlcnRpY2VzKTtcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMudGV4dHVyZVVWcyk7XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBQYXJ0aWNsZURhdGEge1xuXG4gICAgZXhwb3J0IGVudW0gRlVOQ1RJT04ge1xuICAgICAgLy8gVkFMVUUgPSBcInZhbHVlXCIsXG4gICAgICBBRERJVElPTiA9IFwiYWRkaXRpb25cIixcbiAgICAgIFNVQlRSQUNUSU9OID0gXCJzdWJ0cmFjdGlvblwiLFxuICAgICAgTVVMVElQTElDQVRJT04gPSBcIm11bHRpcGxpY2F0aW9uXCIsXG4gICAgICBESVZJU0lPTiA9IFwiZGl2aXNpb25cIixcbiAgICAgIE1PRFVMTyA9IFwibW9kdWxvXCIsXG4gICAgICBQT1dFUiA9IFwicG93ZXJcIixcbiAgICAgIFBPTFlOT01JQUwzID0gXCJwb2x5bm9taWFsM1wiLFxuICAgICAgU1FVQVJFX1JPT1QgPSBcInNxdWFyZVJvb3RcIixcbiAgICAgIFJBTkRPTSA9IFwicmFuZG9tXCIsXG4gICAgICBSQU5ET01fUkFOR0UgPSBcInJhbmRvbVJhbmdlXCJcbiAgICB9XG5cbiAgICBleHBvcnQgY29uc3QgRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTOiB7IFtrZXkgaW4gUGFydGljbGVEYXRhLkZVTkNUSU9OXTogbnVtYmVyIH0gPSB7XG4gICAgICAvLyBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlZBTFVFXTogMSxcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uQURESVRJT05dOiAyLFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5TVUJUUkFDVElPTl06IDIsXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLk1VTFRJUExJQ0FUSU9OXTogMixcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uRElWSVNJT05dOiAyLFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5NT0RVTE9dOiAyLFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5QT1dFUl06IDIsXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlBPTFlOT01JQUwzXTogNSxcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uU1FVQVJFX1JPT1RdOiAxLFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5SQU5ET01dOiAxLFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5SQU5ET01fUkFOR0VdOiAzXG4gICAgfTtcblxuICAgIGV4cG9ydCBjb25zdCBQUkVERUZJTkVEX1ZBUklBQkxFUzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICAgIHN5c3RlbUR1cmF0aW9uOiBcInVfZlBhcnRpY2xlU3lzdGVtRHVyYXRpb25cIixcbiAgICAgIHN5c3RlbVNpemU6IFwidV9mUGFydGljbGVTeXN0ZW1TaXplXCIsXG4gICAgICBzeXN0ZW1UaW1lOiBcInVfZlBhcnRpY2xlU3lzdGVtVGltZVwiLFxuICAgICAgcGFydGljbGVJZDogXCJmUGFydGljbGVJZFwiXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlcyBwYXJ0aWNsZSBzeXN0ZW0gc2hhZGVycyAoe0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfSkgZnJvbSBzaGFkZXIgdW5pdmVyc2FsIGRlcml2YXRlcyBmb3IgV2ViR0xcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0gZXh0ZW5kcyBSZW5kZXJJbmplY3RvclNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBGVU5DVElPTlM6IHsgW2tleSBpbiBQYXJ0aWNsZURhdGEuRlVOQ1RJT05dOiBGdW5jdGlvbiB9ID0ge1xuICAgICAgLy8gW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5WQUxVRV06IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcbiAgICAgIC8vICAgcmV0dXJuIGAoJHtfcGFyYW1ldGVyc1swXX0pYDtcbiAgICAgIC8vIH0sXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLkFERElUSU9OXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICByZXR1cm4gYCgke19wYXJhbWV0ZXJzLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF92YWx1ZTogc3RyaW5nKSA9PiBgJHtfYWNjdW11bGF0b3J9ICsgJHtfdmFsdWV9YCl9KWA7XG4gICAgICB9LFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5TVUJUUkFDVElPTl06IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgcmV0dXJuIGAoJHtfcGFyYW1ldGVycy5yZWR1Y2UoKF9hY2N1bXVsYXRvcjogc3RyaW5nLCBfdmFsdWU6IHN0cmluZykgPT4gYCR7X2FjY3VtdWxhdG9yfSAtICR7X3ZhbHVlfWApfSlgO1xuICAgICAgfSxcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uTVVMVElQTElDQVRJT05dOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIHJldHVybiBgKCR7X3BhcmFtZXRlcnMucmVkdWNlKChfYWNjdW11bGF0b3I6IHN0cmluZywgX3ZhbHVlOiBzdHJpbmcpID0+IGAke19hY2N1bXVsYXRvcn0gKiAke192YWx1ZX1gKX0pYDtcbiAgICAgIH0sXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLkRJVklTSU9OXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICByZXR1cm4gYCgke19wYXJhbWV0ZXJzWzBdfSAvICR7X3BhcmFtZXRlcnNbMV19KWA7XG4gICAgICB9LFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5NT0RVTE9dOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIHJldHVybiBgKCR7X3BhcmFtZXRlcnMucmVkdWNlKChfYWNjdW11bGF0b3I6IHN0cmluZywgX3ZhbHVlOiBzdHJpbmcpID0+IGBtb2QoJHtfYWNjdW11bGF0b3J9LCAke192YWx1ZX0pYCl9KWA7XG4gICAgICB9LFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5QT1dFUl06IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgcmV0dXJuIGBwb3coJHtfcGFyYW1ldGVyc1swXX0sICR7X3BhcmFtZXRlcnNbMV19KWA7XG4gICAgICB9LFxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5QT0xZTk9NSUFMM106IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgbGV0IHg6IHN0cmluZyA9IF9wYXJhbWV0ZXJzWzBdO1xuICAgICAgICBsZXQgYTogc3RyaW5nID0gX3BhcmFtZXRlcnNbMV07XG4gICAgICAgIGxldCBiOiBzdHJpbmcgPSBfcGFyYW1ldGVyc1syXTtcbiAgICAgICAgbGV0IGM6IHN0cmluZyA9IF9wYXJhbWV0ZXJzWzNdO1xuICAgICAgICBsZXQgZDogc3RyaW5nID0gX3BhcmFtZXRlcnNbNF07XG4gICAgICAgIHJldHVybiBgKCR7YX0gKiBwb3coJHt4fSwgMy4wKSArICR7Yn0gKiBwb3coJHt4fSwgMi4wKSArICR7Y30gKiAke3h9ICsgJHtkfSlgO1xuICAgICAgfSxcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uU1FVQVJFX1JPT1RdOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIGxldCB4OiBzdHJpbmcgPSBfcGFyYW1ldGVyc1swXTtcbiAgICAgICAgcmV0dXJuIGBzcXJ0KCR7eH0pYDtcbiAgICAgIH0sXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlJBTkRPTV06IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgcmV0dXJuIGBmZXRjaFJhbmRvbU51bWJlcihpbnQoJHtfcGFyYW1ldGVyc1swXX0pLCBpUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSwgaVBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVyc0xlbmd0aClgO1xuICAgICAgfSxcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uUkFORE9NX1JBTkdFXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICByZXR1cm4gYCgke1JlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uRlVOQ1RJT05TW1wicmFuZG9tXCJdKF9wYXJhbWV0ZXJzKX0gKiAoJHtfcGFyYW1ldGVyc1syXX0gLSAke19wYXJhbWV0ZXJzWzFdfSkgKyAke19wYXJhbWV0ZXJzWzFdfSlgO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwdWJsaWMgc3RhdGljIG92ZXJyaWRlIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgIHN1cGVyLmRlY29yYXRlKF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiZ2V0VmVydGV4U2hhZGVyU291cmNlXCIsIHtcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2V0VmVydGV4U2hhZGVyU291cmNlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImdldEZyYWdtZW50U2hhZGVyU291cmNlXCIsIHtcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgc291cmNlIGNvZGUgZm9yIHRoZSB2ZXJ0ZXggc2hhZGVyIG9mIHRoZSB7QGxpbmsgU2hhZGVyUGFydGljbGVTeXN0ZW19IGZyb20gdGhlIHNldCB7QGxpbmsgU2hhZGVyUGFydGljbGVTeXN0ZW0uZGF0YX0gYW5kIHRoZSBvcmlnaW5hbCB7QGxpbmsgU2hhZGVyUGFydGljbGVTeXN0ZW0udmVydGV4U2hhZGVyU291cmNlfS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSh0aGlzOiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSk6IHN0cmluZyB7XG4gICAgICBsZXQgZGF0YTogUGFydGljbGVEYXRhLlN5c3RlbSA9IHRoaXMuZGF0YTtcbiAgICAgIGxldCBtdHhMb2NhbDogUGFydGljbGVEYXRhLlRyYW5zZm9ybWF0aW9uW10gPSBkYXRhPy5tdHhMb2NhbDtcbiAgICAgIGxldCBtdHhXb3JsZDogUGFydGljbGVEYXRhLlRyYW5zZm9ybWF0aW9uW10gPSBkYXRhPy5tdHhXb3JsZDtcblxuICAgICAgbGV0IHNvdXJjZTogc3RyaW5nID0gdGhpcy52ZXJ0ZXhTaGFkZXJTb3VyY2VcbiAgICAgICAgLnJlcGxhY2UoXCIjdmVyc2lvbiAzMDAgZXNcIiwgYCN2ZXJzaW9uIDMwMCBlc1xcbiNkZWZpbmUgJHt0aGlzLmRlZmluZVswXX0ke2RhdGEuY29sb3IgPyBcIlxcbiNkZWZpbmUgUEFSVElDTEVfQ09MT1JcIiA6IFwiXCJ9YClcbiAgICAgICAgLnJlcGxhY2UoXCIvKiR2YXJpYWJsZXMqL1wiLCBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlVmFyaWFibGVzKGRhdGE/LnZhcmlhYmxlcywgZGF0YT8udmFyaWFibGVOYW1lcykpXG4gICAgICAgIC5yZXBsYWNlKFwiLyokbXR4TG9jYWwqL1wiLCBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlVHJhbnNmb3JtYXRpb25zKG10eExvY2FsLCBcIkxvY2FsXCIpKVxuICAgICAgICAucmVwbGFjZShcIi8qJG10eExvY2FsKi9cIiwgbXR4TG9jYWwgJiYgbXR4TG9jYWwubGVuZ3RoID4gMCA/IFwiKiBtdHhMb2NhbFwiIDogXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhXb3JsZCovXCIsIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVUcmFuc2Zvcm1hdGlvbnMobXR4V29ybGQsIFwiV29ybGRcIikpXG4gICAgICAgIC5yZXBsYWNlKFwiLyokbXR4V29ybGQqL1wiLCBtdHhXb3JsZCAmJiBtdHhXb3JsZC5sZW5ndGggPiAwID8gXCJtdHhXb3JsZCAqXCIgOiBcIlwiKVxuICAgICAgICAucmVwbGFjZUFsbChcIi8qJGNvbG9yKi9cIiwgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZW5lcmF0ZUNvbG9yKGRhdGE/LmNvbG9yKSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgc291cmNlIGNvZGUgZm9yIHRoZSBmcmFnbWVudCBzaGFkZXIgb2YgdGhlIHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbX0gZnJvbSB0aGUgc2V0IHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbS5kYXRhfSBhbmQgdGhlIG9yaWdpbmFsIHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbS5mcmFnbWVudFNoYWRlclNvdXJjZX0uXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSh0aGlzOiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZS5yZXBsYWNlKFwiI3ZlcnNpb24gMzAwIGVzXCIsIGAjdmVyc2lvbiAzMDAgZXMke3RoaXMuZGF0YS5jb2xvciA/IFwiXFxuI2RlZmluZSBQQVJUSUNMRV9DT0xPUlwiIDogXCJcIn1gKTtcbiAgICB9XG5cbiAgICAvLyNyZWdpb24gY29kZSBnZW5lcmF0aW9uXG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVZhcmlhYmxlcyhfdmFyaWFibGVzOiBQYXJ0aWNsZURhdGEuU3lzdGVtW1widmFyaWFibGVzXCJdLCBfdmFyaWFibGVOYW1lczogUGFydGljbGVEYXRhLlN5c3RlbVtcInZhcmlhYmxlTmFtZXNcIl0pOiBzdHJpbmcge1xuICAgICAgaWYgKCFfdmFyaWFibGVzKSByZXR1cm4gXCJcIjtcblxuICAgICAgcmV0dXJuIF92YXJpYWJsZXNcbiAgICAgICAgLm1hcCgoX3ZhcmlhYmxlLCBfaW5kZXgpID0+ICh7IG5hbWU6IFwiZlBhcnRpY2xlU3lzdGVtVmFyaWFibGVfXCIgKyBfdmFyaWFibGVOYW1lc1tfaW5kZXhdLCB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZW5lcmF0ZUV4cHJlc3Npb24oX3ZhcmlhYmxlKSB9KSlcbiAgICAgICAgLm1hcChfdmFyaWFibGUgPT4gYGZsb2F0ICR7X3ZhcmlhYmxlLm5hbWV9ID0gJHtfdmFyaWFibGUudmFsdWV9O2ApXG4gICAgICAgIC5yZWR1Y2UoKF9hY2N1bXVsYXRvcjogc3RyaW5nLCBfY29kZTogc3RyaW5nKSA9PiBgJHtfYWNjdW11bGF0b3J9XFxuJHtfY29kZX1gLCBcIlwiKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVRyYW5zZm9ybWF0aW9ucyhfdHJhbnNmb3JtYXRpb25zOiBQYXJ0aWNsZURhdGEuU3lzdGVtW1wibXR4TG9jYWxcIl0sIF9sb2NhbE9yV29ybGQ6IFwiTG9jYWxcIiB8IFwiV29ybGRcIik6IHN0cmluZyB7XG4gICAgICBpZiAoIV90cmFuc2Zvcm1hdGlvbnMgfHwgX3RyYW5zZm9ybWF0aW9ucy5sZW5ndGggPT0gMCkgcmV0dXJuIFwiXCI7XG5cbiAgICAgIGxldCB0cmFuc2Zvcm1hdGlvbnM6IFtQYXJ0aWNsZURhdGEuVHJhbnNmb3JtYXRpb25bXCJ0cmFuc2Zvcm1hdGlvblwiXSwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ11bXSA9IF90cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgLm1hcChfZGF0YSA9PiB7XG4gICAgICAgICAgbGV0IGlzU2NhbGU6IGJvb2xlYW4gPSBfZGF0YS50cmFuc2Zvcm1hdGlvbiA9PT0gXCJzY2FsZVwiO1xuICAgICAgICAgIGxldCBbeCwgeSwgel0gPSBbX2RhdGEucGFyYW1ldGVyc1swXSwgX2RhdGEucGFyYW1ldGVyc1sxXSwgX2RhdGEucGFyYW1ldGVyc1syXV1cbiAgICAgICAgICAgIC5tYXAoKF92YWx1ZSkgPT4gX3ZhbHVlID8gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZW5lcmF0ZUV4cHJlc3Npb24oX3ZhbHVlKSA6IChpc1NjYWxlID8gXCIxLjBcIiA6IFwiMC4wXCIpKSBhcyBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG5cbiAgICAgICAgICByZXR1cm4gW19kYXRhLnRyYW5zZm9ybWF0aW9uLCB4LCB5LCB6XTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGxldCBjb2RlOiBzdHJpbmcgPSBcIlwiO1xuICAgICAgY29kZSArPSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgLm1hcCgoW190cmFuc2Zvcm1hdGlvbiwgX3gsIF95LCBfel0sIF9pbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgbGV0IHJvdGF0ZUlkOiBzdHJpbmcgPSBfaW5kZXggKyBfbG9jYWxPcldvcmxkO1xuICAgICAgICAgIGlmIChfdHJhbnNmb3JtYXRpb24gPT0gXCJyb3RhdGVcIikge1xuICAgICAgICAgICAgbGV0IHRvUmFkaWFuczogKF92YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmcgPSAoX3ZhbHVlOiBzdHJpbmcpID0+IGAke192YWx1ZX0gKiAke0NhbGMuZGVnMnJhZH1gO1xuICAgICAgICAgICAgcmV0dXJuIGBmbG9hdCBmWFJhZGlhbnMke3JvdGF0ZUlkfSA9ICR7dG9SYWRpYW5zKF94KX07XG4gICAgICAgICAgICAgIGZsb2F0IGZZUmFkaWFucyR7cm90YXRlSWR9ID0gJHt0b1JhZGlhbnMoX3kpfTtcbiAgICAgICAgICAgICAgZmxvYXQgZlpSYWRpYW5zJHtyb3RhdGVJZH0gPSAke3RvUmFkaWFucyhfeil9O1xuICAgICAgICAgICAgICBmbG9hdCBmU2luWCR7cm90YXRlSWR9ID0gc2luKGZYUmFkaWFucyR7cm90YXRlSWR9KTtcbiAgICAgICAgICAgICAgZmxvYXQgZkNvc1gke3JvdGF0ZUlkfSA9IGNvcyhmWFJhZGlhbnMke3JvdGF0ZUlkfSk7IFxuICAgICAgICAgICAgICBmbG9hdCBmU2luWSR7cm90YXRlSWR9ID0gc2luKGZZUmFkaWFucyR7cm90YXRlSWR9KTtcbiAgICAgICAgICAgICAgZmxvYXQgZkNvc1kke3JvdGF0ZUlkfSA9IGNvcyhmWVJhZGlhbnMke3JvdGF0ZUlkfSk7XG4gICAgICAgICAgICAgIGZsb2F0IGZTaW5aJHtyb3RhdGVJZH0gPSBzaW4oZlpSYWRpYW5zJHtyb3RhdGVJZH0pO1xuICAgICAgICAgICAgICBmbG9hdCBmQ29zWiR7cm90YXRlSWR9ID0gY29zKGZaUmFkaWFucyR7cm90YXRlSWR9KTtcXG5gO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKF90cmFuc2Zvcm1hdGlvbjogc3RyaW5nKSA9PiBfdHJhbnNmb3JtYXRpb24gIT0gXCJcIilcbiAgICAgICAgLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF9jb2RlOiBzdHJpbmcpID0+IGAke19hY2N1bXVsYXRvcn1cXG4ke19jb2RlfWAsIFwiXCIpO1xuICAgICAgY29kZSArPSBcIlxcblwiO1xuXG4gICAgICBjb2RlICs9IGBtYXQ0IG10eCR7X2xvY2FsT3JXb3JsZH0gPSBgO1xuICAgICAgY29kZSArPSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgLm1hcCgoW190cmFuc2Zvcm1hdGlvbiwgX3gsIF95LCBfel0sIF9pbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgbGV0IHJvdGF0ZUlkOiBzdHJpbmcgPSBfaW5kZXggKyBfbG9jYWxPcldvcmxkO1xuICAgICAgICAgIHN3aXRjaCAoX3RyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNsYXRlXCI6XG4gICAgICAgICAgICAgIHJldHVybiBgbWF0NChcbiAgICAgICAgICAgICAgMS4wLCAwLjAsIDAuMCwgMC4wLFxuICAgICAgICAgICAgICAwLjAsIDEuMCwgMC4wLCAwLjAsXG4gICAgICAgICAgICAgIDAuMCwgMC4wLCAxLjAsIDAuMCxcbiAgICAgICAgICAgICAgJHtfeH0sICR7X3l9LCAke196fSwgMS4wKWA7XG4gICAgICAgICAgICBjYXNlIFwicm90YXRlXCI6XG4gICAgICAgICAgICAgIHJldHVybiBgbWF0NChcbiAgICAgICAgICAgICAgZkNvc1oke3JvdGF0ZUlkfSAqIGZDb3NZJHtyb3RhdGVJZH0sIGZTaW5aJHtyb3RhdGVJZH0gKiBmQ29zWSR7cm90YXRlSWR9LCAtZlNpblkke3JvdGF0ZUlkfSwgMC4wLFxuICAgICAgICAgICAgICBmQ29zWiR7cm90YXRlSWR9ICogZlNpblkke3JvdGF0ZUlkfSAqIGZTaW5YJHtyb3RhdGVJZH0gLSBmU2luWiR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSwgZlNpbloke3JvdGF0ZUlkfSAqIGZTaW5ZJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9ICsgZkNvc1oke3JvdGF0ZUlkfSAqIGZDb3NYJHtyb3RhdGVJZH0sIGZDb3NZJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9LCAwLjAsXG4gICAgICAgICAgICAgIGZDb3NaJHtyb3RhdGVJZH0gKiBmU2luWSR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSArIGZTaW5aJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9LCBmU2luWiR7cm90YXRlSWR9ICogZlNpblkke3JvdGF0ZUlkfSAqIGZDb3NYJHtyb3RhdGVJZH0gLSBmQ29zWiR7cm90YXRlSWR9ICogZlNpblgke3JvdGF0ZUlkfSwgZkNvc1kke3JvdGF0ZUlkfSAqIGZDb3NYJHtyb3RhdGVJZH0sIDAuMCxcbiAgICAgICAgICAgICAgMC4wLCAwLjAsIDAuMCwgMS4wXG4gICAgICAgICAgICAgIClgO1xuICAgICAgICAgICAgY2FzZSBcInNjYWxlXCI6XG4gICAgICAgICAgICAgIHJldHVybiBgbWF0NChcbiAgICAgICAgICAgICAgJHtfeH0sIDAuMCwgMC4wLCAwLjAsXG4gICAgICAgICAgICAgIDAuMCwgJHtfeX0sIDAuMCwgMC4wLFxuICAgICAgICAgICAgICAwLjAsIDAuMCwgJHtfen0sIDAuMCxcbiAgICAgICAgICAgICAgMC4wLCAwLjAsIDAuMCwgMS4wXG4gICAgICAgICAgICAgIClgO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfdHJhbnNmb3JtYXRpb259XCIgaXMgbm90IGEgdHJhbnNmb3JtYXRpb25gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF9jb2RlOiBzdHJpbmcpID0+IGAke19hY2N1bXVsYXRvcn0gKiBcXG4ke19jb2RlfWApO1xuICAgICAgY29kZSArPSBcIjtcXG5cIjtcblxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVDb2xvcihfY29sb3I6IFBhcnRpY2xlRGF0YS5FeHByZXNzaW9uW10pOiBzdHJpbmcge1xuICAgICAgaWYgKCFfY29sb3IpIHJldHVybiBcIlwiO1xuXG4gICAgICBsZXQgcmdiYTogc3RyaW5nID0gW19jb2xvclswXSwgX2NvbG9yWzFdLCBfY29sb3JbMl0sIF9jb2xvclszXV1cbiAgICAgICAgLm1hcCgoX3ZhbHVlKTogc3RyaW5nID0+IF92YWx1ZSA/IFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVFeHByZXNzaW9uKF92YWx1ZSkgOiBcIjEuMFwiKVxuICAgICAgICAuam9pbihcIiwgXCIpO1xuXG4gICAgICByZXR1cm4gYHZlYzQoJHtyZ2JhfSk7YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZUV4cHJlc3Npb24oX2V4cHJlc3Npb246IFBhcnRpY2xlRGF0YS5FeHByZXNzaW9uKTogc3RyaW5nIHtcbiAgICAgIGlmIChQYXJ0aWNsZURhdGEuaXNGdW5jdGlvbihfZXhwcmVzc2lvbikpIHtcbiAgICAgICAgbGV0IHBhcmFtZXRlcnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGZvciAobGV0IHBhcmFtIG9mIF9leHByZXNzaW9uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZW5lcmF0ZUV4cHJlc3Npb24ocGFyYW0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZW5lcmF0ZUZ1bmN0aW9uKF9leHByZXNzaW9uLmZ1bmN0aW9uLCBwYXJhbWV0ZXJzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhcnRpY2xlRGF0YS5pc1ZhcmlhYmxlKF9leHByZXNzaW9uKSkge1xuICAgICAgICByZXR1cm4gUGFydGljbGVEYXRhLlBSRURFRklORURfVkFSSUFCTEVTW19leHByZXNzaW9uLnZhbHVlXSB8fCBcImZQYXJ0aWNsZVN5c3RlbVZhcmlhYmxlX1wiICsgX2V4cHJlc3Npb24udmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXJ0aWNsZURhdGEuaXNDb25zdGFudChfZXhwcmVzc2lvbikpIHtcbiAgICAgICAgbGV0IHZhbHVlOiBzdHJpbmcgPSBfZXhwcmVzc2lvbi52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gYCR7dmFsdWV9JHt2YWx1ZS5pbmNsdWRlcyhcIi5cIikgPyBcIlwiIDogXCIuMFwifWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXJ0aWNsZURhdGEuaXNDb2RlKF9leHByZXNzaW9uKSkge1xuICAgICAgICBsZXQgY29kZTogc3RyaW5nID0gX2V4cHJlc3Npb24uY29kZVxuICAgICAgICAgIC5yZXBsYWNlQWxsKC9cXGJbYS16QS16XStcXHcqKD8hXFwoKVxcYi9nLCAoX21hdGNoKSA9PiBQYXJ0aWNsZURhdGEuUFJFREVGSU5FRF9WQVJJQUJMRVNbX21hdGNoXSB8fCBcImZQYXJ0aWNsZVN5c3RlbVZhcmlhYmxlX1wiICsgX21hdGNoKVxuICAgICAgICAgIC5yZXBsYWNlQWxsKC8oPzwhXFwuKVxcYlxcZCtcXGIoPyFcXC4pL2csIChfbWF0Y2gpID0+IF9tYXRjaCArIFwiLjBcIik7XG4gICAgICAgIGNvZGUgPSBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLnJlcGxhY2VGdW5jdGlvbnMoY29kZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGBFcnJvciBpbiAke1BhcnRpY2xlU3lzdGVtLm5hbWV9OiBpbnZhbGlkIG5vZGUgc3RydWN0dXJlIGluIHBhcnRpY2xlIHN5c3RlbSBzZXJpYWxpemF0aW9uYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZUZ1bmN0aW9uKF9mdW5jdGlvbjogUGFydGljbGVEYXRhLkZVTkNUSU9OLCBfcGFyYW1ldGVyczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgICAgaWYgKF9wYXJhbWV0ZXJzLmxlbmd0aCA8IFBhcnRpY2xlRGF0YS5GVU5DVElPTl9NSU5JTVVNX1BBUkFNRVRFUlNbX2Z1bmN0aW9uXSlcbiAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfZnVuY3Rpb259XCIgbmVlZHMgYXQgbGVhc3QgJHtQYXJ0aWNsZURhdGEuRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTW19mdW5jdGlvbl19IHBhcmFtZXRlcnNgO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoUGFydGljbGVEYXRhLkZVTkNUSU9OKS5pbmNsdWRlcyhfZnVuY3Rpb24pKVxuICAgICAgICByZXR1cm4gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5GVU5DVElPTlNbX2Z1bmN0aW9uXShfcGFyYW1ldGVycyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IGBFcnJvciBpbiAke1BhcnRpY2xlU3lzdGVtLm5hbWV9OiBcIiR7X2Z1bmN0aW9ufVwiIGlzIG5vdCBhbiBvcGVyYXRpb25gO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHJlcGxhY2VGdW5jdGlvbnMoX2NvZGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICBsZXQgZnVuY3Rpb25SZWdleDogUmVnRXhwID0gL1xcYlthLXpBLXpfXStcXHcqXFwoL2c7XG4gICAgICBsZXQgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheTtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBmdW5jdGlvblJlZ2V4LmV4ZWMoX2NvZGUpKSAhPSBudWxsKSB7XG4gICAgICAgIGxldCBmdW5jdGlvbkdlbmVyYXRvcjogRnVuY3Rpb24gPSBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLkZVTkNUSU9OU1s8UGFydGljbGVEYXRhLkZVTkNUSU9OPm1hdGNoWzBdLnNsaWNlKDAsIC0xKV07XG4gICAgICAgIGlmICghZnVuY3Rpb25HZW5lcmF0b3IpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgbGV0IGNvbW1hSW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgbGV0IG9wZW5CcmFja2V0czogbnVtYmVyID0gMTtcbiAgICAgICAgbGV0IGFyZ3VtZW50c0xhc3RJbmRleDogbnVtYmVyID0gZnVuY3Rpb25SZWdleC5sYXN0SW5kZXg7XG4gICAgICAgIHdoaWxlIChvcGVuQnJhY2tldHMgPiAwKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29kZVthcmd1bWVudHNMYXN0SW5kZXhdKSB7XG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICBvcGVuQnJhY2tldHMrKztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgICBvcGVuQnJhY2tldHMtLTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICBpZiAob3BlbkJyYWNrZXRzID09IDEpXG4gICAgICAgICAgICAgICAgY29tbWFJbmRpY2VzLnB1c2goYXJndW1lbnRzTGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3VtZW50c0xhc3RJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFyZ3M6IHN0cmluZ1tdID1cbiAgICAgICAgICBbZnVuY3Rpb25SZWdleC5sYXN0SW5kZXggLSAxLCAuLi5jb21tYUluZGljZXMsIGFyZ3VtZW50c0xhc3RJbmRleCAtIDFdLnJlZHVjZTxzdHJpbmdbXT4oKF9hY2N1bXVsYXRvciwgX3Bvc2l0aW9uLCBfaW5kZXgsIF9wb3NpdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfaW5kZXggPT0gX3Bvc2l0aW9ucy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgICAgX2FjY3VtdWxhdG9yIDpcbiAgICAgICAgICAgICAgX2FjY3VtdWxhdG9yLmNvbmNhdChfY29kZS5zbGljZShfcG9zaXRpb24gKyAxLCBfcG9zaXRpb25zW19pbmRleCArIDFdKS50cmltKCkpO1xuICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICBmdW5jdGlvblJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICBfY29kZSA9IGAke19jb2RlLnNsaWNlKDAsIG1hdGNoLmluZGV4KX0oJHtmdW5jdGlvbkdlbmVyYXRvcihhcmdzKX0pJHtfY29kZS5zbGljZShhcmd1bWVudHNMYXN0SW5kZXgpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NvZGU7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqXG4gICAqIEJ1ZmZlcnMgdGhlIHJhbmRvbSBudW1iZXIgZGF0YSBmb3IgdGhlIHBhcnRpY2xlIHN5c3RlbSAoe0BsaW5rIENvbXBvbmVudFBhcnRpY2xlU3lzdGVtfSkgaW50byBhIFdlYkdMIFRleHR1cmVcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yQ29tcG9uZW50UGFydGljbGVTeXN0ZW0ge1xuICAgIC8qKlxuICAgICAqIEluamVjdHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhpcyBjbGFzcyBpbnRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUge0BsaW5rIENvbXBvbmVudFBhcnRpY2xlU3lzdGVtfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwidXNlUmVuZGVyRGF0YVwiLCB7XG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtLnVzZVJlbmRlckRhdGFcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiZGVsZXRlUmVuZGVyRGF0YVwiLCB7XG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtLmRlbGV0ZVJlbmRlckRhdGFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyRGF0YSh0aGlzOiBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk6IHZvaWQge1xuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgICBpZiAodGhpcy5yZW5kZXJEYXRhKSB7XG4gICAgICAgIC8vIGJ1ZmZlcnMgZXhpc3RcbiAgICAgICAgY3JjMy5hY3RpdmVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTEpOyAvLyBBVFRFTlRJT04hOiBjaGFuZ2luZyB0aGlzIGlkIHJlcXVpcmVzIGNoYW5naW5nIG9mIGNvcnJlc3BvbmRpbmcgaWQgaW4gcGFydGljbGUgcmVuZGVyIG1ldGhvZCwgdXNlIGN0cmwgKyBzaGlmdCArIGYgc2VhcmNoIVxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5yZW5kZXJEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlci5hc3NlcnQ8V2ViR0xUZXh0dXJlPihjcmMzLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICBsZXQgdGV4dHVyZVNpemU6IG51bWJlciA9IE1hdGguY2VpbChNYXRoLnNxcnQodGhpcy5zaXplKSk7XG4gICAgICAgIHRleHR1cmVTaXplID0gTWF0aC5taW4odGV4dHVyZVNpemUsIGNyYzMuZ2V0UGFyYW1ldGVyKGNyYzMuTUFYX1RFWFRVUkVfU0laRSkpO1xuXG4gICAgICAgIC8vIFRPRE86IHVzZSBpbnRlcm5hbCByYW5kb20gbnVtYmVyIGdlbmVyYXRvciwgYWRkaXRpb25hbGx5IG1heWJlIHVzZSBhIHNlZWQgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byByZWNyZWF0ZSB0aGUgc2FtZSByYW5kb20gbnVtYmVyc1xuICAgICAgICBsZXQgcmFuZG9tTnVtYmVyczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRleHR1cmVTaXplICogdGV4dHVyZVNpemU7IGkrKylcbiAgICAgICAgICByYW5kb21OdW1iZXJzLnB1c2goTWF0aC5yYW5kb20oKSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoXG4gICAgICAgICAgICBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUjMyRiwgdGV4dHVyZVNpemUsIHRleHR1cmVTaXplLCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJFRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCxcbiAgICAgICAgICAgIEZsb2F0MzJBcnJheS5mcm9tKHJhbmRvbU51bWJlcnMpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShjcmMzLlRFWFRVUkVfMkQsIGNyYzMuVEVYVFVSRV9NSU5fRklMVEVSLCBjcmMzLk5FQVJFU1QpO1xuICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoY3JjMy5URVhUVVJFXzJELCBjcmMzLlRFWFRVUkVfTUFHX0ZJTFRFUiwgY3JjMy5ORUFSRVNUKTtcblxuICAgICAgICB0aGlzLnJlbmRlckRhdGEgPSB0ZXh0dXJlO1xuXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsKTtcblxuICAgICAgICB0aGlzLnVzZVJlbmRlckRhdGEoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckRhdGEodGhpczogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHtcbiAgICAgIGlmICghdGhpcy5yZW5kZXJEYXRhKSByZXR1cm47XG5cbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgY3JjMy5kZWxldGVUZXh0dXJlKHRoaXMucmVuZGVyRGF0YSk7XG4gICAgICBkZWxldGUgdGhpcy5yZW5kZXJEYXRhO1xuICAgICAgXG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIFxuICAvKipcbiAgICogSW50ZXJmYWNlIHRvIGJlIGltcGxlbWVudGVkIGJ5IG9iamVjdHMgdGhhdCBjYW4gYmUgcmVjeWNsZWQsIGkuZS4gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIGJ5IHJldXNpbmcgdGhlIG9iamVjdCBpbnN0ZWFkIG9mIHJlcGxhY2luZyBpdCB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVjeWNhYmxlIHtcbiAgICAvKipcbiAgICAgKiBSZWN5Y2xlcyB0aGUgb2JqZWN0IGZvciB0aGUgbmV4dCByZXVzZSBieSBzZXR0aW5nIGl0cyBwcm9wZXJ0aWVzIHRvIHRoZWlyIGRlZmF1bHQgc3RhdGVzLlxuICAgICAqL1xuICAgIHJlY3ljbGUoKTogdm9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBLZWVwcyBhIGRlcG90IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gbWFya2VkIGZvciByZXVzZSwgc29ydGVkIGJ5IHR5cGUuICBcbiAgICogVXNpbmcge0BsaW5rIFJlY3ljbGVyfSByZWR1Y2VzIGxvYWQgb24gdGhlIGNhcmJhZ2UgY29sbGVjdG9yIGFuZCB0aHVzIHN1cHBvcnRzIHNtb290aCBwZXJmb3JtYW5jZS5cbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvUmVjeWNsZXJcbiAgICovXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWN5Y2xlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVwb3Q6IHsgW3R5cGU6IHN0cmluZ106IE9iamVjdFtdIH0gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYW4gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSBmcm9tIHRoZSBkZXBvdCwgY2FsbHMgaXRzIHJlY3ljbGUtbWV0aG9kIGFuZCByZXR1cm5zIGl0LlxuICAgICAqIElmIHRoZSBkZXBvdCBmb3IgdGhhdCB0eXBlIGlzIGVtcHR5IGl0IHJldHVybnMgYSBuZXcgb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZVxuICAgICAqIEBwYXJhbSBfdCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldDxUIGV4dGVuZHMgUmVjeWNhYmxlIHwgUmVjeWNhYmxlQXJyYXk8VD4+KF90OiBuZXcgKCkgPT4gVCk6IFQge1xuICAgICAgbGV0IGtleTogc3RyaW5nID0gX3QubmFtZTtcbiAgICAgIGxldCBpbnN0YW5jZXM6IE9iamVjdFtdID0gUmVjeWNsZXIuZGVwb3Rba2V5XTtcbiAgICAgIGlmIChpbnN0YW5jZXMgJiYgaW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGluc3RhbmNlOiBUID0gPFQ+aW5zdGFuY2VzLnBvcCgpO1xuICAgICAgICBpbnN0YW5jZS5yZWN5Y2xlKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gbmV3IF90KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3Qgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIGluIHRoZSBkZXBvdCwgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCB0aGVyZS4gXG4gICAgICogSWYgbm8gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSB3YXMgaW4gdGhlIGRlcG90LCBvbmUgaXMgY3JlYXRlZCwgc3RvcmVkIGFuZCBib3Jyb3dlZC5cbiAgICAgKiBGb3Igc2hvcnQgdGVybSB1c2FnZSBvZiBvYmplY3RzIGluIGEgbG9jYWwgc2NvcGUsIHdoZW4gdGhlcmUgd2lsbCBiZSBubyBvdGhlciBjYWxsIHRvIFJlY3ljbGVyLmdldCBvciAuYm9ycm93IVxuICAgICAqIEBwYXJhbSBfdCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGJvcnJvdzxUIGV4dGVuZHMgUmVjeWNhYmxlPihfdDogbmV3ICgpID0+IFQpOiBUIHtcbiAgICAgIGxldCB0OiBUO1xuICAgICAgbGV0IGtleTogc3RyaW5nID0gX3QubmFtZTtcbiAgICAgIGxldCBpbnN0YW5jZXM6IE9iamVjdFtdID0gUmVjeWNsZXIuZGVwb3Rba2V5XTtcbiAgICAgIGlmICghaW5zdGFuY2VzIHx8IGluc3RhbmNlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICB0ID0gbmV3IF90KCk7XG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHQpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIGxldCBpbnN0YW5jZTogVCA9IDxUPmluc3RhbmNlc1swXTtcbiAgICAgIGluc3RhbmNlLnJlY3ljbGUoKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIG9iamVjdCBpbiB0aGUgZGVwb3QgZm9yIGxhdGVyIHJlY3ljbGluZy4gVXNlcnMgYXJlIHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyBpbiBvYmplY3RzIHRoYXQgYXJlIGFib3V0IHRvIGxvb3NlIHNjb3BlIGFuZCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgYW55IG90aGVyXG4gICAgICogQHBhcmFtIF9pbnN0YW5jZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc3RvcmUoX2luc3RhbmNlOiBPYmplY3QpOiB2b2lkIHtcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9pbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgLy9EZWJ1Zy5sb2coa2V5KTtcbiAgICAgIGxldCBpbnN0YW5jZXM6IE9iamVjdFtdID0gUmVjeWNsZXIuZGVwb3Rba2V5XSB8fCBbXTtcbiAgICAgIGluc3RhbmNlcy5wdXNoKF9pbnN0YW5jZSk7XG4gICAgICBSZWN5Y2xlci5kZXBvdFtrZXldID0gaW5zdGFuY2VzO1xuICAgICAgLy8gRGVidWcubG9nKGBPYmplY3RNYW5hZ2VyLmRlcG90WyR7a2V5fV06ICR7T2JqZWN0TWFuYWdlci5kZXBvdFtrZXldLmxlbmd0aH1gKTtcbiAgICAgIC8vRGVidWcubG9nKHRoaXMuZGVwb3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtcHR5cyB0aGUgZGVwb3Qgb2YgYSBnaXZlbiB0eXBlLCBsZWF2aW5nIHRoZSBvYmplY3RzIGZvciB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXG4gICAgICogQHBhcmFtIF90XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBkdW1wPFQ+KF90OiBuZXcgKCkgPT4gVCk6IHZvaWQge1xuICAgICAgbGV0IGtleTogc3RyaW5nID0gX3QubmFtZTtcbiAgICAgIFJlY3ljbGVyLmRlcG90W2tleV0gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbXB0eXMgYWxsIGRlcG90cywgbGVhdmluZyBhbGwgb2JqZWN0cyB0byB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBkdW1wQWxsKCk6IHZvaWQge1xuICAgICAgUmVjeWNsZXIuZGVwb3QgPSB7fTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFN0b3JlcyBhbmQgbWFuaXB1bGF0ZXMgYSB0d29kaW1lbnNpb25hbCB2ZWN0b3IgY29tcHJpc2VkIG9mIHRoZSBjb21wb25lbnRzIHggYW5kIHlcbiAgICogYGBgdGV4dFxuICAgKiAgICAgICAgICAgICt5XG4gICAqICAgICAgICAgICAgIHxfXyAreFxuICAgKiBgYGBcbiAgICogQGF1dGhvcnMgTHVrYXMgU2NoZXVlcmxlLCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFZlY3RvcjIgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xuICAgIHByaXZhdGUgZGF0YTogRmxvYXQzMkFycmF5O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW194LCBfeV0pO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBTdGF0aWNcbiAgICAvKiogXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKDAsIDApYC5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzICgwLCAwKVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgWkVSTygpOiBWZWN0b3IyIHtcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgIHZlY3Rvci5zZXQoMCwgMCk7XG4gICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoX3NjYWxlLCBfc2NhbGUpYC5cbiAgICAgKiBAcGFyYW0gX3NjYWxlIHRoZSBzY2FsZSBvZiB0aGUgdmVjdG9yLiBEZWZhdWx0OiAxXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBPTkUoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XG4gICAgICB2ZWN0b3Iuc2V0KF9zY2FsZSwgX3NjYWxlKTtcbiAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMigwLCB5KWAuXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgbnVtYmVyIHRvIHdyaXRlIGluIHRoZSB5IGNvb3JkaW5hdGUuIERlZmF1bHQ6IDFcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzICgwLCBfc2NhbGUpXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xuICAgICAgdmVjdG9yLnNldCgwLCBfc2NhbGUpO1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKHgsIDApYC5cbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBudW1iZXIgdG8gd3JpdGUgaW4gdGhlIHggY29vcmRpbmF0ZS4gRGVmYXVsdDogMVxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKF9zY2FsZSwgMClcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFgoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XG4gICAgICB2ZWN0b3Iuc2V0KF9zY2FsZSwgMCk7XG4gICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3IgdGhyb3VnaCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IHRoZSBnaXZlbiBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TRk9STUFUSU9OKF92ZWN0b3I6IFZlY3RvcjIsIF9tdHhUcmFuc2Zvcm06IE1hdHJpeDN4MywgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBWZWN0b3IyIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gX210eFRyYW5zZm9ybS5nZXQoKTtcbiAgICAgIGxldCBbeCwgeV0gPSBfdmVjdG9yLmdldCgpO1xuICAgICAgcmVzdWx0LnggPSBtWzBdICogeCArIG1bM10gKiB5O1xuICAgICAgcmVzdWx0LnkgPSBtWzFdICogeCArIG1bNF0gKiB5O1xuXG4gICAgICBpZiAoX2luY2x1ZGVUcmFuc2xhdGlvbikge1xuICAgICAgICByZXN1bHQuYWRkKF9tdHhUcmFuc2Zvcm0udHJhbnNsYXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSBnaXZlbiB2ZWN0b3IgdG8gdGhlIGdpdmVuIGxlbmd0aCB3aXRob3V0IGVkaXRpbmcgdGhlIG9yaWdpbmFsIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gX3ZlY3RvciB0aGUgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICAgICAqIEBwYXJhbSBfbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIGRlZmF1bHRzIHRvIDFcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBub3JtYWxpc2VkIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIGxlbmd0aFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfdmVjdG9yOiBWZWN0b3IyLCBfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgW3gsIHldID0gX3ZlY3Rvci5kYXRhO1xuICAgICAgICBsZXQgZmFjdG9yOiBudW1iZXIgPSBfbGVuZ3RoIC8gTWF0aC5oeXBvdCh4LCB5KTtcbiAgICAgICAgdmVjdG9yLnNldChfdmVjdG9yLnggKiBmYWN0b3IsIF92ZWN0b3IueSAqIGZhY3Rvcik7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgRGVidWcud2FybihfZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMRShfdmVjdG9yOiBWZWN0b3IyLCBfc2NhbGU6IG51bWJlcik6IFZlY3RvcjIge1xuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgIHZlY3Rvci5zZXQoX3ZlY3Rvci54ICogX3NjYWxlLCBfdmVjdG9yLnkgKiBfc2NhbGUpO1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgdmVjdG9yIGF0dGFpbmVkIGJ5IGFkZGl0aW9uIG9mIGFsbCBnaXZlbiB2ZWN0b3JzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgU1VNKC4uLl92ZWN0b3JzOiBWZWN0b3IyW10pOiBWZWN0b3IyIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XG4gICAgICBmb3IgKGxldCB2ZWN0b3Igb2YgX3ZlY3RvcnMpXG4gICAgICAgIHJlc3VsdC5zZXQocmVzdWx0LnggKyB2ZWN0b3IueCwgcmVzdWx0LnkgKyB2ZWN0b3IueSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24gb2YgdHdvIHZlY3RvcnMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBESUZGRVJFTkNFKF9taW51ZW5kOiBWZWN0b3IyLCBfc3VidHJhaGVuZDogVmVjdG9yMik6IFZlY3RvcjIge1xuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgIHZlY3Rvci5zZXQoX21pbnVlbmQueCAtIF9zdWJ0cmFoZW5kLngsIF9taW51ZW5kLnkgLSBfc3VidHJhaGVuZC55KTtcbiAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdHByb2R1Y3Qgb2YgMiB2ZWN0b3JzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgRE9UKF9hOiBWZWN0b3IyLCBfYjogVmVjdG9yMik6IG51bWJlciB7XG4gICAgICBsZXQgc2NhbGFyUHJvZHVjdDogbnVtYmVyID0gX2EueCAqIF9iLnggKyBfYS55ICogX2IueTtcbiAgICAgIHJldHVybiBzY2FsYXJQcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlY3RvcnMuIER1ZSB0byB0aGVtIGJlaW5nIG9ubHkgMiBEaW1lbnNpb25hbCwgdGhlIHJlc3VsdCBpcyBhIHNpbmdsZSBudW1iZXIsXG4gICAgICogd2hpY2ggaW1wbGljaXRseSBpcyBvbiB0aGUgWiBheGlzLiBJdCBpcyBhbHNvIHRoZSBzaWduZWQgbWFnbml0dWRlIG9mIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIF9hIFZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9uXG4gICAgICogQHBhcmFtIF9iIFZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IHdpdGhcbiAgICAgKiBAcmV0dXJucyBBIG51bWJlciByZXByZXNlbnRpbmcgcmVzdWx0IG9mIHRoZSBjcm9zcyBwcm9kdWN0LlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgQ1JPU1MoX2E6IFZlY3RvcjIsIF9iOiBWZWN0b3IyKTogbnVtYmVyIHtcbiAgICAgIGxldCBjcm9zc1Byb2R1Y3Q6IG51bWJlciA9IF9hLnggKiBfYi55IC0gX2EueSAqIF9iLng7XG4gICAgICByZXR1cm4gY3Jvc3NQcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9ydGhvZ29uYWwgdmVjdG9yIHRvIHRoZSBnaXZlbiB2ZWN0b3IuIFJvdGF0ZXMgY291bnRlcmNsb2Nrd2lzZSBieSBkZWZhdWx0LlxuICAgICAqIGBgYHRleHRcbiAgICAgKiDihpEgPT4g4oaQID0+IOKGkyA9PiDihpIgPT4g4oaRXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIF92ZWN0b3IgVmVjdG9yIHRvIGdldCB0aGUgb3J0aG9nb25hbCBlcXVpdmFsZW50IG9mXG4gICAgICogQHBhcmFtIF9jbG9ja3dpc2UgU2hvdWxkIHRoZSByb3RhdGlvbiBiZSBjbG9ja3dpc2UgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBjb3VudGVyY2xvY2t3aXNlPyBkZWZhdWx0OiBmYWxzZVxuICAgICAqIEByZXR1cm5zIEEgVmVjdG9yIHRoYXQgaXMgb3J0aG9nb25hbCB0byBhbmQgaGFzIHRoZSBzYW1lIG1hZ25pdHVkZSBhcyB0aGUgZ2l2ZW4gVmVjdG9yLiAgXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBPUlRIT0dPTkFMKF92ZWN0b3I6IFZlY3RvcjIsIF9jbG9ja3dpc2U6IGJvb2xlYW4gPSBmYWxzZSk6IFZlY3RvcjIge1xuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgIGlmIChfY2xvY2t3aXNlKVxuICAgICAgICByZXN1bHQuc2V0KF92ZWN0b3IueSwgLV92ZWN0b3IueCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdC5zZXQoLV92ZWN0b3IueSwgX3ZlY3Rvci54KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhcnRlc2lhbiB2ZWN0b3IgZnJvbSBwb2xhciBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgR0VPKF9hbmdsZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgIGxldCBnZW86IEdlbzIgPSBSZWN5Y2xlci5nZXQoR2VvMik7XG4gICAgICBnZW8uc2V0KF9hbmdsZSwgX21hZ25pdHVkZSk7XG4gICAgICB2ZWN0b3IuZ2VvID0gZ2VvO1xuICAgICAgUmVjeWNsZXIuc3RvcmUoZ2VvKTtcbiAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIEFjY2Vzc29yc1xuICAgIHB1YmxpYyBnZXQgeCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXTtcbiAgICB9XG4gICAgcHVibGljIGdldCB5KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzFdO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgeChfeDogbnVtYmVyKSB7XG4gICAgICB0aGlzLmRhdGFbMF0gPSBfeDtcbiAgICB9XG4gICAgcHVibGljIHNldCB5KF95OiBudW1iZXIpIHtcbiAgICAgIHRoaXMuZGF0YVsxXSA9IF95O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYWduaXR1ZGUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBNYXRoLmh5cG90KC4uLnRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciB3aXRob3V0IGNhbGN1bGF0aW5nIGEgc3F1YXJlIHJvb3QuIEZhc3RlciBmb3Igc2ltcGxlIHByb3hpbWl0eSBldmFsdWF0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIFZlY3RvcjIuRE9UKHRoaXMsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBjbG9uZSBvZiB0aGlzXG4gICAgICovXG4gICAgcHVibGljIGdldCBjbG9uZSgpOiBWZWN0b3IyIHtcbiAgICAgIGxldCBjbG9uZTogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgIGNsb25lLmRhdGEuc2V0KHRoaXMuZGF0YSk7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBvbGFyIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yXG4gICAgICovXG4gICAgcHVibGljIGdldCBnZW8oKTogR2VvMiB7XG4gICAgICBsZXQgZ2VvOiBHZW8yID0gUmVjeWNsZXIuZ2V0KEdlbzIpO1xuICAgICAgZ2VvLm1hZ25pdHVkZSA9IHRoaXMubWFnbml0dWRlO1xuXG4gICAgICBpZiAoZ2VvLm1hZ25pdHVkZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGdlbztcblxuICAgICAgZ2VvLmFuZ2xlID0gMTgwICogTWF0aC5hdGFuMih0aGlzLnkgLyBnZW8ubWFnbml0dWRlLCB0aGlzLnggLyBnZW8ubWFnbml0dWRlKSAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gZ2VvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgY2FydGVzaWFuIHZhbHVlcyBvZiB0aGlzIHZlY3RvciB0byByZXByZXNlbnQgdGhlIGdpdmVuIGFzIHBvbGFyIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgcHVibGljIHNldCBnZW8oX2dlbzogR2VvMikge1xuICAgICAgdGhpcy5zZXQoX2dlby5tYWduaXR1ZGUsIDApO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oTWF0cml4M3gzLlJPVEFUSU9OKF9nZW8uYW5nbGUpKTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMuZGF0YS5zZXQoWzAsIDBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGludG8gdGhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBjb3B5KF9vcmlnaW5hbDogVmVjdG9yMik6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhLnNldChfb3JpZ2luYWwuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yIGFyZSB0byBiZSBjb25zaWRlcmVkIGlkZW50aWNhbCB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZVxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRvbGVyYW5jZSBhcyBjcml0ZXJpdW0gZm9yIHRoZSBkaWZmZXJlbmNlIGlzIGFwcHJvcHJpYXRlIHdpdGggdmVyeSBsYXJnZSBjb29yZGluYXRlIHZhbHVlcyBvciBpZiBfdG9sZXJhbmNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIGJ5IGNvb3JkaW5hdGUgdmFsdWVcbiAgICAgKi9cbiAgICBwdWJsaWMgZXF1YWxzKF9jb21wYXJlOiBWZWN0b3IyLCBfdG9sZXJhbmNlOiBudW1iZXIgPSBOdW1iZXIuRVBTSUxPTik6IGJvb2xlYW4ge1xuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueSAtIF9jb21wYXJlLnkpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoZSBleGVjdXRpbmcgdmVjdG9yLCBjaGFuZ2luZyB0aGUgZXhlY3V0b3IuXG4gICAgICogQHBhcmFtIF9hZGRlbmQgVGhlIHZlY3RvciB0byBhZGQuXG4gICAgICovXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3IyKTogdm9pZCB7XG4gICAgICB0aGlzLmRhdGEuc2V0KFtfYWRkZW5kLnggKyB0aGlzLngsIF9hZGRlbmQueSArIHRoaXMueV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gdmVjdG9yIGZyb20gdGhlIGV4ZWN1dGluZyB2ZWN0b3IsIGNoYW5naW5nIHRoZSBleGVjdXRvci5cbiAgICAgKiBAcGFyYW0gX3N1YnRyYWhlbmQgVGhlIHZlY3RvciB0byBzdWJ0cmFjdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3VidHJhY3QoX3N1YnRyYWhlbmQ6IFZlY3RvcjIpOiB2b2lkIHtcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMueCAtIF9zdWJ0cmFoZW5kLngsIHRoaXMueSAtIF9zdWJ0cmFoZW5kLnldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIFZlY3RvciBieSB0aGUgZ2l2ZW4gX3NjYWxhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2NhbGUoX3NjYWxhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLmRhdGEuc2V0KFtfc2NhbGFyICogdGhpcy54LCBfc2NhbGFyICogdGhpcy55XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHRvIHRoZSBnaXZlbiBsZW5ndGgsIDEgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIHB1YmxpYyBub3JtYWxpemUoX2xlbmd0aDogbnVtYmVyID0gMSk6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMi5OT1JNQUxJWkFUSU9OKHRoaXMsIF9sZW5ndGgpLmRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBudW1iZXJzXG4gICAgICovXG4gICAgcHVibGljIHNldChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDApOiB2b2lkIHtcbiAgICAgIHRoaXMuZGF0YVswXSA9IF94O1xuICAgICAgdGhpcy5kYXRhWzFdID0gX3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIGRhdGEgb2YgdGhlIHZlY3RvclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4LCBpbmNsdWRpbmcgb3IgZXhsdWRpbmcgdGhlIHRyYW5zbGF0aW9uLlxuICAgICAqIEluY2x1ZGluZyBpcyB0aGUgZGVmYXVsdCwgZXhjbHVkaW5nIHdpbGwgb25seSByb3RhdGUgYW5kIHNjYWxlIHRoaXMgdmVjdG9yLlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX210eFRyYW5zZm9ybTogTWF0cml4M3gzLCBfaW5jbHVkZVRyYW5zbGF0aW9uOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMi5UUkFOU0ZPUk1BVElPTih0aGlzLCBfbXR4VHJhbnNmb3JtLCBfaW5jbHVkZVRyYW5zbGF0aW9uKS5kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWluaW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yXG4gICAgICovXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMyk6IHZvaWQge1xuICAgICAgdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCBfY29tcGFyZS54KTtcbiAgICAgIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgX2NvbXBhcmUueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWF4aW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yXG4gICAgICovXG4gICAgcHVibGljIG1heChfY29tcGFyZTogVmVjdG9yMyk6IHZvaWQge1xuICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBfY29tcGFyZS54KTtcbiAgICAgIHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgX2NvbXBhcmUueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHotY29tcG9uZW50IG9mIHRoZSBnaXZlbiBtYWduaXR1ZGUgKGRlZmF1bHQ9MCkgdG8gdGhlIHZlY3RvciBhbmQgcmV0dXJucyBhIG5ldyBWZWN0b3IzXG4gICAgICovXG4gICAgcHVibGljIHRvVmVjdG9yMyhfejogbnVtYmVyID0gMCk6IFZlY3RvcjMge1xuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCwgdGhpcy55LCBfeik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3JcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IGAoJHt0aGlzLngudG9QcmVjaXNpb24oNSl9LCAke3RoaXMueS50b1ByZWNpc2lvbig1KX0pYDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgc3RhbmRhcmQgYXJyYXkubWFwIGZ1bmN0aW9uYWxpdHkgdG8gcGVyZm9ybSB0aGUgZ2l2ZW4gZnVuY3Rpb24gb24gYWxsIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3JcbiAgICAgKiBhbmQgcmV0dXJuIGEgbmV3IHZlY3RvciB3aXRoIHRoZSByZXN1bHRzXG4gICAgICovXG4gICAgcHVibGljIG1hcChfZnVuY3Rpb246ICh2YWx1ZTogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBhcnJheTogRmxvYXQzMkFycmF5KSA9PiBudW1iZXIpOiBWZWN0b3IyIHtcbiAgICAgIGxldCBjb3B5OiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xuICAgICAgY29weS5kYXRhID0gdGhpcy5kYXRhLm1hcChfZnVuY3Rpb24pO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XG4gICAgICAvLyBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGB7IFwiclwiOiAke3RoaXMucn0sIFwiZ1wiOiAke3RoaXMuZ30sIFwiYlwiOiAke3RoaXMuYn0sIFwiYVwiOiAke3RoaXMuYX19YDsgfTtcbiAgICAgIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYFske3RoaXMueH0sICR7dGhpcy55fV1gOyB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxWZWN0b3IyPiB7XG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBbdGhpcy54LCB0aGlzLnldID0gSlNPTi5wYXJzZSg8c3RyaW5nPjx1bmtub3duPl9zZXJpYWxpemF0aW9uKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xuICAgICAgICB4OiB0aGlzLmRhdGFbMF0sIHk6IHRoaXMuZGF0YVsxXVxuICAgICAgfTtcbiAgICAgIHJldHVybiBtdXRhdG9yO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XG4gICAgLy8jZW5kcmVnaW9uXG4gIH1cbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9SZWN5Y2xlL1JlY3ljbGVyLnRzXCIvPlxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiVmVjdG9yMi50c1wiLz5cblxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBvcmlnaW4gb2YgYSByZWN0YW5nbGVcbiAgICovXG4gIGV4cG9ydCBlbnVtIE9SSUdJTjJEIHtcbiAgICBUT1BMRUZUID0gMHgwMCxcbiAgICBUT1BDRU5URVIgPSAweDAxLFxuICAgIFRPUFJJR0hUID0gMHgwMixcbiAgICBDRU5URVJMRUZUID0gMHgxMCxcbiAgICBDRU5URVIgPSAweDExLFxuICAgIENFTlRFUlJJR0hUID0gMHgxMixcbiAgICBCT1RUT01MRUZUID0gMHgyMCxcbiAgICBCT1RUT01DRU5URVIgPSAweDIxLFxuICAgIEJPVFRPTVJJR0hUID0gMHgyMlxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSByZWN0YW5nbGUgd2l0aCBwb3NpdGlvbiBhbmQgc2l6ZSBhbmQgYWRkIGNvbWZvcnRhYmxlIG1ldGhvZHMgdG8gaXRcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICBwdWJsaWMgc2l6ZTogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbkFuZFNpemUoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQsIF9vcmlnaW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIGNyZWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgR0VUKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3dpZHRoOiBudW1iZXIgPSAxLCBfaGVpZ2h0OiBudW1iZXIgPSAxLCBfb3JpZ2luOiBPUklHSU4yRCA9IE9SSUdJTjJELlRPUExFRlQpOiBSZWN0YW5nbGUge1xuICAgICAgbGV0IHJlY3Q6IFJlY3RhbmdsZSA9IFJlY3ljbGVyLmdldChSZWN0YW5nbGUpO1xuICAgICAgcmVjdC5zZXRQb3NpdGlvbkFuZFNpemUoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB4KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHkoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgd2lkdGgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUueDtcbiAgICB9XG4gICAgcHVibGljIGdldCBoZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxlZnRtb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiB3aWR0aFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbGVmdCgpOiBudW1iZXIge1xuICAgICAgaWYgKHRoaXMuc2l6ZS54ID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcbiAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRvcG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIGhlaWdodFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG9wKCk6IG51bWJlciB7XG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICAgICAgcmV0dXJuICh0aGlzLnBvc2l0aW9uLnkgKyB0aGlzLnNpemUueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcmlnaHRtb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiB3aWR0aFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcmlnaHQoKTogbnVtYmVyIHtcbiAgICAgIGlmICh0aGlzLnNpemUueCA+IDApXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngpO1xuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsb3dlc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIGhlaWdodFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYm90dG9tKCk6IG51bWJlciB7XG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxuICAgICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueSArIHRoaXMuc2l6ZS55KTtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB4KF94OiBudW1iZXIpIHtcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF94O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHkoX3k6IG51bWJlcikge1xuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gX3k7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgd2lkdGgoX3dpZHRoOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuc2l6ZS54ID0gX3dpZHRoO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGhlaWdodChfaGVpZ2h0OiBudW1iZXIpIHtcbiAgICAgIHRoaXMuc2l6ZS55ID0gX2hlaWdodDtcbiAgICB9XG4gICAgcHVibGljIHNldCBsZWZ0KF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLnNpemUueCA9IHRoaXMucmlnaHQgLSBfdmFsdWU7XG4gICAgICB0aGlzLnBvc2l0aW9uLnggPSBfdmFsdWU7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgdG9wKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLnNpemUueSA9IHRoaXMuYm90dG9tIC0gX3ZhbHVlO1xuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gX3ZhbHVlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHJpZ2h0KF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLnNpemUueCA9IHRoaXMucG9zaXRpb24ueCArIF92YWx1ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBib3R0b20oX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5wb3NpdGlvbi55ICsgX3ZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogUmVjdGFuZ2xlIHtcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQW5kU2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHJlY3RhbmdsZSB0byB0aGUgdmFsdWVzIGdpdmVuIGJ5IHRoZSByZWN0YW5nbGUgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgY29weShfcmVjdDogUmVjdGFuZ2xlKTogdm9pZCB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQW5kU2l6ZShfcmVjdC54LCBfcmVjdC55LCBfcmVjdC53aWR0aCwgX3JlY3QuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHB1YmxpYyBzZXRQb3NpdGlvbkFuZFNpemUoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IHZvaWQge1xuICAgICAgdGhpcy5zaXplLnNldChfd2lkdGgsIF9oZWlnaHQpO1xuICAgICAgc3dpdGNoIChfb3JpZ2luICYgMHgwMykge1xuICAgICAgICBjYXNlIDB4MDA6IHRoaXMucG9zaXRpb24ueCA9IF94OyBicmVhaztcbiAgICAgICAgY2FzZSAweDAxOiB0aGlzLnBvc2l0aW9uLnggPSBfeCAtIF93aWR0aCAvIDI7IGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDI6IHRoaXMucG9zaXRpb24ueCA9IF94IC0gX3dpZHRoOyBicmVhaztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoX29yaWdpbiAmIDB4MzApIHtcbiAgICAgICAgY2FzZSAweDAwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMDogdGhpcy5wb3NpdGlvbi55ID0gX3kgLSBfaGVpZ2h0IC8gMjsgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyMDogdGhpcy5wb3NpdGlvbi55ID0gX3kgLSBfaGVpZ2h0OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoaXMgcmVjdGFuZ2xlcyBzcGFjZSB0byB0aGUgdGFyZ2V0IHJlY3RhbmdsZXMgc3BhY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgcG9pbnRUb1JlY3QoX3BvaW50OiBWZWN0b3IyLCBfdGFyZ2V0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBfcG9pbnQuY2xvbmU7XG4gICAgICByZXN1bHQuc3VidHJhY3QodGhpcy5wb3NpdGlvbik7XG4gICAgICByZXN1bHQueCAqPSBfdGFyZ2V0LndpZHRoIC8gdGhpcy53aWR0aDtcbiAgICAgIHJlc3VsdC55ICo9IF90YXJnZXQuaGVpZ2h0IC8gdGhpcy5oZWlnaHQ7XG4gICAgICByZXN1bHQuYWRkKF90YXJnZXQucG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGluc2lkZSBvZiB0aGlzIHJlY3RhbmdsZSBvciBvbiB0aGUgYm9yZGVyXG4gICAgICogQHBhcmFtIF9wb2ludFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0luc2lkZShfcG9pbnQ6IFZlY3RvcjIpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiAoX3BvaW50LnggPj0gdGhpcy5sZWZ0ICYmIF9wb2ludC54IDw9IHRoaXMucmlnaHQgJiYgX3BvaW50LnkgPj0gdGhpcy50b3AgJiYgX3BvaW50LnkgPD0gdGhpcy5ib3R0b20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoZSByZWN0YW5nbGUgZ2l2ZW5cbiAgICAgKiBAcGFyYW0gX3JlY3QgXG4gICAgICovXG4gICAgcHVibGljIGNvbGxpZGVzKF9yZWN0OiBSZWN0YW5nbGUpOiBib29sZWFuIHtcbiAgICAgIGlmICh0aGlzLmxlZnQgPiBfcmVjdC5yaWdodCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMucmlnaHQgPCBfcmVjdC5sZWZ0KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy50b3AgPiBfcmVjdC5ib3R0b20pIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmJvdHRvbSA8IF9yZWN0LnRvcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVjdGFuZ2xlIGNyZWF0ZWQgYnkgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcmVjdGFuZ2xlIG9yIG51bGwsIGlmIHRoZXkgZG9uJ3QgY29sbGlkZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRJbnRlcnNlY3Rpb24oX3JlY3Q6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XG4gICAgICBpZiAoIXRoaXMuY29sbGlkZXMoX3JlY3QpKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgbGV0IGludGVyc2VjdGlvbjogUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgICAgaW50ZXJzZWN0aW9uLnggPSBNYXRoLm1heCh0aGlzLmxlZnQsIF9yZWN0LmxlZnQpO1xuICAgICAgaW50ZXJzZWN0aW9uLnkgPSBNYXRoLm1heCh0aGlzLnRvcCwgX3JlY3QudG9wKTtcbiAgICAgIGludGVyc2VjdGlvbi53aWR0aCA9IE1hdGgubWluKHRoaXMucmlnaHQsIF9yZWN0LnJpZ2h0KSAtIGludGVyc2VjdGlvbi54O1xuICAgICAgaW50ZXJzZWN0aW9uLmhlaWdodCA9IE1hdGgubWluKHRoaXMuYm90dG9tLCBfcmVjdC5ib3R0b20pIC0gaW50ZXJzZWN0aW9uLnk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gKiBSZXR1cm5zIHRoZSByZWN0YW5nbGUgY3JlYXRlZCBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiByZWN0YW5nbGUgb3IgbnVsbCwgaWYgdGhleSBkb24ndCBjb2xsaWRlXG4gKi9cbiAgICBwdWJsaWMgY292ZXJzKF9yZWN0OiBSZWN0YW5nbGUpOiBib29sZWFuIHtcbiAgICAgIGlmICh0aGlzLmxlZnQgPiBfcmVjdC5sZWZ0KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy5yaWdodCA8IF9yZWN0LnJpZ2h0KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy50b3AgPiBfcmVjdC50b3ApIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmJvdHRvbSA8IF9yZWN0LmJvdHRvbSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYMaSLlJlY3RhbmdsZShwb3NpdGlvbjoke3RoaXMucG9zaXRpb24udG9TdHJpbmcoKX0sIHNpemU6JHt0aGlzLnNpemUudG9TdHJpbmcoKX1gO1xuICAgICAgcmVzdWx0ICs9IGAsIGxlZnQ6JHt0aGlzLmxlZnQudG9QcmVjaXNpb24oNSl9LCB0b3A6JHt0aGlzLnRvcC50b1ByZWNpc2lvbig1KX0sIHJpZ2h0OiR7dGhpcy5yaWdodC50b1ByZWNpc2lvbig1KX0sIGJvdHRvbToke3RoaXMuYm90dG9tLnRvUHJlY2lzaW9uKDUpfWA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyogKi8gfVxuICB9XG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3IudHNcIi8+XG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3RvclNoYWRlci50c1wiLz5cbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yQ29hdC50c1wiLz5cbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yTWVzaC50c1wiLz5cbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0udHNcIi8+XG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtLnRzXCIvPlxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vTWF0aC9SZWN0YW5nbGUudHNcIi8+XG5cbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvLyBleHBvcnQgZGVjbGFyZSBsZXQgZnVkZ2VDb25maWc6IEdlbmVyYWw7XG5cbiAgZXhwb3J0IHR5cGUgUmVuZGVyVGV4dHVyZSA9IFdlYkdMVGV4dHVyZTtcblxuICBleHBvcnQgZW51bSBCTEVORCB7XG4gICAgT1BBUVVFLCBUUkFOU1BBUkVOVCwgQURESVRJVkUsIFNVQlRSQUNUSVZFLCBNT0RVTEFURVxuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBCdWZmZXJTcGVjaWZpY2F0aW9uIHtcbiAgICBzaXplOiBudW1iZXI7ICAgLy8gVGhlIHNpemUgb2YgdGhlIGRhdGFzYW1wbGUuXG4gICAgZGF0YVR5cGU6IG51bWJlcjsgLy8gVGhlIGRhdGF0eXBlIG9mIHRoZSBzYW1wbGUgKGUuZy4gZ2wuRkxPQVQsIGdsLkJZVEUsIGV0Yy4pXG4gICAgbm9ybWFsaXplOiBib29sZWFuOyAvLyBGbGFnIHRvIG5vcm1hbGl6ZSB0aGUgZGF0YS5cbiAgICBzdHJpZGU6IG51bWJlcjsgLy8gTnVtYmVyIG9mIGluZGljZXMgdGhhdCB3aWxsIGJlIHNraXBwZWQgZWFjaCBpdGVyYXRpb24uXG4gICAgb2Zmc2V0OiBudW1iZXI7IC8vIEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGJlZ2luIHdpdGguXG4gIH1cblxuICBleHBvcnQgY29uc3QgVU5JRk9STV9CTE9DS1M6IHsgW2Jsb2NrOiBzdHJpbmddOiB7IE5BTUU6IHN0cmluZzsgQklORElORzogbnVtYmVyIH0gfSA9IHtcbiAgICBMSUdIVFM6IHtcbiAgICAgIE5BTUU6IFwiTGlnaHRzXCIsXG4gICAgICBCSU5ESU5HOiAwXG4gICAgfSxcbiAgICBTS0lOOiB7XG4gICAgICBOQU1FOiBcIlNraW5cIixcbiAgICAgIEJJTkRJTkc6IDFcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJhc2UgY2xhc3MgZm9yIFJlbmRlck1hbmFnZXIsIGhhbmRsaW5nIHRoZSBjb25uZWN0aW9uIHRvIHRoZSByZW5kZXJpbmcgc3lzdGVtLCBpbiB0aGlzIGNhc2UgV2ViR0wuXG4gICAqIE1ldGhvZHMgYW5kIGF0dHJpYnV0ZXMgb2YgdGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseSwgb25seSB0aHJvdWdoIHtAbGluayBSZW5kZXJ9XG4gICAqL1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyV2ViR0wgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XG4gICAgcHVibGljIHN0YXRpYyB1Ym9MaWdodHM6IFdlYkdMQnVmZmVyO1xuICAgIHB1YmxpYyBzdGF0aWMgdWJvTGlnaHRzVmFyaWFibGVPZmZzZXRzOiB7IFtfbmFtZTogc3RyaW5nXTogbnVtYmVyIH07IC8vIE1hcHMgdGhlIG5hbWVzIG9mIHRoZSB2YXJpYWJsZXMgaW5zaWRlIHRoZSBMaWdodHMgdW5pZm9ybSBibG9jayB0byB0aGVpciByZXNwZWN0aXZlIGJ5dGUgb2Zmc2V0XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5pbml0aWFsaXplKCk7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyDGknBpY2tlZDogUGlja1tdO1xuICAgIHByaXZhdGUgc3RhdGljIHJlY3RSZW5kZXI6IFJlY3RhbmdsZSA9IFJlbmRlcldlYkdMLmdldENhbnZhc1JlY3QoKTtcbiAgICBwcml2YXRlIHN0YXRpYyBzaXplUGljazogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgb2Zmc2NyZWVuLWNhbnZhcywgcmVuZGVyaW5nY29udGV4dCBhbmQgaGFyZHdhcmUgdmlld3BvcnQuIENhbGwgb25jZSBiZWZvcmUgY3JlYXRpbmcgYW55IHJlc291cmNlcyBsaWtlIG1lc2hlcyBvciBzaGFkZXJzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplKF9hbnRpYWxpYXM/OiBib29sZWFuLCBfYWxwaGE/OiBib29sZWFuKTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB7XG4gICAgICBsZXQgZnVkZ2VDb25maWc6IEdlbmVyYWwgPSBSZWZsZWN0LmdldChnbG9iYWxUaGlzLCBcImZ1ZGdlQ29uZmlnXCIpIHx8IHt9O1xuICAgICAgbGV0IGNvbnRleHRBdHRyaWJ1dGVzOiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzID0ge1xuICAgICAgICBhbHBoYTogKF9hbHBoYSAhPSB1bmRlZmluZWQpID8gX2FscGhhIDogZnVkZ2VDb25maWcuYWxwaGEgfHwgZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogKF9hbnRpYWxpYXMgIT0gdW5kZWZpbmVkKSA/IF9hbnRpYWxpYXMgOiBmdWRnZUNvbmZpZy5hbnRpYWxpYXMgfHwgZmFsc2UsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2VcbiAgICAgIH07XG4gICAgICBEZWJ1Zy5mdWRnZShcIkluaXRpYWxpemUgUmVuZGVyV2ViR0xcIiwgY29udGV4dEF0dHJpYnV0ZXMpO1xuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjcmMzID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ+KFxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBjb250ZXh0QXR0cmlidXRlcyksXG4gICAgICAgIFwiV2ViR0wtY29udGV4dCBjb3VsZG4ndCBiZSBjcmVhdGVkXCJcbiAgICAgICk7XG4gICAgICBSZW5kZXJXZWJHTC5jcmMzID0gY3JjMztcbiAgICAgIC8vIEVuYWJsZSBiYWNrZmFjZS0gYW5kIHpCdWZmZXItY3VsbGluZy5cbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ1VMTF9GQUNFKTtcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJMRU5EKTtcbiAgICAgIGNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5UUkFOU1BBUkVOVCk7XG4gICAgICAvLyBSZW5kZXJPcGVyYXRvci5jcmMzLnBpeGVsU3RvcmVpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgICBSZW5kZXJXZWJHTC5yZWN0UmVuZGVyID0gUmVuZGVyV2ViR0wuZ2V0Q2FudmFzUmVjdCgpO1xuXG4gICAgICByZXR1cm4gY3JjMztcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogV3JhcHBlciBmdW5jdGlvbiB0byB1dGlsaXplIHRoZSBidWZmZXJTcGVjaWZpY2F0aW9uIGludGVyZmFjZSB3aGVuIHBhc3NpbmcgZGF0YSB0byB0aGUgc2hhZGVyIHZpYSBhIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gX2F0dHJpYnV0ZUxvY2F0aW9uICBUaGUgbG9jYXRpb24gb2YgdGhlIGF0dHJpYnV0ZSBvbiB0aGUgc2hhZGVyLCB0byB3aGljaCB0aGV5IGRhdGEgd2lsbCBiZSBwYXNzZWQuXG4gICAgICogQHBhcmFtIF9idWZmZXJTcGVjaWZpY2F0aW9uICBJbnRlcmZhY2UgcGFzc2luZyBkYXRhcHVsbHNwZWNpZmljYXRpb25zIHRvIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBzZXRBdHRyaWJ1dGVTdHJ1Y3R1cmUoX2F0dHJpYnV0ZUxvY2F0aW9uOiBudW1iZXIsIF9idWZmZXJTcGVjaWZpY2F0aW9uOiBCdWZmZXJTcGVjaWZpY2F0aW9uKTogdm9pZCB7XG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLnZlcnRleEF0dHJpYlBvaW50ZXIoX2F0dHJpYnV0ZUxvY2F0aW9uLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5zaXplLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5kYXRhVHlwZSwgX2J1ZmZlclNwZWNpZmljYXRpb24ubm9ybWFsaXplLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5zdHJpZGUsIF9idWZmZXJTcGVjaWZpY2F0aW9uLm9mZnNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBDaGVja3MgdGhlIGZpcnN0IHBhcmFtZXRlciBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBXZWJHTC1lcnJvcmNvZGUgaWYgdGhlIHZhbHVlIGlzIG51bGxcbiAgICAqIEBwYXJhbSBfdmFsdWUgIHZhbHVlIHRvIGNoZWNrIGFnYWluc3QgbnVsbFxuICAgICogQHBhcmFtIF9tZXNzYWdlICBvcHRpb25hbCwgYWRkaXRpb25hbCBtZXNzYWdlIGZvciB0aGUgZXhjZXB0aW9uXG4gICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFzc2VydDxUPihfdmFsdWU6IFQgfCBudWxsLCBfbWVzc2FnZTogc3RyaW5nID0gXCJcIik6IFQge1xuICAgICAgaWYgKF92YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZmFpbGVkLiAke19tZXNzYWdlfSwgV2ViR0wtRXJyb3I6ICR7UmVuZGVyV2ViR0wuY3JjMyA/IFJlbmRlcldlYkdMLmNyYzMuZ2V0RXJyb3IoKSA6IFwiXCJ9YCk7XG4gICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgb2Zmc2NyZWVuLWNhbnZhc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgICAgIHJldHVybiA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyV2ViR0wuY3JjMy5jYW52YXM7IC8vIFRPRE86IGVuYWJsZSBPZmZzY3JlZW5DYW52YXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZW5kZXJpbmdDb250ZXh0KCk6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQge1xuICAgICAgcmV0dXJuIFJlbmRlcldlYkdMLmNyYzM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgcmVjdGFuZ2xlIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMuIHgseSBhcmUgMCBhdCBhbGwgdGltZXMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRDYW52YXNSZWN0KCk6IFJlY3RhbmdsZSB7XG4gICAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCA9IDxIVE1MQ2FudmFzRWxlbWVudD5SZW5kZXJXZWJHTC5jcmMzLmNhbnZhcztcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplIG9mIHRoZSBvZmZzY3JlZW4tY2FudmFzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc2V0Q2FudmFzU2l6ZShfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmNhbnZhcy53aWR0aCA9IF93aWR0aDtcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuY2FudmFzLmhlaWdodCA9IF9oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhcmVhIG9uIHRoZSBvZmZzY3JlZW4tY2FudmFzIHRvIHJlbmRlciB0aGUgY2FtZXJhIGltYWdlIHRvLlxuICAgICAqIEBwYXJhbSBfcmVjdFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc2V0UmVuZGVyUmVjdGFuZ2xlKF9yZWN0OiBSZWN0YW5nbGUpOiB2b2lkIHtcbiAgICAgIFJlbmRlcldlYkdMLnJlY3RSZW5kZXIuc2V0UG9zaXRpb25BbmRTaXplKF9yZWN0LngsIF9yZWN0LnksIF9yZWN0LndpZHRoLCBfcmVjdC5oZWlnaHQpO1xuICAgICAgUmVuZGVyV2ViR0wuY3JjMy52aWV3cG9ydChfcmVjdC54LCBfcmVjdC55LCBfcmVjdC53aWR0aCwgX3JlY3QuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgQ29sb3J9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcihfY29sb3I6IENvbG9yID0gbnVsbCk6IHZvaWQge1xuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jbGVhckNvbG9yKF9jb2xvci5yLCBfY29sb3IuZywgX2NvbG9yLmIsIF9jb2xvci5hKTtcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuY2xlYXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgb2Zmc2NyZWVuIGZyYW1lYnVmZmVyIHRvIHRoZSBvcmlnaW5hbCBSZW5kZXJpbmdDb250ZXh0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZXNldEZyYW1lQnVmZmVyKF9mcmFtZUJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlciA9IG51bGwpOiB2b2lkIHtcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIF9mcmFtZUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGFyZWEgb24gdGhlIG9mZnNjcmVlbi1jYW52YXMgdGhlIGNhbWVyYSBpbWFnZSBnZXRzIHJlbmRlcmVkIHRvLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UmVuZGVyUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XG4gICAgICByZXR1cm4gUmVuZGVyV2ViR0wucmVjdFJlbmRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgLyBEaXNhYmxlIFdlYkdMcyBkZXB0aCB0ZXN0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBzZXREZXB0aFRlc3QoX3Rlc3Q6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgIGlmIChfdGVzdClcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9URVNUKTtcbiAgICAgIGVsc2VcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kaXNhYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBibGVuZCBtb2RlIHRvIHJlbmRlciB3aXRoXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBzZXRCbGVuZE1vZGUoX21vZGU6IEJMRU5EKTogdm9pZCB7XG4gICAgICBzd2l0Y2ggKF9tb2RlKSB7XG4gICAgICAgIGNhc2UgQkxFTkQuT1BBUVVFOlxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5aRVJPKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCTEVORC5UUkFOU1BBUkVOVDpcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRXF1YXRpb24oV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GVU5DX0FERCk7XG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TUkNfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgLy8gUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EU1RfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FX01JTlVTX0RTVF9BTFBIQSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQkxFTkQuQURESVRJVkU6XG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEVxdWF0aW9uKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlVOQ19BREQpO1xuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JDX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRTVF9BTFBIQSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQkxFTkQuU1VCVFJBQ1RJVkU6XG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEVxdWF0aW9uKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlVOQ19SRVZFUlNFX1NVQlRSQUNUKTtcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNSQ19BTFBIQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EU1RfQUxQSEEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJMRU5ELk1PRFVMQVRFOiAvLyBjb2xvciBnZXRzIG11bHRpcGxpZWQsIHRyaWVkIHRvIGNvcHkgdW5pdHlzIFwiUGFydGljbGUgU2hhZGVyOiBCbGVuZGluZyBPcHRpb246IFJlbmRlcmluZyBNb2RlOiBNb2R1bGF0ZVwiXG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEVxdWF0aW9uKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlVOQ19BREQpO1xuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0NPTE9SLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBQaWNraW5nXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRleHR1cmUgYnVmZmVyIHRvIGJlIHVzZWQgYXMgcGljay1idWZmZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVBpY2tUZXh0dXJlKF9zaXplOiBudW1iZXIpOiBSZW5kZXJUZXh0dXJlIHtcbiAgICAgIC8vIGNyZWF0ZSB0byByZW5kZXIgdG9cbiAgICAgIGNvbnN0IHRhcmdldFRleHR1cmU6IFJlbmRlclRleHR1cmUgPSBSZW5kZXIuY3JjMy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBSZW5kZXIuY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRhcmdldFRleHR1cmUpO1xuXG4gICAgICB7XG4gICAgICAgIGNvbnN0IGludGVybmFsRm9ybWF0OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEzMkk7XG4gICAgICAgIGNvbnN0IGZvcm1hdDogbnVtYmVyID0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBX0lOVEVHRVI7XG4gICAgICAgIGNvbnN0IHR5cGU6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuSU5UO1xuICAgICAgICBSZW5kZXIucGlja0J1ZmZlciA9IG5ldyBJbnQzMkFycmF5KF9zaXplICogX3NpemUgKiA0KTtcbiAgICAgICAgUmVuZGVyLmNyYzMudGV4SW1hZ2UyRChcbiAgICAgICAgICBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBfc2l6ZSwgX3NpemUsIDAsIGZvcm1hdCwgdHlwZSwgUmVuZGVyLnBpY2tCdWZmZXJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGZpbHRlcmluZyBzbyB3ZSBkb24ndCBuZWVkIG1pcHNcbiAgICAgICAgUmVuZGVyLmNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUik7XG4gICAgICAgIFJlbmRlci5jcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfV1JBUF9TLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBSZW5kZXIuY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXIgPSBSZW5kZXIuY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgUmVuZGVyLmNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRQb2ludDogbnVtYmVyID0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMDtcbiAgICAgIFJlbmRlci5jcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnRQb2ludCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0YXJnZXRUZXh0dXJlLCAwKTtcblxuICAgICAgUmVuZGVyV2ViR0wuc2l6ZVBpY2sgPSBfc2l6ZTtcbiAgICAgIHJldHVybiB0YXJnZXRUZXh0dXJlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgZ2V0UGlja3MoX3NpemU6IG51bWJlciwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja1tdIHtcbiAgICAgIC8vIGV2YWx1YXRlIHRleHR1cmUgYnkgcmVhZGluZyBwaXhlbHMgYW5kIGV4dHJhY3QsIGNvbnZlcnQgYW5kIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIG1lc2ggaGl0XG4gICAgICBsZXQgZGF0YTogSW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KF9zaXplICogX3NpemUgKiA0KTtcbiAgICAgIFJlbmRlci5jcmMzLnJlYWRQaXhlbHMoMCwgMCwgX3NpemUsIF9zaXplLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkFfSU5URUdFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5JTlQsIGRhdGEpO1xuXG4gICAgICBsZXQgbXR4Vmlld1RvV29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JTlZFUlNJT04oX2NtcENhbWVyYS5tdHhXb3JsZFRvVmlldyk7XG4gICAgICBsZXQgcGlja2VkOiBQaWNrW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBSZW5kZXIuxpJwaWNrZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHpCdWZmZXI6IG51bWJlciA9IGRhdGFbNCAqIGkgKyAwXSArIGRhdGFbNCAqIGkgKyAxXSAvIDI1NjtcbiAgICAgICAgaWYgKHpCdWZmZXIgPT0gMCkgLy8gZGlzY2FyZCBtaXNzZXMgXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBwaWNrOiBQaWNrID0gUmVuZGVyLsaScGlja2VkW2ldO1xuICAgICAgICBwaWNrLnpCdWZmZXIgPSBjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoZGF0YSwgNCAqIGkgKyAwKSAqIDIgLSAxO1xuICAgICAgICBwaWNrLmNvbG9yID0gY29udmVydEludDMydG9Db2xvcihkYXRhLCA0ICogaSArIDEpO1xuICAgICAgICBwaWNrLnRleHR1cmVVViA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgICAgcGljay50ZXh0dXJlVVYuc2V0KGNvbnZlcnRJbnQzMnRvRmxvYXQzMihkYXRhLCA0ICogaSArIDIpLCBjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoZGF0YSwgNCAqIGkgKyAzKSk7XG4gICAgICAgIHBpY2subXR4Vmlld1RvV29ybGQgPSBtdHhWaWV3VG9Xb3JsZDtcblxuICAgICAgICBwaWNrZWQucHVzaChwaWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBpY2tlZDtcblxuICAgICAgZnVuY3Rpb24gY29udmVydEludDMydG9GbG9hdDMyKF9pbnQzMkFycmF5OiBJbnQzMkFycmF5LCBfaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgICAgICBsZXQgdmlldzogRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCBfaW50MzJBcnJheVtfaW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQzMigwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29udmVydEludDMydG9Db2xvcihfaW50MzJBcnJheTogSW50MzJBcnJheSwgX2luZGV4OiBudW1iZXIpOiBDb2xvciB7XG4gICAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICAgICAgICBsZXQgdmlldzogRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCBfaW50MzJBcnJheVtfaW5kZXhdKTtcbiAgICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhgcmdiKCR7dmlldy5nZXRVaW50OCgwKX0sICR7dmlldy5nZXRVaW50OCgxKX0sICR7dmlldy5nZXRVaW50OCgyKX0pYCwgdmlldy5nZXRVaW50OCgzKSAvIDI1NSk7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFRoZSByZW5kZXIgZnVuY3Rpb24gZm9yIHBpY2tpbmcgYSBzaW5nbGUgbm9kZS4gXG4gICAgKiBBIGNhbWVyYXByb2plY3Rpb24gd2l0aCBleHRyZW1lbHkgbmFycm93IGZvY3VzIGlzIHVzZWQsIHNvIGVhY2ggcGl4ZWwgb2YgdGhlIGJ1ZmZlciB3b3VsZCBob2xkIHRoZSBzYW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIG5vZGUsICBcbiAgICAqIGJ1dCB0aGUgZnJhZ21lbnQgc2hhZGVyIHJlbmRlcnMgb25seSAxIHBpeGVsIGZvciBlYWNoIG5vZGUgaW50byB0aGUgcmVuZGVyIGJ1ZmZlciwgMXN0IG5vZGUgdG8gMXN0IHBpeGVsLCAybmQgbm9kZSB0byBzZWNvbmQgcGl4ZWwgZXRjLlxuICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBwaWNrKF9ub2RlOiBOb2RlLCBfbXR4TWVzaFRvV29ybGQ6IE1hdHJpeDR4NCwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7IC8vIGNyZWF0ZSBUZXh0dXJlIHRvIHJlbmRlciB0bywgaW50LXJnYmFcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xuICAgICAgICBsZXQgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcbiAgICAgICAgbGV0IGNvYXQ6IENvYXQgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5jb2F0O1xuICAgICAgICBsZXQgc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UgPSBjb2F0IGluc3RhbmNlb2YgQ29hdFRleHR1cmVkID8gU2hhZGVyUGlja1RleHR1cmVkIDogU2hhZGVyUGljaztcblxuICAgICAgICBzaGFkZXIudXNlUHJvZ3JhbSgpO1xuICAgICAgICBjb2F0LnVzZVJlbmRlckRhdGEoc2hhZGVyLCBjbXBNYXRlcmlhbCk7XG4gICAgICAgIGxldCBtdHhNZXNoVG9WaWV3OiBNYXRyaXg0eDQgPSB0aGlzLmNhbGNNZXNoVG9WaWV3KF9ub2RlLCBjbXBNZXNoLCBfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3LCBfY21wQ2FtZXJhLm10eFdvcmxkLnRyYW5zbGF0aW9uKTtcblxuICAgICAgICBsZXQgc2l6ZVVuaWZvcm1Mb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBzaGFkZXIudW5pZm9ybXNbXCJ1X3ZjdFNpemVcIl07XG4gICAgICAgIFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKS51bmlmb3JtMmZ2KHNpemVVbmlmb3JtTG9jYXRpb24sIFtSZW5kZXJXZWJHTC5zaXplUGljaywgUmVuZGVyV2ViR0wuc2l6ZVBpY2tdKTtcblxuICAgICAgICBsZXQgbWVzaDogTWVzaCA9IGNtcE1lc2gubWVzaDtcbiAgICAgICAgbGV0IHJlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSBtZXNoLnVzZVJlbmRlckJ1ZmZlcnMoc2hhZGVyLCBfbXR4TWVzaFRvV29ybGQsIG10eE1lc2hUb1ZpZXcsIFJlbmRlci7GknBpY2tlZC5sZW5ndGgpO1xuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmRyYXdFbGVtZW50cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgcmVuZGVyQnVmZmVycy5uSW5kaWNlcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCk7XG5cbiAgICAgICAgbGV0IHBpY2s6IFBpY2sgPSBuZXcgUGljayhfbm9kZSk7XG4gICAgICAgIFJlbmRlci7GknBpY2tlZC5wdXNoKHBpY2spO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIC8vXG4gICAgICB9XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIExpZ2h0c1xuICAgIC8qKlxuICAgICAqIEJ1ZmZlciB0aGUgZGF0YSBmcm9tIHRoZSBsaWdodHMgaW4gdGhlIHNjZW5lZ3JhcGggaW50byB0aGUgbGlnaHRzIHVib1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgdXBkYXRlTGlnaHRzVUJPKF9saWdodHM6IE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0KTogdm9pZCB7XG4gICAgICBpZiAoIVJlbmRlcldlYkdMLnVib0xpZ2h0cylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgUmVuZGVyV2ViR0wudWJvTGlnaHRzKTtcblxuICAgICAgLy8gZmlsbCB0aGUgYnVmZmVyIHdpdGggdGhlIGFtYmllbnQgbGlnaHQgY29sb3JcbiAgICAgIGxldCBjbXBMaWdodHM6IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0PiA9IF9saWdodHMuZ2V0KExpZ2h0QW1iaWVudCk7XG4gICAgICBpZiAoY21wTGlnaHRzKSB7XG4gICAgICAgIGxldCByZXN1bHQ6IENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICBmb3IgKGxldCBjbXBMaWdodCBvZiBjbXBMaWdodHMpXG4gICAgICAgICAgcmVzdWx0LmFkZChjbXBMaWdodC5saWdodC5jb2xvcik7XG5cbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5idWZmZXJTdWJEYXRhKFxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuVU5JRk9STV9CVUZGRVIsXG4gICAgICAgICAgUmVuZGVyV2ViR0wudWJvTGlnaHRzVmFyaWFibGVPZmZzZXRzW1widV9hbWJpZW50LnZjdENvbG9yXCJdLCAvLyBieXRlIG9mZnNldCBvZiB0aGUgc3RydWN0IExpZ2h0IFwidV9hbWJpZW50XCIgaW5zaWRlIHRoZSB1Ym9cbiAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5nZXRBcnJheSgpKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBmaWxsIHRoZSBidWZmZXIgd2l0aCB0aGUgbGlnaHQgZGF0YSBmb3IgZWFjaCBsaWdodCB0eXBlXG4gICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGRvaW5nIGEgbWF4aW11bSBvZiA0IGNyYzMuYnVmZmVyU3ViRGF0YSgpIGNhbGxzLCBidXQgd2UgY291bGQgZG8gdGhpcyBpbiBvbmUgY2FsbFxuICAgICAgdXBkYXRlTGlnaHRzKExpZ2h0RGlyZWN0aW9uYWwsIFwidV9uTGlnaHRzRGlyZWN0aW9uYWxcIiwgXCJ1X2RpcmVjdGlvbmFsXCIpO1xuICAgICAgdXBkYXRlTGlnaHRzKExpZ2h0UG9pbnQsIFwidV9uTGlnaHRzUG9pbnRcIiwgXCJ1X3BvaW50XCIpO1xuICAgICAgdXBkYXRlTGlnaHRzKExpZ2h0U3BvdCwgXCJ1X25MaWdodHNTcG90XCIsIFwidV9zcG90XCIpO1xuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVMaWdodHMoX3R5cGU6IFR5cGVPZkxpZ2h0LCBfdW5pTmFtZTogc3RyaW5nLCBfdW5pU3RydWN0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY21wTGlnaHRzOiBSZWN5Y2FibGVBcnJheTxDb21wb25lbnRMaWdodD4gPSBfbGlnaHRzLmdldChfdHlwZSk7XG5cbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5idWZmZXJTdWJEYXRhKFxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuVU5JRk9STV9CVUZGRVIsXG4gICAgICAgICAgUmVuZGVyV2ViR0wudWJvTGlnaHRzVmFyaWFibGVPZmZzZXRzW191bmlOYW1lXSwgLy8gYnl0ZSBvZmZzZXQgb2YgdGhlIHVpbnQgXCJ1X25MaWdodHNEaXJlY3Rpb25hbFwiIGluc2lkZSB0aGUgdWJvXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW2NtcExpZ2h0cz8ubGVuZ3RoID8/IDBdKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghY21wTGlnaHRzKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBsaWdodERhdGFTaXplOiBudW1iZXIgPSA0ICsgMTYgKyAxNjsgLy8gdmN0Q29sb3IgKyBtdHhTaGFwZSArIG10eFNoYXBlSW52ZXJzZSwgYXMgZmxvYXQzMnNcbiAgICAgICAgY29uc3QgbGlnaHRzRGF0YTogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjbXBMaWdodHMubGVuZ3RoICogbGlnaHREYXRhU2l6ZSk7XG5cbiAgICAgICAgbGV0IGlMaWdodDogbnVtYmVyID0gMDtcbiAgICAgICAgZm9yIChsZXQgY21wTGlnaHQgb2YgY21wTGlnaHRzKSB7XG4gICAgICAgICAgY29uc3QgbGlnaHREYXRhT2Zmc2V0OiBudW1iZXIgPSBpTGlnaHQgKiBsaWdodERhdGFTaXplO1xuXG4gICAgICAgICAgLy8gc2V0IHZjdENvbG9yXG4gICAgICAgICAgbGlnaHRzRGF0YS5zZXQoY21wTGlnaHQubGlnaHQuY29sb3IuZ2V0QXJyYXkoKSwgbGlnaHREYXRhT2Zmc2V0ICsgMCk7XG5cbiAgICAgICAgICAvLyBzZXQgbXR4U2hhcGVcbiAgICAgICAgICBsZXQgbXR4VG90YWw6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihjbXBMaWdodC5ub2RlLm10eFdvcmxkLCBjbXBMaWdodC5tdHhQaXZvdCk7XG4gICAgICAgICAgbGlnaHRzRGF0YS5zZXQobXR4VG90YWwuZ2V0KCksIGxpZ2h0RGF0YU9mZnNldCArIDQpOyAvLyBvZmZzZXQgKyB2Y3RDb2xvclxuXG4gICAgICAgICAgLy8gc2V0IG10eFNoYXBlSW52ZXJzZVxuICAgICAgICAgIGlmIChfdHlwZSAhPSBMaWdodERpcmVjdGlvbmFsKSB7XG4gICAgICAgICAgICBsZXQgbXR4SW52ZXJzZTogTWF0cml4NHg0ID0gbXR4VG90YWwuaW52ZXJzZSgpO1xuICAgICAgICAgICAgbGlnaHRzRGF0YS5zZXQobXR4SW52ZXJzZS5nZXQoKSwgbGlnaHREYXRhT2Zmc2V0ICsgNCArIDE2KTsgLy8gb2Zmc2V0ICsgdmN0Q29sb3IgKyBtdHhTaGFwZVxuICAgICAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4SW52ZXJzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4VG90YWwpO1xuICAgICAgICAgIGlMaWdodCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5idWZmZXJTdWJEYXRhKFxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuVU5JRk9STV9CVUZGRVIsXG4gICAgICAgICAgUmVuZGVyV2ViR0wudWJvTGlnaHRzVmFyaWFibGVPZmZzZXRzW2Ake191bmlTdHJ1Y3R9WzBdLnZjdENvbG9yYF0sIC8vIGJ5dGUgb2Zmc2V0IG9mIHRoZSBzdHJ1Y3QgTGlnaHQgYXJyYXkgaW5zaWRlIHRoZSB1Ym9cbiAgICAgICAgICBsaWdodHNEYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLyoqXG4gICAgICogRHJhdyBhIG1lc2ggYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBpbmZvcyBhbmQgdGhlIGNvbXBsZXRlIHByb2plY3Rpb24gbWF0cml4XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkcmF3Tm9kZShfbm9kZTogTm9kZSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcbiAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpO1xuICAgICAgbGV0IGNvYXQ6IENvYXQgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5jb2F0O1xuICAgICAgbGV0IGNtcFBhcnRpY2xlU3lzdGVtOiBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk7XG4gICAgICBsZXQgZHJhd1BhcnRpY2xlczogYm9vbGVhbiA9IGNtcFBhcnRpY2xlU3lzdGVtICYmIGNtcFBhcnRpY2xlU3lzdGVtLmlzQWN0aXZlO1xuICAgICAgbGV0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuZ2V0U2hhZGVyKCk7XG4gICAgICBpZiAoZHJhd1BhcnRpY2xlcylcbiAgICAgICAgc2hhZGVyID0gY21wUGFydGljbGVTeXN0ZW0ucGFydGljbGVTeXN0ZW0uZ2V0U2hhZGVyRnJvbShzaGFkZXIpO1xuXG4gICAgICBzaGFkZXIudXNlUHJvZ3JhbSgpO1xuICAgICAgY29hdC51c2VSZW5kZXJEYXRhKHNoYWRlciwgY21wTWF0ZXJpYWwpO1xuXG4gICAgICBsZXQgbXR4TWVzaFRvVmlldzogTWF0cml4NHg0ID0gdGhpcy5jYWxjTWVzaFRvVmlldyhfbm9kZSwgY21wTWVzaCwgX2NtcENhbWVyYS5tdHhXb3JsZFRvVmlldywgX2NtcENhbWVyYS5tdHhXb3JsZC50cmFuc2xhdGlvbik7XG4gICAgICBsZXQgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyA9IGNtcE1lc2gubWVzaC51c2VSZW5kZXJCdWZmZXJzKHNoYWRlciwgY21wTWVzaC5tdHhXb3JsZCwgbXR4TWVzaFRvVmlldyk7XG5cbiAgICAgIGlmIChjbXBNZXNoLnNrZWxldG9uICYmIGNtcE1lc2guc2tlbGV0b24uaXNBY3RpdmUpIFxuICAgICAgICBjbXBNZXNoLnNrZWxldG9uLnVzZVJlbmRlckJ1ZmZlcihzaGFkZXIpO1xuXG4gICAgICBsZXQgdW5pZm9ybTogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBzaGFkZXIudW5pZm9ybXNbXCJ1X3ZjdENhbWVyYVwiXTtcbiAgICAgIGlmICh1bmlmb3JtKVxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLnVuaWZvcm0zZnYodW5pZm9ybSwgX2NtcENhbWVyYS5tdHhXb3JsZC50cmFuc2xhdGlvbi5nZXQoKSk7XG5cbiAgICAgIHVuaWZvcm0gPSBzaGFkZXIudW5pZm9ybXNbXCJ1X210eFdvcmxkVG9WaWV3XCJdO1xuICAgICAgaWYgKHVuaWZvcm0pXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtLCBmYWxzZSwgX2NtcENhbWVyYS5tdHhXb3JsZFRvVmlldy5nZXQoKSk7XG5cbiAgICAgIHVuaWZvcm0gPSBzaGFkZXIudW5pZm9ybXNbXCJ1X210eFdvcmxkVG9DYW1lcmFcIl07XG4gICAgICBpZiAodW5pZm9ybSkge1xuICAgICAgICAvLyBsZXQgbXR4V29ybGRUb0NhbWVyYTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0lPTihfY21wQ2FtZXJhLm10eFdvcmxkKTsgLy8gdG9kbzogb3B0aW1pemUvc3RvcmUgaW4gY2FtZXJhXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtLCBmYWxzZSwgX2NtcENhbWVyYS5tdHhDYW1lcmFJbnZlcnNlLmdldCgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXdQYXJ0aWNsZXMpIHtcbiAgICAgICAgUmVuZGVyV2ViR0wuZHJhd1BhcnRpY2xlcyhjbXBQYXJ0aWNsZVN5c3RlbSwgc2hhZGVyLCByZW5kZXJCdWZmZXJzLCBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50RmFjZUNhbWVyYSksIGNtcE1hdGVyaWFsLnNvcnRGb3JBbHBoYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmRyYXdFbGVtZW50cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgcmVuZGVyQnVmZmVycy5uSW5kaWNlcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkcmF3UGFydGljbGVzKF9jbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0sIF9zaGFkZXI6IFNoYWRlckludGVyZmFjZSwgX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMsIF9jbXBGYWNlQ2FtZXJhOiBDb21wb25lbnRGYWNlQ2FtZXJhLCBfc29ydEZvckFscGhhOiBib29sZWFuKTogdm9pZCB7XG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmRlcHRoTWFzayhfY21wUGFydGljbGVTeXN0ZW0uZGVwdGhNYXNrKTtcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShfY21wUGFydGljbGVTeXN0ZW0uYmxlbmRNb2RlKTtcbiAgICAgIF9jbXBQYXJ0aWNsZVN5c3RlbS51c2VSZW5kZXJEYXRhKCk7XG5cbiAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTFmKF9zaGFkZXIudW5pZm9ybXNbXCJ1X2ZQYXJ0aWNsZVN5c3RlbUR1cmF0aW9uXCJdLCBfY21wUGFydGljbGVTeXN0ZW0uZHVyYXRpb24pO1xuICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtMWYoX3NoYWRlci51bmlmb3Jtc1tcInVfZlBhcnRpY2xlU3lzdGVtU2l6ZVwiXSwgX2NtcFBhcnRpY2xlU3lzdGVtLnNpemUpO1xuICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtMWYoX3NoYWRlci51bmlmb3Jtc1tcInVfZlBhcnRpY2xlU3lzdGVtVGltZVwiXSwgX2NtcFBhcnRpY2xlU3lzdGVtLnRpbWUpO1xuICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtMWkoX3NoYWRlci51bmlmb3Jtc1tcInVfZlBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVyc1wiXSwgMSk7IC8vIEFUVEVOVElPTiE6IGNoYW5naW5nIHRoaXMgaWQgKHRoZSBzZWNvbmQgYXJndW1lbnQpIHJlcXVpcmVzIGNoYW5naW5nIG9mIGNvcnJlc3BvbmRpbmcgdGV4dHVyZSBpZCBpbiBjb21wb25lbnQgcGFydGljbGUgc3lzdGVtIHJlbmRlciBpbmplY3RvclxuXG4gICAgICBsZXQgZmFjZUNhbWVyYTogYm9vbGVhbiA9IF9jbXBGYWNlQ2FtZXJhICYmIF9jbXBGYWNlQ2FtZXJhLmlzQWN0aXZlO1xuICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtMWkoX3NoYWRlci51bmlmb3Jtc1tcInVfYlBhcnRpY2xlU3lzdGVtRmFjZUNhbWVyYVwiXSwgZmFjZUNhbWVyYSA/IDEgOiAwKTtcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTFpKF9zaGFkZXIudW5pZm9ybXNbXCJ1X2JQYXJ0aWNsZVN5c3RlbVJlc3RyaWN0XCJdLCBmYWNlQ2FtZXJhICYmIF9jbXBGYWNlQ2FtZXJhLnJlc3RyaWN0ID8gMSA6IDApO1xuXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmRyYXdFbGVtZW50c0luc3RhbmNlZChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgX3JlbmRlckJ1ZmZlcnMubkluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDAsIF9jbXBQYXJ0aWNsZVN5c3RlbS5zaXplKTtcblxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELlRSQU5TUEFSRU5UKTtcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuZGVwdGhNYXNrKHRydWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNhbGNNZXNoVG9WaWV3KF9ub2RlOiBOb2RlLCBfY21wTWVzaDogQ29tcG9uZW50TWVzaCwgX210eFdvcmxkVG9WaWV3OiBNYXRyaXg0eDQsIF90YXJnZXQ/OiBWZWN0b3IzKTogTWF0cml4NHg0IHtcbiAgICAgIGxldCBjbXBGYWNlQ2FtZXJhOiBDb21wb25lbnRGYWNlQ2FtZXJhID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudEZhY2VDYW1lcmEpO1xuICAgICAgaWYgKGNtcEZhY2VDYW1lcmEgJiYgY21wRmFjZUNhbWVyYS5pc0FjdGl2ZSkge1xuICAgICAgICBsZXQgbXR4TWVzaFRvVmlldzogTWF0cml4NHg0O1xuICAgICAgICBtdHhNZXNoVG9WaWV3ID0gX2NtcE1lc2gubXR4V29ybGQuY2xvbmU7XG4gICAgICAgIG10eE1lc2hUb1ZpZXcubG9va0F0KF90YXJnZXQsIGNtcEZhY2VDYW1lcmEudXBMb2NhbCA/IG51bGwgOiBjbXBGYWNlQ2FtZXJhLnVwLCBjbXBGYWNlQ2FtZXJhLnJlc3RyaWN0KTtcbiAgICAgICAgcmV0dXJuIE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfbXR4V29ybGRUb1ZpZXcsIG10eE1lc2hUb1ZpZXcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9tdHhXb3JsZFRvVmlldywgX2NtcE1lc2gubXR4V29ybGQpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIC8qKlxuICAgKiBHaXZlcyBXZWJHTCBCdWZmZXIgdGhlIGRhdGEgZnJvbSB0aGUge0BsaW5rIFRleHR1cmV9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yVGV4dHVyZSBleHRlbmRzIFJlbmRlckluamVjdG9yIHtcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgIFJlbmRlckluamVjdG9yLmluamVjdChfY29uc3RydWN0b3IsIFJlbmRlckluamVjdG9yVGV4dHVyZSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJkZWxldGVSZW5kZXJEYXRhXCIsIHtcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yVGV4dHVyZS5kZWxldGVSZW5kZXJEYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdFRleHR1cmUodGhpczogVGV4dHVyZSk6IHZvaWQge1xuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgICBpZiAodGhpcy5yZW5kZXJEYXRhKSB7XG4gICAgICAgIC8vIGJ1ZmZlcnMgZXhpc3RcbiAgICAgICAgY3JjMy5hY3RpdmVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTApO1xuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhID0ge307XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIGFsbCBXZWJHTC1DcmVhdGlvbnMgYXJlIGFzc2VydGVkXG4gICAgICAgIGNvbnN0IHRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlci5hc3NlcnQ8V2ViR0xUZXh0dXJlPihjcmMzLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNyYzMudGV4SW1hZ2UyRChjcmMzLlRFWFRVUkVfMkQsIDAsIGNyYzMuUkdCQSwgY3JjMy5SR0JBLCBjcmMzLlVOU0lHTkVEX0JZVEUsIHRoaXMudGV4SW1hZ2VTb3VyY2UpO1xuICAgICAgICAgIGNyYzMudGV4SW1hZ2UyRChcbiAgICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSxcbiAgICAgICAgICAgIHRoaXMudGV4SW1hZ2VTb3VyY2VcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5taXBtYXApIHtcbiAgICAgICAgICBjYXNlIE1JUE1BUC5DUklTUDpcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1JUE1BUC5NRURJVU06XG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1RfTUlQTUFQX0xJTkVBUik7XG4gICAgICAgICAgICBjcmMzLmdlbmVyYXRlTWlwbWFwKGNyYzMuVEVYVFVSRV8yRCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE1JUE1BUC5CTFVSUlk6XG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIpO1xuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICAgICAgICAgICAgY3JjMy5nZW5lcmF0ZU1pcG1hcChjcmMzLlRFWFRVUkVfMkQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0gPSB0ZXh0dXJlO1xuXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsKTtcblxuICAgICAgICB0aGlzLnVzZVJlbmRlckRhdGEoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckRhdGEodGhpczogVGV4dHVyZSk6IHZvaWQge1xuICAgICAgaWYgKCF0aGlzLnJlbmRlckRhdGEpIHJldHVybjtcblxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICBmb3IgKGNvbnN0IHRleHR1cmVLZXkgaW4gdGhpcy5yZW5kZXJEYXRhKSBcbiAgICAgICAgY3JjMy5kZWxldGVUZXh0dXJlKHRoaXMucmVuZGVyRGF0YVt0ZXh0dXJlS2V5XSk7XG4gICAgICB0aGlzLnJlbmRlckRhdGEgPSBudWxsO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX1BIWVNJQ1Mge1xuICAgIFRSSUdHRVJfRU5URVIgPSBcIlRyaWdnZXJFbnRlcmVkQ29sbGlzaW9uXCIsXG4gICAgVFJJR0dFUl9FWElUID0gXCJUcmlnZ2VyTGVmdENvbGxpc2lvblwiLFxuICAgIENPTExJU0lPTl9FTlRFUiA9IFwiQ29sbGlkZXJFbnRlcmVkQ29sbGlzaW9uXCIsXG4gICAgQ09MTElTSU9OX0VYSVQgPSBcIkNvbGxpZGVyTGVmdENvbGxpc2lvblwiXG4gIH1cblxuICAvKipcbiAgICogU3BlY2lhbCB0eXBlIG9mIHtAbGluayBFdmVudH0gZm9yIHBoeXNpY3MuXG4gICAqL1xuICBleHBvcnQgY2xhc3MgRXZlbnRQaHlzaWNzIGV4dGVuZHMgRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbXBvbmVudFJpZ2lkYm9keSB0aGF0IGNvbGxpZGVkIHdpdGggdGhpcyBDb21wb25lbnRSaWdpZGJvZHlcbiAgICAgKi9cbiAgICBwdWJsaWMgY21wUmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHk7XG4gICAgLyoqXG4gICAgICogVGhlIG5vcm1hbCBpbXB1bHNlIGJldHdlZW4gdGhlIHR3byBjb2xsaWRpbmcgb2JqZWN0cy4gTm9ybWFsIHJlcHJlc2VudHMgdGhlIGRlZmF1bHQgaW1wdWxzZS5cbiAgICAgKiBJbXB1bHNlIGlzIG9ubHkgaGFwcGVuaW5nIG9uIENPTExJU0lPTl9FTlRFUiwgc28gdGhlcmUgaXMgbm8gaW1wdWxzZSBvbiBleGl0IG5vciBvbiB0cmlnZ2Vycy5cbiAgICAgKiBVc2UgdGhlIHZlbG9jaXR5IG9mIHRoZSBjbXBSaWdpZGJvZHkgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlbnNpdHkgb2YgdGhlIEVWRU5UIGluc3RlYWQuXG4gICAgICovXG4gICAgcHVibGljIG5vcm1hbEltcHVsc2U6IG51bWJlcjtcbiAgICBwdWJsaWMgdGFuZ2VudEltcHVsc2U6IG51bWJlcjtcbiAgICBwdWJsaWMgYmlub21hbEltcHVsc2U6IG51bWJlcjtcbiAgICAvKiogVGhlIHBvaW50IHdoZXJlIHRoZSBjb2xsaXNpb24vdHJpZ2dlcmluZyBpbml0aWFsbHkgaGFwcGVuZWQuIFRoZSBjb2xsaXNpb24gcG9pbnQgZXhpc3RzIG9ubHkgb24gQ09MTElTSU9OX0VOVEVSIC8gVFJJR0dFUl9FTlRFUi4gKi9cbiAgICBwdWJsaWMgY29sbGlzaW9uUG9pbnQ6IFZlY3RvcjM7XG4gICAgLyoqIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBjb2xsaXNpb24uIE9ubHkgZXhpc3Rpbmcgb24gQ09MTElTSU9OX0VOVEVSICovXG4gICAgcHVibGljIGNvbGxpc2lvbk5vcm1hbDogVmVjdG9yMztcblxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IGV2ZW50IGN1c3RvbWl6ZWQgZm9yIHBoeXNpY3MuIEhvbGRpbmcgaW5mb3JtYXRpb25zIGFib3V0IGltcHVsc2VzLiBDb2xsaXNpb24gcG9pbnQgYW5kIHRoZSBib2R5IHRoYXQgaXMgY29sbGlkaW5nICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90eXBlOiBFVkVOVF9QSFlTSUNTLCBfaGl0UmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHksIF9ub3JtYWxJbXB1bHNlOiBudW1iZXIsIF90YW5nZW50SW1wdWxzZTogbnVtYmVyLCBfYmlub3JtYWxJbXB1bHNlOiBudW1iZXIsIF9jb2xsaXNpb25Qb2ludDogVmVjdG9yMyA9IG51bGwsIF9jb2xsaXNpb25Ob3JtYWw6IFZlY3RvcjMgPSBudWxsKSB7XG4gICAgICBzdXBlcihfdHlwZSk7XG4gICAgICB0aGlzLmNtcFJpZ2lkYm9keSA9IF9oaXRSaWdpZGJvZHk7XG4gICAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSBfbm9ybWFsSW1wdWxzZTtcbiAgICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSBfdGFuZ2VudEltcHVsc2U7XG4gICAgICB0aGlzLmJpbm9tYWxJbXB1bHNlID0gX2Jpbm9ybWFsSW1wdWxzZTtcbiAgICAgIHRoaXMuY29sbGlzaW9uUG9pbnQgPSBfY29sbGlzaW9uUG9pbnQ7XG4gICAgICB0aGlzLmNvbGxpc2lvbk5vcm1hbCA9IF9jb2xsaXNpb25Ob3JtYWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogR3JvdXBzIHRvIHBsYWNlIGEgbm9kZSBpbiwgbm90IGV2ZXJ5IGdyb3VwIHNob3VsZCBjb2xsaWRlIHdpdGggZXZlcnkgZ3JvdXAuIFVzZSBhIE1hc2sgaW4gdG8gZXhjbHVkZSBjb2xsaXNpb25zXG4gICovXG4gIGV4cG9ydCBlbnVtIENPTExJU0lPTl9HUk9VUCB7IC8vVE9ETyBHaXZlIGEgcG9zc2libGl0aHkgdG8gc2V0IHdoaWNoIGxheWVyIGNvbGxpZGVzIHdpdGggd2hpY2gsIENvbGxpc2lvbk1hdHJpeD9cbiAgICBERUZBVUxUID0gMSxcbiAgICBHUk9VUF8xID0gMixcbiAgICBHUk9VUF8yID0gNCxcbiAgICBHUk9VUF8zID0gOCxcbiAgICBHUk9VUF80ID0gMTYsXG4gICAgR1JPVVBfNSA9IDMyXG4gIH1cblxuICAvKipcbiAgKiBEZWZpbmVzIHRoZSB0eXBlIG9mIHRoZSByaWdpZGJvZHkgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgd2F5IGl0IGludGVyYWN0cyB3aXRoIHRoZSBwaHlzaWNhbCBhbmQgdGhlIHZpc3VhbCB3b3JsZFxuICAqL1xuICBleHBvcnQgZW51bSBCT0RZX1RZUEUge1xuICAgIC8qKiBUaGUgYm9keSBpZ25vcmVzIHRoZSBoaWVyYXJjaHkgb2YgdGhlIHJlbmRlciBncmFwaCwgaXMgY29tcGxldGVseSBjb250cm9sbGVkICBieSBwaHlzaWNzIGFuZCB0YWtlcyBpdHMgbm9kZSB3aXRoIGl0ICAqL1xuICAgIERZTkFNSUMsIC8vID0gT0lNTy5SaWdpZEJvZHlUeXBlLkRZTkFNSUMsXG4gICAgLyoqIFRoZSBib2R5IGlnbm9yZXMgdGhlIGhpZXJhcmNoeSBvZiB0aGUgcmVuZGVyIGdyYXBoLCBpcyBjb21wbGV0ZWx5IGltbW92ZWJsZSBhbmQga2VlcHMgaXRzIG5vZGUgZnJvbSBtb3ZpbmcgICovXG4gICAgU1RBVElDLCAvLyA9IE9JTU8uUmlnaWRCb2R5VHlwZS5TVEFUSUMsXG4gICAgLyoqIFRoZSBib2R5IGlzIGNvbnRyb2xsZWQgYnkgaXRzIG5vZGUgYW5kIG1vdmVzIHdpdGggaXQsIHdoaWxlIGl0IGltcGFjdHMgdGhlIHBoeXNpY2FsIHdvcmxkIGUuZy4gYnkgY29sbGlzaW9ucyAqL1xuICAgIEtJTkVNQVRJQyAvLyA9IE9JTU8uUmlnaWRCb2R5VHlwZS5LSU5FTUFUSUNcbiAgfVxuXG4gIC8qKlxuICAqIERpZmZlcmVudCB0eXBlcyBvZiBjb2xsaWRlciBzaGFwZXMsIHdpdGggZGlmZmVyZW50IG9wdGlvbnMgaW4gc2NhbGluZyBCT1ggPSBWZWN0b3IzKGxlbmd0aCwgaGVpZ2h0LCBkZXB0aCksXG4gICogU1BIRVJFID0gVmVjdG9yMyhkaWFtZXRlciwgeCwgeCksIENBUFNVTEUgPSBWZWN0b3IzKGRpYW1ldGVyLCBoZWlnaHQsIHgpLCBDWUxJTkRFUiA9IFZlY3RvcjMoZGlhbWV0ZXIsIGhlaWdodCwgeCksXG4gICogQ09ORSA9IFZlY3RvcihkaWFtZXRlciwgaGVpZ2h0LCB4KSwgUFlSQU1JRCA9IFZlY3RvcjMobGVuZ3RoLCBoZWlnaHQsIGRlcHRoKTsgeCA9PSB1bnVzZWQuXG4gICogQ09OVkVYID0gQ29tcG9uZW50TWVzaCBuZWVkcyB0byBiZSBhdmFpbGFibGUgaW4gdGhlIFJCIFByb3BlcnR5IGNvbnZleE1lc2gsIHRoZSBwb2ludHMgb2YgdGhhdCBjb21wb25lbnQgYXJlIHVzZWQgdG8gY3JlYXRlIGEgY29sbGlkZXIgdGhhdCBtYXRjaGVzLFxuICAqIHRoZSBjbG9zZXN0IHBvc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoYXQgZm9ybSwgaW4gZm9ybSBvZiBhIGh1bGwuIENvbnZleCBpcyBleHBlcmltZW50YWwgYW5kIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyIHdoZW4gdmVydGljZXNcbiAgKiBhcmUgdG9vIGNsb3NlIHRvIG9uZSBhbm90aGVyIGFuZCB0aGUgZ2l2ZW4gdmVydGljZXMgZG8gbm90IGZvcm0gYSBpbiBpdHNlbGYgY2xvc2VkIHNoYXBlIGFuZCBoYXZpbmcgYSBnZW51cyBvZiAwIChubyBob2xlcykuIFZlcnRpY2VzIGluIHRoZSBDb21wb25lbnRNZXNoIGNhbiBiZSBzY2FsZWQgZGlmZmVyZW50bHkgXG4gICogZm9yIHRleHR1cmluZy9ub3JtYWwgb3Igb3RoZXIgcmVhc29ucywgc28gdGhlIGNvbGxpZGVyIG1pZ2h0IGJlIG9mZiBjb21wYXJlZCB0byB0aGUgdmlzdWFsIHNoYXBlLCB0aGlzIGNhbiBiZSBjb3JyZWN0ZWQgYnkgY2hhbmdpbmcgdGhlIHBpdm90IHNjYWxlIG9mIHRoZSBDb21wb25lbnRSaWdpZGJvZHkuICBcbiAgKi9cbiAgZXhwb3J0IGVudW0gQ09MTElERVJfVFlQRSB7XG4gICAgQ1VCRSxcbiAgICBTUEhFUkUsXG4gICAgQ0FQU1VMRSxcbiAgICBDWUxJTkRFUixcbiAgICBDT05FLFxuICAgIFBZUkFNSUQsXG4gICAgQ09OVkVYXG4gIH1cblxuICAvKiogRGlzcGxheWluZyBkaWZmZXJlbnQgdHlwZXMgb2YgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgZGlmZmVyZW50IHBoeXNpYyBmZWF0dXJlcy4gRGVmYXVsdCA9IEpPSU5UU19BTkRfQ09MTElERVIuICovXG4gIGV4cG9ydCBlbnVtIFBIWVNJQ1NfREVCVUdNT0RFIHtcbiAgICBOT05FLFxuICAgIENPTExJREVSUyxcbiAgICBKT0lOVFNfQU5EX0NPTExJREVSLFxuICAgIEJPVU5ESU5HX0JPWEVTLFxuICAgIENPTlRBQ1RTLFxuICAgIFBIWVNJQ19PQkpFQ1RTX09OTFlcbiAgfVxuXG4gIC8qKiBJbmZvIGFib3V0IFJheWNhc3RzIHNob3QgZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0uICovXG4gIGV4cG9ydCBjbGFzcyBSYXlIaXRJbmZvIGltcGxlbWVudHMgUmVjeWNhYmxlIHtcbiAgICBwdWJsaWMgaGl0OiBib29sZWFuO1xuICAgIHB1YmxpYyBoaXREaXN0YW5jZTogbnVtYmVyO1xuICAgIHB1YmxpYyBoaXRQb2ludDogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xuICAgIHB1YmxpYyByaWdpZGJvZHlDb21wb25lbnQ6IENvbXBvbmVudFJpZ2lkYm9keTtcbiAgICBwdWJsaWMgaGl0Tm9ybWFsOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XG4gICAgcHVibGljIHJheUVuZDogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xuICAgIHB1YmxpYyByYXlPcmlnaW46IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMucmVjeWNsZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xuICAgICAgdGhpcy5oaXQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaGl0RGlzdGFuY2UgPSAwO1xuICAgICAgdGhpcy5oaXRQb2ludC5yZWN5Y2xlKCk7XG4gICAgICB0aGlzLnJpZ2lkYm9keUNvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLmhpdE5vcm1hbC5yZWN5Y2xlKCk7XG4gICAgICB0aGlzLnJheU9yaWdpbi5yZWN5Y2xlKCk7XG4gICAgICB0aGlzLnJheUVuZC5yZWN5Y2xlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdlbmVyYWwgc2V0dGluZ3MgZm9yIHRoZSBwaHlzaWMgc2ltdWxhdGlvbiBhbmQgdGhlIGRlYnVnIG9mIGl0LiAqL1xuICBleHBvcnQgY2xhc3MgUGh5c2ljc1NldHRpbmdzIHtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfZGVmYXVsdENvbGxpc2lvbkdyb3VwOiBudW1iZXIsIF9kZWZhdWx0Q29sbGlzaW9uTWFzazogbnVtYmVyKSB7XG4gICAgICBpZiAodHlwZW9mIE9JTU8gPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5kZWZhdWx0Q29sbGlzaW9uR3JvdXAgPSBfZGVmYXVsdENvbGxpc2lvbkdyb3VwO1xuICAgICAgdGhpcy5kZWZhdWx0Q29sbGlzaW9uTWFzayA9IF9kZWZhdWx0Q29sbGlzaW9uTWFzaztcbiAgICB9XG5cbiAgICAvKiogQ2hhbmdlIGlmIHJpZ2lkYm9kaWVzIGFyZSBhYmxlIHRvIHNsZWVwIChkb24ndCBiZSBjb25zaWRlcmVkIGluIHBoeXNpY2FsIGNhbGN1bGF0aW9ucykgd2hlbiB0aGVpciBtb3ZlbWVudCBpcyBiZWxvdyBhIHRocmVzaG9sZC4gRGVhY3RpdmF0aW9uIGlzIGRlY3JlYXNpbmcgcGVyZm9ybWFuY2UgZm9yIG1pbm9yIGFkdmFudGFnZSBpbiBwcmVjaXNpb24uICovXG4gICAgcHVibGljIGdldCBkaXNhYmxlU2xlZXBpbmcoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRpc2FibGVTbGVlcGluZztcbiAgICB9XG4gICAgcHVibGljIHNldCBkaXNhYmxlU2xlZXBpbmcoX3ZhbHVlOiBib29sZWFuKSB7XG4gICAgICBPSU1PLlNldHRpbmcuZGlzYWJsZVNsZWVwaW5nID0gX3ZhbHVlO1xuICAgIH1cbiAgICAvKiogU2xlZXBpbmcgVGhyZXNob2xkIGZvciBNb3ZlbWVudCBWZWxvY3RpeS4gKi9cbiAgICBwdWJsaWMgZ2V0IHNsZWVwaW5nVmVsb2NpdHlUaHJlc2hvbGQoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZDtcbiAgICB9XG4gICAgcHVibGljIHNldCBzbGVlcGluZ1ZlbG9jaXR5VGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBPSU1PLlNldHRpbmcuc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZCA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKiogU2xlZXBpbmcgVGhyZXNob2xkIGZvciBSb3RhdGlvbiBWZWxvY2l0eS4gKi9cbiAgICBwdWJsaWMgZ2V0IHNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLnNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBPSU1PLlNldHRpbmcuc2xlZXBpbmdBbmd1bGFyVmVsb2NpdHlUaHJlc2hvbGQgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIFRocmVzaG9sZCBob3cgbG9uZyB0aGUgUmlnaWRib2R5IG11c3QgYmUgYmVsb3cvYWJvdmUgdGhlIHRocmVzaG9sZCB0byBjb3VudCBhcyBzbGVlcGluZy4gKi9cbiAgICBwdWJsaWMgZ2V0IHNsZWVwaW5nVGltZVRocmVzaG9sZCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5zbGVlcGluZ1RpbWVUaHJlc2hvbGQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc2xlZXBpbmdUaW1lVGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBPSU1PLlNldHRpbmcuc2xlZXBpbmdUaW1lVGhyZXNob2xkID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBFcnJvciB0aHJlc2hvbGQuIERlZmF1bHQgaXMgMC4wNS4gVGhlIGhpZ2hlciB0aGUgbW9yZSBsaWtlbHkgY29sbGlzaW9ucyBnZXQgZGV0ZWN0ZWQgYmVmb3JlIGFjdHVhbCBpbXBhY3QgYXQgaGlnaCBzcGVlZHMgYnV0IGl0J3MgdmlzdWFsbHkgbGVzcyBhY2N1cmF0ZS4gKi9cbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRDb2xsaXNpb25NYXJnaW4oKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEdKS01hcmdpbjtcbiAgICB9XG4gICAgcHVibGljIHNldCBkZWZhdWx0Q29sbGlzaW9uTWFyZ2luKF90aGlja25lc3M6IG51bWJlcikge1xuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRHSktNYXJnaW4gPSBfdGhpY2tuZXNzO1xuICAgIH1cblxuICAgIC8qKiBUaGUgZGVmYXVsdCBhcHBsaWVkIGZyaWN0aW9uIGJldHdlZW4gdHdvIHJpZ2lkYm9kaWVzIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuIEhvdyBtdWNoIHZlbG9jaXR5IGlzIHNsb3dlZCBkb3duIHdoZW4gbW92aW5nIGFjY3Jvc3MgdGhpcyBzdXJmYWNlLiAqL1xuICAgIHB1YmxpYyBnZXQgZGVmYXVsdEZyaWN0aW9uKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRGcmljdGlvbjtcbiAgICB9XG4gICAgcHVibGljIHNldCBkZWZhdWx0RnJpY3Rpb24oX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0RnJpY3Rpb24gPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIEJvdW5jaW5lc3Mgb2YgcmlnaWRib2RpZXMuIEhvdyBtdWNoIG9mIHRoZSBpbXBhY3QgaXMgcmVzdGl0dXRlZC4gKi9cbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRSZXN0aXR1dGlvbigpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0UmVzdGl0dXRpb247XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdFJlc3RpdHV0aW9uKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdFJlc3RpdHV0aW9uID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBHcm91cHMgdGhlIGRlZmF1bHQgcmlnaWRib2R5IHdpbGwgY29sbGlkZSB3aXRoLiBTZXQgaXQgbGlrZTogKFBIWVNJQ1NfR1JPVVAuREVGQVVMVCB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMSB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMiB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMykgXG4gICAgICogdG8gY29sbGlkZSB3aXRoIG11bHRpcGxlIGdyb3Vwcy4gRGVmYXVsdCBpcyBjb2xsaXNpb24gd2l0aCBldmVyeXRoaW5nIGJ1dCB0cmlnZ2Vycy5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENvbGxpc2lvbk1hc2soKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdENvbGxpc2lvbk1hc2s7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdENvbGxpc2lvbk1hc2soX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Q29sbGlzaW9uTWFzayA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKiogVGhlIGdyb3VwIHRoYXQgdGhpcyByaWdpZGJvZHkgYmVsb25ncyB0by4gRGVmYXVsdCBpcyB0aGUgREVGQVVMVCBHcm91cCB3aGljaCBtZWFucyBpdHMganVzdCBhIG5vcm1hbCBSaWdpZGJvZHkgbm90IGEgdHJpZ2dlciBub3IgYW55dGhpbmcgc3BlY2lhbC4gKi9cbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRDb2xsaXNpb25Hcm91cCgpOiBDT0xMSVNJT05fR1JPVVAge1xuICAgICAgcmV0dXJuIDxDT0xMSVNJT05fR1JPVVA+T0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25Hcm91cDtcbiAgICB9XG4gICAgcHVibGljIHNldCBkZWZhdWx0Q29sbGlzaW9uR3JvdXAoX3ZhbHVlOiBDT0xMSVNJT05fR1JPVVApIHtcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Q29sbGlzaW9uR3JvdXAgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIENoYW5nZSB0aGUgdHlwZSBvZiBqb2ludCBzb2x2ZXIgYWxnb3JpdGhtLiBEZWZhdWx0IEl0ZXJhdGl2ZSA9PSAwLCBpcyBmYXN0ZXIgYnV0IGxlc3Mgc3RhYmxlLiBEaXJlY3QgPT0gMSwgc2xvdyBidXQgbW9yZSBzdGFibGUsIHJlY29tbWVuZGVkIGZvciBjb21wbGV4IGpvaW50IHdvcmsuIENoYW5nZSB0aGlzIHNldHRpbmcgb25seSBhdCB0aGUgc3RhcnQgb2YgeW91ciBnYW1lLiAqL1xuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENvbnN0cmFpbnRTb2x2ZXJUeXBlKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRKb2ludENvbnN0cmFpbnRTb2x2ZXJUeXBlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGRlZmF1bHRDb25zdHJhaW50U29sdmVyVHlwZShfdmFsdWU6IG51bWJlcikge1xuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRKb2ludENvbnN0cmFpbnRTb2x2ZXJUeXBlID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBUaGUgY29ycmVjdGlvbiBhbGdvcml0aG0gdXNlZCB0byBjb3JyZWN0IHBoeXNpY3MgY2FsY3VsYXRpb25zLiBDaGFuZ2UgdGhpcyBvbmx5IGF0IHRoZSBiZWdpbm5pbmcgb2YgeW91ciBnYW1lLiBFYWNoIGhhcyBkaWZmZXJlbnQgYXBwcm9hY2hlcywgc28gaWYgeW91IGhhdmUgcHJvYmxlbXMgdGVzdCBhbm90aGVyXG4gICAgICogIERlZmF1bHQgMCA9IEJhdW1nYXJ0ZSAoZmFzdCBidXQgbGVzcyBjb3JyZWN0IGluZHVjZXMgc29tZSBlbmVyZ3kgZXJyb3JzKSwgMSA9IFNwbGl0LUltcHVsc2UgKGZhc3QgYW5kIG5vIGVuZ2VyeSBlcnJvcnMsIGJ1dCBtb3JlIGluYWNjdXJhdGUgZm9yIGpvaW50cyksIDIgPSBOb24tbGluZWFyIEdhdXNzIFNlaWRlbCAoc2xvd2VzdCBidXQgbW9zdCBhY2N1cmF0ZSkqL1xuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENvcnJlY3Rpb25BbGdvcml0aG0oKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50UG9zaXRpb25Db3JyZWN0aW9uQWxnb3JpdGhtO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGRlZmF1bHRDb3JyZWN0aW9uQWxnb3JpdGhtKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50UG9zaXRpb25Db3JyZWN0aW9uQWxnb3JpdGhtID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSBzaW11bGF0aW9uIGluIGZvcm0gb2YgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhlIHNpbXVsYXRpb25zIHJ1bnMgdGhyb3VnaCB1bnRpbCBpdCBhY2NlcHRzIHRoZSByZXN1bHQuXG4gICAgICogIDEwIERlZmF1bHQgLSBIaWdoZXIgbWVhbnMgbW9yZSBwcmVjaXNpb24gYnV0IHJlc3VsdHMgaW4gYSBwZXJmb3JtYW5jZSBkZWNyZWFzZS4gVGhpcyBoZWxwcyBlc3BlY2lhbGx5IHdpdGggam9pbnRzLFxuICAgICAqIGJ1dCBhbHNvIHRoZSBnZW5lcmFsIHN0YWJpbGl0eSBvZiB0aGUgc2ltdWxhdGlvbiBkdWUgdG8gc2ltdWxhdGlvbiBzdGVwcyBiZWluZyByZWNoZWNrZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIGJlaW5nIHNldC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNvbHZlckl0ZXJhdGlvbnMoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBQaHlzaWNzLmFjdGl2ZUluc3RhbmNlLmdldE9pbW9Xb3JsZCgpLmdldE51bVBvc2l0aW9uSXRlcmF0aW9ucygpO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNvbHZlckl0ZXJhdGlvbnMoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIFBoeXNpY3MuYWN0aXZlSW5zdGFuY2UuZ2V0T2ltb1dvcmxkKCkuc2V0TnVtUG9zaXRpb25JdGVyYXRpb25zKF92YWx1ZSk7XG4gICAgICBQaHlzaWNzLmFjdGl2ZUluc3RhbmNlLmdldE9pbW9Xb3JsZCgpLnNldE51bVZlbG9jaXR5SXRlcmF0aW9ucyhfdmFsdWUpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICAgKiBBY3RzIGFzIHRoZSBwaHlzaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28ge0BsaW5rIE5vZGV9J3MuXG4gICAgICogVGhlIHR5cGUgb2YgY29ubmNldGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBzdWJjbGFzc2VzIGxpa2UgcHJpc21hdGljIGpvaW50LCBjeWxpbmRlciBqb2ludCBldGMuXG4gICAgICogQSBSaWdpZGJvZHkgb24gdGhlIHtAbGluayBOb2RlfSB0aGF0IHRoaXMgY29tcG9uZW50IGlzIGFkZGVkIHRvIGlzIG5lZWRlZC4gU2V0dGluZyB0aGUgY29ubmVjdGVkUmlnaWRib2R5IGFuZFxuICAgICAqIGluaXRpYWxpemluZyB0aGUgY29ubmVjdGlvbiBjcmVhdGVzIGEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZW0uIFRoaXMgZGlmZmVycyBmcm9tIGEgY29ubmVjdGlvbiB0aHJvdWdoIGhpZXJhcmNoeVxuICAgICAqIGluIHRoZSBub2RlIHN0cnVjdHVyZSBvZiBmdWRnZS4gSm9pbnRzIGNhbiBoYXZlIGRpZmZlcmVudCBET0YncyAoRGVncmVlcyBPZiBGcmVlZG9tKSwgMSBBeGlzIHRoYXQgY2FuIGVpdGhlciB0d2lzdCBvciBzd2luZyBpcyBhIGRlZ3JlZSBvZiBmcmVlZG9tLlxuICAgICAqIEEgam9pbnQgdHlwaWNhbGx5IGNvbnNpc3RzIG9mIGEgbW90b3IgdGhhdCBsaW1pdHMgbW92ZW1lbnQvcm90YXRpb24gb3IgaXMgYWN0aXZseSB0cnlpbmcgdG8gbW92ZSB0byBhIGxpbWl0LiBBbmQgYSBzcHJpbmcgd2hpY2ggZGVmaW5lcyB0aGUgcmlnaWRpdHkuXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUgMjAyMFxuICAgICAqL1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgSm9pbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKiByZWZlcnMgYmFjayB0byB0aGlzIGNsYXNzIGZyb20gYW55IHN1YmNsYXNzIGUuZy4gaW4gb3JkZXIgdG8gZmluZCBjb21wYXRpYmxlIG90aGVyIHJlc291cmNlcyovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBKb2ludCA9IEpvaW50O1xuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBKb2ludFtdID0gW107XG5cbiAgICAvLyBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50Sm9pbnQpO1xuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSBmYWxzZTsgLy9NdWx0aXBsZSBqb2ludHMgY2FuIGJlIGF0dGFjaGVkIHRvIG9uZSBOb2RlXG5cbiAgICAjaWRCb2R5QW5jaG9yOiBudW1iZXIgPSAwO1xuICAgICNpZEJvZHlUaWVkOiBudW1iZXIgPSAwO1xuICAgICNib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHk7XG4gICAgI2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHk7XG5cbiAgICAjY29ubmVjdGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgI2FuY2hvcjogT0lNTy5WZWMzO1xuICAgICNpbnRlcm5hbENvbGxpc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgI2JyZWFrRm9yY2U6IG51bWJlciA9IDA7XG4gICAgI2JyZWFrVG9ycXVlOiBudW1iZXIgPSAwO1xuXG4gICAgI25hbWVDaGlsZFRvQ29ubmVjdDogc3RyaW5nO1xuXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGpvaW50OiBPSU1PLkpvaW50O1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjb25maWc6IE9JTU8uSm9pbnRDb25maWc7XG5cbiAgICAvKiogQ3JlYXRlIGEgam9pbnQgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gUmlnaWRib2R5Q29tcG9uZW50cy4gKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuYm9keUFuY2hvciA9IF9ib2R5QW5jaG9yO1xuICAgICAgdGhpcy5ib2R5VGllZCA9IF9ib2R5VGllZDtcblxuICAgICAgLypcbiAgICAgICAgVGVsbCB0aGUgcGh5c2ljcyB0aGF0IHRoZXJlIGlzIGEgbmV3IGpvaW50IGFuZCBvbiB0aGUgcGh5c2ljcyBzdGFydCB0aGUgYWN0dWFsIGpvaW50IGlzIGZpcnN0IGNyZWF0ZWQuIFZhbHVlcyBjYW4gYmUgc2V0IGJ1dCB0aGVcbiAgICAgICAgYWN0dWFsIGNvbnN0cmFpbnQgYWluJ3QgZXhpc3RlbnQgdW50aWwgdGhlIGdhbWUgc3RhcnRzXG4gICAgICAqL1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kRXZlbnQpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaG5kRXZlbnQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBKb2ludCk6IG51bWJlciB7IHJldHVybiBKb2ludC5zdWJjbGFzc2VzLnB1c2goX3N1YmNsYXNzKSAtIDE7IH1cblxuICAgIC8qKiBHZXQvU2V0IHRoZSBmaXJzdCBDb21wb25lbnRSaWdpZGJvZHkgb2YgdGhpcyBjb25uZWN0aW9uLiBJdCBzaG91bGQgYWx3YXlzIGJlIHRoZSBvbmUgdGhhdCB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0b28gaW4gdGhlIHNjZW5lVHJlZS4gKi9cbiAgICBwdWJsaWMgZ2V0IGJvZHlBbmNob3IoKTogQ29tcG9uZW50UmlnaWRib2R5IHtcbiAgICAgIHJldHVybiB0aGlzLiNib2R5QW5jaG9yO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgYm9keUFuY2hvcihfY21wUkI6IENvbXBvbmVudFJpZ2lkYm9keSkge1xuICAgICAgdGhpcy4jaWRCb2R5QW5jaG9yID0gX2NtcFJCICE9IG51bGwgPyBfY21wUkIuaWQgOiAtMTtcbiAgICAgIHRoaXMuI2JvZHlBbmNob3IgPSBfY21wUkI7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcbiAgICB9XG5cbiAgICAvKiogR2V0L1NldCB0aGUgc2Vjb25kIENvbXBvbmVudFJpZ2lkYm9keSBvZiB0aGlzIGNvbm5lY3Rpb24uICovXG4gICAgcHVibGljIGdldCBib2R5VGllZCgpOiBDb21wb25lbnRSaWdpZGJvZHkge1xuICAgICAgcmV0dXJuIHRoaXMuI2JvZHlUaWVkO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGJvZHlUaWVkKF9jbXBSQjogQ29tcG9uZW50UmlnaWRib2R5KSB7XG4gICAgICB0aGlzLiNpZEJvZHlUaWVkID0gX2NtcFJCICE9IG51bGwgPyBfY21wUkIuaWQgOiAtMTtcbiAgICAgIHRoaXMuI2JvZHlUaWVkID0gX2NtcFJCO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4YWN0IHBvc2l0aW9uIHdoZXJlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBhcmUgY29ubmVjdGVkLiBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYW5jaG9yKCk6IFZlY3RvcjMge1xuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2FuY2hvci54LCB0aGlzLiNhbmNob3IueSwgdGhpcy4jYW5jaG9yLnopO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGFuY2hvcihfdmFsdWU6IFZlY3RvcjMpIHtcbiAgICAgIHRoaXMuI2FuY2hvciA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIGZvcmNlIG5lZWRlZCB0byBicmVhayB0aGUgSk9JTlQsIHdoaWxlIHJvdGF0aW5nLCBpbiBOZXd0b24uIDAgZXF1YWxzIHVuYnJlYWthYmxlIChkZWZhdWx0KSBcbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgYnJlYWtUb3JxdWUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNicmVha1RvcnF1ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBicmVha1RvcnF1ZShfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jYnJlYWtUb3JxdWUgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LnNldEJyZWFrVG9ycXVlKHRoaXMuI2JyZWFrVG9ycXVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW1vdW50IG9mIGZvcmNlIG5lZWRlZCB0byBicmVhayB0aGUgSk9JTlQsIGluIE5ld3Rvbi4gMCBlcXVhbHMgdW5icmVha2FibGUgKGRlZmF1bHQpIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYnJlYWtGb3JjZSgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI2JyZWFrRm9yY2U7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgYnJlYWtGb3JjZShfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jYnJlYWtGb3JjZSA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QnJlYWtGb3JjZSh0aGlzLiNicmVha0ZvcmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogSWYgdGhlIHR3byBjb25uZWN0ZWQgUmlnaWRCb2RpZXMgY29sbGlkZSB3aXRoIGVhdGggb3RoZXIuIChEZWZhdWx0ID0gZmFsc2UpXG4gICAgICAqIE9uIGEgd2VsZGluZyBqb2ludCB0aGUgY29ubmVjdGVkIGJvZGllcyBzaG91bGQgbm90IGJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAqIGZvciBiZXN0IHJlc3VsdHNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGludGVybmFsQ29sbGlzaW9uKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29sbGlzaW9uO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGludGVybmFsQ29sbGlzaW9uKF92YWx1ZTogYm9vbGVhbikge1xuICAgICAgdGhpcy4jaW50ZXJuYWxDb2xsaXNpb24gPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LnNldEFsbG93Q29sbGlzaW9uKHRoaXMuI2ludGVybmFsQ29sbGlzaW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IGEgY2hpbGQgbm9kZSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBqb2ludC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29ubmVjdENoaWxkKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIHRoaXMuI25hbWVDaGlsZFRvQ29ubmVjdCA9IF9uYW1lO1xuICAgICAgaWYgKCF0aGlzLm5vZGUpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgbGV0IGNoaWxkcmVuOiBOb2RlW10gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRyZW5CeU5hbWUoX25hbWUpO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PSAxKVxuICAgICAgICB0aGlzLmNvbm5lY3ROb2RlKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGF0ICR7dGhpcy5ub2RlLm5hbWV9IGZhaWxzIHRvIGNvbm5lY3QgY2hpbGQgd2l0aCBub24gZXhpc3RlbnQgb3IgYW1iaWdvdXMgbmFtZSAke19uYW1lfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdGhlIGdpdmVuIG5vZGUgdG8gdGhlIGpvaW50LiBUaWVpbmcgaXRzIHJpZ2lkYm9keSB0byB0aGUgbm9kZXMgcmlnaWRib2R5IHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25uZWN0Tm9kZShfbm9kZTogTm9kZSk6IHZvaWQge1xuICAgICAgaWYgKCFfbm9kZSB8fCAhdGhpcy5ub2RlKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIERlYnVnLmZ1ZGdlKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY29ubmVjdGVkICR7dGhpcy5ub2RlLm5hbWV9IGFuZCAke19ub2RlLm5hbWV9YCk7XG5cbiAgICAgIGxldCBjb25uZWN0Qm9keTogQ29tcG9uZW50UmlnaWRib2R5ID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSk7XG4gICAgICBsZXQgdGhpc0JvZHk6IENvbXBvbmVudFJpZ2lkYm9keSA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KTtcblxuICAgICAgaWYgKCFjb25uZWN0Qm9keSB8fCAhdGhpc0JvZHkpIHtcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGF0ICR7dGhpcy5ub2RlLm5hbWV9IGZhaWxzIGR1ZSB0byBtaXNzaW5nIHJpZ2lkYm9kaWVzIG9uICR7dGhpcy5ub2RlLm5hbWV9IG9yICR7X25vZGUubmFtZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvZHlBbmNob3IgPSB0aGlzQm9keTtcbiAgICAgIHRoaXMuYm9keVRpZWQgPSBjb25uZWN0Qm9keTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2sgaWYgY29ubmVjdGlvbiBpcyBkaXJ0eSwgc28gd2hlbiBlaXRoZXIgcmIgaXMgY2hhbmdlZCBkaXNjb25uZWN0IGFuZCByZWNvbm5lY3QuIEludGVybmFsbHkgdXNlZCBubyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC4gKi9cbiAgICBwdWJsaWMgaXNDb25uZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpcy4jY29ubmVjdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemluZyBhbmQgY29ubmVjdGluZyB0aGUgdHdvIHJpZ2lkYm9kaWVzIHdpdGggdGhlIGNvbmZpZ3VyZWQgam9pbnQgcHJvcGVydGllc1xuICAgICAqIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHRoZSBwaHlzaWNzIHN5c3RlbS4gTm8gdXNlciBpbnRlcmFjdGlvbiBuZWVkZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbm5lY3QoKTogdm9pZCB7XG4gICAgICBpZiAodGhpcy4jY29ubmVjdGVkID09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLiNpZEJvZHlBbmNob3IgPT0gLTEgfHwgdGhpcy4jaWRCb2R5VGllZCA9PSAtMSkge1xuICAgICAgICAgIGlmICh0aGlzLiNuYW1lQ2hpbGRUb0Nvbm5lY3QpXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RDaGlsZCh0aGlzLiNuYW1lQ2hpbGRUb0Nvbm5lY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uc3RydWN0Sm9pbnQoKTtcbiAgICAgICAgdGhpcy4jY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRKb2ludCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RpbmcgdGhlIHR3byByaWdpZGJvZGllcyBhbmQgcmVtb3ZpbmcgdGhlbSBmcm9tIHRoZSBwaHlzaWNzIHN5c3RlbSxcbiAgICAgKiBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBkaXNjb25uZWN0KCk6IHZvaWQge1xuICAgICAgaWYgKHRoaXMuI2Nvbm5lY3RlZCA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSm9pbnQoKTtcbiAgICAgICAgdGhpcy4jY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgSm9pbnQgdXNlZCBieSB0aGUgcGh5c2ljcyBlbmdpbmUuIFVzZWQgaW50ZXJuYWxseSBubyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC5cbiAgICAgKiBPbmx5IHRvIGJlIHVzZWQgd2hlbiBmdW5jdGlvbmFsaXR5IHRoYXQgaXMgbm90IGFkZGVkIHdpdGhpbiBGVURHRSBpcyBuZWVkZWQuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0T2ltb0pvaW50KCk6IE9JTU8uSm9pbnQge1xuICAgICAgcmV0dXJuIHRoaXMuam9pbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xuICAgICAgc2VyaWFsaXphdGlvbi5hbmNob3IgPSB0aGlzLmFuY2hvci5zZXJpYWxpemUoKTtcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICB0aGlzLmFuY2hvciA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYW5jaG9yKTtcbiAgICAgIHRoaXMuI211dGF0ZShfc2VyaWFsaXphdGlvbik7XG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XG4gICAgICB0aGlzLmNvbm5lY3RDaGlsZChfc2VyaWFsaXphdGlvbi5uYW1lQ2hpbGRUb0Nvbm5lY3QpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICBtdXRhdG9yLmFuY2hvciA9IHRoaXMuYW5jaG9yLmdldE11dGF0b3IoKTtcbiAgICAgIHJldHVybiBtdXRhdG9yO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLmFuY2hvcikgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMuYW5jaG9yID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmFuY2hvcikpKTtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5hbmNob3I7XG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5uYW1lQ2hpbGRUb0Nvbm5lY3QpICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aGlzLmNvbm5lY3RDaGlsZChfbXV0YXRvci5uYW1lQ2hpbGRUb0Nvbm5lY3QpO1xuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xuICAgIH1cblxuXG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNwcmluZ0RhbXBlcjtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5qb2ludDtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tb3RvcjtcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xuICAgIH1cblxuICAgIC8qKiBUZWxsIHRoZSBGdWRnZVBoeXNpY3Mgc3lzdGVtIHRoYXQgdGhpcyBqb2ludCBuZWVkcyB0byBiZSBoYW5kbGVkIGluIHRoZSBuZXh0IGZyYW1lLiAqL1xuICAgIHByb3RlY3RlZCBkaXJ0eVN0YXR1cygpOiB2b2lkIHtcbiAgICAgIFBoeXNpY3MuY2hhbmdlSm9pbnRTdGF0dXModGhpcyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZEpvaW50KCk6IHZvaWQge1xuICAgICAgUGh5c2ljcy5hZGRKb2ludCh0aGlzKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVtb3ZlSm9pbnQoKTogdm9pZCB7XG4gICAgICBQaHlzaWNzLnJlbW92ZUpvaW50KHRoaXMpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCguLi5fY29uZmlnUGFyYW1zOiBPYmplY3RbXSk6IHZvaWQge1xuICAgICAgbGV0IHBvc0JvZHlBbmNob3I6IFZlY3RvcjMgPSB0aGlzLmJvZHlBbmNob3Iubm9kZS5tdHhXb3JsZC50cmFuc2xhdGlvbjsgLy9TZXR0aW5nIHRoZSBhbmNob3IgcG9zaXRpb24gbG9jYWxseSBmcm9tIHRoZSBmaXJzdCByaWdpZGJvZHlcbiAgICAgIGxldCB3b3JsZEFuY2hvcjogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyhwb3NCb2R5QW5jaG9yLnggKyB0aGlzLiNhbmNob3IueCwgcG9zQm9keUFuY2hvci55ICsgdGhpcy4jYW5jaG9yLnksIHBvc0JvZHlBbmNob3IueiArIHRoaXMuI2FuY2hvci56KTtcblxuICAgICAgLy8gQHRzLWlnbm9yZSAgICAvLyB1bmZvcnR1bmF0ZWx5LCBtZXRob2QgaW5pdCBpcyBub3QgYSBtZW1iZXIgb2YgdGhlIGJhc2UgY2xhc3MgT0lNTy5Kb2ludENvbmZpZ1xuICAgICAgdGhpcy5jb25maWcuaW5pdCh0aGlzLiNib2R5QW5jaG9yLmdldE9pbW9SaWdpZGJvZHkoKSwgdGhpcy4jYm9keVRpZWQuZ2V0T2ltb1JpZ2lkYm9keSgpLCB3b3JsZEFuY2hvciwgLi4uX2NvbmZpZ1BhcmFtcyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNvbmZpZ3VyZUpvaW50KCk6IHZvaWQge1xuICAgICAgdGhpcy5qb2ludC5zZXRCcmVha0ZvcmNlKHRoaXMuYnJlYWtGb3JjZSk7XG4gICAgICB0aGlzLmpvaW50LnNldEJyZWFrVG9ycXVlKHRoaXMuYnJlYWtUb3JxdWUpO1xuICAgICAgdGhpcy5qb2ludC5zZXRBbGxvd0NvbGxpc2lvbih0aGlzLiNpbnRlcm5hbENvbGxpc2lvbik7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yLCBfZGVsZXRlOiBNdXRhdG9yKTogdm9pZCB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gX2RlbGV0ZSlcbiAgICAgICAgZGVsZXRlIF9tdXRhdG9yW2tleV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBobmRFdmVudCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICBzd2l0Y2ggKF9ldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgRVZFTlQuQ09NUE9ORU5UX0FERDpcbiAgICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5ESVNDT05ORUNUX0pPSU5ULCAoKSA9PiB7IHRoaXMuZGlzY29ubmVjdCgpOyB0aGlzLmRpcnR5U3RhdHVzKCk7IH0sIHRydWUpO1xuICAgICAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfUkVNT1ZFOlxuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkRJU0NPTk5FQ1RfSk9JTlQsICgpID0+IHsgdGhpcy5kaXNjb25uZWN0KCk7IHRoaXMuZGlydHlTdGF0dXMoKTsgfSwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVKb2ludCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xuICAgICAgICBuYW1lQ2hpbGRUb0Nvbm5lY3Q6IHRoaXMuI25hbWVDaGlsZFRvQ29ubmVjdCxcbiAgICAgICAgaW50ZXJuYWxDb2xsaXNpb246IHRoaXMuI2ludGVybmFsQ29sbGlzaW9uLFxuICAgICAgICBicmVha0ZvcmNlOiB0aGlzLiNicmVha0ZvcmNlLFxuICAgICAgICBicmVha1RvcnF1ZTogdGhpcy4jYnJlYWtUb3JxdWVcbiAgICAgIH07XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9O1xuXG4gICAgI211dGF0ZSA9IChfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJpbnRlcm5hbENvbGxpc2lvblwiLCBcImJyZWFrRm9yY2VcIiwgXCJicmVha1RvcnF1ZVwiXSk7XG4gICAgfTtcbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBqb2ludHMgb3BlcmF0aW5nIHdpdGggZXhhY3RseSBvbmUgYXhpc1xuICAgICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICovXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBKb2ludEF4aWFsIGV4dGVuZHMgSm9pbnQge1xuICAgIHByb3RlY3RlZCBzcHJpbmdEYW1wZXI6IE9JTU8uU3ByaW5nRGFtcGVyO1xuICAgIFxuICAgIC8vSW50ZXJuYWwgVmFyaWFibGVzXG4gICAgI21heE1vdG9yOiBudW1iZXIgPSAxMDtcbiAgICAjbWluTW90b3I6IG51bWJlciA9IC0xMDtcbiAgICAjbW90b3JTcGVlZDogbnVtYmVyID0gMDtcbiAgICAjYXhpczogT0lNTy5WZWMzO1xuICAgICNzcHJpbmdGcmVxdWVuY3k6IG51bWJlciA9IDA7XG4gICAgI3NwcmluZ0RhbXBpbmc6IG51bWJlciA9IDA7XG5cbiAgICAvKiogQ3JlYXRpbmcgYSBjeWxpbmRyaWNhbCBqb2ludCBiZXR3ZWVuIHR3byBDb21wb25lbnRSaWdpZGJvZGllcyBtb3Zpbmcgb24gb25lIGF4aXMgYW5kIHJvdGF0aW5nIGFyb3VuZCBhbm90aGVyIGJvdW5kIG9uIGEgbG9jYWwgYW5jaG9ycG9pbnQuICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcbiAgICAgIHRoaXMuYXhpcyA9IF9heGlzO1xuICAgICAgdGhpcy5hbmNob3IgPSBfbG9jYWxBbmNob3I7XG4gICAgICB0aGlzLm1pbk1vdG9yID0gLTEwO1xuICAgICAgdGhpcy5tYXhNb3RvciA9IDEwO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXG4gICAgLyoqXG4gICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxuICAgICAqICBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYXhpcygpOiBWZWN0b3IzIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzLngsIHRoaXMuI2F4aXMueSwgdGhpcy4jYXhpcy56KTtcbiAgICB9XG4gICAgcHVibGljIHNldCBheGlzKF92YWx1ZTogVmVjdG9yMykge1xuICAgICAgdGhpcy4jYXhpcyA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4TW90b3IoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNtYXhNb3RvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IG1heE1vdG9yKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNtYXhNb3RvciA9IF92YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD48dW5rbm93bj50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5Nb3RvcigpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21pbk1vdG9yO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1pbk1vdG9yKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNtaW5Nb3RvciA9IF92YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD48dW5rbm93bj50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3ByaW5nRGFtcGluZygpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmc7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRGFtcGluZyhfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZyA9IF92YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD48dW5rbm93bj50aGlzLmpvaW50KS5nZXRTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikgeyAvKiAqLyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFRoZSB0YXJnZXQgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1vdG9yU3BlZWQoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclNwZWVkO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgbW90b3JTcGVlZChfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jbW90b3JTcGVlZCA9IF92YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeSgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeTtcbiAgICB9XG4gICAgcHVibGljIHNldCBzcHJpbmdGcmVxdWVuY3koX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeSA9IF92YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD50aGlzLmpvaW50KS5nZXRTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikgeyAvKiAqLyB9XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xuICAgICAgc2VyaWFsaXphdGlvbi5heGlzID0gdGhpcy5heGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIHRoaXMuYXhpcyA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpcyk7XG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpcykgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMuYXhpcyA9IG5ldyBWZWN0b3IzKC4uLjxudW1iZXJbXT4oT2JqZWN0LnZhbHVlcyhfbXV0YXRvci5heGlzKSkpO1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLmF4aXM7XG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xuICAgICAgdGhpcy5kZWxldGVGcm9tTXV0YXRvcihfbXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcbiAgICAgIG11dGF0b3IuYXhpcyA9IHRoaXMuYXhpcy5nZXRNdXRhdG9yKCk7XG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG5cbiAgICAvLyNlbmRyZWdpb25cbiAgICBcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XG4gICAgICB0aGlzLnNwcmluZ0RhbXBlciA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLiNzcHJpbmdGcmVxdWVuY3ksIHRoaXMuI3NwcmluZ0RhbXBpbmcpO1xuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy4jYXhpcyk7XG4gICAgfVxuXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcbiAgICAgICAgc3ByaW5nRGFtcGluZzogdGhpcy4jc3ByaW5nRGFtcGluZyxcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5OiB0aGlzLiNzcHJpbmdGcmVxdWVuY3ksXG4gICAgICAgIG1heE1vdG9yOiB0aGlzLiNtYXhNb3RvcixcbiAgICAgICAgbWluTW90b3I6IHRoaXMuI21pbk1vdG9yLFxuICAgICAgICBtb3RvclNwZWVkOiB0aGlzLiNtb3RvclNwZWVkXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfTtcblxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcbiAgICAgIHRoaXMubXV0YXRlQmFzZShfbXV0YXRvciwgW1wic3ByaW5nRGFtcGluZ1wiLCBcInNwcmluZ0ZyZXF1ZW5jeVwiLCBcIm1heE1vdG9yXCIsIFwibWluTW90b3JcIiwgXCJtb3RvclNwZWVkXCJdKTtcbiAgICB9O1xuICB9XG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnL0RlYnVnVGFyZ2V0LnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnL0RlYnVnLnRzXCIvPlxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJUaW1lL1RpbWUudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRXZlbnQvRXZlbnQudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2VyaWFsaXphdGlvbi9NdXRhYmxlLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNlcmlhbGl6YXRpb24vU2VyaWFsaXplci50c1wiLz4gXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiR3JhcGgvTm9kZS50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb21wb25lbnQvQ29tcG9uZW50LnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlY3ljbGUvUmVjeWNhYmxlQXJyYXkudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyL1JlbmRlcldlYkdMLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJJbmplY3RvclRleHR1cmUudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGh5c2ljcy9IZWxwZXJzUGh5c2ljcy50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQaHlzaWNzL0pvaW50LnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBoeXNpY3MvSm9pbnRBeGlhbC50c1wiLz5cblxuXG4vL2dsb2JhbCBmdW5jdGlvbnNcbmZ1bmN0aW9uIGlmTnVtYmVyKF9jaGVjazogbnVtYmVyLCBfZGVmYXVsdDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHR5cGVvZiBfY2hlY2sgPT0gXCJ1bmRlZmluZWRcIiA/IF9kZWZhdWx0IDogX2NoZWNrO1xufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEFuaW1hdGlvblN0cnVjdHVyZSB0aGF0IHRoZSBBbmltYXRpb24gdXNlcyB0byBtYXAgdGhlIFNlcXVlbmNlcyB0byB0aGUgQXR0cmlidXRlcy5cbiAgICogQnVpbHQgb3V0IG9mIGEge0BsaW5rIE5vZGV9J3Mgc2VyaWFsc2F0aW9uLCBpdCBzd2FwcyB0aGUgdmFsdWVzIHdpdGgge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlfXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblN0cnVjdHVyZSB7XG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogQW5pbWF0aW9uU3RydWN0dXJlW10gfCBBbmltYXRpb25TdHJ1Y3R1cmUgfCBBbmltYXRpb25TZXF1ZW5jZTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IzIGV4dGVuZHMgQW5pbWF0aW9uU3RydWN0dXJlIHtcbiAgICB4PzogQW5pbWF0aW9uU2VxdWVuY2U7XG4gICAgeT86IEFuaW1hdGlvblNlcXVlbmNlO1xuICAgIHo/OiBBbmltYXRpb25TZXF1ZW5jZTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3I0IGV4dGVuZHMgQW5pbWF0aW9uU3RydWN0dXJlIHtcbiAgICB4PzogQW5pbWF0aW9uU2VxdWVuY2U7XG4gICAgeT86IEFuaW1hdGlvblNlcXVlbmNlO1xuICAgIHo/OiBBbmltYXRpb25TZXF1ZW5jZTtcbiAgICB3PzogQW5pbWF0aW9uU2VxdWVuY2U7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblNlcXVlbmNlTWF0cml4NHg0IGV4dGVuZHMgQW5pbWF0aW9uU3RydWN0dXJlIHtcbiAgICByb3RhdGlvbj86IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMyB8IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yNDtcbiAgICBzY2FsZT86IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMztcbiAgICB0cmFuc2xhdGlvbj86IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMztcbiAgfVxuXG4gIC8qKlxuICAqIEFuIGFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcgbmFtZXMgb2YgbGFibGVzIHRvIHRpbWVzdGFtcHMuXG4gICogTGFiZWxzIG5lZWQgdG8gYmUgdW5pcXVlIHBlciBBbmltYXRpb24uXG4gICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxuICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkxhYmVsIHtcbiAgICBbbmFtZTogc3RyaW5nXTogbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgQW5pbWF0aW9uIEV2ZW50IFRyaWdnZXJzXG4gICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxuICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XG4gICAgW25hbWU6IHN0cmluZ106IG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbGx5IHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB2YXJpb3VzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzIGFuZCBldmVudHMuXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcbiAgICovXG4gIGVudW0gQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFIHtcbiAgICAvKipEZWZhdWx0OiBmb3J3YXJkLCBjb250aW5vdXMgKi9cbiAgICBOT1JNQUwsXG4gICAgLyoqYmFja3dhcmQsIGNvbnRpbm91cyAqL1xuICAgIFJFVkVSU0UsXG4gICAgLyoqZm9yd2FyZCwgcmFzdGVyZWQgKi9cbiAgICBSQVNURVJFRCxcbiAgICAvKipiYWNrd2FyZCwgcmFzdGVyZWQgKi9cbiAgICBSQVNURVJFRFJFVkVSU0VcbiAgfVxuXG4gIC8qKlxuICAgKiBIb2xkcyBkaWZmZXJlbnQgcGxheW1vZGVzIHRoZSBhbmltYXRpb24gdXNlcyB0byBwbGF5IGJhY2sgaXRzIGFuaW1hdGlvbi5cbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxuICAgKi9cbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX1BMQVlNT0RFIHtcbiAgICAvKipQbGF5cyBhbmltYXRpb24gaW4gYSBsb29wOiBpdCByZXN0YXJ0cyBvbmNlIGl0IGhpdCB0aGUgZW5kLiovXG4gICAgTE9PUCA9IFwibG9vcFwiLFxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBvbmNlIGFuZCBzdG9wcyBhdCB0aGUgbGFzdCBrZXkvZnJhbWUqL1xuICAgIFBMQVlfT05DRSA9IFwicGxheU9uY2VcIixcbiAgICAvKipQbGF5cyBhbmltYXRpb24gb25jZSBhbmQgc3RvcHMgb24gdGhlIGZpcnN0IGtleS9mcmFtZSAqL1xuICAgIFBMQVlfT05DRV9SRVNFVCA9IFwicGxheU9uY2VSZXNldFwiLFxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBsaWtlIExPT1AsIGJ1dCBiYWNrd2FyZHMuKi9cbiAgICBSRVZFUlNFX0xPT1AgPSBcInJldmVyc2VMb29wXCIsXG4gICAgLyoqQ2F1c2VzIHRoZSBhbmltYXRpb24gbm90IHRvIHBsYXkgYXQgYWxsLiBVc2VmdWwgZm9yIGp1bXBpbmcgdG8gdmFyaW91cyBwb3NpdGlvbnMgaW4gdGhlIGFuaW1hdGlvbiB3aXRob3V0IHByb2NlZWRpbmcgaW4gdGhlIGFuaW1hdGlvbi4qL1xuICAgIFNUT1AgPSBcInN0b3BcIlxuICAgIC8vVE9ETzogYWRkIGFuIElOSEVSSVQgYW5kIGEgUElOR1BPTkcgbW9kZVxuICB9XG5cbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX1FVQU5USVpBVElPTiB7XG4gICAgLy9UT0RPOiBhZGQgYW4gaW4tZGVwdGggZGVzY3JpcHRpb24gb2Ygd2hhdCBoYXBwZW5zIHRvIHRoZSBhbmltYXRpb24gKGFuZCBldmVudHMpIGRlcGVuZGluZyBvbiB0aGUgcXVhbnRpemF0aW9uLiBVc2UgR3JhcGhzIHRvIGV4cGxhaW4uXG4gICAgLyoqQ2FsY3VsYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGFuaW1hdGlvbiBhdCB0aGUgZXhhY3QgcG9zaXRpb24gb2YgdGltZS4gSWdub3JlcyBGUFMgdmFsdWUgb2YgYW5pbWF0aW9uLiovXG4gICAgQ09OVElOT1VTID0gXCJjb250aW5vdXNcIixcbiAgICAvKipMaW1pdHMgdGhlIGNhbGN1bGF0aW9uIG9mIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHRoZSBGUFMgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbi4gU2tpcHMgZnJhbWVzIGlmIG5lZWRlZC4qL1xuICAgIERJU0NSRVRFID0gXCJkaXNjcmV0ZVwiLFxuICAgIC8qKiBBZHZhbmNlcyB0aGUgdGltZSBlYWNoIGZyYW1lIGFjY29yZGluZyB0byB0aGUgRlBTIHZhbHVlIG9mIHRoZSBhbmltYXRpb24sIGlnbm9yaW5nIHRoZSBhY3R1YWwgZHVyYXRpb24gb2YgdGhlIGZyYW1lcy4gRG9lc24ndCBza2lwIGFueSBmcmFtZXMuKi9cbiAgICBGUkFNRVMgPSBcImZyYW1lc1wiXG4gIH1cblxuICAvKipcbiAgICogRGVzY3JpYmVzIGFuZCBjb250cm9scyBhbmQgYW5pbWF0aW9uIGJ5IHlpZWxkaW5nIG11dGF0b3JzIFxuICAgKiBhY2NvcmRpbmcgdG8gdGhlIHN0b3JlZCB7QGxpbmsgQW5pbWF0aW9uU3RydWN0dXJlfSBhbmQge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlfXNcbiAgICogQXBwbGllZCB0byBhIHtAbGluayBOb2RlfSBkaXJlY3RseSB2aWEgc2NyaXB0IG9yIHtAbGluayBDb21wb25lbnRBbmltYXRvcn0uXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIxMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyM1xuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbiBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XG4gICAgLy8gLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cbiAgICAvLyBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGJhc2VDbGFzczogdHlwZW9mIEFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcbiAgICAvLyAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgQW5pbWF0aW9uW10gPSBbXTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQW5pbWF0aW9uLnJlZ2lzdGVyU3ViY2xhc3MoQW5pbWF0aW9uKTtcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XG4gICAgcHVibGljIHRvdGFsVGltZTogbnVtYmVyID0gMDtcbiAgICBwdWJsaWMgbGFiZWxzOiBBbmltYXRpb25MYWJlbCA9IHt9OyAvLyBhIGxhYmVsIG1hcmtzIGEgc3BlY2lmaWMgdGltZSB0byBjb252ZW5pZW50bHkganVtcCB0byB1c2luZyBhIHRleHQgaWRlbnRpZmllclxuICAgIC8vIHN0ZXBzUGVyU2Vjb25kOiBudW1iZXIgPSAxMDtcbiAgICBwdWJsaWMgYW5pbWF0aW9uU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmU7XG4gICAgcHVibGljIGV2ZW50czogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XG4gICAgcHJvdGVjdGVkIGZyYW1lc1BlclNlY29uZDogbnVtYmVyID0gNjA7IC8vIFRPRE86IGNoYW5nZSB0aGlzIGFuZCBpdHMgYWNjZXNzb3JzIHRvICNmcmFtZXNQZXJTZWNvbmQ/XG5cbiAgICAvLyBwcm9jZXNzZWQgZXZlbnRsaXN0IGFuZCBhbmltYXRpb24gc3RydWN1dHJlcyBmb3IgcGxheWJhY2suXG4gICAgcHJpdmF0ZSBldmVudHNQcm9jZXNzZWQ6IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4gPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPigpO1xuICAgICNhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkOiBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+ID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvblN0cnVjdHVyZT4oKTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gQW5pbWF0aW9uLm5hbWUsIF9hbmltU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fSwgX2ZwczogbnVtYmVyID0gNjApIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlID0gX2FuaW1TdHJ1Y3R1cmU7XG4gICAgICB0aGlzLiNhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLnNldChBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMLCBfYW5pbVN0cnVjdHVyZSk7XG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcHM7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YkNsYXNzOiB0eXBlb2YgQW5pbWF0aW9uKTogbnVtYmVyIHsgcmV0dXJuIEFuaW1hdGlvbi5zdWJjbGFzc2VzLnB1c2goX3N1YkNsYXNzKSAtIDE7IH1cblxuICAgIHB1YmxpYyBnZXQgZ2V0TGFiZWxzKCk6IEVudW1lcmF0b3Ige1xuICAgICAgLy9UT0RPOiB0aGlzIGFjdHVhbGx5IG5lZWRzIHRlc3RpbmdcbiAgICAgIGxldCBlbjogRW51bWVyYXRvciA9IG5ldyBFbnVtZXJhdG9yKHRoaXMubGFiZWxzKTtcbiAgICAgIHJldHVybiBlbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZwcygpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZnBzKF9mcHM6IG51bWJlcikge1xuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfZnBzO1xuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoaXMgYW5pbWF0aW9ucyBjYWNoZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJDYWNoZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMuI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgTXV0YXRvcn0gd2l0aCB0aGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgdG8gdGhlIHtAbGluayBOb2RlfSB0byBhbmltYXRlXG4gICAgICogaW4gdGhlIHN0YXRlIHRoZSBhbmltYXRpb24gaXMgaW4gYXQgdGhlIGdpdmVuIHRpbWUsIGRpcmVjdGlvbiBhbmQgcXVhbnRpemF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGdldFN0YXRlKF90aW1lOiBudW1iZXIsIF9kaXJlY3Rpb246IG51bWJlciwgX3F1YW50aXphdGlvbjogQU5JTUFUSU9OX1FVQU5USVpBVElPTik6IE11dGF0b3Ige1xuICAgICAgbGV0IG06IE11dGF0b3IgPSB7fTtcbiAgICAgIGxldCBhbmltYXRpb25TdHJ1Y3R1cmU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRTtcblxuICAgICAgaWYgKF9xdWFudGl6YXRpb24gPT0gQU5JTUFUSU9OX1FVQU5USVpBVElPTi5DT05USU5PVVMpXG4gICAgICAgIGFuaW1hdGlvblN0cnVjdHVyZSA9IF9kaXJlY3Rpb24gPCAwID8gQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UgOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMO1xuICAgICAgZWxzZVxuICAgICAgICBhbmltYXRpb25TdHJ1Y3R1cmUgPSBfZGlyZWN0aW9uIDwgMCA/IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UgOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQ7XG5cbiAgICAgIG0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcih0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShhbmltYXRpb25TdHJ1Y3R1cmUpLCBfdGltZSk7XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgbmFtZXMgb2YgdGhlIGV2ZW50cyB0aGUge0BsaW5rIENvbXBvbmVudEFuaW1hdG9yfSBuZWVkcyB0byBmaXJlIGJldHdlZW4gX21pbiBhbmQgX21heCBpbnB1dCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIGlzIHN1cHBvc2VkIHRvIHJ1biBpbi4gPjAgPT0gZm9yd2FyZCwgMCA9PSBzdG9wLCA8MCA9PSBiYWNrd2FyZHNcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB3aXRoIHRoZSBuYW1lcyBvZiB0aGUgY3VzdG9tIGV2ZW50cyB0byBmaXJlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFdmVudHNUb0ZpcmUoX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIsIF9xdWFudGl6YXRpb246IEFOSU1BVElPTl9RVUFOVElaQVRJT04sIF9kaXJlY3Rpb246IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgICAgIGxldCBldmVudExpc3Q6IHN0cmluZ1tdID0gW107XG4gICAgICBsZXQgbWluU2VjdGlvbjogbnVtYmVyID0gTWF0aC5mbG9vcihfbWluIC8gdGhpcy50b3RhbFRpbWUpO1xuICAgICAgbGV0IG1heFNlY3Rpb246IG51bWJlciA9IE1hdGguZmxvb3IoX21heCAvIHRoaXMudG90YWxUaW1lKTtcbiAgICAgIF9taW4gPSBfbWluICUgdGhpcy50b3RhbFRpbWU7XG4gICAgICBfbWF4ID0gX21heCAlIHRoaXMudG90YWxUaW1lO1xuXG4gICAgICB3aGlsZSAobWluU2VjdGlvbiA8PSBtYXhTZWN0aW9uKSB7XG4gICAgICAgIGxldCBldmVudFRyaWdnZXJzOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB0aGlzLmdldENvcnJlY3RFdmVudExpc3QoX2RpcmVjdGlvbiwgX3F1YW50aXphdGlvbik7XG4gICAgICAgIGlmIChtaW5TZWN0aW9uID09IG1heFNlY3Rpb24pIHtcbiAgICAgICAgICBldmVudExpc3QgPSBldmVudExpc3QuY29uY2F0KHRoaXMuY2hlY2tFdmVudHNCZXR3ZWVuKGV2ZW50VHJpZ2dlcnMsIF9taW4sIF9tYXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudExpc3QgPSBldmVudExpc3QuY29uY2F0KHRoaXMuY2hlY2tFdmVudHNCZXR3ZWVuKGV2ZW50VHJpZ2dlcnMsIF9taW4sIHRoaXMudG90YWxUaW1lKSk7XG4gICAgICAgICAgX21pbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbWluU2VjdGlvbisrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnRMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gRXZlbnQgdG8gdGhlIExpc3Qgb2YgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG5lZWRzIHRvIGJlIHVuaXF1ZSBwZXIgQW5pbWF0aW9uKS5cbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZXZlbnQgKGluIG1pbGxpc2Vjb25kcykuXG4gICAgICovXG4gICAgcHVibGljIHNldEV2ZW50KF9uYW1lOiBzdHJpbmcsIF90aW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgIHRoaXMuZXZlbnRzW19uYW1lXSA9IF90aW1lO1xuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBldmVudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBfbmFtZSBuYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUuXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUV2ZW50KF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tfbmFtZV07XG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5jbGVhcigpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogKFJlLSlDYWxjdWxhdGUgdGhlIHRvdGFsIHRpbWUgb2YgdGhlIEFuaW1hdGlvbi4gQ2FsY3VsYXRpb24taGVhdnksIHVzZSBvbmx5IGlmIGFjdHVhbGx5IG5lZWRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FsY3VsYXRlVG90YWxUaW1lKCk6IHZvaWQge1xuICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xuICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUpO1xuICAgICAgaWYgKHRoaXMudG90YWxUaW1lID09IDApIC8vIGFuaW1hdGlvbnMgd2l0aCBvbmUga2V5ZnJhbWUgbmVlZCBhIHRvdGFsIHRpbWUgIT0gMCB0byB3b3JrXG4gICAgICAgIHRoaXMudG90YWxUaW1lID0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lIHRvIHVzZSBmb3IgYW5pbWF0aW9uIHNhbXBsaW5nIHdoZW4gYXBwbHlpbmcgYSBwbGF5bW9kZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRNb2RhbFRpbWUoX3RpbWU6IG51bWJlciwgX3BsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREUsIF90aW1lU3RvcDogbnVtYmVyID0gX3RpbWUpOiBudW1iZXIge1xuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuU1RPUDpcbiAgICAgICAgICAvLyByZXR1cm4gdGhpcy5sb2NhbFRpbWUuZ2V0T2Zmc2V0KCk7XG4gICAgICAgICAgcmV0dXJuIF90aW1lU3RvcDtcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWV9PTkNFOlxuICAgICAgICAgIGlmIChfdGltZSA+PSB0aGlzLnRvdGFsVGltZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZSAtIDAuMDE7ICAgICAvL1RPRE86IHRoaXMgbWlnaHQgY2F1c2Ugc29tZSBpc3N1ZXNcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUExBWV9PTkNFX1JFU0VUOlxuICAgICAgICAgIGlmIChfdGltZSA+PSB0aGlzLnRvdGFsVGltZSlcbiAgICAgICAgICAgIC8vIFRPRE86IHJldHVybiBfdGltZVN0b3AgaW5zdGVhZD9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZSArIDAuMDE7ICAgICAvL1RPRE86IHRoaXMgbWlnaHQgY2F1c2Ugc29tZSBpc3N1ZXNcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGltZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBzaG91bGQgY3VycmVudGx5IGJlIHBsYXlpbmcgaW4uXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSB0aW1lIGF0IHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uXG4gICAgICogQHJldHVybnMgMSBpZiBmb3J3YXJkLCAwIGlmIHN0b3AsIC0xIGlmIGJhY2t3YXJkc1xuICAgICAqL1xuICAgIHB1YmxpYyBjYWxjdWxhdGVEaXJlY3Rpb24oX3RpbWU6IG51bWJlciwgX3BsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREUpOiBudW1iZXIge1xuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuU1RPUDpcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgLy8gY2FzZSBBTklNQVRJT05fUExBWU1PREUuUElOR1BPTkc6XG4gICAgICAgIC8vICAgaWYgKE1hdGguZmxvb3IoX3RpbWUgLyB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUpICUgMiA9PSAwKVxuICAgICAgICAvLyAgICAgcmV0dXJuIDE7XG4gICAgICAgIC8vICAgZWxzZVxuICAgICAgICAvLyAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5SRVZFUlNFX0xPT1A6XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0U6XG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlfT05DRV9SRVNFVDpcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSB7XG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBsYWJlbHM6IHt9LFxuICAgICAgICBldmVudHM6IHt9LFxuICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHRoaXMuZnJhbWVzUGVyU2Vjb25kXG4gICAgICAgIC8vIHNwczogdGhpcy5zdGVwc1BlclNlY29uZFxuICAgICAgfTtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5sYWJlbHMpIHtcbiAgICAgICAgcy5sYWJlbHNbbmFtZV0gPSB0aGlzLmxhYmVsc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgcy5ldmVudHNbbmFtZV0gPSB0aGlzLmV2ZW50c1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHMuYW5pbWF0aW9uU3RydWN0dXJlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGl6YXRpb24odGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUpO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfc2VyaWFsaXphdGlvbi5mcmFtZXNQZXJTZWNvbmQ7XG4gICAgICAvLyB0aGlzLnN0ZXBzUGVyU2Vjb25kID0gX3NlcmlhbGl6YXRpb24uc3BzO1xuICAgICAgdGhpcy5sYWJlbHMgPSB7fTtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX3NlcmlhbGl6YXRpb24ubGFiZWxzKSB7XG4gICAgICAgIHRoaXMubGFiZWxzW25hbWVdID0gX3NlcmlhbGl6YXRpb24ubGFiZWxzW25hbWVdO1xuICAgICAgfVxuICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX3NlcmlhbGl6YXRpb24uZXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzW25hbWVdID0gX3NlcmlhbGl6YXRpb24uZXZlbnRzW25hbWVdO1xuICAgICAgfVxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQgPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPigpO1xuXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IGF3YWl0IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGl6YXRpb24oX3NlcmlhbGl6YXRpb24uYW5pbWF0aW9uU3RydWN0dXJlKTtcblxuICAgICAgdGhpcy4jYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZCA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+KCk7XG5cbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIC8vIH1cblxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XG4gICAgICBkZWxldGUgX211dGF0b3IudG90YWxUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgYW4gQW5pbWF0aW9uU3RydWN0dXJlIGFuZCByZXR1cm5zIHRoZSBTZXJpYWxpemF0aW9uIG9mIHNhaWQgU3RydWN0dXJlLlxuICAgICAqIEBwYXJhbSBfc3RydWN0dXJlIFRoZSBBbmltYXRpb24gU3RydWN0dXJlIGF0IHRoZSBjdXJyZW50IGxldmVsIHRvIHRyYW5zZm9ybSBpbnRvIHRoZSBTZXJpYWxpemF0aW9uLlxuICAgICAqIEByZXR1cm5zIHRoZSBmaWxsZWQgU2VyaWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXphdGlvbihfc3RydWN0dXJlOiBPYmplY3QpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIF9zdHJ1Y3R1cmUpIHtcbiAgICAgICAgbGV0IHN0cnVjdHVyZU9yU2VxdWVuY2U6IE9iamVjdCA9ICg8R2VuZXJhbD5fc3RydWN0dXJlKVtwcm9wZXJ0eV07XG4gICAgICAgIGlmIChzdHJ1Y3R1cmVPclNlcXVlbmNlIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpXG4gICAgICAgICAgc2VyaWFsaXphdGlvbltwcm9wZXJ0eV0gPSBzdHJ1Y3R1cmVPclNlcXVlbmNlLnNlcmlhbGl6ZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc2VyaWFsaXphdGlvbltwcm9wZXJ0eV0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXphdGlvbihzdHJ1Y3R1cmVPclNlcXVlbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgYSBTZXJpYWxpemF0aW9uIHRvIGNyZWF0ZSBhIG5ldyBBbmltYXRpb25TdHJ1Y3R1cmUuXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFRoZSBzZXJpYWxpemF0aW9uIHRvIHRyYW5zZmVyIGludG8gYW4gQW5pbWF0aW9uU3RydWN0dXJlXG4gICAgICogQHJldHVybnMgdGhlIG5ld2x5IGNyZWF0ZWQgQW5pbWF0aW9uU3RydWN0dXJlLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGl6YXRpb24oX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPEFuaW1hdGlvblN0cnVjdHVyZT4ge1xuICAgICAgbGV0IHN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XG4gICAgICBmb3IgKGxldCBuIGluIF9zZXJpYWxpemF0aW9uKSB7XG4gICAgICAgIGlmIChfc2VyaWFsaXphdGlvbltuXS5hbmltYXRpb25TZXF1ZW5jZSkge1xuICAgICAgICAgIGxldCBhbmltU2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xuICAgICAgICAgIHN0cnVjdHVyZVtuXSA9IDxBbmltYXRpb25TZXF1ZW5jZT4oYXdhaXQgYW5pbVNlcS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltuXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cnVjdHVyZVtuXSA9IGF3YWl0IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGl6YXRpb24oX3NlcmlhbGl6YXRpb25bbl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFuZCByZXR1cm5zIHRoZSBsaXN0IG9mIGV2ZW50cyB0byBiZSB1c2VkIHdpdGggdGhlc2Ugc2V0dGluZ3MuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb246IG51bWJlciwgX3F1YW50aXphdGlvbjogQU5JTUFUSU9OX1FVQU5USVpBVElPTik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XG4gICAgICBpZiAoX3F1YW50aXphdGlvbiAhPSBBTklNQVRJT05fUVVBTlRJWkFUSU9OLkZSQU1FUykge1xuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfZGlyZWN0aW9uID49IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgYW4ge0BsaW5rIEFuaW1hdGlvblN0cnVjdHVyZX0gYW5kIHJldHVybnMgYSB7QGxpbmsgTXV0YXRvcn0gZGVzY3JpYmluZyB0aGUgc3RhdGUgYXQgdGhlIGdpdmVuIHRpbWVcbiAgICAgKi9cbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcihfc3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUsIF90aW1lOiBudW1iZXIpOiBNdXRhdG9yIHtcbiAgICAgIGxldCBuZXdNdXRhdG9yOiBNdXRhdG9yID0ge307XG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcbiAgICAgICAgaWYgKF9zdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xuICAgICAgICAgIG5ld011dGF0b3Jbbl0gPSAoPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl0pLmV2YWx1YXRlKF90aW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdNdXRhdG9yW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dLCBfdGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld011dGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSBjdXJyZW50IEFuaW1hdGlvblN0cmN1dHVyZSB0byBmaW5kIHRoZSB0b3RhbFRpbWUgb2YgdGhpcyBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIF9zdHJ1Y3R1cmUgVGhlIHN0cnVjdHVyZSB0byB0cmF2ZXJzZVxuICAgICAqL1xuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSk6IHZvaWQge1xuICAgICAgZm9yIChsZXQgbiBpbiBfc3RydWN0dXJlKSB7XG4gICAgICAgIGlmIChfc3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcbiAgICAgICAgICBsZXQgc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlID0gPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl07XG4gICAgICAgICAgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBzZXF1ZW5jZVRpbWU6IG51bWJlciA9IHNlcXVlbmNlLmdldEtleShzZXF1ZW5jZS5sZW5ndGggLSAxKS50aW1lO1xuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSBNYXRoLm1heChzZXF1ZW5jZVRpbWUsIHRoaXMudG90YWxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25TdHJjdXR1cmV9IGFuZCByZXR1cm5zIGl0LlxuICAgICAqIEBwYXJhbSBfdHlwZSB0aGUgdHlwZSBvZiB0aGUgc3RydWN0dXJlIHRvIGdldFxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0ZWQgW1tAbGluayBBbmltYXRpb25TdHJ1Y3R1cmVdXVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKF90eXBlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUpOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xuICAgICAgaWYgKCF0aGlzLiNhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLmhhcyhfdHlwZSkpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcbiAgICAgICAgbGV0IGFlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTtcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTDpcbiAgICAgICAgICAgIGFlID0gdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFOlxuICAgICAgICAgICAgYWUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmNhbGN1bGF0ZVJldmVyc2VTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEOlxuICAgICAgICAgICAgYWUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkU2VxdWVuY2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0U6XG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpLCB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkU2VxdWVuY2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuc2V0KF90eXBlLCBhZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5nZXQoX3R5cGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25FdmVudFRyaWdnZXJ9IGFuZCByZXR1cm5zIGl0LlxuICAgICAqIEBwYXJhbSBfdHlwZSBUaGUgdHlwZSBvZiBBbmltYXRpb25FdmVudFRyaWdnZXIgdG8gZ2V0XG4gICAgICogQHJldHVybnMgdGhlIHJlcXVlc3RlZCB7QGxpbmsgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyfVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKF90eXBlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50c1Byb2Nlc3NlZC5oYXMoX3R5cGUpKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XG4gICAgICAgIGxldCBldjogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUw6XG4gICAgICAgICAgICBldiA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRTpcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSZXZlcnNlRXZlbnRUcmlnZ2Vycyh0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRDpcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnModGhpcy5ldmVudHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFOlxuICAgICAgICAgICAgZXYgPSB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkRXZlbnRUcmlnZ2Vycyh0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5zZXQoX3R5cGUsIGV2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5nZXQoX3R5cGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyBhbiBleGlzdGluZyBzdHJ1Y3R1cmUgdG8gYXBwbHkgYSByZWNhbGN1bGF0aW9uIGZ1bmN0aW9uIHRvIHRoZSBBbmltYXRpb25TdHJ1Y3R1cmUgdG8gc3RvcmUgaW4gYSBuZXcgU3RydWN0dXJlLlxuICAgICAqIEBwYXJhbSBfb2xkU3RydWN0dXJlIFRoZSBvbGQgc3RydWN0dXJlIHRvIHRyYXZlcnNlXG4gICAgICogQHBhcmFtIF9mdW5jdGlvblRvVXNlIFRoZSBmdW5jdGlvbiB0byB1c2UgdG8gcmVjYWxjdWxhdGVkIHRoZSBzdHJ1Y3R1cmUuXG4gICAgICogQHJldHVybnMgQSBuZXcgQW5pbWF0aW9uIFN0cnVjdHVyZSB3aXRoIHRoZSByZWNhbHVsYXRlZCBBbmltYXRpb24gU2VxdWVuY2VzLlxuICAgICAqL1xuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUoX29sZFN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlLCBfZnVuY3Rpb25Ub1VzZTogRnVuY3Rpb24pOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xuICAgICAgbGV0IG5ld1N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XG4gICAgICBmb3IgKGxldCBuIGluIF9vbGRTdHJ1Y3R1cmUpIHtcbiAgICAgICAgaWYgKF9vbGRTdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IF9mdW5jdGlvblRvVXNlKF9vbGRTdHJ1Y3R1cmVbbl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUoPEFuaW1hdGlvblN0cnVjdHVyZT5fb2xkU3RydWN0dXJlW25dLCBfZnVuY3Rpb25Ub1VzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTdHJ1Y3R1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJldmVyc2VkIEFuaW1hdGlvbiBTZXF1ZW5jZSBvdXQgb2YgYSBnaXZlbiBTZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gX3NlcXVlbmNlIFRoZSBzZXF1ZW5jZSB0byBjYWxjdWxhdGUgdGhlIG5ldyBzZXF1ZW5jZSBvdXQgb2ZcbiAgICAgKiBAcmV0dXJucyBUaGUgcmV2ZXJzZWQgU2VxdWVuY2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJldmVyc2VTZXF1ZW5jZShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlKTogQW5pbWF0aW9uU2VxdWVuY2Uge1xuICAgICAgbGV0IHNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG9sZEtleTogQW5pbWF0aW9uS2V5ID0gX3NlcXVlbmNlLmdldEtleShpKTtcbiAgICAgICAgbGV0IGtleTogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleSh0aGlzLnRvdGFsVGltZSAtIG9sZEtleS50aW1lLCBvbGRLZXkudmFsdWUsIG9sZEtleS5pbnRlcnBvbGF0aW9uLCBvbGRLZXkuc2xvcGVPdXQsIG9sZEtleS5zbG9wZUluKTtcbiAgICAgICAgc2VxLmFkZEtleShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmFzdGVyZWQge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlfSBvdXQgb2YgYSBnaXZlbiBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gX3NlcXVlbmNlIFRoZSBzZXF1ZW5jZSB0byBjYWxjdWxhdGUgdGhlIG5ldyBzZXF1ZW5jZSBvdXQgb2ZcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSYXN0ZXJlZFNlcXVlbmNlKF9zZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UpOiBBbmltYXRpb25TZXF1ZW5jZSB7XG4gICAgICBsZXQgc2VxOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xuICAgICAgbGV0IGZyYW1lVGltZTogbnVtYmVyID0gMTAwMCAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMudG90YWxUaW1lOyBpICs9IGZyYW1lVGltZSkge1xuICAgICAgICBsZXQga2V5OiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KGksIF9zZXF1ZW5jZS5ldmFsdWF0ZShpKSwgQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ09OU1RBTlQsIDAsIDApO1xuICAgICAgICBzZXEuYWRkS2V5KGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmV2ZXJzZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcn0gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUuICBcbiAgICAgKiBAcGFyYW0gX2V2ZW50cyB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgbmV3IG9uZSBvdXQgb2ZcbiAgICAgKiBAcmV0dXJucyB0aGUgcmV2ZXJzZWQgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSZXZlcnNlRXZlbnRUcmlnZ2VycyhfZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIpOiBBbmltYXRpb25FdmVudFRyaWdnZXIge1xuICAgICAgbGV0IGFlOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50cykge1xuICAgICAgICBhZVtuYW1lXSA9IHRoaXMudG90YWxUaW1lIC0gX2V2ZW50c1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmFzdGVyZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcn0gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUuICBcbiAgICAgKiBAcGFyYW0gX2V2ZW50cyB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgbmV3IG9uZSBvdXQgb2ZcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnMoX2V2ZW50czogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcbiAgICAgIGxldCBhZTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XG4gICAgICBsZXQgZnJhbWVUaW1lOiBudW1iZXIgPSAxMDAwIC8gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ldmVudHMpIHtcbiAgICAgICAgYWVbbmFtZV0gPSBfZXZlbnRzW25hbWVdIC0gKF9ldmVudHNbbmFtZV0gJSBmcmFtZVRpbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGljaCBldmVudHMgbGF5IGJldHdlZW4gdHdvIGdpdmVuIHRpbWVzIGFuZCByZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgb25lcyB0aGF0IGRvLlxuICAgICAqIEBwYXJhbSBfZXZlbnRUcmlnZ2VycyBUaGUgZXZlbnQgb2JqZWN0IHRvIGNoZWNrIHRoZSBldmVudHMgaW5zaWRlIG9mXG4gICAgICogQHBhcmFtIF9taW4gdGhlIG1pbmltdW0gb2YgdGhlIHJhbmdlIHRvIGNoZWNrIGJldHdlZW4gKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0gX21heCB0aGUgbWF4aW11bSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2sgYmV0d2VlbiAoZXhjbHVzaXZlKVxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lcyBvZiB0aGUgZXZlbnRzIGluIHRoZSBnaXZlbiByYW5nZS4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBjaGVja0V2ZW50c0JldHdlZW4oX2V2ZW50VHJpZ2dlcnM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciwgX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gICAgICBsZXQgZXZlbnRzVG9UcmlnZ2VyOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRUcmlnZ2Vycykge1xuICAgICAgICBpZiAoX21pbiA8PSBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSAmJiBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSA8IF9tYXgpIHtcbiAgICAgICAgICBldmVudHNUb1RyaWdnZXIucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50c1RvVHJpZ2dlcjtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlcyBiZXR3ZWVuIHtAbGluayBBbmltYXRpb25LZXl9cy5cbiAgICogUmVwcmVzZW50ZWQgaW50ZXJuYWxseSBieSBhIGN1YmljIGZ1bmN0aW9uIChgZih4KSA9IGF4wrMgKyBieMKyICsgY3ggKyBkYCkuIFxuICAgKiBPbmx5IG5lZWRzIHRvIGJlIHJlY2FsY3VsYXRlZCB3aGVuIHRoZSBrZXlzIGNoYW5nZSwgc28gYXQgcnVudGltZSBpdCBzaG91bGQgb25seSBiZSBjYWxjdWxhdGVkIG9uY2UuXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25GdW5jdGlvbiB7XG4gICAgcHJpdmF0ZSBhOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgYjogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIGM6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBkOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUga2V5SW46IEFuaW1hdGlvbktleTtcbiAgICBwcml2YXRlIGtleU91dDogQW5pbWF0aW9uS2V5O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9rZXlJbjogQW5pbWF0aW9uS2V5LCBfa2V5T3V0OiBBbmltYXRpb25LZXkgPSBudWxsKSB7XG4gICAgICB0aGlzLmtleUluID0gX2tleUluO1xuICAgICAgdGhpcy5rZXlPdXQgPSBfa2V5T3V0O1xuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHNldEtleUluKF9rZXlJbjogQW5pbWF0aW9uS2V5KSB7XG4gICAgICB0aGlzLmtleUluID0gX2tleUluO1xuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHNldEtleU91dChfa2V5T3V0OiBBbmltYXRpb25LZXkpIHtcbiAgICAgIHRoaXMua2V5T3V0ID0gX2tleU91dDtcbiAgICAgIHRoaXMuY2FsY3VsYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVyIHZhbHVlcyBvZiB0aGlzIGN1YmljIGZ1bmN0aW9uLiBgZih4KSA9IGF4wrMgKyBieMKyICsgY3ggKyBkYFxuICAgICAqIFVzZWQgYnkgZWRpdG9yLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRQYXJhbWV0ZXJzKCk6IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlcjsgZDogbnVtYmVyIH0ge1xuICAgICAgcmV0dXJuIHsgYTogdGhpcy5hLCBiOiB0aGlzLmIsIGM6IHRoaXMuYywgZDogdGhpcy5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB0aW1lLlxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgZnVuY3Rpb24gaW4gbWlsbGlzZWNvbmRzLiBXaWxsIGJlIGNvcnJlY3RlZCBmb3Igb2Zmc2V0IGludGVybmFsbHkuXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lXG4gICAgICovXG4gICAgcHVibGljIGV2YWx1YXRlKF90aW1lOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgX3RpbWUgLT0gdGhpcy5rZXlJbi50aW1lO1xuICAgICAgbGV0IHRpbWUyOiBudW1iZXIgPSBfdGltZSAqIF90aW1lO1xuICAgICAgbGV0IHRpbWUzOiBudW1iZXIgPSB0aW1lMiAqIF90aW1lO1xuICAgICAgcmV0dXJuIHRoaXMuYSAqIHRpbWUzICsgdGhpcy5iICogdGltZTIgKyB0aGlzLmMgKiBfdGltZSArIHRoaXMuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAoUmUtKUNhbGN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGN1YmljIGZ1bmN0aW9uLlxuICAgICAqIFNlZSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMxNzM0NjkvY2FsY3VsYXRlLWN1YmljLWVxdWF0aW9uLWZyb20tdHdvLXBvaW50cy1hbmQtdHdvLXNsb3Blcy12YXJpYWJseVxuICAgICAqIGFuZCBodHRwczovL2ppcmthZGVsbG9yby5naXRodWIuaW8vRlVER0UvRG9jdW1lbnRhdGlvbi9Mb2dzLzE5MDQxMF9Ob3RpemVuX0xTXG4gICAgICovXG4gICAgcHVibGljIGNhbGN1bGF0ZSgpOiB2b2lkIHtcbiAgICAgIGlmICghdGhpcy5rZXlJbikge1xuICAgICAgICB0aGlzLmQgPSB0aGlzLmMgPSB0aGlzLmIgPSB0aGlzLmEgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMua2V5T3V0IHx8IHRoaXMua2V5SW4uaW50ZXJwb2xhdGlvbiA9PSBBTklNQVRJT05fSU5URVJQT0xBVElPTi5DT05TVEFOVCkge1xuICAgICAgICB0aGlzLmQgPSB0aGlzLmtleUluLnZhbHVlO1xuICAgICAgICB0aGlzLmMgPSB0aGlzLmIgPSB0aGlzLmEgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB4MTogbnVtYmVyID0gdGhpcy5rZXlPdXQudGltZSAtIHRoaXMua2V5SW4udGltZTtcblxuICAgICAgdGhpcy5kID0gdGhpcy5rZXlJbi52YWx1ZTtcbiAgICAgIGlmICh0aGlzLmtleUluLmludGVycG9sYXRpb24gPT0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uTElORUFSKSB7XG4gICAgICAgIHRoaXMuYyA9ICh0aGlzLmtleU91dC52YWx1ZSAtIHRoaXMua2V5SW4udmFsdWUpIC8geDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jID0gdGhpcy5rZXlJbi5zbG9wZU91dDtcbiAgICAgIHRoaXMuYSA9ICgteDEgKiAodGhpcy5rZXlJbi5zbG9wZU91dCArIHRoaXMua2V5T3V0LnNsb3BlSW4pIC0gMiAqIHRoaXMua2V5SW4udmFsdWUgKyAyICogdGhpcy5rZXlPdXQudmFsdWUpIC8gLU1hdGgucG93KHgxLCAzKTtcbiAgICAgIHRoaXMuYiA9ICh0aGlzLmtleU91dC5zbG9wZUluIC0gdGhpcy5rZXlJbi5zbG9wZU91dCAtIDMgKiB0aGlzLmEgKiBNYXRoLnBvdyh4MSwgMikpIC8gKDIgKiB4MSk7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIFxuICBleHBvcnQgZW51bSBBTklNQVRJT05fSU5URVJQT0xBVElPTiB7XG4gICAgQ09OU1RBTlQsXG4gICAgTElORUFSLFxuICAgIENVQklDXG4gIH1cbiAgLy8gdHlwZSBBbmltYXRpb25JbnRlcnBvbGF0aW9uID0gXCJjb25zdGFudFwiIHwgXCJsaW5lYXJcIiB8IFwiY3ViaWNcIjtcblxuICAvKipcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgY29udGlub3VzIHBvaW50cyBpbiB0aW1lIHRoZWlyIGFjY29tcGFueWluZyB2YWx1ZXMgYXMgd2VsbCBhcyB0aGVpciBzbG9wZXMuIFxuICAgKiBBbHNvIGhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSB7QGxpbmsgQW5pbWF0aW9uRnVuY3Rpb259cyB0aGF0IGNvbWUgaW4gYW5kIG91dCBvZiB0aGUgc2lkZXMuIFxuICAgKiBUaGUge0BsaW5rIEFuaW1hdGlvbkZ1bmN0aW9ufXMgYXJlIGhhbmRsZWQgYnkgdGhlIHtAbGluayBBbmltYXRpb25TZXF1ZW5jZX1zLlxuICAgKiBJZiB0aGUgcHJvcGVydHkgY29uc3RhbnQgaXMgdHJ1ZSwgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZSBhbmQgd2lsIG5vdCBiZSBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB0aGlzIGFuZCB0aGUgbmV4dCBrZXkgaW4gYSBzZXF1ZW5jZVxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XG4gICAqL1xuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uS2V5IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XG4gICAgLy8gVE9ETzogY2hlY2sgaWYgZnVuY3Rpb25JbiBjYW4gYmUgcmVtb3ZlZFxuICAgIC8qKkRvbid0IG1vZGlmeSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy4qL1xuICAgIHB1YmxpYyBmdW5jdGlvbkluOiBBbmltYXRpb25GdW5jdGlvbjtcbiAgICAvKipEb24ndCBtb2RpZnkgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuKi9cbiAgICBwdWJsaWMgZnVuY3Rpb25PdXQ6IEFuaW1hdGlvbkZ1bmN0aW9uO1xuXG4gICAgI3RpbWU6IG51bWJlcjtcbiAgICAjdmFsdWU6IG51bWJlcjtcbiAgICAjaW50ZXJwb2xhdGlvbjogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT047XG5cbiAgICAjc2xvcGVJbjogbnVtYmVyID0gMDtcbiAgICAjc2xvcGVPdXQ6IG51bWJlciA9IDA7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RpbWU6IG51bWJlciA9IDAsIF92YWx1ZTogbnVtYmVyID0gMCwgX2ludGVycG9sYXRpb246IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OID0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ1VCSUMsIF9zbG9wZUluOiBudW1iZXIgPSAwLCBfc2xvcGVPdXQ6IG51bWJlciA9IDApIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLiN0aW1lID0gX3RpbWU7XG4gICAgICB0aGlzLiN2YWx1ZSA9IF92YWx1ZTtcbiAgICAgIHRoaXMuI2ludGVycG9sYXRpb24gPSBfaW50ZXJwb2xhdGlvbjtcbiAgICAgIHRoaXMuI3Nsb3BlSW4gPSBfc2xvcGVJbjtcbiAgICAgIHRoaXMuI3Nsb3BlT3V0ID0gX3Nsb3BlT3V0O1xuXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0ID0gbmV3IEFuaW1hdGlvbkZ1bmN0aW9uKHRoaXMsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBjb21wYXJhdGlvbiBmdW5jdGlvbiB0byB1c2UgaW4gYW4gYXJyYXkgc29ydCBmdW5jdGlvbiB0byBzb3J0IHRoZSBrZXlzIGJ5IHRoZWlyIHRpbWUuXG4gICAgICogQHBhcmFtIF9hIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIF9iIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJucyA+MCBpZiBhPmIsIDAgaWYgYT1iLCA8MCBpZiBhPGJcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGNvbXBhcmUoX2E6IEFuaW1hdGlvbktleSwgX2I6IEFuaW1hdGlvbktleSk6IG51bWJlciB7XG4gICAgICByZXR1cm4gX2EudGltZSAtIF9iLnRpbWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB0aW1lKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jdGltZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHRpbWUoX3RpbWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jdGltZSA9IF90aW1lO1xuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB2YWx1ZShfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jdmFsdWUgPSBfdmFsdWU7XG4gICAgICB0aGlzLmZ1bmN0aW9uSW4uY2FsY3VsYXRlKCk7XG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaW50ZXJwb2xhdGlvbigpOiBBTklNQVRJT05fSU5URVJQT0xBVElPTiB7XG4gICAgICByZXR1cm4gdGhpcy4jaW50ZXJwb2xhdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGludGVycG9sYXRpb24oX2ludGVycG9sYXRpb246IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OKSB7XG4gICAgICB0aGlzLiNpbnRlcnBvbGF0aW9uID0gX2ludGVycG9sYXRpb247XG4gICAgICB0aGlzLmZ1bmN0aW9uSW4uY2FsY3VsYXRlKCk7XG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc2xvcGVJbigpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3Nsb3BlSW47XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBzbG9wZUluKF9zbG9wZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNzbG9wZUluID0gX3Nsb3BlO1xuICAgICAgdGhpcy5mdW5jdGlvbkluLmNhbGN1bGF0ZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc2xvcGVPdXQoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNzbG9wZU91dDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHNsb3BlT3V0KF9zbG9wZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNzbG9wZU91dCA9IF9zbG9wZTtcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XG4gICAgICBzZXJpYWxpemF0aW9uLnRpbWUgPSB0aGlzLiN0aW1lO1xuICAgICAgc2VyaWFsaXphdGlvbi52YWx1ZSA9IHRoaXMuI3ZhbHVlO1xuICAgICAgc2VyaWFsaXphdGlvbi5pbnRlcnBvbGF0aW9uID0gdGhpcy4jaW50ZXJwb2xhdGlvbjtcbiAgICAgIHNlcmlhbGl6YXRpb24uc2xvcGVJbiA9IHRoaXMuI3Nsb3BlSW47XG4gICAgICBzZXJpYWxpemF0aW9uLnNsb3BlT3V0ID0gdGhpcy4jc2xvcGVPdXQ7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgdGhpcy4jdGltZSA9IF9zZXJpYWxpemF0aW9uLnRpbWU7XG4gICAgICB0aGlzLiN2YWx1ZSA9IF9zZXJpYWxpemF0aW9uLnZhbHVlO1xuICAgICAgdGhpcy4jaW50ZXJwb2xhdGlvbiA9IF9zZXJpYWxpemF0aW9uLmludGVycG9sYXRpb247XG4gICAgICB0aGlzLiNzbG9wZUluID0gX3NlcmlhbGl6YXRpb24uc2xvcGVJbjtcbiAgICAgIHRoaXMuI3Nsb3BlT3V0ID0gX3NlcmlhbGl6YXRpb24uc2xvcGVPdXQ7XG4gICAgICAvLyBpZiAoX3NlcmlhbGl6YXRpb24uaW50ZXJwb2xhdGlvbiA9PSB1bmRlZmluZWQpXG4gICAgICAvLyAgIGlmIChfc2VyaWFsaXphdGlvbi5jb25zdGFudCkgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd2hlbiBjb25zdGFudCBpcyByZW1vdmVkXG4gICAgICAvLyAgICAgdGhpcy4jaW50ZXJwb2xhdGlvbiA9IFwiY29uc3RhbnRcIjtcbiAgICAgIC8vICAgZWxzZVxuICAgICAgLy8gICAgIHRoaXMuI2ludGVycG9sYXRpb24gPSBcImN1YmljXCI7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIC8vXG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBBIHNlcXVlbmNlIG9mIHtAbGluayBBbmltYXRpb25LZXl9cyB0aGF0IGlzIG1hcHBlZCB0byBhbiBhdHRyaWJ1dGUgb2YgYSB7QGxpbmsgTm9kZX0gb3IgaXRzIHtAbGluayBDb21wb25lbnR9cyBpbnNpZGUgdGhlIHtAbGluayBBbmltYXRpb259LlxuICAgKiBQcm92aWRlcyBmdW5jdGlvbnMgdG8gbW9kaWZ5IHNhaWQga2V5c1xuICAgKiBAYXV0aG9ycyBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOSB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvblNlcXVlbmNlIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XG4gICAgcHJpdmF0ZSBrZXlzOiBBbmltYXRpb25LZXlbXSA9IFtdO1xuXG4gICAgcHVibGljIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgc2VxdWVuY2UgYXQgdGhlIGdpdmVuIHBvaW50IGluIHRpbWUuXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBzZXF1ZW5jZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gdGltZS4gdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBrZXlzLlxuICAgICAqL1xuICAgIHB1YmxpYyBldmFsdWF0ZShfdGltZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vVE9ETzogc2hvdWxkbid0IHJldHVybiAwIGJ1dCBzb21ldGhpbmcgaW5kaWNhdGluZyBubyBjaGFuZ2UsIGxpa2UgbnVsbC4gcHJvYmFibHkgbmVlZHMgdG8gYmUgY2hhbmdlZCBpbiBOb2RlIGFzIHdlbGwgdG8gaWdub3JlIG5vbi1udW1lcmljIHZhbHVlcyBpbiB0aGUgYXBwbHlBbmltYXRpb24gZnVuY3Rpb25cbiAgICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDEgfHwgdGhpcy5rZXlzWzBdLnRpbWUgPj0gX3RpbWUpXG4gICAgICAgIHJldHVybiB0aGlzLmtleXNbMF0udmFsdWU7XG5cblxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMua2V5c1tpXS50aW1lIDw9IF90aW1lICYmIF90aW1lIDwgdGhpcy5rZXlzW2kgKyAxXS50aW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dC5ldmFsdWF0ZShfdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHRoaXMua2V5c1tpXS50aW1lID09IF90aW1lKVxuICAgICAgICAvLyAgIHJldHVybiB0aGlzLmtleXNbaV0udmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5rZXlzW3RoaXMua2V5cy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGtleSB0byB0aGUgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIF9rZXkgdGhlIGtleSB0byBhZGRcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkS2V5KF9rZXk6IEFuaW1hdGlvbktleSk6IHZvaWQge1xuICAgICAgdGhpcy5rZXlzLnB1c2goX2tleSk7XG4gICAgICB0aGlzLmtleXMuc29ydChBbmltYXRpb25LZXkuY29tcGFyZSk7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnlzIGEgZ2l2ZW4ga2V5IGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIGFkZFxuICAgICAqL1xuICAgIHB1YmxpYyBtb2RpZnlLZXkoX2tleTogQW5pbWF0aW9uS2V5LCBfdGltZT86IG51bWJlciwgX3ZhbHVlPzogbnVtYmVyKTogdm9pZCB7XG4gICAgICBpZiAoX3RpbWUgIT0gbnVsbClcbiAgICAgICAgX2tleS50aW1lID0gX3RpbWU7XG4gICAgICBpZiAoX3ZhbHVlICE9IG51bGwpXG4gICAgICAgIF9rZXkudmFsdWUgPSBfdmFsdWU7XG4gICAgICB0aGlzLmtleXMuc29ydChBbmltYXRpb25LZXkuY29tcGFyZSk7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZ2l2ZW4ga2V5IGZyb20gdGhlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSBfa2V5IHRoZSBrZXkgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUtleShfa2V5OiBBbmltYXRpb25LZXkpOiB2b2lkIHtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMua2V5c1tpXSA9PSBfa2V5KSB7XG4gICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEga2V5IGluIHRoZSBzZXF1ZW5jZSBleGFjdGx5IG1hdGNoaW5nIHRoZSBnaXZlbiB0aW1lLlxuICAgICAqL1xuICAgIHB1YmxpYyBmaW5kS2V5KF90aW1lOiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xuICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMua2V5cylcbiAgICAgICAgaWYgKGtleS50aW1lID09IF90aW1lKVxuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBBbmltYXRpb24gS2V5IGF0IHRoZSBnaXZlbiBpbmRleCBmcm9tIHRoZSBrZXlzLlxuICAgICAqIEBwYXJhbSBfaW5kZXggdGhlIHplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gcmVtb3ZlIHRoZSBrZXlcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVtb3ZlZCBBbmltYXRpb25LZXkgaWYgc3VjY2Vzc2Z1bCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUtleUF0SW5kZXgoX2luZGV4OiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xuICAgICAgaWYgKF9pbmRleCA8IDAgfHwgX2luZGV4ID49IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgYWs6IEFuaW1hdGlvbktleSA9IHRoaXMua2V5c1tfaW5kZXhdO1xuICAgICAgdGhpcy5rZXlzLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XG4gICAgICByZXR1cm4gYWs7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGtleSBmcm9tIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZGVzaXJlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0gX2luZGV4IHRoZSB6ZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGdldCB0aGUga2V5XG4gICAgICogQHJldHVybnMgdGhlIEFuaW1hdGlvbktleSBhdCB0aGUgaW5kZXggaWYgaXQgZXhpc3RzLCBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0S2V5KF9pbmRleDogbnVtYmVyKTogQW5pbWF0aW9uS2V5IHtcbiAgICAgIGlmIChfaW5kZXggPCAwIHx8IF9pbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLmtleXNbX2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgc2VxdWVuY2UncyBrZXlzLiBUaGlzIGlzIG5vdCBhIGNvcHksIGJ1dCB0aGUgYWN0dWFsIGFycmF5IHVzZWQgaW50ZXJuYWxseS4gSGFuZGxlIHdpdGggY2FyZSFcbiAgICAgKiBVc2VkIGJ5IEVkaXRvci5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0S2V5cygpOiBBbmltYXRpb25LZXlbXSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlzO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAga2V5czogW10sXG4gICAgICAgIGFuaW1hdGlvblNlcXVlbmNlOiB0cnVlXG4gICAgICB9O1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzLmtleXNbaV0gPSB0aGlzLmtleXNbaV0uc2VyaWFsaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXJpYWxpemF0aW9uLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gdGhpcy5rZXlzLnB1c2goPEFuaW1hdGlvbktleT5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmtleXNbaV0pKTtcbiAgICAgICAgbGV0IGs6IEFuaW1hdGlvbktleSA9IG5ldyBBbmltYXRpb25LZXkoKTtcbiAgICAgICAgYXdhaXQgay5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5rZXlzW2ldKTtcbiAgICAgICAgdGhpcy5rZXlzW2ldID0gaztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsgLyogKi8gfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IChyZS0pZ2VuZXJhdGVzIGFsbCBmdW5jdGlvbnMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVnZW5lcmF0ZUZ1bmN0aW9ucygpOiB2b2lkIHtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGY6IEFuaW1hdGlvbkZ1bmN0aW9uID0gbmV3IEFuaW1hdGlvbkZ1bmN0aW9uKHRoaXMua2V5c1tpXSk7XG4gICAgICAgIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dCA9IGY7XG4gICAgICAgIGlmIChpID09IHRoaXMua2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy9UT0RPOiBjaGVjayBpZiB0aGlzIGlzIGV2ZW4gdXNlZnVsLiBNYXliZSB1cGRhdGUgdGhlIHJ1bmNvbmRpdGlvbiB0byBsZW5ndGggLSAxIGluc3RlYWQuIE1pZ2h0IGJlIHJlZHVuZGFudCBpZiBmdW5jdGlvbkluIGlzIHJlbW92ZWQsIHNlZSBUT0RPIGluIEFuaW1hdGlvbktleS5cbiAgICAgICAgICBmLnNldEtleU91dCA9IHRoaXMua2V5c1swXTtcbiAgICAgICAgICB0aGlzLmtleXNbMF0uZnVuY3Rpb25JbiA9IGY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZi5zZXRLZXlPdXQgPSB0aGlzLmtleXNbaSArIDFdO1xuICAgICAgICB0aGlzLmtleXNbaSArIDFdLmZ1bmN0aW9uSW4gPSBmO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uU3ByaXRlIGV4dGVuZHMgQW5pbWF0aW9uIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQW5pbWF0aW9uLnJlZ2lzdGVyU3ViY2xhc3MoQW5pbWF0aW9uU3ByaXRlKTtcbiAgICBwdWJsaWMgdGV4dHVyZTogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0LnRleHR1cmU7XG4gICAgcHJpdmF0ZSBpZFRleHR1cmU6IHN0cmluZztcbiAgICBwcml2YXRlIGZyYW1lczogbnVtYmVyID0gMjU7XG4gICAgcHJpdmF0ZSB3cmFwQWZ0ZXI6IG51bWJlciA9IDU7XG4gICAgcHJpdmF0ZSBzdGFydDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKDAsIDApO1xuICAgIHByaXZhdGUgc2l6ZTogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKDgwLCA4MCk7XG4gICAgcHJpdmF0ZSBuZXh0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoODAsIDApO1xuICAgIHByaXZhdGUgd3JhcDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKDAsIDgwKTtcblxuICAgIC8vIFRPRE86IGZwcyBzaG91bGQgYmUgYSBwYXJhbWV0ZXIgdG9vXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIkFuaW1hdGlvblNwcml0ZVwiKSB7IC8vfSwgX2ZwczogbnVtYmVyID0gMTUpIHtcbiAgICAgIHN1cGVyKF9uYW1lLCB7fSwgMSk7XG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IHRoaXMuZnJhbWVzO1xuICAgICAgdGhpcy5jcmVhdGUodGhpcy50ZXh0dXJlLCB0aGlzLmZyYW1lcywgdGhpcy53cmFwQWZ0ZXIsIHRoaXMuc3RhcnQsIHRoaXMuc2l6ZSwgdGhpcy5uZXh0LCB0aGlzLndyYXAsIHRoaXMuZnJhbWVzUGVyU2Vjb25kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZXh0dXJlIHRvIGJlIHVzZWQgYXMgdGhlIHNwcml0ZXNoZWV0XG4gICAgICovXG4gICAgcHVibGljIHNldFRleHR1cmUoX3RleHR1cmU6IFRleHR1cmUpOiB2b2lkIHtcbiAgICAgIHRoaXMudGV4dHVyZSA9IF90ZXh0dXJlO1xuICAgICAgdGhpcy5pZFRleHR1cmUgPSBfdGV4dHVyZS5pZFJlc291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhpcyBhbmltYXRpb24gc3ByaXRlIGZyb20gdGhlIGdpdmVuIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGUoX3RleHR1cmU6IFRleHR1cmUsIF9mcmFtZXM6IG51bWJlciwgX3dyYXBBZnRlcjogbnVtYmVyLCBfc3RhcnQ6IFZlY3RvcjIsIF9zaXplOiBWZWN0b3IyLCBfbmV4dDogVmVjdG9yMiwgX3dyYXA6IFZlY3RvcjIsIF9mcmFtZXNQZXJTZWNvbmQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgdGhpcy5zZXRUZXh0dXJlKF90ZXh0dXJlKTtcbiAgICAgIHRoaXMuZnJhbWVzID0gX2ZyYW1lcztcbiAgICAgIHRoaXMud3JhcEFmdGVyID0gX3dyYXBBZnRlcjtcbiAgICAgIHRoaXMuc3RhcnQgPSBfc3RhcnQ7XG4gICAgICB0aGlzLnNpemUgPSBfc2l6ZTtcbiAgICAgIHRoaXMubmV4dCA9IF9uZXh0O1xuICAgICAgdGhpcy53cmFwID0gX3dyYXA7XG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcmFtZXNQZXJTZWNvbmQ7XG5cbiAgICAgIGxldCBzY2FsZTogVmVjdG9yMiA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjJbXSA9IHRoaXMuZ2V0UG9zaXRpb25zKCk7XG5cbiAgICAgIGxldCB4VHJhbnNsYXRpb246IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKCk7XG4gICAgICBsZXQgeVRyYW5zbGF0aW9uOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xuICAgICAgbGV0IHhTY2FsZTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcbiAgICAgIGxldCB5U2NhbGU6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKCk7XG4gICAgICB4U2NhbGUuYWRkS2V5KG5ldyBBbmltYXRpb25LZXkoMCwgc2NhbGUueCkpO1xuICAgICAgeVNjYWxlLmFkZEtleShuZXcgQW5pbWF0aW9uS2V5KDAsIHNjYWxlLnkpKTtcblxuICAgICAgZm9yIChsZXQgZnJhbWU6IG51bWJlciA9IDA7IGZyYW1lIDw9IHRoaXMuZnJhbWVzOyBmcmFtZSsrKSB7XG4gICAgICAgIGxldCB0aW1lOiBudW1iZXIgPSAxMDAwICogZnJhbWUgLyB0aGlzLmZyYW1lc1BlclNlY29uZDtcbiAgICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IyID0gcG9zaXRpb25zW01hdGgubWluKGZyYW1lLCB0aGlzLmZyYW1lcyAtIDEpXTsgLy9yZXBlYXQgdGhlIGxhc3Qga2V5IHRvIGdpdmUgdGhlIGxhc3QgZnJhbWUgc29tZSB0aW1lXG4gICAgICAgIHhUcmFuc2xhdGlvbi5hZGRLZXkobmV3IEFuaW1hdGlvbktleSh0aW1lLCBwb3NpdGlvbi54IC8gdGhpcy50ZXh0dXJlLnRleEltYWdlU291cmNlLndpZHRoKSk7Ly8sIDAsIDAsIHRydWUpKVxuICAgICAgICB5VHJhbnNsYXRpb24uYWRkS2V5KG5ldyBBbmltYXRpb25LZXkodGltZSwgcG9zaXRpb24ueSAvIHRoaXMudGV4dHVyZS50ZXhJbWFnZVNvdXJjZS5oZWlnaHQpKTsvLywgMCwgMCwgdHJ1ZSkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlID0ge1xuICAgICAgICBcImNvbXBvbmVudHNcIjoge1xuICAgICAgICAgIFwiQ29tcG9uZW50TWF0ZXJpYWxcIjogW3tcbiAgICAgICAgICAgIFwibXR4UGl2b3RcIjoge1xuICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICB4OiB4VHJhbnNsYXRpb24sXG4gICAgICAgICAgICAgICAgeTogeVRyYW5zbGF0aW9uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwic2NhbGluZ1wiOiB7XG4gICAgICAgICAgICAgICAgeDogeFNjYWxlLFxuICAgICAgICAgICAgICAgIHk6IHlTY2FsZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBvZiB0aGUgc3ByaXRlc2hlZXRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2NhbGUoKTogVmVjdG9yMiB7XG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIoXG4gICAgICAgIHRoaXMuc2l6ZS54IC8gdGhpcy50ZXh0dXJlLnRleEltYWdlU291cmNlLndpZHRoLFxuICAgICAgICB0aGlzLnNpemUueSAvIHRoaXMudGV4dHVyZS50ZXhJbWFnZVNvdXJjZS5oZWlnaHRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb25zIG9mIHRoZSBzcHJpdGVzaGVldFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRQb3NpdGlvbnMoKTogVmVjdG9yMltdIHtcbiAgICAgIGxldCBpTmV4dDogbnVtYmVyID0gMDtcbiAgICAgIGxldCBpV3JhcDogbnVtYmVyID0gMDtcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjJbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgZnJhbWU6IG51bWJlciA9IDA7IGZyYW1lIDwgdGhpcy5mcmFtZXM7IGZyYW1lKyspIHtcbiAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjIoXG4gICAgICAgICAgdGhpcy5zdGFydC54ICsgaU5leHQgKiB0aGlzLm5leHQueCArIGlXcmFwICogdGhpcy53cmFwLngsXG4gICAgICAgICAgdGhpcy5zdGFydC55ICsgaU5leHQgKiB0aGlzLm5leHQueSArIGlXcmFwICogdGhpcy53cmFwLnlcbiAgICAgICAgKSk7XG5cbiAgICAgICAgaU5leHQrKztcbiAgICAgICAgaWYgKGlOZXh0ID49IHRoaXMud3JhcEFmdGVyKSB7XG4gICAgICAgICAgaU5leHQgPSAwO1xuICAgICAgICAgIGlXcmFwKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbj86IHN0cmluZ1tdLCBfZGlzcGF0Y2hNdXRhdGU/OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xuICAgICAgdGhpcy5jcmVhdGUodGhpcy50ZXh0dXJlLCB0aGlzLmZyYW1lcywgdGhpcy53cmFwQWZ0ZXIsIHRoaXMuc3RhcnQsIHRoaXMuc2l6ZSwgdGhpcy5uZXh0LCB0aGlzLndyYXAsIHRoaXMuZnJhbWVzUGVyU2Vjb25kKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSA9IHRoaXMuaWRSZXNvdXJjZTtcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRUZXh0dXJlID0gdGhpcy5pZFRleHR1cmU7XG4gICAgICBzZXJpYWxpemF0aW9uLmZyYW1lcyA9IHRoaXMuZnJhbWVzO1xuICAgICAgc2VyaWFsaXphdGlvbi53cmFwQWZ0ZXIgPSB0aGlzLndyYXBBZnRlcjtcbiAgICAgIGZvciAobGV0IG5hbWUgb2YgW1wic3RhcnRcIiwgXCJzaXplXCIsIFwibmV4dFwiLCBcIndyYXBcIl0pXG4gICAgICAgIHNlcmlhbGl6YXRpb25bbmFtZV0gPSAoPFZlY3RvcjI+UmVmbGVjdC5nZXQodGhpcywgbmFtZSkpLnNlcmlhbGl6ZSgpO1xuXG4gICAgICBsZXQgYW5pbWF0aW9uc1N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0gdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmU7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IHt9OyAvLyBubyBuZWVkIHRvIHNlcmlhbGl6ZSBzdHJ1Y3R1cmVcbiAgICAgIC8vIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IGFuaW1hdGlvbnNTdHJ1Y3R1cmU7IC8vIHJlc3RvcmUgZXhpc3RlbnQgc3RydWN0dXJlXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3M6IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3Nbc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgaWYgKF9zLmlkVGV4dHVyZSlcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gPFRleHR1cmU+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfcy5pZFRleHR1cmUpO1xuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnRleHR1cmUgPSBUZXh0dXJlRGVmYXVsdC50ZXh0dXJlO1xuXG4gICAgICBmb3IgKGxldCBuYW1lIG9mIFtcInN0YXJ0XCIsIFwic2l6ZVwiLCBcIm5leHRcIiwgXCJ3cmFwXCJdKVxuICAgICAgICAoPFZlY3RvcjI+UmVmbGVjdC5nZXQodGhpcywgbmFtZSkpLmRlc2VyaWFsaXplKF9zW25hbWVdKTtcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMudGV4dHVyZSwgX3MuZnJhbWVzLCBfcy53cmFwQWZ0ZXIsIHRoaXMuc3RhcnQsIHRoaXMuc2l6ZSwgdGhpcy5uZXh0LCB0aGlzLndyYXAsIHRoaXMuZnJhbWVzUGVyU2Vjb25kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSB7QGxpbmsgQW5pbWF0aW9uU3ByaXRlfSBpbnRvIGFuIHtAbGluayBBbmltYXRpb259XG4gICAgICovXG4gICAgcHVibGljIGNvbnZlcnRUb0FuaW1hdGlvbigpOiBBbmltYXRpb24ge1xuICAgICAgbGV0IGFuaW1hdGlvbjogQW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih0aGlzLm5hbWUsIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmZyYW1lc1BlclNlY29uZCk7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEV4dGVuc2lvbiBvZiBBdWRpb0J1ZmZlciB3aXRoIGEgbG9hZCBtZXRob2QgdGhhdCBjcmVhdGVzIGEgYnVmZmVyIGluIHRoZSB7QGxpbmsgQXVkaW9NYW5hZ2VyfS5kZWZhdWx0IHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgQ29tcG9uZW50QXVkaW99XHJcbiAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQXVkaW8gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiQXVkaW9cIjtcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICBwdWJsaWMgYnVmZmVyOiBBdWRpb0J1ZmZlciA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBwYXRoOiBVUkwgPSB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHVybDogUmVxdWVzdEluZm8gPSB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHJlYWR5OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF91cmw/OiBSZXF1ZXN0SW5mbykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICBpZiAoX3VybCkge1xyXG4gICAgICAgIHRoaXMubG9hZChfdXJsKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBfdXJsLnRvU3RyaW5nKCkuc3BsaXQoXCIvXCIpLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc1JlYWR5KCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWFkeTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBhdWRpbyAobXAzKSBmcm9tIHRoZSBnaXZlbiB1cmxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJBdWRpb0xvYWRcIiwgX3VybCk7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnBhdGggPSBuZXcgVVJMKHRoaXMudXJsLnRvU3RyaW5nKCksIFByb2plY3QuYmFzZVVSTCk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaCh0aGlzLnBhdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgIGxldCBidWZmZXI6IEF1ZGlvQnVmZmVyID0gYXdhaXQgQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZGVjb2RlQXVkaW9EYXRhKGFycmF5QnVmZmVyKTtcclxuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLlJFQURZKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHVybDogdGhpcy51cmwsXHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZChfc2VyaWFsaXphdGlvbi51cmwpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCB1cmw6IHN0cmluZyA9IF9tdXRhdG9yLnVybDsgLy8gc2F2ZSB1cmwgZm9yIHJlY29uc3RydWN0aW9uIGFmdGVyIGV4Y2x1c2lvblxyXG4gICAgICBpZiAoX211dGF0b3IudXJsICE9IHRoaXMudXJsLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgdGhpcy5sb2FkKF9tdXRhdG9yLnVybCk7XHJcbiAgICAgIC8vIGV4Y2VwdCB1cmwgZnJvbSBtdXRhdG9yIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmdcclxuICAgICAgZGVsZXRlIChfbXV0YXRvci51cmwpO1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICAvLyByZWNvbnN0cnVjdCwgZm9yIG11dGF0b3IgbWF5IGJlIGtlcHQgYnkgY2FsbGVyXHJcbiAgICAgIFJlZmxlY3Quc2V0KF9tdXRhdG9yLCBcInVybFwiLCB1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vIGRlbGV0ZSBfbXV0YXRvci5pZFJlc291cmNlOyBcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlYWR5O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0FVRElPIHtcbiAgICAvKiogYnJvYWRjYXN0IHRvIGEge0BsaW5rIE5vZGV9IGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzIGluIHRoZSBncmFwaCBhZnRlciBpdCB3YXMgYXBwZW5kZWQgdG8gYSBwYXJlbnQgKi9cbiAgICBDSElMRF9BUFBFTkQgPSBcImNoaWxkQXBwZW5kVG9BdWRpb0dyYXBoXCIsXG4gICAgLyoqIGJyb2FkY2FzdCB0byBhIHtAbGluayBOb2RlfSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGgganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXG4gICAgQ0hJTERfUkVNT1ZFID0gXCJjaGlsZFJlbW92ZUZyb21BdWRpb0dyYXBoXCIsXG4gICAgLyoqIGJyb2FkY2FzdCB0byBhIHtAbGluayBOb2RlfSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGggdG8gdXBkYXRlIHRoZSBwYW5uZXJzIGluIEF1ZGlvQ29tcG9uZW50cyAqL1xuICAgIFVQREFURSA9IFwidXBkYXRlQXVkaW9HcmFwaFwiLFxuICAgIC8qKiBmaXJlZCB3aGVuIHRoZSBhdWRpbyBmaWxlIHdhcyBsb2FkZWQgYW5kIGlzIHJlYWR5IGZvciBwbGF5aW5nICovXG4gICAgUkVBRFkgPSBcInJlYWR5XCIsXG4gICAgLyoqIGZpcmVkIHdoZW4gdGhlIGVuZCBvZiB0aGUgYXVkaW8gaXMgcmVhY2hlZCB3aGlsZSBwbGF5aW5nICovXG4gICAgRU5ERUQgPSBcImVuZGVkXCJcbiAgfVxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL0V2ZW50L0V2ZW50QXVkaW8udHNcIi8+XG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIHN0YW5kYXJkIEF1ZGlvQ29udGV4dCBmb3IgaW50ZWdyYXRpb24gd2l0aCBGVURHRS1ncmFwaHMuXG4gICAqIENyZWF0ZXMgYSBkZWZhdWx0IG9iamVjdCBhdCBzdGFydHVwIHRvIGJlIGFkZHJlc3NlZCBhcyBBdWRpb01hbmFnZXIgZGVmYXVsdC5cbiAgICogT3RoZXIgb2JqZWN0cyBvZiB0aGlzIGNsYXNzIG1heSBiZSBjcmVhdGUgZm9yIHNwZWNpYWwgcHVycG9zZXMuXG4gICAqL1xuICBleHBvcnQgY2xhc3MgQXVkaW9NYW5hZ2VyIGV4dGVuZHMgQXVkaW9Db250ZXh0IHtcbiAgICAvKiogVGhlIGRlZmF1bHQgY29udGV4dCB0aGF0IG1heSBiZSB1c2VkIHRocm91Z2hvdXQgdGhlIHByb2plY3Qgd2l0aG91dCB0aGUgbmVlZCB0byBjcmVhdGUgb3RoZXJzICovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkZWZhdWx0OiBBdWRpb01hbmFnZXIgPSBuZXcgQXVkaW9NYW5hZ2VyKHsgbGF0ZW5jeUhpbnQ6IFwiaW50ZXJhY3RpdmVcIiwgc2FtcGxlUmF0ZTogNDQxMDAgfSk7XG4gICAgcHJpdmF0ZSBzdGF0aWMgZXZlbnRVcGRhdGU6IEV2ZW50ID0gbmV3IEV2ZW50KEVWRU5UX0FVRElPLlVQREFURSk7XG4gICAgLyoqIFRoZSBtYXN0ZXIgdm9sdW1lIGFsbCBBdWRpb05vZGVzIGluIHRoZSBjb250ZXh0IHNob3VsZCBhdHRhY2ggdG8gKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgZ2FpbjogR2Fpbk5vZGU7XG4gICAgcHJpdmF0ZSBncmFwaDogTm9kZSA9IG51bGw7XG4gICAgcHJpdmF0ZSBjbXBMaXN0ZW5lcjogQ29tcG9uZW50QXVkaW9MaXN0ZW5lciA9IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbnRleHRPcHRpb25zPzogQXVkaW9Db250ZXh0T3B0aW9ucykge1xuICAgICAgc3VwZXIoX2NvbnRleHRPcHRpb25zKTtcbiAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuY3JlYXRlR2FpbigpO1xuICAgICAgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5kZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtYXN0ZXIgdm9sdW1lXG4gICAgICovXG4gICAgcHVibGljIHNldCB2b2x1bWUoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWFzdGVyIHZvbHVtZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdm9sdW1lKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBGVURHRS1ncmFwaCB0byBsaXN0ZW4gdG8uIEVhY2gge0BsaW5rIENvbXBvbmVudEF1ZGlvfSBpbiB0aGUgZ3JhcGggd2lsbCBjb25uZWN0IHRvIHRoaXMgY29udGV4dHMgbWFzdGVyIGdhaW4sIGFsbCBvdGhlcnMgZGlzY29ubmVjdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgbGlzdGVuVG8gPSAoX2dyYXBoOiBOb2RlIHwgbnVsbCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKHRoaXMuZ3JhcGgpXG4gICAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xuICAgICAgaWYgKCFfZ3JhcGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuZ3JhcGggPSBfZ3JhcGg7XG4gICAgICB0aGlzLmdyYXBoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIEZVREdFLWdyYXBoIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG9cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0R3JhcGhMaXN0ZW5pbmdUbyA9ICgpOiBOb2RlID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBDb21wb25lbnRBdWRpb0xpc3RlbmVyfSB0aGF0IHNlcnZlcyB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gZm9yIHRoaXMgY29udGV4dHMgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgbGlzdGVuV2l0aCA9IChfY21wTGlzdGVuZXI6IENvbXBvbmVudEF1ZGlvTGlzdGVuZXIgfCBudWxsKTogdm9pZCA9PiB7XG4gICAgICB0aGlzLmNtcExpc3RlbmVyID0gX2NtcExpc3RlbmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzcGF0aWFsIHNldHRpbmdzIG9mIHRoZSBBdWRpb05vZGVzIGVmZmVjdGVkIGluIHRoZSBjdXJyZW50IEZVREdFLWdyYXBoXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIC8vIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLlVQREFURSkpO1xuICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChBdWRpb01hbmFnZXIuZXZlbnRVcGRhdGUpO1xuICAgICAgaWYgKHRoaXMuY21wTGlzdGVuZXIpXG4gICAgICAgIHRoaXMuY21wTGlzdGVuZXIudXBkYXRlKHRoaXMubGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbn0iLCIvLyBuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIFxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBFbnVtZXJhdG9yIGZvciBhbGwgcG9zc2libGUgT3NjaWxsYXRvciBUeXBlc1xyXG4vLyAgICAgICovXHJcbi8vICAgICB0eXBlIE9TQ0lMTEFUT1JfVFlQRSA9IFwic2luZVwiIHwgXCJzcXVhcmVcIiB8IFwic2F3dG9vdGhcIiB8IFwidHJpYW5nbGVcIiB8IFwiY3VzdG9tXCI7XHJcblxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBJbnRlcmZhY2UgdG8gY3JlYXRlIEN1c3RvbSBPc2NpbGxhdG9yIFR5cGVzLlxyXG4vLyAgICAgICogU3RhcnQtL0VuZHBvaW50IG9mIGEgY3VzdHVtIGN1cnZlIGUuZy4gc2luZSBjdXJ2ZS5cclxuLy8gICAgICAqIEJvdGggcGFyYW1ldGVycyBuZWVkIHRvIGJlIGluYmV0d2VlbiAtMSBhbmQgMS5cclxuLy8gICAgICAqIEBwYXJhbSBzdGFydHBvaW50IHN0YXJ0cG9pbnQgb2YgYSBjdXJ2ZSBcclxuLy8gICAgICAqIEBwYXJhbSBlbmRwb2ludCBFbmRwb2ludCBvZiBhIGN1cnZlIFxyXG4vLyAgICAgICovXHJcbi8vICAgICBpbnRlcmZhY2UgT3NjaWxsYXRvcldhdmUge1xyXG4vLyAgICAgICAgIHN0YXJ0cG9pbnQ6IG51bWJlcjtcclxuLy8gICAgICAgICBlbmRwb2ludDogbnVtYmVyO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgLyoqXHJcbi8vICAgICAgKiBBZGQgYW4ge0BsaW5rIEF1ZGlvRmlsdGVyfSB0byBhbiB7QGxpbmsgQXVkaW9dXVxyXG4vLyAgICAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5XHJcbi8vICAgICAgKi9cclxuLy8gICAgIGV4cG9ydCBjbGFzcyBBdWRpb09zY2lsbGF0b3Ige1xyXG5cclxuLy8gICAgICAgICBwdWJsaWMgYXVkaW9Pc2NpbGxhdG9yOiBPc2NpbGxhdG9yTm9kZTsgXHJcblxyXG4vLyAgICAgICAgIHByaXZhdGUgZnJlcXVlbmN5OiBudW1iZXI7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBvc2NpbGxhdG9yVHlwZTogT1NDSUxMQVRPUl9UWVBFO1xyXG4vLyAgICAgICAgIHByaXZhdGUgb3NjaWxsYXRvcldhdmU6IFBlcmlvZGljV2F2ZTtcclxuXHJcbi8vICAgICAgICAgcHJpdmF0ZSBsb2NhbEdhaW46IEdhaW5Ob2RlO1xyXG4vLyAgICAgICAgIHByaXZhdGUgbG9jYWxHYWluVmFsdWU6IG51bWJlcjtcclxuXHJcbi8vICAgICAgICAgY29uc3RydWN0b3IoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9vc2NpbGxhdG9yVHlwZT86IE9TQ0lMTEFUT1JfVFlQRSkge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvciA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4gPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVHYWluKCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMub3NjaWxsYXRvclR5cGUgPSBfb3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIGlmICh0aGlzLm9zY2lsbGF0b3JUeXBlICE9IFwiY3VzdG9tXCIpIHtcclxuLy8gICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnR5cGUgPSB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9zY2lsbGF0b3JXYXZlKSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMub3NjaWxsYXRvcldhdmUpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGUgYSBDdXN0b20gUGVyaW9kaWMgV2F2ZSBmaXJzdCB0byB1c2UgQ3VzdG9tIFR5cGVcIik7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRPc2NpbGxhdG9yVHlwZShfb3NjaWxsYXRvclR5cGU6IE9TQ0lMTEFUT1JfVFlQRSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICBpZiAodGhpcy5vc2NpbGxhdG9yVHlwZSAhPSBcImN1c3RvbVwiKSB7XHJcbi8vICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci50eXBlID0gdGhpcy5vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgIGlmICghdGhpcy5vc2NpbGxhdG9yV2F2ZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnNldFBlcmlvZGljV2F2ZSh0aGlzLm9zY2lsbGF0b3JXYXZlKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldE9zY2lsbGF0b3JUeXBlKCk6IE9TQ0lMTEFUT1JfVFlQRSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGNyZWF0ZVBlcmlvZGljV2F2ZShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX3JlYWw6IE9zY2lsbGF0b3JXYXZlLCBfaW1hZzogT3NjaWxsYXRvcldhdmUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgbGV0IHdhdmVSZWFsOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4vLyAgICAgICAgICAgICB3YXZlUmVhbFswXSA9IF9yZWFsLnN0YXJ0cG9pbnQ7XHJcbi8vICAgICAgICAgICAgIHdhdmVSZWFsWzFdID0gX3JlYWwuZW5kcG9pbnQ7XHJcblxyXG4vLyAgICAgICAgICAgICBsZXQgd2F2ZUltYWc6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbi8vICAgICAgICAgICAgIHdhdmVJbWFnWzBdID0gX2ltYWcuc3RhcnRwb2ludDtcclxuLy8gICAgICAgICAgICAgd2F2ZUltYWdbMV0gPSBfaW1hZy5lbmRwb2ludDtcclxuXHJcbi8vICAgICAgICAgICAgIHRoaXMub3NjaWxsYXRvcldhdmUgPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVQZXJpb2RpY1dhdmUod2F2ZVJlYWwsIHdhdmVJbWFnKTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRMb2NhbEdhaW4oX2xvY2FsR2FpbjogR2Fpbk5vZGUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4gPSBfbG9jYWxHYWluO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldExvY2FsR2FpbigpOiBHYWluTm9kZSB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsR2FpbjtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRMb2NhbEdhaW5WYWx1ZShfbG9jYWxHYWluVmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpblZhbHVlID0gX2xvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLnZhbHVlID0gdGhpcy5sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRMb2NhbEdhaW5WYWx1ZSgpOiBudW1iZXIge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBzZXRGcmVxdWVuY3koX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9mcmVxdWVuY3k6IG51bWJlcik6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IF9mcmVxdWVuY3k7XHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSh0aGlzLmZyZXF1ZW5jeSwgX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWUpO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldEZyZXF1ZW5jeSgpOiBudW1iZXIge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5mcmVxdWVuY3k7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgY3JlYXRlU25hcmUoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRPc2NpbGxhdG9yVHlwZShcInRyaWFuZ2xlXCIpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldEZyZXF1ZW5jeShfYXVkaW9TZXR0aW5ncywgMTAwKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRMb2NhbEdhaW5WYWx1ZSgwKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSk7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSgwLjAxLCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSArIC4xKTtcclxuXHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5sb2NhbEdhaW4pO1xyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gfSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVGltZS9Mb29wLnRzXCIvPlxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9BbmltYXRpb24vQW5pbWF0aW9uLnRzXCIvPlxuXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICAvKipcbiAgICogSG9sZHMgYSByZWZlcmVuY2UgdG8gYW4ge0BsaW5rIEFuaW1hdGlvbn0gYW5kIGNvbnRyb2xzIGl0LiBDb250cm9scyBxdWFudGl6YXRpb24gYW5kIHBsYXltb2RlIGFzIHdlbGwgYXMgc3BlZWQuXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjJcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBbmltYXRvciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEFuaW1hdG9yKTtcbiAgICAvL1RPRE86IGFkZCBmdW5jdGlvbmFsaXR5IHRvIGJsZW5kIGZyb20gb25lIGFuaW1hdGlvbiB0byBhbm90aGVyLlxuICAgIHB1YmxpYyBhbmltYXRpb246IEFuaW1hdGlvbjtcbiAgICBwdWJsaWMgcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERTtcbiAgICBwdWJsaWMgcXVhbnRpemF0aW9uOiBBTklNQVRJT05fUVVBTlRJWkFUSU9OO1xuICAgIHB1YmxpYyBzY2FsZVdpdGhHYW1lVGltZTogYm9vbGVhbiA9IHRydWU7XG4gICAgcHVibGljIGFuaW1hdGVJbkVkaXRvcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgI3NjYWxlOiBudW1iZXIgPSAxO1xuICAgICN0aW1lTG9jYWw6IFRpbWU7XG4gICAgI3ByZXZpb3VzOiBudW1iZXIgPSAwO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9hbmltYXRpb24/OiBBbmltYXRpb24sIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFID0gQU5JTUFUSU9OX1BMQVlNT0RFLkxPT1AsIF9xdWFudGl6YXRpb246IEFOSU1BVElPTl9RVUFOVElaQVRJT04gPSBBTklNQVRJT05fUVVBTlRJWkFUSU9OLkNPTlRJTk9VUykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucGxheW1vZGUgPSBfcGxheW1vZGU7XG4gICAgICB0aGlzLnF1YW50aXphdGlvbiA9IF9xdWFudGl6YXRpb247XG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IF9hbmltYXRpb247XG5cbiAgICAgIHRoaXMuI3RpbWVMb2NhbCA9IG5ldyBUaW1lKCk7XG5cbiAgICAgIC8vVE9ETzogdXBkYXRlIGFuaW1hdGlvbiB0b3RhbCB0aW1lIHdoZW4gbG9hZGluZyBhIGRpZmZlcmVudCBhbmltYXRpb24/XG4gICAgICB0aGlzLmFuaW1hdGlvbj8uY2FsY3VsYXRlVG90YWxUaW1lKCk7XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCAoKSA9PiB0aGlzLmFjdGl2YXRlKGZhbHNlKSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DSElMRF9SRU1PVkUsICgpID0+IHRoaXMuYWN0aXZhdGUoZmFsc2UpKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgc2NhbGUoX3NjYWxlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NjYWxlID0gX3NjYWxlO1xuICAgICAgdGhpcy51cGRhdGVTY2FsZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc2NhbGUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNzY2FsZTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogLSBnZXQ6IHJldHVybiB0aGUgY3VycmVudCBzYW1wbGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uICBcbiAgICAgKiAtIHNldDoganVtcCB0byBhIGNlcnRhaW4gc2FtcGxlIHRpbWUgaW4gdGhlIGFuaW1hdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGltZSgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3RpbWVMb2NhbC5nZXQoKSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHRpbWUoX3RpbWU6IG51bWJlcikge1xuICAgICAgdGhpcy5qdW1wVG8oX3RpbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgIHN1cGVyLmFjdGl2YXRlKF9vbik7XG4gICAgICBpZiAoIXRoaXMubm9kZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB0aGlzLmFjdGl2YXRlTGlzdGVuZXJzKF9vbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSnVtcHMgdG8gYSBjZXJ0YWluIHRpbWUgaW4gdGhlIGFuaW1hdGlvbiB0byBwbGF5IGZyb20gdGhlcmUuXG4gICAgICovXG4gICAgcHVibGljIGp1bXBUbyhfdGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLiN0aW1lTG9jYWwuc2V0KF90aW1lKTtcbiAgICAgIHRoaXMuI3ByZXZpb3VzID0gX3RpbWU7XG4gICAgICBfdGltZSA9IF90aW1lICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lO1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB0aGlzLmFuaW1hdGlvbi5nZXRTdGF0ZShfdGltZSwgdGhpcy5hbmltYXRpb24uY2FsY3VsYXRlRGlyZWN0aW9uKF90aW1lLCB0aGlzLnBsYXltb2RlKSwgdGhpcy5xdWFudGl6YXRpb24pO1xuICAgICAgdGhpcy5ub2RlLmFwcGx5QW5pbWF0aW9uKG11dGF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1bXBzIHRvIGEgY2VydGFpbiBsYWJlbCBpbiB0aGUgYW5pbWF0aW9uIGlmIGRlZmluZWRcbiAgICAgKi9cbiAgICBwdWJsaWMganVtcFRvTGFiZWwoX2xhYmVsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGxldCB0aW1lOiBudW1iZXIgPSB0aGlzLmFuaW1hdGlvbi5sYWJlbHNbX2xhYmVsXTtcbiAgICAgIGlmICh0aW1lKVxuICAgICAgICB0aGlzLmp1bXBUbyh0aW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgYW4gdXBkYXRlIG9mIHRoZSBhbmltYXRpb24gZnJvbSBvdXRzaWRlLiBVc2VkIGluIHRoZSBWaWV3QW5pbWF0aW9uLiBTaG91bGRuJ3QgYmUgdXNlZCBkdXJpbmcgdGhlIGdhbWUuXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSAodW5zY2FsZWQpIHRpbWUgdG8gdXBkYXRlIHRoZSBhbmltYXRpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB0aGUgTXV0YXRvciBmb3IgQW5pbWF0aW9uLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlQW5pbWF0aW9uKF90aW1lOiBudW1iZXIpOiBNdXRhdG9yIHtcbiAgICAgIHRoaXMuI3ByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQW5pbWF0aW9uTG9vcChudWxsLCBfdGltZSk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICBzZXJpYWxpemF0aW9uLmlkQW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb24uaWRSZXNvdXJjZTtcbiAgICAgIHNlcmlhbGl6YXRpb24ucGxheW1vZGUgPSB0aGlzLnBsYXltb2RlO1xuICAgICAgc2VyaWFsaXphdGlvbi5xdWFudGl6YXRpb24gPSB0aGlzLnF1YW50aXphdGlvbjtcbiAgICAgIHNlcmlhbGl6YXRpb24uc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgc2VyaWFsaXphdGlvbi5zY2FsZVdpdGhHYW1lVGltZSA9IHRoaXMuc2NhbGVXaXRoR2FtZVRpbWU7XG4gICAgICBzZXJpYWxpemF0aW9uLmFuaW1hdGVJbkVkaXRvciA9IHRoaXMuYW5pbWF0ZUluRWRpdG9yO1xuXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgdGhpcy5hbmltYXRpb24gPSA8QW5pbWF0aW9uPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRBbmltYXRpb24pO1xuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9zZXJpYWxpemF0aW9uLnBsYXltb2RlO1xuICAgICAgdGhpcy5xdWFudGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbi5xdWFudGl6YXRpb247XG4gICAgICB0aGlzLnNjYWxlID0gX3NlcmlhbGl6YXRpb24uc2NhbGU7XG4gICAgICB0aGlzLnNjYWxlV2l0aEdhbWVUaW1lID0gX3NlcmlhbGl6YXRpb24uc2NhbGVXaXRoR2FtZVRpbWU7XG4gICAgICB0aGlzLmFuaW1hdGVJbkVkaXRvciA9IF9zZXJpYWxpemF0aW9uLmFuaW1hdGVJbkVkaXRvcjtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLmFuaW1hdGVJbkVkaXRvcikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb24oMCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVMaXN0ZW5lcnModGhpcy5hY3RpdmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xuICAgICAgaWYgKHR5cGVzLnBsYXltb2RlKVxuICAgICAgICB0eXBlcy5wbGF5bW9kZSA9IEFOSU1BVElPTl9QTEFZTU9ERTtcbiAgICAgIGlmICh0eXBlcy5xdWFudGl6YXRpb24pXG4gICAgICAgIHR5cGVzLnF1YW50aXphdGlvbiA9IEFOSU1BVElPTl9RVUFOVElaQVRJT047XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgcHJpdmF0ZSBhY3RpdmF0ZUxpc3RlbmVycyhfb246IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgIGlmIChfb24gJiYgKFByb2plY3QubW9kZSAhPSBNT0RFLkVESVRPUiB8fCBQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IgJiYgdGhpcy5hbmltYXRlSW5FZGl0b3IpKSB7XG4gICAgICAgIFRpbWUuZ2FtZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlRJTUVfU0NBTEVELCB0aGlzLnVwZGF0ZVNjYWxlKTtcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlQW5pbWF0aW9uTG9vcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUaW1lLmdhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5USU1FX1NDQUxFRCwgdGhpcy51cGRhdGVTY2FsZSk7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vI3JlZ2lvbiB1cGRhdGVBbmltYXRpb25cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBBbmltYXRpb24uXG4gICAgICogVXNlcyB0aGUgYnVpbHQtaW4gdGltZSB1bmxlc3MgYSBkaWZmZXJlbnQgdGltZSBpcyBzcGVjaWZpZWQuXG4gICAgICogTWF5IGFsc28gYmUgY2FsbGVkIGZyb20gdXBkYXRlQW5pbWF0aW9uKCkuXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVBbmltYXRpb25Mb29wID0gKF9lOiBFdmVudCwgX3RpbWU/OiBudW1iZXIpOiBNdXRhdG9yID0+IHtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUgPT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGxldCB0aW1lOiBudW1iZXIgPSBfdGltZSB8fCBfdGltZSA9PT0gMCA/IF90aW1lIDogdGhpcy4jdGltZUxvY2FsLmdldCgpO1xuICAgICAgaWYgKHRoaXMucXVhbnRpemF0aW9uID09IEFOSU1BVElPTl9RVUFOVElaQVRJT04uRlJBTUVTKSB7XG4gICAgICAgIHRpbWUgPSB0aGlzLiNwcmV2aW91cyArICgxMDAwIC8gdGhpcy5hbmltYXRpb24uZnBzKTtcbiAgICAgIH1cbiAgICAgIGxldCBkaXJlY3Rpb246IG51bWJlciA9IHRoaXMuYW5pbWF0aW9uLmNhbGN1bGF0ZURpcmVjdGlvbih0aW1lLCB0aGlzLnBsYXltb2RlKTtcbiAgICAgIHRpbWUgPSB0aGlzLmFuaW1hdGlvbi5nZXRNb2RhbFRpbWUodGltZSwgdGhpcy5wbGF5bW9kZSwgdGhpcy4jdGltZUxvY2FsLmdldE9mZnNldCgpKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUV2ZW50cyh0aGlzLmFuaW1hdGlvbi5nZXRFdmVudHNUb0ZpcmUodGhpcy4jcHJldmlvdXMsIHRpbWUsIHRoaXMucXVhbnRpemF0aW9uLCBkaXJlY3Rpb24pKTtcblxuICAgICAgaWYgKHRoaXMuI3ByZXZpb3VzICE9IHRpbWUpIHtcbiAgICAgICAgdGhpcy4jcHJldmlvdXMgPSB0aW1lO1xuICAgICAgICB0aW1lID0gdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcbiAgICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB0aGlzLmFuaW1hdGlvbi5nZXRTdGF0ZSh0aW1lLCBkaXJlY3Rpb24sIHRoaXMucXVhbnRpemF0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgIHRoaXMubm9kZS5hcHBseUFuaW1hdGlvbihtdXRhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyBhbGwgY3VzdG9tIGV2ZW50cyB0aGUgQW5pbWF0aW9uIHNob3VsZCBoYXZlIGZpcmVkIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxuICAgICAqIEBwYXJhbSBfZXZlbnRzIGEgbGlzdCBvZiBuYW1lcyBvZiBjdXN0b20gZXZlbnRzIHRvIGZpcmVcbiAgICAgKi9cbiAgICBwcml2YXRlIGV4ZWN1dGVFdmVudHMoX2V2ZW50czogc3RyaW5nW10pOiB2b2lkIHtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoX2V2ZW50c1tpXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNjYWxlIG9mIHRoZSBhbmltYXRpb24gaWYgdGhlIHVzZXIgY2hhbmdlcyBpdCBvciBpZiB0aGUgZ2xvYmFsIGdhbWUgdGltZXIgY2hhbmdlZCBpdHMgc2NhbGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVTY2FsZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGxldCBuZXdTY2FsZTogbnVtYmVyID0gdGhpcy4jc2NhbGU7XG4gICAgICBpZiAodGhpcy5zY2FsZVdpdGhHYW1lVGltZSlcbiAgICAgICAgbmV3U2NhbGUgKj0gVGltZS5nYW1lLmdldFNjYWxlKCk7XG4gICAgICB0aGlzLiN0aW1lTG9jYWwuc2V0U2NhbGUobmV3U2NhbGUpO1xuICAgIH07XG4gICAgLy8jZW5kcmVnaW9uXG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgZXhwb3J0IGVudW0gQVVESU9fUEFOTkVSIHtcclxuICAgIENPTkVfSU5ORVJfQU5HTEUgPSBcImNvbmVJbm5lckFuZ2xlXCIsXHJcbiAgICBDT05FX09VVEVSX0FOR0xFID0gXCJjb25lT3V0ZXJBbmdsZVwiLFxyXG4gICAgQ09ORV9PVVRFUl9HQUlOID0gXCJjb25lT3V0ZXJHYWluXCIsXHJcbiAgICBESVNUQU5DRV9NT0RFTCA9IFwiZGlzdGFuY2VNb2RlbFwiLFxyXG4gICAgTUFYX0RJU1RBTkNFID0gXCJtYXhEaXN0YW5jZVwiLFxyXG4gICAgUEFOTklOR19NT0RFTCA9IFwicGFubmluZ01vZGVsXCIsXHJcbiAgICBSRUZfRElTVEFOQ0UgPSBcInJlZkRpc3RhbmNlXCIsXHJcbiAgICBST0xMT0ZGX0ZBQ1RPUiA9IFwicm9sbG9mZkZhY3RvclwiXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBBVURJT19OT0RFX1RZUEUge1xyXG4gICAgU09VUkNFLCBQQU5ORVIsIEdBSU5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhIG1pbmltYWwgYXVkaW8gZ3JhcGggKGJ5IGRlZmF1bHQgaW4ge0BsaW5rIEF1ZGlvTWFuYWdlcn0uZGVmYXVsdCkgYW5kIHN5bmNocm9uaXplcyBpdCB3aXRoIHRoZSBjb250YWluaW5nIHtAbGluayBOb2RlfVxyXG4gICAqIGBgYHRleHRcclxuICAgKiDilIwgQXVkaW9NYW5hZ2VyKC5kZWZhdWx0KSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiDilIIg4pSMIENvbXBvbmVudEF1ZGlvIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIJcclxuICAgKiDilIIg4pSCICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiAgXHJcbiAgICog4pSCIOKUgiAgICDilIJzb3VyY2XilIIg4oaSIOKUgnBhbm5lcuKUgiDihpIg4pSCIGdhaW4g4pSCIOKGkiDilIIgZ2FpbiDilIIg4pSCXHJcbiAgICog4pSCIOKUgiAgICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIgIFxyXG4gICAqIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSCXHJcbiAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QXVkaW8gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEF1ZGlvKTtcclxuICAgIC8qKiBwbGFjZXMgYW5kIGRpcmVjdHMgdGhlIHBhbm5lciByZWxhdGl2ZSB0byB0aGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSB7QGxpbmsgTm9kZX0gICovXHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwcml2YXRlIGF1ZGlvOiBBdWRpbztcclxuICAgIHByaXZhdGUgZ2FpbjogR2Fpbk5vZGU7XHJcbiAgICBwcml2YXRlIHBhbm5lcjogUGFubmVyTm9kZTtcclxuICAgIHByaXZhdGUgc291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XHJcbiAgICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xyXG4gICAgcHJpdmF0ZSBwbGF5aW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIGxpc3RlbmVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9hdWRpbzogQXVkaW8gPSBudWxsLCBfbG9vcDogYm9vbGVhbiA9IGZhbHNlLCBfc3RhcnQ6IGJvb2xlYW4gPSBmYWxzZSwgX2F1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5pbnN0YWxsKF9hdWRpb01hbmFnZXIpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShfYXVkaW8sIF9sb29wKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcblxyXG4gICAgICBpZiAoX3N0YXJ0KVxyXG4gICAgICAgIHRoaXMucGxheShfc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgdm9sdW1lKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdm9sdW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGxvb3AoX29uOiBib29sZWFuKSB7XHJcbiAgICAgIHRoaXMuc291cmNlLmxvb3AgPSBfb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBsb29wKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UubG9vcDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHBsYXliYWNrUmF0ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBwbGF5YmFja1JhdGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGdldCBpc1BsYXlpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBsYXlpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0F0dGFjaGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5ub2RlICE9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0xpc3RlbmVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdpdmVuIHtAbGluayBBdWRpb30gYXMgdGhlIGF1ZGlvIHNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0QXVkaW8oX2F1ZGlvOiBBdWRpbyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShfYXVkaW8sIHRoaXMuc291cmNlLmxvb3ApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIEF1ZGlvfSBjdXJyZW50bHkgdXNlZCBhcyBhdWRpbyBzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEF1ZGlvKCk6IEF1ZGlvIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXVkaW87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHByb3BlcnR5IG9mIHRoZSBwYW5uZXIgdG8gdGhlIGdpdmVuIHZhbHVlLiBVc2UgdG8gbWFuaXB1bGF0ZSByYW5nZSBhbmQgcm9sbG9mZiBldGMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQYW5uZXIoX3Byb3BlcnR5OiBBVURJT19QQU5ORVIsIF92YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlZmxlY3Quc2V0KHRoaXMucGFubmVyLCBfcHJvcGVydHksIF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogbWF5IGJlIHVzZWQgZm9yIHNlcmlhbGl6YXRpb24gb2YgQXVkaW9Ob2Rlc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtdXRhdG9yIGZvciB0aGUgc3BlY2lmaWVkIEF1ZGlvTm9kZSBvZiB0aGUgc3RhbmRhcmQgZ3JhcGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JPZk5vZGUoX3R5cGU6IEFVRElPX05PREVfVFlQRSk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbm9kZTogQXVkaW9Ob2RlID0gdGhpcy5nZXRBdWRpb05vZGUoX3R5cGUpO1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IGdldE11dGF0b3JPZkFyYml0cmFyeShub2RlKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgQXVkaW9Ob2RlIG9mIHRoZSBzdGFuZGFyZCBncmFwaCBmb3IgZnVydGhlciBtYW5pcHVsYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEF1ZGlvTm9kZShfdHlwZTogQVVESU9fTk9ERV9UWVBFKTogQXVkaW9Ob2RlIHtcclxuICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLlNPVVJDRTogcmV0dXJuIHRoaXMuc291cmNlO1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLlBBTk5FUjogcmV0dXJuIHRoaXMucGFubmVyO1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLkdBSU46IHJldHVybiB0aGlzLmdhaW47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IG9yIHN0b3AgcGxheWluZyB0aGUgYXVkaW9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHBsYXkoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfb24pIHtcclxuICAgICAgICBpZiAodGhpcy5hdWRpby5pc1JlYWR5KSB7XHJcbiAgICAgICAgICB0aGlzLmNyZWF0ZVNvdXJjZSh0aGlzLmF1ZGlvLCB0aGlzLnNvdXJjZS5sb29wLCB0aGlzLnBsYXliYWNrUmF0ZSk7XHJcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zdGFydCgwLCAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5hdWRpby5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlJFQURZLCB0aGlzLmhuZEF1ZGlvUmVhZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkVOREVELCB0aGlzLmhuZEF1ZGlvRW5kZWQpO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcjogdW5rbm93bikgeyAvKiBjYXRjaCBleGNlcHRpb24gd2hlbiBzb3VyY2UgaGFzbid0IGJlZW4gc3RhcnRlZC4uLiAqLyB9XHJcbiAgICAgIHRoaXMucGxheWluZyA9IF9vbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgQXVkaW9Ob2RlcyBiZXR3ZWVuIHRoZSBwYW5uZXIgYW5kIHRoZSBsb2NhbCBnYWluIG9mIHRoaXMge0BsaW5rIENvbXBvbmVudEF1ZGlvfVxyXG4gICAgICogX2lucHV0IGFuZCBfb3V0cHV0IG1heSBiZSB0aGUgc2FtZSBBdWRpb05vZGUsIGlmIHRoZXJlIGlzIG9ubHkgb25lIHRvIGluc2VydCxcclxuICAgICAqIG9yIG1heSBoYXZlIG11bHRpcGxlIEF1ZGlvTm9kZSBiZXR3ZWVuIHRoZW0gdG8gY3JlYXRlIGFuIGVmZmVjdC1ncmFwaC5cXFxyXG4gICAgICogTm90ZSB0aGF0IHtAbGluayBDb21wb25lbnRBdWRpb30gZG9lcyBub3Qga2VlcCB0cmFjayBvZiBpbnNlcnRlZCBBdWRpb05vZGVzIVxyXG4gICAgICogYGBgdGV4dFxyXG4gICAgICog4pSMIEF1ZGlvTWFuYWdlciguZGVmYXVsdCkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICAgKiDilIIg4pSMIENvbXBvbmVudEF1ZGlvIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIJcclxuICAgICAqIOKUgiDilIIgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiAgXHJcbiAgICAgKiDilIIg4pSCICAgIOKUgnNvdXJjZeKUgiDihpIg4pSCcGFubmVy4pSCIOKGkiDilIJfaW5wdXTilIIg4oaSIC4uLiAg4oaSIOKUgl9vdXRwdXTilIIg4oaSIOKUgiBnYWluIOKUgiDihpIg4pSCIGdhaW4g4pSCIOKUglxyXG4gICAgICog4pSCIOKUgiAgICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCICBcclxuICAgICAqIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSCXHJcbiAgICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5zZXJ0QXVkaW9Ob2RlcyhfaW5wdXQ6IEF1ZGlvTm9kZSwgX291dHB1dDogQXVkaW9Ob2RlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucGFubmVyLmRpc2Nvbm5lY3QoMCk7XHJcbiAgICAgIGlmICghX2lucHV0ICYmICFfb3V0cHV0KSB7XHJcbiAgICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnBhbm5lci5jb25uZWN0KF9pbnB1dCk7XHJcbiAgICAgIF9vdXRwdXQuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGUgb3ZlcnJpZGUuIENvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzIEF1ZGlvTm9kZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBzdXBlci5hY3RpdmF0ZShfb24pO1xyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3RzIHRoaXMgY29tcG9uZW50cyBnYWluLW5vZGUgdG8gdGhlIGdhaW4gbm9kZSBvZiB0aGUgQXVkaW9NYW5hZ2VyIHRoaXMgY29tcG9uZW50IHJ1bnMgb24uXHJcbiAgICAgKiBPbmx5IGNhbGwgdGhpcyBtZXRob2QgaWYgdGhlIGNvbXBvbmVudCBpcyBub3QgYXR0YWNoZWQgdG8gYSB7QGxpbmsgTm9kZX0gYnV0IG5lZWRzIHRvIGJlIGhlYXJkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29ubmVjdChfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbilcclxuICAgICAgICB0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmF1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFJlc291cmNlID0gdGhpcy5hdWRpby5pZFJlc291cmNlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnBsYXlpbmcgPSB0aGlzLnBsYXlpbmc7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ubG9vcCA9IHRoaXMubG9vcDtcclxuICAgICAgc2VyaWFsaXphdGlvbi52b2x1bWUgPSB0aGlzLnZvbHVtZTtcclxuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5nZXRNdXRhdG9yT2ZOb2RlKEFVRElPX05PREVfVFlQRS5QQU5ORVIpKTtcclxuICAgICAgLy8gVE9ETzogc2VyaWFsaXplIHBhbm5lciBwYXJhbWV0ZXJzXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBsZXQgYXVkaW86IEF1ZGlvID0gPEF1ZGlvPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKGF1ZGlvLCBfc2VyaWFsaXphdGlvbi5sb29wKTtcclxuICAgICAgdGhpcy52b2x1bWUgPSBfc2VyaWFsaXphdGlvbi52b2x1bWU7XHJcbiAgICAgIHRoaXMucGxheShfc2VyaWFsaXphdGlvbi5wbGF5aW5nKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuICAgICAgbGV0IGF1ZGlvOiBNdXRhdG9yID0gbXV0YXRvci5hdWRpbztcclxuICAgICAgZGVsZXRlIG11dGF0b3IuYXVkaW87IC8vIGp1c3QgdG8gcmVhcnJhbmdlIGluIGludGVyZmFjZXMuLi5cclxuICAgICAgbXV0YXRvci5sb29wID0gdGhpcy5sb29wO1xyXG4gICAgICBtdXRhdG9yLnZvbHVtZSA9IHRoaXMudm9sdW1lO1xyXG4gICAgICBtdXRhdG9yLmF1ZGlvID0gYXVkaW87IC8vLi4uIHNvIGF1ZGlvIGNvbWVzIGxhc3RcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgLy8gICAvLyB0aGlzLnZvbHVtZSA9IF9tdXRhdG9yLnZvbHVtZTtcclxuICAgIC8vICAgLy8gdGhpcy5sb29wID0gX211dGF0b3IubG9vcDtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmxpc3RlbmVkO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIHByaXZhdGUgaG5kQXVkaW9SZWFkeTogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiQXVkaW8gc3RhcnRcIiwgUmVmbGVjdC5nZXQoX2V2ZW50LnRhcmdldCwgXCJ1cmxcIikpO1xyXG4gICAgICBpZiAodGhpcy5wbGF5aW5nKVxyXG4gICAgICAgIHRoaXMucGxheSh0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBobmRBdWRpb0VuZGVkOiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgLy8gRGVidWcuZnVkZ2UoXCJBdWRpbyBlbmRlZFwiLCBSZWZsZWN0LmdldChfZXZlbnQudGFyZ2V0LCBcInVybFwiKSk7XHJcbiAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGluc3RhbGwoX2F1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQpOiB2b2lkIHtcclxuICAgICAgbGV0IGFjdGl2ZTogYm9vbGVhbiA9IHRoaXMuaXNBY3RpdmU7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoZmFsc2UpO1xyXG4gICAgICB0aGlzLmF1ZGlvTWFuYWdlciA9IF9hdWRpb01hbmFnZXI7XHJcbiAgICAgIHRoaXMucGFubmVyID0gX2F1ZGlvTWFuYWdlci5jcmVhdGVQYW5uZXIoKTtcclxuICAgICAgdGhpcy5nYWluID0gX2F1ZGlvTWFuYWdlci5jcmVhdGVHYWluKCk7XHJcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5nYWluKTtcclxuICAgICAgdGhpcy5nYWluLmNvbm5lY3QoX2F1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgICAgdGhpcy5hY3RpdmF0ZShhY3RpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlU291cmNlKF9hdWRpbzogQXVkaW8sIF9sb29wOiBib29sZWFuLCBfcGxheWJhY2tSYXRlOiBudW1iZXIgPSAxLjApOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHRoaXMuc291cmNlLmJ1ZmZlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLmF1ZGlvTWFuYWdlci5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLnBhbm5lcik7XHJcblxyXG4gICAgICBpZiAoX2F1ZGlvKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpbyA9IF9hdWRpbztcclxuICAgICAgICB0aGlzLnNvdXJjZS5idWZmZXIgPSBfYXVkaW8uYnVmZmVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNvdXJjZS5sb29wID0gX2xvb3A7XHJcbiAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gX3BsYXliYWNrUmF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZUNvbm5lY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0KHRoaXMuaXNBY3RpdmUgJiYgdGhpcy5pc0F0dGFjaGVkICYmIHRoaXMubGlzdGVuZWQpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICAvLyBub3BcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgY29ubmVjdHMvZGlzY29ubmVjdHMgQXVkaW9Ob2RlcyB3aGVuIGFkZGluZy9yZW1vdmluZyB0aGlzIGNvbXBvbmVudCB0by9mcm9tIGEgbm9kZS4gXHJcbiAgICAgKiBUaGVyZWZvcmUgdW51c2VkIEF1ZGlvTm9kZXMgbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkIHdoZW4gYW4gdW51c2VkIGNvbXBvbmVudCBpcyBjb2xsZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVBdHRhY2ggPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coX2V2ZW50KTtcclxuICAgICAgaWYgKF9ldmVudC50eXBlID09IEVWRU5ULkNPTVBPTkVOVF9BREQpIHtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uVVBEQVRFLCB0aGlzLnVwZGF0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lZCA9IHRoaXMubm9kZS5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfUkVNT1ZFLCB0aGlzLmhhbmRsZUdyYXBoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5VUERBVEUsIHRoaXMudXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgY29ubmVjdHMvZGlzY29ubmVjdHMgQXVkaW9Ob2RlcyB3aGVuIGFwcGVuZGluZy9yZW1vdmluZyB0aGUgRlVER0UtZ3JhcGggdGhlIGNvbXBvbmVudCBpcyBpbi4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGFuZGxlR3JhcGggPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coX2V2ZW50KTtcclxuICAgICAgdGhpcy5saXN0ZW5lZCA9IChfZXZlbnQudHlwZSA9PSBFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVXBkYXRlcyB0aGUgcGFubmVyIG5vZGUsIGl0cyBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uLCB1c2luZyB0aGUgd29ybGRtYXRyaXggb2YgdGhlIGNvbnRhaW5lciBhbmQgdGhlIHBpdm90IG9mIHRoaXMgY29tcG9uZW50LiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGUgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLm10eFBpdm90O1xyXG4gICAgICBpZiAodGhpcy5ub2RlKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50b1N0cmluZygpKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4UmVzdWx0LnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgZm9yd2FyZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5aKDEpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWi52YWx1ZSA9IHBvc2l0aW9uLno7XHJcblxyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblgudmFsdWUgPSBmb3J3YXJkLng7XHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWS52YWx1ZSA9IGZvcndhcmQueTtcclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25aLnZhbHVlID0gZm9yd2FyZC56O1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZm9yd2FyZCk7XHJcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUgd2h5IHRoZSBmb2xsb3dpbmcgcHJvZHVjZXMgZXJyb25lb3VzIHJlc3VsdHMsIHNlZSB0ZXN0IFwiU3BhdGlhbCBBdWRpb1wiXHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU2VydmVzIHRvIHNldCB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgQXVkaW9MaXN0ZW5lcnMgcmVsYXRpdmUgdG8gdGhlXHJcbiAgICogd29ybGQgdHJhbnNmb3JtIG9mIHRoZSB7QGxpbmsgTm9kZX0gaXQgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QXVkaW9MaXN0ZW5lciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QXVkaW9MaXN0ZW5lcik7XHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBnaXZlbiBBdWRpb0xpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGUoX2xpc3RlbmVyOiBBdWRpb0xpc3RlbmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IHRoaXMubXR4UGl2b3Q7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMubm9kZS5tdHhXb3JsZCwgdGhpcy5tdHhQaXZvdCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRvU3RyaW5nKCkpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBtdHhSZXN1bHQudHJhbnNsYXRpb247XHJcbiAgICAgIGxldCBmb3J3YXJkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlooMSksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICBsZXQgdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKFZlY3RvcjMuWSgpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgaWYgKF9saXN0ZW5lci5wb3NpdGlvblggIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWi52YWx1ZSA9IHBvc2l0aW9uLno7XHJcblxyXG4gICAgICAgIF9saXN0ZW5lci5mb3J3YXJkWC52YWx1ZSA9IGZvcndhcmQueDtcclxuICAgICAgICBfbGlzdGVuZXIuZm9yd2FyZFkudmFsdWUgPSBmb3J3YXJkLnk7XHJcbiAgICAgICAgX2xpc3RlbmVyLmZvcndhcmRaLnZhbHVlID0gZm9yd2FyZC56O1xyXG5cclxuICAgICAgICBfbGlzdGVuZXIudXBYLnZhbHVlID0gdXAueDtcclxuICAgICAgICBfbGlzdGVuZXIudXBZLnZhbHVlID0gdXAueTtcclxuICAgICAgICBfbGlzdGVuZXIudXBaLnZhbHVlID0gdXAuejtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBGaXJlZm94IHN0aWxsIHVzZXMgZGVwcmVjYXRlZCBtZXRob2RzLiBUT0RPOiBkZWxldGUgYXMgc29vbiBhcyBwb3NzaWJsZSFcclxuICAgICAgICBfbGlzdGVuZXIuc2V0UG9zaXRpb24ocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XHJcbiAgICAgICAgX2xpc3RlbmVyLnNldE9yaWVudGF0aW9uKGZvcndhcmQueCwgZm9yd2FyZC55LCBmb3J3YXJkLnosIHVwLngsIHVwLnksIHVwLnopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShmb3J3YXJkKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodXApO1xyXG4gICAgICBpZiAodGhpcy5ub2RlKVxyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRyYW5zbGF0aW9uLnRvU3RyaW5nKCksIGZvcndhcmQudG9TdHJpbmcoKSwgdXAudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiQ29tcG9uZW50LnRzXCIvPlxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBlbnVtIEZJRUxEX09GX1ZJRVcge1xuICAgIEhPUklaT05UQUwgPSBcImhvcml6b250YWxcIixcbiAgICBWRVJUSUNBTCA9IFwidmVydGljYWxcIixcbiAgICBESUFHT05BTCA9IFwiZGlhZ29uYWxcIlxuICB9XG4gIC8qKlxuICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyBwcm9qZWN0aW9ucyBhIGNhbWVyYSBjYW4gcHJvdmlkZS4gIFxuICAgKiBUT0RPOiBjaGFuZ2UgYmFjayB0byBudW1iZXIgZW51bSBpZiBzdHJpbmdzIG5vdCBuZWVkZWRcbiAgICovXG4gIGV4cG9ydCBlbnVtIFBST0pFQ1RJT04ge1xuICAgIENFTlRSQUwgPSBcImNlbnRyYWxcIixcbiAgICBPUlRIT0dSQVBISUMgPSBcIm9ydGhvZ3JhcGhpY1wiLFxuICAgIERJTUVUUklDID0gXCJkaW1ldHJpY1wiLFxuICAgIFNURVJFTyA9IFwic3RlcmVvXCJcbiAgfVxuICAvKipcbiAgICogVGhlIGNhbWVyYSBjb21wb25lbnQgaG9sZHMgdGhlIHByb2plY3Rpb24tbWF0cml4IGFuZCBvdGhlciBkYXRhIG5lZWRlZCB0byByZW5kZXIgYSBzY2VuZSBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiB0aGUgbm9kZSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudENhbWVyYSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudENhbWVyYSk7XG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcbiAgICBwdWJsaWMgY2xyQmFja2dyb3VuZDogQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7IC8vIFRoZSBjb2xvciBvZiB0aGUgYmFja2dyb3VuZCB0aGUgY2FtZXJhIHdpbGwgcmVuZGVyLlxuICAgIC8vcHJpdmF0ZSBvcnRob2dyYXBoaWM6IGJvb2xlYW4gPSBmYWxzZTsgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpbWFnZSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggcGVyc3BlY3RpdmUgb3Igb3J0aG9ncmFwaGljIHByb2plY3Rpb24uXG4gICAgcHJpdmF0ZSBwcm9qZWN0aW9uOiBQUk9KRUNUSU9OID0gUFJPSkVDVElPTi5DRU5UUkFMO1xuICAgIHByaXZhdGUgZmllbGRPZlZpZXc6IG51bWJlciA9IDQ1OyAvLyBUaGUgY2FtZXJhJ3Mgc2Vuc29yYW5nbGUuXG4gICAgcHJpdmF0ZSBhc3BlY3RSYXRpbzogbnVtYmVyID0gMS4wO1xuICAgIHByaXZhdGUgZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gRklFTERfT0ZfVklFVy5ESUFHT05BTDtcbiAgICBwcml2YXRlIG5lYXI6IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSBmYXI6IG51bWJlciA9IDIwMDA7XG4gICAgcHJpdmF0ZSBiYWNrZ3JvdW5kRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7IC8vIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGJhY2tncm91bmQgb2YgdGhpcyBjYW1lcmEgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiBiYWNrZ3JvdW5kIHNob3VsZCBiZSBhbiBhdHRyaWJ1dGUgb2YgQ2FtZXJhIG9yIFZpZXdwb3J0XG5cbiAgICAjbXR4V29ybGRUb1ZpZXc6IE1hdHJpeDR4NDtcbiAgICAjbXR4Q2FtZXJhSW52ZXJzZTogTWF0cml4NHg0O1xuICAgICNtdHhQcm9qZWN0aW9uOiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0OyAvLyBUaGUgbWF0cml4IHRvIG11bHRpcGx5IGVhY2ggc2NlbmUgb2JqZWN0cyB0cmFuc2Zvcm1hdGlvbiBieSwgdG8gZGV0ZXJtaW5lIHdoZXJlIGl0IHdpbGwgYmUgZHJhd24uXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW1lcmFzIHdvcmxkdHJhbnNmb3JtYXRpb24gbWF0cml4IGkuZS4gdGhlIHRyYW5zZm9ybWF0aW9uIHJlbGF0aXZlIHRvIHRoZSByb290IG9mIHRoZSBncmFwaFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbXR4V29ybGQoKTogTWF0cml4NHg0IHtcbiAgICAgIGxldCBtdHhDYW1lcmE6IE1hdHJpeDR4NCA9IHRoaXMubXR4UGl2b3QuY2xvbmU7XG4gICAgICB0cnkge1xuICAgICAgICBtdHhDYW1lcmEgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAvLyBubyBjb250YWluZXIgbm9kZSBvciBubyB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBmb3VuZCAtPiBjb250aW51ZSB3aXRoIHBpdm90IG9ubHlcbiAgICAgIH1cbiAgICAgIHJldHVybiBtdHhDYW1lcmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbXVsdGlwbGljYXRpb24gb2YgdGhlIHdvcmxkdHJhbnNmb3JtYXRpb24gb2YgdGhlIGNhbWVyYSBjb250YWluZXIsIHRoZSBwaXZvdCBvZiB0aGlzIGNhbWVyYSBhbmQgdGhlIGludmVyc2lvbiBvZiB0aGUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiB5aWVsZGluZyB0aGUgd29ybGRzcGFjZSB0byB2aWV3c3BhY2UgbWF0cml4XG4gICAgICovXG4gICAgcHVibGljIGdldCBtdHhXb3JsZFRvVmlldygpOiBNYXRyaXg0eDQge1xuICAgICAgaWYgKHRoaXMuI210eFdvcmxkVG9WaWV3KVxuICAgICAgICByZXR1cm4gdGhpcy4jbXR4V29ybGRUb1ZpZXc7XG5cbiAgICAgIC8vVE9ETzogb3B0aW1pemUsIG5vIG5lZWQgdG8gcmVjYWxjdWxhdGUgaWYgbmVpdGhlciBtdHhXb3JsZCBub3IgcGl2b3QgaGF2ZSBjaGFuZ2VkXG4gICAgICB0aGlzLiNtdHhXb3JsZFRvVmlldyA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLiNtdHhQcm9qZWN0aW9uLCB0aGlzLm10eENhbWVyYUludmVyc2UpO1xuICAgICAgcmV0dXJuIHRoaXMuI210eFdvcmxkVG9WaWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGludmVyc2lvbiBvZiB0aGlzIGNhbWVyYXMgd29ybGR0cmFuc2Zvcm1hdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbXR4Q2FtZXJhSW52ZXJzZSgpOiBNYXRyaXg0eDQge1xuICAgICAgaWYgKHRoaXMuI210eENhbWVyYUludmVyc2UpXG4gICAgICAgIHJldHVybiB0aGlzLiNtdHhDYW1lcmFJbnZlcnNlO1xuXG4gICAgICAvL1RPRE86IG9wdGltaXplLCBubyBuZWVkIHRvIHJlY2FsY3VsYXRlIGlmIG5laXRoZXIgbXR4V29ybGQgbm9yIHBpdm90IGhhdmUgY2hhbmdlZFxuICAgICAgdGhpcy4jbXR4Q2FtZXJhSW52ZXJzZSA9IE1hdHJpeDR4NC5JTlZFUlNJT04odGhpcy5tdHhXb3JsZCk7XG4gICAgICByZXR1cm4gdGhpcy4jbXR4Q2FtZXJhSW52ZXJzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9qZWN0aW9ubWF0cml4IG9mIHRoaXMgY2FtZXJhXG4gICAgICovXG4gICAgcHVibGljIGdldCBtdHhQcm9qZWN0aW9uKCk6IE1hdHJpeDR4NCB7XG4gICAgICBpZiAodGhpcy4jbXR4UHJvamVjdGlvbilcbiAgICAgICAgcmV0dXJuIHRoaXMuI210eFByb2plY3Rpb247XG5cbiAgICAgIC8vVE9ETzogb3B0aW1pemUsIG5vIG5lZWQgdG8gcmVjYWxjdWxhdGUgaWYgbmVpdGhlciBtdHhXb3JsZCBub3IgcGl2b3QgaGF2ZSBjaGFuZ2VkXG4gICAgICB0aGlzLiNtdHhQcm9qZWN0aW9uID0gbmV3IE1hdHJpeDR4NDtcbiAgICAgIHJldHVybiB0aGlzLiNtdHhQcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGlzIGNhbWVyYXMge0BsaW5rIG10eFdvcmxkVG9WaWV3fSBhbmQge0BsaW5rIG10eENhbWVyYUludmVyc2V9IG1hdHJpY2VzXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0V29ybGRUb1ZpZXcoKTogdm9pZCB7XG4gICAgICBpZiAodGhpcy4jbXR4V29ybGRUb1ZpZXcpIFJlY3ljbGVyLnN0b3JlKHRoaXMuI210eFdvcmxkVG9WaWV3KTtcbiAgICAgIGlmICh0aGlzLiNtdHhDYW1lcmFJbnZlcnNlKSBSZWN5Y2xlci5zdG9yZSh0aGlzLiNtdHhDYW1lcmFJbnZlcnNlKTtcbiAgICAgIHRoaXMuI210eFdvcmxkVG9WaWV3ID0gbnVsbDtcbiAgICAgIHRoaXMuI210eENhbWVyYUludmVyc2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMge0BsaW5rIFBST0pFQ1RJT059IG1vZGVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UHJvamVjdGlvbigpOiBQUk9KRUNUSU9OIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSBjYW1lcmEgc2hvdWxkIGJlIHJlbmRlcmVkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QmFja2dyb3VuZEVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kRW5hYmxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW1lcmFzIGFzcGVjdCByYXRpb1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBc3BlY3QoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzXG4gICAgICovXG4gICAgcHVibGljIGdldEZpZWxkT2ZWaWV3KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5maWVsZE9mVmlldztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW1lcmFzIGRpcmVjdGlvbiBpLmUuIHRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RGlyZWN0aW9uKCk6IEZJRUxEX09GX1ZJRVcge1xuICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgbmVhciB2YWx1ZSBpLmUuIHRoZSBtaW5pbXVtIGRpc3RhbmNlIHRvIHJlbmRlciBvYmplY3RzIGF0XG4gICAgICovXG4gICAgcHVibGljIGdldE5lYXIoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLm5lYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyBmYXIgdmFsdWUgaS5lLiB0aGUgbWF4aW11bSBkaXN0YW5jZSB0byByZW5kZXIgb2JqZWN0cyBhdFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRGYXIoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmZhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSB0byBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uLiBUaGUgd29ybGQgb3JpZ2luIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc2VsZW1lbnQuXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcbiAgICAgKiBAcGFyYW0gX2ZpZWxkT2ZWaWV3IFRoZSBmaWVsZCBvZiB2aWV3IGluIERlZ3JlZXMuIChEZWZhdWx0ID0gNDUpXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbiBcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvamVjdENlbnRyYWwoX2FzcGVjdDogbnVtYmVyID0gdGhpcy5hc3BlY3RSYXRpbywgX2ZpZWxkT2ZWaWV3OiBudW1iZXIgPSB0aGlzLmZpZWxkT2ZWaWV3LCBfZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gdGhpcy5kaXJlY3Rpb24sIF9uZWFyOiBudW1iZXIgPSB0aGlzLm5lYXIsIF9mYXI6IG51bWJlciA9IHRoaXMuZmFyKTogdm9pZCB7XG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gX2FzcGVjdDtcbiAgICAgIHRoaXMuZmllbGRPZlZpZXcgPSBfZmllbGRPZlZpZXc7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XG4gICAgICB0aGlzLm5lYXIgPSBfbmVhcjtcbiAgICAgIHRoaXMuZmFyID0gX2ZhcjtcbiAgICAgIHRoaXMuI210eFByb2plY3Rpb24gPSBNYXRyaXg0eDQuUFJPSkVDVElPTl9DRU5UUkFMKF9hc3BlY3QsIHRoaXMuZmllbGRPZlZpZXcsIF9uZWFyLCBfZmFyLCB0aGlzLmRpcmVjdGlvbik7IC8vIFRPRE86IHJlbW92ZSBtYWdpYyBudW1iZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYW1lcmEgdG8gb3J0aG9ncmFwaGljIHByb2plY3Rpb24uIERlZmF1bHQgdmFsdWVzIGFyZSBkZXJpdmVkIHRoZSBjYW52YXMgY2xpZW50IGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gX2xlZnQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGxlZnQgYm9yZGVyLiAgICBcbiAgICAgKiBAcGFyYW0gX3JpZ2h0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyByaWdodCBib3JkZXIuICBcbiAgICAgKiBAcGFyYW0gX2JvdHRvbSBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgYm90dG9tIGJvcmRlci5cbiAgICAgKiBAcGFyYW0gX3RvcCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgdG9wIGJvcmRlci4gICAgICBcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvamVjdE9ydGhvZ3JhcGhpYyhfbGVmdDogbnVtYmVyID0gLVJlbmRlci5nZXRDYW52YXMoKS5jbGllbnRXaWR0aCAvIDIsIF9yaWdodDogbnVtYmVyID0gUmVuZGVyLmdldENhbnZhcygpLmNsaWVudFdpZHRoIC8gMiwgX2JvdHRvbTogbnVtYmVyID0gUmVuZGVyLmdldENhbnZhcygpLmNsaWVudEhlaWdodCAvIDIsIF90b3A6IG51bWJlciA9IC1SZW5kZXIuZ2V0Q2FudmFzKCkuY2xpZW50SGVpZ2h0IC8gMik6IHZvaWQge1xuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gUFJPSkVDVElPTi5PUlRIT0dSQVBISUM7XG4gICAgICB0aGlzLiNtdHhQcm9qZWN0aW9uID0gTWF0cml4NHg0LlBST0pFQ1RJT05fT1JUSE9HUkFQSElDKF9sZWZ0LCBfcmlnaHQsIF9ib3R0b20sIF90b3AsIDQwMCwgLTQwMCk7IC8vIFRPRE86IGV4YW1pbmUgbWFnaWMgbnVtYmVycyFcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNhbGN1bGF0ZWQgZGltZW5zaW9uIG9mIGEgcHJvamVjdGlvbiBzdXJmYWNlIGluIHRoZSBoeXBvdGhldGljYWwgZGlzdGFuY2Ugb2YgMSB0byB0aGUgY2FtZXJhXG4gICAgICovXG4gICAgcHVibGljIGdldFByb2plY3Rpb25SZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcbiAgICAgIGxldCB0YW5Gb3Y6IG51bWJlciA9IE1hdGgudGFuKE1hdGguUEkgKiB0aGlzLmZpZWxkT2ZWaWV3IC8gMzYwKTsgLy8gSGFsZiBvZiB0aGUgYW5nbGUsIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb24gZnJvbSB0aGUgY2VudGVyIC0+IHJpZ2h0IGFuZ2xlXG4gICAgICBsZXQgdGFuSG9yaXpvbnRhbDogbnVtYmVyID0gMDtcbiAgICAgIGxldCB0YW5WZXJ0aWNhbDogbnVtYmVyID0gMDtcblxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IEZJRUxEX09GX1ZJRVcuRElBR09OQUwpIHtcbiAgICAgICAgbGV0IGFzcGVjdDogbnVtYmVyID0gTWF0aC5zcXJ0KHRoaXMuYXNwZWN0UmF0aW8pO1xuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuRm92ICogYXNwZWN0O1xuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdiAvIGFzcGVjdDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5WRVJUSUNBTCkge1xuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdjtcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhblZlcnRpY2FsICogdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgIH0gZWxzZSB7Ly9GT1ZfRElSRUNUSU9OLkhPUklaT05UQUxcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdjtcbiAgICAgICAgdGFuVmVydGljYWwgPSB0YW5Ib3Jpem9udGFsIC8gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGFuSG9yaXpvbnRhbCAqIDIsIHRhblZlcnRpY2FsICogMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB3b3JsZCBzcGFjZSB0byBjbGlwIHNwYWNlXG4gICAgICovXG4gICAgcHVibGljIHBvaW50V29ybGRUb0NsaXAoX3BvaW50SW5Xb3JsZFNwYWNlOiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzO1xuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMubXR4V29ybGRUb1ZpZXcuZ2V0KCk7XG4gICAgICBsZXQgdzogbnVtYmVyID0gbVszXSAqIF9wb2ludEluV29ybGRTcGFjZS54ICsgbVs3XSAqIF9wb2ludEluV29ybGRTcGFjZS55ICsgbVsxMV0gKiBfcG9pbnRJbldvcmxkU3BhY2UueiArIG1bMTVdO1xuXG4gICAgICByZXN1bHQgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF9wb2ludEluV29ybGRTcGFjZSwgdGhpcy5tdHhXb3JsZFRvVmlldyk7XG4gICAgICByZXN1bHQuc2NhbGUoMSAvIHcpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCBmcm9tIGNsaXAgc3BhY2UgdG8gd29ybGQgc3BhY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9Xb3JsZChfcG9pbnRJbkNsaXBTcGFjZTogVmVjdG9yMyk6IFZlY3RvcjMge1xuICAgICAgbGV0IG10eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKHRoaXMubXR4V29ybGRUb1ZpZXcpO1xuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IG10eFZpZXdUb1dvcmxkLmdldCgpO1xuICAgICAgbGV0IHJheVdvcmxkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnRJbkNsaXBTcGFjZSwgbXR4Vmlld1RvV29ybGQsIHRydWUpO1xuICAgICAgbGV0IHc6IG51bWJlciA9IG1bM10gKiBfcG9pbnRJbkNsaXBTcGFjZS54ICsgbVs3XSAqIF9wb2ludEluQ2xpcFNwYWNlLnkgKyBtWzExXSAqIF9wb2ludEluQ2xpcFNwYWNlLnogKyBtWzE1XTtcbiAgICAgIHJheVdvcmxkLnNjYWxlKDEgLyB3KTtcblxuICAgICAgcmV0dXJuIHJheVdvcmxkO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNsckJhY2tncm91bmQsXG4gICAgICAgIGJhY2tncm91bmRFbmFibGVkOiB0aGlzLmJhY2tncm91bmRFbmFibGVkLFxuICAgICAgICBwcm9qZWN0aW9uOiB0aGlzLnByb2plY3Rpb24sXG4gICAgICAgIGZpZWxkT2ZWaWV3OiB0aGlzLmZpZWxkT2ZWaWV3LFxuICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgICBuZWFyOiB0aGlzLm5lYXIsXG4gICAgICAgIGZhcjogdGhpcy5mYXIsXG4gICAgICAgIGFzcGVjdDogdGhpcy5hc3BlY3RSYXRpbyxcbiAgICAgICAgcGl2b3Q6IHRoaXMubXR4UGl2b3Quc2VyaWFsaXplKCksXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgdGhpcy5jbHJCYWNrZ3JvdW5kLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmJhY2tncm91bmRDb2xvcik7XG4gICAgICB0aGlzLmJhY2tncm91bmRFbmFibGVkID0gX3NlcmlhbGl6YXRpb24uYmFja2dyb3VuZEVuYWJsZWQ7XG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBfc2VyaWFsaXphdGlvbi5wcm9qZWN0aW9uO1xuICAgICAgdGhpcy5maWVsZE9mVmlldyA9IF9zZXJpYWxpemF0aW9uLmZpZWxkT2ZWaWV3O1xuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IF9zZXJpYWxpemF0aW9uLmFzcGVjdDtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gX3NlcmlhbGl6YXRpb24uZGlyZWN0aW9uO1xuICAgICAgdGhpcy5uZWFyID0gX3NlcmlhbGl6YXRpb24ubmVhcjtcbiAgICAgIHRoaXMuZmFyID0gX3NlcmlhbGl6YXRpb24uZmFyO1xuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XG4gICAgICBzd2l0Y2ggKHRoaXMucHJvamVjdGlvbikge1xuICAgICAgICBjYXNlIFBST0pFQ1RJT04uT1JUSE9HUkFQSElDOlxuICAgICAgICAgIHRoaXMucHJvamVjdE9ydGhvZ3JhcGhpYygpOyAvLyBUT0RPOiBzZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIHBhcmFtZXRlcnNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLkNFTlRSQUw6XG4gICAgICAgICAgdGhpcy5wcm9qZWN0Q2VudHJhbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XG4gICAgICBpZiAodHlwZXMuZGlyZWN0aW9uKVxuICAgICAgICB0eXBlcy5kaXJlY3Rpb24gPSBGSUVMRF9PRl9WSUVXO1xuICAgICAgaWYgKHR5cGVzLnByb2plY3Rpb24pXG4gICAgICAgIHR5cGVzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OO1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5wcm9qZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5DRU5UUkFMOlxuICAgICAgICAgIHRoaXMucHJvamVjdENlbnRyYWwodGhpcy5hc3BlY3RSYXRpbywgdGhpcy5maWVsZE9mVmlldywgdGhpcy5kaXJlY3Rpb24sIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XG4gICAgICBkZWxldGUgX211dGF0b3IudHJhbnNmb3JtO1xuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBNYWtlcyB0aGUgbm9kZSBmYWNlIHRoZSBjYW1lcmEgd2hlbiByZW5kZXJpbmcsIHJlc3BlY3RpbmcgcmVzdHJpY3Rpb25zIGZvciByb3RhdGlvbiBhcm91bmQgc3BlY2lmaWMgYXhpc1xuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvQ29tcG9uZW50XG4gICAqL1xuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50RmFjZUNhbWVyYSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEZhY2VDYW1lcmEpO1xuXG4gICAgcHVibGljIHVwTG9jYWw6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHB1YmxpYyB1cDogVmVjdG9yMyA9IFZlY3RvcjMuWSgxKTtcbiAgICBwdWJsaWMgcmVzdHJpY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IHRydWU7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBGaWx0ZXJzIHN5bmNocm9uaXphdGlvbiBiZXR3ZWVuIGEgZ3JhcGggaW5zdGFuY2UgYW5kIHRoZSBncmFwaCBpdCBpcyBjb25uZWN0ZWQgdG8uIElmIGFjdGl2ZSwgbm8gc3luY2hyb25pemF0aW9uIG9jY3Vycy5cbiAgICogTWF5YmUgbW9yZSBmaW5lZ3JhaW5lZCBpbiB0aGUgZnV0dXJlLi4uXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9Db21wb25lbnRcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRHcmFwaEZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEdyYXBoRmlsdGVyKTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCB0eXBlIFR5cGVPZkxpZ2h0ID0gbmV3ICgpID0+IExpZ2h0O1xuICAvKipcbiAgICogQmFzZWNsYXNzIGZvciBkaWZmZXJlbnQga2luZHMgb2YgbGlnaHRzLiBcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiAgICovXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMaWdodCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xuICAgIHB1YmxpYyBjb2xvcjogQ29sb3I7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIFR5cGVPZkxpZ2h0fSBvZiB0aGlzIGxpZ2h0LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUeXBlKCk6IFR5cGVPZkxpZ2h0IHtcbiAgICAgIHJldHVybiA8VHlwZU9mTGlnaHQ+dGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLnNlcmlhbGl6ZSgpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29sb3IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoKTogdm9pZCB7LyoqLyB9XG4gIH1cblxuICAvKipcbiAgICogQW1iaWVudCBsaWdodCwgY29taW5nIGZyb20gYWxsIGRpcmVjdGlvbnMsIGlsbHVtaW5hdGluZyBldmVyeXRoaW5nIHdpdGggaXRzIGNvbG9yIGluZGVwZW5kZW50IG9mIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiAobGlrZSBhIGZvZ2d5IGRheSBvciBpbiB0aGUgc2hhZGVzKSAgXG4gICAqIEF0dGFjaGVkIHRvIGEgbm9kZSBieSB7QGxpbmsgQ29tcG9uZW50TGlnaHR9LCB0aGUgcGl2b3QgbWF0cml4IGlzIGlnbm9yZWQuXG4gICAqIGBgYHRleHRcbiAgICogfiB+IH4gIFxuICAgKiAgfiB+IH4gIFxuICAgKiBgYGBcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBMaWdodEFtYmllbnQgZXh0ZW5kcyBMaWdodCB7XG4gIH1cbiAgLyoqXG4gICAqIERpcmVjdGlvbmFsIGxpZ2h0LCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyBmcm9tIGEgc3BlY2lmaWVkIGRpcmVjdGlvbiB3aXRoIGl0cyBjb2xvciAobGlrZSBzdGFuZGluZyBpbiBicmlnaHQgc3VubGlnaHQpICBcbiAgICogQXR0YWNoZWQgdG8gYSBub2RlIGJ5IHtAbGluayBDb21wb25lbnRMaWdodH0sIHRoZSBwaXZvdCBtYXRyaXggc3BlY2lmaWVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0IG9ubHkuXG4gICAqIGBgYHRleHRcbiAgICogLS0tPiAgXG4gICAqIC0tLT4gIFxuICAgKiAtLS0+ICBcbiAgICogYGBgXG4gICAqL1xuICBleHBvcnQgY2xhc3MgTGlnaHREaXJlY3Rpb25hbCBleHRlbmRzIExpZ2h0IHtcbiAgfVxuICAvKipcbiAgICogT21uaWRpcmVjdGlvbmFsIGxpZ2h0IGVtaXR0aW5nIGZyb20gaXRzIHBvc2l0aW9uLCBpbGx1bWluYXRpbmcgb2JqZWN0cyBkZXBlbmRpbmcgb24gdGhlaXIgcG9zaXRpb24gYW5kIGRpc3RhbmNlIHdpdGggaXRzIGNvbG9yIChsaWtlIGEgY29sb3JlZCBsaWdodCBidWxiKSAgXG4gICAqIEF0dGFjaGVkIHRvIGEgbm9kZSBieSB7QGxpbmsgQ29tcG9uZW50TGlnaHR9LCB0aGUgcGl2b3QgbWF0cml4IHNwZWNpZmllcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0LCBpdCdzIHNoYXBlIGFuZCByb3RhdGlvbi4gXG4gICAqIFNvIHdpdGggdW5ldmVuIHNjYWxpbmcsIG90aGVyIHNoYXBlcyB0aGFuIGEgcGVyZmVjdCBzcGhlcmUsIHN1Y2ggYXMgYW4gb3ZhbCBvciBhIGRpc2MsIGFyZSBwb3NzaWJsZSwgd2hpY2ggY3JlYXRlcyBhIHZpc2libGUgZWZmZWN0IG9mIHRoZSByb3RhdGlvbiB0b28uIFxuICAgKiBUaGUgaW50ZW5zaXR5IG9mIHRoZSBsaWdodCBkcm9wcyBsaW5lYXJseSBmcm9tIDEgaW4gdGhlIGNlbnRlciB0byAwIGF0IHRoZSBwZXJpbWV0ZXIgb2YgdGhlIHNoYXBlLlxuICAgKiBgYGB0ZXh0XG4gICAqICAgICAgICAgLlxcfC8uXG4gICAqICAgICAgICAtLSBvIC0tXG4gICAqICAgICAgICAgwrQvfFxcYFxuICAgKiBgYGBcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBMaWdodFBvaW50IGV4dGVuZHMgTGlnaHQge1xuICB9XG4gIC8qKlxuICAgKiBTcG90IGxpZ2h0IGVtaXR0aW5nIHdpdGhpbiBhIHNwZWNpZmllZCBhbmdsZSBmcm9tIGl0cyBwb3NpdGlvbiwgaWxsdW1pbmF0aW5nIG9iamVjdHMgZGVwZW5kaW5nIG9uIHRoZWlyIHBvc2l0aW9uIGFuZCBkaXN0YW5jZSB3aXRoIGl0cyBjb2xvciAgXG4gICAqIEF0dGFjaGVkIHRvIGEgbm9kZSBieSB7QGxpbmsgQ29tcG9uZW50TGlnaHR9LCB0aGUgcGl2b3QgbWF0cml4IHNwZWNpZmllcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0LCB0aGUgZGlyZWN0aW9uIGFuZCB0aGUgc2l6ZSBhbmQgYW5nbGVzIG9mIHRoZSBjb25lLlxuICAgKiBUaGUgaW50ZW5zaXR5IG9mIHRoZSBsaWdodCBkcm9wcyBsaW5lYXJseSBmcm9tIDEgaW4gdGhlIGNlbnRlciB0byAwIGF0IHRoZSBvdXRlciBsaW1pdHMgb2YgdGhlIGNvbmUuXG4gICAqIGBgYHRleHRcbiAgICogICAgICAgICAgbyAgXG4gICAqICAgICAgICAgL3xcXCAgXG4gICAqICAgICAgICAvIHwgXFwgXG4gICAqIGBgYCAgIFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIExpZ2h0U3BvdCBleHRlbmRzIExpZ2h0IHtcbiAgfVxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL0xpZ2h0L0xpZ2h0LnRzXCIvPlxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgaWRlbnRpZmllcnMgZm9yIHRoZSB2YXJpb3VzIHR5cGVzIG9mIGxpZ2h0IHRoaXMgY29tcG9uZW50IGNhbiBwcm92aWRlLiAgXG4gICAqL1xuICAvLyBleHBvcnQgbGV0IExJR0hUX1RZUEU6IHsgW3R5cGU6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICBleHBvcnQgZW51bSBMSUdIVF9UWVBFIHtcbiAgICBBTUJJRU5UID0gXCJMaWdodEFtYmllbnRcIixcbiAgICBESVJFQ1RJT05BTCA9IFwiTGlnaHREaXJlY3Rpb25hbFwiLFxuICAgIFBPSU5UID0gXCJMaWdodFBvaW50XCIsXG4gICAgU1BPVCA9IFwiTGlnaHRTcG90XCJcbiAgfVxuICAvKipcbiAgICAqIEF0dGFjaGVzIGEge0BsaW5rIExpZ2h0fSB0byB0aGUgbm9kZVxuICAgICogVGhlIHBpdm90IG1hdHJpeCBoYXMgZGlmZmVyZW50IGVmZmVjdHMgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSB7QGxpbmsgTGlnaHR9LiBTZWUgdGhlcmUgZm9yIGRldGFpbHMuXG4gICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgICovXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRMaWdodCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudExpZ2h0KTtcbiAgICAvLyBwcml2YXRlIHN0YXRpYyBjb25zdHJ1Y3RvcnM6IHsgW3R5cGU6IHN0cmluZ106IEdlbmVyYWwgfSA9IHsgW0xJR0hUX1RZUEUuQU1CSUVOVF06IExpZ2h0QW1iaWVudCwgW0xJR0hUX1RZUEUuRElSRUNUSU9OQUxdOiBMaWdodERpcmVjdGlvbmFsLCBbTElHSFRfVFlQRS5QT0lOVF06IExpZ2h0UG9pbnQsIFtMSUdIVF9UWVBFLlNQT1RdOiBMaWdodFNwb3QgfTtcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xuICAgIHB1YmxpYyBsaWdodDogTGlnaHQgPSBudWxsO1xuICAgIC8vVE9ETzogc2luY2UgdGhlcmUgaXMgYWxtb3N0IG5vIGZ1bmN0aW9uYWxpdHkgbGVmdCBpbiBMaWdodCwgZWxpbWluYXRlIGl0IGFuZCBwdXQgYWxsIGluIHRoZSBjb21wb25lbnQgYXMgd2l0aCB0aGUgY2FtZXJhLi4uXG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2xpZ2h0OiBMaWdodCA9IG5ldyBMaWdodEFtYmllbnQoKSkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgICB0aGlzLmxpZ2h0ID0gX2xpZ2h0O1xuICAgIH1cblxuICAgIC8vIFRPRE86IHVzZSBUeXBlT2ZMaWdodCBhcyByZXR1cm4gdHlwZT9cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHR5cGUgb2Yge0BsaW5rIExpZ2h0fSB1c2VkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRUeXBlPFQgZXh0ZW5kcyBMaWdodD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xuICAgICAgbGV0IG10ck9sZDogTXV0YXRvciA9IHt9O1xuICAgICAgaWYgKHRoaXMubGlnaHQpXG4gICAgICAgIG10ck9sZCA9IHRoaXMubGlnaHQuZ2V0TXV0YXRvcigpO1xuXG4gICAgICB0aGlzLmxpZ2h0ID0gbmV3IF9jbGFzcygpO1xuICAgICAgdGhpcy5saWdodC5tdXRhdGUobXRyT2xkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XG4gICAgICAgIHBpdm90OiB0aGlzLm10eFBpdm90LnNlcmlhbGl6ZSgpLFxuICAgICAgICBsaWdodDogU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5saWdodClcbiAgICAgIH07XG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XG4gICAgICB0aGlzLmxpZ2h0ID0gYXdhaXQgPFByb21pc2U8TGlnaHQ+PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubGlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XG4gICAgICBtdXRhdG9yLnR5cGUgPSB0aGlzLmxpZ2h0LmdldFR5cGUoKS5uYW1lO1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XG4gICAgICBpZiAodHlwZXMudHlwZSlcbiAgICAgICAgdHlwZXMudHlwZSA9IExJR0hUX1RZUEU7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgbGV0IHR5cGU6IHN0cmluZyA9IF9tdXRhdG9yLnR5cGU7XG4gICAgICBpZiAodHlwZW9mICh0eXBlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlICE9IHRoaXMubGlnaHQuY29uc3RydWN0b3IubmFtZSlcbiAgICAgICAgdGhpcy5zZXRUeXBlKFNlcmlhbGl6ZXIuZ2V0Q29uc3RydWN0b3I8TGlnaHQ+KHR5cGUpKTtcbiAgICAgIGRlbGV0ZSAoX211dGF0b3IudHlwZSk7IC8vIGV4Y2x1ZGUgbGlnaHQgdHlwZSBmcm9tIGZ1cnRoZXIgbXV0YXRpb25cbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgICBfbXV0YXRvci50eXBlID0gdHlwZTsgLy8gcmVjb25zdHJ1Y3QgbXV0YXRvclxuICAgIH1cbiAgfVxufVxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIHtAbGluayBNYXRlcmlhbH0gdG8gdGhlIG5vZGVcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkgLSAyMDIxXG4gICAqL1xuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50TWF0ZXJpYWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRNYXRlcmlhbCk7XG4gICAgcHVibGljIGNsclByaW1hcnk6IENvbG9yID0gQ29sb3IuQ1NTKFwid2hpdGVcIik7XG4gICAgcHVibGljIGNsclNlY29uZGFyeTogQ29sb3IgPSBDb2xvci5DU1MoXCJ3aGl0ZVwiKTtcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5JREVOVElUWSgpO1xuICAgIHB1YmxpYyBtYXRlcmlhbDogTWF0ZXJpYWw7XG4gICAgLyoqIFN1cHBvcnQgc29ydGluZyBvZiBvYmplY3RzIHdpdGggdHJhbnNwYXJlbmN5IHdoZW4gcmVuZGVyaW5nLCByZW5kZXIgb2JqZWN0cyBpbiB0aGUgYmFjayBmaXJzdC4gV2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1c2VkIGFzIGEgcGFydCBvZiBhIHtAbGluayBQYXJ0aWNsZVN5c3RlbX0sIHRyeSBlbmFibGluZyB0aGlzIHdoZW4gZGlzYWJsaW5nIHtAbGluayBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS5kZXB0aE1hc2t9ICovXG4gICAgcHVibGljIHNvcnRGb3JBbHBoYTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8vIHB1YmxpYyBtdXRhdG9yQ29hdDogTXV0YXRvckZvckNvbXBvbmVudDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWF0ZXJpYWw6IE1hdGVyaWFsID0gbnVsbCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBfbWF0ZXJpYWw7XG4gICAgICAvLyB0aGlzLm11dGF0b3JDb2F0ID0gX21hdGVyaWFsLmdldENvYXQoKS5nZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xuICAgICAgICBzb3J0Rm9yQWxwaGE6IHRoaXMuc29ydEZvckFscGhhLFxuICAgICAgICBjbHJQcmltYXJ5OiB0aGlzLmNsclByaW1hcnkuc2VyaWFsaXplKCksXG4gICAgICAgIGNsclNlY29uZGFyeTogdGhpcy5jbHJTZWNvbmRhcnkuc2VyaWFsaXplKCksXG4gICAgICAgIHBpdm90OiB0aGlzLm10eFBpdm90LnNlcmlhbGl6ZSgpLFxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpLFxuICAgICAgICBpZE1hdGVyaWFsOiB0aGlzLm1hdGVyaWFsLmlkUmVzb3VyY2VcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICB0aGlzLm1hdGVyaWFsID0gPE1hdGVyaWFsPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRNYXRlcmlhbCk7XG4gICAgICBhd2FpdCB0aGlzLmNsclByaW1hcnkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY2xyUHJpbWFyeSk7XG4gICAgICBhd2FpdCB0aGlzLmNsclNlY29uZGFyeS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jbHJTZWNvbmRhcnkpO1xuICAgICAgdGhpcy5zb3J0Rm9yQWxwaGEgPSBfc2VyaWFsaXphdGlvbi5zb3J0Rm9yQWxwaGE7XG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSgpOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSB7XG4gICAgLy8gICBsZXQgbXV0YXRvckNvYXQ6IE11dGF0b3JGb3JDb21wb25lbnQgPSB0aGlzLm1hdGVyaWFsLmdldENvYXQoKS5nZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk7XG4gICAgLy8gICByZXR1cm4gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPjx1bmtub3duPm11dGF0b3JDb2F0O1xuICAgIC8vIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQXR0YWNoZXMgYSB7QGxpbmsgTWVzaH0gdG8gdGhlIG5vZGVcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRNZXNoIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50TWVzaCk7XG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcbiAgICBwdWJsaWMgcmVhZG9ubHkgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xuICAgIHB1YmxpYyBtZXNoOiBNZXNoO1xuICAgIHB1YmxpYyBza2VsZXRvbjogQ29tcG9uZW50U2tlbGV0b247XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21lc2g/OiBNZXNoLCBfc2tlbGV0b24/OiBDb21wb25lbnRTa2VsZXRvbikge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMubWVzaCA9IF9tZXNoO1xuICAgICAgdGhpcy5za2VsZXRvbiA9IF9za2VsZXRvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHJhZGl1cygpOiBudW1iZXIge1xuICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLm10eFdvcmxkLnNjYWxpbmc7XG4gICAgICBsZXQgc2NhbGU6IG51bWJlciA9IE1hdGgubWF4KE1hdGguYWJzKHNjYWxpbmcueCksIE1hdGguYWJzKHNjYWxpbmcueSksIE1hdGguYWJzKHNjYWxpbmcueikpO1xuICAgICAgcmV0dXJuIHRoaXMubWVzaC5yYWRpdXMgKiBzY2FsZTtcbiAgICB9XG5cbiAgICAvLyAvKipcbiAgICAvLyAgKiBDYWxjdWxhdGVzIHRoZSBwb3NpdGlvbiBvZiBhIHZlcnRleCB0cmFuc2Zvcm1lZCBieSB0aGUgc2tlbGV0b25cbiAgICAvLyAgKiBAcGFyYW0gX2luZGV4IGluZGV4IG9mIHRoZSB2ZXJ0ZXhcbiAgICAvLyAgKi9cbiAgICAvLyBwdWJsaWMgZ2V0VmVydGV4UG9zaXRpb24oX2luZGV4OiBudW1iZXIpOiBWZWN0b3IzIHtcbiAgICAvLyAgIC8vIGV4dHJhY3QgdGhlIHZlcnRleCBkYXRhICh2ZXJ0aWNlczogM0QgdmVjdG9ycywgYm9uZSBpbmRpY2VzICYgd2VpZ2h0czogNEQgdmVjdG9ycylcbiAgICAvLyAgIGNvbnN0IGlWZXJ0ZXg6IG51bWJlciA9IF9pbmRleCAqIDM7XG4gICAgLy8gICBjb25zdCBpQm9uZUluZmx1ZW5jZTogbnVtYmVyID0gX2luZGV4ICogNDtcblxuICAgIC8vICAgY29uc3QgdmVydGV4OiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoLi4uUmVmbGVjdC5nZXQodGhpcy5tZXNoLCBcInJlbmRlck1lc2hcIikudmVydGljZXMuc2xpY2UoaVZlcnRleCwgaVZlcnRleCArIDMpKTtcbiAgICAvLyAgIGlmICghKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2hTa2luKSkgcmV0dXJuIHZlcnRleDtcblxuICAgIC8vICAgY29uc3QgaUJvbmVzOiBVaW50OEFycmF5ID0gdGhpcy5tZXNoLmlCb25lcy5zbGljZShpQm9uZUluZmx1ZW5jZSwgaUJvbmVJbmZsdWVuY2UgKyA0KTtcbiAgICAvLyAgIGNvbnN0IHdlaWdodHM6IEZsb2F0MzJBcnJheSA9IHRoaXMubWVzaC53ZWlnaHRzLnNsaWNlKGlCb25lSW5mbHVlbmNlLCBpQm9uZUluZmx1ZW5jZSArIDQpO1xuXG4gICAgLy8gICAvLyBnZXQgYm9uZSBtYXRyaWNlc1xuICAgIC8vICAgY29uc3QgbXR4Qm9uZXM6IEFycmF5PE1hdHJpeDR4ND4gPSB0aGlzLnNrZWxldG9uLm10eEJvbmVzO1xuXG4gICAgLy8gICAvLyBza2luIG1hdHJpeCBTID0gc3VtX2k9MV5te3dfaSAqIEJfaX1cbiAgICAvLyAgIGNvbnN0IHNraW5NYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcbiAgICAvLyAgIHNraW5NYXRyaXguc2V0KEFycmF5XG4gICAgLy8gICAgIC5mcm9tKGlCb25lcylcbiAgICAvLyAgICAgLm1hcCgoaUJvbmUsIGlXZWlnaHQpID0+IG10eEJvbmVzW2lCb25lXS5nZXQoKS5tYXAodmFsdWUgPT4gdmFsdWUgKiB3ZWlnaHRzW2lXZWlnaHRdKSkgLy8gYXBwbHkgd2VpZ2h0IG9uIGVhY2ggbWF0cml4XG4gICAgLy8gICAgIC5yZWR1Y2UoKG10eFN1bSwgbXR4Qm9uZSkgPT4gbXR4U3VtLm1hcCgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSArIG10eEJvbmVbaW5kZXhdKSkgLy8gc3VtIHVwIHRoZSBtYXRyaWNlc1xuICAgIC8vICAgKTtcblxuICAgIC8vICAgLy8gdHJhbnNmb3JtIHZlcnRleFxuICAgIC8vICAgdmVydGV4LnRyYW5zZm9ybShza2luTWF0cml4KTtcblxuICAgIC8vICAgcmV0dXJuIHZlcnRleDtcbiAgICAvLyB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgb3IgdGhpbmsgaWYgdGhlIHRyYW5zZm9ybWVkIGJvdW5kaW5nIGJveCBpcyBvZiB2YWx1ZSBvciBjYW4gYmUgbWFkZSB0byBiZVxuICAgIC8vIHB1YmxpYyBnZXQgYm91bmRpbmdCb3goKTogQm94IHtcbiAgICAvLyAgIGxldCBib3g6IEJveCA9IFJlY3ljbGVyLmdldChCb3gpO1xuICAgIC8vICAgYm94LnNldChcbiAgICAvLyAgICAgVmVjdG9yMy5UUkFOU0ZPUk1BVElPTih0aGlzLm1lc2guYm91bmRpbmdCb3gubWluLCB0aGlzLm10eFdvcmxkLCB0cnVlKSxcbiAgICAvLyAgICAgVmVjdG9yMy5UUkFOU0ZPUk1BVElPTih0aGlzLm1lc2guYm91bmRpbmdCb3gubWF4LCB0aGlzLm10eFdvcmxkLCB0cnVlKVxuICAgIC8vICAgKTtcbiAgICAvLyAgIHJldHVybiBib3g7XG4gICAgLy8gfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uO1xuICAgICAgLyogYXQgdGhpcyBwb2ludCBvZiB0aW1lLCBzZXJpYWxpemF0aW9uIGFzIHJlc291cmNlIGFuZCBhcyBpbmxpbmUgb2JqZWN0IGlzIHBvc3NpYmxlLiBUT0RPOiBjaGVjayBpZiBpbmxpbmUgYmVjb21lcyBvYnNvbGV0ZSAqL1xuICAgICAgbGV0IGlkTWVzaDogc3RyaW5nID0gdGhpcy5tZXNoLmlkUmVzb3VyY2U7XG4gICAgICBpZiAoaWRNZXNoKVxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBpZE1lc2g6IGlkTWVzaCB9O1xuICAgICAgZWxzZVxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBtZXNoOiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLm1lc2gpIH07XG5cbiAgICAgIGlmICh0aGlzLnNrZWxldG9uKVxuICAgICAgICBzZXJpYWxpemF0aW9uLnNrZWxldG9uID0gTm9kZS5QQVRIX0ZST01fVE8odGhpcywgdGhpcy5za2VsZXRvbik7XG5cbiAgICAgIHNlcmlhbGl6YXRpb24ucGl2b3QgPSB0aGlzLm10eFBpdm90LnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGxldCBtZXNoOiBNZXNoO1xuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTWVzaClcbiAgICAgICAgbWVzaCA9IDxNZXNoPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRNZXNoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgbWVzaCA9IDxNZXNoPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWVzaCk7XG4gICAgICB0aGlzLm1lc2ggPSBtZXNoO1xuXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uc2tlbGV0b24pIHtcbiAgICAgICAgY29uc3QgaG5kTm9kZURlc2VyaWFsaXplZDogRXZlbnRMaXN0ZW5lclVuaWZpZWQgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaG5kR3JhcGhEZXNlcmlhbGl6ZWQ6IEV2ZW50TGlzdGVuZXJVbmlmaWVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5za2VsZXRvbiA9IE5vZGUuRklORCh0aGlzLCBfc2VyaWFsaXphdGlvbi5za2VsZXRvbikgYXMgQ29tcG9uZW50U2tlbGV0b247XG4gICAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSgpOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvckZvclVzZXJJbnRlcmZhY2UgPSA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+dGhpcy5nZXRNdXRhdG9yKCk7XG4gICAgICAvLyBpZiAoIXRoaXMubWVzaClcbiAgICAgIC8vICAgbXV0YXRvci5tZXNoID0gTWVzaDtcbiAgICAgIHJldHVybiBtdXRhdG9yO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxufVxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgZXhwb3J0IGVudW0gUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFIHtcbiAgICAvKipQbGF5cyBwYXJ0aWNsZSBzeXN0ZW0gaW4gYSBsb29wOiBpdCByZXN0YXJ0cyBvbmNlIGl0IGhpdCB0aGUgZW5kLiovXG4gICAgTE9PUCxcbiAgICAvKipQbGF5cyBwYXJ0aWNsZSBzeXN0ZW0gb25jZSBhbmQgc3RvcHMgYXQgdGhlIGxhc3QgcG9pbnQgaW4gdGltZS4qL1xuICAgIFBMQVlfT05DRVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEge0BsaW5rIFBhcnRpY2xlU3lzdGVtfSB0byB0aGUgbm9kZS4gXG4gICAqIFdvcmtzIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIENvbXBvbmVudE1lc2h9IGFuZCB7QGxpbmsgQ29tcG9uZW50TWF0ZXJpYWx9IHRvIGNyZWF0ZSBhIHNoYWRlciBwYXJ0aWNsZSBzeXN0ZW0uXG4gICAqIEFkZGl0aW9uYWxseSBhIHtAbGluayBDb21wb25lbnRGYWNlQ2FtZXJhfSBjYW4gYmUgYXR0YWNoZWQgdG8gbWFrZSB0aGUgcGFydGljbGVzIGZhY2UgdGhlIGNhbWVyYS5cbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjJcbiAgICovXG4gIEBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtLmRlY29yYXRlXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFBhcnRpY2xlU3lzdGVtKTtcbiAgICBwdWJsaWMgcGFydGljbGVTeXN0ZW06IFBhcnRpY2xlU3lzdGVtO1xuICAgIC8qKiBXaGVuIGRpc2FibGVkIHRyeSBlbmFibGluZyB7QGxpbmsgQ29tcG9uZW50TWF0ZXJpYWwuc29ydEZvckFscGhhfSAqL1xuICAgIHB1YmxpYyBkZXB0aE1hc2s6IGJvb2xlYW47XG4gICAgcHVibGljIGJsZW5kTW9kZTogQkxFTkQ7XG4gICAgcHVibGljIHBsYXlNb2RlOiBQQVJUSUNMRV9TWVNURU1fUExBWU1PREU7XG4gICAgcHVibGljIGR1cmF0aW9uOiBudW1iZXI7XG5cbiAgICAvKiogQGludGVybmFsIEEgdGV4dHVyZSBmaWxlZCB3aXRoIHJhbmRvbSBudW1iZXJzLiBVc2VkIGJ5IHRoZSByZW5kZXIgZW5naW5lICovXG4gICAgcHJvdGVjdGVkIHJlbmRlckRhdGE6IHVua25vd247XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiBwYXJ0aWNsZXMgKi9cbiAgICAjc2l6ZTogbnVtYmVyO1xuICAgICN0aW1lU2NhbGU6IG51bWJlciA9IDE7XG4gICAgcmVhZG9ubHkgI3RpbWU6IFRpbWU7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3BhcnRpY2xlU3lzdGVtOiBQYXJ0aWNsZVN5c3RlbSA9IG51bGwpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtID0gX3BhcnRpY2xlU3lzdGVtO1xuICAgICAgdGhpcy5kZXB0aE1hc2sgPSB0cnVlO1xuICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCTEVORC5BRERJVElWRTtcbiAgICAgIHRoaXMucGxheU1vZGUgPSBQQVJUSUNMRV9TWVNURU1fUExBWU1PREUuTE9PUDtcbiAgICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwO1xuICAgICAgdGhpcy5zaXplID0gMTA7XG4gICAgICB0aGlzLiN0aW1lID0gbmV3IFRpbWUoKTtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kRXZlbnQpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaG5kRXZlbnQpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCB0aGlzLmhuZEV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBwYXJ0aWNsZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNzaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIHBhcnRpY2xlcy4gQ2F1dGlvbjogU2V0dGluZyB0aGlzIHdpbGwgcmVpbml0aWFsaXplIHRoZSByYW5kb20gbnVtYmVycyBhcnJheSh0ZXh0dXJlKSB1c2VkIGluIHRoZSBzaGFkZXIuXG4gICAgICovXG4gICAgcHVibGljIHNldCBzaXplKF9zaXplOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NpemUgPSBfc2l6ZTtcbiAgICAgIHRoaXMuZGVsZXRlUmVuZGVyRGF0YSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdGltZSgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3RpbWUuZ2V0KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB0aW1lKF90aW1lOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3RpbWUuc2V0KF90aW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHRpbWVTY2FsZSgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3RpbWVTY2FsZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHRpbWVTY2FsZShfc2NhbGU6IG51bWJlcikge1xuICAgICAgdGhpcy4jdGltZVNjYWxlID0gX3NjYWxlO1xuICAgICAgdGhpcy51cGRhdGVUaW1lU2NhbGUoKTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogR2VuZXJhdGVzIGFuZCBiaW5kcyB0aGUgcmFuZG9tIG51bWJlcnMgdGV4dHVyZSBpbiBXZWJHTFxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cbiAgICAgKiBAaW50ZXJuYWwgXG4gICAgICovXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XG5cbiAgICAvKiogXG4gICAgICogRGVsZXRlcyB0aGUgcmFuZG9tIG51bWJlcnMgdGV4dHVyZSBpbiBXZWJHTCBmcmVlaW5nIHRoZSBhbGxvY2F0ZWQgZ3B1IG1lbW9yeS5cbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JDb21wb25lbnRQYXJ0aWNsZVN5c3RlbX0uIFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVSZW5kZXJEYXRhKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxuXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpLFxuICAgICAgICBpZFBhcnRpY2xlU3lzdGVtOiB0aGlzLnBhcnRpY2xlU3lzdGVtPy5pZFJlc291cmNlLFxuICAgICAgICBkZXB0aE1hc2s6IHRoaXMuZGVwdGhNYXNrLFxuICAgICAgICBibGVuZE1vZGU6IHRoaXMuYmxlbmRNb2RlLFxuICAgICAgICBwbGF5TW9kZTogdGhpcy5wbGF5TW9kZSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHNpemU6IHRoaXMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZFBhcnRpY2xlU3lzdGVtKSB0aGlzLnBhcnRpY2xlU3lzdGVtID0gPFBhcnRpY2xlU3lzdGVtPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRQYXJ0aWNsZVN5c3RlbSk7XG4gICAgICB0aGlzLmRlcHRoTWFzayA9IF9zZXJpYWxpemF0aW9uLmRlcHRoTWFzaztcbiAgICAgIHRoaXMuYmxlbmRNb2RlID0gX3NlcmlhbGl6YXRpb24uYmxlbmRNb2RlO1xuICAgICAgdGhpcy5wbGF5TW9kZSA9IF9zZXJpYWxpemF0aW9uLnBsYXlNb2RlO1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IF9zZXJpYWxpemF0aW9uLmR1cmF0aW9uO1xuICAgICAgdGhpcy5zaXplID0gX3NlcmlhbGl6YXRpb24uc2l6ZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoX2V4dGVuZGFibGU/OiBib29sZWFuKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XG4gICAgICBtdXRhdG9yLnNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3JGb3JVc2VySW50ZXJmYWNlID0gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPnRoaXMuZ2V0TXV0YXRvcih0cnVlKTtcbiAgICAgIGRlbGV0ZSBtdXRhdG9yLnBhcnRpY2xlU3lzdGVtO1xuICAgICAgbXV0YXRvci5wYXJ0aWNsZVN5c3RlbSA9IHRoaXMucGFydGljbGVTeXN0ZW0/LmdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlKCk7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvckFuaW1hdGlvbigpOiBNdXRhdG9yRm9yQW5pbWF0aW9uIHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yRm9yQW5pbWF0aW9uID0gPE11dGF0b3JGb3JBbmltYXRpb24+dGhpcy5nZXRNdXRhdG9yKCk7XG4gICAgICBkZWxldGUgbXV0YXRvci5wYXJ0aWNsZVN5c3RlbTtcbiAgICAgIGRlbGV0ZSBtdXRhdG9yLnNpemU7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcbiAgICAgIGlmICh0eXBlcy5ibGVuZE1vZGUpXG4gICAgICAgIHR5cGVzLmJsZW5kTW9kZSA9IEJMRU5EO1xuICAgICAgaWYgKHR5cGVzLnBsYXlNb2RlKVxuICAgICAgICB0eXBlcy5wbGF5TW9kZSA9IFBBUlRJQ0xFX1NZU1RFTV9QTEFZTU9ERTtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XG4gICAgICBkZWxldGUgX211dGF0b3IucmFuZG9tTnVtYmVyc1JlbmRlckRhdGE7XG4gICAgICBkZWxldGUgX211dGF0b3IudGltZTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICBwcml2YXRlIGhuZEV2ZW50ID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgIHN3aXRjaCAoX2V2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRDpcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfQUREOlxuICAgICAgICAgIFRpbWUuZ2FtZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlRJTUVfU0NBTEVELCB0aGlzLnVwZGF0ZVRpbWVTY2FsZSk7XG4gICAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfUkVNT1ZFOlxuICAgICAgICAgIFRpbWUuZ2FtZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULlRJTUVfU0NBTEVELCB0aGlzLnVwZGF0ZVRpbWVTY2FsZSk7XG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAodGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbilcbiAgICAgICAgc3dpdGNoICh0aGlzLnBsYXlNb2RlKSB7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYXNlIFBBUlRJQ0xFX1NZU1RFTV9QTEFZTU9ERS5MT09QOlxuICAgICAgICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFLlBMQVlfT05DRTpcbiAgICAgICAgICAgIHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRpbWVTY2FsZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGxldCB0aW1lU2NhbGU6IG51bWJlciA9IHRoaXMuI3RpbWVTY2FsZSAqIFRpbWUuZ2FtZS5nZXRTY2FsZSgpO1xuICAgICAgdGhpcy4jdGltZS5zZXRTY2FsZSh0aW1lU2NhbGUpO1xuICAgIH07XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGVudW0gUElDSyB7XG4gICAgUkFESVVTID0gXCJyYWRpdXNcIixcbiAgICBDQU1FUkEgPSBcImNhbWVyYVwiLFxuICAgIFBIWVNJQ1MgPSBcInBoeXNpY3NcIlxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHBpY2tpbmcgZnVuY3Rpb25hbGl0eSB0byB0aGUgbm9kZVxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFBpY2sgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRQaWNrKTtcbiAgICBwdWJsaWMgcGljazogUElDSyA9IFBJQ0suUkFESVVTO1xuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIG5vZGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgUmF5fSBhbmQgaW52b2tlcyBldmVudHMgYWNjb3JkaW5nbHlcbiAgICAgKi9cbiAgICBwdWJsaWMgcGlja0FuZERpc3BhdGNoKF9yYXk6IFJheSwgX2V2ZW50OiBQb2ludGVyRXZlbnQpOiB2b2lkIHtcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IGNtcE1lc2ggPyBjbXBNZXNoLm10eFdvcmxkLnRyYW5zbGF0aW9uIDogdGhpcy5ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMucGljaykge1xuICAgICAgICBjYXNlIFBJQ0suUkFESVVTOlxuICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBvbmx5IGJlIG5vZGUucmFkaXVzLiBBZGp1c3RtZW50IG5lZWRlZCwgaWYgbWVzaCB3YXMgdHJhbnNmb3JtZWQuLi5cbiAgICAgICAgICBpZiAoX3JheS5nZXREaXN0YW5jZShwb3NpdGlvbikubWFnbml0dWRlIDwgdGhpcy5ub2RlLnJhZGl1cykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUElDSy5QSFlTSUNTOlxuICAgICAgICAgIGxldCBoaXRJbmZvOiBSYXlIaXRJbmZvID0gUGh5c2ljcy5yYXljYXN0KF9yYXkub3JpZ2luLCBfcmF5LmRpcmVjdGlvbiwgVmVjdG9yMy5ESUZGRVJFTkNFKHBvc2l0aW9uLCBfcmF5Lm9yaWdpbikubWFnbml0dWRlU3F1YXJlZCk7XG4gICAgICAgICAgaWYgKGhpdEluZm8uaGl0KVxuICAgICAgICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9UT0RPOiBQSUNLLkNBTUVSQVxuICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNdXRhdG9yKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xuICAgICAgaWYgKHR5cGVzLnBpY2spXG4gICAgICAgIHR5cGVzLnBpY2sgPSBQSUNLO1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQmFzZSBjbGFzcyBmb3Igc2NyaXB0cyB0aGUgdXNlciB3cml0ZXNcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL0NvbXBvbmVudFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFNjcmlwdCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLy8gcmVnaXN0ZXJpbmcgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UsIG9ubHkgaXRzIHN1YmNsYXNzZXMuIE9yIHRoaXMgY29tcG9uZW50IG11c3QgcmVmZXIgdG8gc2NyaXB0cyB0byBiZSBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudFxuICAgIC8vIFRPRE86IHJldGhpbmsgJiByZWZhY3RvclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRTY3JpcHQpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqXG4gICAqIEJ1ZmZlcnMgdGhlIGJvbmUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgQ29tcG9uZW50U2tlbGV0b259IGludG8gYSBXZWJHTCBCdWZmZXJcbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbiB7XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcInVzZVJlbmRlckJ1ZmZlclwiLCB7XG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uLnVzZVJlbmRlckJ1ZmZlclxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1cGRhdGVSZW5kZXJCdWZmZXJcIiwge1xuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbi51cGRhdGVSZW5kZXJCdWZmZXJcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiZGVsZXRlUmVuZGVyQnVmZmVyXCIsIHtcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b24uZGVsZXRlUmVuZGVyQnVmZmVyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckJ1ZmZlcih0aGlzOiBDb21wb25lbnRTa2VsZXRvbiwgX3NoYWRlcjogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcblxuICAgICAgaWYgKHRoaXMucmVuZGVyQnVmZmVyKVxuICAgICAgICBjcmMzLmJpbmRCdWZmZXJCYXNlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIFVOSUZPUk1fQkxPQ0tTLlNLSU4uQklORElORywgdGhpcy5yZW5kZXJCdWZmZXIpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXBkYXRlUmVuZGVyQnVmZmVyKHRoaXM6IENvbXBvbmVudFNrZWxldG9uKTogdm9pZCB7XG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xuXG4gICAgICBpZiAoIXRoaXMucmVuZGVyQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJvbmVzQnl0ZVNpemU6IG51bWJlciA9IDI1NiAqIDE2ICogNDsgLy8gQ0FVVElPTjogdGhpcyBpcyBkZXBlbmRlbnQgb24gdGhlIHNoYWRlciBzb3VyY2UgY29kZSB3aGVyZSAyNTYgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGJvbmVzXG5cbiAgICAgICAgdGhpcy5yZW5kZXJCdWZmZXIgPSBSZW5kZXJXZWJHTC5hc3NlcnQoY3JjMy5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcik7XG4gICAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBib25lc0J5dGVTaXplLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRZTkFNSUNfRFJBVyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tdHhCb25lcy5sZW5ndGggKiAxNik7XG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tdHhCb25lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgZGF0YS5zZXQodGhpcy5tdHhCb25lc1tpXS5nZXQoKSwgaSAqIDE2KTtcblxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyKTtcbiAgICAgIGNyYzMuYnVmZmVyU3ViRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCAwLCBkYXRhKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckJ1ZmZlcih0aGlzOiBDb21wb25lbnRTa2VsZXRvbik6IHZvaWQge1xuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcblxuICAgICAgaWYgKHRoaXMucmVuZGVyQnVmZmVyKVxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcih0aGlzLnJlbmRlckJ1ZmZlcik7XG4gICAgfVxuICB9XG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi8uLi9SZW5kZXIvUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbi50c1wiLz5cbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIC8qKlxuICAgKiBIb2xkcyBhbiBhcnJheSBvZiBib25lcyAoe0BsaW5rIE5vZGV9cyB3aXRoaW4gYSB7QGxpbmsgR3JhcGh9KS4gUmVmZXJlbmNlZCBmcm9tIGEge0BsaW5rIENvbXBvbmVudE1lc2h9IGl0IGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgTWVzaFNraW59IGFuZCBlbmFibGUgc2tpbm5pbmcgZm9yIHRoZSBtZXNoLlxuICAgKiBAYXV0aG9ycyBNYXR0aGlhcyBSb21pbmcsIEhGVSwgMjAyMi0yMDIzIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXG4gICAqL1xuICBAUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbi5kZWNvcmF0ZVxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50U2tlbGV0b24gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKiBUaGUgYm9uZXMgdXNlZCBmb3Igc2tpbm5pbmcgKi9cbiAgICBwdWJsaWMgYm9uZXM6IE5vZGVbXTtcbiAgICAvKiogV2hlbiBhcHBsaWVkIHRvIHZlcnRpY2VzLCBpdCBtb3ZlcyB0aGVtIGZyb20gb2JqZWN0L21vZGVsIHNwYWNlIHRvIGJvbmUtbG9jYWwgc3BhY2UgYXMgaWYgdGhlIGJvbmUgd2VyZSBhdCBpdHMgaW5pdGlhbCBwb3NlICovXG4gICAgcHVibGljIG10eEJpbmRJbnZlcnNlczogTWF0cml4NHg0W107IC8vIFRPRE86IHRoaW5rIGFib3V0IHNlcmlhbGl6aW5nIHRoaXMgc2VwYXJhdGVseSB0byBtYWtlIGl0IHNoYXJlYWJsZSBiZXR3ZWVuIHNrZWxldG9uIHNlcmlhbGl6YXRpb25zXG5cbiAgICBwcm90ZWN0ZWQgcmVuZGVyQnVmZmVyOiB1bmtub3duO1xuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvKiogQ29udGFpbnMgdGhlIGJvbmUgdHJhbnNmb3JtYXRpb25zIGFwcGxpY2FibGUgdG8gdGhlIHZlcnRpY2VzIG9mIGEge0BsaW5rIE1lc2hTa2lufSAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBtdHhCb25lczogTWF0cml4NHg0W10gPSBbXTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9uZXM6IE5vZGVbXSA9IFtdLCBfbXR4Qm9uZUludmVyc2VzOiBNYXRyaXg0eDRbXSA9IFtdKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5ib25lcyA9IF9ib25lcztcbiAgICAgIHRoaXMubXR4QmluZEludmVyc2VzID0gX210eEJvbmVJbnZlcnNlcztcblxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLm10eEJpbmRJbnZlcnNlc1tpXSA9PSBudWxsKVxuICAgICAgICAgIHRoaXMubXR4QmluZEludmVyc2VzW2ldID0gdGhpcy5ib25lc1tpXS5tdHhXb3JsZEludmVyc2UuY2xvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b259LlxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHVzZVJlbmRlckJ1ZmZlcihfc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UpOiBSZW5kZXJCdWZmZXJzIHsgcmV0dXJuIG51bGw7IC8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxuICAgIC8qKlxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9ufS5cbiAgICAgKiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGVSZW5kZXJCdWZmZXIoKTogUmVuZGVyQnVmZmVycyB7IHJldHVybiBudWxsOyAvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cbiAgICAvKipcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbn0uXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVsZXRlUmVuZGVyQnVmZmVyKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5vZGUgYXMgYSBib25lIHdpdGggaXRzIGJpbmQgaW52ZXJzZSBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkQm9uZShfYm9uZTogTm9kZSwgX210eEJpbmRJbnZlcnNlOiBNYXRyaXg0eDQgPSBfYm9uZS5tdHhXb3JsZEludmVyc2UuY2xvbmUpOiB2b2lkIHtcbiAgICAgIHRoaXMuYm9uZXMucHVzaChfYm9uZSk7XG4gICAgICB0aGlzLm10eEJpbmRJbnZlcnNlcy5wdXNoKF9tdHhCaW5kSW52ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgYm9uZSBpbiB0aGUgYm9uZXMgYXJyYXkgd2hpY2ggaGFzIHRoZSBnaXZlbiBuYW1lLCBhbmQgLTEgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBpbmRleE9mKF9uYW1lOiBzdHJpbmcpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gYm9uZSBub2RlIGluIHRoZSBib25lIGFycmF5LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICAgKi9cbiAgICBwdWJsaWMgaW5kZXhPZihfbm9kZTogTm9kZSk6IG51bWJlcjtcbiAgICBwdWJsaWMgaW5kZXhPZihfbmFtZTogc3RyaW5nIHwgTm9kZSk6IG51bWJlciB7XG4gICAgICBpZiAodHlwZW9mIChfbmFtZSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9uZXMuZmluZEluZGV4KChfYm9uZTogTm9kZSkgPT4gX2JvbmUubmFtZSA9PSBfbmFtZSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLmJvbmVzLmluZGV4T2YoX25hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGJvbmUgbWF0cmljZXMgdG8gYmUgdXNlZCBieSB0aGUgc2hhZGVyXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgIGZvciAoY29uc3QgbXR4Qm9uZSBvZiB0aGlzLm10eEJvbmVzKVxuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhCb25lKTtcbiAgICAgIHRoaXMubXR4Qm9uZXMubGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG10eEJvbmU6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLmJvbmVzW2ldLm10eFdvcmxkLCB0aGlzLm10eEJpbmRJbnZlcnNlc1tpXSk7XG4gICAgICAgIHRoaXMubXR4Qm9uZXMucHVzaChtdHhCb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHBvc2Ugb2YgdGhpcyBza2VsZXRvbiB0byB0aGUgZGVmYXVsdCBwb3NlXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0UG9zZSgpOiB2b2lkIHsgLy8gVE9ETzogdGVzdCB0aGlzXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy5ib25lc1tpXS5tdHhMb2NhbC5zZXQoTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLm10eEJpbmRJbnZlcnNlc1tpXSkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICBzZXJpYWxpemF0aW9uLmJvbmVzID0gdGhpcy5ib25lcy5tYXAoX2JvbmUgPT4gTm9kZS5QQVRIX0ZST01fVE8odGhpcywgX2JvbmUpKTtcbiAgICAgIHNlcmlhbGl6YXRpb24ubXR4QmluZEludmVyc2VzID0gU2VyaWFsaXplci5zZXJpYWxpemVBcnJheShNYXRyaXg0eDQsIHRoaXMubXR4QmluZEludmVyc2VzKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8Q29tcG9uZW50U2tlbGV0b24+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcblxuICAgICAgY29uc3QgaG5kTm9kZURlc2VyaWFsaXplZDogRXZlbnRMaXN0ZW5lclVuaWZpZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuYm9uZXMgPSBfc2VyaWFsaXphdGlvbi5ib25lcy5tYXAoKF9wYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBsZXQgYm9uZTogTm9kZSA9IE5vZGUuRklORCh0aGlzLCBfcGF0aCkgYXMgTm9kZTtcbiAgICAgICAgICBpZiAoIWJvbmUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Tm9kZS5uYW1lfSBcIiR7dGhpcy5ub2RlLm5hbWV9XCIgJHtDb21wb25lbnRTa2VsZXRvbi5uYW1lfTogQ291bGQgbm90IGZpbmQgYm9uZSAke19wYXRofWApO1xuICAgICAgICAgIHJldHVybiBib25lO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xuXG4gICAgICB0aGlzLm10eEJpbmRJbnZlcnNlcyA9IDxNYXRyaXg0eDRbXT5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb24ubXR4QmluZEludmVyc2VzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgZXhwb3J0IGVudW0gQkFTRSB7XG4gICAgU0VMRiwgUEFSRU5ULCBXT1JMRCwgTk9ERVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEgdHJhbnNmb3JtLXtAbGluayBNYXRyaXg0eDR9IHRvIHRoZSBub2RlLCBtb3ZpbmcsIHNjYWxpbmcgYW5kIHJvdGF0aW5nIGl0IGluIHNwYWNlIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XG4gICAqL1xuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50VHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50VHJhbnNmb3JtKTtcbiAgICBwdWJsaWMgbXR4TG9jYWw6IE1hdHJpeDR4NDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbXR4SW5pdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCkpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLm10eExvY2FsID0gX210eEluaXQ7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9ucyByZXNwZWN0aW5nIHRoZSBoaWVyYXJjaHlcbiAgICAvKipcbiAgICAgKiByZWNhbGN1bGF0ZXMgdGhpcyBsb2NhbCBtYXRyaXggdG8geWllbGQgdGhlIGlkZW50aWNhbCB3b3JsZCBtYXRyaXggYmFzZWQgb24gdGhlIGdpdmVuIG5vZGUuXG4gICAgICogVXNlIHJlYmFzZSBiZWZvcmUgYXBwZW5kaW5nIHRoZSBjb250YWluZXIgb2YgdGhpcyBjb21wb25lbnQgdG8gYW5vdGhlciBub2RlIHdoaWxlIHByZXNlcnZpbmcgaXRzIHRyYW5zZm9ybWF0aW9uIGluIHRoZSB3b3JsZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmViYXNlKF9ub2RlOiBOb2RlID0gbnVsbCk6IHZvaWQge1xuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5tdHhMb2NhbDtcbiAgICAgIGxldCBjb250YWluZXI6IE5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICBpZiAoY29udGFpbmVyKVxuICAgICAgICBtdHhSZXN1bHQgPSBjb250YWluZXIubXR4V29ybGQ7XG5cbiAgICAgIGlmIChfbm9kZSlcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0LlJFTEFUSVZFKG10eFJlc3VsdCwgbnVsbCwgX25vZGUubXR4V29ybGRJbnZlcnNlKTtcblxuICAgICAgdGhpcy5tdHhMb2NhbCA9IG10eFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0ZWQgYmFzZSAoU0VMRiwgUEFSRU5ULCBXT1JMRCkgb3IgYSBwYXJ0aWN1bGFyIG90aGVyIG5vZGUgKE5PREUpXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9iYXNlOiBCQVNFID0gQkFTRS5TRUxGLCBfbm9kZTogTm9kZSA9IG51bGwpOiB2b2lkIHtcbiAgICAgIHN3aXRjaCAoX2Jhc2UpIHtcbiAgICAgICAgY2FzZSBCQVNFLlNFTEY6XG4gICAgICAgICAgdGhpcy5tdHhMb2NhbC5tdWx0aXBseShfbXR4VHJhbnNmb3JtKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCQVNFLlBBUkVOVDpcbiAgICAgICAgICB0aGlzLm10eExvY2FsLm11bHRpcGx5KF9tdHhUcmFuc2Zvcm0sIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJBU0UuTk9ERTpcbiAgICAgICAgICBpZiAoIV9ub2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQkFTRS5OT0RFIHJlcXVpcmVzIGEgbm9kZSBnaXZlbiBhcyBiYXNlXCIpO1xuICAgICAgICBjYXNlIEJBU0UuV09STEQ6XG4gICAgICAgICAgdGhpcy5yZWJhc2UoX25vZGUpO1xuICAgICAgICAgIHRoaXMubXR4TG9jYWwubXVsdGlwbHkoX210eFRyYW5zZm9ybSwgdHJ1ZSk7XG5cbiAgICAgICAgICBsZXQgbm9kZTogTm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbGV0IG10eFRlbXA6IE1hdHJpeDR4NDtcbiAgICAgICAgICAgIGlmIChfYmFzZSA9PSBCQVNFLk5PREUpIHtcbiAgICAgICAgICAgICAgLy8gZml4IG10eFdvcmxkIG9mIGNvbnRhaW5lciBmb3Igc3Vic2VxdWVudCByZWJhc2luZyBcbiAgICAgICAgICAgICAgbXR4VGVtcCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfbm9kZS5tdHhXb3JsZCwgbm9kZS5tdHhMb2NhbCk7XG4gICAgICAgICAgICAgIG5vZGUubXR4V29ybGQuc2V0KG10eFRlbXApO1xuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhUZW1wKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBhcmVudDogTm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgIC8vIGZpeCBtdHhMb2NhbCBmb3IgY3VycmVudCBwYXJlbnRcbiAgICAgICAgICAgICAgdGhpcy5yZWJhc2Uobm9kZS5nZXRQYXJlbnQoKSk7XG4gICAgICAgICAgICAgIG10eFRlbXAgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04obm9kZS5nZXRQYXJlbnQoKS5tdHhXb3JsZCwgbm9kZS5tdHhMb2NhbCk7XG4gICAgICAgICAgICAgIG5vZGUubXR4V29ybGQuc2V0KG10eFRlbXApO1xuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhUZW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xuICAgICAgICBsb2NhbDogdGhpcy5tdHhMb2NhbC5zZXJpYWxpemUoKSxcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgYXdhaXQgdGhpcy5tdHhMb2NhbC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5sb2NhbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBwdWJsaWMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XG4gICAgLy8gICAgIHRoaXMubG9jYWwubXV0YXRlKF9tdXRhdG9yKTtcbiAgICAvLyB9XG4gICAgLy8gcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7IFxuICAgIC8vICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXRNdXRhdG9yKCk7XG4gICAgLy8gfVxuXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XG4gICAgLy8gICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gdGhpcy5sb2NhbC5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xuICAgIC8vICAgICByZXR1cm4gdHlwZXM7XG4gICAgLy8gfVxuXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci53b3JsZDtcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxufVxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqXG4gICAqIERlc2NyaWJlcyBhIFZSIENvbnRyb2xsZXIgYW5kIGl0cyBjYXBhYmlsaXRpZXMuXG4gICAqL1xuICBleHBvcnQgY2xhc3MgVlJDb250cm9sbGVyIHtcbiAgICBwdWJsaWMgY21wVHJhbnNmb3JtOiBDb21wb25lbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHB1YmxpYyBnYW1lUGFkOiBHYW1lcGFkID0gbnVsbDtcbiAgICBwdWJsaWMgdGh1bWJzdGlja1g6IG51bWJlciA9IG51bGw7XG4gICAgcHVibGljIHRodW1ic3RpY2tZOiBudW1iZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFZSIENvbXBvbmVudCBDbGFzcywgZm9yIFNlc3Npb24gTWFuYWdlbWVudCwgQ29udHJvbGxlciBNYW5hZ2VtZW50IGFuZCBSZWZlcmVuY2UgU3BhY2UgTWFuYWdlbWVudC4gXG4gICAqIEBhdXRob3IgVmFsZW50aW4gU2NobWlkYmVyZ2VyLCBIRlUsIDIwMjJcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRWUkRldmljZSBleHRlbmRzIENvbXBvbmVudENhbWVyYSB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFZSRGV2aWNlKTtcbiAgICBwdWJsaWMgcmlnaHRDbnRybDogVlJDb250cm9sbGVyID0gbmV3IFZSQ29udHJvbGxlcigpO1xuICAgIHB1YmxpYyBsZWZ0Q250cmw6IFZSQ29udHJvbGxlciA9IG5ldyBWUkNvbnRyb2xsZXIoKTtcblxuICAgICNtdHhMb2NhbDogTWF0cml4NHg0O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmdldE10eExvY2FsRnJvbUNtcFRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0dWFsIG1hdHJpeCBvZiB0aGUgdnIgLSBkZXZpY2UuXG4gICAgICogQ3JlYXRvcnMgc2hvdWxkIHVzZSB0aGlzIGZvciByZWFkb25seSBwdXJwb3Nlcy4gIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbXR4TG9jYWwoKTogTWF0cml4NHg0IHtcbiAgICAgIHJldHVybiB0aGlzLiNtdHhMb2NhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgVmVjdG9yMyBhcyBQb3NpdGlvbiBvZiB0aGUgcmVmZXJlbmNlIHNwYWNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdHJhbnNsYXRpb24oX25ld1BvczogVmVjdG9yMykge1xuICAgICAgbGV0IGludlRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShWZWN0b3IzLkRJRkZFUkVOQ0UoX25ld1BvcywgdGhpcy4jbXR4TG9jYWwudHJhbnNsYXRpb24pLCAtMSk7XG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oaW52VHJhbnNsYXRpb24pKTtcbiAgICAgIHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uID0gX25ld1BvcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFZlY3RvcjMgUm90YXRpb24gb2YgdGhlIHJlZmVyZW5jZSBzcGFjZS5cbiAgICAgKiBSb3RhdGlvbiBuZWVkcyB0byBiZSBzZXQgaW4gdGhlIE9yaWdpbiAoMCwwLDApLCBvdGhlcndpc2UgdGhlIFhSLVJpZyBnZXRzIHJvdGF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4uIFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX25ld1JvdDogVmVjdG9yMykge1xuICAgICAgbGV0IG5ld1JvdDogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoVmVjdG9yMy5TQ0FMRShWZWN0b3IzLlNVTShfbmV3Um90LCB0aGlzLiNtdHhMb2NhbC5yb3RhdGlvbiksIC0xKSwgTWF0aC5QSSAvIDE4MCk7XG5cbiAgICAgIGxldCBvcmllbnRhdGlvbjogUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICBvcmllbnRhdGlvbi5ldWxlckFuZ2xlcyA9IG5ld1JvdDtcbiAgICAgIC8vc2V0IHhyIC0gcmlnIGJhY2sgdG8gb3JpZ2luXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uLCBWZWN0b3IzLlpFUk8oKSkpKTtcbiAgICAgIC8vcm90YXRlIHhyIHJpZyBpbiBvcmlnaW5cbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShWZWN0b3IzLlpFUk8oKSwgPERPTVBvaW50SW5pdD48dW5rbm93bj5vcmllbnRhdGlvbikpO1xuICAgICAgLy9zZXQgeHIgLSByaWcgYmFjayB0byBsYXN0IHBvc2l0aW9uIFxuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlID0gWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlLmdldE9mZnNldFJlZmVyZW5jZVNwYWNlKG5ldyBYUlJpZ2lkVHJhbnNmb3JtKFZlY3RvcjMuRElGRkVSRU5DRShWZWN0b3IzLlpFUk8oKSwgdGhpcy4jbXR4TG9jYWwudHJhbnNsYXRpb24pKSk7XG4gICAgICB0aGlzLiNtdHhMb2NhbC5yb3RhdGlvbiA9IFZlY3RvcjMuU0NBTEUoX25ld1JvdCwgLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBWZWN0b3IzIGluIFBvc2l0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3BhY2UuXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAgIGxldCBpbnZUcmFuc2xhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoX2J5LCAtMSk7XG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oaW52VHJhbnNsYXRpb24pKTtcbiAgICAgIHRoaXMuI210eExvY2FsLnRyYW5zbGF0ZShfYnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBWZWN0b3IzIGluIFJvdGF0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3BhY2UuXG4gICAgICogUm90YXRpb24gbmVlZHMgdG8gYmUgYWRkZWQgaW4gdGhlIE9yaWdpbiAoMCwwLDApLCBvdGhlcndpc2UgdGhlIFhSLVJpZyBnZXRzIHJvdGF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4uIFxuICAgICAqL1xuICAgIHB1YmxpYyByb3RhdGUoX2J5OiBWZWN0b3IzKTogdm9pZCB7XG4gICAgICBsZXQgcm90QW1vdW50OiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShWZWN0b3IzLlNDQUxFKF9ieSwgLTEpLCBNYXRoLlBJIC8gMTgwKTtcblxuICAgICAgbGV0IG9yaWVudGF0aW9uOiBRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgIG9yaWVudGF0aW9uLmV1bGVyQW5nbGVzID0gcm90QW1vdW50O1xuICAgICAgLy9zZXQgeHIgLSByaWcgYmFjayB0byBvcmlnaW5cbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcy4jbXR4TG9jYWwudHJhbnNsYXRpb24sIFZlY3RvcjMuWkVSTygpKSkpO1xuICAgICAgLy9yb3RhdGUgeHIgcmlnIGluIG9yaWdpblxuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlID0gWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlLmdldE9mZnNldFJlZmVyZW5jZVNwYWNlKG5ldyBYUlJpZ2lkVHJhbnNmb3JtKFZlY3RvcjMuWkVSTygpLCA8RE9NUG9pbnRJbml0Pjx1bmtub3duPm9yaWVudGF0aW9uKSk7XG4gICAgICAvL3NldCB4ciAtIHJpZyBiYWNrIHRvIGxhc3QgcG9zaXRpb24gXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5ESUZGRVJFTkNFKFZlY3RvcjMuWkVSTygpLCB0aGlzLiNtdHhMb2NhbC50cmFuc2xhdGlvbikpKTtcbiAgICAgIHRoaXMuI210eExvY2FsLnJvdGF0ZShWZWN0b3IzLlNDQUxFKF9ieSwgLTEpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE10eExvY2FsRnJvbUNtcFRyYW5zZm9ybSgpOiB2b2lkIHtcbiAgICAgIHRoaXMuI210eExvY2FsID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRUcmFuc2Zvcm0pLm10eExvY2FsO1xuXG4gICAgfVxuICB9XG59XG5cbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0NPTlRST0wge1xuICAgIElOUFVUID0gXCJpbnB1dFwiLFxuICAgIE9VVFBVVCA9IFwib3V0cHV0XCJcbiAgfVxuXG4gIGV4cG9ydCBjb25zdCBlbnVtIENPTlRST0xfVFlQRSB7XG4gICAgLyoqIFRoZSBvdXRwdXQgc2ltcGx5IGZvbGxvd3MgdGhlIHNjYWxlZCBhbmQgZGVsYXllZCBpbnB1dCAqL1xuICAgIFBST1BPUlRJT05BTCxcbiAgICAvKiogVGhlIG91dHB1dCB2YWx1ZSBjaGFuZ2VzIG92ZXIgdGltZSB3aXRoIGEgcmF0ZSBnaXZlbiBieSB0aGUgc2NhbGVkIGFuZCBkZWxheWVkIGlucHV0ICovXG4gICAgSU5URUdSQUwsXG4gICAgLyoqIFRoZSBvdXRwdXQgdmFsdWUgcmVhY3RzIHRvIGNoYW5nZXMgb2YgdGhlIHNjYWxlZCBpbnB1dCBhbmQgZHJvcHMgdG8gMCB3aXRoIGdpdmVuIGRlbGF5LCBpZiBpbnB1dCByZW1haW5zIGNvbnN0YW50ICovXG4gICAgRElGRkVSRU5USUFMXG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGlucHV0IHNpZ25hbHMgb2YgdHlwZSBudW1iZXIgYW5kIGdlbmVyYXRlcyBhbiBvdXRwdXQgc2lnbmFsIG9mIHRoZSBzYW1lIHR5cGUgdXNpbmcgXG4gICAqIHByb3BvcnRpb25hbCwgaW50ZWdyYWwgb3IgZGlmZmVyZW50aWFsIG1hcHBpbmcsIGFuIGFtcGxpZmljYXRpb24gZmFjdG9yIGFuZCBhIGxpbmVhciBkYW1wZW5pbmcvZGVsYXlcbiAgICogYGBgdGV4dFxuICAgKiAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgKiAgICAgICAgIOKUgiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgIHBhc3MgdGhyb3VnaCAoUHJvcG9ydGlvbmFsKSAgICAgIOKUglxuICAgKiBJbnB1dCDihpIg4pSCIOKGkiDilIJhbXBsaWZ54pSCIOKGkiDilIJkZWxheeKUgiDihpIg4pqfIHN1bSB1cCBvdmVyIHRpbWUgKEludGVncmFsKSDimp4g4oaSIOKUgiDihpIgT3V0cHV0XG4gICAqICAgICAgICAg4pSCICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgcGFzcyBjaGFuZ2UgIChEaWZmZXJlbnRpYWwpICAgICAg4pSCXG4gICAqICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxuICAgKiBgYGBcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBDb250cm9sIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIHB1YmxpYyByZWFkb25seSB0eXBlOiBDT05UUk9MX1RZUEU7XG4gICAgcHVibGljIGFjdGl2ZTogYm9vbGVhbjtcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xuXG4gICAgcHJvdGVjdGVkIHJhdGVEaXNwYXRjaE91dHB1dDogbnVtYmVyID0gMDtcbiAgICBwcm90ZWN0ZWQgdmFsdWVQcmV2aW91czogbnVtYmVyID0gMDtcbiAgICBwcm90ZWN0ZWQgb3V0cHV0QmFzZTogbnVtYmVyID0gMDtcbiAgICBwcm90ZWN0ZWQgb3V0cHV0VGFyZ2V0OiBudW1iZXIgPSAwO1xuICAgIHByb3RlY3RlZCBvdXRwdXRQcmV2aW91czogbnVtYmVyID0gMDtcbiAgICBwcm90ZWN0ZWQgb3V0cHV0VGFyZ2V0UHJldmlvdXM6IG51bWJlciA9IDA7XG4gICAgcHJvdGVjdGVkIGZhY3RvcjogbnVtYmVyID0gMDtcblxuICAgIHByb3RlY3RlZCB0aW1lOiBUaW1lID0gVGltZS5nYW1lO1xuICAgIHByb3RlY3RlZCB0aW1lVmFsdWVEZWxheTogbnVtYmVyID0gMDtcbiAgICBwcm90ZWN0ZWQgdGltZU91dHB1dFRhcmdldFNldDogbnVtYmVyID0gMDtcbiAgICBwcm90ZWN0ZWQgaWRUaW1lcjogbnVtYmVyID0gdW5kZWZpbmVkO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9mYWN0b3I6IG51bWJlciA9IDEsIF90eXBlOiBDT05UUk9MX1RZUEUgPSBDT05UUk9MX1RZUEUuUFJPUE9SVElPTkFMLCBfZGVsYXk6IG51bWJlciA9IDApIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmZhY3RvciA9IF9mYWN0b3I7XG4gICAgICB0aGlzLnR5cGUgPSBfdHlwZTtcbiAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xuICAgICAgdGhpcy5zZXREZWxheShfZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGltZS1vYmplY3QgdG8gYmUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBvdXRwdXQgaW4ge0BsaW5rIENPTlRST0xfVFlQRS5JTlRFR1JBTH1cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0VGltZWJhc2UoX3RpbWU6IFRpbWUpOiB2b2lkIHtcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xuICAgICAgdGhpcy5jYWxjdWxhdGVPdXRwdXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZWVkIGFuIGlucHV0IHZhbHVlIGludG8gdGhpcyBjb250cm9sIGFuZCBmaXJlIHRoZSBldmVudHMge0BsaW5rIEVWRU5UX0NPTlRST0wuSU5QVVR9IGFuZCB7QGxpbmsgRVZFTlRfQ09OVFJPTC5PVVRQVVR9XG4gICAgICovXG4gICAgcHVibGljIHNldElucHV0KF9pbnB1dDogbnVtYmVyKTogdm9pZCB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHRoaXMub3V0cHV0QmFzZSA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XG4gICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xuICAgICAgdGhpcy5vdXRwdXRUYXJnZXQgPSB0aGlzLmZhY3RvciAqIF9pbnB1dDtcbiAgICAgIHRoaXMudGltZU91dHB1dFRhcmdldFNldCA9IHRoaXMudGltZS5nZXQoKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMKSB7XG4gICAgICAgIHRoaXMudmFsdWVQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0IC0gdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cztcbiAgICAgICAgdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0O1xuICAgICAgICB0aGlzLm91dHB1dFRhcmdldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlRfQ09OVFJPTC5JTlBVVCkpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMKVxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KHRoaXMudmFsdWVQcmV2aW91cyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPdXRwdXQobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVE9ETzogZGVzY3JpYmUhXG4gICAgICovXG4gICAgcHVibGljIHB1bHNlKF9pbnB1dDogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLnNldElucHV0KF9pbnB1dCk7XG4gICAgICB0aGlzLnNldElucHV0KDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGltZSB0byB0YWtlIGZvciB0aGUgaW50ZXJuYWwgbGluZWFyIGRhbXBlbmluZyB1bnRpbCB0aGUgZmluYWwgb3VwdXQgdmFsdWUgaXMgcmVhY2hlZFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXREZWxheShfdGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLnRpbWVWYWx1ZURlbGF5ID0gTWF0aC5tYXgoMCwgX3RpbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIG91dHB1dC1ldmVudHMgdG8gZGlzcGF0Y2ggcGVyIHNlY29uZC4gXG4gICAgICogQXQgdGhlIGRlZmF1bHQgb2YgMCwgdGhlIGNvbnRyb2wgb3V0cHV0IG11c3QgYmUgcG9sbGVkIGFuZCB3aWxsIG9ubHkgYWN0aXZlbHkgZGlzcGF0Y2hlZCBvbmNlIGVhY2ggdGltZSBpbnB1dCBvY2N1cnMgYW5kIHRoZSBvdXRwdXQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0UmF0ZURpc3BhdGNoT3V0cHV0KF9yYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDApOiB2b2lkIHtcbiAgICAgIHRoaXMucmF0ZURpc3BhdGNoT3V0cHV0ID0gX3JhdGVEaXNwYXRjaE91dHB1dDtcbiAgICAgIHRoaXMudGltZS5kZWxldGVUaW1lcih0aGlzLmlkVGltZXIpO1xuICAgICAgdGhpcy5pZFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMucmF0ZURpc3BhdGNoT3V0cHV0KVxuICAgICAgICB0aGlzLmlkVGltZXIgPSB0aGlzLnRpbWUuc2V0VGltZXIoMTAwMCAvIHRoaXMucmF0ZURpc3BhdGNoT3V0cHV0LCAwLCB0aGlzLmRpc3BhdGNoT3V0cHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZhY3RvciB0byBtdWx0aXBseSB0aGUgaW5wdXQgdmFsdWUgZ2l2ZW4gd2l0aCB7QGxpbmsgc2V0SW5wdXR9IHdpdGhcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0RmFjdG9yKF9mYWN0b3I6IG51bWJlcik6IHZvaWQge1xuICAgICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgZnJvbSB0aGUgb3V0cHV0IG9mIHRoaXMgY29udHJvbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRPdXRwdXQoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG91dHB1dCBvZiB0aGlzIGNvbnRyb2xcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2FsY3VsYXRlT3V0cHV0KCk6IG51bWJlciB7XG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXIgPSAwO1xuICAgICAgbGV0IHZhbHVlOiBudW1iZXIgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5JTlRFR1JBTDpcbiAgICAgICAgICBsZXQgdGltZUN1cnJlbnQ6IG51bWJlciA9IHRoaXMudGltZS5nZXQoKTtcbiAgICAgICAgICBsZXQgdGltZUVsYXBzZWRTaW5jZUlucHV0OiBudW1iZXIgPSB0aW1lQ3VycmVudCAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcbiAgICAgICAgICBvdXRwdXQgPSB0aGlzLm91dHB1dEJhc2U7XG5cbiAgICAgICAgICBpZiAodGhpcy50aW1lVmFsdWVEZWxheSA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVWYWx1ZURlbGF5KSB7XG4gICAgICAgICAgICAgIG91dHB1dCArPSAwLjUgKiAodGhpcy52YWx1ZVByZXZpb3VzICsgdmFsdWUpICogdGltZUVsYXBzZWRTaW5jZUlucHV0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dCArPSAwLjUgKiAodGhpcy52YWx1ZVByZXZpb3VzICsgdmFsdWUpICogdGhpcy50aW1lVmFsdWVEZWxheTtcbiAgICAgICAgICAgICAgdGltZUVsYXBzZWRTaW5jZUlucHV0IC09IHRoaXMudGltZVZhbHVlRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dCArPSB2YWx1ZSAqIHRpbWVFbGFwc2VkU2luY2VJbnB1dDtcbiAgICAgICAgICAvLyB2YWx1ZSArPSAwLjUgKiAodGhpcy5pbnB1dFByZXZpb3VzIC0gaW5wdXQpICogdGhpcy50aW1lSW5wdXREZWxheSArIGlucHV0ICogdGltZUVsYXBzZWRTaW5jZUlucHV0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5ESUZGRVJFTlRJQUw6XG4gICAgICAgIGNhc2UgQ09OVFJPTF9UWVBFLlBST1BPUlRJT05BTDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXRwdXQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgdGhlIG91dHB1dCBjb25zaWRlcmluZyB0aGUgdGltZSBvZiB0aGUgZGVsYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFZhbHVlRGVsYXllZCgpOiBudW1iZXIge1xuICAgICAgaWYgKHRoaXMudGltZVZhbHVlRGVsYXkgPiAwKSB7XG4gICAgICAgIGxldCB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ6IG51bWJlciA9IHRoaXMudGltZS5nZXQoKSAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcbiAgICAgICAgaWYgKHRpbWVFbGFwc2VkU2luY2VJbnB1dCA8IHRoaXMudGltZVZhbHVlRGVsYXkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVQcmV2aW91cyArICh0aGlzLm91dHB1dFRhcmdldCAtIHRoaXMudmFsdWVQcmV2aW91cykgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQgLyB0aGlzLnRpbWVWYWx1ZURlbGF5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0VGFyZ2V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZGlzcGF0Y2hPdXRwdXQgPSAoX2V2ZW50T3JWYWx1ZTogRXZlbnRUaW1lciB8IG51bWJlcik6IHZvaWQgPT4ge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lLmdldFRpbWVyKHRoaXMuaWRUaW1lcik7XG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXI7XG4gICAgICBpZiAodHlwZW9mIChfZXZlbnRPclZhbHVlKSA9PSBcIm51bWJlclwiKVxuICAgICAgICBvdXRwdXQgPSBfZXZlbnRPclZhbHVlO1xuICAgICAgZWxzZVxuICAgICAgICBvdXRwdXQgPSB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xuICAgICAgbGV0IG91dHB1dENoYW5nZWQ6IGJvb2xlYW4gPSAob3V0cHV0ICE9IHRoaXMub3V0cHV0UHJldmlvdXMpO1xuXG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgdGltZXIuYWN0aXZlID0gb3V0cHV0Q2hhbmdlZDtcbiAgICAgICAgaWYgKCFvdXRwdXRDaGFuZ2VkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vdXRwdXRQcmV2aW91cyA9IG91dHB1dDtcblxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuICB9XG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiQ29udHJvbC50c1wiLz5cbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogSGFuZGxlcyBtdWx0aXBsZSBjb250cm9scyBhcyBpbnB1dHMgYW5kIGNyZWF0ZXMgYW4gb3V0cHV0IGZyb20gdGhhdC5cbiAgICogQXMgYSBzdWJjbGFzcyBvZiB7QGxpbmsgQ29udHJvbH0sIGF4aXMgY2FsY3VsYXRlcyB0aGUgb3VwdXQgc3VtbWluZyB1cCB0aGUgaW5wdXRzIGFuZCBwcm9jZXNzaW5nIHRoZSByZXN1bHQgdXNpbmcgaXRzIG93biBzZXR0aW5ncy4gIFxuICAgKiBEaXNwYXRjaGVzIHtAbGluayBFVkVOVF9DT05UUk9MLk9VVFBVVH0gYW5kIHtAbGluayBFVkVOVF9DT05UUk9MLklOUFVUfSB3aGVuIG9uZSBvZiB0aGUgY29udHJvbHMgZGlzcGF0Y2hlcyB0aGVtLlxuICAgKiBgYGB0ZXh0XG4gICAqICAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICogICAgICAgICAgIOKUgiDilIzilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIJcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgKiAgICAgICAgICAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgXFzilIzilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICDilIJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIItLS3ilIJzdW3ilIIg4oaSIOKUgmludGVybmFsIGNvbnRyb2wg4pSCIOKGkiDilIIg4oaSIE91dHB1dFxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgL+KUlOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUglxuICAgKiAgICAgICAgICAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgKiAgIElucHV0IOKGkiDilIIg4pSCY29udHJvbOKUgi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuICAgKiAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICBcbiAgICogYGBgXG4gICAqL1xuICBleHBvcnQgY2xhc3MgQXhpcyBleHRlbmRzIENvbnRyb2wge1xuICAgIHByaXZhdGUgY29udHJvbHM6IE1hcDxzdHJpbmcsIENvbnRyb2w+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgc3VtUHJldmlvdXM6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGNvbnRyb2wgZ2l2ZW4gdG8gdGhlIGxpc3Qgb2YgY29udHJvbHMgZmVlZGluZyBpbnRvIHRoaXMgYXhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBhZGRDb250cm9sKF9jb250cm9sOiBDb250cm9sKTogdm9pZCB7XG4gICAgICB0aGlzLmNvbnRyb2xzLnNldChfY29udHJvbC5uYW1lLCBfY29udHJvbCk7XG4gICAgICBfY29udHJvbC5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuSU5QVVQsIHRoaXMuaG5kSW5wdXRFdmVudCk7XG4gICAgICBfY29udHJvbC5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuT1VUUFVULCB0aGlzLmhuZE91dHB1dEV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29udHJvbChfbmFtZTogc3RyaW5nKTogQ29udHJvbCB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cm9scy5nZXQoX25hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVDb250cm9sKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGxldCBjb250cm9sOiBDb250cm9sID0gdGhpcy5nZXRDb250cm9sKF9uYW1lKTtcbiAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLklOUFVULCB0aGlzLmhuZElucHV0RXZlbnQpO1xuICAgICAgICBjb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQ09OVFJPTC5PVVRQVVQsIHRoaXMuaG5kT3V0cHV0RXZlbnQpO1xuICAgICAgICB0aGlzLmNvbnRyb2xzLmRlbGV0ZShfbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhpcyBheGlzIGFmdGVyIHN1bW1pbmcgdXAgYWxsIGlucHV0cyBhbmQgcHJvY2Vzc2luZyB0aGUgc3VtIGFjY29yZGluZyB0byB0aGUgYXhpcycgc2V0dGluZ3NcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0T3V0cHV0KCk6IG51bWJlciB7XG4gICAgICBsZXQgc3VtSW5wdXQ6IG51bWJlciA9IDA7XG4gICAgICBmb3IgKGxldCBjb250cm9sIG9mIHRoaXMuY29udHJvbHMpIHtcblxuICAgICAgICBpZiAoY29udHJvbFsxXS5hY3RpdmUpXG4gICAgICAgICAgc3VtSW5wdXQgKz0gY29udHJvbFsxXS5nZXRPdXRwdXQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1bUlucHV0ICE9IHRoaXMuc3VtUHJldmlvdXMpXG4gICAgICAgIHN1cGVyLnNldElucHV0KHN1bUlucHV0KTtcblxuICAgICAgdGhpcy5zdW1QcmV2aW91cyA9IHN1bUlucHV0O1xuXG4gICAgICByZXR1cm4gc3VwZXIuZ2V0T3V0cHV0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBobmRPdXRwdXRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGxldCBjb250cm9sOiBDb250cm9sID0gKDxDb250cm9sPl9ldmVudC50YXJnZXQpO1xuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBjb250cm9sOiBjb250cm9sLFxuICAgICAgICAgIGlucHV0OiAoPEN1c3RvbUV2ZW50Pl9ldmVudCkuZGV0YWlsLm91dHB1dCxcbiAgICAgICAgICBvdXRwdXQ6IHRoaXMuZ2V0T3V0cHV0KClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGhuZElucHV0RXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50ID0gbmV3IEV2ZW50KEVWRU5UX0NPTlRST0wuSU5QVVQsIF9ldmVudCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgaW50ZXJmYWNlIEtleVByZXNzZWQge1xuICAgIFtjb2RlOiBzdHJpbmddOiBib29sZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIHRoZSBrZXlzIHByZXNzZWQgb24gdGhlIGtleWJvYXJkIGFuZCBzdG9yZXMgdGhlaXIgc3RhdHVzLiBcbiAgICovXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBLZXlib2FyZCB7XG4gICAgcHJpdmF0ZSBzdGF0aWMga2V5c1ByZXNzZWQ6IEtleVByZXNzZWQgPSBLZXlib2FyZC5pbml0aWFsaXplKCk7XG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgY29kZV9lbjogT2JqZWN0O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cyBpcyBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzUHJlc3NlZE9uZShfa2V5czogS0VZQk9BUkRfQ09ERVtdKTogYm9vbGVhbiB7XG4gICAgICBmb3IgKGxldCBjb2RlIG9mIF9rZXlzKSB7XG4gICAgICAgIGlmIChLZXlib2FyZC5rZXlzUHJlc3NlZFtjb2RlXSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSBnaXZlbiBrZXlzIGFyZSBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNQcmVzc2VkQ29tYm8oX2tleXM6IEtFWUJPQVJEX0NPREVbXSk6IGJvb2xlYW4ge1xuICAgICAgZm9yIChsZXQgY29kZSBvZiBfa2V5cykge1xuICAgICAgICBpZiAoIUtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGdpdmVuIGFzIF9hY3RpdmUgaWYgb25lIG9yLCB3aGVuIF9jb21ibyBpcyB0cnVlLCBhbGwgb2YgdGhlIGdpdmVuIGtleXMgYXJlIHByZXNzZWQuXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZ2l2ZW4gYXMgX2luYWN0aXZlIGlmIG5vdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1hcFRvVmFsdWU8VD4oX2FjdGl2ZTogVCwgX2luYWN0aXZlOiBULCBfa2V5czogS0VZQk9BUkRfQ09ERVtdLCBfY29tYm86IGJvb2xlYW4gPSBmYWxzZSk6IFQge1xuICAgICAgaWYgKCFfY29tYm8gJiYgS2V5Ym9hcmQuaXNQcmVzc2VkT25lKF9rZXlzKSlcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XG4gICAgICBpZiAoS2V5Ym9hcmQuaXNQcmVzc2VkQ29tYm8oX2tleXMpKVxuICAgICAgICByZXR1cm4gX2FjdGl2ZTtcbiAgICAgIHJldHVybiBfaW5hY3RpdmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhbGFuY2VkIHRlcm5hcnkgdmFsdWUgKGVpdGhlciAtMSwgMCBvciAxKSBcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIG1hdGNoIG9mIHRoZSBrZXlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGFuZCB0aGUgbGlzdHMgb2Yga2V5cyBnaXZlbiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1hcFRvVHJpdChfcG9zaXRpdmU6IEtFWUJPQVJEX0NPREVbXSwgX25lZ2F0aXZlOiBLRVlCT0FSRF9DT0RFW10pOiBudW1iZXIge1xuICAgICAgcmV0dXJuIEtleWJvYXJkLm1hcFRvVmFsdWUoLTEsIDAsIF9uZWdhdGl2ZSkgKyBLZXlib2FyZC5tYXBUb1ZhbHVlKDEsIDAsIF9wb3NpdGl2ZSk7XG4gICAgfVxuXG4gICAgLy8gcHVibGljIHN0YXRpYyBsb2NhbGUoX2tleWJvYXJkOiBPYmplY3QpOiB2b2lkIHtcbiAgICAvLyAgIGlmICghS2V5Ym9hcmQuY29kZV9lbikge1xuICAgIC8vICAgICAvLyBzYXZlIG9yaWdpbmFsIGtleWJvYXJkIGNvZGVzIHRvIGJlIGFibGUgdG8gc3dpdGNoIGJhY2sgbGF0ZXJcbiAgICAvLyAgICAgS2V5Ym9hcmQuY29kZV9lbiA9IHt9O1xuICAgIC8vICAgICBPYmplY3QuYXNzaWduKEtleWJvYXJkLmNvZGVfZW4sIEtFWUJPQVJEX0NPREUpO1xuICAgIC8vICAgfVxuXG4gICAgLy8gICBmb3IgKGxldCBrZXkgaW4gX2tleWJvYXJkKSB7XG4gICAgLy8gICAgIGxldCB2YWx1ZTogc3RyaW5nID0gUmVmbGVjdC5nZXQoX2tleWJvYXJkLCBrZXkpO1xuICAgIC8vICAgICBmb3IgKGxldCBvcmlnaW5hbCBpbiBLRVlCT0FSRF9DT0RFKVxuICAgIC8vICAgICAgIGlmIChSZWZsZWN0LmdldChLRVlCT0FSRF9DT0RFLCBvcmlnaW5hbCkgPT0gdmFsdWUpXG4gICAgLy8gICAgICAgICAvLyByZW1vdmUgb3JpZ2luYWwga2V5IHRoZSB5aWVsZHMgdGhlIHZhbHVlXG4gICAgLy8gICAgICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEtFWUJPQVJEX0NPREUsIG9yaWdpbmFsKTtcbiAgICAvLyAgICAgLy8gYWRkIG5ldyBrZXkgdG8geWllbGQgdGhhdCB2YWx1ZVxuICAgIC8vICAgICBSZWZsZWN0LnNldChLRVlCT0FSRF9DT0RFLCBrZXksIHZhbHVlKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBpbml0aWFsaXplKCk6IEtleVByZXNzZWQge1xuICAgICAgbGV0IHN0b3JlOiBLZXlQcmVzc2VkID0ge307XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBLZXlib2FyZC5obmRLZXlJbnRlcmFjdGlvbik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgS2V5Ym9hcmQuaG5kS2V5SW50ZXJhY3Rpb24pO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGhuZEtleUludGVyYWN0aW9uKF9ldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgS2V5Ym9hcmQua2V5c1ByZXNzZWRbX2V2ZW50LmNvZGVdID0gKF9ldmVudC50eXBlID09IFwia2V5ZG93blwiKTtcbiAgICB9XG4gIH1cbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBSb3V0aW5nIHRvIHRoZSBhbGVydCBib3hcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z0FsZXJ0IGV4dGVuZHMgRGVidWdUYXJnZXQge1xuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XG4gICAgICBbREVCVUdfRklMVEVSLklORk9dOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuSU5GT10pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuV0FSTl0pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5FUlJPUl0pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuU09VUkNFXSlcbiAgICB9O1xuXG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgYSBkZWxlZ2F0ZS1mdW5jdGlvbiBleHBlY3RpbmcgYSBtZXNzYWdlIHRvIGxvZy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZURlbGVnYXRlKF9oZWFkbGluZTogc3RyaW5nKTogRnVuY3Rpb24ge1xuICAgICAgbGV0IGRlbGVnYXRlOiBGdW5jdGlvbiA9IGZ1bmN0aW9uIChfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcbiAgICAgICAgbGV0IGFyZ3M6IHN0cmluZ1tdID0gX2FyZ3MubWFwKF9hcmcgPT4gX2FyZy50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IG91dDogc3RyaW5nID0gX2hlYWRsaW5lICsgXCIgXCIgKyBEZWJ1Z1RhcmdldC5tZXJnZUFyZ3VtZW50cyhfbWVzc2FnZSwgYXJncyk7XG4gICAgICAgIGFsZXJ0KG91dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRlbGVnYXRlO1xuICAgIH1cbiAgfVxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFJvdXRpbmcgdG8gYSBIVE1MRGlhbG9nRWxlbWVudFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIERlYnVnRGlhbG9nIGV4dGVuZHMgRGVidWdUYXJnZXQge1xuICAgIC8vIFRPRE86IGNoZWNrb3V0IEhUTUxEaWFsb2dFbGVtZW50OyAhISFcbiAgfVxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFJvdXRlIHRvIGFuIEhUTUxUZXh0QXJlYSwgbWF5IGJlIG9ic29sZXRlIHdoZW4gdXNpbmcgSFRNTERpYWxvZ0VsZW1lbnRcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z1RleHRBcmVhIGV4dGVuZHMgRGVidWdUYXJnZXQge1xuICAgIHB1YmxpYyBzdGF0aWMgdGV4dEFyZWE6IEhUTUxUZXh0QXJlYUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgcHVibGljIHN0YXRpYyBhdXRvU2Nyb2xsOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XG4gICAgICBbREVCVUdfRklMVEVSLklORk9dOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuSU5GT10pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuV0FSTl0pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5FUlJPUl0pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5DTEVBUl06IERlYnVnVGV4dEFyZWEuY2xlYXIsXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQXTogRGVidWdUZXh0QXJlYS5ncm91cCxcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRURdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwLFxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUEVORF06IERlYnVnVGV4dEFyZWEuZ3JvdXBFbmQsXG4gICAgICBbREVCVUdfRklMVEVSLlNPVVJDRV06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxuICAgIH07XG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSB0ZXh0IGFyZWEgYW5kIHRoZSBncm91cHNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICBEZWJ1Z1RleHRBcmVhLmdyb3VwcyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJlZ2lucyBhIG5ldyBncm91cCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBncm91cChfbmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICBEZWJ1Z1RleHRBcmVhLnByaW50KFwi4pa8IFwiICsgX25hbWUpO1xuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucHVzaChfbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuZHMgdGhlIGxhc3QgZ3JvdXBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwRW5kKCk6IHZvaWQge1xuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucG9wKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRlbGVnYXRlLWZ1bmN0aW9uIGV4cGVjdGluZyBhIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRGVsZWdhdGUoX2hlYWRsaW5lOiBzdHJpbmcpOiBGdW5jdGlvbiB7XG4gICAgICBsZXQgZGVsZWdhdGU6IEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xuICAgICAgICBEZWJ1Z1RleHRBcmVhLnByaW50KF9oZWFkbGluZSArIFwiIFwiICsgRGVidWdUYXJnZXQubWVyZ2VBcmd1bWVudHMoX21lc3NhZ2UsIF9hcmdzKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRlbGVnYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldEluZGVudGF0aW9uKF9sZXZlbDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2xldmVsOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBcInwgXCI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHByaW50KF90ZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIERlYnVnVGV4dEFyZWEudGV4dEFyZWEudGV4dENvbnRlbnQgKz0gRGVidWdUZXh0QXJlYS5nZXRJbmRlbnRhdGlvbihEZWJ1Z1RleHRBcmVhLmdyb3Vwcy5sZW5ndGgpICsgX3RleHQgKyBcIlxcblwiO1xuICAgICAgaWYgKERlYnVnVGV4dEFyZWEuYXV0b1Njcm9sbClcbiAgICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS5zY3JvbGxUb3AgPSBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnNjcm9sbEhlaWdodDtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFRoZSBjb2RlcyBzZW50IGZyb20gYSBzdGFuZGFyZCBlbmdsaXNoIGtleWJvYXJkIGxheW91dFxuICAgKi9cbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERSB7XG4gICAgQSA9IFwiS2V5QVwiLFxuICAgIEIgPSBcIktleUJcIixcbiAgICBDID0gXCJLZXlDXCIsXG4gICAgRCA9IFwiS2V5RFwiLFxuICAgIEUgPSBcIktleUVcIixcbiAgICBGID0gXCJLZXlGXCIsXG4gICAgRyA9IFwiS2V5R1wiLFxuICAgIEggPSBcIktleUhcIixcbiAgICBJID0gXCJLZXlJXCIsXG4gICAgSiA9IFwiS2V5SlwiLFxuICAgIEsgPSBcIktleUtcIixcbiAgICBMID0gXCJLZXlMXCIsXG4gICAgTSA9IFwiS2V5TVwiLFxuICAgIE4gPSBcIktleU5cIixcbiAgICBPID0gXCJLZXlPXCIsXG4gICAgUCA9IFwiS2V5UFwiLFxuICAgIFEgPSBcIktleVFcIixcbiAgICBSID0gXCJLZXlSXCIsXG4gICAgUyA9IFwiS2V5U1wiLFxuICAgIFQgPSBcIktleVRcIixcbiAgICBVID0gXCJLZXlVXCIsXG4gICAgViA9IFwiS2V5VlwiLFxuICAgIFcgPSBcIktleVdcIixcbiAgICBYID0gXCJLZXlYXCIsXG4gICAgWSA9IFwiS2V5WVwiLFxuICAgIFogPSBcIktleVpcIixcbiAgICBFU0MgPSBcIkVzY2FwZVwiLFxuICAgIFpFUk8gPSBcIkRpZ2l0MFwiLFxuICAgIE9ORSA9IFwiRGlnaXQxXCIsXG4gICAgVFdPID0gXCJEaWdpdDJcIixcbiAgICBUSFJFRSA9IFwiRGlnaXQzXCIsXG4gICAgRk9VUiA9IFwiRGlnaXQ0XCIsXG4gICAgRklWRSA9IFwiRGlnaXQ1XCIsXG4gICAgU0lYID0gXCJEaWdpdDZcIixcbiAgICBTRVZFTiA9IFwiRGlnaXQ3XCIsXG4gICAgRUlHSFQgPSBcIkRpZ2l0OFwiLFxuICAgIE5JTkUgPSBcIkRpZ2l0OVwiLFxuICAgIE1JTlVTID0gXCJNaW51c1wiLFxuICAgIEVRVUFMID0gXCJFcXVhbFwiLFxuICAgIEJBQ0tTUEFDRSA9IFwiQmFja3NwYWNlXCIsXG4gICAgVEFCVUxBVE9SID0gXCJUYWJcIixcbiAgICBCUkFDS0VUX0xFRlQgPSBcIkJyYWNrZXRMZWZ0XCIsXG4gICAgQlJBQ0tFVF9SSUdIVCA9IFwiQnJhY2tldFJpZ2h0XCIsXG4gICAgRU5URVIgPSBcIkVudGVyXCIsXG4gICAgQ1RSTF9MRUZUID0gXCJDb250cm9sTGVmdFwiLFxuICAgIFNFTUlDT0xPTiA9IFwiU2VtaWNvbG9uXCIsXG4gICAgUVVPVEUgPSBcIlF1b3RlXCIsXG4gICAgQkFDS19RVU9URSA9IFwiQmFja3F1b3RlXCIsXG4gICAgU0hJRlRfTEVGVCA9IFwiU2hpZnRMZWZ0XCIsXG4gICAgQkFDS1NMQVNIID0gXCJCYWNrc2xhc2hcIixcbiAgICBDT01NQSA9IFwiQ29tbWFcIixcbiAgICBQRVJJT0QgPSBcIlBlcmlvZFwiLFxuICAgIFNMQVNIID0gXCJTbGFzaFwiLFxuICAgIFNISUZUX1JJR0hUID0gXCJTaGlmdFJpZ2h0XCIsXG4gICAgTlVNUEFEX01VTFRJUExZID0gXCJOdW1wYWRNdWx0aXBseVwiLFxuICAgIEFMVF9MRUZUID0gXCJBbHRMZWZ0XCIsXG4gICAgU1BBQ0UgPSBcIlNwYWNlXCIsXG4gICAgQ0FQU19MT0NLID0gXCJDYXBzTG9ja1wiLFxuICAgIEYxID0gXCJGMVwiLFxuICAgIEYyID0gXCJGMlwiLFxuICAgIEYzID0gXCJGM1wiLFxuICAgIEY0ID0gXCJGNFwiLFxuICAgIEY1ID0gXCJGNVwiLFxuICAgIEY2ID0gXCJGNlwiLFxuICAgIEY3ID0gXCJGN1wiLFxuICAgIEY4ID0gXCJGOFwiLFxuICAgIEY5ID0gXCJGOVwiLFxuICAgIEYxMCA9IFwiRjEwXCIsXG4gICAgUEFVU0UgPSBcIlBhdXNlXCIsXG4gICAgU0NST0xMX0xPQ0sgPSBcIlNjcm9sbExvY2tcIixcbiAgICBOVU1QQUQ3ID0gXCJOdW1wYWQ3XCIsXG4gICAgTlVNUEFEOCA9IFwiTnVtcGFkOFwiLFxuICAgIE5VTVBBRDkgPSBcIk51bXBhZDlcIixcbiAgICBOVU1QQURfU1VCVFJBQ1QgPSBcIk51bXBhZFN1YnRyYWN0XCIsXG4gICAgTlVNUEFENCA9IFwiTnVtcGFkNFwiLFxuICAgIE5VTVBBRDUgPSBcIk51bXBhZDVcIixcbiAgICBOVU1QQUQ2ID0gXCJOdW1wYWQ2XCIsXG4gICAgTlVNUEFEX0FERCA9IFwiTnVtcGFkQWRkXCIsXG4gICAgTlVNUEFEMSA9IFwiTnVtcGFkMVwiLFxuICAgIE5VTVBBRDIgPSBcIk51bXBhZDJcIixcbiAgICBOVU1QQUQzID0gXCJOdW1wYWQzXCIsXG4gICAgTlVNUEFEMCA9IFwiTnVtcGFkMFwiLFxuICAgIE5VTVBBRF9ERUNJTUFMID0gXCJOdW1wYWREZWNpbWFsXCIsXG4gICAgUFJJTlRfU0NSRUVOID0gXCJQcmludFNjcmVlblwiLFxuICAgIElOVExfQkFDS19TTEFTSCA9IFwiSW50bEJhY2tTbGFzaFwiLFxuICAgIEYxMSA9IFwiRjExXCIsXG4gICAgRjEyID0gXCJGMTJcIixcbiAgICBOVU1QQURfRVFVQUwgPSBcIk51bXBhZEVxdWFsXCIsXG4gICAgRjEzID0gXCJGMTNcIixcbiAgICBGMTQgPSBcIkYxNFwiLFxuICAgIEYxNSA9IFwiRjE1XCIsXG4gICAgRjE2ID0gXCJGMTZcIixcbiAgICBGMTcgPSBcIkYxN1wiLFxuICAgIEYxOCA9IFwiRjE4XCIsXG4gICAgRjE5ID0gXCJGMTlcIixcbiAgICBGMjAgPSBcIkYyMFwiLFxuICAgIEYyMSA9IFwiRjIxXCIsXG4gICAgRjIyID0gXCJGMjJcIixcbiAgICBGMjMgPSBcIkYyM1wiLFxuICAgIEYyNCA9IFwiRjI0XCIsXG4gICAgS0FOQV9NT0RFID0gXCJLYW5hTW9kZVwiLFxuICAgIExBTkcyID0gXCJMYW5nMlwiLFxuICAgIExBTkcxID0gXCJMYW5nMVwiLFxuICAgIElOVExfUk8gPSBcIkludGxSb1wiLFxuICAgIENPTlZFUlQgPSBcIkNvbnZlcnRcIixcbiAgICBOT05fQ09OVkVSVCA9IFwiTm9uQ29udmVydFwiLFxuICAgIElOVExfWUVOID0gXCJJbnRsWWVuXCIsXG4gICAgTlVNUEFEX0NPTU1BID0gXCJOdW1wYWRDb21tYVwiLFxuICAgIFVORE8gPSBcIlVuZG9cIixcbiAgICBQQVNURSA9IFwiUGFzdGVcIixcbiAgICBNRURJQV9UUkFDS19QUkVWSU9VUyA9IFwiTWVkaWFUcmFja1ByZXZpb3VzXCIsXG4gICAgQ1VUID0gXCJDdXRcIixcbiAgICBDT1BZID0gXCJDb3B5XCIsXG4gICAgTUVESUFfVFJBQ0tfTkVYVCA9IFwiTWVkaWFUcmFja05leHRcIixcbiAgICBOVU1QQURfRU5URVIgPSBcIk51bXBhZEVudGVyXCIsXG4gICAgQ1RSTF9SSUdIVCA9IFwiQ29udHJvbFJpZ2h0XCIsXG4gICAgQVVESU9fVk9MVU1FX01VVEUgPSBcIkF1ZGlvVm9sdW1lTXV0ZVwiLFxuICAgIExBVU5DSF9BUFAyID0gXCJMYXVuY2hBcHAyXCIsXG4gICAgTUVESUFfUExBWV9QQVVTRSA9IFwiTWVkaWFQbGF5UGF1c2VcIixcbiAgICBNRURJQV9TVE9QID0gXCJNZWRpYVN0b3BcIixcbiAgICBFSkVDVCA9IFwiRWplY3RcIixcbiAgICBBVURJT19WT0xVTUVfRE9XTiA9IFwiQXVkaW9Wb2x1bWVEb3duXCIsXG4gICAgVk9MVU1FX0RPV04gPSBcIlZvbHVtZURvd25cIixcbiAgICBBVURJT19WT0xVTUVfVVAgPSBcIkF1ZGlvVm9sdW1lVXBcIixcbiAgICBWT0xVTUVfVVAgPSBcIlZvbHVtZVVwXCIsXG4gICAgQlJPV1NFUl9IT01FID0gXCJCcm93c2VySG9tZVwiLFxuICAgIE5VTVBBRF9ESVZJREUgPSBcIk51bXBhZERpdmlkZVwiLFxuICAgIEFMVF9SSUdIVCA9IFwiQWx0UmlnaHRcIixcbiAgICBIRUxQID0gXCJIZWxwXCIsXG4gICAgTlVNX0xPQ0sgPSBcIk51bUxvY2tcIixcbiAgICBIT01FID0gXCJIb21lXCIsXG4gICAgQVJST1dfVVAgPSBcIkFycm93VXBcIixcbiAgICBBUlJPV19SSUdIVCA9IFwiQXJyb3dSaWdodFwiLFxuICAgIEFSUk9XX0RPV04gPSBcIkFycm93RG93blwiLFxuICAgIEFSUk9XX0xFRlQgPSBcIkFycm93TGVmdFwiLFxuICAgIEVORCA9IFwiRW5kXCIsXG4gICAgUEFHRV9VUCA9IFwiUGFnZVVwXCIsXG4gICAgUEFHRV9ET1dOID0gXCJQYWdlRG93blwiLFxuICAgIElOU0VSVCA9IFwiSW5zZXJ0XCIsXG4gICAgREVMRVRFID0gXCJEZWxldGVcIixcbiAgICBNRVRBX0xFRlQgPSBcIk1ldGFfTGVmdFwiLFxuICAgIE9TX0xFRlQgPSBcIk9TTGVmdFwiLFxuICAgIE1FVEFfUklHSFQgPSBcIk1ldGFSaWdodFwiLFxuICAgIE9TX1JJR0hUID0gXCJPU1JpZ2h0XCIsXG4gICAgQ09OVEVYVF9NRU5VID0gXCJDb250ZXh0TWVudVwiLFxuICAgIFBPV0VSID0gXCJQb3dlclwiLFxuICAgIEJST1dTRVJfU0VBUkNIID0gXCJCcm93c2VyU2VhcmNoXCIsXG4gICAgQlJPV1NFUl9GQVZPUklURVMgPSBcIkJyb3dzZXJGYXZvcml0ZXNcIixcbiAgICBCUk9XU0VSX1JFRlJFU0ggPSBcIkJyb3dzZXJSZWZyZXNoXCIsXG4gICAgQlJPV1NFUl9TVE9QID0gXCJCcm93c2VyU3RvcFwiLFxuICAgIEJST1dTRVJfRk9SV0FSRCA9IFwiQnJvd3NlckZvcndhcmRcIixcbiAgICBCUk9XU0VSX0JBQ0sgPSBcIkJyb3dzZXJCYWNrXCIsXG4gICAgTEFVTkNIX0FQUDEgPSBcIkxhdW5jaEFwcDFcIixcbiAgICBMQVVOQ0hfTUFJTCA9IFwiTGF1bmNoTWFpbFwiLFxuICAgIExBVU5DSF9NRURJQV9QTEFZRVIgPSBcIkxhdW5jaE1lZGlhUGxheWVyXCIsXG5cbiAgICAvL21hYyBicmluZ3MgdGhpcyBidXR0dG9uXG4gICAgRk4gPSBcIkZuXCIsIC8vbm8gZXZlbnQgZmlyZWQgYWN0dWFsbHlcblxuICAgIC8vTGludXggYnJpbmdzIHRoZXNlXG4gICAgQUdBSU4gPSBcIkFnYWluXCIsXG4gICAgUFJPUFMgPSBcIlByb3BzXCIsXG4gICAgU0VMRUNUID0gXCJTZWxlY3RcIixcbiAgICBPUEVOID0gXCJPcGVuXCIsXG4gICAgRklORCA9IFwiRmluZFwiLFxuICAgIFdBS0VfVVAgPSBcIldha2VVcFwiLFxuICAgIE5VTVBBRF9QQVJFTlRfTEVGVCA9IFwiTnVtcGFkUGFyZW50TGVmdFwiLFxuICAgIE5VTVBBRF9QQVJFTlRfUklHSFQgPSBcIk51bXBhZFBhcmVudFJpZ2h0XCIsXG5cbiAgICAvL2FuZHJvaWRcbiAgICBTTEVFUCA9IFwiU2xlZXBcIlxuICB9XG5cbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERV9ERSB7XG4gICAgWiA9IEtFWUJPQVJEX0NPREUuWSxcbiAgICBZID0gS0VZQk9BUkRfQ09ERS5aLFxuICAgIMOWID0gS0VZQk9BUkRfQ09ERS5TRU1JQ09MT04sXG4gICAgw4QgPSBLRVlCT0FSRF9DT0RFLlFVT1RFLFxuICAgIMOcID0gS0VZQk9BUkRfQ09ERS5CUkFDS0VUX0xFRlQsXG4gICAgSEFTSCA9IEtFWUJPQVJEX0NPREUuQkFDS1NMQVNILFxuICAgIFBMVVMgPSBLRVlCT0FSRF9DT0RFLkJSQUNLRVRfUklHSFQsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIFxuICAgIMOfID0gS0VZQk9BUkRfQ09ERS5NSU5VUyxcbiAgICBBQ1VURSA9IEtFWUJPQVJEX0NPREUuRVFVQUwsXG4gICAgTEVTU19USEFOID0gS0VZQk9BUkRfQ09ERS5JTlRMX0JBQ0tfU0xBU0gsXG4gICAgTUlOVVMgPSBLRVlCT0FSRF9DT0RFLlNMQVNIXG4gIH1cblxuICAvKiBcbiAgRmlyZWZveCBjYW4ndCBtYWtlIHVzZSBvZiB0aG9zZSBidXR0b25zIGFuZCBDb21iaW5hdGlvbnM6XG4gIFNJTkdFTEVfQlVUVE9OUzpcbiAgIERydWNrLFxuICBDT01CSU5BVElPTlM6XG4gICBTaGlmdCArIEYxMCwgU2hpZnQgKyBOdW1wYWQ1LFxuICAgQ1RSTCArIHEsIENUUkwgKyBGNCxcbiAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjMsIEFMVCArIEY3LCBBTFQgKyBGOCwgQUxUICsgRjEwXG4gIE9wZXJhIHdvbid0IGRvIGdvb2Qgd2l0aCB0aGVzZSBCdXR0b25zIGFuZCBjb21iaW5hdGlvbnM6XG4gIFNJTkdMRV9CVVRUT05TOlxuICAgRmxvYXQzMkFycmF5LCBGMTEsIEFMVCxcbiAgQ09NQklOQVRJT05TOlxuICAgQ1RSTCArIHEsIENUUkwgKyB0LCBDVFJMICsgaCwgQ1RSTCArIGcsIENUUkwgKyBuLCBDVFJMICsgZiBcbiAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjQsIEFMVCArIEY1LCBBTFQgKyBGNiwgQUxUICsgRjcsIEFMVCArIEY4LCBBTFQgKyBGMTBcbiAgICovXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX1RJTUVSIHtcbiAgICBDQUxMID0gXCLGkmxhcHNlXCJcbiAgfVxuICAvKipcbiAgICogQW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIGEgY2FsbCBmcm9tIGEge0BsaW5rIFRpbWVyfVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEV2ZW50VGltZXIge1xuICAgIHB1YmxpYyB0eXBlOiBFVkVOVF9USU1FUiA9IEVWRU5UX1RJTUVSLkNBTEw7XG4gICAgcHVibGljIHRhcmdldDogVGltZXI7XG4gICAgcHVibGljIGFyZ3VtZW50czogT2JqZWN0W107XG4gICAgcHVibGljIGZpcnN0Q2FsbDogYm9vbGVhbiA9IHRydWU7XG4gICAgcHVibGljIGxhc3RDYWxsOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHVibGljIGNvdW50OiBudW1iZXI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RpbWVyOiBUaW1lciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcbiAgICAgIHRoaXMudGFyZ2V0ID0gX3RpbWVyO1xuICAgICAgdGhpcy5hcmd1bWVudHMgPSBfYXJndW1lbnRzO1xuICAgICAgdGhpcy5maXJzdENhbGwgPSB0cnVlO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQ3VzdG9tIHRvdWNoIGV2ZW50c1xuICAgKi9cbiAgZXhwb3J0IGVudW0gRVZFTlRfVE9VQ0gge1xuICAgIC8qKiBjdXN0b20gZXZlbnQgZmlyZWQgaW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIHRvdWNobW92ZSwgZGV0YWlscyBvZmZzZXQgdG8gc3RhcnRpbmcgdG91Y2ggKi9cbiAgICBNT1ZFID0gXCJ0b3VjaE1vdmVcIixcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHRvdWNoZXMgaGF2ZW4ndCBtb3ZlZCBvdXRzaWRlIG9mIHRoZSB0YXAgcmFkaXVzICovXG4gICAgVEFQID0gXCJ0b3VjaFRhcFwiLFxuICAgIC8qKiBjdXN0b20gZXZlbnQgZmlyZWQgd2hlbiB0aGUgdG91Y2hlcyBoYXZlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5vdGNoIHJhZGl1cywgZGV0YWlscyBvZmZzZXQgYW5kIGNhcmRpbmFsIGRpcmVjdGlvbiAqL1xuICAgIE5PVENIID0gXCJ0b3VjaE5vdGNoXCIsXG4gICAgLyoqIGN1c3RvbSBldmVudCBmaXJlZCB3aGVuIHRoZSB0b3VjaGVzIGhhdmVuJ3QgbW92ZWQgb3V0c2lkZSBvZiB0aGUgdGFwIHJhZGl1cyBmb3Igc29tZSB0aW1lICovXG4gICAgTE9ORyA9IFwidG91Y2hMb25nXCIsXG4gICAgLyoqIGN1c3RvbSBldmVudCBmaXJlZCB3aGVuIHR3byB0YXBzIHdlcmUgZGV0ZWN0ZWQgaW4gc2hvcnQgc3VjY2Vzc2lvbiAqL1xuICAgIERPVUJMRSA9IFwidG91Y2hEb3VibGVcIixcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG9ubHkgdHdvIHRvdWNoZXMgY2hhbmdlcyBiZXlvbmQgYSB0b2xlcmFuY2UgKi9cbiAgICBQSU5DSCA9IFwidG91Y2hQaW5jaFwiLFxuICAgIC8qKiBjdXN0b20gZXZlbnQgbm90IGltcGxlbWVudGVkIHlldCAqL1xuICAgIFJPVEFURSA9IFwidG91Y2hSb3RhdGVcIlxuICB9XG5cbiAgLyoqIERldGFpbHMgZm9yIEN1c3RvbVRvdWNoRXZlbnRzLCB1c2UgYXMgZ2VuZXJpYyBDdXN0b21FdmVudDxFdmVudFRvdWNoRGV0YWlsPiAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEV2ZW50VG91Y2hEZXRhaWwge1xuICAgIHBvc2l0aW9uOiBWZWN0b3IyO1xuICAgIHRvdWNoZXM6IFRvdWNoTGlzdDtcbiAgICBvZmZzZXQ/OiBWZWN0b3IyO1xuICAgIG1vdmVtZW50PzogVmVjdG9yMjtcbiAgICBjYXJkaW5hbD86IFZlY3RvcjI7XG4gICAgcGluY2g/OiBWZWN0b3IyO1xuICAgIHBpbmNoRGVsdGE/OiBudW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBDdXN0b21Ub3VjaEV2ZW50cyB0byB0aGUgRXZlbnRUYXJnZXQgZ2l2ZW4gd2l0aCB0aGUgY29uc3RydWN0b3IuXG4gICAqIFdoZW4gdXNpbmcgdG91Y2ggZXZlbnRzLCBtYWtlIHN1cmUgdG8gc2V0IGB0b3VjaC1hY3Rpb246IG5vbmVgIGluIENTUyBcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFRvdWNoRXZlbnREaXNwYXRjaGVyIHtcbiAgICBwdWJsaWMgcG9zU3RhcnQ6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcbiAgICBwdWJsaWMgcG9zTm90Y2g6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcbiAgICBwdWJsaWMgcmFkaXVzVGFwOiBudW1iZXI7XG4gICAgcHVibGljIHJhZGl1c05vdGNoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSB0YXJnZXQ6IEV2ZW50VGFyZ2V0O1xuICAgIHByaXZhdGUgcG9zUHJldjogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xuICAgIHByaXZhdGUgbW92ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIHRpbWVyRG91YmxlOiBUaW1lcjtcbiAgICBwcml2YXRlIHRpbWVyTG9uZzogVGltZXI7XG4gICAgcHJpdmF0ZSB0aW1lRG91YmxlOiBudW1iZXI7XG4gICAgcHJpdmF0ZSB0aW1lTG9uZzogbnVtYmVyO1xuICAgIHByaXZhdGUgdGltZTogVGltZSA9IG5ldyBUaW1lKCk7XG4gICAgcHJpdmF0ZSBwaW5jaERpc3RhbmNlOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgcGluY2hUb2xlcmFuY2U6IG51bWJlciA9IDE7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RhcmdldDogRXZlbnRUYXJnZXQsIF9yYWRpdXNUYXA6IG51bWJlciA9IDUsIF9yYWRpdXNOb3RjaDogbnVtYmVyID0gNTAsIF90aW1lRG91YmxlOiBudW1iZXIgPSAyMDAsIF90aW1lckxvbmc6IG51bWJlciA9IDEwMDApIHtcbiAgICAgIHRoaXMudGFyZ2V0ID0gX3RhcmdldDtcbiAgICAgIHRoaXMucmFkaXVzVGFwID0gX3JhZGl1c1RhcDtcbiAgICAgIHRoaXMucmFkaXVzTm90Y2ggPSBfcmFkaXVzTm90Y2g7XG4gICAgICB0aGlzLnRpbWVEb3VibGUgPSBfdGltZURvdWJsZTtcbiAgICAgIHRoaXMudGltZUxvbmcgPSBfdGltZXJMb25nO1xuICAgICAgdGhpcy5hY3RpdmF0ZSh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZS0vQWN0aXZhdGVzIHRoZSBkaXNwYXRjaCBvZiBDdXN0b21Ub3VjaEV2ZW50c1xuICAgICAqL1xuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgIGlmIChfb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgPEV2ZW50TGlzdGVuZXI+dGhpcy5obmRFdmVudCk7XG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCA8RXZlbnRMaXN0ZW5lcj50aGlzLmhuZEV2ZW50KTtcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCA8RXZlbnRMaXN0ZW5lcj50aGlzLmhuZEV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCA8RXZlbnRMaXN0ZW5lcj50aGlzLmhuZEV2ZW50KTtcbiAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCA8RXZlbnRMaXN0ZW5lcj50aGlzLmhuZEV2ZW50KTtcbiAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgPEV2ZW50TGlzdGVuZXI+dGhpcy5obmRFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBobmRFdmVudCA9IChfZXZlbnQ6IFRvdWNoRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgIF9ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbGV0IHRvdWNoRmlyc3Q6IFRvdWNoID0gX2V2ZW50LnRvdWNoZXNbMF07XG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjIgPSB0aGlzLmNhbGNBdmVyYWdlUG9zaXRpb24oX2V2ZW50LnRvdWNoZXMpOyAvL25ldyBWZWN0b3IyKHRvdWNoRmlyc3Q/LmNsaWVudFgsIHRvdWNoRmlyc3Q/LmNsaWVudFkpO1xuICAgICAgbGV0IG9mZnNldDogVmVjdG9yMjtcblxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxuICAgICAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnN0YXJ0R2VzdHVyZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoX2V2ZW50LnRvdWNoZXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHBpbmNoXG4gICAgICAgICAgICBsZXQgcGluY2g6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihfZXZlbnQudG91Y2hlc1sxXS5jbGllbnRYIC0gdG91Y2hGaXJzdC5jbGllbnRYLCBfZXZlbnQudG91Y2hlc1sxXS5jbGllbnRZIC0gdG91Y2hGaXJzdC5jbGllbnRZKTtcbiAgICAgICAgICAgIHRoaXMucGluY2hEaXN0YW5jZSA9IHBpbmNoLm1hZ25pdHVkZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZGlzcGF0Y2hMb25nOiBUaW1lckhhbmRsZXIgPSAoX2V2ZW50VGltZXI6IEV2ZW50VGltZXIpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILkxPTkcsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IHBvc2l0aW9uLCB0b3VjaGVzOiBfZXZlbnQudG91Y2hlcyB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLnRpbWVyTG9uZz8uY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLnRpbWVyTG9uZyA9IG5ldyBUaW1lcih0aGlzLnRpbWUsIHRoaXMudGltZUxvbmcsIDEsIGRpc3BhdGNoTG9uZyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgICAgICAgIHRoaXMudGltZXJMb25nPy5jbGVhcigpO1xuXG4gICAgICAgICAgaWYgKF9ldmVudC50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIHRvdWNoZXMgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0R2VzdHVyZShwb3NpdGlvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZGlzcGF0Y2hUYXA6IFRpbWVySGFuZGxlciA9IChfZXZlbnRUaW1lcjogRXZlbnRUaW1lcik6IHZvaWQgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILlRBUCwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsIGRldGFpbDogeyBwb3NpdGlvbjogcG9zaXRpb24sIHRvdWNoZXM6IF9ldmVudC50b3VjaGVzIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIHdhcyBhIHRhcCBiZWZvcmUgYW5kIHRpbWVyIGlzIHN0aWxsIHJ1bm5pbmcgLT4gZG91YmxlIHRhcFxuICAgICAgICAgIGlmICh0aGlzLnRpbWVyRG91YmxlPy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXJEb3VibGUuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4oRVZFTlRfVE9VQ0guRE9VQkxFLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMgfVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5tb3ZlZClcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIHdhcyBtb3ZlbWVudCwgb3RoZXJ3aXNlIHNldCB0aW1lciB0byBmaXJlIHRhcFxuICAgICAgICAgICAgdGhpcy50aW1lckRvdWJsZSA9IG5ldyBUaW1lcih0aGlzLnRpbWUsIHRoaXMudGltZURvdWJsZSwgMSwgZGlzcGF0Y2hUYXApO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgICAgICB0aGlzLmRldGVjdFBpbmNoKF9ldmVudCwgcG9zaXRpb24pO1xuICAgICAgICAgIG9mZnNldCA9IFZlY3RvcjIuRElGRkVSRU5DRSh0aGlzLnBvc1ByZXYsIHRoaXMucG9zU3RhcnQpO1xuICAgICAgICAgIHRoaXMubW92ZWQgfHw9IChvZmZzZXQubWFnbml0dWRlIDwgdGhpcy5yYWRpdXNUYXApOyAvLyByZW1lbWJlciB0aGF0IHRvdWNoIG1vdmVkIG92ZXIgdGFwIHJhZGl1c1xuICAgICAgICAgIGxldCBtb3ZlbWVudDogVmVjdG9yMiA9IFZlY3RvcjIuRElGRkVSRU5DRShwb3NpdGlvbiwgdGhpcy5wb3NQcmV2KTtcbiAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILk1PVkUsIHtcbiAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMsIG9mZnNldDogb2Zmc2V0LCBtb3ZlbWVudDogbW92ZW1lbnQgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIC8vIGZpcmUgbm90Y2ggd2hlbiB0b3VjaGVzIG1vdmVkIG91dCBvZiBub3RjaCByYWRpdXMgYW5kIHJlc2V0IG5vdGNoXG4gICAgICAgICAgb2Zmc2V0ID0gVmVjdG9yMi5ESUZGRVJFTkNFKHBvc2l0aW9uLCB0aGlzLnBvc05vdGNoKTtcbiAgICAgICAgICBpZiAob2Zmc2V0Lm1hZ25pdHVkZSA+IHRoaXMucmFkaXVzTm90Y2gpIHtcbiAgICAgICAgICAgIGxldCBjYXJkaW5hbDogVmVjdG9yMiA9IE1hdGguYWJzKG9mZnNldC54KSA+IE1hdGguYWJzKG9mZnNldC55KSA/XG4gICAgICAgICAgICAgIFZlY3RvcjIuWChvZmZzZXQueCA8IDAgPyAtMSA6IDEpIDpcbiAgICAgICAgICAgICAgVmVjdG9yMi5ZKG9mZnNldC55IDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4oRVZFTlRfVE9VQ0guTk9UQ0gsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IHBvc2l0aW9uLCB0b3VjaGVzOiBfZXZlbnQudG91Y2hlcywgb2Zmc2V0OiBvZmZzZXQsIGNhcmRpbmFsOiBjYXJkaW5hbCwgbW92ZW1lbnQ6IG1vdmVtZW50IH1cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5wb3NOb3RjaCA9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL1RPRE86IHBpbmNoLCByb3RhdGUuLi5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3NQcmV2LnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBkZXRlY3RQaW5jaCA9IChfZXZlbnQ6IFRvdWNoRXZlbnQsIF9wb3NpdGlvbjogVmVjdG9yMik6IHZvaWQgPT4ge1xuICAgICAgaWYgKF9ldmVudC50b3VjaGVzLmxlbmd0aCAhPSAyKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGxldCB0OiBUb3VjaExpc3QgPSBfZXZlbnQudG91Y2hlcztcbiAgICAgIGxldCBwaW5jaDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKHRbMV0uY2xpZW50WCAtIHRbMF0uY2xpZW50WCwgdFsxXS5jbGllbnRZIC0gdFswXS5jbGllbnRZKTtcbiAgICAgIGxldCBwaW5jaERpc3RhbmNlOiBudW1iZXIgPSBwaW5jaC5tYWduaXR1ZGU7XG4gICAgICBsZXQgcGluY2hEZWx0YTogbnVtYmVyID0gcGluY2hEaXN0YW5jZSAtIHRoaXMucGluY2hEaXN0YW5jZTtcbiAgICAgIGlmIChNYXRoLmFicyhwaW5jaERlbHRhKSA+IHRoaXMucGluY2hUb2xlcmFuY2UpXG4gICAgICAgIHRoaXMudGFyZ2V0LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILlBJTkNILCB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IF9wb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMsIHBpbmNoOiBwaW5jaCwgcGluY2hEZWx0YTogcGluY2hEZWx0YSB9XG4gICAgICAgICAgfSkpO1xuICAgICAgdGhpcy5waW5jaERpc3RhbmNlID0gcGluY2hEaXN0YW5jZTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBzdGFydEdlc3R1cmUoX3Bvc2l0aW9uOiBWZWN0b3IyKTogdm9pZCB7XG4gICAgICB0aGlzLnBvc05vdGNoLnNldChfcG9zaXRpb24ueCwgX3Bvc2l0aW9uLnkpO1xuICAgICAgdGhpcy5wb3NTdGFydC5zZXQoX3Bvc2l0aW9uLngsIF9wb3NpdGlvbi55KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGNBdmVyYWdlUG9zaXRpb24oX3RvdWNoZXM6IFRvdWNoTGlzdCk6IFZlY3RvcjIge1xuICAgICAgbGV0IGF2ZXJhZ2U6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcbiAgICAgIGZvciAobGV0IHRvdWNoIG9mIF90b3VjaGVzKSB7XG4gICAgICAgIGF2ZXJhZ2UueCArPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICBhdmVyYWdlLnkgKz0gdG91Y2guY2xpZW50WTtcbiAgICAgIH1cbiAgICAgIGF2ZXJhZ2Uuc2NhbGUoMSAvIF90b3VjaGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gYXZlcmFnZTtcbiAgICB9XG4gIH1cbn1cblxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBBIG5vZGUgbWFuYWdlZCBieSB7QGxpbmsgUHJvamVjdH0gdGhhdCBmdW5jdGlvbnMgYXMgYSB0ZW1wbGF0ZSBmb3Ige0BsaW5rIEdyYXBoSW5zdGFuY2V9cyBcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvUmVzb3VyY2VcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBHcmFwaCBleHRlbmRzIE5vZGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcbiAgICBwdWJsaWMgdHlwZTogc3RyaW5nID0gXCJHcmFwaFwiO1xuICAgIC8vICNzeW5jaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiR3JhcGhcIikge1xuICAgICAgc3VwZXIoX25hbWUpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURSwgdGhpcy5obmRNdXRhdGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5pZFJlc291cmNlID0gdGhpcy5pZFJlc291cmNlO1xuICAgICAgc2VyaWFsaXphdGlvbi50eXBlID0gdGhpcy50eXBlO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XG4gICAgICBhd2FpdCBQcm9qZWN0LnJlc3luY0dyYXBoSW5zdGFuY2VzKHRoaXMpO1xuICAgICAgdGhpcy5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlQuR1JBUEhfREVTRVJJQUxJWkVEKSk7XG4gICAgICBjb25zb2xlLmxvZyhcIkRlc2VyaWFsaXplZFwiLCB0aGlzLm5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBobmRNdXRhdGUgPSBhc3luYyAoX2V2ZW50OiBDdXN0b21FdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xuXG4gICAgICAvLyBUT0RPOiBpZiBwYXRoIGNvbnRhaW5zIGEgZ3JhcGggaW5zdGFuY2UgYmVsb3cgdGhpcywgZG9uJ3QgZGlzcGF0Y2ghXG4gICAgICAvLyBsZXQgcGF0aDogTm9kZVtdID0gUmVmbGVjdC5nZXQoX2V2ZW50LCBcInBhdGhcIik7XG4gICAgICAvLyBmb3IgKGxldCBub2RlIG9mIHBhdGgpXG4gICAgICAvLyAgIGlmIChub2RlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSAmJiBub2RlLmlkU291cmNlICE9IHRoaXMuaWRSZXNvdXJjZSlcbiAgICAgIC8vICAgICByZXR1cm47XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiR3JhcGggbXV0YXRlc1wiLCB0aGlzLm5hbWUpO1xuICAgICAgLy8gdGhpcy4jc3luY2luZyA9IHRydWU7XG4gICAgICBfZXZlbnQuZGV0YWlsLnBhdGggPSBSZWZsZWN0LmdldChfZXZlbnQsIFwicGF0aFwiKTsgLy8gc2F2ZSBwYXRoIHRvIHRhcmdldCBpbiBkZXRhaWxcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuTVVUQVRFX0dSQVBILCB7IGRldGFpbDogX2V2ZW50LmRldGFpbCB9KSk7XG4gICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURV9JTlNUQU5DRSkpO1xuICAgICAgLy8gdGhpcy4jc3luY2luZyA9IGZhbHNlO1xuICAgIH07XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICBlbnVtIFNZTkMge1xuICAgIFJFQURZLCBHUkFQSF9TWU5DRUQsIEdSQVBIX0RPTkUsIElOU1RBTkNFXG4gIH1cblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgYSB7QGxpbmsgR3JhcGh9LiAgXG4gICAqIFRoaXMgbm9kZSBrZWVwcyBhIHJlZmVyZW5jZSB0byBpdHMgcmVzb3VyY2UgYW4gY2FuIHRodXMgb3B0aW1pemUgc2VyaWFsaXphdGlvblxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZXNvdXJjZVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEdyYXBoSW5zdGFuY2UgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKiogaWQgb2YgdGhlIHJlc291cmNlIHRoYXQgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgZnJvbSAqL1xuICAgIC8vIFRPRE86IGV4YW1pbmUsIGlmIHRoaXMgc2hvdWxkIGJlIGEgZGlyZWN0IHJlZmVyZW5jZSB0byB0aGUgR3JhcGgsIGluc3RlYWQgb2YgdGhlIGlkXG4gICAgcHVibGljIHN0YXRpYyBjb3VudDogbnVtYmVyID0gMDtcbiAgICAjaWRTb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcbiAgICAjc3luYzogU1lOQyA9IFNZTkMuUkVBRFk7XG4gICAgI2Rlc2VyaWFsaXplRnJvbVNvdXJjZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGFsb25lIHdpbGwgbm90IGNyZWF0ZSBhIHJlY29uc3RydWN0aW9uLCBidXQgb25seSBzYXZlIHRoZSBpZC5cbiAgICAgKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIGdyYXBoLCBjYWxsIHJlc2V0IG9uIHRoaXMgb3Igc2V0IHdpdGggYSBncmFwaCBhcyBwYXJhbWV0ZXIuXG4gICAgICogUHJlZmVyIFByb2plY3QuY3JlYXRlR3JhcGhJbnN0YW5jZShfZ3JhcGgpLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfZ3JhcGg/OiBHcmFwaCkge1xuICAgICAgc3VwZXIoXCJHcmFwaEluc3RhbmNlXCIpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURSwgdGhpcy5obmRNdXRhdGlvbkluc3RhbmNlKTtcblxuICAgICAgaWYgKCFfZ3JhcGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuI2lkU291cmNlID0gX2dyYXBoLmlkUmVzb3VyY2U7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBpZFNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuI2lkU291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3JlYXRlIHRoaXMgbm9kZSBmcm9tIHRoZSB7QGxpbmsgR3JhcGh9IHJlZmVyZW5jZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgcmVzZXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBsZXQgcmVzb3VyY2U6IEdyYXBoID0gPEdyYXBoPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UodGhpcy4jaWRTb3VyY2UpO1xuICAgICAgYXdhaXQgdGhpcy5zZXQocmVzb3VyY2UpO1xuICAgIH1cblxuICAgIC8vVE9ETzogb3B0aW1pemUgdXNpbmcgdGhlIHJlZmVyZW5jZWQgR3JhcGgsIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBvbmx5IHRoZSBkaWZmZXJlbmNlc1xuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgZmlsdGVyOiBDb21wb25lbnRHcmFwaEZpbHRlciA9IHRoaXMuZ2V0Q29tcG9uZW50KENvbXBvbmVudEdyYXBoRmlsdGVyKTtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XG5cbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmlzQWN0aXZlKSAvLyBpZiBncmFwaCBzeW5jaHJvbmlzYXRpb24gaXMgdW5maWx0ZXJlZCwga25vd2luZyB0aGUgc291cmNlIGlzIHN1ZmZpY2llbnQgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBzZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplRnJvbVNvdXJjZSA9IHRydWU7XG5cbiAgICAgIHNlcmlhbGl6YXRpb24uaWRTb3VyY2UgPSB0aGlzLiNpZFNvdXJjZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICB0aGlzLiNpZFNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkU291cmNlID8/IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XG4gICAgICBpZiAoIV9zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplRnJvbVNvdXJjZSkge1xuICAgICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7IC8vIGluc3RhbmNlIGlzIGRlc2VyaWFsaXplZCBmcm9tIGluZGl2aWR1YWwgZGF0YVxuICAgICAgICB0aGlzLiNkZXNlcmlhbGl6ZUZyb21Tb3VyY2UgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IHRoaXMuZ2V0KCk7XG4gICAgICBpZiAoZ3JhcGgpXG4gICAgICAgIC8vIGlmIChfc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZUZyb21Tb3VyY2UpIC8vIG5vIGNvbXBvbmVudHMtPiBhc3N1bWUgc3luY2hyb25pemVkIEdyYXBoSW5zdGFuY2VcbiAgICAgICAgLy8gICBhd2FpdCB0aGlzLnNldChncmFwaCk7IC8vIHJlY3JlYXRlIGNvbXBsZXRlIGluc3RhbmNlIGZyb20gc291cmNlIGdyYXBoXG4gICAgICAgIC8vIGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3RUb0dyYXBoKCk7IC8vIG90aGVyd2lzZSBqdXN0IGNvbm5lY3RcbiAgICAgIC8vIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlZ2lzdGVyIGZvciByZXN5bmNcIiwgX3NlcmlhbGl6YXRpb24ubmFtZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgUHJvamVjdC5yZWdpc3RlckdyYXBoSW5zdGFuY2VGb3JSZXN5bmModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyB0aGlzIGdyYXBoIGluc3RhbmNlIHRvIHRoZSBncmFwaCByZWZlcmVuY2VkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0VG9HcmFwaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGxldCBncmFwaDogR3JhcGggPSB0aGlzLmdldCgpO1xuICAgICAgaWYgKHRoaXMuI2Rlc2VyaWFsaXplRnJvbVNvdXJjZSlcbiAgICAgICAgYXdhaXQgdGhpcy5zZXQoZ3JhcGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIG5vZGUgdG8gYmUgYSByZWNyZWF0aW9uIG9mIHRoZSB7QGxpbmsgR3JhcGh9IGdpdmVuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIHNldChfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICB0aGlzLiNpZFNvdXJjZSA9IF9ncmFwaC5pZFJlc291cmNlO1xuXG4gICAgICBsZXQgY3VycmVudEdyYXBoOiBHcmFwaCA9IHRoaXMuZ2V0KCk7XG4gICAgICBpZiAoY3VycmVudEdyYXBoKSB7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkJlZm9yZSBSZW1vdmVcIiwgY3VycmVudEdyYXBoLm5hbWUsIHRoaXMubmFtZSwgY3VycmVudEdyYXBoLmxpc3RlbmVycyk7XG4gICAgICAgIGN1cnJlbnRHcmFwaC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURV9HUkFQSCwgdGhpcy5obmRNdXRhdGlvbkdyYXBoKTtcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQWZ0ZXIgUmVtb3ZlXCIsIGN1cnJlbnRHcmFwaC5uYW1lLCB0aGlzLm5hbWUsIGN1cnJlbnRHcmFwaC5saXN0ZW5lcnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiB0aGUgc2VyaWFsaXphdGlvbiBzaG91bGQgYmUgc3RvcmVkIGluIHRoZSBHcmFwaCBmb3Igb3B0aW1pemF0aW9uIDwtIGFsc28gdXNlZnVsIGZvciBzeW5jIHdpdGggaW5zdGFuY2VzXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplKF9ncmFwaCk7XG4gICAgICAvL1NlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XG4gICAgICBmb3IgKGxldCBwYXRoIGluIHNlcmlhbGl6YXRpb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uW3BhdGhdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKHRoaXMubmFtZSArIEdyYXBoSW5zdGFuY2UuY291bnQrKyk7XG5cbiAgICAgIC8vIGdyYXBoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTVVUQVRFLCAoX2V2ZW50OiBDdXN0b21FdmVudCkgPT4gdGhpcy5obmRNdXRhdGlvbiwgdHJ1ZSk7XG4gICAgICBfZ3JhcGguYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEVfR1JBUEgsIHRoaXMuaG5kTXV0YXRpb25HcmFwaCk7XG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiQWRkXCIsIF9ncmFwaC5uYW1lLCB0aGlzLm5hbWUsIF9ncmFwaC5saXN0ZW5lcnMpO1xuICAgICAgLy8gZ3JhcGguYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEVfR1JBUEhfRE9ORSwgKCkgPT4geyBjb25zb2xlLmxvZyhcIkRvbmVcIiwgdGhpcy5uYW1lKTsgLyogdGhpcy4jc3luYyA9IHRydWU7ICovIH0pO1xuXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGNvbnNvbGUubG9nKF9ncmFwaD8ubGlzdGVuZXJzKTtcbiAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBncmFwaCB0aGlzIGluc3RhbmNlcyByZWZlcnMgdG9cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0KCk6IEdyYXBoIHtcbiAgICAgIHJldHVybiA8R3JhcGg+UHJvamVjdC5yZXNvdXJjZXNbdGhpcy4jaWRTb3VyY2VdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNvdXJjZSBncmFwaCBtdXRhdGVkLCByZWZsZWN0IG11dGF0aW9uIGluIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGhuZE11dGF0aW9uR3JhcGggPSBhc3luYyAoX2V2ZW50OiBDdXN0b21FdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJSZWZsZWN0IEdyYXBoLU11dGF0aW9uIHRvIEluc3RhbmNlXCIsIFNZTkNbdGhpcy4jc3luY10sICg8R3JhcGg+X2V2ZW50LmN1cnJlbnRUYXJnZXQpLm5hbWUsIHRoaXMuZ2V0UGF0aCgpLm1hcChfbm9kZSA9PiBfbm9kZS5uYW1lKSk7XG4gICAgICAvLyBpZiAodGhpcy4jc3luYyAhPSBTWU5DLlJFQURZKSB7XG4gICAgICAvLyAgIC8vIGNvbnNvbGUubG9nKFwiU3luYyBhYm9ydGVkLCBzd2l0Y2ggdG8gcmVhZHlcIik7XG4gICAgICAvLyAgIHRoaXMuI3N5bmMgPSBTWU5DLlJFQURZO1xuICAgICAgLy8gICByZXR1cm47XG4gICAgICAvLyB9XG5cbiAgICAgIGlmICh0aGlzLmlzRmlsdGVyZWQoKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB0aGlzLiNzeW5jID0gU1lOQy5HUkFQSF9TWU5DRUQ7IC8vIGRvIG5vdCBzeW5jIGFnYWluLCBzaW5jZSBtdXRhdGlvbiBpcyBhbHJlYWR5IGEgc3luY2hyb25pemF0aW9uXG4gICAgICBhd2FpdCB0aGlzLnJlZmxlY3RNdXRhdGlvbihfZXZlbnQsIDxHcmFwaD5fZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcywgX2V2ZW50LmRldGFpbC5wYXRoKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFX0lOU1RBTkNFLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGluc3RhbmNlIG11dGF0ZWQsIHJlZmxlY3QgbXV0YXRpb24gaW4gc291cmNlIGdyYXBoXG4gICAgICovXG4gICAgcHJpdmF0ZSBobmRNdXRhdGlvbkluc3RhbmNlID0gYXN5bmMgKF9ldmVudDogQ3VzdG9tRXZlbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiUmVmbGVjdCBJbnN0YW5jZS1NdXRhdGlvbiB0byBHcmFwaFwiLCBTWU5DW3RoaXMuI3N5bmNdLCB0aGlzLmdldFBhdGgoKS5tYXAoX25vZGUgPT4gX25vZGUubmFtZSksIHRoaXMuZ2V0KCkubmFtZSk7XG4gICAgICAvLyBpZiAodGhpcy4jc3luYyAhPSBTWU5DLlJFQURZKSB7XG4gICAgICAvLyAgIC8vIGNvbnNvbGUubG9nKFwiU3luYyBhYm9ydGVkLCBzd2l0Y2ggdG8gcmVhZHlcIik7XG4gICAgICAvLyAgIHRoaXMuI3N5bmMgPSBTWU5DLlJFQURZO1xuICAgICAgLy8gICByZXR1cm47XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGlmIChfZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSAmJiBfZXZlbnQudGFyZ2V0ICE9IHRoaXMpIHtcbiAgICAgIC8vICAgLy8gY29uc29sZS5sb2coXCJTeW5jIGFib3J0ZWQsIHRhcmdldCBhbHJlYWR5IHN5bmNlZFwiKTtcbiAgICAgIC8vICAgcmV0dXJuO1xuICAgICAgLy8gfVxuXG4gICAgICBpZiAodGhpcy5pc0ZpbHRlcmVkKCkpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdGhpcy4jc3luYyA9IFNZTkMuSU5TVEFOQ0U7IC8vIGRvIG5vdCBzeW5jIGFnYWluLCBzaW5jZSBtdXRhdGlvbiBpcyBhbHJlYWR5IGEgc3luY2hyb25pemF0aW9uXG4gICAgICBhd2FpdCB0aGlzLnJlZmxlY3RNdXRhdGlvbihfZXZlbnQsIHRoaXMsIHRoaXMuZ2V0KCksIFJlZmxlY3QuZ2V0KF9ldmVudCwgXCJwYXRoXCIpKTtcbiAgICAgIHRoaXMuZ2V0KCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuTVVUQVRFLCB7IGRldGFpbDogX2V2ZW50LmRldGFpbCB9KSk7XG4gICAgfTtcblxuICAgIC8vIHJlZmxlY3QgbXV0YXRpb24gZnJvbSBhIHNvdXJjZSBncmFwaCBvciBpbnN0YW5jZSB0byBhIGRlc3RpbmF0aW9uIGluc3RhbmNlIG9yIGdyYXBoXG4gICAgcHJpdmF0ZSBhc3luYyByZWZsZWN0TXV0YXRpb24oX2V2ZW50OiBDdXN0b21FdmVudCwgX3NvdXJjZTogTm9kZSwgX2Rlc3RpbmF0aW9uOiBOb2RlLCBfcGF0aDogTm9kZVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlJlZmxlY3QgbXV0YXRpb25cIiwgX3NvdXJjZSwgX2Rlc3RpbmF0aW9uKTtcblxuXG4gICAgICBmb3IgKGxldCBub2RlIG9mIF9wYXRoKSAvLyBpdGVyYXRlIHVwIHRoZSBldmVudCBwYXRoLCB3aGljaCBtYXkgY29udGFpbiByZWd1bGFyIE5vZGVzIG9yIEdyYXBoSW5zdGFuY2VzXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSkgLy8gdW50aWwgdGhpcyBHcmFwaEluc3RhbmNlIGlzIGZvdW5kIChvciBubyBHcmFwaEluc3RhbmNlLi4uKVxuICAgICAgICAgIGlmIChub2RlID09IHRoaXMpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3luYyBhYm9ydGVkLCB0YXJnZXQgYWxyZWFkeSBzeW5jZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAvLyBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgaW4gdGhlIGRlc3RpbmF0aW9uIGhpZXJhcmNoeVxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSBfcGF0aC5pbmRleE9mKF9zb3VyY2UpO1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGRJbmRleDogbnVtYmVyID0gX3BhdGhbaV0uZ2V0UGFyZW50KCkuZmluZENoaWxkKF9wYXRoW2ldKTsgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgY2hpbGRub2RlIGluIHRoZSBvcmlnaW5hbCBwYXRoXG4gICAgICAgIF9kZXN0aW5hdGlvbiA9IF9kZXN0aW5hdGlvbi5nZXRDaGlsZChjaGlsZEluZGV4KTsgLy8gZ2V0IHRoZSBjb3JyZXNwb25kaW5nIGNoaWxkIGluIHRoaXMgcGF0aFxuICAgICAgICAvLyBUT0RPOiByZXNwZWN0IGluZGV4IGZvciBub24tc2luZ2xldG9uIGNvbXBvbmVudHMuLi5cbiAgICAgIH1cblxuICAgICAgLy8gbXV0YXRlIHRoZSBjb3JyZXNwb25kaW5nIGNvbXBvbmVudCBpbiB0aGUgZGVzdGluYXRpb25cbiAgICAgIGxldCBjbXBNdXRhdGU6IENvbXBvbmVudCA9IF9kZXN0aW5hdGlvbi5nZXRDb21wb25lbnQoX2V2ZW50LmRldGFpbC5jb21wb25lbnQuY29uc3RydWN0b3IpO1xuICAgICAgaWYgKGNtcE11dGF0ZSlcbiAgICAgICAgYXdhaXQgY21wTXV0YXRlLm11dGF0ZShfZXZlbnQuZGV0YWlsLm11dGF0b3IsIG51bGwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzRmlsdGVyZWQoKTogYm9vbGVhbiB7XG4gICAgICBsZXQgY21wRmlsdGVyOiBDb21wb25lbnRHcmFwaEZpbHRlciA9IHRoaXMuZ2V0Q29tcG9uZW50KENvbXBvbmVudEdyYXBoRmlsdGVyKTtcbiAgICAgIHJldHVybiAoY21wRmlsdGVyICYmIGNtcEZpbHRlci5pc0FjdGl2ZSk7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBIb2xkcyBkYXRhIHRvIGZlZWQgaW50byBhIHtAbGluayBTaGFkZXJ9IHRvIGRlc2NyaWJlIHRoZSBzdXJmYWNlIG9mIHtAbGluayBNZXNofS4gIFxuICAgKiB7QGxpbmsgTWF0ZXJpYWx9cyByZWZlcmVuY2Uge0BsaW5rIENvYXR9IGFuZCB7QGxpbmsgU2hhZGVyfS4gICBcbiAgICogVGhlIG1ldGhvZCB1c2VSZW5kZXJEYXRhIHdpbGwgYmUgaW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yfSBhdCBydW50aW1lLCBleHRlbmRpbmcgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhpcyBjbGFzcyB0byBkZWFsIHdpdGggdGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIENvYXQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcbiAgICAvLyBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJDb2F0XCI7XG4gICAgLy8gcHJvdGVjdGVkIHJlbmRlckRhdGE6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9OyAvLyB0aGlzIHdhc24ndCB1c2VkIGFueXdoZXJlLi4uXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZW5kZXItcGFyYW1ldGVycyBmcm9tIHRoaXMgYW5kIHRoZSBnaXZlbiBtYXRlcmlhbCBpbnNpZGUgdGhlIGdpdmVuIHNoYWRlci5cbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JDb2F0fS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgdXNlUmVuZGVyRGF0YShfc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlbmRlckRhdGE7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBUaGUgc2ltcGxlc3Qge0BsaW5rIENvYXR9IHByb3ZpZGluZyBqdXN0IGEgY29sb3JcbiAgICovXG4gIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcbiAgZXhwb3J0IGNsYXNzIENvYXRDb2xvcmVkIGV4dGVuZHMgQ29hdCB7XG4gICAgcHVibGljIGNvbG9yOiBDb2xvcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCkpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmNvbG9yID0gX2NvbG9yO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5jb2xvciA9IHRoaXMuY29sb3Iuc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29sb3IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBUaGUgc2ltcGxlc3Qge0BsaW5rIENvYXR9IHByb3ZpZGluZyBqdXN0IGEgY29sb3JcbiAgICovXG4gIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcbiAgZXhwb3J0IGNsYXNzIENvYXRSZW1pc3NpdmUgZXh0ZW5kcyBDb2F0Q29sb3JlZCB7XG4gICAgcHVibGljIHNwZWN1bGFyOiBudW1iZXI7XG4gICAgcHVibGljIGRpZmZ1c2U6IG51bWJlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCksIF9kaWZmdXNlOiBudW1iZXIgPSAxLCBfc3BlY3VsYXI6IG51bWJlciA9IDApIHtcbiAgICAgIHN1cGVyKF9jb2xvcik7XG4gICAgICB0aGlzLmRpZmZ1c2UgPSBfZGlmZnVzZTtcbiAgICAgIHRoaXMuc3BlY3VsYXIgPSBfc3BlY3VsYXI7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICBzZXJpYWxpemF0aW9uLmRpZmZ1c2UgPSB0aGlzLmRpZmZ1c2U7XG4gICAgICBzZXJpYWxpemF0aW9uLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhcjtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgYXdhaXQgdGhpcy5jb2xvci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2xvcik7XG4gICAgICB0aGlzLmRpZmZ1c2UgPSBfc2VyaWFsaXphdGlvbi5kaWZmdXNlO1xuICAgICAgdGhpcy5zcGVjdWxhciA9IF9zZXJpYWxpemF0aW9uLnNwZWN1bGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBBIHtAbGluayBDb2F0fSBwcm92aWRpbmcgYSB0ZXh0dXJlIGFuZCBhZGRpdGlvbmFsIGRhdGEgZm9yIHRleHR1cmluZ1xuICAgKi9cbiAgQFJlbmRlckluamVjdG9yQ29hdC5kZWNvcmF0ZVxuICBleHBvcnQgY2xhc3MgQ29hdFRleHR1cmVkIGV4dGVuZHMgQ29hdENvbG9yZWQge1xuICAgIHB1YmxpYyB0ZXh0dXJlOiBUZXh0dXJlID0gbnVsbDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCksIF90ZXh0dXJlOiBUZXh0dXJlID0gVGV4dHVyZURlZmF1bHQudGV4dHVyZSkge1xuICAgICAgc3VwZXIoX2NvbG9yKTtcbiAgICAgIHRoaXMudGV4dHVyZSA9IF90ZXh0dXJlO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5pZFRleHR1cmUgPSB0aGlzLnRleHR1cmUuaWRSZXNvdXJjZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSlcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gPFRleHR1cmU+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiQ29hdFRleHR1cmVkLnRzXCIvPlxuXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEEge0BsaW5rIENvYXR9IHByb3ZpZGluZyBhIHRleHR1cmUgYW5kIGFkZGl0aW9uYWwgZGF0YSBmb3IgdGV4dHVyaW5nXG4gICAqL1xuICBAUmVuZGVySW5qZWN0b3JDb2F0LmRlY29yYXRlXG4gIGV4cG9ydCBjbGFzcyBDb2F0UmVtaXNzaXZlVGV4dHVyZWQgZXh0ZW5kcyBDb2F0VGV4dHVyZWQge1xuICAgIHB1YmxpYyBzcGVjdWxhcjogbnVtYmVyO1xuICAgIHB1YmxpYyBkaWZmdXNlOiBudW1iZXI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigpLCBfdGV4dHVyZTogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0LnRleHR1cmUsIF9kaWZmdXNlOiBudW1iZXIgPSAxLCBfc3BlY3VsYXI6IG51bWJlciA9IDApIHtcbiAgICAgIHN1cGVyKF9jb2xvciwgX3RleHR1cmUpO1xuICAgICAgdGhpcy5kaWZmdXNlID0gX2RpZmZ1c2U7XG4gICAgICB0aGlzLnNwZWN1bGFyID0gX3NwZWN1bGFyO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5kaWZmdXNlID0gdGhpcy5kaWZmdXNlO1xuICAgICAgc2VyaWFsaXphdGlvbi5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXI7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIHRoaXMuZGlmZnVzZSA9IF9zZXJpYWxpemF0aW9uLmRpZmZ1c2U7XG4gICAgICB0aGlzLnNwZWN1bGFyID0gX3NlcmlhbGl6YXRpb24uc3BlY3VsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIERlZmluZXMgYSBjb2xvciBhcyB2YWx1ZXMgaW4gdGhlIHJhbmdlIG9mIDAgdG8gMSBmb3IgdGhlIGZvdXIgY2hhbm5lbHMgcmVkLCBncmVlbiwgYmx1ZSBhbmQgYWxwaGEgKGZvciBvcGFjaXR5KVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIENvbG9yIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XG4gICAgLy8gY3JjMiBvbmx5IHVzZWQgZm9yIGNvbnZlcnRpbmcgY29sb3JzIGZyb20gc3RyaW5ncyBwcmVkZWZpbmVkIGJ5IENTU1xuICAgIHByaXZhdGUgc3RhdGljIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiLCB7IHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSB9KTtcbiAgICAgIGNyYzIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG4gICAgICByZXR1cm4gY3JjMjtcbiAgICB9KSgpO1xuXG4gICAgcHVibGljIHI6IG51bWJlcjtcbiAgICBwdWJsaWMgZzogbnVtYmVyO1xuICAgIHB1YmxpYyBiOiBudW1iZXI7XG4gICAgcHVibGljIGE6IG51bWJlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcjogbnVtYmVyID0gMSwgX2c6IG51bWJlciA9IDEsIF9iOiBudW1iZXIgPSAxLCBfYTogbnVtYmVyID0gMSkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc2V0Tm9ybVJHQkEoX3IsIF9nLCBfYiwgX2EpO1xuICAgIH1cblxuICAgIC8vIC8qKlxuICAgIC8vICAqIFJldHVybnMgYSBoZXgtY29kZSByZXByZXNlbnRhdGlvbiwgaS5lLiBcIiNSUkdHQkJBQVwiLCBvZiB0aGUgZ2l2ZW4gY3NzIGNvbG9yIGtleXdvcmQuXG4gICAgLy8gICovXG4gICAgLy8gcHVibGljIHN0YXRpYyBnZXRIZXhGcm9tQ1NTS2V5d29yZChfa2V5d29yZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyAgIGxldCBoZXg6IHN0cmluZyA9IFwiI1wiO1xuICAgIC8vICAgZm9yIChsZXQgYnl0ZSBvZiBDb2xvci5nZXRCeXRlc1JHQkFGcm9tQ1NTS2V5d29yZChfa2V5d29yZCkpXG4gICAgLy8gICAgIGhleCArPSBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgLy8gICByZXR1cm4gaGV4O1xuICAgIC8vIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgVWludDhDbGFtcGVkQXJyYXl9IHdpdGggdGhlIDgtYml0IGNvbG9yIGNoYW5uZWwgdmFsdWVzIGluIHRoZSBvcmRlciBSR0JBLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Qnl0ZXNSR0JBRnJvbUNTU0tleXdvcmQoX2tleXdvcmQ6IHN0cmluZyk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcbiAgICAgIENvbG9yLmNyYzIuZmlsbFN0eWxlID0gX2tleXdvcmQ7XG4gICAgICBDb2xvci5jcmMyLmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgcmV0dXJuIENvbG9yLmNyYzIuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB7QGxpbmsgQ29sb3J9IG9iamVjdCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIGNzcyBjb2xvciBrZXl3b3JkLiBcbiAgICAgKiBQYXNzaW5nIGFuIF9hbHBoYSB2YWx1ZSB3aWxsIG92ZXJyaWRlIHRoZSBhbHBoYSB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIGtleXdvcmQuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBDU1MoX2tleXdvcmQ6IHN0cmluZywgX2FscGhhPzogbnVtYmVyKTogQ29sb3Ige1xuICAgICAgY29uc3QgYnl0ZXNSR0JBOiBVaW50OENsYW1wZWRBcnJheSA9IENvbG9yLmdldEJ5dGVzUkdCQUZyb21DU1NLZXl3b3JkKF9rZXl3b3JkKTtcbiAgICAgIC8vIC8vIGNvbnNlcnZlIHRoZSBpbnB1dCBhbHBoYSB2YWx1ZSBmcm9tIGtleXdvcmQgd2hlbiByZ2JhKCkgb3IgaHNsYSgpIGlzIHVzZWQsIG90aGVyd2lzZSBcInJnYmEoLi4uLCAwLjMpXCIgcmVzdWx0cyBpbiBjb2xvci5hID0gfjAuMzAxOTYgY29udmVyc2lvblxuICAgICAgLy8gaWYgKF9rZXl3b3JkLnRvTG9jYWxlTG93ZXJDYXNlKCkubWF0Y2goLyhyZ2JhfGhzbGEpXFwoLipcXCkvKSkgXG4gICAgICAvLyAgIF9hbHBoYSA9IHBhcnNlRmxvYXQoX2tleXdvcmQubWF0Y2goL1teLF0rKD89XFwpKS8pWzBdKTtcbiAgICAgIGNvbnN0IGNvbG9yOiBDb2xvciA9IG5ldyBDb2xvcihcbiAgICAgICAgYnl0ZXNSR0JBWzBdIC8gMjU1LFxuICAgICAgICBieXRlc1JHQkFbMV0gLyAyNTUsXG4gICAgICAgIGJ5dGVzUkdCQVsyXSAvIDI1NSxcbiAgICAgICAgX2FscGhhID8/IGJ5dGVzUkdCQVszXSAvIDI1NSk7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIE1VTFRJUExJQ0FUSU9OIGxpa2UgaW4gTWF0YXJpeDN4My9NYXRyaXg0eDQ/XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHJ1bnMgdGhlIHByb2R1Y3Qgb2YgdHdvIGNvbG9ycy4gXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMWShfY29sb3IxOiBDb2xvciwgX2NvbG9yMjogQ29sb3IpOiBDb2xvciB7XG4gICAgICByZXR1cm4gbmV3IENvbG9yKF9jb2xvcjEuciAqIF9jb2xvcjIuciwgX2NvbG9yMS5nICogX2NvbG9yMi5nLCBfY29sb3IxLmIgKiBfY29sb3IyLmIsIF9jb2xvcjEuYSAqIF9jb2xvcjIuYSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIHNldENsYW1wZWRSR0JBPyBOb3JtIGlzIG1pc2xlYWRpbmcsIHNpbmNlIGl0IGlzIG5vdCBub3JtYWxpemVkIGJ1dCBjbGFtcGVkXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSBnaXZlbiBjb2xvciBjaGFubmVsIHZhbHVlcyBiZXd0ZWVuIDAgYW5kIDEgYW5kIHNldHMgdGhlbS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0Tm9ybVJHQkEoX3I6IG51bWJlciwgX2c6IG51bWJlciwgX2I6IG51bWJlciwgX2E6IG51bWJlcik6IHZvaWQge1xuICAgICAgdGhpcy5yID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX3IpKTtcbiAgICAgIHRoaXMuZyA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIF9nKSk7XG4gICAgICB0aGlzLmIgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBfYikpO1xuICAgICAgdGhpcy5hID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX2EpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gOC1iaXQgdmFsdWVzIGZvciB0aGUgY29sb3IgY2hhbm5lbHMuXG4gICAgICovXG4gICAgcHVibGljIHNldEJ5dGVzUkdCQShfcjogbnVtYmVyLCBfZzogbnVtYmVyLCBfYjogbnVtYmVyLCBfYTogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLnNldE5vcm1SR0JBKF9yIC8gMjU1LCBfZyAvIDI1NSwgX2IgLyAyNTUsIF9hIC8gMjU1KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHtAbGluayBGbG9hdDMyQXJyYXl9IHdpdGggdGhlIGNvbG9yIGNoYW5uZWwgdmFsdWVzIGluIHRoZSBvcmRlciBSR0JBLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBcnJheSgpOiBGbG9hdDMyQXJyYXkge1xuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgZ2l2ZW4gY29sb3IgY2hhbm5lbCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxIGFuZCBzZXRzIHRoZW0uXG4gICAgICovXG4gICAgcHVibGljIHNldEFycmF5Tm9ybVJHQkEoX2NvbG9yOiBGbG9hdDMyQXJyYXkpOiB2b2lkIHtcbiAgICAgIHRoaXMuc2V0Tm9ybVJHQkEoX2NvbG9yWzBdLCBfY29sb3JbMV0sIF9jb2xvclsyXSwgX2NvbG9yWzNdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4ge0BsaW5rIFVpbnQ4Q2xhbXBlZEFycmF5fS4gT3JkZXIgb2YgdGhlIGNoYW5uZWxzIGlzIFJHQkFcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0QXJyYXlCeXRlc1JHQkEoX2NvbG9yOiBVaW50OENsYW1wZWRBcnJheSk6IHZvaWQge1xuICAgICAgdGhpcy5zZXRCeXRlc1JHQkEoX2NvbG9yWzBdLCBfY29sb3JbMV0sIF9jb2xvclsyXSwgX2NvbG9yWzNdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHtAbGluayBVaW50OENsYW1wZWRBcnJheX0gd2l0aCB0aGUgY29sb3IgY2hhbm5lbCB2YWx1ZXMgaW4gdGhlIG9yZGVyIFJHQkEuXG4gICAgICovXG4gICAgcHVibGljIGdldEFycmF5Qnl0ZXNSR0JBKCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcbiAgICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoW3RoaXMuciAqIDI1NSwgdGhpcy5nICogMjU1LCB0aGlzLmIgKiAyNTUsIHRoaXMuYSAqIDI1NV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIGNvbG9yIHRvIHRoaXMuXG4gICAgICovXG4gICAgcHVibGljIGFkZChfY29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICB0aGlzLnIgKz0gX2NvbG9yLnI7XG4gICAgICB0aGlzLmcgKz0gX2NvbG9yLmc7XG4gICAgICB0aGlzLmIgKz0gX2NvbG9yLmI7XG4gICAgICB0aGlzLmEgKz0gX2NvbG9yLmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3NzIGNvbG9yIGtleXdvcmQgcmVwcmVzZW50aW5nIHRoaXMgY29sb3IuXG4gICAgICovXG4gICAgcHVibGljIGdldENTUygpOiBzdHJpbmcge1xuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcbiAgICAgIHJldHVybiBgUkdCQSgke2J5dGVzWzBdfSwgJHtieXRlc1sxXX0sICR7Ynl0ZXNbMl19LCAke3RoaXMuYX0pYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29sb3IuXG4gICAgICovXG4gICAgcHVibGljIGdldEhleCgpOiBzdHJpbmcge1xuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcbiAgICAgIGxldCBoZXg6IHN0cmluZyA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBieXRlIG9mIGJ5dGVzKVxuICAgICAgICBoZXggKz0gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgICAgcmV0dXJuIGhleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gaGV4IHN0cmluZyBjb2xvci5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0SGV4KF9oZXg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcbiAgICAgIGxldCBjaGFubmVsOiBudW1iZXIgPSAwO1xuICAgICAgZm9yIChsZXQgYnl0ZSBpbiBieXRlcylcbiAgICAgICAgYnl0ZXNbYnl0ZV0gPSBwYXJzZUludChfaGV4LnN1YnN0cihjaGFubmVsKysgKiAyLCAyKSwgMTYpO1xuICAgICAgdGhpcy5zZXRBcnJheUJ5dGVzUkdCQShieXRlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgY29sb3IgdG8gdGhlIHZhbHVlcyBnaXZlbiBieSB0aGUgY29sb3IgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgY29weShfY29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICB0aGlzLnIgPSBfY29sb3IucjtcbiAgICAgIHRoaXMuZyA9IF9jb2xvci5nO1xuICAgICAgdGhpcy5iID0gX2NvbG9yLmI7XG4gICAgICB0aGlzLmEgPSBfY29sb3IuYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gYChyOiAke3RoaXMuci50b0ZpeGVkKDMpfSwgZzogJHt0aGlzLmcudG9GaXhlZCgzKX0sIGI6ICR7dGhpcy5iLnRvRml4ZWQoMyl9LCBhOiAke3RoaXMuYS50b0ZpeGVkKDMpfSlgO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcih0cnVlKTtcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYHsgXCJyXCI6ICR7dGhpcy5yfSwgXCJnXCI6ICR7dGhpcy5nfSwgXCJiXCI6ICR7dGhpcy5ifSwgXCJhXCI6ICR7dGhpcy5hfX1gOyB9O1xuICAgICAgc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgWyR7dGhpcy5yfSwgJHt0aGlzLmd9LCAke3RoaXMuYn0sICR7dGhpcy5hfV1gOyB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGlmICh0eXBlb2YgKF9zZXJpYWxpemF0aW9uKSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmFdID0gSlNPTi5wYXJzZSg8c3RyaW5nPjx1bmtub3duPl9zZXJpYWxpemF0aW9uKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEJhc2VjbGFzcyBmb3IgbWF0ZXJpYWxzLiBDb21iaW5lcyBhIHtAbGluayBTaGFkZXJ9IHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBDb2F0fVxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcbiAgICAvKiogVGhlIG5hbWUgdG8gY2FsbCB0aGUgTWF0ZXJpYWwgYnkuICovXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgc2hhZGVyVHlwZTogdHlwZW9mIFNoYWRlcjsgLy8gVGhlIHNoYWRlciBwcm9ncmFtIHVzZWQgYnkgdGhpcyBCYXNlTWF0ZXJpYWxcbiAgICAjY29hdDogQ29hdDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfc2hhZGVyPzogdHlwZW9mIFNoYWRlciwgX2NvYXQ/OiBDb2F0KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSBfc2hhZGVyO1xuICAgICAgaWYgKF9zaGFkZXIpIHtcbiAgICAgICAgaWYgKF9jb2F0KVxuICAgICAgICAgIHRoaXMuY29hdCA9IF9jb2F0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5jb2F0ID0gdGhpcy5jcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTtcbiAgICAgIH1cbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHJlZmVyZW5jZWQge0BsaW5rIENvYXR9IGluc3RhbmNlXG4gICAgICovXG4gICAgcHVibGljIGdldCBjb2F0KCk6IENvYXQge1xuICAgICAgcmV0dXJuIHRoaXMuI2NvYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoaXMgbWF0ZXJpYWwgcmVmZXJlbmNlIHRoZSBnaXZlbiB7QGxpbmsgQ29hdH0gaWYgaXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSByZWZlcmVuY2VkIHtAbGluayBTaGFkZXJ9XG4gICAgICovXG4gICAgcHVibGljIHNldCBjb2F0KF9jb2F0OiBDb2F0KSB7XG4gICAgICBpZiAoX2NvYXQuY29uc3RydWN0b3IgIT0gdGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSlcbiAgICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgdGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSlcbiAgICAgICAgICBEZWJ1Zy5mdWRnZShcIkNvYXQgaXMgZXh0ZW5zaW9uIG9mIENvYXQgcmVxdWlyZWQgYnkgc2hhZGVyXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIlNoYWRlciBhbmQgY29hdCBkb24ndCBtYXRjaFwiKSk7XG4gICAgICB0aGlzLiNjb2F0ID0gX2NvYXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQ29hdH0gaW5zdGFuY2UgdGhhdCBpcyB2YWxpZCBmb3IgdGhlIHtAbGluayBTaGFkZXJ9IHJlZmVyZW5jZWQgYnkgdGhpcyBtYXRlcmlhbFxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTogQ29hdCB7XG4gICAgICBsZXQgY29hdDogQ29hdCA9IG5ldyAodGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSkoKTtcbiAgICAgIHJldHVybiBjb2F0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIG1hdGVyaWFscyByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIHtAbGluayBTaGFkZXJ9LCBjcmVhdGVzIGFuZCByZWZlcmVuY2VzIGEgbmV3IHtAbGluayBDb2F0fSBpbnN0YW5jZSAgXG4gICAgICogYW5kIG11dGF0ZXMgdGhlIG5ldyBjb2F0IHRvIHByZXNlcnZlIG1hdGNoaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIF9zaGFkZXJUeXBlIFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRTaGFkZXIoX3NoYWRlclR5cGU6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHtcbiAgICAgIHRoaXMuc2hhZGVyVHlwZSA9IF9zaGFkZXJUeXBlO1xuICAgICAgbGV0IGNvYXQ6IENvYXQgPSB0aGlzLmNyZWF0ZUNvYXRNYXRjaGluZ1NoYWRlcigpO1xuICAgICAgY29hdC5tdXRhdGUodGhpcy4jY29hdC5nZXRNdXRhdG9yKCkpO1xuICAgICAgdGhpcy5jb2F0ID0gY29hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgU2hhZGVyfSByZWZlcmVuY2VkIGJ5IHRoaXMgbWF0ZXJpYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2hhZGVyKCk6IHR5cGVvZiBTaGFkZXIge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyVHlwZTtcbiAgICB9XG5cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIC8vIFRPRE86IHRoaXMgdHlwZSBvZiBzZXJpYWxpemF0aW9uIHdhcyBpbXBsZW1lbnRlZCBmb3IgaW1wbGljaXQgTWF0ZXJpYWwgY3JlYXRlLiBDaGVjayBpZiBvYnNvbGV0ZSB3aGVuIG9ubHkgb25lIG1hdGVyaWFsIGNsYXNzIGV4aXN0cyBhbmQvb3IgbWF0ZXJpYWxzIGFyZSBzdG9yZWQgc2VwYXJhdGVseVxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXG4gICAgICAgIHNoYWRlcjogdGhpcy5zaGFkZXJUeXBlLm5hbWUsXG4gICAgICAgIGNvYXQ6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMuI2NvYXQpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcbiAgICAgIHRoaXMuc2hhZGVyVHlwZSA9ICg8R2VuZXJhbD5GdWRnZUNvcmUpW19zZXJpYWxpemF0aW9uLnNoYWRlcl07XG4gICAgICBsZXQgY29hdDogQ29hdCA9IDxDb2F0PmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29hdCk7XG4gICAgICB0aGlzLmNvYXQgPSBjb2F0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XG4gICAgICBtdXRhdG9yLmNvYXQgPSB0aGlzLmNvYXQuZ2V0TXV0YXRvcigpO1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIC8vIGRlbGV0ZSBfbXV0YXRvci5pZFJlc291cmNlO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQWJzdHJhY3QgY2xhc3Mgc3VwcG9ydGluZyB2YXJpb3VzIGFyaXRobWV0aWNhbCBoZWxwZXIgZnVuY3Rpb25zXG4gICAqL1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2FsYyB7XG4gICAgLyoqIGZhY3RvciBtdWx0aXBsaWVkIHdpdGggYW5nbGUgaW4gZGVncmVlcyB5aWVsZHMgdGhlIGFuZ2xlIGluIHJhZGlhbiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGVnMnJhZDogbnVtYmVyID0gTWF0aC5QSSAvIDE4MDtcbiAgICAvKiogZmFjdG9yIG11bHRpcGxpZWQgd2l0aCBhbmdsZSBpbiByYWRpYW4geWllbGRzIHRoZSBhbmdsZSBpbiBkZWdyZWVzICovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSByYWQyZGVnOiBudW1iZXIgPSAxIC8gQ2FsYy5kZWcycmFkO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIHZhbHVlcyBwYXNzZWQgaW4sIGVpdGhlciBfdmFsdWUgaWYgd2l0aGluIF9taW4gYW5kIF9tYXggb3IgdGhlIGJvdW5kYXJ5IGJlaW5nIGV4Y2VlZGVkIGJ5IF92YWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY2xhbXA8VD4oX3ZhbHVlOiBULCBfbWluOiBULCBfbWF4OiBULCBfaXNTbWFsbGVyOiAoX3ZhbHVlMTogVCwgX3ZhbHVlMjogVCkgPT4gYm9vbGVhbiA9IChfdmFsdWUxOiBULCBfdmFsdWUyOiBUKSA9PiB7IHJldHVybiBfdmFsdWUxIDwgX3ZhbHVlMjsgfSk6IFQge1xuICAgICAgaWYgKF9pc1NtYWxsZXIoX3ZhbHVlLCBfbWluKSkgcmV0dXJuIF9taW47XG4gICAgICBpZiAoX2lzU21hbGxlcihfbWF4LCBfdmFsdWUpKSByZXR1cm4gX21heDtcbiAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQm9yZGVyIHtcbiAgICBsZWZ0OiBudW1iZXI7XG4gICAgdG9wOiBudW1iZXI7XG4gICAgcmlnaHQ6IG51bWJlcjtcbiAgICBib3R0b206IG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtaW5nIGRlc2NyaWJlcyBob3cgdG8gbWFwIGEgcmVjdGFuZ2xlIGludG8gYSBnaXZlbiBmcmFtZVxuICAgKiBhbmQgaG93IHBvaW50cyBpbiB0aGUgZnJhbWUgY29ycmVzcG9uZCB0byBwb2ludHMgaW4gdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgYW5kIHZpY2UgdmVyc2FcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkgIFxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvRnJhbWluZ1xuICAgKi9cbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZyYW1pbmcgZXh0ZW5kcyBNdXRhYmxlIHtcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgcG9pbnQgaW4gdGhlIGdpdmVuIGZyYW1lIGFjY29yZGluZyB0byB0aGlzIGZyYW1pbmdcbiAgICAgKiBAcGFyYW0gX3BvaW50SW5GcmFtZSBUaGUgcG9pbnQgaW4gdGhlIGZyYW1lIGdpdmVuXG4gICAgICogQHBhcmFtIF9yZWN0RnJhbWUgVGhlIGZyYW1lIHRoZSBwb2ludCBpcyByZWxhdGl2ZSB0b1xuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyO1xuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIHBvaW50IGluIGEgZ2l2ZW4gcmVjdGFuZ2xlIGJhY2sgdG8gYSBjYWxjdWxhdGVkIGZyYW1lIG9mIG9yaWdpblxuICAgICAqIEBwYXJhbSBfcG9pbnQgVGhlIHBvaW50IGluIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gX3JlY3QgVGhlIHJlY3RhbmdsZSB0aGUgcG9pbnQgaXMgcmVsYXRpdmUgdG9cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjI7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHJlY3RhbmdsZSBhcyB0aGUgZnJhbWUgYW5kIGNyZWF0ZXMgYSBuZXcgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZnJhbWluZ1xuICAgICAqIEBwYXJhbSBfcmVjdEZyYW1lXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGhhcyBhIGZpeGVkIHdpZHRoIGFuZCBoZWlnaHQgYW5kIGRpc3BsYXkgc2hvdWxkIHNjYWxlIHRvIGZpdCB0aGUgZnJhbWVcbiAgICogUG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cbiAgICovXG4gIGV4cG9ydCBjbGFzcyBGcmFtaW5nRml4ZWQgZXh0ZW5kcyBGcmFtaW5nIHtcbiAgICBwdWJsaWMgd2lkdGg6IG51bWJlciA9IDMwMDtcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXIgPSAxNTA7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3dpZHRoOiBudW1iZXIgPSAzMDAsIF9oZWlnaHQ6IG51bWJlciA9IDE1MCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc2V0U2l6ZShfd2lkdGgsIF9oZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyBmcmFtaW5nIHRvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICovXG4gICAgcHVibGljIHNldFNpemUoX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgdGhpcy53aWR0aCA9IF93aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gX2hlaWdodDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXG4gICAgICAgIHRoaXMud2lkdGggKiAoX3BvaW50SW5GcmFtZS54IC0gX3JlY3RGcmFtZS54KSAvIF9yZWN0RnJhbWUud2lkdGgsXG4gICAgICAgIHRoaXMuaGVpZ2h0ICogKF9wb2ludEluRnJhbWUueSAtIF9yZWN0RnJhbWUueSkgLyBfcmVjdEZyYW1lLmhlaWdodFxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFBvaW50SW52ZXJzZShfcG9pbnQ6IFZlY3RvcjIsIF9yZWN0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcbiAgICAgICAgX3BvaW50LnggKiBfcmVjdC53aWR0aCAvIHRoaXMud2lkdGggKyBfcmVjdC54LFxuICAgICAgICBfcG9pbnQueSAqIF9yZWN0LmhlaWdodCAvIHRoaXMuaGVpZ2h0ICsgX3JlY3QueVxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgYXJlIGZyYWN0aW9ucyBvZiB0aG9zZSBvZiB0aGUgZnJhbWUsIHNjYWxlZCBieSBub3JtZWQgdmFsdWVzIG5vcm1XaWR0aCBhbmQgbm9ybUhlaWdodC5cbiAgICogRGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZSBhbmQgcG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cbiAgICovXG4gIGV4cG9ydCBjbGFzcyBGcmFtaW5nU2NhbGVkIGV4dGVuZHMgRnJhbWluZyB7XG4gICAgcHVibGljIG5vcm1XaWR0aDogbnVtYmVyID0gMS4wO1xuICAgIHB1YmxpYyBub3JtSGVpZ2h0OiBudW1iZXIgPSAxLjA7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgZnJhbWluZyB0byB0aGUgZ2l2ZW4gbm9ybWVkIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0U2NhbGUoX25vcm1XaWR0aDogbnVtYmVyLCBfbm9ybUhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLm5vcm1XaWR0aCA9IF9ub3JtV2lkdGg7XG4gICAgICB0aGlzLm5vcm1IZWlnaHQgPSBfbm9ybUhlaWdodDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXG4gICAgICAgIHRoaXMubm9ybVdpZHRoICogKF9wb2ludEluRnJhbWUueCAtIF9yZWN0RnJhbWUueCksXG4gICAgICAgIHRoaXMubm9ybUhlaWdodCAqIChfcG9pbnRJbkZyYW1lLnkgLSBfcmVjdEZyYW1lLnkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxuICAgICAgICBfcG9pbnQueCAvIHRoaXMubm9ybVdpZHRoICsgX3JlY3QueCxcbiAgICAgICAgX3BvaW50LnkgLyB0aGlzLm5vcm1IZWlnaHQgKyBfcmVjdC55XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy5ub3JtV2lkdGggKiBfcmVjdEZyYW1lLndpZHRoLCB0aGlzLm5vcm1IZWlnaHQgKiBfcmVjdEZyYW1lLmhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGZpdHMgaW50byBhIG1hcmdpbiBnaXZlbiBhcyBmcmFjdGlvbnMgb2YgdGhlIHNpemUgb2YgdGhlIGZyYW1lIGdpdmVuIGJ5IG5vcm1BbmNob3JcbiAgICogcGx1cyBhbiBhYnNvbHV0ZSBwYWRkaW5nIGdpdmVuIGJ5IHBpeGVsQm9yZGVyLiBEaXNwbGF5IHNob3VsZCBmaXQgaW50byB0aGlzLlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdDb21wbGV4IGV4dGVuZHMgRnJhbWluZyB7XG4gICAgcHVibGljIG1hcmdpbjogQm9yZGVyID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfTtcbiAgICBwdWJsaWMgcGFkZGluZzogQm9yZGVyID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfTtcblxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcbiAgICAgICAgX3BvaW50SW5GcmFtZS54IC0gdGhpcy5wYWRkaW5nLmxlZnQgLSB0aGlzLm1hcmdpbi5sZWZ0ICogX3JlY3RGcmFtZS53aWR0aCxcbiAgICAgICAgX3BvaW50SW5GcmFtZS55IC0gdGhpcy5wYWRkaW5nLnRvcCAtIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0RnJhbWUuaGVpZ2h0XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHVibGljIGdldFBvaW50SW52ZXJzZShfcG9pbnQ6IFZlY3RvcjIsIF9yZWN0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcbiAgICAgICAgX3BvaW50LnggKyB0aGlzLnBhZGRpbmcubGVmdCArIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdC53aWR0aCxcbiAgICAgICAgX3BvaW50LnkgKyB0aGlzLnBhZGRpbmcudG9wICsgdGhpcy5tYXJnaW4udG9wICogX3JlY3QuaGVpZ2h0XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xuICAgICAgaWYgKCFfcmVjdEZyYW1lKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgbGV0IG1pblg6IG51bWJlciA9IF9yZWN0RnJhbWUueCArIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdEZyYW1lLndpZHRoICsgdGhpcy5wYWRkaW5nLmxlZnQ7XG4gICAgICBsZXQgbWluWTogbnVtYmVyID0gX3JlY3RGcmFtZS55ICsgdGhpcy5tYXJnaW4udG9wICogX3JlY3RGcmFtZS5oZWlnaHQgKyB0aGlzLnBhZGRpbmcudG9wO1xuICAgICAgbGV0IG1heFg6IG51bWJlciA9IF9yZWN0RnJhbWUueCArICgxIC0gdGhpcy5tYXJnaW4ucmlnaHQpICogX3JlY3RGcmFtZS53aWR0aCAtIHRoaXMucGFkZGluZy5yaWdodDtcbiAgICAgIGxldCBtYXhZOiBudW1iZXIgPSBfcmVjdEZyYW1lLnkgKyAoMSAtIHRoaXMubWFyZ2luLmJvdHRvbSkgKiBfcmVjdEZyYW1lLmhlaWdodCAtIHRoaXMucGFkZGluZy5ib3R0b207XG5cbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICByZXR1cm4geyBtYXJnaW46IHRoaXMubWFyZ2luLCBwYWRkaW5nOiB0aGlzLnBhZGRpbmcgfTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yMiBhcyBwb2xhciBjb29yZGluYXRlcyBcbiAgICogYGBgdGV4dFxuICAgKiAg4oaVLSBhbmdsZSAoQW5nbGUgdG8gdGhlIHgtYXhpcylcbiAgICogIC3ihpIgTWFnbml0dWRlIChEaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIpICBcbiAgICogYGBgXG4gICAqL1xuICBleHBvcnQgY2xhc3MgR2VvMiBpbXBsZW1lbnRzIFJlY3ljYWJsZSB7XG4gICAgcHVibGljIG1hZ25pdHVkZTogbnVtYmVyID0gMDtcbiAgICBwdWJsaWMgYW5nbGU6IG51bWJlciA9IDA7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2FuZ2xlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKSB7XG4gICAgICB0aGlzLnNldChfYW5nbGUsIF9tYWduaXR1ZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlIGF0IG9uY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0KF9hbmdsZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSk6IHZvaWQge1xuICAgICAgdGhpcy5tYWduaXR1ZGUgPSBfbWFnbml0dWRlO1xuICAgICAgdGhpcy5hbmdsZSA9IF9hbmdsZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMuc2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByZXR0eSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBgYW5nbGU6ICR7dGhpcy5hbmdsZS50b1ByZWNpc2lvbig1KX0sICBtYWduaXR1ZGU6ICR7dGhpcy5tYWduaXR1ZGUudG9QcmVjaXNpb24oNSl9YDtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yMyBhcyBnZW9ncmFwaGljIGNvb3JkaW5hdGVzIGFzIHNlZW4gb24gYSBnbG9iZVxuICAgKiBgYGB0ZXh0XG4gICAqIOKGkHzihpIgTG9uZ2l0dWRlIChBbmdsZSB0byB0aGUgei1heGlzKSBcbiAgICogIOKGlS0gTGF0aXR1ZGUgKEFuZ2xlIHRvIHRoZSBlcXVhdG9yKVxuICAgKiAgLeKGkiBNYWduaXR1ZGUgKERpc3RhbmNlIGZyb20gdGhlIGNlbnRlcikgIFxuICAgKiBgYGBcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBHZW8zIGltcGxlbWVudHMgUmVjeWNhYmxlIHtcbiAgICBwdWJsaWMgbWFnbml0dWRlOiBudW1iZXIgPSAwO1xuICAgIHB1YmxpYyBsYXRpdHVkZTogbnVtYmVyID0gMDtcbiAgICBwdWJsaWMgbG9uZ2l0dWRlOiBudW1iZXIgPSAwO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9sb25naXR1ZGU6IG51bWJlciA9IDAsIF9sYXRpdHVkZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSkge1xuICAgICAgdGhpcy5zZXQoX2xvbmdpdHVkZSwgX2xhdGl0dWRlLCBfbWFnbml0dWRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBpbnN0YW5jZSBhdCBvbmNlXG4gICAgICovXG4gICAgcHVibGljIHNldChfbG9uZ2l0dWRlOiBudW1iZXIgPSAwLCBfbGF0aXR1ZGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpOiB2b2lkIHtcbiAgICAgIHRoaXMubWFnbml0dWRlID0gX21hZ25pdHVkZTtcbiAgICAgIHRoaXMubGF0aXR1ZGUgPSBfbGF0aXR1ZGU7XG4gICAgICB0aGlzLmxvbmdpdHVkZSA9IF9sb25naXR1ZGU7XG4gICAgfVxuXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XG4gICAgICB0aGlzLnNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcmV0dHkgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gYGxvbmdpdHVkZTogJHt0aGlzLmxvbmdpdHVkZS50b1ByZWNpc2lvbig1KX0sIGxhdGl0dWRlOiAke3RoaXMubGF0aXR1ZGUudG9QcmVjaXNpb24oNSl9LCBtYWduaXR1ZGU6ICR7dGhpcy5tYWduaXR1ZGUudG9QcmVjaXNpb24oNSl9YDtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLy8gRnJvbSBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4gIC8vIEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuICBleHBvcnQgZnVuY3Rpb24gTWFzaCgpOiBGdW5jdGlvbiB7XG4gICAgbGV0IG46IG51bWJlciA9IDB4ZWZjODI0OWQ7XG5cbiAgICBsZXQgbWFzaDogRnVuY3Rpb24gPSBmdW5jdGlvbiAoX2RhdGE6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB7XG4gICAgICBfZGF0YSA9IF9kYXRhLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbiArPSBfZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBsZXQgaDogbnVtYmVyID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgICBoIC09IG47XG4gICAgICAgIGggKj0gbjtcbiAgICAgICAgbiA9IGggPj4+IDA7XG4gICAgICAgIGggLT0gbjtcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICAgIH1cbiAgICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIH07XG5cbiAgICAvLyBtYXNoLnZlcnNpb24gPSAnTWFzaCAwLjknO1xuICAgIHJldHVybiBtYXNoO1xuICB9XG5cblxuICAvLyBGcm9tIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbiAgZXhwb3J0IGZ1bmN0aW9uIExGSUI0KCk6IEZ1bmN0aW9uIHtcbiAgICAvLyBHZW9yZ2UgTWFyc2FnbGlhJ3MgTEZJQjQsXG4gICAgLy9odHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZ3JvdXAvc2NpLmNyeXB0L21zZy9lYjRkZGRlNzgyYjE3MDUxXG4gICAgbGV0IGFyZ3M6IG51bWJlcltdID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBsZXQgazA6IG51bWJlciA9IDAsXG4gICAgICBrMTogbnVtYmVyID0gNTgsXG4gICAgICBrMjogbnVtYmVyID0gMTE5LFxuICAgICAgazM6IG51bWJlciA9IDE3ODtcblxuICAgIGxldCBzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgbGV0IG1hc2g6IEZ1bmN0aW9uID0gTWFzaCgpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJncyA9IFsrbmV3IERhdGUoKV07XG4gICAgfVxuICAgIGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCAyNTY7IGorKykge1xuICAgICAgc1tqXSA9IG1hc2goXCIgXCIpO1xuICAgICAgc1tqXSAtPSBtYXNoKFwiIFwiKSAqIDQuNzY4MzcxNTgyMDMxMjVlLTc7IC8vIDJeLTIxXG4gICAgICBpZiAoc1tqXSA8IDApIHtcbiAgICAgICAgc1tqXSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IDI1NjsgaisrKSB7XG4gICAgICAgIHNbal0gLT0gbWFzaChhcmdzW2ldKTtcbiAgICAgICAgc1tqXSAtPSBtYXNoKGFyZ3NbaV0pICogNC43NjgzNzE1ODIwMzEyNWUtNzsgLy8gMl4tMjFcbiAgICAgICAgaWYgKHNbal0gPCAwKSB7XG4gICAgICAgICAgc1tqXSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hc2ggPSBudWxsO1xuXG4gICAgbGV0IHJhbmRvbTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoKTogbnVtYmVyIHtcbiAgICAgIGxldCB4OiBudW1iZXI7XG5cbiAgICAgIGswID0gKGswICsgMSkgJiAyNTU7XG4gICAgICBrMSA9IChrMSArIDEpICYgMjU1O1xuICAgICAgazIgPSAoazIgKyAxKSAmIDI1NTtcbiAgICAgIGszID0gKGszICsgMSkgJiAyNTU7XG5cbiAgICAgIHggPSBzW2swXSAtIHNbazFdO1xuICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgIHggKz0gMTtcbiAgICAgIH1cbiAgICAgIHggLT0gc1trMl07XG4gICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgeCArPSAxO1xuICAgICAgfVxuICAgICAgeCAtPSBzW2szXTtcbiAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICB4ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzW2swXSA9IHg7XG4gICAgfTtcblxuICAgIC8vIHJhbmRvbS51aW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gICByZXR1cm4gcmFuZG9tKCkgKiAweDEwMDAwMDAwMCA+Pj4gMDsgLy8gMl4zMlxuICAgIC8vIH07XG4gICAgLy8gcmFuZG9tLmZyYWN0NTMgPSByYW5kb207XG4gICAgLy8gcmFuZG9tLnZlcnNpb24gPSBcIkxGSUI0IDAuOVwiO1xuICAgIC8vIHJhbmRvbS5hcmdzID0gYXJncztcblxuICAgIHJldHVybiByYW5kb207XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGUgbWF0cml4IGFzIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZyB7QGxpbmsgVmVjdG9yMn0sIGJlaW5nIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbWF0cml4XG4gICAqL1xuICBpbnRlcmZhY2UgVmVjdG9yUmVwcmVzZW50YXRpb24ge1xuICAgIHRyYW5zbGF0aW9uOiBWZWN0b3IyO1xuICAgIHJvdGF0aW9uOiBudW1iZXI7XG4gICAgc2NhbGluZzogVmVjdG9yMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1wbGUgY2xhc3MgZm9yIDN4MyBtYXRyaXggb3BlcmF0aW9uc1xuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXG4gICAqL1xuICBleHBvcnQgY2xhc3MgTWF0cml4M3gzIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgUmVjeWNhYmxlIHtcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7IC8vIFRoZSBkYXRhIG9mIHRoZSBtYXRyaXguXG4gICAgcHJpdmF0ZSBtdXRhdG9yOiBNdXRhdG9yID0gbnVsbDsgLy8gcHJlcGFyZWQgZm9yIG9wdGltaXphdGlvbiwga2VlcCBtdXRhdG9yIHRvIHJlZHVjZSByZWR1bmRhbnQgY2FsY3VsYXRpb24gYW5kIGZvciBjb21wYXJpc29uLiBTZXQgdG8gbnVsbCB3aGVuIGRhdGEgY2hhbmdlcyFcbiAgICBwcml2YXRlIHZlY3RvcnM6IFZlY3RvclJlcHJlc2VudGF0aW9uOyAvLyB2ZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXRyaXhcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnJlY3ljbGUoKTtcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgIH1cblxuXG4gICAgLy9UT0RPOiBmaWd1cmUgb3V0IHdoYXQgdGhpcyBpcyB1c2VkIGZvclxuICAgIC8qKiBUT0RPOiBkZXNjcmliZSEgKi9cbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT04oX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IE1hdHJpeDN4MyB7XG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgMiAvIF93aWR0aCwgMCwgMCxcbiAgICAgICAgMCwgLTIgLyBfaGVpZ2h0LCAwLFxuICAgICAgICAtMSwgMSwgMVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbmV3IGlkZW50aXR5IG1hdHJpeFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgSURFTlRJVFkoKTogTWF0cml4M3gzIHtcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCB0cmFuc2xhdGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHtAbGluayBWZWN0b3IyfS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TTEFUSU9OKF90cmFuc2xhdGU6IFZlY3RvcjIpOiBNYXRyaXgzeDMge1xuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXG4gICAgICAgIDEsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsXG4gICAgICAgIF90cmFuc2xhdGUueCwgX3RyYW5zbGF0ZS55LCAxXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHotYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXG4gICAgICogQHBhcmFtIF9hbmdsZUluRGVncmVlcyBUaGUgdmFsdWUgb2YgdGhlIHJvdGF0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXgzeDMge1xuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogQ2FsYy5kZWcycmFkO1xuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgbGV0IGNvczogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgY29zLCBzaW4sIDAsXG4gICAgICAgIC1zaW4sIGNvcywgMCxcbiAgICAgICAgMCwgMCwgMVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCBzY2FsZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMSU5HKF9zY2FsYXI6IFZlY3RvcjIpOiBNYXRyaXgzeDMge1xuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXG4gICAgICAgIF9zY2FsYXIueCwgMCwgMCxcbiAgICAgICAgMCwgX3NjYWxhci55LCAwLFxuICAgICAgICAwLCAwLCAxXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIHBhc3NlZCBtYXRyaWNlcy5cbiAgICAgKiBAcGFyYW0gX210eExlZnQgVGhlIG1hdHJpeCB0byBtdWx0aXBseS5cbiAgICAgKiBAcGFyYW0gX210eFJpZ2h0IFRoZSBtYXRyaXggdG8gbXVsdGlwbHkgYnkuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBNVUxUSVBMSUNBVElPTihfbXR4TGVmdDogTWF0cml4M3gzLCBfbXR4UmlnaHQ6IE1hdHJpeDN4Myk6IE1hdHJpeDN4MyB7XG4gICAgICBsZXQgYTAwOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzAgKiAzICsgMF07XG4gICAgICBsZXQgYTAxOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzAgKiAzICsgMV07XG4gICAgICBsZXQgYTAyOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzAgKiAzICsgMl07XG4gICAgICBsZXQgYTEwOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzEgKiAzICsgMF07XG4gICAgICBsZXQgYTExOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzEgKiAzICsgMV07XG4gICAgICBsZXQgYTEyOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzEgKiAzICsgMl07XG4gICAgICBsZXQgYTIwOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzIgKiAzICsgMF07XG4gICAgICBsZXQgYTIxOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzIgKiAzICsgMV07XG4gICAgICBsZXQgYTIyOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzIgKiAzICsgMl07XG4gICAgICBsZXQgYjAwOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVswICogMyArIDBdO1xuICAgICAgbGV0IGIwMTogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMCAqIDMgKyAxXTtcbiAgICAgIGxldCBiMDI6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzAgKiAzICsgMl07XG4gICAgICBsZXQgYjEwOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsxICogMyArIDBdO1xuICAgICAgbGV0IGIxMTogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMSAqIDMgKyAxXTtcbiAgICAgIGxldCBiMTI6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzEgKiAzICsgMl07XG4gICAgICBsZXQgYjIwOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsyICogMyArIDBdO1xuICAgICAgbGV0IGIyMTogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMiAqIDMgKyAxXTtcbiAgICAgIGxldCBiMjI6IG51bWJlciA9IF9tdHhSaWdodC5kYXRhWzIgKiAzICsgMl07XG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwLFxuICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEsXG4gICAgICAgIGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMixcbiAgICAgICAgYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwLFxuICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEsXG4gICAgICAgIGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMixcbiAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwLFxuICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEsXG4gICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMlxuICAgICAgXSk7XG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBpbnZlcnNlIG9mIGEgcGFzc2VkIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gX210eCBUaGUgbWF0cml4IHRvIGNvbXB1dGUgdGhlIGludmVyc2Ugb2YuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBJTlZFUlNJT04oX210eDogTWF0cml4M3gzKTogTWF0cml4M3gzIHtcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbXR4LmRhdGE7XG4gICAgICBsZXQgbTAwOiBudW1iZXIgPSBtWzAgKiAzICsgMF07XG4gICAgICBsZXQgbTAxOiBudW1iZXIgPSBtWzAgKiAzICsgMV07XG4gICAgICBsZXQgbTAyOiBudW1iZXIgPSBtWzAgKiAzICsgMl07XG4gICAgICBsZXQgbTEwOiBudW1iZXIgPSBtWzEgKiAzICsgMF07XG4gICAgICBsZXQgbTExOiBudW1iZXIgPSBtWzEgKiAzICsgMV07XG4gICAgICBsZXQgbTEyOiBudW1iZXIgPSBtWzEgKiAzICsgMl07XG4gICAgICBsZXQgbTIwOiBudW1iZXIgPSBtWzIgKiAzICsgMF07XG4gICAgICBsZXQgbTIxOiBudW1iZXIgPSBtWzIgKiAzICsgMV07XG4gICAgICBsZXQgbTIyOiBudW1iZXIgPSBtWzIgKiAzICsgMl07XG5cbiAgICAgIGxldCBkOiBudW1iZXIgPSAxIC9cbiAgICAgICAgKG0wMCAqIChtMTEgKiBtMjIgLSBtMjEgKiBtMTIpIC1cbiAgICAgICAgICBtMDEgKiAobTEwICogbTIyIC0gbTEyICogbTIwKSArXG4gICAgICAgICAgbTAyICogKG0xMCAqIG0yMSAtIG0xMSAqIG0yMCkpO1xuXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLmdldChNYXRyaXgzeDMpO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgZCAqIChtMTEgKiBtMjIgLSBtMjEgKiBtMTIpLCAvLyBbMF1cbiAgICAgICAgZCAqIChtMDIgKiBtMjEgLSBtMDEgKiBtMjIpLCAvLyBbMV1cbiAgICAgICAgZCAqIChtMDEgKiBtMTIgLSBtMDIgKiBtMTEpLCAvLyBbMl1cbiAgICAgICAgZCAqIChtMTIgKiBtMjAgLSBtMTAgKiBtMjIpLCAvLyBbM11cbiAgICAgICAgZCAqIChtMDAgKiBtMjIgLSBtMDIgKiBtMjApLCAvLyBbNF1cbiAgICAgICAgZCAqIChtMTAgKiBtMDIgLSBtMDAgKiBtMTIpLCAvLyBbNV1cbiAgICAgICAgZCAqIChtMTAgKiBtMjEgLSBtMjAgKiBtMTEpLCAvLyBbNl1cbiAgICAgICAgZCAqIChtMjAgKiBtMDEgLSBtMDAgKiBtMjEpLCAvLyBbN11cbiAgICAgICAgZCAqIChtMDAgKiBtMTEgLSBtMTAgKiBtMDEpIC8vIFs4XVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2xhdGlvbiB7QGxpbmsgVmVjdG9yMn0uICBcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBieSBSZWN5Y2xlci4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRyYW5zbGF0aW9uKCk6IFZlY3RvcjIge1xuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKHRoaXMuZGF0YVs2XSwgdGhpcy5kYXRhWzddKTtcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb247IC8vIC5jbG9uZTtcbiAgICB9XG4gICAgcHVibGljIHNldCB0cmFuc2xhdGlvbihfdHJhbnNsYXRpb246IFZlY3RvcjIpIHtcbiAgICAgIHRoaXMuZGF0YS5zZXQoX3RyYW5zbGF0aW9uLmdldCgpLCA2KTtcbiAgICAgIC8vIG5vIGZ1bGwgY2FjaGUgcmVzZXQgcmVxdWlyZWRcbiAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IF90cmFuc2xhdGlvbjtcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgcm90YXRpb24ge0BsaW5rIFZlY3RvcjJ9ICAgXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XG4gICAgICovXG4gICAgcHVibGljIGdldCByb3RhdGlvbigpOiBudW1iZXIge1xuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMucm90YXRpb24pXG4gICAgICAgIHRoaXMudmVjdG9ycy5yb3RhdGlvbiA9IHRoaXMuZ2V0RXVsZXJBbmdsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjtcbiAgICB9XG4gICAgcHVibGljIHNldCByb3RhdGlvbihfcm90YXRpb246IG51bWJlcikge1xuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzY2FsZSB7QGxpbmsgVmVjdG9yM30uICBcbiAgICAgKiAqKkNhdXRpb24hKiogRG8gbm90IG1hbmlwdWxhdGUgcmVzdWx0LCBpbnN0ZWFkIGNyZWF0ZSBhIGNsb25lISAgICBcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNjYWxpbmcoKTogVmVjdG9yMiB7XG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy5zY2FsaW5nKVxuICAgICAgICB0aGlzLnZlY3RvcnMuc2NhbGluZyA9IG5ldyBWZWN0b3IyKFxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0pICogKHRoaXMuZGF0YVswXSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzNdLCB0aGlzLmRhdGFbNF0pICogKHRoaXMuZGF0YVs0XSA8IDAgPyAtMSA6IDEpXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnNjYWxpbmc7IC8vIC5jbG9uZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBzY2FsaW5nKF9zY2FsaW5nOiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLm11dGF0ZSh7IFwic2NhbGluZ1wiOiBfc2NhbGluZyB9KTtcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogTWF0cml4M3gzIHtcbiAgICAgIGxldCBtdHhDbG9uZTogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XG4gICAgICBtdHhDbG9uZS5zZXQodGhpcyk7XG4gICAgICByZXR1cm4gbXR4Q2xvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBtYXRyaXggdG8gdGhlIGlkZW50aXR5LW1hdHJpeCBhbmQgY2xlYXJzIGNhY2hlLiBVc2VkIGJ5IHRoZSByZWN5Y2xlciB0byByZXNldC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLFxuICAgICAgICAwLCAwLCAxXG4gICAgICBdKTtcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIHRoZSBpZGVudGl0eS1tYXRyaXggYW5kIGNsZWFycyBjYWNoZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgICB0aGlzLnJlY3ljbGUoKTtcbiAgICB9XG5cbiAgICAvLyNyZWdpb24gVHJhbnNsYXRpb25cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBieSB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9IHRvIHRoaXMgbWF0cml4IFxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2xhdGUoX2J5OiBWZWN0b3IyKTogdm9pZCB7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXgzeDMuVFJBTlNMQVRJT04oX2J5KSk7XG4gICAgICAvLyBUT0RPOiBwb3NzaWJsZSBvcHRpbWl6YXRpb24sIHRyYW5zbGF0aW9uIG1heSBhbHRlciBtdXRhdG9yIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQuXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zbGF0ZVgoX3g6IG51bWJlcik6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhWzZdICs9IF94O1xuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcbiAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB5LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhbnNsYXRlWShfeTogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLmRhdGFbN10gKz0gX3k7XG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICAvLyNyZWdpb24gU2NhbGluZ1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHNjYWxpbmcgYnkgdGhlIGdpdmVuIHtAbGluayBWZWN0b3IyfSB0byB0aGlzIG1hdHJpeCBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2NhbGUoX2J5OiBWZWN0b3IyKTogdm9pZCB7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXgzeDMuU0NBTElORyhfYnkpKTtcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB4LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2NhbGVYKF9ieTogbnVtYmVyKTogdm9pZCB7XG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xuICAgICAgdmVjdG9yLnNldChfYnksIDEpO1xuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXG4gICAgICovXG4gICAgcHVibGljIHNjYWxlWShfYnk6IG51bWJlcik6IHZvaWQge1xuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcbiAgICAgIHZlY3Rvci5zZXQoMSwgX2J5KTtcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHZlY3Rvcik7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG5cbiAgICAvLyNyZWdpb24gUm90YXRpb25cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB6LUF4aXMgdG8gdGhpcyBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgcm90YXRlKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogdm9pZCB7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXgzeDMuUk9UQVRJT04oX2FuZ2xlSW5EZWdyZWVzKSk7XG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgbXVsdGlwbHkoX210eFJpZ2h0OiBNYXRyaXgzeDMpOiB2b2lkIHtcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBfbXR4UmlnaHQpO1xuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZXVsZXItYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFdWxlckFuZ2xlKCk6IG51bWJlciB7XG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMiA9IHRoaXMuc2NhbGluZztcblxuICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XG4gICAgICBsZXQgczE6IG51bWJlciA9IHRoaXMuZGF0YVsxXSAvIHNjYWxpbmcueDtcbiAgICAgIGxldCBzMzogbnVtYmVyID0gdGhpcy5kYXRhWzNdIC8gc2NhbGluZy55O1xuICAgICAgbGV0IHM0OiBudW1iZXIgPSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnk7XG5cbiAgICAgIGxldCB4U2tldzogbnVtYmVyID0gTWF0aC5hdGFuMigtczMsIHM0KTtcbiAgICAgIGxldCB5U2tldzogbnVtYmVyID0gTWF0aC5hdGFuMihzMCwgczEpO1xuXG4gICAgICBsZXQgc3k6IG51bWJlciA9IE1hdGguaHlwb3QoczAsIHMxKTsgLy8gcHJvYmFibHkgMi4gcGFyYW0gc2hvdWxkIGJlIHRoaXMuZGF0YVs0XSAvIHNjYWxpbmcueVxuICAgICAgbGV0IHJvdGF0aW9uOiBudW1iZXI7XG5cbiAgICAgIGlmICghKHN5ID4gMWUtNikpXG4gICAgICAgIHJvdGF0aW9uID0geVNrZXc7XG4gICAgICBlbHNlXG4gICAgICAgIHJvdGF0aW9uID0geFNrZXc7XG5cbiAgICAgIHJvdGF0aW9uICo9IENhbGMucmFkMmRlZztcblxuICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQoX210eFRvOiBNYXRyaXgzeDMpOiB2b2lkIHtcbiAgICAgIC8vIHRoaXMuZGF0YSA9IF90by5nZXQoKTtcbiAgICAgIHRoaXMuZGF0YS5zZXQoX210eFRvLmRhdGEpO1xuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBgxpIuTWF0cml4M3gzKHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IGFzIGEgRmxvYXQzMkFycmF5XG4gICAgICovXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgLy8gdGhpcy5nZXRNdXRhdG9yKCk7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uc2VyaWFsaXplKCksXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuc2VyaWFsaXplKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xuICAgICAgICB0cmFuc2xhdGlvbjogYXdhaXQgdGhpcy50cmFuc2xhdGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi50cmFuc2xhdGlvbiksXG4gICAgICAgIHJvdGF0aW9uOiBfc2VyaWFsaXphdGlvbi5yb3RhdGlvbixcbiAgICAgICAgc2NhbGluZzogYXdhaXQgdGhpcy5zY2FsaW5nLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnNjYWxpbmcpXG4gICAgICB9O1xuICAgICAgdGhpcy5tdXRhdGUobXV0YXRvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcbiAgICAgIGlmICh0aGlzLm11dGF0b3IpXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0b3I7XG5cbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5nZXRNdXRhdG9yKCksXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuZ2V0TXV0YXRvcigpXG4gICAgICB9O1xuXG4gICAgICAvLyBjYWNoZSBtdXRhdG9yXG4gICAgICB0aGlzLm11dGF0b3IgPSBtdXRhdG9yO1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgbGV0IG9sZFRyYW5zbGF0aW9uOiBWZWN0b3IyID0gdGhpcy50cmFuc2xhdGlvbjtcbiAgICAgIGxldCBvbGRSb3RhdGlvbjogbnVtYmVyID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGxldCBvbGRTY2FsaW5nOiBWZWN0b3IyID0gdGhpcy5zY2FsaW5nO1xuICAgICAgbGV0IG5ld1RyYW5zbGF0aW9uOiBWZWN0b3IyID0gPFZlY3RvcjI+X211dGF0b3JbXCJ0cmFuc2xhdGlvblwiXTtcbiAgICAgIGxldCBuZXdSb3RhdGlvbjogbnVtYmVyID0gPG51bWJlcj5fbXV0YXRvcltcInJvdGF0aW9uXCJdO1xuICAgICAgbGV0IG5ld1NjYWxpbmc6IFZlY3RvcjIgPSA8VmVjdG9yMj5fbXV0YXRvcltcInNjYWxpbmdcIl07XG4gICAgICBsZXQgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb24gPSB7IHRyYW5zbGF0aW9uOiBvbGRUcmFuc2xhdGlvbiwgcm90YXRpb246IG9sZFJvdGF0aW9uLCBzY2FsaW5nOiBvbGRTY2FsaW5nIH07XG4gICAgICBpZiAobmV3VHJhbnNsYXRpb24pIHtcbiAgICAgICAgdmVjdG9ycy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IyKFxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueCA6IG9sZFRyYW5zbGF0aW9uLngsXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueSAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi55IDogb2xkVHJhbnNsYXRpb24ueVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2ZWN0b3JzLnJvdGF0aW9uID0gKG5ld1JvdGF0aW9uID09IHVuZGVmaW5lZCkgPyBvbGRSb3RhdGlvbiA6IG5ld1JvdGF0aW9uO1xuXG4gICAgICBpZiAobmV3U2NhbGluZykge1xuICAgICAgICB2ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcbiAgICAgICAgICBuZXdTY2FsaW5nLnggIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy54IDogb2xkU2NhbGluZy54LFxuICAgICAgICAgIG5ld1NjYWxpbmcueSAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnkgOiBvbGRTY2FsaW5nLnlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogcG9zc2libGUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHdoZW4gb25seSBvbmUgb3IgdHdvIGNvbXBvbmVudHMgY2hhbmdlLCB0aGVuIHVzZSBvbGQgbWF0cml4IGluc3RlYWQgb2YgSURFTlRJVFkgYW5kIHRyYW5zZm9ybSBieSBkaWZmZXJlbmNlcy9xdW90aWVudHNcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5JREVOVElUWSgpO1xuICAgICAgaWYgKHZlY3RvcnMudHJhbnNsYXRpb24pXG4gICAgICAgIG10eFJlc3VsdC50cmFuc2xhdGUodmVjdG9ycy50cmFuc2xhdGlvbik7XG4gICAgICBpZiAodmVjdG9ycy5yb3RhdGlvbikge1xuICAgICAgICBtdHhSZXN1bHQucm90YXRlKHZlY3RvcnMucm90YXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHZlY3RvcnMuc2NhbGluZylcbiAgICAgICAgbXR4UmVzdWx0LnNjYWxlKHZlY3RvcnMuc2NhbGluZyk7XG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xuXG4gICAgICB0aGlzLnZlY3RvcnMgPSB2ZWN0b3JzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikgdHlwZXMudHJhbnNsYXRpb24gPSBcIlZlY3RvcjJcIjtcbiAgICAgIGlmIChfbXV0YXRvci5yb3RhdGlvbiAhPSB1bmRlZmluZWQpIHR5cGVzLnJvdGF0aW9uID0gXCJudW1iZXJcIjtcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IyXCI7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cblxuICAgIHByaXZhdGUgcmVzZXRDYWNoZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMudmVjdG9ycyA9IHsgdHJhbnNsYXRpb246IG51bGwsIHJvdGF0aW9uOiBudWxsLCBzY2FsaW5nOiBudWxsIH07XG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvLyNlbmRyZWdpb25cblxufVxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYW5kIHByb3ZpZGVzIG9wZXJhdGlvbnMgZm9yIGl0LlxuICAgKiBgYGB0ZXh0XG4gICAqIFsgMCwgMSwgMiwgMyBdIOKGkCByb3cgdmVjdG9yIHhcbiAgICogWyA0LCA1LCA2LCA3IF0g4oaQIHJvdyB2ZWN0b3IgeVxuICAgKiBbIDgsIDksMTAsMTEgXSDihpAgcm93IHZlY3RvciB6XG4gICAqIFsxMiwxMywxNCwxNSBdIOKGkCB0cmFuc2xhdGlvblxuICAgKiAgICAgICAgICAgIOKGkSAgaG9tb2dlbmVvdXMgY29sdW1uXG4gICAqIGBgYFxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5IHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXG4gICAqL1xuICBleHBvcnQgY2xhc3MgTWF0cml4NHg0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgUmVjeWNhYmxlIHtcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpOyAvLyBUaGUgZGF0YSBvZiB0aGUgbWF0cml4LlxuICAgIHByaXZhdGUgbXV0YXRvcjogTXV0YXRvciA9IG51bGw7IC8vIHByZXBhcmVkIGZvciBvcHRpbWl6YXRpb24sIGtlZXAgbXV0YXRvciB0byByZWR1Y2UgcmVkdW5kYW50IGNhbGN1bGF0aW9uIGFuZCBmb3IgY29tcGFyaXNvbi4gU2V0IHRvIG51bGwgd2hlbiBkYXRhIGNoYW5nZXMhXG5cbiAgICByZWFkb25seSAjdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcbiAgICByZWFkb25seSAjc2NhbGluZzogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xuICAgIHJlYWRvbmx5ICNyb3RhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKCk7XG4gICAgcmVhZG9ubHkgI3F1YXRlcm5pb246IFF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uLklERU5USVRZKCk7XG5cbiAgICAjdHJhbnNsYXRpb25EaXJ0eTogYm9vbGVhbjtcbiAgICAjc2NhbGluZ0RpcnR5OiBib29sZWFuO1xuICAgICNyb3RhdGlvbkRpcnR5OiBib29sZWFuO1xuICAgICNxdWF0ZXJuaW9uRGlydHk6IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5yZWN5Y2xlKCk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFNUQVRJQ1NcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG5ldyBpZGVudGl0eSBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDR4NCB7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgbWF0cml4IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgQ09OU1RSVUNUSU9OKF90cmFuc2xhdGlvbj86IFZlY3RvcjMsIF9yb3RhdGlvbj86IFZlY3RvcjMgfCBRdWF0ZXJuaW9uLCBfc2NhbGluZz86IFZlY3RvcjMpOiBNYXRyaXg0eDQge1xuICAgICAgbGV0IHJlc3VsdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XG4gICAgICByZXN1bHQubXV0YXRlKHsgXCJ0cmFuc2xhdGlvblwiOiBfdHJhbnNsYXRpb24sIFwicm90YXRpb25cIjogX3JvdGF0aW9uLCBcInNjYWxpbmdcIjogX3NjYWxpbmcgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHR3byBwYXNzZWQgbWF0cmljZXMuXG4gICAgICogQHBhcmFtIF9tdHhMZWZ0IFRoZSBtYXRyaXggdG8gbXVsdGlwbHkuXG4gICAgICogQHBhcmFtIF9tdHhSaWdodCBUaGUgbWF0cml4IHRvIG11bHRpcGx5IGJ5LlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgTVVMVElQTElDQVRJT04oX210eExlZnQ6IE1hdHJpeDR4NCwgX210eFJpZ2h0OiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xuICAgICAgbGV0IGE6IEZsb2F0MzJBcnJheSA9IF9tdHhMZWZ0LmRhdGE7XG4gICAgICBsZXQgYjogRmxvYXQzMkFycmF5ID0gX210eFJpZ2h0LmRhdGE7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgICAgbGV0IGEwMDogbnVtYmVyID0gYVswICogNCArIDBdO1xuICAgICAgbGV0IGEwMTogbnVtYmVyID0gYVswICogNCArIDFdO1xuICAgICAgbGV0IGEwMjogbnVtYmVyID0gYVswICogNCArIDJdO1xuICAgICAgbGV0IGEwMzogbnVtYmVyID0gYVswICogNCArIDNdO1xuICAgICAgbGV0IGExMDogbnVtYmVyID0gYVsxICogNCArIDBdO1xuICAgICAgbGV0IGExMTogbnVtYmVyID0gYVsxICogNCArIDFdO1xuICAgICAgbGV0IGExMjogbnVtYmVyID0gYVsxICogNCArIDJdO1xuICAgICAgbGV0IGExMzogbnVtYmVyID0gYVsxICogNCArIDNdO1xuICAgICAgbGV0IGEyMDogbnVtYmVyID0gYVsyICogNCArIDBdO1xuICAgICAgbGV0IGEyMTogbnVtYmVyID0gYVsyICogNCArIDFdO1xuICAgICAgbGV0IGEyMjogbnVtYmVyID0gYVsyICogNCArIDJdO1xuICAgICAgbGV0IGEyMzogbnVtYmVyID0gYVsyICogNCArIDNdO1xuICAgICAgbGV0IGEzMDogbnVtYmVyID0gYVszICogNCArIDBdO1xuICAgICAgbGV0IGEzMTogbnVtYmVyID0gYVszICogNCArIDFdO1xuICAgICAgbGV0IGEzMjogbnVtYmVyID0gYVszICogNCArIDJdO1xuICAgICAgbGV0IGEzMzogbnVtYmVyID0gYVszICogNCArIDNdO1xuICAgICAgbGV0IGIwMDogbnVtYmVyID0gYlswICogNCArIDBdO1xuICAgICAgbGV0IGIwMTogbnVtYmVyID0gYlswICogNCArIDFdO1xuICAgICAgbGV0IGIwMjogbnVtYmVyID0gYlswICogNCArIDJdO1xuICAgICAgbGV0IGIwMzogbnVtYmVyID0gYlswICogNCArIDNdO1xuICAgICAgbGV0IGIxMDogbnVtYmVyID0gYlsxICogNCArIDBdO1xuICAgICAgbGV0IGIxMTogbnVtYmVyID0gYlsxICogNCArIDFdO1xuICAgICAgbGV0IGIxMjogbnVtYmVyID0gYlsxICogNCArIDJdO1xuICAgICAgbGV0IGIxMzogbnVtYmVyID0gYlsxICogNCArIDNdO1xuICAgICAgbGV0IGIyMDogbnVtYmVyID0gYlsyICogNCArIDBdO1xuICAgICAgbGV0IGIyMTogbnVtYmVyID0gYlsyICogNCArIDFdO1xuICAgICAgbGV0IGIyMjogbnVtYmVyID0gYlsyICogNCArIDJdO1xuICAgICAgbGV0IGIyMzogbnVtYmVyID0gYlsyICogNCArIDNdO1xuICAgICAgbGV0IGIzMDogbnVtYmVyID0gYlszICogNCArIDBdO1xuICAgICAgbGV0IGIzMTogbnVtYmVyID0gYlszICogNCArIDFdO1xuICAgICAgbGV0IGIzMjogbnVtYmVyID0gYlszICogNCArIDJdO1xuICAgICAgbGV0IGIzMzogbnVtYmVyID0gYlszICogNCArIDNdO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFxuICAgICAgICBbXG4gICAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwICsgYjAzICogYTMwLFxuICAgICAgICAgIGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMSArIGIwMyAqIGEzMSxcbiAgICAgICAgICBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzIsXG4gICAgICAgICAgYjAwICogYTAzICsgYjAxICogYTEzICsgYjAyICogYTIzICsgYjAzICogYTMzLFxuICAgICAgICAgIGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCArIGIxMyAqIGEzMCxcbiAgICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzEsXG4gICAgICAgICAgYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyICsgYjEzICogYTMyLFxuICAgICAgICAgIGIxMCAqIGEwMyArIGIxMSAqIGExMyArIGIxMiAqIGEyMyArIGIxMyAqIGEzMyxcbiAgICAgICAgICBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzAsXG4gICAgICAgICAgYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxICsgYjIzICogYTMxLFxuICAgICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMiArIGIyMyAqIGEzMixcbiAgICAgICAgICBiMjAgKiBhMDMgKyBiMjEgKiBhMTMgKyBiMjIgKiBhMjMgKyBiMjMgKiBhMzMsXG4gICAgICAgICAgYjMwICogYTAwICsgYjMxICogYTEwICsgYjMyICogYTIwICsgYjMzICogYTMwLFxuICAgICAgICAgIGIzMCAqIGEwMSArIGIzMSAqIGExMSArIGIzMiAqIGEyMSArIGIzMyAqIGEzMSxcbiAgICAgICAgICBiMzAgKiBhMDIgKyBiMzEgKiBhMTIgKyBiMzIgKiBhMjIgKyBiMzMgKiBhMzIsXG4gICAgICAgICAgYjMwICogYTAzICsgYjMxICogYTEzICsgYjMyICogYTIzICsgYjMzICogYTMzXG4gICAgICAgIF0pO1xuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgdHJhbnNwb3NlIG9mIGEgcGFzc2VkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TUE9TRShfbXR4OiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IF9tdHguZGF0YTtcbiAgICAgIGxldCByZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgICAgcmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgbVswXSwgbVs0XSwgbVs4XSwgbVsxMl0sXG4gICAgICAgIG1bMV0sIG1bNV0sIG1bOV0sIG1bMTNdLFxuICAgICAgICBtWzJdLCBtWzZdLCBtWzEwXSwgbVsxNF0sXG4gICAgICAgIG1bM10sIG1bN10sIG1bMTFdLCBtWzE1XVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBpbnZlcnNlIG9mIGEgcGFzc2VkIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gX210eCBUaGUgbWF0cml4IHRvIGNvbXB1dGUgdGhlIGludmVyc2Ugb2YuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBJTlZFUlNJT04oX210eDogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbXR4LmRhdGE7XG4gICAgICBsZXQgbTAwOiBudW1iZXIgPSBtWzAgKiA0ICsgMF07XG4gICAgICBsZXQgbTAxOiBudW1iZXIgPSBtWzAgKiA0ICsgMV07XG4gICAgICBsZXQgbTAyOiBudW1iZXIgPSBtWzAgKiA0ICsgMl07XG4gICAgICBsZXQgbTAzOiBudW1iZXIgPSBtWzAgKiA0ICsgM107XG4gICAgICBsZXQgbTEwOiBudW1iZXIgPSBtWzEgKiA0ICsgMF07XG4gICAgICBsZXQgbTExOiBudW1iZXIgPSBtWzEgKiA0ICsgMV07XG4gICAgICBsZXQgbTEyOiBudW1iZXIgPSBtWzEgKiA0ICsgMl07XG4gICAgICBsZXQgbTEzOiBudW1iZXIgPSBtWzEgKiA0ICsgM107XG4gICAgICBsZXQgbTIwOiBudW1iZXIgPSBtWzIgKiA0ICsgMF07XG4gICAgICBsZXQgbTIxOiBudW1iZXIgPSBtWzIgKiA0ICsgMV07XG4gICAgICBsZXQgbTIyOiBudW1iZXIgPSBtWzIgKiA0ICsgMl07XG4gICAgICBsZXQgbTIzOiBudW1iZXIgPSBtWzIgKiA0ICsgM107XG4gICAgICBsZXQgbTMwOiBudW1iZXIgPSBtWzMgKiA0ICsgMF07XG4gICAgICBsZXQgbTMxOiBudW1iZXIgPSBtWzMgKiA0ICsgMV07XG4gICAgICBsZXQgbTMyOiBudW1iZXIgPSBtWzMgKiA0ICsgMl07XG4gICAgICBsZXQgbTMzOiBudW1iZXIgPSBtWzMgKiA0ICsgM107XG4gICAgICBsZXQgdG1wMDogbnVtYmVyID0gbTIyICogbTMzO1xuICAgICAgbGV0IHRtcDE6IG51bWJlciA9IG0zMiAqIG0yMztcbiAgICAgIGxldCB0bXAyOiBudW1iZXIgPSBtMTIgKiBtMzM7XG4gICAgICBsZXQgdG1wMzogbnVtYmVyID0gbTMyICogbTEzO1xuICAgICAgbGV0IHRtcDQ6IG51bWJlciA9IG0xMiAqIG0yMztcbiAgICAgIGxldCB0bXA1OiBudW1iZXIgPSBtMjIgKiBtMTM7XG4gICAgICBsZXQgdG1wNjogbnVtYmVyID0gbTAyICogbTMzO1xuICAgICAgbGV0IHRtcDc6IG51bWJlciA9IG0zMiAqIG0wMztcbiAgICAgIGxldCB0bXA4OiBudW1iZXIgPSBtMDIgKiBtMjM7XG4gICAgICBsZXQgdG1wOTogbnVtYmVyID0gbTIyICogbTAzO1xuICAgICAgbGV0IHRtcDEwOiBudW1iZXIgPSBtMDIgKiBtMTM7XG4gICAgICBsZXQgdG1wMTE6IG51bWJlciA9IG0xMiAqIG0wMztcbiAgICAgIGxldCB0bXAxMjogbnVtYmVyID0gbTIwICogbTMxO1xuICAgICAgbGV0IHRtcDEzOiBudW1iZXIgPSBtMzAgKiBtMjE7XG4gICAgICBsZXQgdG1wMTQ6IG51bWJlciA9IG0xMCAqIG0zMTtcbiAgICAgIGxldCB0bXAxNTogbnVtYmVyID0gbTMwICogbTExO1xuICAgICAgbGV0IHRtcDE2OiBudW1iZXIgPSBtMTAgKiBtMjE7XG4gICAgICBsZXQgdG1wMTc6IG51bWJlciA9IG0yMCAqIG0xMTtcbiAgICAgIGxldCB0bXAxODogbnVtYmVyID0gbTAwICogbTMxO1xuICAgICAgbGV0IHRtcDE5OiBudW1iZXIgPSBtMzAgKiBtMDE7XG4gICAgICBsZXQgdG1wMjA6IG51bWJlciA9IG0wMCAqIG0yMTtcbiAgICAgIGxldCB0bXAyMTogbnVtYmVyID0gbTIwICogbTAxO1xuICAgICAgbGV0IHRtcDIyOiBudW1iZXIgPSBtMDAgKiBtMTE7XG4gICAgICBsZXQgdG1wMjM6IG51bWJlciA9IG0xMCAqIG0wMTtcblxuICAgICAgbGV0IHQwOiBudW1iZXIgPSAodG1wMCAqIG0xMSArIHRtcDMgKiBtMjEgKyB0bXA0ICogbTMxKSAtXG4gICAgICAgICh0bXAxICogbTExICsgdG1wMiAqIG0yMSArIHRtcDUgKiBtMzEpO1xuXG4gICAgICBsZXQgdDE6IG51bWJlciA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cbiAgICAgICAgKHRtcDAgKiBtMDEgKyB0bXA3ICogbTIxICsgdG1wOCAqIG0zMSk7XG4gICAgICBsZXQgdDI6IG51bWJlciA9ICh0bXAyICogbTAxICsgdG1wNyAqIG0xMSArIHRtcDEwICogbTMxKSAtXG4gICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcbiAgICAgIGxldCB0MzogbnVtYmVyID0gKHRtcDUgKiBtMDEgKyB0bXA4ICogbTExICsgdG1wMTEgKiBtMjEpIC1cbiAgICAgICAgKHRtcDQgKiBtMDEgKyB0bXA5ICogbTExICsgdG1wMTAgKiBtMjEpO1xuXG4gICAgICBsZXQgZDogbnVtYmVyID0gMS4wIC8gKG0wMCAqIHQwICsgbTEwICogdDEgKyBtMjAgKiB0MiArIG0zMCAqIHQzKTtcblxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXG4gICAgICAgIGQgKiB0MCwgLy8gWzBdXG4gICAgICAgIGQgKiB0MSwgLy8gWzFdXG4gICAgICAgIGQgKiB0MiwgLy8gWzJdXG4gICAgICAgIGQgKiB0MywgLy8gWzNdXG4gICAgICAgIGQgKiAoKHRtcDEgKiBtMTAgKyB0bXAyICogbTIwICsgdG1wNSAqIG0zMCkgLSAodG1wMCAqIG0xMCArIHRtcDMgKiBtMjAgKyB0bXA0ICogbTMwKSksICAgICAgICAvLyBbNF1cbiAgICAgICAgZCAqICgodG1wMCAqIG0wMCArIHRtcDcgKiBtMjAgKyB0bXA4ICogbTMwKSAtICh0bXAxICogbTAwICsgdG1wNiAqIG0yMCArIHRtcDkgKiBtMzApKSwgICAgICAgIC8vIFs1XVxuICAgICAgICBkICogKCh0bXAzICogbTAwICsgdG1wNiAqIG0xMCArIHRtcDExICogbTMwKSAtICh0bXAyICogbTAwICsgdG1wNyAqIG0xMCArIHRtcDEwICogbTMwKSksICAgICAgLy8gWzZdXG4gICAgICAgIGQgKiAoKHRtcDQgKiBtMDAgKyB0bXA5ICogbTEwICsgdG1wMTAgKiBtMjApIC0gKHRtcDUgKiBtMDAgKyB0bXA4ICogbTEwICsgdG1wMTEgKiBtMjApKSwgICAgICAvLyBbN11cbiAgICAgICAgZCAqICgodG1wMTIgKiBtMTMgKyB0bXAxNSAqIG0yMyArIHRtcDE2ICogbTMzKSAtICh0bXAxMyAqIG0xMyArIHRtcDE0ICogbTIzICsgdG1wMTcgKiBtMzMpKSwgIC8vIFs4XVxuICAgICAgICBkICogKCh0bXAxMyAqIG0wMyArIHRtcDE4ICogbTIzICsgdG1wMjEgKiBtMzMpIC0gKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpLCAgLy8gWzldXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTAzICsgdG1wMTkgKiBtMTMgKyB0bXAyMiAqIG0zMykgLSAodG1wMTUgKiBtMDMgKyB0bXAxOCAqIG0xMyArIHRtcDIzICogbTMzKSksICAvLyBbMTBdXG4gICAgICAgIGQgKiAoKHRtcDE3ICogbTAzICsgdG1wMjAgKiBtMTMgKyB0bXAyMyAqIG0yMykgLSAodG1wMTYgKiBtMDMgKyB0bXAyMSAqIG0xMyArIHRtcDIyICogbTIzKSksICAvLyBbMTFdXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTIyICsgdG1wMTcgKiBtMzIgKyB0bXAxMyAqIG0xMikgLSAodG1wMTYgKiBtMzIgKyB0bXAxMiAqIG0xMiArIHRtcDE1ICogbTIyKSksICAvLyBbMTJdXG4gICAgICAgIGQgKiAoKHRtcDIwICogbTMyICsgdG1wMTIgKiBtMDIgKyB0bXAxOSAqIG0yMikgLSAodG1wMTggKiBtMjIgKyB0bXAyMSAqIG0zMiArIHRtcDEzICogbTAyKSksICAvLyBbMTNdXG4gICAgICAgIGQgKiAoKHRtcDE4ICogbTEyICsgdG1wMjMgKiBtMzIgKyB0bXAxNSAqIG0wMikgLSAodG1wMjIgKiBtMzIgKyB0bXAxNCAqIG0wMiArIHRtcDE5ICogbTEyKSksICAvLyBbMTRdXG4gICAgICAgIGQgKiAoKHRtcDIyICogbTIyICsgdG1wMTYgKiBtMDIgKyB0bXAyMSAqIG0xMikgLSAodG1wMjAgKiBtMTIgKyB0bXAyMyAqIG0yMiArIHRtcDE3ICogbTAyKSkgIC8vIFsxNV1cbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiB0cmFuc2xhdGlvbiwgaXRzIHotYXhpcyBwb2ludGluZyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0LFxuICAgICAqIGFuZCBhIG1pbmltYWwgYW5nbGUgYmV0d2VlbiBpdHMgeS1heGlzIGFuZCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LCByZXNwZXRpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLlxuICAgICAqIFRoZSBwaXRjaCBtYXkgYmUgcmVzdHJpY3RlZCB0byB0aGUgdXAtdmVjdG9yIHRvIG9ubHkgY2FsY3VsYXRlIHlhdy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIExPT0tfQVQoX3RyYW5zbGF0aW9uOiBWZWN0b3IzLCBfdGFyZ2V0OiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoKSwgX3Jlc3RyaWN0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcbiAgICAgIGxldCB6QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCBfdHJhbnNsYXRpb24pO1xuICAgICAgekF4aXMubm9ybWFsaXplKCk7XG4gICAgICBsZXQgdmN0Q3Jvc3M6IFZlY3RvcjMgPSBWZWN0b3IzLkNST1NTKF91cCwgekF4aXMpO1xuICAgICAgaWYgKHZjdENyb3NzLm1hZ25pdHVkZVNxdWFyZWQgPT0gMCkgLy8gZXhwZXJpbWVudGFsIHdvcmthcm91bmQ6IGlmIHogYW5kIHVwIGlzIHBhcmFsbGVsLCB0aGVyZSBpcyBubyB1cCB0byByZW1haW4uLi5cbiAgICAgICAgdmN0Q3Jvc3MueCA9IDAuMDAxOyAvLyBzbyB0aWx0IGEgbGl0dGxlXG4gICAgICBsZXQgeEF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odmN0Q3Jvc3MpO1xuICAgICAgbGV0IHlBeGlzOiBWZWN0b3IzID0gX3Jlc3RyaWN0ID8gX3VwIDogVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoekF4aXMsIHhBeGlzKSk7XG4gICAgICB6QXhpcyA9IF9yZXN0cmljdCA/IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKHhBeGlzLCBfdXApKSA6IHpBeGlzO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFxuICAgICAgICBbXG4gICAgICAgICAgeEF4aXMueCwgeEF4aXMueSwgeEF4aXMueiwgMCxcbiAgICAgICAgICB5QXhpcy54LCB5QXhpcy55LCB5QXhpcy56LCAwLFxuICAgICAgICAgIHpBeGlzLngsIHpBeGlzLnksIHpBeGlzLnosIDAsXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLngsXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLnksXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLnosXG4gICAgICAgICAgMVxuICAgICAgICBdKTtcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIGl0cyB5LWF4aXMgbWF0Y2hpbmcgdGhlIGdpdmVuIHVwLXtAbGluayBWZWN0b3IzfVxuICAgICAqIGFuZCBpdHMgei1heGlzIGZhY2luZyB0b3dhcmRzIHRoZSBnaXZlbiB0YXJnZXQgYXQgYSBtaW5pbWFsIGFuZ2xlLCByZXNwZXRpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS5cbiAgICAgKi9cbiAgICAvLyBwdWJsaWMgc3RhdGljIFNIT1dfVE8oX3RyYW5zbGF0aW9uOiBWZWN0b3IzLCBfdGFyZ2V0OiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoKSk6IE1hdHJpeDR4NCB7XG4gICAgLy8gICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgIC8vICAgbGV0IHpBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIF90cmFuc2xhdGlvbik7XG4gICAgLy8gICB6QXhpcy5ub3JtYWxpemUoKTtcbiAgICAvLyAgIGxldCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKF91cCwgekF4aXMpKTtcbiAgICAvLyAgIC8vIGxldCB5QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKHpBeGlzLCB4QXhpcykpO1xuICAgIC8vICAgekF4aXMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh4QXhpcywgX3VwKSk7XG4gICAgLy8gICBtdHhSZXN1bHQuZGF0YS5zZXQoXG4gICAgLy8gICAgIFtcbiAgICAvLyAgICAgICB4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCAwLFxuICAgIC8vICAgICAgIF91cC54LCBfdXAueSwgX3VwLnosIDAsXG4gICAgLy8gICAgICAgekF4aXMueCwgekF4aXMueSwgekF4aXMueiwgMCxcbiAgICAvLyAgICAgICBfdHJhbnNsYXRpb24ueCxcbiAgICAvLyAgICAgICBfdHJhbnNsYXRpb24ueSxcbiAgICAvLyAgICAgICBfdHJhbnNsYXRpb24ueixcbiAgICAvLyAgICAgICAxXG4gICAgLy8gICAgIF0pO1xuICAgIC8vICAgcmV0dXJuIG10eFJlc3VsdDtcbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgdHJhbnNsYXRlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yM30uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0xBVElPTihfdHJhbnNsYXRlOiBWZWN0b3IzKTogTWF0cml4NHg0IHtcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xuICAgICAgICAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICBfdHJhbnNsYXRlLngsIF90cmFuc2xhdGUueSwgX3RyYW5zbGF0ZS56LCAxXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHgtYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9YKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcbiAgICAgIGxldCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXG4gICAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAgIDAsIGNvcywgc2luLCAwLFxuICAgICAgICAwLCAtc2luLCBjb3MsIDAsXG4gICAgICAgIDAsIDAsIDAsIDFcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeS1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1koX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcbiAgICAgIGxldCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXG4gICAgICAgIGNvcywgMCwgLXNpbiwgMCxcbiAgICAgICAgMCwgMSwgMCwgMCxcbiAgICAgICAgc2luLCAwLCBjb3MsIDAsXG4gICAgICAgIDAsIDAsIDAsIDFcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgei1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogQ2FsYy5kZWcycmFkO1xuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgbGV0IGNvczogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgY29zLCBzaW4sIDAsIDAsXG4gICAgICAgIC1zaW4sIGNvcywgMCwgMCxcbiAgICAgICAgMCwgMCwgMSwgMCxcbiAgICAgICAgMCwgMCwgMCwgMVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIHdoZW4gbXVsdGlwbGllZCBieSwgdXNpbmcgdGhlIHJvdGF0aW9uIGV1bGVyIGFuZ2xlcyBvciB1bml0IHF1YXRlcm5pb24gZ2l2ZW4uXG4gICAgICogUm90YXRpb24gb2NjdXJzIGFyb3VuZCB0aGUgYXhpcyBpbiB0aGUgb3JkZXIgWi1ZLVggLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX3JvdGF0aW9uOiBWZWN0b3IzIHwgUXVhdGVybmlvbik6IE1hdHJpeDR4NCB7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgICAgTWF0cml4NHg0LlNFVF9ST1RBVElPTihtdHhSZXN1bHQuZGF0YSwgX3JvdGF0aW9uKTtcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHNjYWxlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yM31cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFNDQUxJTkcoX3NjYWxhcjogVmVjdG9yMyk6IE1hdHJpeDR4NCB7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgX3NjYWxhci54LCAwLCAwLCAwLFxuICAgICAgICAwLCBfc2NhbGFyLnksIDAsIDAsXG4gICAgICAgIDAsIDAsIF9zY2FsYXIueiwgMCxcbiAgICAgICAgMCwgMCwgMCwgMVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gbWF0cml4IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBiYXNlLlxuICAgICAqIElmIGtub3duLCBwYXNzIHRoZSBpbnZlcnNlIG9mIHRoZSBiYXNlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IGNhbGN1bGF0aW9uIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgUkVMQVRJVkUoX210eDogTWF0cml4NHg0LCBfbXR4QmFzZTogTWF0cml4NHg0LCBfbXR4SW52ZXJzZT86IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XG4gICAgICBpZiAoX210eEludmVyc2UpXG4gICAgICAgIHJldHVybiBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX210eEludmVyc2UsIF9tdHgpO1xuXG4gICAgICBsZXQgbXR4SW52ZXJzZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0lPTihfbXR4QmFzZSk7XG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04obXR4SW52ZXJzZSwgX210eCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhJbnZlcnNlKTtcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIFBST0pFQ1RJT05TXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIHBlcnNwZWN0aXZlIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxuICAgICAqIEBwYXJhbSBfYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gYmV0d2VlbiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHByb2plY3Rpb25zcGFjZS4oRGVmYXVsdCA9IGNhbnZhcy5jbGllbnRXaWR0aCAvIGNhbnZhcy5DbGllbnRIZWlnaHQpXG4gICAgICogQHBhcmFtIF9maWVsZE9mVmlld0luRGVncmVlcyBUaGUgZmllbGQgb2YgdmlldyBpbiBEZWdyZWVzLiAoRGVmYXVsdCA9IDQ1KVxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgbmVhciBjbGlwc3BhY2UgYm9yZGVyIG9uIHRoZSB6LWF4aXMuXG4gICAgICogQHBhcmFtIF9mYXIgVGhlIGZhciBjbGlwc3BhY2UgYm9yZGVyIG9uIHRoZSB6LWF4aXMuXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT05fQ0VOVFJBTChfYXNwZWN0OiBudW1iZXIsIF9maWVsZE9mVmlld0luRGVncmVlczogbnVtYmVyLCBfbmVhcjogbnVtYmVyLCBfZmFyOiBudW1iZXIsIF9kaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcpOiBNYXRyaXg0eDQge1xuICAgICAgLy9UT0RPOiBjYW1lcmEgbG9va3MgZG93biBuZWdhdGl2ZSB6LWRpcmVjdGlvbiwgc2hvdWxkIGJlIHBvc2l0aXZlXG4gICAgICBsZXQgZmllbGRPZlZpZXdJblJhZGlhbnM6IG51bWJlciA9IF9maWVsZE9mVmlld0luRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcbiAgICAgIGxldCBmOiBudW1iZXIgPSBNYXRoLnRhbigwLjUgKiAoTWF0aC5QSSAtIGZpZWxkT2ZWaWV3SW5SYWRpYW5zKSk7XG4gICAgICBsZXQgcmFuZ2VJbnY6IG51bWJlciA9IDEuMCAvIChfbmVhciAtIF9mYXIpO1xuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXG4gICAgICAgIGYsIDAsIDAsIDAsXG4gICAgICAgIDAsIGYsIDAsIDAsXG4gICAgICAgIDAsIDAsIChfbmVhciArIF9mYXIpICogcmFuZ2VJbnYsIC0xLFxuICAgICAgICAwLCAwLCBfbmVhciAqIF9mYXIgKiByYW5nZUludiAqIDIsIDBcbiAgICAgIF0pO1xuXG4gICAgICBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMKSB7XG4gICAgICAgIF9hc3BlY3QgPSBNYXRoLnNxcnQoX2FzcGVjdCk7XG4gICAgICAgIG10eFJlc3VsdC5kYXRhWzBdID0gZiAvIF9hc3BlY3Q7XG4gICAgICAgIG10eFJlc3VsdC5kYXRhWzVdID0gZiAqIF9hc3BlY3Q7XG4gICAgICB9IGVsc2UgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5WRVJUSUNBTClcbiAgICAgICAgbXR4UmVzdWx0LmRhdGFbMF0gPSBmIC8gX2FzcGVjdDtcbiAgICAgIGVsc2UgLy9GT1ZfRElSRUNUSU9OLkhPUklaT05UQUxcbiAgICAgICAgbXR4UmVzdWx0LmRhdGFbNV0gPSBmICogX2FzcGVjdDtcblxuICAgICAgLy8gSEFDSzogbWF0cml4IHNob3VsZCBsb29rIGluIHBvc2l0aXZlIHotZGlyZWN0aW9uLCBwcmVmZXJhYmx5IHRoZSBtYXRyaXggc2hvdWxkIGJlIGNhbGN1bGF0ZWQgbGlrZSB0aGF0IHJpZ2h0IGF3YXlcbiAgICAgIG10eFJlc3VsdC5yb3RhdGVZKDE4MCk7XG5cbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxuICAgICAqIEBwYXJhbSBfbGVmdCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbGVmdCBib3JkZXIuXG4gICAgICogQHBhcmFtIF9yaWdodCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgcmlnaHQgYm9yZGVyLlxuICAgICAqIEBwYXJhbSBfYm90dG9tIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBib3R0b20gYm9yZGVyLlxuICAgICAqIEBwYXJhbSBfdG9wIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyB0b3AgYm9yZGVyLlxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbmVhciBib3JkZXIuXG4gICAgICogQHBhcmFtIF9mYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGZhciBib3JkZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT05fT1JUSE9HUkFQSElDKF9sZWZ0OiBudW1iZXIsIF9yaWdodDogbnVtYmVyLCBfYm90dG9tOiBudW1iZXIsIF90b3A6IG51bWJlciwgX25lYXI6IG51bWJlciA9IC00MDAsIF9mYXI6IG51bWJlciA9IDQwMCk6IE1hdHJpeDR4NCB7XG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcbiAgICAgICAgMiAvIChfcmlnaHQgLSBfbGVmdCksIDAsIDAsIDAsXG4gICAgICAgIDAsIC0yIC8gKF90b3AgLSBfYm90dG9tKSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMiAvIChfZmFyIC0gX25lYXIpLCAwLFxuICAgICAgICAoX2xlZnQgKyBfcmlnaHQpIC8gKF9sZWZ0IC0gX3JpZ2h0KSxcbiAgICAgICAgKF9ib3R0b20gKyBfdG9wKSAvIChfYm90dG9tIC0gX3RvcCksXG4gICAgICAgIChfbmVhciArIF9mYXIpIC8gKF9uZWFyIC0gX2ZhciksXG4gICAgICAgIDFcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJvdGF0aW9uIHBhcnQgb2YgdGhlIGdpdmVuIG1hdHJpeGVzIGRhdGEgYXJyYXkgdG8gdGhlIGdpdmVuIHJvdGF0aW9uLlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIFNFVF9ST1RBVElPTihfbTogRmxvYXQzMkFycmF5LCBfcm90YXRpb246IFZlY3RvcjMgfCBRdWF0ZXJuaW9uKTogdm9pZCB7XG4gICAgICBpZiAoX3JvdGF0aW9uIGluc3RhbmNlb2YgVmVjdG9yMykge1xuICAgICAgICBjb25zdCBhbmdsZXNJblJhZGlhbnM6IFZlY3RvcjMgPSBWZWN0b3IzLlNDQUxFKF9yb3RhdGlvbiwgQ2FsYy5kZWcycmFkKTtcbiAgICAgICAgY29uc3Qgc2luWDogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVzSW5SYWRpYW5zLngpO1xuICAgICAgICBjb25zdCBjb3NYOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZXNJblJhZGlhbnMueCk7XG4gICAgICAgIGNvbnN0IHNpblk6IG51bWJlciA9IE1hdGguc2luKGFuZ2xlc0luUmFkaWFucy55KTtcbiAgICAgICAgY29uc3QgY29zWTogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVzSW5SYWRpYW5zLnkpO1xuICAgICAgICBjb25zdCBzaW5aOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZXNJblJhZGlhbnMueik7XG4gICAgICAgIGNvbnN0IGNvc1o6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlc0luUmFkaWFucy56KTtcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUoYW5nbGVzSW5SYWRpYW5zKTtcblxuICAgICAgICBfbVswXSA9IGNvc1ogKiBjb3NZOyAvKiovICAgICAgICAgICAgICAgICBfbVsxXSA9IHNpblogKiBjb3NZOyAvKiovICAgICAgICAgICAgICAgICBfbVsyXSA9IC1zaW5ZO1xuICAgICAgICBfbVs0XSA9IGNvc1ogKiBzaW5ZICogc2luWCAtIHNpblogKiBjb3NYOyBfbVs1XSA9IHNpblogKiBzaW5ZICogc2luWCArIGNvc1ogKiBjb3NYOyBfbVs2XSA9IGNvc1kgKiBzaW5YO1xuICAgICAgICBfbVs4XSA9IGNvc1ogKiBzaW5ZICogY29zWCArIHNpblogKiBzaW5YOyBfbVs5XSA9IHNpblogKiBzaW5ZICogY29zWCAtIGNvc1ogKiBzaW5YOyBfbVsxMF0gPSBjb3NZICogY29zWDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uTm9ybWFsaXplZDogUXVhdGVybmlvbiA9IFF1YXRlcm5pb24uTk9STUFMSVpBVElPTihfcm90YXRpb24pO1xuICAgICAgICBjb25zdCB4OiBudW1iZXIgPSByb3RhdGlvbk5vcm1hbGl6ZWQueCwgeTogbnVtYmVyID0gcm90YXRpb25Ob3JtYWxpemVkLnksIHo6IG51bWJlciA9IHJvdGF0aW9uTm9ybWFsaXplZC56LCB3OiBudW1iZXIgPSByb3RhdGlvbk5vcm1hbGl6ZWQudztcbiAgICAgICAgY29uc3QgeHg6IG51bWJlciA9IHggKiB4LCB4eTogbnVtYmVyID0geCAqIHksIHh6OiBudW1iZXIgPSB4ICogeiwgeHc6IG51bWJlciA9IHggKiB3O1xuICAgICAgICBjb25zdCB5eTogbnVtYmVyID0geSAqIHksIHl6OiBudW1iZXIgPSB5ICogeiwgeXc6IG51bWJlciA9IHkgKiB3O1xuICAgICAgICBjb25zdCB6ejogbnVtYmVyID0geiAqIHosIHp3OiBudW1iZXIgPSB6ICogdztcbiAgICAgICAgY29uc3Qgd3c6IG51bWJlciA9IHcgKiB3O1xuXG4gICAgICAgIF9tWzBdID0gd3cgKyB4eCAtIHl5IC0geno7IF9tWzFdID0gMiAqICh4eSArIHp3KTsvKiovIF9tWzJdID0gMiAqICh4eiAtIHl3KTtcbiAgICAgICAgX21bNF0gPSAyICogKHh5IC0gencpOy8qKi8gX21bNV0gPSB3dyAtIHh4ICsgeXkgLSB6ejsgX21bNl0gPSAyICogKHl6ICsgeHcpO1xuICAgICAgICBfbVs4XSA9IDIgKiAoeHogKyB5dyk7LyoqLyBfbVs5XSA9IDIgKiAoeXogLSB4dyk7LyoqLyBfbVsxMF0gPSB3dyAtIHh4IC0geXkgKyB6ejtcblxuICAgICAgICAvLyBfbVswXSA9IDEgLSAyICogKHl5ICsgenopOyBfbVsxXSA9IDIgKiAoeHkgKyB6dyk7LyoqLyBfbVsyXSA9IDIgKiAoeHogLSB5dyk7XG4gICAgICAgIC8vIF9tWzRdID0gMiAqICh4eSAtIHp3KTsvKiovIF9tWzVdID0gMSAtIDIgKiAoeHggKyB6eik7IF9tWzZdID0gMiAqICh5eiArIHh3KTtcbiAgICAgICAgLy8gX21bOF0gPSAyICogKHh6ICsgeXcpOy8qKi8gX21bOV0gPSAyICogKHl6IC0geHcpOy8qKi8gX21bMTBdID0gMSAtIDIgKiAoeHggKyB5eSk7XG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uTm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uICBBY2Nlc3NvcnNcbiAgICAvKiogXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNsYXRpb24ge0BsaW5rIFZlY3RvcjN9LiAgXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSBhbmQgcmVhZG9ubHksIHNpbmNlIHRoZSB2ZWN0b3IgaXMgZ29pbmcgdG8gYmUgcmV1c2VkIGludGVybmFsbHkuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXggaWdub3JpbmcgaXRzIHJvdGF0aW9uIGFuZCBzY2FsaW5nXG4gICAgICovXG4gICAgcHVibGljIGdldCB0cmFuc2xhdGlvbigpOiBWZWN0b3IzIHtcbiAgICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvbkRpcnR5KSB7XG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uLnNldCh0aGlzLmRhdGFbMTJdLCB0aGlzLmRhdGFbMTNdLCB0aGlzLmRhdGFbMTRdKTtcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zbGF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMykge1xuICAgICAgdGhpcy5tdXRhdGUoeyBcInRyYW5zbGF0aW9uXCI6IF90cmFuc2xhdGlvbiB9KTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm90YXRpb24ge0BsaW5rIFZlY3RvcjN9LiAgXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSBhbmQgcmVhZG9ubHksIHNpbmNlIHRoZSB2ZWN0b3IgaXMgZ29pbmcgdG8gYmUgcmV1c2VkIGludGVybmFsbHkuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IFZlY3RvcjMge1xuICAgICAgaWYgKHRoaXMuI3JvdGF0aW9uRGlydHkpIHtcbiAgICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLnNjYWxpbmc7XG5cbiAgICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XG4gICAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xuICAgICAgICBsZXQgczI6IG51bWJlciA9IHRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueDtcbiAgICAgICAgbGV0IHM2OiBudW1iZXIgPSB0aGlzLmRhdGFbNl0gLyBzY2FsaW5nLnk7XG4gICAgICAgIGxldCBzMTA6IG51bWJlciA9IHRoaXMuZGF0YVsxMF0gLyBzY2FsaW5nLno7XG5cbiAgICAgICAgbGV0IHN5OiBudW1iZXIgPSBNYXRoLmh5cG90KHMwLCBzMSk7IC8vIHByb2JhYmx5IDIuIHBhcmFtIHNob3VsZCBiZSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnlcblxuICAgICAgICBsZXQgc2luZ3VsYXI6IGJvb2xlYW4gPSBzeSA8IDFlLTY7IC8vIElmXG5cbiAgICAgICAgbGV0IHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHoxOiBudW1iZXI7XG4gICAgICAgIGxldCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCB6MjogbnVtYmVyO1xuXG4gICAgICAgIGlmICghc2luZ3VsYXIpIHtcbiAgICAgICAgICB4MSA9IE1hdGguYXRhbjIoczYsIHMxMCk7XG4gICAgICAgICAgeTEgPSBNYXRoLmF0YW4yKC1zMiwgc3kpO1xuICAgICAgICAgIHoxID0gTWF0aC5hdGFuMihzMSwgczApO1xuXG4gICAgICAgICAgeDIgPSBNYXRoLmF0YW4yKC1zNiwgLXMxMCk7XG4gICAgICAgICAgeTIgPSBNYXRoLmF0YW4yKC1zMiwgLXN5KTtcbiAgICAgICAgICB6MiA9IE1hdGguYXRhbjIoLXMxLCAtczApO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHgyKSArIE1hdGguYWJzKHkyKSArIE1hdGguYWJzKHoyKSA8IE1hdGguYWJzKHgxKSArIE1hdGguYWJzKHkxKSArIE1hdGguYWJzKHoxKSkge1xuICAgICAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgICAgIHkxID0geTI7XG4gICAgICAgICAgICB6MSA9IHoyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzVdIC8gc2NhbGluZy55KTtcbiAgICAgICAgICB5MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVsyXSAvIHNjYWxpbmcueCwgc3kpO1xuICAgICAgICAgIHoxID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI3JvdGF0aW9uLnNldCh4MSwgeTEsIHoxKTtcbiAgICAgICAgdGhpcy4jcm90YXRpb24uc2NhbGUoQ2FsYy5yYWQyZGVnKTtcbiAgICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy4jcm90YXRpb247XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBRdWF0ZXJuaW9uIHwgVmVjdG9yMykge1xuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2NhbGluZyB7QGxpbmsgVmVjdG9yM30uICBcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgaW50ZXJuYWxseS4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2NhbGluZygpOiBWZWN0b3IzIHtcbiAgICAgIGlmICh0aGlzLiNzY2FsaW5nRGlydHkpIHtcbiAgICAgICAgdGhpcy4jc2NhbGluZy5zZXQoXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKSwgLy8qICh0aGlzLmRhdGFbMF0gPCAwID8gLTEgOiAxKSxcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl0pLCAvLyogKHRoaXMuZGF0YVs1XSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0pIC8vICogKHRoaXMuZGF0YVsxMF0gPCAwID8gLTEgOiAxKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLiNzY2FsaW5nRGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNzY2FsaW5nO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNjYWxpbmcoX3NjYWxpbmc6IFZlY3RvcjMpIHtcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJzY2FsaW5nXCI6IF9zY2FsaW5nIH0pO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdW5pdCBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXguXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSBhbmQgcmVhZG9ubHksIHNpbmNlIHRoZSBxdWF0ZXJuaW9uIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBpbnRlcm5hbGx5LiBDcmVhdGUgYSBjbG9uZSB0byBrZWVwIGxvbmdlciBhbmQgbWFuaXB1bGF0ZS4gXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XG4gICAgICovXG4gICAgcHVibGljIGdldCBxdWF0ZXJuaW9uKCk6IFF1YXRlcm5pb24ge1xuICAgICAgaWYgKHRoaXMuI3F1YXRlcm5pb25EaXJ0eSkge1xuICAgICAgICB0aGlzLiNxdWF0ZXJuaW9uLmV1bGVyQW5nbGVzID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy4jcXVhdGVybmlvbkRpcnR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiNxdWF0ZXJuaW9uO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHF1YXRlcm5pb24oX3F1YXRlcm5pb246IFF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJyb3RhdGlvblwiOiBfcXVhdGVybmlvbiB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoaXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IE1hdHJpeDR4NCB7XG4gICAgICBsZXQgbXR4Q2xvbmU6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgICAgbXR4Q2xvbmUuc2V0KHRoaXMpO1xuICAgICAgcmV0dXJuIG10eENsb25lO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIHRoZSBpZGVudGl0eS1tYXRyaXggYW5kIGNsZWFycyBjYWNoZS4gVXNlZCBieSB0aGUgcmVjeWNsZXIgdG8gcmVzZXQuXG4gICAgICovXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XG4gICAgICB0aGlzLmRhdGEuc2V0KFtcbiAgICAgICAgMSwgMCwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMSwgMCxcbiAgICAgICAgMCwgMCwgMCwgMVxuICAgICAgXSk7XG4gICAgICAvLyBUT0RPOiB0aGluayBhYm91dCB0aGlzIGNoYW5nZTogdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nIG9mIGEgcmVjeWNsZWQgbWF0cml4IGFyZSBhY3R1YWxseSBcbiAgICAgIC8vIGtub3duIGFuZCBuZWVkIG5vdCBiZSBsYXppbHkgcmVjYWxjdWxhdGVkLiBCdXQgbW9zdCBtYXRyaXggbWFuaXB1bGF0aW9uIGxvZ2ljIGFzc3VtZXMgdGhhdCBhIHJlY3ljbGVkIG1hdHJpeFxuICAgICAgLy8gd2lsbCBkbyB0aGlzIGxhemlseS4gU28sIGZvciBub3csIHdlIHJlc2V0IHRoZSBjYWNoZSBoZXJlLCBidXQgbWF5YmUgd2Ugc2hvdWxkIHJhdGhlciByZXNldCB0aGUgY2FjaGVcbiAgICAgIC8vIGV2ZXJ5dGltZSBhIG1hdHJpeCBpcyBjaGFuZ2VkIGkuZS4gdXNlIC5zZXQoKSBpbnN0ZWFkIG9mIC5kYXRhLnNldCgpIHdoZW4gY2FjaGUgc2hvdWxkIGJlIHJlc2V0LlxuICAgICAgLy8gdGhpcy4jdHJhbnNsYXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgLy8gdGhpcy4jcm90YXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgLy8gdGhpcy4jc2NhbGluZy5zZXQoMSwgMSwgMSk7XG4gICAgICAvLyB0aGlzLiNxdWF0ZXJuaW9uLnNldCgwLCAwLCAwLCAxKTtcbiAgICAgIC8vIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSBmYWxzZTtcbiAgICAgIC8vIHRoaXMuI3JvdGF0aW9uRGlydHkgPSBmYWxzZTtcbiAgICAgIC8vIHRoaXMuI3NjYWxpbmdEaXJ0eSA9IGZhbHNlO1xuICAgICAgLy8gdGhpcy4jcXVhdGVybmlvbkRpcnR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG1hdHJpeCB0byB0aGUgaWRlbnRpdHktbWF0cml4IGFuZCBjbGVhcnMgY2FjaGUuXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgICAgdGhpcy5yZWN5Y2xlKCk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFJvdGF0aW9uXG4gICAgLyoqXG4gICAgICogUm90YXRlIHRoaXMgbWF0cml4IGJ5IGdpdmVuIHtAbGluayBWZWN0b3IzfSBpbiB0aGUgb3JkZXIgWiwgWSwgWC4gUmlnaHQgaGFuZCByb3RhdGlvbiBpcyB1c2VkLCB0aHVtYiBwb2ludHMgaW4gYXhpcyBkaXJlY3Rpb24sIGZpbmdlcnMgY3VybGluZyBpbmRpY2F0ZSByb3RhdGlvblxuICAgICAqIFRoZSByb3RhdGlvbiBpcyBhcHBlbmRlZCB0byBhbHJlYWR5IGFwcGxpZWQgdHJhbnNmb3JtcywgdGh1cyBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0LiBTZXQgX2Zyb21MZWZ0IHRvIHRydWUgdG8gc3dpdGNoIGFuZCBwdXQgaXQgaW4gZnJvbnQuXG4gICAgICovXG4gICAgcHVibGljIHJvdGF0ZShfYnk6IFZlY3RvcjMsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAvLyB0aGlzLnJvdGF0ZVooX2J5LnosIF9mcm9tTGVmdCk7XG4gICAgICAvLyB0aGlzLnJvdGF0ZVkoX2J5LnksIF9mcm9tTGVmdCk7XG4gICAgICAvLyB0aGlzLnJvdGF0ZVgoX2J5LngsIF9mcm9tTGVmdCk7XG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTihfYnkpO1xuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc3Bvc2UgdGhpcyBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhbnNwb3NlKCk6IE1hdHJpeDR4NCB7XG4gICAgICBsZXQgbWF0cml4OiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XG4gICAgICB0aGlzLmRhdGEuc2V0KFtcbiAgICAgICAgbWF0cml4WzBdLCBtYXRyaXhbNF0sIG1hdHJpeFs4XSwgbWF0cml4WzEyXSxcbiAgICAgICAgbWF0cml4WzFdLCBtYXRyaXhbNV0sIG1hdHJpeFs5XSwgbWF0cml4WzEzXSxcbiAgICAgICAgbWF0cml4WzJdLCBtYXRyaXhbNl0sIG1hdHJpeFsxMF0sIG1hdHJpeFsxNF0sXG4gICAgICAgIG1hdHJpeFszXSwgbWF0cml4WzddLCBtYXRyaXhbMTFdLCBtYXRyaXhbMTVdXG4gICAgICBdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmVydCB0aGlzIG1hdHJpeFxuICAgICAqL1xuICAgIHB1YmxpYyBpbnZlcnNlKCk6IE1hdHJpeDR4NCB7XG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gdGhpcy5kYXRhO1xuICAgICAgbGV0IG0wMDogbnVtYmVyID0gbVswICogNCArIDBdO1xuICAgICAgbGV0IG0wMTogbnVtYmVyID0gbVswICogNCArIDFdO1xuICAgICAgbGV0IG0wMjogbnVtYmVyID0gbVswICogNCArIDJdO1xuICAgICAgbGV0IG0wMzogbnVtYmVyID0gbVswICogNCArIDNdO1xuICAgICAgbGV0IG0xMDogbnVtYmVyID0gbVsxICogNCArIDBdO1xuICAgICAgbGV0IG0xMTogbnVtYmVyID0gbVsxICogNCArIDFdO1xuICAgICAgbGV0IG0xMjogbnVtYmVyID0gbVsxICogNCArIDJdO1xuICAgICAgbGV0IG0xMzogbnVtYmVyID0gbVsxICogNCArIDNdO1xuICAgICAgbGV0IG0yMDogbnVtYmVyID0gbVsyICogNCArIDBdO1xuICAgICAgbGV0IG0yMTogbnVtYmVyID0gbVsyICogNCArIDFdO1xuICAgICAgbGV0IG0yMjogbnVtYmVyID0gbVsyICogNCArIDJdO1xuICAgICAgbGV0IG0yMzogbnVtYmVyID0gbVsyICogNCArIDNdO1xuICAgICAgbGV0IG0zMDogbnVtYmVyID0gbVszICogNCArIDBdO1xuICAgICAgbGV0IG0zMTogbnVtYmVyID0gbVszICogNCArIDFdO1xuICAgICAgbGV0IG0zMjogbnVtYmVyID0gbVszICogNCArIDJdO1xuICAgICAgbGV0IG0zMzogbnVtYmVyID0gbVszICogNCArIDNdO1xuICAgICAgbGV0IHRtcDA6IG51bWJlciA9IG0yMiAqIG0zMztcbiAgICAgIGxldCB0bXAxOiBudW1iZXIgPSBtMzIgKiBtMjM7XG4gICAgICBsZXQgdG1wMjogbnVtYmVyID0gbTEyICogbTMzO1xuICAgICAgbGV0IHRtcDM6IG51bWJlciA9IG0zMiAqIG0xMztcbiAgICAgIGxldCB0bXA0OiBudW1iZXIgPSBtMTIgKiBtMjM7XG4gICAgICBsZXQgdG1wNTogbnVtYmVyID0gbTIyICogbTEzO1xuICAgICAgbGV0IHRtcDY6IG51bWJlciA9IG0wMiAqIG0zMztcbiAgICAgIGxldCB0bXA3OiBudW1iZXIgPSBtMzIgKiBtMDM7XG4gICAgICBsZXQgdG1wODogbnVtYmVyID0gbTAyICogbTIzO1xuICAgICAgbGV0IHRtcDk6IG51bWJlciA9IG0yMiAqIG0wMztcbiAgICAgIGxldCB0bXAxMDogbnVtYmVyID0gbTAyICogbTEzO1xuICAgICAgbGV0IHRtcDExOiBudW1iZXIgPSBtMTIgKiBtMDM7XG4gICAgICBsZXQgdG1wMTI6IG51bWJlciA9IG0yMCAqIG0zMTtcbiAgICAgIGxldCB0bXAxMzogbnVtYmVyID0gbTMwICogbTIxO1xuICAgICAgbGV0IHRtcDE0OiBudW1iZXIgPSBtMTAgKiBtMzE7XG4gICAgICBsZXQgdG1wMTU6IG51bWJlciA9IG0zMCAqIG0xMTtcbiAgICAgIGxldCB0bXAxNjogbnVtYmVyID0gbTEwICogbTIxO1xuICAgICAgbGV0IHRtcDE3OiBudW1iZXIgPSBtMjAgKiBtMTE7XG4gICAgICBsZXQgdG1wMTg6IG51bWJlciA9IG0wMCAqIG0zMTtcbiAgICAgIGxldCB0bXAxOTogbnVtYmVyID0gbTMwICogbTAxO1xuICAgICAgbGV0IHRtcDIwOiBudW1iZXIgPSBtMDAgKiBtMjE7XG4gICAgICBsZXQgdG1wMjE6IG51bWJlciA9IG0yMCAqIG0wMTtcbiAgICAgIGxldCB0bXAyMjogbnVtYmVyID0gbTAwICogbTExO1xuICAgICAgbGV0IHRtcDIzOiBudW1iZXIgPSBtMTAgKiBtMDE7XG5cbiAgICAgIGxldCB0MDogbnVtYmVyID0gKHRtcDAgKiBtMTEgKyB0bXAzICogbTIxICsgdG1wNCAqIG0zMSkgLVxuICAgICAgICAodG1wMSAqIG0xMSArIHRtcDIgKiBtMjEgKyB0bXA1ICogbTMxKTtcblxuICAgICAgbGV0IHQxOiBudW1iZXIgPSAodG1wMSAqIG0wMSArIHRtcDYgKiBtMjEgKyB0bXA5ICogbTMxKSAtXG4gICAgICAgICh0bXAwICogbTAxICsgdG1wNyAqIG0yMSArIHRtcDggKiBtMzEpO1xuICAgICAgbGV0IHQyOiBudW1iZXIgPSAodG1wMiAqIG0wMSArIHRtcDcgKiBtMTEgKyB0bXAxMCAqIG0zMSkgLVxuICAgICAgICAodG1wMyAqIG0wMSArIHRtcDYgKiBtMTEgKyB0bXAxMSAqIG0zMSk7XG4gICAgICBsZXQgdDM6IG51bWJlciA9ICh0bXA1ICogbTAxICsgdG1wOCAqIG0xMSArIHRtcDExICogbTIxKSAtXG4gICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcblxuICAgICAgbGV0IGQ6IG51bWJlciA9IDEuMCAvIChtMDAgKiB0MCArIG0xMCAqIHQxICsgbTIwICogdDIgKyBtMzAgKiB0Myk7XG5cbiAgICAgIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XG4gICAgICBtYXRyaXguZGF0YS5zZXQoW1xuICAgICAgICBkICogdDAsIC8vIFswXVxuICAgICAgICBkICogdDEsIC8vIFsxXVxuICAgICAgICBkICogdDIsIC8vIFsyXVxuICAgICAgICBkICogdDMsIC8vIFszXVxuICAgICAgICBkICogKCh0bXAxICogbTEwICsgdG1wMiAqIG0yMCArIHRtcDUgKiBtMzApIC0gKHRtcDAgKiBtMTAgKyB0bXAzICogbTIwICsgdG1wNCAqIG0zMCkpLCAgICAgICAgLy8gWzRdXG4gICAgICAgIGQgKiAoKHRtcDAgKiBtMDAgKyB0bXA3ICogbTIwICsgdG1wOCAqIG0zMCkgLSAodG1wMSAqIG0wMCArIHRtcDYgKiBtMjAgKyB0bXA5ICogbTMwKSksICAgICAgICAvLyBbNV1cbiAgICAgICAgZCAqICgodG1wMyAqIG0wMCArIHRtcDYgKiBtMTAgKyB0bXAxMSAqIG0zMCkgLSAodG1wMiAqIG0wMCArIHRtcDcgKiBtMTAgKyB0bXAxMCAqIG0zMCkpLCAgICAgIC8vIFs2XVxuICAgICAgICBkICogKCh0bXA0ICogbTAwICsgdG1wOSAqIG0xMCArIHRtcDEwICogbTIwKSAtICh0bXA1ICogbTAwICsgdG1wOCAqIG0xMCArIHRtcDExICogbTIwKSksICAgICAgLy8gWzddXG4gICAgICAgIGQgKiAoKHRtcDEyICogbTEzICsgdG1wMTUgKiBtMjMgKyB0bXAxNiAqIG0zMykgLSAodG1wMTMgKiBtMTMgKyB0bXAxNCAqIG0yMyArIHRtcDE3ICogbTMzKSksICAvLyBbOF1cbiAgICAgICAgZCAqICgodG1wMTMgKiBtMDMgKyB0bXAxOCAqIG0yMyArIHRtcDIxICogbTMzKSAtICh0bXAxMiAqIG0wMyArIHRtcDE5ICogbTIzICsgdG1wMjAgKiBtMzMpKSwgIC8vIFs5XVxuICAgICAgICBkICogKCh0bXAxNCAqIG0wMyArIHRtcDE5ICogbTEzICsgdG1wMjIgKiBtMzMpIC0gKHRtcDE1ICogbTAzICsgdG1wMTggKiBtMTMgKyB0bXAyMyAqIG0zMykpLCAgLy8gWzEwXVxuICAgICAgICBkICogKCh0bXAxNyAqIG0wMyArIHRtcDIwICogbTEzICsgdG1wMjMgKiBtMjMpIC0gKHRtcDE2ICogbTAzICsgdG1wMjEgKiBtMTMgKyB0bXAyMiAqIG0yMykpLCAgLy8gWzExXVxuICAgICAgICBkICogKCh0bXAxNCAqIG0yMiArIHRtcDE3ICogbTMyICsgdG1wMTMgKiBtMTIpIC0gKHRtcDE2ICogbTMyICsgdG1wMTIgKiBtMTIgKyB0bXAxNSAqIG0yMikpLCAgLy8gWzEyXVxuICAgICAgICBkICogKCh0bXAyMCAqIG0zMiArIHRtcDEyICogbTAyICsgdG1wMTkgKiBtMjIpIC0gKHRtcDE4ICogbTIyICsgdG1wMjEgKiBtMzIgKyB0bXAxMyAqIG0wMikpLCAgLy8gWzEzXVxuICAgICAgICBkICogKCh0bXAxOCAqIG0xMiArIHRtcDIzICogbTMyICsgdG1wMTUgKiBtMDIpIC0gKHRtcDIyICogbTMyICsgdG1wMTQgKiBtMDIgKyB0bXAxOSAqIG0xMikpLCAgLy8gWzE0XVxuICAgICAgICBkICogKCh0bXAyMiAqIG0yMiArIHRtcDE2ICogbTAyICsgdG1wMjEgKiBtMTIpIC0gKHRtcDIwICogbTEyICsgdG1wMjMgKiBtMjIgKyB0bXAxNyAqIG0wMikpICAvLyBbMTVdXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgeC1heGlzIHRvIHRoaXMgbWF0cml4XG4gICAgICovXG4gICAgcHVibGljIHJvdGF0ZVgoX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9YKF9hbmdsZUluRGVncmVlcyk7XG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBfZnJvbUxlZnQpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHktYXhpcyB0byB0aGlzIG1hdHJpeFxuICAgICAqL1xuICAgIHB1YmxpYyByb3RhdGVZKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShfYW5nbGVJbkRlZ3JlZXMpO1xuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB6LWF4aXMgdG8gdGhpcyBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgcm90YXRlWihfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzKTtcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIF9mcm9tTGVmdCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSb3RhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXggdG8gcG9pbnQgdGhlIHotYXhpcyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCB0aWx0cyBpdCB0byBhY2NvcmQgd2l0aCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LFxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLiBJZiBubyB1cC17QGxpbmsgVmVjdG9yM30gaXMgZ2l2ZW4sIHRoZSBwcmV2aW91cyB1cC17QGxpbmsgVmVjdG9yM30gaXMgdXNlZC4gXG4gICAgICogVGhlIHBpdGNoIG1heSBiZSByZXN0cmljdGVkIHRvIHRoZSB1cC12ZWN0b3IgdG8gb25seSBjYWxjdWxhdGUgeWF3LlxuICAgICAqL1xuICAgIHB1YmxpYyBsb29rQXQoX3RhcmdldDogVmVjdG9yMywgX3VwPzogVmVjdG9yMywgX3Jlc3RyaWN0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgIF91cCA9IF91cCA/IFZlY3RvcjMuTk9STUFMSVpBVElPTihfdXApIDogVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WSgpKTtcblxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTE9PS19BVCh0aGlzLnRyYW5zbGF0aW9uLCBfdGFyZ2V0LCBfdXAsIF9yZXN0cmljdCk7XG4gICAgICBtdHhSZXN1bHQuc2NhbGUodGhpcy5zY2FsaW5nKTtcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMge0BsaW5rIE1hdHJpeDR4NC5sb29rQXR9LCBidXQgb3B0aW1pemVkIGFuZCBuZWVkcyB0ZXN0aW5nXG4gICAgICovXG4gICAgLy8gVE9ETzogdGVzdGluZyBsb29rYXQgdGhhdCByZWFsbHkganVzdCByb3RhdGVzIHRoZSBtYXRyaXggcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgb25lXG4gICAgLy8gcHVibGljIGxvb2tBdFJvdGF0ZShfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcHJlc2VydmVTY2FsaW5nOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIC8vICAgaWYgKCFfdXApXG4gICAgLy8gICAgIF91cCA9IHRoaXMuZ2V0WSgpO1xuXG4gICAgLy8gICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcbiAgICAvLyAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHRoaXMudHJhbnNsYXRpb24pO1xuICAgIC8vICAgZGlmZmVyZW5jZS5ub3JtYWxpemUoKTtcbiAgICAvLyAgIGxldCBjb3M6IG51bWJlciA9IFZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFooKSksIGRpZmZlcmVuY2UpO1xuICAgIC8vICAgbGV0IHNpbjogbnVtYmVyID0gVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WCgpKSwgZGlmZmVyZW5jZSk7XG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyhzaW4sIGNvcyk7XG4gICAgLy8gICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xuICAgIC8vICAgbXR4Um90YXRpb24uZGF0YS5zZXQoW1xuICAgIC8vICAgICBjb3MsIDAsIC1zaW4sIDAsXG4gICAgLy8gICAgIDAsIDEsIDAsIDAsXG4gICAgLy8gICAgIHNpbiwgMCwgY29zLCAwLFxuICAgIC8vICAgICAwLCAwLCAwLCAxXG4gICAgLy8gICBdKTtcbiAgICAvLyAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIGZhbHNlKTtcblxuICAgIC8vICAgY29zID0gVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WigpKSwgZGlmZmVyZW5jZSk7XG4gICAgLy8gICBzaW4gPSAtVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WSgpKSwgZGlmZmVyZW5jZSk7XG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyhzaW4sIGNvcyk7XG4gICAgLy8gICBtdHhSb3RhdGlvbi5kYXRhLnNldChbXG4gICAgLy8gICAgIDEsIDAsIDAsIDAsXG4gICAgLy8gICAgIDAsIGNvcywgc2luLCAwLFxuICAgIC8vICAgICAwLCAtc2luLCBjb3MsIDAsXG4gICAgLy8gICAgIDAsIDAsIDAsIDFcbiAgICAvLyAgIF0pO1xuICAgIC8vICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgZmFsc2UpO1xuICAgIC8vICAgdGhpcy5zY2FsaW5nID0gc2NhbGluZztcbiAgICAvLyAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcbiAgICAvLyB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICAvLyNyZWdpb24gVHJhbnNsYXRpb25cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBieSB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9IHRvIHRoaXMgbWF0cml4LlxuICAgICAqIElmIF9sb2NhbCBpcyB0cnVlLCB0cmFuc2xhdGlvbiBvY2N1cnMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHJvdGF0aW9uIGFuZCBzY2FsaW5nIG9mIHRoaXMgbWF0cml4LFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgcGFyZW50IG90aGVyd2lzZS4gXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjMsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgIGlmIChfbG9jYWwpIHtcbiAgICAgICAgbGV0IG10eFRyYW5zbGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuVFJBTlNMQVRJT04oX2J5KTtcbiAgICAgICAgdGhpcy5tdWx0aXBseShtdHhUcmFuc2xhdGlvbik7XG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRyYW5zbGF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YVsxMl0gKz0gX2J5Lng7XG4gICAgICAgIHRoaXMuZGF0YVsxM10gKz0gX2J5Lnk7XG4gICAgICAgIHRoaXMuZGF0YVsxNF0gKz0gX2J5Lno7XG4gICAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXg0eDQuVFJBTlNMQVRJT04oX2J5KSk7XG4gICAgICAvLyAvLyBUT0RPOiBwb3NzaWJsZSBvcHRpbWl6YXRpb24sIHRyYW5zbGF0aW9uIG1heSBhbHRlciBtdXRhdG9yIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQuXG4gICAgICAvLyB0aGlzLnNldChtYXRyaXgpO1xuICAgICAgLy8gUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zbGF0ZVgoX3g6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5YKF94KTtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zbGF0ZVkoX3k6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5ZKF95KTtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgei1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zbGF0ZVooX3o6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKF96KTtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBTY2FsaW5nXG4gICAgLyoqXG4gICAgICogQWRkIGEgc2NhbGluZyBieSB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9IHRvIHRoaXMgbWF0cml4IFxuICAgICAqL1xuICAgIHB1YmxpYyBzY2FsZShfYnk6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDR4NC5TQ0FMSU5HKF9ieSkpO1xuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXG4gICAgICovXG4gICAgcHVibGljIHNjYWxlWChfYnk6IG51bWJlcik6IHZvaWQge1xuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcbiAgICAgIHZlY3Rvci5zZXQoX2J5LCAxLCAxKTtcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHZlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNjYWxpbmcgYWxvbmcgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxuICAgICAqL1xuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICB2ZWN0b3Iuc2V0KDEsIF9ieSwgMSk7XG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2NhbGVaKF9ieTogbnVtYmVyKTogdm9pZCB7XG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgdmVjdG9yLnNldCgxLCAxLCBfYnkpO1xuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgbXVsdGlwbHkoX21hdHJpeDogTWF0cml4NHg0LCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBfZnJvbUxlZnQgPyBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX21hdHJpeCwgdGhpcykgOiBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcywgX21hdHJpeCk7XG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcbiAgICAvLyBwdWJsaWMgZ2V0RXVsZXJBbmdsZXNOZXcoKTogVmVjdG9yMyB7XG4gICAgLy8gICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcblxuICAgIC8vICAgbGV0IHRoZXRhWDogbnVtYmVyLCB0aGV0YVk6IG51bWJlciwgdGhldGFaOiBudW1iZXI7XG4gICAgLy8gICBsZXQgcjAyOiBudW1iZXIgPSB0aGlzLmRhdGFbMl0gLyBzY2FsaW5nLno7XG4gICAgLy8gICBsZXQgcjExOiBudW1iZXIgPSB0aGlzLmRhdGFbNV0gLyBzY2FsaW5nLnk7XG5cbiAgICAvLyAgIGlmIChyMDIgPCAxKSB7XG4gICAgLy8gICAgIGlmIChyMDIgPiAtMSkge1xuICAgIC8vICAgICAgIHRoZXRhWSA9IE1hdGguYXNpbigtcjAyKTtcbiAgICAvLyAgICAgICB0aGV0YVogPSBNYXRoLmF0YW4yKHRoaXMuZGF0YVsxXSAvIHNjYWxpbmcueSwgdGhpcy5kYXRhWzBdIC8gc2NhbGluZy54KTtcbiAgICAvLyAgICAgICB0aGV0YVggPSBNYXRoLmF0YW4yKHRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzEwXSAvIHNjYWxpbmcueik7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgZWxzZSB7XG4gICAgLy8gICAgICAgdGhldGFZID0gTWF0aC5QSSAvIDI7XG4gICAgLy8gICAgICAgdGhldGFaID0gLU1hdGguYXRhbjIodGhpcy5kYXRhWzZdIC8gc2NhbGluZy55LCByMTEpO1xuICAgIC8vICAgICAgIHRoZXRhWCA9IDA7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyAgIGVsc2Uge1xuICAgIC8vICAgICB0aGV0YVkgPSAtTWF0aC5QSSAvIDI7XG4gICAgLy8gICAgIHRoZXRhWiA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs2XSAvIHNjYWxpbmcueSwgcjExKTtcbiAgICAvLyAgICAgdGhldGFYID0gMDtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHRoaXMuI2V1bGVyQW5nbGVzLnNldCgtdGhldGFYLCB0aGV0YVksIHRoZXRhWik7XG4gICAgLy8gICB0aGlzLiNldWxlckFuZ2xlcy5zY2FsZShNYXRoZW1hdGljLnJhZDJkZWcpO1xuXG4gICAgLy8gICByZXR1cm4gdGhpcy4jZXVsZXJBbmdsZXM7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgICovXG4gICAgcHVibGljIHNldChfbXR4VG86IE1hdHJpeDR4NCB8IEFycmF5TGlrZTxudW1iZXI+KTogdm9pZCB7XG4gICAgICBpZiAoX210eFRvIGluc3RhbmNlb2YgTWF0cml4NHg0KVxuICAgICAgICB0aGlzLmRhdGEuc2V0KF9tdHhUby5kYXRhKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5kYXRhLnNldChfbXR4VG8pO1xuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBgxpIuTWF0cml4NHg0KHRyYW5zbGF0aW9uOiAke3RoaXMudHJhbnNsYXRpb24udG9TdHJpbmcoKX0sIHJvdGF0aW9uOiAke3RoaXMucm90YXRpb24udG9TdHJpbmcoKX0sIHNjYWxpbmc6ICR7dGhpcy5zY2FsaW5nLnRvU3RyaW5nKCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IGFzIGEgRmxvYXQzMkFycmF5XG4gICAgICovXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xuICAgICAgLy8gVE9ETzogb3B0aW1pemF0aW9uLCBpdCBzaG91bGRuJ3QgYWx3YXlzIHJldHVybiBhIGNvcHksIHNpbmNlIHRoaXMgYmxvYXRzIG1lbW9yeVxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY2FyZGluYWwgeC1heGlzXG4gICAgICovXG4gICAgcHVibGljIGdldFgoKTogVmVjdG9yMyB7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBjYXJkaW5hbCB5LWF4aXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0WSgpOiBWZWN0b3IzIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICByZXN1bHQuc2V0KHRoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHotYXhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRaKCk6IFZlY3RvcjMge1xuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcbiAgICAgIHJlc3VsdC5zZXQodGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB0aGUgdHdvIGNhcmRpbmFsIGF4aXMgYW5kIHJldmVyc2VzIHRoZSB0aGlyZCwgZWZmZWN0aXZlbHkgcm90YXRpbmcgdGhlIHRyYW5zZm9ybSAxODAgZGVncmVlcyBhcm91bmQgb25lIGFuZCA5MCBkZWdyZWVzIGFyb3VuZCBhIHNlY29uZCBheGlzXG4gICAgICovXG4gICAgcHVibGljIHN3YXBYWSgpOiB2b2lkIHtcbiAgICAgIGxldCB0ZW1wOiBudW1iZXJbXSA9IFt0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdXTsgLy8gc3RvcmUgeC1heGlzXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdXSwgMCk7IC8vIG92ZXJ3cml0ZSB4LWF4aXMgd2l0aCB5LWF4aXNcbiAgICAgIHRoaXMuZGF0YS5zZXQodGVtcCwgNCk7IC8vIG92ZXJ3cml0ZSBZIHdpdGggdGVtcFxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVs4XSwgLXRoaXMuZGF0YVs5XSwgLXRoaXMuZGF0YVsxMF1dLCA4KTsgLy8gcmV2ZXJzZSB6LWF4aXNcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBzd2FwWFooKTogdm9pZCB7XG4gICAgICBsZXQgdGVtcDogbnVtYmVyW10gPSBbdGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXV07IC8vIHN0b3JlIHgtYXhpc1xuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF1dLCAwKTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHotYXhpc1xuICAgICAgdGhpcy5kYXRhLnNldCh0ZW1wLCA4KTsgLy8gb3ZlcndyaXRlIFogd2l0aCB0ZW1wXG4gICAgICB0aGlzLmRhdGEuc2V0KFstdGhpcy5kYXRhWzRdLCAtdGhpcy5kYXRhWzVdLCAtdGhpcy5kYXRhWzZdXSwgNCk7IC8vIHJldmVyc2UgeS1heGlzXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN3YXBzIHRoZSB0d28gY2FyZGluYWwgYXhpcyBhbmQgcmV2ZXJzZXMgdGhlIHRoaXJkLCBlZmZlY3RpdmVseSByb3RhdGluZyB0aGUgdHJhbnNmb3JtIDE4MCBkZWdyZWVzIGFyb3VuZCBvbmUgYW5kIDkwIGRlZ3JlZXMgYXJvdW5kIGEgc2Vjb25kIGF4aXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3dhcFlaKCk6IHZvaWQge1xuICAgICAgbGV0IHRlbXA6IG51bWJlcltdID0gW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dOyAvLyBzdG9yZSB5LWF4aXNcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMuZGF0YVs4XSwgdGhpcy5kYXRhWzldLCB0aGlzLmRhdGFbMTBdXSwgNCk7IC8vIG92ZXJ3cml0ZSB5LWF4aXMgd2l0aCB6LWF4aXNcbiAgICAgIHRoaXMuZGF0YS5zZXQodGVtcCwgOCk7IC8vIG92ZXJ3cml0ZSBaIHdpdGggdGVtcFxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVswXSwgLXRoaXMuZGF0YVsxXSwgLXRoaXMuZGF0YVsyXV0sIDApOyAvLyByZXZlcnNlIHgtYXhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5sYXRpb24gZnJvbSB0aGlzIG1hdHJpeCB0byB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUcmFuc2xhdGlvblRvKF9tdHhUYXJnZXQ6IE1hdHJpeDR4NCk6IFZlY3RvcjMge1xuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICBkaWZmZXJlbmNlLnNldChfbXR4VGFyZ2V0LmRhdGFbMTJdIC0gdGhpcy5kYXRhWzEyXSwgX210eFRhcmdldC5kYXRhWzEzXSAtIHRoaXMuZGF0YVsxM10sIF9tdHhUYXJnZXQuZGF0YVsxNF0gLSB0aGlzLmRhdGFbMTRdKTtcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICAvLyB0aGlzLmdldE11dGF0b3IoKTtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5zZXJpYWxpemUoKSxcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24uc2VyaWFsaXplKCksXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5zZXJpYWxpemUoKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XG4gICAgICAgIHRyYW5zbGF0aW9uOiBhd2FpdCB0aGlzLnRyYW5zbGF0aW9uLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnRyYW5zbGF0aW9uKSxcbiAgICAgICAgcm90YXRpb246IGF3YWl0IHRoaXMucm90YXRpb24uZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucm90YXRpb24pLFxuICAgICAgICBzY2FsaW5nOiBhd2FpdCB0aGlzLnNjYWxpbmcuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uc2NhbGluZylcbiAgICAgIH07XG4gICAgICB0aGlzLm11dGF0ZShtdXRhdG9yKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xuICAgICAgaWYgKHRoaXMubXV0YXRvcilcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRvcjtcblxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLmdldE11dGF0b3IoKSxcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24uZ2V0TXV0YXRvcigpLFxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuZ2V0TXV0YXRvcigpXG4gICAgICB9O1xuXG4gICAgICAvLyBjYWNoZSBtdXRhdG9yXG4gICAgICB0aGlzLm11dGF0b3IgPSBtdXRhdG9yO1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgbTogRmxvYXQzMkFycmF5ID0gdGhpcy5kYXRhO1xuXG4gICAgICBpZiAoX211dGF0b3IudHJhbnNsYXRpb24pIHtcbiAgICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gdGhpcy50cmFuc2xhdGlvbjtcbiAgICAgICAgdHJhbnNsYXRpb24ubXV0YXRlKF9tdXRhdG9yLnRyYW5zbGF0aW9uKTtcbiAgICAgICAgbVsxMl0gPSB0cmFuc2xhdGlvbi54OyBtWzEzXSA9IHRyYW5zbGF0aW9uLnk7IG1bMTRdID0gdHJhbnNsYXRpb24uejtcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24gfHwgX211dGF0b3Iuc2NhbGluZykge1xuICAgICAgICAvLyBUT0RPOiBpbXBvcnRlZCBhbmltYXRpb24gdXNlcyBcInNjYWxlXCIgaW5zdGVhZCBvZiBcInNjYWxpbmdcIiAtPiByZW5hbWUgb3VyIFwic2NhbGluZ1wiIHRvIFwic2NhbGVcIj9cbiAgICAgICAgLy8gVE9ETzogbWFrZSBmdWxsIHZlY3RvciBhbmQgcXVhdGVybmlvbiBtdXRhdG9ycyBtYW5kYXRvcnk/XG5cbiAgICAgICAgbGV0IHJvdGF0aW9uOiBWZWN0b3IzIHwgUXVhdGVybmlvbiA9IF9tdXRhdG9yLnJvdGF0aW9uPy53ICE9IHVuZGVmaW5lZCA/XG4gICAgICAgICAgdGhpcy4jcXVhdGVybmlvbiA6IC8vIHVzaW5nIHRoaXMuI3F1YXRlcm5pb24gYXNzdW1lcyB3ZSBnZXQgYSBmdWxsIHF1YXRlcm5pb24gbXV0YXRvciB3aXRoIHgsIHksIHogYW5kIHcgc2V0IHNvIHdlIG5ldmVyIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHF1YXRlcm5pb24gaGVyZS4gVGhpcyBtaWdodCBjYXVzZSB0cm91YmxlIGlmIHdlIGV2ZXIgd2FudCB0byBtdXRhdGUgb25seSBhIHBhcnQgb2YgYSBxdWF0ZXJuaW9uLi4uXG4gICAgICAgICAgaXNGdWxsVmVjdG9yTXV0YXRvcihfbXV0YXRvci5yb3RhdGlvbikgPyB0aGlzLiNyb3RhdGlvbiA6IHRoaXMucm90YXRpb247IC8vIGhhY2sgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvbiBvZiByb3RhdGlvbiBhbmQgc2NhbGluZy4gVGhpcyByZWNhbGN1bGF0aW9uIGlzIHVubmVjZXNzYXJ5IHdoZW4gd2UgZ2V0IGEgZnVsbCBtdXRhdG9yIGkuZS4gd2l0aCB4LCB5IGFuZCB6IHNldFxuXG4gICAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gaXNGdWxsVmVjdG9yTXV0YXRvcihfbXV0YXRvci5zY2FsaW5nKSA/IHRoaXMuI3NjYWxpbmcgOiB0aGlzLnNjYWxpbmc7XG5cbiAgICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uKVxuICAgICAgICAgIHJvdGF0aW9uLm11dGF0ZShfbXV0YXRvci5yb3RhdGlvbik7XG5cbiAgICAgICAgaWYgKF9tdXRhdG9yLnNjYWxpbmcpXG4gICAgICAgICAgc2NhbGluZy5tdXRhdGUoX211dGF0b3Iuc2NhbGluZyk7XG5cbiAgICAgICAgTWF0cml4NHg0LlNFVF9ST1RBVElPTihtLCByb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGlzRXVsZXJSb3RhdGlvbjogYm9vbGVhbiA9IHJvdGF0aW9uIGluc3RhbmNlb2YgVmVjdG9yMztcbiAgICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9ICFpc0V1bGVyUm90YXRpb247XG4gICAgICAgIHRoaXMuI3F1YXRlcm5pb25EaXJ0eSA9IGlzRXVsZXJSb3RhdGlvbjtcblxuICAgICAgICBjb25zdCBzeDogbnVtYmVyID0gc2NhbGluZy54LCBzeTogbnVtYmVyID0gc2NhbGluZy55LCBzejogbnVtYmVyID0gc2NhbGluZy56O1xuICAgICAgICBtWzBdICo9IHN4OyBtWzFdICo9IHN4OyBtWzJdICo9IHN4O1xuICAgICAgICBtWzRdICo9IHN5OyBtWzVdICo9IHN5OyBtWzZdICo9IHN5O1xuICAgICAgICBtWzhdICo9IHN6OyBtWzldICo9IHN6OyBtWzEwXSAqPSBzejtcbiAgICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRnVsbFZlY3Rvck11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIF9tdXRhdG9yICYmIF9tdXRhdG9yLnggIT0gdW5kZWZpbmVkICYmIF9tdXRhdG9yLnkgIT0gdW5kZWZpbmVkICYmIF9tdXRhdG9yLnogIT0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikgdHlwZXMudHJhbnNsYXRpb24gPSBcIlZlY3RvcjNcIjtcbiAgICAgIGlmIChfbXV0YXRvci5yb3RhdGlvbikgdHlwZXMucm90YXRpb24gPSBcIlZlY3RvcjNcIjtcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IzXCI7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cblxuICAgIHByaXZhdGUgcmVzZXRDYWNoZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9IHRydWU7XG4gICAgICB0aGlzLiNxdWF0ZXJuaW9uRGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8vI2VuZHJlZ2lvblxufVxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqXG4gICAqIEJhc2VjbGFzcyBmb3IgTm9pc2UyLCBOb2lzZTMgYW5kIE5vaXNlNFxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxuICAgKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxuICAgKi9cbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5vaXNlIHtcbiAgICBwcm90ZWN0ZWQgcGVybTogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDUxMik7XG4gICAgcHJvdGVjdGVkIHBlcm1Nb2QxMjogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDUxMik7XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxIGJhc2VkIG9uIHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzYW1wbGU6ICguLi5fYXJnczogbnVtYmVyW10pID0+IG51bWJlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XG4gICAgICBjb25zdCBwOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAyNTY7IGkrKylcbiAgICAgICAgcFtpXSA9IGk7XG5cbiAgICAgIGxldCBuOiBudW1iZXI7XG4gICAgICBsZXQgcTogbnVtYmVyO1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMjU1OyBpID4gMDsgaS0tKSB7XG4gICAgICAgIG4gPSBNYXRoLmZsb29yKChpICsgMSkgKiBfcmFuZG9tKCkpO1xuICAgICAgICBxID0gcFtpXTtcbiAgICAgICAgcFtpXSA9IHBbbl07XG4gICAgICAgIHBbbl0gPSBxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgNTEyOyBpKyspIHtcbiAgICAgICAgdGhpcy5wZXJtW2ldID0gcFtpICYgMjU1XTtcbiAgICAgICAgdGhpcy5wZXJtTW9kMTJbaV0gPSB0aGlzLnBlcm1baV0gJSAxMjtcbiAgICAgIH1cbiAgICB9XG5cblxuICB9XG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi9Ob2lzZS50c1wiLz5cblxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gYWRhcHRpb24gb2YgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFzdC1zaW1wbGV4LW5vaXNlXG4gICAqIGRvbmUgYnkgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICpcbiAgICogQmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxuICAgKiBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cbiAgICogQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cbiAgICpcbiAgICogVGhpcyBjb2RlIHdhcyBwbGFjZWQgaW4gdGhlIHB1YmxpYyBkb21haW4gYnkgaXRzIG9yaWdpbmFsIGF1dGhvcixcbiAgICogU3RlZmFuIEd1c3RhdnNvbi4gWW91IG1heSB1c2UgaXQgYXMgeW91IHNlZSBmaXQsIGJ1dFxuICAgKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cbiAgICovXG4gIGV4cG9ydCBjbGFzcyBOb2lzZTIgZXh0ZW5kcyBOb2lzZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAoMy4wIC0gTWF0aC5zcXJ0KDMuMCkpIC8gNi4wO1xuICAgIHByaXZhdGUgc3RhdGljIGdyYWRpZW50OiBudW1iZXJbXVtdID0gW1sxLCAxXSwgWy0xLCAxXSwgWzEsIC0xXSwgWy0xLCAtMV0sIFsxLCAwXSwgWy0xLCAwXSwgWzEsIDBdLCBbLTEsIDBdLCBbMCwgMV0sIFswLCAtMV0sIFswLCAxXSwgWzAsIC0xXV07XG4gICAgI3NhbXBsZTogKF94OiBudW1iZXIsIF95OiBudW1iZXIpID0+IG51bWJlciA9IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xuICAgICAgc3VwZXIoX3JhbmRvbSk7XG5cbiAgICAgIHRoaXMuI3NhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyKSA9PiB7XG4gICAgICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICAgICAgY29uc3QgczogbnVtYmVyID0gKF94ICsgX3kpICogMC41ICogKE1hdGguc3FydCgzLjApIC0gMS4wKTsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxuICAgICAgICBjb25zdCBpOiBudW1iZXIgPSBNYXRoLmZsb29yKF94ICsgcyk7XG4gICAgICAgIGNvbnN0IGo6IG51bWJlciA9IE1hdGguZmxvb3IoX3kgKyBzKTtcbiAgICAgICAgY29uc3QgdDogbnVtYmVyID0gKGkgKyBqKSAqIE5vaXNlMi5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IFgwOiBudW1iZXIgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkpIHNwYWNlXG4gICAgICAgIGNvbnN0IFkwOiBudW1iZXIgPSBqIC0gdDtcbiAgICAgICAgY29uc3QgeDA6IG51bWJlciA9IF94IC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICAgIGNvbnN0IHkwOiBudW1iZXIgPSBfeSAtIFkwO1xuXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cbiAgICAgICAgY29uc3QgaTE6IG51bWJlciA9IHgwID4geTAgPyAxIDogMDtcbiAgICAgICAgY29uc3QgajE6IG51bWJlciA9IHgwID4geTAgPyAwIDogMTtcblxuICAgICAgICAvLyBPZmZzZXQ6bnVtYmVycyBmb3IgY29ybmVyc1xuICAgICAgICBjb25zdCB4MTogbnVtYmVyID0geDAgLSBpMSArIE5vaXNlMi5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2UyLm9mZnNldDtcbiAgICAgICAgY29uc3QgeDI6IG51bWJlciA9IHgwIC0gMS4wICsgMi4wICogTm9pc2UyLm9mZnNldDtcbiAgICAgICAgY29uc3QgeTI6IG51bWJlciA9IHkwIC0gMS4wICsgMi4wICogTm9pc2UyLm9mZnNldDtcblxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVyc1xuICAgICAgICBjb25zdCBpaTogbnVtYmVyID0gaSAmIDI1NTtcbiAgICAgICAgY29uc3Qgamo6IG51bWJlciA9IGogJiAyNTU7XG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlMi5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIHRoaXMucGVybVtqal1dXTtcbiAgICAgICAgY29uc3QgZzE6IG51bWJlcltdID0gTm9pc2UyLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgaTEgKyB0aGlzLnBlcm1bamogKyBqMV1dXTtcbiAgICAgICAgY29uc3QgZzI6IG51bWJlcltdID0gTm9pc2UyLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgMSArIHRoaXMucGVybVtqaiArIDFdXV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuICAgICAgICBjb25zdCB0MDogbnVtYmVyID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XG4gICAgICAgIGNvbnN0IG4wOiBudW1iZXIgPSB0MCA8IDAgPyAwLjAgOiBNYXRoLnBvdyh0MCwgNCkgKiAoZzBbMF0gKiB4MCArIGcwWzFdICogeTApO1xuXG4gICAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MTtcbiAgICAgICAgY29uc3QgbjE6IG51bWJlciA9IHQxIDwgMCA/IDAuMCA6IE1hdGgucG93KHQxLCA0KSAqIChnMVswXSAqIHgxICsgZzFbMV0gKiB5MSk7XG5cbiAgICAgICAgY29uc3QgdDI6IG51bWJlciA9IDAuNSAtIHgyICogeDIgLSB5MiAqIHkyO1xuICAgICAgICBjb25zdCBuMjogbnVtYmVyID0gdDIgPCAwID8gMC4wIDogTWF0aC5wb3codDIsIDQpICogKGcyWzBdICogeDIgKyBnMlsxXSAqIHkyKTtcblxuICAgICAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwgMV1cbiAgICAgICAgcmV0dXJuIDcwLjE0ODA1NzcwNjUzOTUyICogKG4wICsgbjEgKyBuMik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzYW1wbGUgPSAoX3g6IG51bWJlciwgX3k6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgICByZXR1cm4gdGhpcy4jc2FtcGxlKF94LCBfeSk7XG4gICAgfTtcbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogVGhpcyBpcyBhbiBhZGFwdGlvbiBvZiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mYXN0LXNpbXBsZXgtbm9pc2VcbiAgICogZG9uZSBieSBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxuICAgKlxuICAgKiBCYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXG4gICAqIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxuICAgKiBCZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxuICAgKlxuICAgKiBUaGlzIGNvZGUgd2FzIHBsYWNlZCBpbiB0aGUgcHVibGljIGRvbWFpbiBieSBpdHMgb3JpZ2luYWwgYXV0aG9yLFxuICAgKiBTdGVmYW4gR3VzdGF2c29uLiBZb3UgbWF5IHVzZSBpdCBhcyB5b3Ugc2VlIGZpdCwgYnV0XG4gICAqIGF0dHJpYnV0aW9uIGlzIGFwcHJlY2lhdGVkLlxuICAgKi9cbiAgLy8gVE9ETzogVGVzdFxuICBleHBvcnQgY2xhc3MgTm9pc2UzIGV4dGVuZHMgTm9pc2Uge1xuICAgIHByaXZhdGUgc3RhdGljIG9mZnNldDogbnVtYmVyID0gMS4wIC8gNi4wO1xuICAgIHByaXZhdGUgc3RhdGljIGdyYWRpZW50OiBudW1iZXJbXVtdID0gW1sxLCAxLCAwXSwgWy0xLCAxLCAwXSwgWzEsIC0xLCAwXSwgWy0xLCAtMSwgMF0sIFsxLCAwLCAxXSwgWy0xLCAwLCAxXSwgWzEsIDAsIC0xXSwgWy0xLCAwLCAtMV0sIFswLCAxLCAxXSwgWzAsIC0xLCAtMV0sIFswLCAxLCAtMV0sIFswLCAtMSwgLTFdXG4gICAgXTtcbiAgICAjc2FtcGxlOiAoX3g6IG51bWJlciwgX3k6IG51bWJlciwgX3o6IG51bWJlcikgPT4gbnVtYmVyID0gbnVsbDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XG4gICAgICBzdXBlcihfcmFuZG9tKTtcblxuICAgICAgdGhpcy4jc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIpID0+IHtcbiAgICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxuICAgICAgICBjb25zdCBzOiBudW1iZXIgPSAoX3ggKyBfeSArIF96KSAvIDMuMDsgLy8gVmVyeSBuaWNlIGFuZCBzaW1wbGUgc2tldyBmYWN0b3IgZm9yIDNEXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoX3ggKyBzKTtcbiAgICAgICAgY29uc3QgajogbnVtYmVyID0gTWF0aC5mbG9vcihfeSArIHMpO1xuICAgICAgICBjb25zdCBrOiBudW1iZXIgPSBNYXRoLmZsb29yKF96ICsgcyk7XG4gICAgICAgIGNvbnN0IHQ6IG51bWJlciA9IChpICsgaiArIGspICogTm9pc2UzLm9mZnNldDtcbiAgICAgICAgY29uc3QgWDA6IG51bWJlciA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6KSBzcGFjZVxuICAgICAgICBjb25zdCBZMDogbnVtYmVyID0gaiAtIHQ7XG4gICAgICAgIGNvbnN0IFowOiBudW1iZXIgPSBrIC0gdDtcbiAgICAgICAgY29uc3QgeDA6IG51bWJlciA9IF94IC0gWDA7IC8vIFRoZSB4LHkseiBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW5cbiAgICAgICAgY29uc3QgeTA6IG51bWJlciA9IF95IC0gWTA7XG4gICAgICAgIGNvbnN0IHowOiBudW1iZXIgPSBfeiAtIFowO1xuXG4gICAgICAgIC8vIERldGVyaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluXG4gICAgICAgIGxldCBpMTogbnVtYmVyLCBqMTogbnVtYmVyLCBrMTogbnVtYmVyIC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgICAgICAgIDtcbiAgICAgICAgbGV0IGkyOiBudW1iZXIsIGoyOiBudW1iZXIsIGsyOiBudW1iZXIgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcbiAgICAgICAgICA7XG4gICAgICAgIGlmICh4MCA+PSB5MCkge1xuICAgICAgICAgIGlmICh5MCA+PSB6MCkge1xuICAgICAgICAgICAgaTEgPSBpMiA9IGoyID0gMTtcbiAgICAgICAgICAgIGoxID0gazEgPSBrMiA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmICh4MCA+PSB6MCkge1xuICAgICAgICAgICAgaTEgPSBpMiA9IGsyID0gMTtcbiAgICAgICAgICAgIGoxID0gazEgPSBqMiA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGsxID0gaTIgPSBrMiA9IDE7XG4gICAgICAgICAgICBpMSA9IGoxID0gajIgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoeTAgPCB6MCkge1xuICAgICAgICAgICAgazEgPSBqMiA9IGsyID0gMTtcbiAgICAgICAgICAgIGkxID0gajEgPSBpMiA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmICh4MCA8IHowKSB7XG4gICAgICAgICAgICBqMSA9IGoyID0gazIgPSAxO1xuICAgICAgICAgICAgaTEgPSBrMSA9IGkyID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgajEgPSBpMiA9IGoyID0gMTtcbiAgICAgICAgICAgIGkxID0gazEgPSBrMiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeDE6IG51bWJlciA9IHgwIC0gaTEgKyBOb2lzZTMub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2UzLm9mZnNldDtcbiAgICAgICAgY29uc3QgejE6IG51bWJlciA9IHowIC0gazEgKyBOb2lzZTMub2Zmc2V0O1xuICAgICAgICBjb25zdCB4MjogbnVtYmVyID0geDAgLSBpMiArIDIuMCAqIE5vaXNlMy5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgICBjb25zdCB5MjogbnVtYmVyID0geTAgLSBqMiArIDIuMCAqIE5vaXNlMy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHoyOiBudW1iZXIgPSB6MCAtIGsyICsgMi4wICogTm9pc2UzLm9mZnNldDtcbiAgICAgICAgY29uc3QgeDM6IG51bWJlciA9IHgwIC0gMS4wICsgMy4wICogTm9pc2UzLm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgICAgY29uc3QgeTM6IG51bWJlciA9IHkwIC0gMS4wICsgMy4wICogTm9pc2UzLm9mZnNldDtcbiAgICAgICAgY29uc3QgejM6IG51bWJlciA9IHowIC0gMS4wICsgMy4wICogTm9pc2UzLm9mZnNldDtcblxuICAgICAgICAvLyBXb3JrIDpudW1iZXJ1dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZvdXIgc2ltcGxleCBjb3JuZXJzXG4gICAgICAgIGNvbnN0IGlpOiBudW1iZXIgPSBpICYgMjU1O1xuICAgICAgICBjb25zdCBqajogbnVtYmVyID0gaiAmIDI1NTtcbiAgICAgICAgY29uc3Qga2s6IG51bWJlciA9IGsgJiAyNTU7XG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIHRoaXMucGVybVtqaiArIHRoaXMucGVybVtra11dXV07XG4gICAgICAgIGNvbnN0IGcxOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIGkxICsgdGhpcy5wZXJtW2pqICsgajEgKyB0aGlzLnBlcm1ba2sgKyBrMV1dXV07XG4gICAgICAgIGNvbnN0IGcyOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIGkyICsgdGhpcy5wZXJtW2pqICsgajIgKyB0aGlzLnBlcm1ba2sgKyBrMl1dXV07XG4gICAgICAgIGNvbnN0IGczOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIDEgKyB0aGlzLnBlcm1bamogKyAxICsgdGhpcy5wZXJtW2trICsgMV1dXV07XG5cbiAgICAgICAgLy8gQ2FsY3U6bnVtYmVyYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZm91ciBjb3JuZXJzXG4gICAgICAgIGNvbnN0IHQwOiBudW1iZXIgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XG4gICAgICAgIGNvbnN0IG4wOiBudW1iZXIgPSB0MCA8IDBcbiAgICAgICAgICA/IDAuMFxuICAgICAgICAgIDogTWF0aC5wb3codDAsIDQpICogKGcwWzBdICogeDAgKyBnMFsxXSAqIHkwICsgZzBbMl0gKiB6MCk7XG4gICAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MSAtIHoxICogejE7XG4gICAgICAgIGNvbnN0IG4xOiBudW1iZXIgPSB0MSA8IDBcbiAgICAgICAgICA/IDAuMFxuICAgICAgICAgIDogTWF0aC5wb3codDEsIDQpICogKGcxWzBdICogeDEgKyBnMVsxXSAqIHkxICsgZzFbMl0gKiB6MSk7XG4gICAgICAgIGNvbnN0IHQyOiBudW1iZXIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejI7XG4gICAgICAgIGNvbnN0IG4yOiBudW1iZXIgPSB0MiA8IDBcbiAgICAgICAgICA/IDAuMFxuICAgICAgICAgIDogTWF0aC5wb3codDIsIDQpICogKGcyWzBdICogeDIgKyBnMlsxXSAqIHkyICsgZzJbMl0gKiB6Mik7XG4gICAgICAgIGNvbnN0IHQzOiBudW1iZXIgPSAwLjUgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XG4gICAgICAgIGNvbnN0IG4zOiBudW1iZXIgPSB0MyA8IDBcbiAgICAgICAgICA/IDAuMFxuICAgICAgICAgIDogTWF0aC5wb3codDMsIDQpICogKGczWzBdICogeDMgKyBnM1sxXSAqIHkzICsgZzNbMl0gKiB6Myk7XG5cbiAgICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byBzdGF5IGp1c3QgaW5zaWRlIFstMSwxXVxuICAgICAgICByZXR1cm4gOTQuNjg0OTMxNTA2ODE5NzIgKiAobjAgKyBuMSArIG4yICsgbjMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuI3NhbXBsZShfeCwgX3ksIF96KTtcbiAgICB9O1xuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8vIFRPRE86IFRlc3RcbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gYWRhcHRpb24gb2YgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFzdC1zaW1wbGV4LW5vaXNlXG4gICAqIGRvbmUgYnkgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICpcbiAgICogQmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxuICAgKiBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cbiAgICogQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cbiAgICpcbiAgICogVGhpcyBjb2RlIHdhcyBwbGFjZWQgaW4gdGhlIHB1YmxpYyBkb21haW4gYnkgaXRzIG9yaWdpbmFsIGF1dGhvcixcbiAgICogU3RlZmFuIEd1c3RhdnNvbi4gWW91IG1heSB1c2UgaXQgYXMgeW91IHNlZSBmaXQsIGJ1dFxuICAgKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cbiAgICovXG4gIGV4cG9ydCBjbGFzcyBOb2lzZTQgZXh0ZW5kcyBOb2lzZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAoNS4wIC0gTWF0aC5zcXJ0KDUuMCkpIC8gMjAuMDtcbiAgICBwcml2YXRlIHN0YXRpYyBncmFkaWVudDogbnVtYmVyW11bXSA9IFtbMCwgMSwgMSwgMV0sIFswLCAxLCAxLCAtMV0sIFswLCAxLCAtMSwgMV0sIFswLCAxLCAtMSwgLTFdLCBbMCwgLTEsIDEsIDFdLCBbMCwgLTEsIDEsIC0xXSwgWzAsIC0xLCAtMSwgMV0sIFswLCAtMSwgLTEsIC0xXSwgWzEsIDAsIDEsIDFdLCBbMSwgMCwgMSwgLTFdLCBbMSwgMCwgLTEsIDFdLCBbMSwgMCwgLTEsIC0xXSwgWy0xLCAwLCAxLCAxXSwgWy0xLCAwLCAxLCAtMV0sIFstMSwgMCwgLTEsIDFdLCBbLTEsIDAsIC0xLCAtMV0sIFsxLCAxLCAwLCAxXSwgWzEsIDEsIDAsIC0xXSwgWzEsIC0xLCAwLCAxXSwgWzEsIC0xLCAwLCAtMV0sIFstMSwgMSwgMCwgMV0sIFstMSwgMSwgMCwgLTFdLCBbLTEsIC0xLCAwLCAxXSwgWy0xLCAtMSwgMCwgLTFdLCBbMSwgMSwgMSwgMF0sIFsxLCAxLCAtMSwgMF0sIFsxLCAtMSwgMSwgMF0sIFsxLCAtMSwgLTEsIDBdLCBbLTEsIDEsIDEsIDBdLCBbLTEsIDEsIC0xLCAwXSwgWy0xLCAtMSwgMSwgMF0sIFstMSwgLTEsIC0xLCAwXV07XG4gICAgI3NhbXBsZTogKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpID0+IG51bWJlciA9IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xuICAgICAgc3VwZXIoX3JhbmRvbSk7XG5cbiAgICAgIHRoaXMuI3NhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgICAgLy8gU2tldyB0aGUgKHgseSx6LHcpIHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBjZWxsIG9mIDI0IHNpbXBsaWNlcyB3ZSdyZSBpblxuICAgICAgICBjb25zdCBzOiBudW1iZXIgPSAoX3ggKyBfeSArIF96ICsgX3cpICogKE1hdGguc3FydCg1LjApIC0gMS4wKSAvIDQuMDsgLy8gRmFjdG9yIGZvciA0RCBza2V3aW5nXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoX3ggKyBzKTtcbiAgICAgICAgY29uc3QgajogbnVtYmVyID0gTWF0aC5mbG9vcihfeSArIHMpO1xuICAgICAgICBjb25zdCBrOiBudW1iZXIgPSBNYXRoLmZsb29yKF96ICsgcyk7XG4gICAgICAgIGNvbnN0IGw6IG51bWJlciA9IE1hdGguZmxvb3IoX3cgKyBzKTtcbiAgICAgICAgY29uc3QgdDogbnVtYmVyID0gKGkgKyBqICsgayArIGwpICogTm9pc2U0Lm9mZnNldDsgLy8gRmFjdG9yIGZvciA0RCB1bnNrZXdpbmdcbiAgICAgICAgY29uc3QgWDA6IG51bWJlciA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6LHcpIHNwYWNlXG4gICAgICAgIGNvbnN0IFkwOiBudW1iZXIgPSBqIC0gdDtcbiAgICAgICAgY29uc3QgWjA6IG51bWJlciA9IGsgLSB0O1xuICAgICAgICBjb25zdCBXMDogbnVtYmVyID0gbCAtIHQ7XG4gICAgICAgIGNvbnN0IHgwOiBudW1iZXIgPSBfeCAtIFgwOyAvLyBUaGUgeCx5LHosdyBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW5cbiAgICAgICAgY29uc3QgeTA6IG51bWJlciA9IF95IC0gWTA7XG4gICAgICAgIGNvbnN0IHowOiBudW1iZXIgPSBfeiAtIFowO1xuICAgICAgICBjb25zdCB3MDogbnVtYmVyID0gX3cgLSBXMDtcblxuICAgICAgICAvLyBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3JlIGluLCB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGVcbiAgICAgICAgLy8gbWFnbml0dWRlIG9yZGVyaW5nIG9mIHgwLCB5MCwgejAgYW5kIHcwLiBTaXggcGFpci13aXNlIGNvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgYmV0d2VlblxuICAgICAgICAvLyBlYWNoIHBvc3NpYmxlIHBhaXIgb2YgdGhlIGZvdXIgY29vcmRpbmF0ZXMsIGFuZCB0aGUgcmVzdWx0cyBhcmUgdXNlZCB0byByYW5rIHRoZSBudW1iZXJzLlxuICAgICAgICBsZXQgcmFua3g6IG51bWJlciA9IDA7XG4gICAgICAgIGxldCByYW5reTogbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IHJhbmt6OiBudW1iZXIgPSAwO1xuICAgICAgICBsZXQgcmFua3c6IG51bWJlciA9IDA7XG4gICAgICAgIGlmICh4MCA+IHkwKSByYW5reCsrO1xuICAgICAgICBlbHNlIHJhbmt5Kys7XG4gICAgICAgIGlmICh4MCA+IHowKSByYW5reCsrO1xuICAgICAgICBlbHNlIHJhbmt6Kys7XG4gICAgICAgIGlmICh4MCA+IHcwKSByYW5reCsrO1xuICAgICAgICBlbHNlIHJhbmt3Kys7XG4gICAgICAgIGlmICh5MCA+IHowKSByYW5reSsrO1xuICAgICAgICBlbHNlIHJhbmt6Kys7XG4gICAgICAgIGlmICh5MCA+IHcwKSByYW5reSsrO1xuICAgICAgICBlbHNlIHJhbmt3Kys7XG4gICAgICAgIGlmICh6MCA+IHcwKSByYW5reisrO1xuICAgICAgICBlbHNlIHJhbmt3Kys7XG5cbiAgICAgICAgLy8gc2ltcGxleFtjXSBpcyBhIDQtdmVjdG9yIHdpdGggdGhlIG51bWJlcnMgMCwgMSwgMiBhbmQgMyBpbiBzb21lIG9yZGVyLlxuICAgICAgICAvLyBNYW55IHZhbHVlcyBvZiBjIHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno+dyBtYWtlcyB4PHosIHk8dyBhbmQgeDx3XG4gICAgICAgIC8vIGltcG9zc2libGUuIE9ubHkgdGhlIDI0IGluZGljZXMgd2hpY2ggaGF2ZSBub24temVybyBlbnRyaWVzIG1ha2UgYW55IHNlbnNlLlxuICAgICAgICAvLyBXZSB1c2UgYSB0aHJlc2hvbGRpbmcgdG8gc2V0IHRoZSBjb29yZGluYXRlcyBpbiB0dXJuIGZyb20gdGhlIGxhcmdlc3QgbWFnbml0dWRlLlxuICAgICAgICAvLyBSYW5rIDMgZGVub3RlcyB0aGUgbGFyZ2VzdCBjb29yZGluYXRlLlxuICAgICAgICBjb25zdCBpMTogbnVtYmVyID0gcmFua3ggPj0gMyA/IDEgOiAwO1xuICAgICAgICBjb25zdCBqMTogbnVtYmVyID0gcmFua3kgPj0gMyA/IDEgOiAwO1xuICAgICAgICBjb25zdCBrMTogbnVtYmVyID0gcmFua3ogPj0gMyA/IDEgOiAwO1xuICAgICAgICBjb25zdCBsMTogbnVtYmVyID0gcmFua3cgPj0gMyA/IDEgOiAwO1xuICAgICAgICAvLyBSYW5rIDogMiBkZW5vdGVzIHRoZSBzZWNvbmQgbGFyZ2VzdCBjb29yZGluYXRlLlxuICAgICAgICBjb25zdCBpMjogbnVtYmVyID0gcmFua3ggPj0gMiA/IDEgOiAwO1xuICAgICAgICBjb25zdCBqMjogbnVtYmVyID0gcmFua3kgPj0gMiA/IDEgOiAwO1xuICAgICAgICBjb25zdCBrMjogbnVtYmVyID0gcmFua3ogPj0gMiA/IDEgOiAwO1xuICAgICAgICBjb25zdCBsMjogbnVtYmVyID0gcmFua3cgPj0gMiA/IDEgOiAwO1xuICAgICAgICAvLyBSYW5rIDogMSBkZW5vdGVzIHRoZSBzZWNvbmQgc21hbGxlc3QgY29vcmRpbmF0ZS5cbiAgICAgICAgY29uc3QgaTM6IG51bWJlciA9IHJhbmt4ID49IDEgPyAxIDogMDtcbiAgICAgICAgY29uc3QgajM6IG51bWJlciA9IHJhbmt5ID49IDEgPyAxIDogMDtcbiAgICAgICAgY29uc3QgazM6IG51bWJlciA9IHJhbmt6ID49IDEgPyAxIDogMDtcbiAgICAgICAgY29uc3QgbDM6IG51bWJlciA9IHJhbmt3ID49IDEgPyAxIDogMDtcblxuICAgICAgICAvLyBUaGUgZmlmdGggY29ybmVyIGhhcyBhbGwgY29vcmRpbmF0ZSBvZmZzZXRzID0gMSwgc28gbm8gbmVlZCB0byBjb21wdXRlIHRoYXQuXG4gICAgICAgIGNvbnN0IHgxOiBudW1iZXIgPSB4MCAtIGkxICsgTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2U0Lm9mZnNldDtcbiAgICAgICAgY29uc3QgejE6IG51bWJlciA9IHowIC0gazEgKyBOb2lzZTQub2Zmc2V0O1xuICAgICAgICBjb25zdCB3MTogbnVtYmVyID0gdzAgLSBsMSArIE5vaXNlNC5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHgyOiBudW1iZXIgPSB4MCAtIGkyICsgMi4wICogTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgICAgY29uc3QgeTI6IG51bWJlciA9IHkwIC0gajIgKyAyLjAgKiBOb2lzZTQub2Zmc2V0O1xuICAgICAgICBjb25zdCB6MjogbnVtYmVyID0gejAgLSBrMiArIDIuMCAqIE5vaXNlNC5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHcyOiBudW1iZXIgPSB3MCAtIGwyICsgMi4wICogTm9pc2U0Lm9mZnNldDtcbiAgICAgICAgY29uc3QgeDM6IG51bWJlciA9IHgwIC0gaTMgKyAzLjAgKiBOb2lzZTQub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBmb3VydGggY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgICAgY29uc3QgeTM6IG51bWJlciA9IHkwIC0gajMgKyAzLjAgKiBOb2lzZTQub2Zmc2V0O1xuICAgICAgICBjb25zdCB6MzogbnVtYmVyID0gejAgLSBrMyArIDMuMCAqIE5vaXNlNC5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHczOiBudW1iZXIgPSB3MCAtIGwzICsgMy4wICogTm9pc2U0Lm9mZnNldDtcbiAgICAgICAgY29uc3QgeDQ6IG51bWJlciA9IHgwIC0gMS4wICsgNC4wICogTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgICBjb25zdCB5NDogbnVtYmVyID0geTAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0O1xuICAgICAgICBjb25zdCB6NDogbnVtYmVyID0gejAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0O1xuICAgICAgICBjb25zdCB3NDogbnVtYmVyID0gdzAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0O1xuXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZml2ZSBzaW1wbGV4IGNvcm5lcnNcbiAgICAgICAgY29uc3QgaWk6IG51bWJlciA9IGkgJiAyNTU7XG4gICAgICAgIGNvbnN0IGpqOiBudW1iZXIgPSBqICYgMjU1O1xuICAgICAgICBjb25zdCBrazogbnVtYmVyID0gayAmIDI1NTtcbiAgICAgICAgY29uc3QgbGw6IG51bWJlciA9IGwgJiAyNTU7XG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcbiAgICAgICAgICB0aGlzLnBlcm1baWkgKyB0aGlzLnBlcm1bamogKyB0aGlzLnBlcm1ba2sgKyB0aGlzLnBlcm1bbGxdXV1dICVcbiAgICAgICAgICAzMlxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBnMTogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXG4gICAgICAgICAgdGhpcy5wZXJtW1xuICAgICAgICAgICAgaWkgKyBpMSArIHRoaXMucGVybVtqaiArIGoxICsgdGhpcy5wZXJtW2trICsgazEgKyB0aGlzLnBlcm1bbGwgKyBsMV1dXVxuICAgICAgICAgIF0gJSAzMlxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBnMjogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXG4gICAgICAgICAgdGhpcy5wZXJtW1xuICAgICAgICAgICAgaWkgKyBpMiArIHRoaXMucGVybVtqaiArIGoyICsgdGhpcy5wZXJtW2trICsgazIgKyB0aGlzLnBlcm1bbGwgKyBsMl1dXVxuICAgICAgICAgIF0gJSAzMlxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBnMzogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXG4gICAgICAgICAgdGhpcy5wZXJtW1xuICAgICAgICAgICAgaWkgKyBpMyArIHRoaXMucGVybVtqaiArIGozICsgdGhpcy5wZXJtW2trICsgazMgKyB0aGlzLnBlcm1bbGwgKyBsM11dXVxuICAgICAgICAgIF0gJSAzMlxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBnNDogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXG4gICAgICAgICAgdGhpcy5wZXJtW1xuICAgICAgICAgICAgaWkgKyAxICsgdGhpcy5wZXJtW2pqICsgMSArIHRoaXMucGVybVtrayArIDEgKyB0aGlzLnBlcm1bbGwgKyAxXV1dXG4gICAgICAgICAgXSAlIDMyXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICAgIGNvbnN0IHQwOiBudW1iZXIgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejAgLSB3MCAqIHcwO1xuICAgICAgICBjb25zdCBuMDogbnVtYmVyID0gdDAgPCAwXG4gICAgICAgICAgPyAwLjBcbiAgICAgICAgICA6IE1hdGgucG93KHQwLCA0KSAqIChnMFswXSAqIHgwICsgZzBbMV0gKiB5MCArIGcwWzJdICogejAgKyBnMFszXSAqIHcwKTtcbiAgICAgICAgY29uc3QgdDE6IG51bWJlciA9IDAuNSAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MSAtIHcxICogdzE7XG4gICAgICAgIGNvbnN0IG4xOiBudW1iZXIgPSB0MSA8IDBcbiAgICAgICAgICA/IDAuMFxuICAgICAgICAgIDogTWF0aC5wb3codDEsIDQpICogKGcxWzBdICogeDEgKyBnMVsxXSAqIHkxICsgZzFbMl0gKiB6MSArIGcxWzNdICogdzEpO1xuICAgICAgICBjb25zdCB0MjogbnVtYmVyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyIC0gdzIgKiB3MjtcbiAgICAgICAgY29uc3QgbjI6IG51bWJlciA9IHQyIDwgMFxuICAgICAgICAgID8gMC4wXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MiwgNCkgKiAoZzJbMF0gKiB4MiArIGcyWzFdICogeTIgKyBnMlsyXSAqIHoyICsgZzJbM10gKiB3Mik7XG4gICAgICAgIGNvbnN0IHQzOiBudW1iZXIgPSAwLjUgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejMgLSB3MyAqIHczO1xuICAgICAgICBjb25zdCBuMzogbnVtYmVyID0gdDMgPCAwXG4gICAgICAgICAgPyAwLjBcbiAgICAgICAgICA6IE1hdGgucG93KHQzLCA0KSAqIChnM1swXSAqIHgzICsgZzNbMV0gKiB5MyArIGczWzJdICogejMgKyBnM1szXSAqIHczKTtcbiAgICAgICAgY29uc3QgdDQ6IG51bWJlciA9IDAuNSAtIHg0ICogeDQgLSB5NCAqIHk0IC0gejQgKiB6NCAtIHc0ICogdzQ7XG4gICAgICAgIGNvbnN0IG40OiBudW1iZXIgPSB0NCA8IDBcbiAgICAgICAgICA/IDAuMFxuICAgICAgICAgIDogTWF0aC5wb3codDQsIDQpICogKGc0WzBdICogeDQgKyBnNFsxXSAqIHk0ICsgZzRbMl0gKiB6NCArIGc0WzNdICogdzQpO1xuXG4gICAgICAgIC8vIFN1bSB1cCBhbmQgc2NhbGUgdGhlIHJlc3VsdCB0byBjb3ZlciB0aGUgcmFuZ2UgWy0xLDFdXG4gICAgICAgIHJldHVybiA3Mi4zNzg1NTc2NTE1MzY2NSAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIHNhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgIHJldHVybiB0aGlzLiNzYW1wbGUoX3gsIF95LCBfeiwgX3cpO1xuICAgIH07XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAgKiBTdG9yaW5nIGFuZCBtYW5pcHVsYXRpbmcgcm90YXRpb25zIGluIHRoZSBmb3JtIG9mIHF1YXRlcm5pb25zLlxuICAgICogQ29uc3RydWN0ZWQgb3V0IG9mIHRoZSA0IGNvbXBvbmVudHM6ICh4LCB5LCB6LCB3KS4gTWF0aGVtYXRpY2FsIG5vdGF0aW9uOiB3ICsgeGkgKyB5aiArIHprLlxuICAgICogQSBRdWF0ZXJuaW9uIGNhbiBiZSBkZXNjcmliZWQgd2l0aCBhbiBheGlzIGFuZCBhbmdsZTogKHgsIHksIHopID0gc2luKGFuZ2xlLzIpKmF4aXM7IHcgPSBjb3MoYW5nbGUvMikuXG4gICAgKiByb2xsOiB4LCBwaXRjaDogeSwgeWF3OiB6LiBOb3RlIHRoYXQgb3BlcmF0aW9ucyBhcmUgYWRhcHRlZCB0byB3b3JrIHdpdGggdmVjdG9ycyB3aGVyZSB5IGlzIHVwIGFuZCB6IGlzIGZvcndhcmQuXG4gICAgKiBAYXV0aG9ycyBNYXR0aGlhcyBSb21pbmcsIEhGVSwgMjAyMyB8IE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xuICAgICovXG4gIGV4cG9ydCBjbGFzcyBRdWF0ZXJuaW9uIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgUmVjeWNhYmxlIHtcbiAgICBwdWJsaWMgeDogbnVtYmVyO1xuICAgIHB1YmxpYyB5OiBudW1iZXI7XG4gICAgcHVibGljIHo6IG51bWJlcjtcbiAgICBwdWJsaWMgdzogbnVtYmVyO1xuICAgIHByaXZhdGUgbXV0YXRvcjogTXV0YXRvciA9IG51bGw7IC8vIHByZXBhcmVkIGZvciBvcHRpbWl6YXRpb24sIGtlZXAgbXV0YXRvciB0byByZWR1Y2UgcmVkdW5kYW50IGNhbGN1bGF0aW9uIGFuZCBmb3IgY29tcGFyaXNvbi4gU2V0IHRvIG51bGwgd2hlbiBkYXRhIGNoYW5nZXMhXG4gICAgXG4gICAgcmVhZG9ubHkgI2V1bGVyQW5nbGVzOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7IC8vIGV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcXVhdGVybmlvbiBpbiBkZWdyZWVzLlxuICAgICNldWxlckFuZ2xlc0RpcnR5OiBib29sZWFuO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDAsIF93OiBudW1iZXIgPSAxKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5zZXQoX3gsIF95LCBfeiwgX3cpO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBTVEFUSUNTXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBuZXcgaWRlbnRpdHkgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgSURFTlRJVFkoKTogUXVhdGVybmlvbiB7XG4gICAgICBjb25zdCByZXN1bHQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfcTogUXVhdGVybmlvbik6IFF1YXRlcm5pb24ge1xuICAgICAgY29uc3QgcmVzdWx0OiBRdWF0ZXJuaW9uID0gX3EuY2xvbmU7XG4gICAgICByZXN1bHQubm9ybWFsaXplKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSBhbmdsZXMgZ2l2ZW4uXG4gICAgICogUm90YXRpb24gb2NjdXJzIGFyb3VuZCB0aGUgYXhpcyBpbiB0aGUgb3JkZXIgWi1ZLVguXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTihfZXVsZXJBbmdsZXM6IFZlY3RvcjMpOiBRdWF0ZXJuaW9uIHtcbiAgICAgIGNvbnN0IHJlc3VsdDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcbiAgICAgIHJlc3VsdC5ldWxlckFuZ2xlcyA9IF9ldWxlckFuZ2xlcztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIHBhc3NlZCBxdWF0ZXJuaW9ucy5cbiAgICAgKiBAcGFyYW0gX210eExlZnQgVGhlIHF1YXRlcm5pb24gdG8gbXVsdGlwbHkuXG4gICAgICogQHBhcmFtIF9tdHhSaWdodCBUaGUgcXVhdGVybmlvbiB0byBtdWx0aXBseSBieS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIE1VTFRJUExJQ0FUSU9OKF9xTGVmdDogUXVhdGVybmlvbiwgX3FSaWdodDogUXVhdGVybmlvbik6IFF1YXRlcm5pb24ge1xuICAgICAgY29uc3QgcmVzdWx0OiBRdWF0ZXJuaW9uID0gX3FMZWZ0LmNsb25lO1xuICAgICAgcmVzdWx0Lm11bHRpcGx5KF9xUmlnaHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaW52ZXJzZSBvZiBhIHBhc3NlZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBfbXR4IFRoZSBxdWF0ZXJuaW9uIHRvIGNvbXB1dGUgdGhlIGludmVyc2Ugb2YuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBJTlZFUlNJT04oX3E6IFF1YXRlcm5pb24pOiBRdWF0ZXJuaW9uIHtcbiAgICAgIGNvbnN0IHJlc3VsdDogUXVhdGVybmlvbiA9IF9xLmNsb25lO1xuICAgICAgcmVzdWx0LmludmVyc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHBhc3NlZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBfbXR4IFRoZSBxdWF0ZXJuaW9uIHRvIGNvbXB1dGUgdGhlIGNvbmp1Z2F0ZSBvZi5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIENPTkpVR0FUSU9OKF9xOiBRdWF0ZXJuaW9uKTogUXVhdGVybmlvbiB7XG4gICAgICBjb25zdCByZXN1bHQ6IFF1YXRlcm5pb24gPSBfcS5jbG9uZTtcbiAgICAgIHJlc3VsdC5jb25qdWdhdGUoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXRlcm5pb25zLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgRE9UKF9xMTogUXVhdGVybmlvbiwgX3EyOiBRdWF0ZXJuaW9uKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBfcTEueCAqIF9xMi54ICsgX3ExLnkgKiBfcTIueSArIF9xMS56ICogX3EyLnogKyBfcTEudyAqIF9xMi53O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdGVybmlvbnMgYmFzZWQgb24gdGhlIGdpdmVuIF9mYWN0b3IuIFdoZW4gX2ZhY3RvciBpcyAwIHRoZSByZXN1bHQgaXMgX2Zyb20sIHdoZW4gX2ZhY3RvciBpcyAxIHRoZSByZXN1bHQgaXMgX3RvLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgTEVSUChfZnJvbTogUXVhdGVybmlvbiwgX3RvOiBRdWF0ZXJuaW9uLCBfZmFjdG9yOiBudW1iZXIpOiBRdWF0ZXJuaW9uIHtcbiAgICAgIGxldCByZXN1bHQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XG4gICAgICByZXN1bHQuc2V0KFxuICAgICAgICAoX2Zyb20ueCAqICgxIC0gX2ZhY3RvcikgKyBfdG8ueCAqIF9mYWN0b3IpLFxuICAgICAgICAoX2Zyb20ueSAqICgxIC0gX2ZhY3RvcikgKyBfdG8ueSAqIF9mYWN0b3IpLFxuICAgICAgICAoX2Zyb20ueiAqICgxIC0gX2ZhY3RvcikgKyBfdG8ueiAqIF9mYWN0b3IpLFxuICAgICAgICAoX2Zyb20udyAqICgxIC0gX2ZhY3RvcikgKyBfdG8udyAqIF9mYWN0b3IpXG4gICAgICApO1xuICAgICAgcmVzdWx0Lm5vcm1hbGl6ZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdGVybmlvbnMgYmFzZWQgb24gdGhlIGdpdmVuIF9mYWN0b3IuIFdoZW4gX2ZhY3RvciBpcyAwIHRoZSByZXN1bHQgaXMgX2Zyb20sIHdoZW4gX2ZhY3RvciBpcyAxIHRoZSByZXN1bHQgaXMgX3RvLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFNMRVJQKF9mcm9tOiBRdWF0ZXJuaW9uLCBfdG86IFF1YXRlcm5pb24sIF9mYWN0b3I6IG51bWJlcik6IFF1YXRlcm5pb24ge1xuICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG4gICAgICBsZXQgY29zSGFsZlRoZXRhOiBudW1iZXIgPSBfZnJvbS53ICogX3RvLncgKyBfZnJvbS54ICogX3RvLnggKyBfZnJvbS55ICogX3RvLnkgKyBfZnJvbS56ICogX3RvLno7XG4gICAgICBpZiAoTWF0aC5hYnMoY29zSGFsZlRoZXRhKSA+PSAxKVxuICAgICAgICByZXR1cm4gX2Zyb207XG4gICAgICBsZXQgaGFsZlRoZXRhOiBudW1iZXIgPSBNYXRoLmFjb3MoY29zSGFsZlRoZXRhKTtcbiAgICAgIGxldCBzaW5IYWxmVGhldGE6IG51bWJlciA9IE1hdGguc3FydCgxIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhKTtcbiAgICAgIGlmIChNYXRoLmFicyhzaW5IYWxmVGhldGEpIDwgMC4wMDEpIHtcbiAgICAgICAgbGV0IHJlc3VsdDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAoX2Zyb20ueCAqIDAuNSArIF90by54ICogMC41KSxcbiAgICAgICAgICAoX2Zyb20ueSAqIDAuNSArIF90by55ICogMC41KSxcbiAgICAgICAgICAoX2Zyb20ueiAqIDAuNSArIF90by56ICogMC41KSxcbiAgICAgICAgICAoX2Zyb20udyAqIDAuNSArIF90by53ICogMC41KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IHJhdGlvQTogbnVtYmVyID0gTWF0aC5zaW4oKDEgLSBfZmFjdG9yKSAqIGhhbGZUaGV0YSkgLyBzaW5IYWxmVGhldGE7XG4gICAgICBsZXQgcmF0aW9COiBudW1iZXIgPSBNYXRoLnNpbihfZmFjdG9yICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YTtcbiAgICAgIGxldCByZXN1bHQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XG4gICAgICByZXN1bHQuc2V0KFxuICAgICAgICAoX2Zyb20ueCAqIHJhdGlvQSArIF90by54ICogcmF0aW9CKSxcbiAgICAgICAgKF9mcm9tLnkgKiByYXRpb0EgKyBfdG8ueSAqIHJhdGlvQiksXG4gICAgICAgIChfZnJvbS56ICogcmF0aW9BICsgX3RvLnogKiByYXRpb0IpLFxuICAgICAgICAoX2Zyb20udyAqIHJhdGlvQSArIF90by53ICogcmF0aW9CKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogUXVhdGVybmlvbiB7XG4gICAgICBsZXQgcmVzdWx0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIuZ2V0KFF1YXRlcm5pb24pO1xuICAgICAgcmVzdWx0LnNldCh0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAtIGdldDogcmV0dXJuIHRoZSBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm90YXRpb24gaW4gZGVncmVlcy4gIFxuICAgICAqIC0gc2V0OiBzZXQgdGhlIGV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByb3RhdGlvbiBpbiBkZWdyZWVzLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZXVsZXJBbmdsZXMoKTogVmVjdG9yMyB7XG4gICAgICBpZiAodGhpcy4jZXVsZXJBbmdsZXNEaXJ0eSkge1xuICAgICAgICB0aGlzLiNldWxlckFuZ2xlc0RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMueCA9PSAwICYmIHRoaXMueSA9PSAwICYmIHRoaXMueiA9PSAwICYmIHRoaXMudyA9PSAxKSB7XG4gICAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMuc2V0KDAsIDAsIDApO1xuICAgICAgICAgIHJldHVybiB0aGlzLiNldWxlckFuZ2xlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvbGwgKHgtYXhpcyByb3RhdGlvbilcbiAgICAgICAgbGV0IHNpbnJjb3NwOiBudW1iZXIgPSAyICogKHRoaXMudyAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueik7XG4gICAgICAgIGxldCBjb3NyY29zcDogbnVtYmVyID0gMSAtIDIgKiAodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMueCA9IE1hdGguYXRhbjIoc2lucmNvc3AsIGNvc3Jjb3NwKTtcblxuICAgICAgICAvLyBwaXRjaCAoeS1heGlzIHJvdGF0aW9uKVxuICAgICAgICBsZXQgc2lucDogbnVtYmVyID0gMiAqICh0aGlzLncgKiB0aGlzLnkgLSB0aGlzLnogKiB0aGlzLngpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc2lucCkgPj0gMSlcbiAgICAgICAgICB0aGlzLiNldWxlckFuZ2xlcy55ID0gc2lucCA8IDAgPyAtTWF0aC5hYnMoTWF0aC5QSSAvIDIpIDogTWF0aC5hYnMoTWF0aC5QSSAvIDIpOyAvLyB1c2UgOTAgZGVncmVlcyBpZiBvdXQgb2YgcmFuZ2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnkgPSBNYXRoLmFzaW4oc2lucCk7XG5cbiAgICAgICAgLy8geWF3ICh6LWF4aXMgcm90YXRpb24pXG4gICAgICAgIGxldCBzaW55Y29zcDogbnVtYmVyID0gMiAqICh0aGlzLncgKiB0aGlzLnogKyB0aGlzLnggKiB0aGlzLnkpO1xuICAgICAgICBsZXQgY29zeWNvc3A6IG51bWJlciA9IDEgLSAyICogKHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7XG4gICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnogPSBNYXRoLmF0YW4yKHNpbnljb3NwLCBjb3N5Y29zcCk7XG5cbiAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMuc2NhbGUoQ2FsYy5yYWQyZGVnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuI2V1bGVyQW5nbGVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZXVsZXJBbmdsZXMoX2V1bGVyQW5nbGVzOiBWZWN0b3IzKSB7XG4gICAgICBjb25zdCBoYWxmQW5nbGVzSW5SYWRpYW5zOiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShfZXVsZXJBbmdsZXMsIENhbGMuZGVnMnJhZCAvIDIpO1xuICAgICAgY29uc3QgY29zWDogbnVtYmVyID0gTWF0aC5jb3MoaGFsZkFuZ2xlc0luUmFkaWFucy54KTtcbiAgICAgIGNvbnN0IGNvc1k6IG51bWJlciA9IE1hdGguY29zKGhhbGZBbmdsZXNJblJhZGlhbnMueSk7XG4gICAgICBjb25zdCBjb3NaOiBudW1iZXIgPSBNYXRoLmNvcyhoYWxmQW5nbGVzSW5SYWRpYW5zLnopO1xuICAgICAgY29uc3Qgc2luWDogbnVtYmVyID0gTWF0aC5zaW4oaGFsZkFuZ2xlc0luUmFkaWFucy54KTtcbiAgICAgIGNvbnN0IHNpblk6IG51bWJlciA9IE1hdGguc2luKGhhbGZBbmdsZXNJblJhZGlhbnMueSk7XG4gICAgICBjb25zdCBzaW5aOiBudW1iZXIgPSBNYXRoLnNpbihoYWxmQW5nbGVzSW5SYWRpYW5zLnopO1xuXG4gICAgICB0aGlzLnNldChcbiAgICAgICAgc2luWCAqIGNvc1kgKiBjb3NaIC0gY29zWCAqIHNpblkgKiBzaW5aLFxuICAgICAgICBjb3NYICogc2luWSAqIGNvc1ogKyBzaW5YICogY29zWSAqIHNpblosXG4gICAgICAgIGNvc1ggKiBjb3NZICogc2luWiAtIHNpblggKiBzaW5ZICogY29zWixcbiAgICAgICAgY29zWCAqIGNvc1kgKiBjb3NaICsgc2luWCAqIHNpblkgKiBzaW5aXG4gICAgICApO1xuXG4gICAgICB0aGlzLiNldWxlckFuZ2xlc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHF1YXRlcm5pb24gdG8gYSBsZW5ndGggb2YgMSAoYSB1bml0IHF1YXRlcm5pb24pIG1ha2luZyBpdCBhIHZhbGlkIHJvdGF0aW9uIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgcHVibGljIG5vcm1hbGl6ZSgpOiBRdWF0ZXJuaW9uIHtcbiAgICAgIGxldCBsZW5ndGg6IG51bWJlciA9IE1hdGguc3FydCh0aGlzLnggKiogMiArIHRoaXMueSAqKiAyICsgdGhpcy56ICoqIDIgKyB0aGlzLncgKiogMik7XG4gICAgICB0aGlzLnggLz0gbGVuZ3RoO1xuICAgICAgdGhpcy55IC89IGxlbmd0aDtcbiAgICAgIHRoaXMueiAvPSBsZW5ndGg7XG4gICAgICB0aGlzLncgLz0gbGVuZ3RoO1xuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGUgdGhpcyBxdWF0ZXJuaW9uIGFuZCByZXR1cm5zIGl0XG4gICAgICovXG4gICAgcHVibGljIG5lZ2F0ZSgpOiBRdWF0ZXJuaW9uIHtcbiAgICAgIHRoaXMueCAqPSAtMTtcbiAgICAgIHRoaXMueSAqPSAtMTtcbiAgICAgIHRoaXMueiAqPSAtMTtcbiAgICAgIHRoaXMudyAqPSAtMTtcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBxdWF0ZXJuaW9uIHRvIHRoZSBpZGVudGl0eS1xdWF0ZXJuaW9uIGFuZCBjbGVhcnMgY2FjaGUuIFVzZWQgYnkgdGhlIHJlY3ljbGVyIHRvIHJlc2V0LlxuICAgICAqL1xuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xuICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52ZXJzZSB0aGlzIHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBwdWJsaWMgaW52ZXJzZSgpOiB2b2lkIHtcbiAgICAgIC8vIHF1YXRlcm5pb24gaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG4gICAgICB0aGlzLmNvbmp1Z2F0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmp1Z2F0ZXMgdGhpcyBxdWF0ZXJuaW9uIGFuZCByZXR1cm5zIGl0XG4gICAgICovXG4gICAgcHVibGljIGNvbmp1Z2F0ZSgpOiBRdWF0ZXJuaW9uIHtcbiAgICAgIHRoaXMueCAqPSAtMTtcbiAgICAgIHRoaXMueSAqPSAtMTtcbiAgICAgIHRoaXMueiAqPSAtMTtcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGhpcyBxdWF0ZXJuaW9uIHdpdGggdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBwdWJsaWMgbXVsdGlwbHkoX290aGVyOiBRdWF0ZXJuaW9uLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgY29uc3QgYTogUXVhdGVybmlvbiA9IF9mcm9tTGVmdCA/IF9vdGhlciA6IHRoaXM7XG4gICAgICBjb25zdCBiOiBRdWF0ZXJuaW9uID0gX2Zyb21MZWZ0ID8gdGhpcyA6IF9vdGhlcjtcbiAgICAgIC8vIGZyb206IGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cbiAgICAgIGNvbnN0IGF4OiBudW1iZXIgPSBhLng7XG4gICAgICBjb25zdCBheTogbnVtYmVyID0gYS55O1xuICAgICAgY29uc3QgYXo6IG51bWJlciA9IGEuejtcbiAgICAgIGNvbnN0IGF3OiBudW1iZXIgPSBhLnc7XG4gICAgICBjb25zdCBieDogbnVtYmVyID0gYi54O1xuICAgICAgY29uc3QgYnk6IG51bWJlciA9IGIueTtcbiAgICAgIGNvbnN0IGJ6OiBudW1iZXIgPSBiLno7XG4gICAgICBjb25zdCBidzogbnVtYmVyID0gYi53O1xuXG4gICAgICB0aGlzLnNldChcbiAgICAgICAgYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5ICsgYXcgKiBieCxcbiAgICAgICAgLWF4ICogYnogKyBheSAqIGJ3ICsgYXogKiBieCArIGF3ICogYnksXG4gICAgICAgIGF4ICogYnkgLSBheSAqIGJ4ICsgYXogKiBidyArIGF3ICogYnosXG4gICAgICAgIC1heCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYnogKyBhdyAqIGJ3XG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgcXVhdGVybmlvbiB0byB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgcHVibGljIHNldChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKTogdm9pZCB7XG4gICAgICB0aGlzLnggPSBfeDsgdGhpcy55ID0gX3k7IHRoaXMueiA9IF96OyB0aGlzLncgPSBfdztcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIGDGki5RdWF0ZXJuaW9uKHg6ICR7dGhpcy54fSwgeTogJHt0aGlzLnl9LCB6OiAke3RoaXMuen0sIHc6ICR7dGhpcy53fSlgO1xuICAgIH1cblxuICAgIC8vIGN1cnJlbnRseSBxdWF0ZXJuaW9ucyBhcmUgbmV2ZXIgc2VyaWFsaXplZCwgc28gdGhpcyBpcyBub3QgbmVlZGVkLiBCdXQgbWF5YmUgaXQgd2lsbCBiZSBpbiB0aGUgZnV0dXJlLlxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xuICAgICAgc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgWyR7dGhpcy54fSwgJHt0aGlzLnl9LCAke3RoaXMuen0sICR7dGhpcy53fV1gOyB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxRdWF0ZXJuaW9uPiB7XG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53XSA9IEpTT04ucGFyc2UoPHN0cmluZz48dW5rbm93bj5fc2VyaWFsaXphdGlvbik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICBpZiAoIXRoaXMubXV0YXRvcilcbiAgICAgICAgdGhpcy5tdXRhdG9yID0geyB4OiB0aGlzLngsIHk6IHRoaXMueSwgejogdGhpcy56LCB3OiB0aGlzLncgfTtcbiAgICAgIHJldHVybiB0aGlzLm11dGF0b3I7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgdGhpcy54ID0gX211dGF0b3IueCA/PyB0aGlzLng7XG4gICAgICB0aGlzLnkgPSBfbXV0YXRvci55ID8/IHRoaXMueTtcbiAgICAgIHRoaXMueiA9IF9tdXRhdG9yLnogPz8gdGhpcy56O1xuICAgICAgdGhpcy53ID0gX211dGF0b3IudyA/PyB0aGlzLnc7XG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XG5cbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XG4gICAgICB0aGlzLiNldWxlckFuZ2xlc0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBDbGFzcyBmb3IgY3JlYXRpbmcgcmFuZG9tIHZhbHVlcywgc3VwcG9ydGluZyBKYXZhc2NyaXB0J3MgTWF0aC5yYW5kb20gYW5kIGEgZGV0ZXJtaW5pc3RpZyBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgKFBSTkcpIFxuICAgKiB0aGF0IGNhbiBiZSBmZWQgd2l0aCBhIHNlZWQgYW5kIHRoZW4gcmV0dXJucyBhIHJlcHJvZHVjYWJsZSBzZXQgb2YgcmFuZG9tIG51bWJlcnMgKGlmIHRoZSBwcmVjaXNpb24gb2YgSmF2YXNjcmlwdCBhbGxvd3MpIFxuICAgKiBcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJhbmRvbSB7XG4gICAgcHVibGljIHN0YXRpYyBkZWZhdWx0OiBSYW5kb20gPSBuZXcgUmFuZG9tKCk7XG4gICAgcHJpdmF0ZSBnZW5lcmF0ZTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUmFuZG9tfS4gXG4gICAgICogSWYgYSBzZWVkIGlzIGdpdmVuLCBMRklCNCBpcyB1c2VkIGFzIGdlbmVyYXRvciwgcmVwcm9kdWNpbmcgYSBzZXJpZXMgb2YgbnVtYmVycyBmcm9tIHRoYXQgc2VlZC5cbiAgICAgKiBJZiBhIGZ1bmN0aW9uIHByb2R1Y2luZyB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWQgYXMgZ2VuZXJhdG9yLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihfc2VlZE9yRnVuY3Rpb24/OiBudW1iZXIgfCBGdW5jdGlvbikge1xuICAgICAgaWYgKF9zZWVkT3JGdW5jdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICB0aGlzLmdlbmVyYXRlID0gX3NlZWRPckZ1bmN0aW9uO1xuICAgICAgZWxzZSBpZiAoX3NlZWRPckZ1bmN0aW9uID09IHVuZGVmaW5lZClcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IE1hdGgucmFuZG9tO1xuICAgICAgZWxzZVxuICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IG5ldyBMRklCNChfc2VlZE9yRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBub3JtZWQgcmFuZG9tIG51bWJlciwgdGh1cyBpbiB0aGUgcmFuZ2Ugb2YgWzAsIDFbXG4gICAgICovXG4gICAgcHVibGljIGdldE5vcm0oKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgaW4gdGhlIHJhbmdlIG9mIGdpdmVuIFtfbWluLCBfbWF4W1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRSYW5nZShfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICByZXR1cm4gX21pbiArIHRoaXMuZ2VuZXJhdGUoKSAqIChfbWF4IC0gX21pbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBpbiB0aGUgcmFuZ2Ugb2YgZ2l2ZW4gZmxvb3JlZCBbX21pbiwgX21heFtcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UmFuZ2VGbG9vcmVkKF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZ2V0UmFuZ2UoX21pbiwgX21heCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSByYW5kb21seVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRCb29sZWFuKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUoKSA8IDAuNTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIC0xIG9yIDEgcmFuZG9tbHlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U2lnbigpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9vbGVhbigpID8gMSA6IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBpbmRleCBpbnRvIHRoZSBnaXZlbiBhcnJheVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRJbmRleDxUPihfYXJyYXk6IEFycmF5PFQ+KTogbnVtYmVyIHtcbiAgICAgIGlmIChfYXJyYXkubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VGbG9vcmVkKDAsIF9hcnJheS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBlbGVtZW50IG9mIHRoZSBnaXZlbiBhcnJheVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFbGVtZW50PFQ+KF9hcnJheTogQXJyYXk8VD4pOiBUIHtcbiAgICAgIGlmIChfYXJyYXkubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuIF9hcnJheVt0aGlzLmdldEluZGV4KF9hcnJheSldO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHJhbmRvbWx5IHNlbGVjdGVkIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXRcbiAgICAgKi9cbiAgICBwdWJsaWMgc3BsaWNlPFQ+KF9hcnJheTogQXJyYXk8VD4pOiBUIHtcbiAgICAgIHJldHVybiBfYXJyYXkuc3BsaWNlKHRoaXMuZ2V0SW5kZXgoX2FycmF5KSwgMSlbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIGtleSBmcm9tIHRoZSBnaXZlbiBNYXAtaW5zdGFuY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0S2V5PFQsIFU+KF9tYXA6IE1hcDxULCBVPik6IFQge1xuICAgICAgbGV0IGtleXM6IEdlbmVyYWwgPSBBcnJheS5mcm9tKF9tYXAua2V5cygpKTtcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBwcm9wZXJ0eSBuYW1lIGZyb20gdGhlIGdpdmVuIG9iamVjdFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRQcm9wZXJ0eU5hbWU8VD4oX29iamVjdDogVCk6IGtleW9mIFQge1xuICAgICAgbGV0IGtleXM6IHN0cmluZ1tdID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoX29iamVjdCk7XG4gICAgICByZXR1cm4gPGtleW9mIFQ+a2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQgc3ltYm9sIGZyb20gdGhlIGdpdmVuIG9iamVjdCwgaWYgc3ltYm9scyBhcmUgdXNlZCBhcyBrZXlzXG4gICAgICovXG4gICAgcHVibGljIGdldFByb3BlcnR5U3ltYm9sPFQ+KF9vYmplY3Q6IFQpOiBzeW1ib2wge1xuICAgICAgbGV0IGtleXM6IHN5bWJvbFtdID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhfb2JqZWN0KTtcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gdGhyZWUtZGltZW5zaW9uYWwgdmVjdG9yIGluIHRoZSBsaW1pdHMgb2YgdGhlIGJveCBkZWZpbmVkIGJ5IHRoZSB2ZWN0b3JzIGdpdmVuIGFzIFtfY29ybmVyMCwgX2Nvcm5lcjFbXG4gICAgICovXG4gICAgcHVibGljIGdldFZlY3RvcjMoX2Nvcm5lcjA6IFZlY3RvcjMsIF9jb3JuZXIxOiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy5nZXRSYW5nZShfY29ybmVyMC54LCBfY29ybmVyMS54KSwgdGhpcy5nZXRSYW5nZShfY29ybmVyMC55LCBfY29ybmVyMS55KSwgdGhpcy5nZXRSYW5nZShfY29ybmVyMC56LCBfY29ybmVyMS56KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB0d28tZGltZW5zaW9uYWwgdmVjdG9yIGluIHRoZSBsaW1pdHMgb2YgdGhlIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHRoZSB2ZWN0b3JzIGdpdmVuIGFzIFtfY29ybmVyMCwgX2Nvcm5lcjFbXG4gICAgICovXG4gICAgcHVibGljIGdldFZlY3RvcjIoX2Nvcm5lcjA6IFZlY3RvcjIsIF9jb3JuZXIxOiBWZWN0b3IyKTogVmVjdG9yMiB7XG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy5nZXRSYW5nZShfY29ybmVyMC54LCBfY29ybmVyMS54KSwgdGhpcy5nZXRSYW5nZShfY29ybmVyMC55LCBfY29ybmVyMS55KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIHtAbGluayBSYW5kb219LWluc3RhbmNlIHVzaW5nIE1hdGgucmFuZG9tKCkuXG4gICAqL1xuICBleHBvcnQgY29uc3QgcmFuZG9tOiBSYW5kb20gPSBuZXcgUmFuZG9tKCk7XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgdGhyZWVkaW1lbnNpb25hbCB2ZWN0b3IgY29tcHJpc2VkIG9mIHRoZSBjb21wb25lbnRzIHgsIHkgYW5kIHpcbiAgICogYGBgdGV4dFxuICAgKiAgICAgICAgICAgICt5XG4gICAqICAgICAgICAgICAgIHxfXyAreFxuICAgKiAgICAgICAgICAgIC9cbiAgICogICAgICAgICAgK3ogICBcbiAgICogYGBgXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTktMjAyMiB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFZlY3RvcjMgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xuICAgIHByaXZhdGUgZGF0YTogRmxvYXQzMkFycmF5OyAvLyBUT0RPOiBjaGVjayB3aHkgdGhpcyBzaG91bGRuJ3QgYmUgeCx5LHogYXMgbnVtYmVycy4uLlxuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDApIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfeCwgX3ksIF96XSk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFN0YXRpY1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoIHBvaW50aW5nIGluIHgtZGlyZWN0aW9uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBYKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgdmVjdG9yLnNldChfc2NhbGUsIDAsIDApO1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGxlbmd0aCBwb2ludGluZyBpbiB5LWRpcmVjdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgWShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcbiAgICAgIHZlY3Rvci5zZXQoMCwgX3NjYWxlLCAwKTtcbiAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4gei1kaXJlY3Rpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFooX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICB2ZWN0b3IuZGF0YS5zZXQoWzAsIDAsIF9zY2FsZV0pO1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIHZhbHVlIDAgb24gZWFjaCBheGlzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBaRVJPKCk6IFZlY3RvcjMge1xuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgdmVjdG9yLnNldCgwLCAwLCAwKTtcbiAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciBvZiB0aGUgZ2l2ZW4gc2l6ZSBvbiBlYWNoIG9mIHRoZSB0aHJlZSBheGlzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBPTkUoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICB2ZWN0b3Iuc2V0KF9zY2FsZSwgX3NjYWxlLCBfc2NhbGUpO1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3IgdGhyb3VnaCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IHRoZSBnaXZlbiBtYXRyaXggb3Igcm90YXRpb24gcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TRk9STUFUSU9OKF92ZWN0b3I6IFZlY3RvcjMsIF90cmFuc2Zvcm06IE1hdHJpeDR4NCB8IFF1YXRlcm5pb24sIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMyB7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgbGV0IFt4LCB5LCB6XSA9IF92ZWN0b3IuZ2V0KCk7XG5cbiAgICAgIGlmIChfdHJhbnNmb3JtIGluc3RhbmNlb2YgTWF0cml4NHg0KSB7XG4gICAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfdHJhbnNmb3JtLmdldCgpO1xuXG4gICAgICAgIHJlc3VsdC54ID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6O1xuICAgICAgICByZXN1bHQueSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogejtcbiAgICAgICAgcmVzdWx0LnogPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6O1xuXG4gICAgICAgIGlmIChfaW5jbHVkZVRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChfdHJhbnNmb3JtLnRyYW5zbGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvdHJhbnNmb3Jtcy9pbmRleC5odG1cbiAgICAgICAgLy8gcmVzdWx0ID0gcSAqIHF1YXRlcm5pb24odmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiwgMCkgKiBjb25qKHEpXG4gICAgICAgIC8vIGNvbnN0IHE6IG51bWJlcltdID0gX3RyYW5zZm9ybS5nZXQoKTtcblxuICAgICAgICAvLyBxICogcXVhdGVybmlvbih2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56LCAwKSAuLi5cbiAgICAgICAgY29uc3QgcXg6IG51bWJlciA9IF90cmFuc2Zvcm0udyAqIHggKyBfdHJhbnNmb3JtLnkgKiB6IC0gX3RyYW5zZm9ybS56ICogeTtcbiAgICAgICAgY29uc3QgcXk6IG51bWJlciA9IF90cmFuc2Zvcm0udyAqIHkgKyBfdHJhbnNmb3JtLnogKiB4IC0gX3RyYW5zZm9ybS54ICogejtcbiAgICAgICAgY29uc3QgcXo6IG51bWJlciA9IF90cmFuc2Zvcm0udyAqIHogKyBfdHJhbnNmb3JtLnggKiB5IC0gX3RyYW5zZm9ybS55ICogeDtcbiAgICAgICAgY29uc3QgcXc6IG51bWJlciA9IC1fdHJhbnNmb3JtLnggKiB4IC0gX3RyYW5zZm9ybS55ICogeSAtIF90cmFuc2Zvcm0ueiAqIHo7XG5cbiAgICAgICAgLy8gLi4uICogY29uaihxKVxuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgIHF4ICogX3RyYW5zZm9ybS53ICsgcXcgKiAtIF90cmFuc2Zvcm0ueCArIHF5ICogLSBfdHJhbnNmb3JtLnogLSBxeiAqIC0gX3RyYW5zZm9ybS55LFxuICAgICAgICAgIHF5ICogX3RyYW5zZm9ybS53ICsgcXcgKiAtIF90cmFuc2Zvcm0ueSArIHF6ICogLSBfdHJhbnNmb3JtLnggLSBxeCAqIC0gX3RyYW5zZm9ybS56LFxuICAgICAgICAgIHF6ICogX3RyYW5zZm9ybS53ICsgcXcgKiAtIF90cmFuc2Zvcm0ueiArIHF4ICogLSBfdHJhbnNmb3JtLnkgLSBxeSAqIC0gX3RyYW5zZm9ybS54XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aGljaCBpcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgdG8gdGhlIGdpdmVuIGxlbmd0aFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XG4gICAgICBsZXQgbWFnbml0dWRlU3F1YXJlZDogbnVtYmVyID0gX3ZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkO1xuICAgICAgaWYgKG1hZ25pdHVkZVNxdWFyZWQgPT0gMClcbiAgICAgICAgdGhyb3cgKG5ldyBSYW5nZUVycm9yKFwiSW1wb3NzaWJsZSBub3JtYWxpemF0aW9uXCIpKTtcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBfdmVjdG9yLmNsb25lO1xuICAgICAgdmVjdG9yLnNjYWxlKF9sZW5ndGggLyBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZCkpO1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgdmVjdG9yIGF0dGFpbmVkIGJ5IGFkZGl0aW9uIG9mIGFsbCBnaXZlbiB2ZWN0b3JzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgU1VNKC4uLl92ZWN0b3JzOiBWZWN0b3IzW10pOiBWZWN0b3IzIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICBmb3IgKGxldCB2ZWN0b3Igb2YgX3ZlY3RvcnMpXG4gICAgICAgIHJlc3VsdC5zZXQocmVzdWx0LnggKyB2ZWN0b3IueCwgcmVzdWx0LnkgKyB2ZWN0b3IueSwgcmVzdWx0LnogKyB2ZWN0b3Iueik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24gb2YgdHdvIHZlY3RvcnMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBESUZGRVJFTkNFKF9taW51ZW5kOiBWZWN0b3IzLCBfc3VidHJhaGVuZDogVmVjdG9yMyk6IFZlY3RvcjMge1xuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcbiAgICAgIHZlY3Rvci5zZXQoX21pbnVlbmQueCAtIF9zdWJ0cmFoZW5kLngsIF9taW51ZW5kLnkgLSBfc3VidHJhaGVuZC55LCBfbWludWVuZC56IC0gX3N1YnRyYWhlbmQueik7XG4gICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gc2NhbGluZyBmYWN0b3JcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFNDQUxFKF92ZWN0b3I6IFZlY3RvcjMsIF9zY2FsaW5nOiBudW1iZXIpOiBWZWN0b3IzIHtcbiAgICAgIGxldCBzY2FsZWQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICBzY2FsZWQuc2V0KF92ZWN0b3IueCAqIF9zY2FsaW5nLCBfdmVjdG9yLnkgKiBfc2NhbGluZywgX3ZlY3Rvci56ICogX3NjYWxpbmcpO1xuICAgICAgcmV0dXJuIHNjYWxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgY3Jvc3Nwcm9kdWN0IG9mIDIgdmVjdG9ycy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIENST1NTKF9hOiBWZWN0b3IzLCBfYjogVmVjdG9yMyk6IFZlY3RvcjMge1xuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcbiAgICAgIHZlY3Rvci5zZXQoXG4gICAgICAgIF9hLnkgKiBfYi56IC0gX2EueiAqIF9iLnksXG4gICAgICAgIF9hLnogKiBfYi54IC0gX2EueCAqIF9iLnosXG4gICAgICAgIF9hLnggKiBfYi55IC0gX2EueSAqIF9iLnhcbiAgICAgICk7XG4gICAgICByZXR1cm4gdmVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90cHJvZHVjdCBvZiAyIHZlY3RvcnMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBET1QoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzKTogbnVtYmVyIHtcbiAgICAgIGxldCBzY2FsYXJQcm9kdWN0OiBudW1iZXIgPSBfYS54ICogX2IueCArIF9hLnkgKiBfYi55ICsgX2EueiAqIF9iLno7XG4gICAgICByZXR1cm4gc2NhbGFyUHJvZHVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBpbmNvbWluZyB2ZWN0b3IgYXQgdGhlIGdpdmVuIG5vcm1hbCB2ZWN0b3IuIFRoZSBsZW5ndGggb2Ygbm9ybWFsIHNob3VsZCBiZSAxLlxuICAgICAqICAgICBfX19fX19fX19fX19fX19fX19cbiAgICAgKiAgICAgICAgICAgL3xcXFxuICAgICAqIGluY29taW5nIC8gfCBcXCByZWZsZWN0aW9uXG4gICAgICogICAgICAgICAvICB8ICBcXCAgIFxuICAgICAqICAgICAgICAgIG5vcm1hbFxuICAgICAqIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgUkVGTEVDVElPTihfaW5jb21pbmc6IFZlY3RvcjMsIF9ub3JtYWw6IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICAgIGxldCBkb3Q6IG51bWJlciA9IC1WZWN0b3IzLkRPVChfaW5jb21pbmcsIF9ub3JtYWwpO1xuICAgICAgbGV0IHJlZmxlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLlNVTShfaW5jb21pbmcsIFZlY3RvcjMuU0NBTEUoX25vcm1hbCwgMiAqIGRvdCkpO1xuICAgICAgcmV0dXJuIHJlZmxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGUgZGl2aWRlbmQgYnkgdGhlIGRpdmlzb3IgY29tcG9uZW50IGJ5IGNvbXBvbmVudCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBSQVRJTyhfZGl2aWRlbmQ6IFZlY3RvcjMsIF9kaXZpc29yOiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgdmVjdG9yLnNldChfZGl2aWRlbmQueCAvIF9kaXZpc29yLngsIF9kaXZpZGVuZC55IC8gX2Rpdmlzb3IueSwgX2RpdmlkZW5kLnogLyBfZGl2aXNvci56KTtcbiAgICAgIHJldHVybiB2ZWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhcnRlc2lhbiB2ZWN0b3IgZnJvbSBnZW9ncmFwaGljIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBHRU8oX2xvbmdpdHVkZTogbnVtYmVyID0gMCwgX2xhdGl0dWRlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgbGV0IGdlbzogR2VvMyA9IFJlY3ljbGVyLmdldChHZW8zKTtcbiAgICAgIGdlby5zZXQoX2xvbmdpdHVkZSwgX2xhdGl0dWRlLCBfbWFnbml0dWRlKTtcbiAgICAgIHZlY3Rvci5nZW8gPSBnZW87XG4gICAgICBSZWN5Y2xlci5zdG9yZShnZW8pO1xuICAgICAgcmV0dXJuIHZlY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFuZ2xlIGluIGRlZ3JlZXMgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHZlY3RvcnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIEFOR0xFKF9mcm9tOiBWZWN0b3IzLCBfdG86IFZlY3RvcjMpOiBudW1iZXIge1xuICAgICAgbGV0IGFuZ2xlOiBudW1iZXIgPSBNYXRoLmFjb3MoVmVjdG9yMy5ET1QoX2Zyb20sIF90bykgLyAoX2Zyb20ubWFnbml0dWRlICogX3RvLm1hZ25pdHVkZSkpO1xuICAgICAgcmV0dXJuIGFuZ2xlICogQ2FsYy5yYWQyZGVnO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBBY2Nlc3NvcnNcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgZXF1YWxzLWZ1bmN0aW9uc1xuICAgIHB1YmxpYyBnZXQgeCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVswXTtcbiAgICB9XG4gICAgcHVibGljIGdldCB5KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzFdO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHooKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMl07XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB4KF94OiBudW1iZXIpIHtcbiAgICAgIHRoaXMuZGF0YVswXSA9IF94O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHkoX3k6IG51bWJlcikge1xuICAgICAgdGhpcy5kYXRhWzFdID0gX3k7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgeihfejogbnVtYmVyKSB7XG4gICAgICB0aGlzLmRhdGFbMl0gPSBfejtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gTWF0aC5oeXBvdCguLi50aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3Igd2l0aG91dCBjYWxjdWxhdGluZyBhIHNxdWFyZSByb290LiBGYXN0ZXIgZm9yIHNpbXBsZSBwcm94aW1pdHkgZXZhbHVhdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1hZ25pdHVkZVNxdWFyZWQoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBWZWN0b3IzLkRPVCh0aGlzLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyB2ZWN0b3JcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IFZlY3RvcjMge1xuICAgICAgbGV0IGNsb25lOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgY2xvbmUuZGF0YS5zZXQodGhpcy5kYXRhKTtcbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAtIGdldDogcmV0dXJucyBhIGdlb2dyYXBoaWMgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3IgIFxuICAgICAqIC0gc2V0OiBhZGp1c3QgdGhlIGNhcnRlc2lhbiB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3IgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiBhcyBnZW9ncmFwaGljIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgcHVibGljIHNldCBnZW8oX2dlbzogR2VvMykge1xuICAgICAgdGhpcy5zZXQoMCwgMCwgX2dlby5tYWduaXR1ZGUpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oTWF0cml4NHg0LlJPVEFUSU9OX1goLV9nZW8ubGF0aXR1ZGUpKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5ST1RBVElPTl9ZKF9nZW8ubG9uZ2l0dWRlKSk7XG4gICAgfVxuICAgIHB1YmxpYyBnZXQgZ2VvKCk6IEdlbzMge1xuICAgICAgbGV0IGdlbzogR2VvMyA9IFJlY3ljbGVyLmdldChHZW8zKTtcbiAgICAgIGdlby5tYWduaXR1ZGUgPSB0aGlzLm1hZ25pdHVkZTtcblxuICAgICAgaWYgKGdlby5tYWduaXR1ZGUgPT09IDApXG4gICAgICAgIHJldHVybiBnZW87XG5cbiAgICAgIGdlby5sb25naXR1ZGUgPSAxODAgKiBNYXRoLmF0YW4yKHRoaXMueCAvIGdlby5tYWduaXR1ZGUsIHRoaXMueiAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcbiAgICAgIGdlby5sYXRpdHVkZSA9IDE4MCAqIE1hdGguYXNpbih0aGlzLnkgLyBnZW8ubWFnbml0dWRlKSAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gZ2VvO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhLnNldChbMCwgMCwgMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiB2ZWN0b3IgaW50byB0aGlzXG4gICAgICovXG4gICAgcHVibGljIGNvcHkoX29yaWdpbmFsOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgICB0aGlzLmRhdGEuc2V0KF9vcmlnaW5hbC5kYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IgYXJlIHRvIGJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsIHdpdGhpbiB0aGUgZ2l2ZW4gdG9sZXJhbmNlXG4gICAgICogVE9ETzogZXhhbWluZSwgaWYgdG9sZXJhbmNlIGFzIGNyaXRlcml1bSBmb3IgdGhlIGRpZmZlcmVuY2UgaXMgYXBwcm9wcmlhdGUgd2l0aCB2ZXJ5IGxhcmdlIGNvb3JkaW5hdGUgdmFsdWVzIG9yIGlmIF90b2xlcmFuY2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgYnkgY29vcmRpbmF0ZSB2YWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBlcXVhbHMoX2NvbXBhcmU6IFZlY3RvcjMsIF90b2xlcmFuY2U6IG51bWJlciA9IE51bWJlci5FUFNJTE9OKTogYm9vbGVhbiB7XG4gICAgICBpZiAoTWF0aC5hYnModGhpcy54IC0gX2NvbXBhcmUueCkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoTWF0aC5hYnModGhpcy55IC0gX2NvbXBhcmUueSkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoTWF0aC5hYnModGhpcy56IC0gX2NvbXBhcmUueikgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGRlc2NyaWJlZCBieSB0aGlzIGlzIHdpdGhpbiBhIGN1YmUgd2l0aCB0aGUgb3Bwb3NpdGUgY29ybmVycyAxIGFuZCAyXG4gICAgICovXG4gICAgcHVibGljIGlzSW5zaWRlQ3ViZShfY29ybmVyMTogVmVjdG9yMywgX2Nvcm5lcjI6IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICAgIGxldCBkaWFnb25hbDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfY29ybmVyMiwgX2Nvcm5lcjEpO1xuICAgICAgbGV0IHJlbGF0aXZlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMsIF9jb3JuZXIxKTtcbiAgICAgIGxldCByYXRpbzogVmVjdG9yMyA9IFZlY3RvcjMuUkFUSU8ocmVsYXRpdmUsIGRpYWdvbmFsKTtcbiAgICAgIGlmIChyYXRpby54ID4gMSB8fCByYXRpby54IDwgMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHJhdGlvLnkgPiAxIHx8IHJhdGlvLnkgPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAocmF0aW8ueiA+IDEgfHwgcmF0aW8ueiA8IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZGVzY3JpYmVkIGJ5IHRoaXMgaXMgd2l0aGluIGEgc3BoZXJlIHdpdGggdGhlIGdpdmVuIGNlbnRlciBhbmQgcmFkaXVzXG4gICAgICovXG4gICAgcHVibGljIGlzSW5zaWRlU3BoZXJlKF9jZW50ZXI6IFZlY3RvcjMsIF9yYWRpdXM6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX2NlbnRlcik7XG4gICAgICByZXR1cm4gZGlmZmVyZW5jZS5tYWduaXR1ZGVTcXVhcmVkIDwgKF9yYWRpdXMgKiBfcmFkaXVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBhZGQoX2FkZGVuZDogVmVjdG9yMyk6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhLnNldChbX2FkZGVuZC54ICsgdGhpcy54LCBfYWRkZW5kLnkgKyB0aGlzLnksIF9hZGRlbmQueiArIHRoaXMuel0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gdmVjdG9yIGZyb20gdGhpc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdWJ0cmFjdChfc3VidHJhaGVuZDogVmVjdG9yMyk6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy54IC0gX3N1YnRyYWhlbmQueCwgdGhpcy55IC0gX3N1YnRyYWhlbmQueSwgdGhpcy56IC0gX3N1YnRyYWhlbmQuel0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gc2NhbGFyXG4gICAgICovXG4gICAgcHVibGljIHNjYWxlKF9zY2FsYXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhLnNldChbX3NjYWxhciAqIHRoaXMueCwgX3NjYWxhciAqIHRoaXMueSwgX3NjYWxhciAqIHRoaXMuel0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhpcyB0byB0aGUgZ2l2ZW4gbGVuZ3RoLCAxIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBwdWJsaWMgbm9ybWFsaXplKF9sZW5ndGg6IG51bWJlciA9IDEpOiB2b2lkIHtcbiAgICAgIHRoaXMuZGF0YSA9IFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLCBfbGVuZ3RoKS5kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyc1xuICAgICAqL1xuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCk6IHZvaWQge1xuICAgICAgdGhpcy5kYXRhWzBdID0gX3g7XG4gICAgICB0aGlzLmRhdGFbMV0gPSBfeTtcbiAgICAgIHRoaXMuZGF0YVsyXSA9IF96O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyB2ZWN0b3IgYXMgYSBuZXcgRmxvYXQzMkFycmF5IChjb3B5KVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4IG9yIHJvdGF0aW9uIHF1YXRlcm5pb24uIFxuICAgICAqIEluY2x1ZGluZyBvciBleGx1ZGluZyB0aGUgdHJhbnNsYXRpb24gaWYgYSBtYXRyaXggaXMgcGFzc2VkLlxuICAgICAqIEluY2x1ZGluZyBpcyB0aGUgZGVmYXVsdCwgZXhjbHVkaW5nIHdpbGwgb25seSByb3RhdGUgYW5kIHNjYWxlIHRoaXMgdmVjdG9yLlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX3RyYW5zZm9ybTogTWF0cml4NHg0IHwgUXVhdGVybmlvbiwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgIGxldCB0cmFuc2Zvcm1lZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcywgX3RyYW5zZm9ybSwgX2luY2x1ZGVUcmFuc2xhdGlvbik7XG4gICAgICB0aGlzLmRhdGEuc2V0KHRyYW5zZm9ybWVkLmRhdGEpO1xuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNmb3JtZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyb3BzIHRoZSB6LWNvbXBvbmVudCBhbmQgcmV0dXJucyBhIFZlY3RvcjIgY29uc2lzdGluZyBvZiB0aGUgeC0gYW5kIHktY29tcG9uZW50c1xuICAgICAqL1xuICAgIHB1YmxpYyB0b1ZlY3RvcjIoKTogVmVjdG9yMiB7XG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZmxlY3RzIHRoaXMgdmVjdG9yIGF0IGEgZ2l2ZW4gbm9ybWFsLiBTZWUge0BsaW5rIFZlY3RvcjMuUkVGTEVDVElPTn1cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVmbGVjdChfbm9ybWFsOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgICBjb25zdCByZWZsZWN0ZWQ6IFZlY3RvcjMgPSBWZWN0b3IzLlJFRkxFQ1RJT04odGhpcywgX25vcm1hbCk7XG4gICAgICB0aGlzLnNldChyZWZsZWN0ZWQueCwgcmVmbGVjdGVkLnksIHJlZmxlY3RlZC56KTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlZmxlY3RlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2h1ZmZsZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3JcbiAgICAgKi9cbiAgICBwdWJsaWMgc2h1ZmZsZSgpOiB2b2lkIHtcbiAgICAgIGxldCBhOiBudW1iZXJbXSA9IEFycmF5LmZyb20odGhpcy5kYXRhKTtcbiAgICAgIHRoaXMuc2V0KFJhbmRvbS5kZWZhdWx0LnNwbGljZShhKSwgUmFuZG9tLmRlZmF1bHQuc3BsaWNlKGEpLCBhWzBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXd0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIGdpdmVuIHZlY3RvclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXREaXN0YW5jZShfdG86IFZlY3RvcjMpOiBudW1iZXIge1xuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX3RvKTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGRpZmZlcmVuY2UpO1xuICAgICAgcmV0dXJuIGRpZmZlcmVuY2UubWFnbml0dWRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWluaW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yXG4gICAgICovXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMyk6IHZvaWQge1xuICAgICAgdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCBfY29tcGFyZS54KTtcbiAgICAgIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgX2NvbXBhcmUueSk7XG4gICAgICB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIF9jb21wYXJlLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBkaW1lbnNpb24sIG1vdmVzIHRoZSBjb21wb25lbnQgdG8gdGhlIG1heGltdW0gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvclxuICAgICAqL1xuICAgIHB1YmxpYyBtYXgoX2NvbXBhcmU6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAgIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgX2NvbXBhcmUueCk7XG4gICAgICB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIF9jb21wYXJlLnkpO1xuICAgICAgdGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCBfY29tcGFyZS56KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvclxuICAgICAqL1xuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYCgke3RoaXMueC50b1ByZWNpc2lvbig1KX0sICR7dGhpcy55LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnoudG9QcmVjaXNpb24oNSl9KWA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIHN0YW5kYXJkIGFycmF5Lm1hcCBmdW5jdGlvbmFsaXR5IHRvIHBlcmZvcm0gdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yXG4gICAgICogYW5kIHJldHVybiBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgcmVzdWx0c1xuICAgICAqL1xuICAgIHB1YmxpYyBtYXAoX2Z1bmN0aW9uOiAodmFsdWU6IG51bWJlciwgaW5kZXg6IG51bWJlciwgYXJyYXk6IEZsb2F0MzJBcnJheSkgPT4gbnVtYmVyKTogVmVjdG9yMyB7XG4gICAgICBsZXQgY29weTogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcbiAgICAgIGNvcHkuZGF0YSA9IHRoaXMuZGF0YS5tYXAoX2Z1bmN0aW9uKTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xuICAgICAgLy8gc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgeyBcInJcIjogJHt0aGlzLnJ9LCBcImdcIjogJHt0aGlzLmd9LCBcImJcIjogJHt0aGlzLmJ9LCBcImFcIjogJHt0aGlzLmF9fWA7IH07XG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnh9LCAke3RoaXMueX0sICR7dGhpcy56fV1gOyB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxWZWN0b3IzPiB7XG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMuel0gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHRoaXMuZGF0YVswXSA9IF9tdXRhdG9yLnggPz8gdGhpcy5kYXRhWzBdO1xuICAgICAgdGhpcy5kYXRhWzFdID0gX211dGF0b3IueSA/PyB0aGlzLmRhdGFbMV07XG4gICAgICB0aGlzLmRhdGFbMl0gPSBfbXV0YXRvci56ID8/IHRoaXMuZGF0YVsyXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0geyB4OiB0aGlzLmRhdGFbMF0sIHk6IHRoaXMuZGF0YVsxXSwgejogdGhpcy5kYXRhWzJdIH07XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxuICAgIC8vI2VuZHJlZ2lvbiBUcmFuc2ZlclxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgYSBmYWNlIG9mIGEge0BsaW5rIE1lc2h9IGJ5IHJlZmVyZW5jaW5nIHRocmVlIHtAbGluayBWZXJ0aWNlc30gd2l0aCB0aGVpciBpbmRpemVzXG4gICAqIGFuZCBjYWxjdWxhdGVzIGZhY2Ugbm9ybWFscy5cbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBGYWNlIHtcbiAgICBwdWJsaWMgaW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBwdWJsaWMgbm9ybWFsVW5zY2FsZWQ6IFZlY3RvcjM7XG4gICAgcHVibGljIG5vcm1hbDogVmVjdG9yMztcbiAgICBwcml2YXRlIHZlcnRpY2VzOiBWZXJ0aWNlcztcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdmVydGljZXM6IFZlcnRpY2VzLCBfaW5kZXgwOiBudW1iZXIsIF9pbmRleDE6IG51bWJlciwgX2luZGV4MjogbnVtYmVyKSB7XG4gICAgICB0aGlzLmluZGljZXMgPSBbX2luZGV4MCwgX2luZGV4MSwgX2luZGV4Ml07XG4gICAgICB0aGlzLnZlcnRpY2VzID0gX3ZlcnRpY2VzO1xuICAgICAgdGhpcy5jYWxjdWxhdGVOb3JtYWxzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHZlcnRleCByZWZlcmVuY2VkIGJ5IHRoZSBnaXZlbiBpbmRleFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRQb3NpdGlvbihfaW5kZXg6IG51bWJlcik6IFZlY3RvcjMge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMucG9zaXRpb24odGhpcy5pbmRpY2VzW19pbmRleF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG11c3QgYmUgY29wbGFuYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNJbnNpZGUoX3BvaW50OiBWZWN0b3IzKTogYm9vbGVhbiB7XG4gICAgICBsZXQgZGlmZnM6IFZlY3RvcjNbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaW5kZXggb2YgdGhpcy5pbmRpY2VzKSB7XG4gICAgICAgIGxldCBkaWZmOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMudmVydGljZXMucG9zaXRpb24oaW5kZXgpLCBfcG9pbnQpO1xuICAgICAgICBkaWZmcy5wdXNoKGRpZmYpO1xuICAgICAgfVxuICAgICAgbGV0IG4wOiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhkaWZmc1sxXSwgZGlmZnNbMF0pO1xuICAgICAgbGV0IG4xOiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhkaWZmc1syXSwgZGlmZnNbMV0pO1xuICAgICAgbGV0IG4yOiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhkaWZmc1swXSwgZGlmZnNbMl0pO1xuXG4gICAgICBsZXQgZG90MTogbnVtYmVyID0gVmVjdG9yMy5ET1QobjAsIG4xKTtcbiAgICAgIGxldCBkb3QyOiBudW1iZXIgPSBWZWN0b3IzLkRPVChuMCwgbjIpO1xuXG4gICAgICByZXR1cm4gIShkb3QxIDwgMCB8fCBkb3QyIDwgMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVOb3JtYWxzKCk6IHZvaWQge1xuICAgICAgbGV0IHRyaWdvbjogVmVjdG9yM1tdID0gdGhpcy5pbmRpY2VzLm1hcCgoX2luZGV4OiBudW1iZXIpID0+IHRoaXMudmVydGljZXMucG9zaXRpb24oX2luZGV4KSk7XG4gICAgICBsZXQgdjE6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodHJpZ29uWzFdLCB0cmlnb25bMF0pO1xuICAgICAgbGV0IHYyOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRyaWdvblsyXSwgdHJpZ29uWzBdKTtcbiAgICAgIHRoaXMubm9ybWFsVW5zY2FsZWQgPSBWZWN0b3IzLkNST1NTKHYxLCB2Mik7XG4gICAgICB0aGlzLm5vcm1hbCA9IFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLm5vcm1hbFVuc2NhbGVkKTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBtZXNoZXMuIFxuICAgKiBNZXNoZXMgcHJvdmlkZSBpbmRleGVkIHZlcnRpY2VzLCB0aGUgb3JkZXIgb2YgaW5kaWNlcyB0byBjcmVhdGUgdHJpZ29ucyBhbmQgbm9ybWFscywgYW5kIHRleHR1cmUgY29vcmRpbmF0ZXNcbiAgICogXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LzIyXG4gICAqL1xuICBAUmVuZGVySW5qZWN0b3JNZXNoLmRlY29yYXRlXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNZXNoIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgTWVzaCA9IE1lc2g7XG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIE1lc2hbXSA9IFtdO1xuXG4gICAgLy8gVE9ETzogYXQgdGhpcyB0aW1lLCBjcmVhdGluZyB0aGUgYnVmZmVycyBmb3IgZmxhdCBzaGFkaW5nIGlzIGEgYnJ1dGUgZm9yY2UgYWxnb3JpdGhtIGFuZCBzaG91bGQgYmUgb3B0aW1pemVkIGluIHRoZSBkaWZmZXJlbnQgc3ViY2xhc3Nlc1xuICAgIC8vIFRPRE86IHJlbmFtZSB2ZXJ0aWNlcyB0byB2ZXJ0aWNlc1Ntb290aCBvciBqdXN0IGNsb3VkLCBhbmQgY2xvdWQgdG8gdmVydGljZXNcbiAgICAvLyBcblxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiTWVzaFwiO1xuICAgIC8vIGJhc2Ugc3RydWN0dXJlIGZvciBtZXNoZXMgaW4gRlVER0VcbiAgICBwdWJsaWMgdmVydGljZXM6IFZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XG4gICAgcHVibGljIGZhY2VzOiBGYWNlW10gPSBbXTtcblxuICAgIC8vIHB1YmxpYyByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzOyAvKiBkZWZpbmVkIGJ5IFJlbmRlckluamVjdG9yKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgcHVibGljIHJlbmRlck1lc2g6IFJlbmRlck1lc2g7IC8qIGRlZmluZWQgYnkgUmVuZGVySW5qZWN0b3IqL1xuXG4gICAgLyoqIGJvdW5kaW5nIGJveCBBQUJCICovXG4gICAgcHJvdGVjdGVkIMaSYm94OiBCb3g7XG4gICAgLy8gVE9ETzogZXhwbG9yZSBtYXRoZW1hdGljcyBmb3IgZWFzeSB0cmFuc2Zvcm1hdGlvbnMgb2YgcmFkaXVzIFxuICAgIC8qKiBib3VuZGluZyByYWRpdXMgKi9cbiAgICBwcm90ZWN0ZWQgxpJyYWRpdXM6IG51bWJlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoXCIpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWdpc3RlclN1YmNsYXNzKF9zdWJDbGFzczogdHlwZW9mIE1lc2gpOiBudW1iZXIgeyByZXR1cm4gTWVzaC5zdWJjbGFzc2VzLnB1c2goX3N1YkNsYXNzKSAtIDE7IH1cblxuICAgIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGJvdW5kaW5nQm94KCk6IEJveCB7XG4gICAgICBpZiAodGhpcy7GkmJveCA9PSBudWxsKVxuICAgICAgICB0aGlzLsaSYm94ID0gdGhpcy5jcmVhdGVCb3VuZGluZ0JveCgpO1xuXG4gICAgICByZXR1cm4gdGhpcy7GkmJveDtcbiAgICB9XG4gICAgcHVibGljIGdldCByYWRpdXMoKTogbnVtYmVyIHtcbiAgICAgIGlmICh0aGlzLsaScmFkaXVzID09IG51bGwpXG4gICAgICAgIHRoaXMuxpJyYWRpdXMgPSB0aGlzLmNyZWF0ZVJhZGl1cygpO1xuXG4gICAgICByZXR1cm4gdGhpcy7GknJhZGl1cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JNZXNofS5cbiAgICAgKiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXJzKF9zaGFkZXI6IFNoYWRlckludGVyZmFjZSwgX210eE1lc2hUb1dvcmxkOiBNYXRyaXg0eDQsIF9tdHhNZXNoVG9WaWV3OiBNYXRyaXg0eDQsIF9pZD86IG51bWJlcik6IFJlbmRlckJ1ZmZlcnMgeyByZXR1cm4gbnVsbDsgLyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XG4gICAgLyoqXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yTWVzaH0uXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UmVuZGVyQnVmZmVycyhfc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UpOiBSZW5kZXJCdWZmZXJzIHsgcmV0dXJuIG51bGw7IC8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxuICAgIC8qKlxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3Rvck1lc2h9LlxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3NoYWRlcjogU2hhZGVySW50ZXJmYWNlKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGJvdW5kcyBvZiB0aGlzIG1lc2ggYXN3ZWxsIGFzIHRoZSBidWZmZXJzIG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBSZW5kZXJNZXNofS5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgICB0aGlzLsaSYm94ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy7GknJhZGl1cyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5yZW5kZXJNZXNoPy5jbGVhcigpO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIC8vIFNlcmlhbGl6ZS9EZXNlcmlhbGl6ZSBmb3IgYWxsIG1lc2hlcyB0aGF0IGNhbGN1bGF0ZSB3aXRob3V0IHBhcmFtZXRlcnNcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUgLy8gc3RvcmUgZm9yIGVkaXRvciB2aWV3XG4gICAgICB9OyAvLyBubyBkYXRhIG5lZWRlZCAuLi5cbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XG4gICAgICAvLyB0eXBlIGlzIGFuIGFjY2Vzc29yIGFuZCBtdXN0IG5vdCBiZSBkZXNlcmlhbGl6ZWRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XG4gICAgICAvLyBUT0RPOiBzbyBtdWNoIHRvIGRlbGV0ZS4uLiByYXRoZXIganVzdCBnYXRoZXIgd2hhdCB0byBtdXRhdGVcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci7GkmJveDtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci7GknJhZGl1cztcblxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlbmRlckJ1ZmZlcnM7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlUmFkaXVzKCk6IG51bWJlciB7XG4gICAgICAvL1RPRE86IHJhZGl1cyBhbmQgYm91bmRpbmcgYm94IGNvdWxkIGJlIGNyZWF0ZWQgb24gY29uc3RydWN0aW9uIG9mIHZlcnRleC1hcnJheVxuICAgICAgbGV0IHJhZGl1czogbnVtYmVyID0gMDtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihpKS5tYWduaXR1ZGVTcXVhcmVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNxcnQocmFkaXVzKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlQm91bmRpbmdCb3goKTogQm94IHtcbiAgICAgIGxldCBib3g6IEJveCA9IFJlY3ljbGVyLmdldChCb3gpO1xuICAgICAgYm94LnNldCgpO1xuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHBvaW50OiBWZWN0b3IzID0gdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihpKTtcbiAgICAgICAgYm94LmV4cGFuZChwb2ludCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94O1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogR2VuZXJhdGUgYSBzaW1wbGUgY3ViZSB3aXRoIGVkZ2VzIG9mIGxlbmd0aCAxLCBlYWNoIGZhY2UgY29uc2lzdGluZyBvZiB0d28gdHJpZ29uc1xuICAgKiBgYGB0ZXh0XG4gICAqICAgICAgICgxMikgNF9fX183ICAoMTEpXG4gICAqICAgICAgICg4KSAwL19fMy98ICgxMClcbiAgICogICAgICAgKDE1KSB8fDVffHw2ICgxNClcbiAgICogICAgICAgKDkpIDF8L18yfC8gKDEzKVxuICAgKiBgYGBcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNZXNoQ3ViZSBleHRlbmRzIE1lc2gge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaEN1YmUpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hDdWJlXCIpIHtcbiAgICAgIHN1cGVyKF9uYW1lKTtcblxuICAgICAgLy8gbm8gc2hhcmVkIHZlcnRpY2VzLCBjb3JuZXJzIG5lZWQgdGhyZWUgbm9ybWFscyBmb3IgUGhvbmcgYW5kIEdvdXJhdWRcbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgVmVydGljZXMoXG4gICAgICAgIC8vIGZyb250IHZlcnRpY2VzXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC41LCAwLjUpLCBuZXcgVmVjdG9yMigwLCAwKSksIC8vIDBcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAtMC41LCAwLjUpLCBuZXcgVmVjdG9yMigwLCAxKSksIC8vIDFcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKDEsIDEpKSwgLy8gMlxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwLjUpLCBuZXcgVmVjdG9yMigxLCAwKSkgLy8zXG4gICAgICApO1xuXG4gICAgICAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcyBvbiBzaWRlc1xuICAgICAgZm9yIChsZXQgYW5nbGU6IG51bWJlciA9IDkwOyBhbmdsZSA8IDM2MDsgYW5nbGUgKz0gOTApIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OKFZlY3RvcjMuWShhbmdsZSkpO1xuICAgICAgICBsZXQgc2lkZTogVmVydGV4W10gPSB0aGlzLnZlcnRpY2VzLnNsaWNlKDAsIDQpLm1hcCgoX3Y6IFZlcnRleCkgPT5cbiAgICAgICAgICBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIHRyYW5zZm9ybSksIF92LnV2KSk7XG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaCguLi5zaWRlKTtcbiAgICAgIH1cbiAgICAgIC8vIGdlbmVyYXRlIHZlcnRpY2VzIGZvciB0b3AgYW5kIGJvdHRvbVxuICAgICAgZm9yIChsZXQgYW5nbGU6IG51bWJlciA9IDkwOyBhbmdsZSA8IDM2MDsgYW5nbGUgKz0gMTgwKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm06IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTihWZWN0b3IzLlgoYW5nbGUpKTtcbiAgICAgICAgbGV0IHNpZGU6IFZlcnRleFtdID0gdGhpcy52ZXJ0aWNlcy5zbGljZSgwLCA0KS5tYXAoKF92OiBWZXJ0ZXgpID0+XG4gICAgICAgICAgbmV3IFZlcnRleChWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF92LnBvc2l0aW9uLCB0cmFuc2Zvcm0pLCBfdi51dikpO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goLi4uc2lkZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmFjZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAyNDsgaSArPSA0KVxuICAgICAgICAvLyBnZW5lcmF0ZSBmYWNlc1xuICAgICAgICB0aGlzLmZhY2VzLnB1c2goLi4ubmV3IFF1YWQodGhpcy52ZXJ0aWNlcywgaSArIDAsIGkgKyAxLCBpICsgMiwgaSArIDMpLmZhY2VzKTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgZmxhdCBwb2x5Z29uLiBBbGwgdHJpZ29ucyBzaGFyZSB2ZXJ0ZXggMCwgc28gY2FyZWZ1bCBkZXNpZ24gaXMgcmVxdWlyZWQgdG8gY3JlYXRlIGNvbmNhdmUgcG9seWdvbnMuIFxuICAgKiBWZXJ0ZXggMCBpcyBhbHNvIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmFjZSBub3JtYWwuXG4gICAqIGBgYHRleHRcbiAgICogICAgICAgICAgICAgMCBcbiAgICogICAgICAgICAgIDHilbF84pWyICA0IC4uLlxuICAgKiAgICAgICAgICAgIOKVsnxf4pWy4pWxIFxuICAgKiAgICAgICAgICAgIDIgICAzXG4gICAqIGBgYFxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyXG4gICAqL1xuICBleHBvcnQgY2xhc3MgTWVzaFBvbHlnb24gZXh0ZW5kcyBNZXNoIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQb2x5Z29uKTtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHNoYXBlRGVmYXVsdDogVmVjdG9yMltdID0gWyAvLyB0cmlnb24gaXMgdGhlIG1pbmltYWwgc2hhcGVcbiAgICAgIG5ldyBWZWN0b3IyKC0xLCAtMSksXG4gICAgICBuZXcgVmVjdG9yMigxLCAtMSksXG4gICAgICBuZXcgVmVjdG9yMigwLCAxKVxuICAgIF07XG4gICAgcHJvdGVjdGVkIHNoYXBlOiBNdXRhYmxlQXJyYXk8VmVjdG9yMj4gPSBuZXcgTXV0YWJsZUFycmF5PFZlY3RvcjI+KFZlY3RvcjIpO1xuICAgIHByb3RlY3RlZCBmaXRUZXh0dXJlOiBib29sZWFuO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hQb2x5Z29uXCIsIF9zaGFwZTogVmVjdG9yMltdID0gTWVzaFBvbHlnb24uc2hhcGVEZWZhdWx0LCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpIHtcbiAgICAgIHN1cGVyKF9uYW1lKTtcbiAgICAgIHRoaXMuY3JlYXRlKF9zaGFwZSwgX2ZpdFRleHR1cmUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgbWluVmVydGljZXMoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGlzIG1lc2ggZnJvbSB0aGUgZ2l2ZW4gdmVydGljZXMuXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZShfc2hhcGU6IFZlY3RvcjJbXSA9IFtdLCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgIHRoaXMuc2hhcGUgPSA8TXV0YWJsZUFycmF5PFZlY3RvcjI+Pk11dGFibGVBcnJheS5mcm9tKF9zaGFwZS5tYXAoX3ZlcnRleCA9PiBfdmVydGV4LmNsb25lKSk7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZpdFRleHR1cmUgPSBfZml0VGV4dHVyZTtcblxuICAgICAgaWYgKF9zaGFwZS5sZW5ndGggPCB0aGlzLm1pblZlcnRpY2VzKSB7XG4gICAgICAgIERlYnVnLndhcm4oYEF0IGxlYXN0ICR7dGhpcy5taW5WZXJ0aWNlc30gdmVydGljZXMgbmVlZGVkIHRvIGNvbnN0cnVjdCBNZXNoUG9seWdvbiwgZGVmYXVsdCB0cmlnb24gdXNlZGApO1xuICAgICAgICB0aGlzLmNyZWF0ZShNZXNoUG9seWdvbi5zaGFwZURlZmF1bHQsIHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBzaGFwZTogVmVjdG9yMltdID0gX3NoYXBlO1xuXG4gICAgICBsZXQgbWluOiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XG4gICAgICBsZXQgbWF4OiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XG4gICAgICBmb3IgKGxldCB2ZXJ0ZXggb2Ygc2hhcGUpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgodmVydGV4LnRvVmVjdG9yMygpKSk7XG5cbiAgICAgICAgbWluLnggPSBNYXRoLm1pbihtaW4ueCwgdmVydGV4LngpO1xuICAgICAgICBtYXgueCA9IE1hdGgubWF4KG1heC54LCB2ZXJ0ZXgueCk7XG4gICAgICAgIG1pbi55ID0gTWF0aC5taW4obWluLnksIHZlcnRleC55KTtcbiAgICAgICAgbWF4LnkgPSBNYXRoLm1heChtYXgueSwgdmVydGV4LnkpO1xuICAgICAgfVxuICAgICAgbGV0IHNpemU6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihtYXgueCAtIG1pbi54LCBtYXgueSAtIG1pbi55KTtcblxuICAgICAgaWYgKHRoaXMuZml0VGV4dHVyZSkge1xuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgdGV4dHVyZVVWOiBWZWN0b3IyID0gVmVjdG9yMi5ESUZGRVJFTkNFKHNoYXBlW2ldLCBtaW4pO1xuICAgICAgICAgIHRoaXMudmVydGljZXNbaV0udXYgPSBuZXcgVmVjdG9yMih0ZXh0dXJlVVYueCAvIHNpemUueCwgMSAtIHRleHR1cmVVVi55IC8gc2l6ZS55KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3NoYXBlLmZvckVhY2goKF92ZXJ0ZXgsIF9pKSA9PiB0aGlzLnZlcnRpY2VzW19pXS51diA9IG5ldyBWZWN0b3IyKF92ZXJ0ZXgueCwgLV92ZXJ0ZXgueSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZhY2VzID0gW107XG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAyOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKHRoaXMudmVydGljZXMsIGkgLSAxLCBpLCAwKSk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICBzZXJpYWxpemF0aW9uLnNoYXBlID0gU2VyaWFsaXplci5zZXJpYWxpemVBcnJheShWZWN0b3IyLCB0aGlzLnNoYXBlKTtcbiAgICAgIHNlcmlhbGl6YXRpb24uZml0VGV4dHVyZSA9IHRoaXMuZml0VGV4dHVyZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgbGV0IHZlY3RvcnM6IFZlY3RvcjJbXSA9IDxWZWN0b3IyW10+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZUFycmF5KF9zZXJpYWxpemF0aW9uLnNoYXBlKTtcbiAgICAgIHRoaXMuY3JlYXRlKHZlY3RvcnMsIF9zZXJpYWxpemF0aW9uLmZpdFRleHR1cmUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMuc2hhcGUsIHRoaXMuZml0VGV4dHVyZSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gIH1cbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJNZXNoUG9seWdvbi50c1wiLz5cbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGV4dHJ1c2lvbiBvZiBhIHBvbHlnb24gYnkgYSBzZXJpZXMgb2YgdHJhbnNmb3JtYXRpb25zXG4gICAqIGBgYHRleHQgIFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBfX19fXG4gICAqIFBvbHlnb24gICAgICAgICBfX19f4pWx4pWyICAg4pWyICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XG4gICAqIFRyYW5zZm9ybSAwICDihpIg4pWxIOKVsl9f4pWyX+KVsl9fX+KVsiDihpAgVHJhbnNmb3JtIDIgICAgICAgICAgeiBfX+KUglxuICAgKiAoYmFzZSkgICAgICAgICDilbJf4pWxX1/ilbEg4pWxICAg4pWxICAgKGxpZCkgICAgICAgICAgICAgICAgICAgICDilbIgICAgICAgXG4gICAqICAgICBUcmFuc2Zvcm0gMSAg4oaSICDilbLilbFfX1/ilbEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxuICAgKiBgYGBcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE1lc2hFeHRydXNpb24gZXh0ZW5kcyBNZXNoUG9seWdvbiB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoRXh0cnVzaW9uKTtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG10eERlZmF1bHRzOiBNYXRyaXg0eDRbXSA9IFsgLy8gb2Zmc2V0IG9mICswLjV6IGFuZCAtMC41eiBhcyBkZWZhdWx0XG4gICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04oVmVjdG9yMy5aKDAuNSkpLFxuICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKFZlY3RvcjMuWigtMC41KSlcbiAgICBdO1xuICAgIHByaXZhdGUgbXR4VHJhbnNmb3JtczogTXV0YWJsZUFycmF5PE1hdHJpeDR4ND4gPSBuZXcgTXV0YWJsZUFycmF5KE1hdHJpeDR4NCk7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaEV4dHJ1c2lvblwiLCBfdmVydGljZXM6IFZlY3RvcjJbXSA9IE1lc2hQb2x5Z29uLnNoYXBlRGVmYXVsdCwgX210eFRyYW5zZm9ybXM6IE1hdHJpeDR4NFtdID0gTWVzaEV4dHJ1c2lvbi5tdHhEZWZhdWx0cywgX2ZpdFRleHR1cmU6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgICBzdXBlcihfbmFtZSwgX3ZlcnRpY2VzLCBfZml0VGV4dHVyZSk7XG4gICAgICB0aGlzLmV4dHJ1ZGUoX210eFRyYW5zZm9ybXMpO1xuICAgICAgLy8gY29uc29sZS5sb2coXCJNdXRhdG9yXCIsIHRoaXMuZ2V0TXV0YXRvcigpKTtcbiAgICB9XG5cbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcbiAgICAgIHNlcmlhbGl6YXRpb24udHJhbnNmb3JtcyA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQXJyYXkoTWF0cml4NHg0LCB0aGlzLm10eFRyYW5zZm9ybXMpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIGxldCBtdHhUcmFuc2Zvcm1zOiBNYXRyaXg0eDRbXTtcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi50cmFuc2Zvcm1zKVxuICAgICAgICBtdHhUcmFuc2Zvcm1zID0gPE1hdHJpeDR4NFtdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi50cmFuc2Zvcm1zKTtcbiAgICAgIHRoaXMuZXh0cnVkZShtdHhUcmFuc2Zvcm1zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgICB0aGlzLmV4dHJ1ZGUodGhpcy5tdHhUcmFuc2Zvcm1zKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIHByaXZhdGUgZXh0cnVkZShfbXR4VHJhbnNmb3JtczogTWF0cml4NHg0W10gPSBNZXNoRXh0cnVzaW9uLm10eERlZmF1bHRzKTogdm9pZCB7XG4gICAgICB0aGlzLm10eFRyYW5zZm9ybXMgPSA8TXV0YWJsZUFycmF5PE1hdHJpeDR4ND4+TXV0YWJsZUFycmF5LmZyb20oPE11dGFibGVBcnJheTxNYXRyaXg0eDQ+Pl9tdHhUcmFuc2Zvcm1zKTtcbiAgICAgIGxldCBuVHJhbnNmb3JtczogbnVtYmVyID0gX210eFRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgbGV0IG5WZXJ0aWNlc1NoYXBlOiBudW1iZXIgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgLy8gY3JlYXRlIG5ldyB2ZXJ0ZXggY2xvdWQsIGN1cnJlbnQgY2xvdWQgaG9sZHMgTWVzaFBvbHlnb25cbiAgICAgIGxldCB2ZXJ0aWNlczogVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcblxuICAgICAgLy8gY3JlYXRlIGJhc2UgYnkgdHJhbnNmb3JtYXRpb24gb2YgcG9seWdvbiB3aXRoIGZpcnN0IHRyYW5zZm9ybVxuICAgICAgbGV0IGJhc2U6IFZlcnRleFtdID0gdGhpcy52ZXJ0aWNlcy5tYXAoKF92OiBWZXJ0ZXgpID0+IG5ldyBWZXJ0ZXgoVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfdi5wb3NpdGlvbiwgX210eFRyYW5zZm9ybXNbMF0sIHRydWUpLCBfdi51dikpO1xuICAgICAgdmVydGljZXMucHVzaCguLi5iYXNlKTtcbiAgICAgIC8vIGNyZWF0ZSBsaWQgYnkgdHJhbnNmb3JtYXRpb24gb2YgcG9seWdvbiB3aXRoIGxhc3QgdHJhbnNmb3JtXG4gICAgICBsZXQgbGlkOiBWZXJ0ZXhbXSA9IHRoaXMudmVydGljZXMubWFwKChfdjogVmVydGV4KSA9PiBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIF9tdHhUcmFuc2Zvcm1zW25UcmFuc2Zvcm1zIC0gMV0sIHRydWUpLCBfdi51dikpO1xuICAgICAgdmVydGljZXMucHVzaCguLi5saWQpO1xuXG4gICAgICAvLyByZWNyZWF0ZSBiYXNlIGZhY2VzIHRvIHJlY2FsY3VsYXRlIG5vcm1hbHNcbiAgICAgIHRoaXMuZmFjZXMgPSB0aGlzLmZhY2VzLm1hcCgoX2ZhY2U6IEZhY2UpID0+IG5ldyBGYWNlKHZlcnRpY2VzLCBfZmFjZS5pbmRpY2VzWzBdLCBfZmFjZS5pbmRpY2VzWzFdLCBfZmFjZS5pbmRpY2VzWzJdKSk7XG4gICAgICAvLyBjcmVhdGUgdGhlIGxpZCBmYWNlcyB1c2luZyB0aGUgaW5kaWNlcyBvZiB0aGUgYmFzZSBmYWNlcywgYnV0IHdpdGggYW4gaW5kZXggb2Zmc2V0IGFuZCByZXZlcnNlIG9yZGVyIG9mIGluZGljZXNcbiAgICAgIHRoaXMuZmFjZXMucHVzaCguLi50aGlzLmZhY2VzLm1hcChfZmFjZSA9PlxuICAgICAgICBuZXcgRmFjZSh2ZXJ0aWNlcywgX2ZhY2UuaW5kaWNlc1syXSArIG5WZXJ0aWNlc1NoYXBlLCBfZmFjZS5pbmRpY2VzWzFdICsgblZlcnRpY2VzU2hhcGUsIF9mYWNlLmluZGljZXNbMF0gKyBuVmVydGljZXNTaGFwZSlcbiAgICAgICkpO1xuXG4gICAgICBmb3IgKGxldCB0OiBudW1iZXIgPSAwOyB0IDwgblRyYW5zZm9ybXM7IHQrKykge1xuICAgICAgICBsZXQgbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBfbXR4VHJhbnNmb3Jtc1t0XTtcbiAgICAgICAgbGV0IHJlZmVyVG9DbG9zZTogbnVtYmVyID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICBsZXQgd3JhcDogVmVydGV4W10gPSB0aGlzLnZlcnRpY2VzLm1hcCgoX3Y6IFZlcnRleCwgX2k6IG51bWJlcikgPT5cbiAgICAgICAgICBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIG10eFRyYW5zZm9ybSwgdHJ1ZSksIG5ldyBWZWN0b3IyKF9pIC8gblZlcnRpY2VzU2hhcGUsIHQgLyBuVHJhbnNmb3JtcykpXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goLi4ud3JhcCk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlcnRleChyZWZlclRvQ2xvc2UsIG5ldyBWZWN0b3IyKDEsIHQgLyBuVHJhbnNmb3JtcykpKTtcbiAgICAgICAgLy8gaWYgKGkgPiAwICYmIGkgPCBuVHJhbnNmb3JtcyAtIDEpXG4gICAgICAgIC8vICAgdmVydGljZXMucHVzaCguLi53cmFwLm1hcCgoX3ZlY3RvcjogVmVjdG9yMykgPT4gX3ZlY3Rvci5jbG9uZSkpOyA8LSBubyBzbGljaW5nIGZvciBmbGF0IHNoYWRpbmcgeWV0Li4uXG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBpbmRpemVzIGZvciB3cmFwcGVyXG4gICAgICBmb3IgKGxldCB0OiBudW1iZXIgPSAwOyB0IDwgblRyYW5zZm9ybXMgLSAxOyB0KyspXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuVmVydGljZXNTaGFwZTsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPVxuICAgICAgICAgICAgKyAyICogblZlcnRpY2VzU2hhcGUgLy8gYmFzZSAmIGxpZCBhcmUgb2Zmc2V0cyBcbiAgICAgICAgICAgICsgdCAqIChuVmVydGljZXNTaGFwZSArIDEpIC8vIG9mZnNldCBmb3IgZWFjaCB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAgICAgKyBpO1xuICAgICAgICAgIGxldCBxdWFkOiBRdWFkID0gbmV3IFF1YWQodmVydGljZXMsIGluZGV4LCBpbmRleCArIG5WZXJ0aWNlc1NoYXBlICsgMSwgaW5kZXggKyBuVmVydGljZXNTaGFwZSArIDIsIGluZGV4ICsgMSwgUVVBRFNQTElULkFUXzApO1xuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCguLi5xdWFkLmZhY2VzKTtcbiAgICAgICAgfVxuXG4gICAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBwcml2YXRlIGNhbGN1bGF0ZVBvbHlnb25MZW5ndGhzKCk6IG51bWJlcltdIHtcbiAgICAvLyAgIGxldCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gICAgLy8gICBsZXQgZmlyc3Q6IFZlY3RvcjM7XG4gICAgLy8gICBsZXQgcHJldjogVmVjdG9yMztcbiAgICAvLyAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgLy8gICAgIGxldCBjdXJyZW50OiBWZWN0b3IzID0gbmV3IFZlY3RvcjModGhpcy52ZXJ0aWNlc1tpXSwgdGhpcy52ZXJ0aWNlc1tpICsgMV0sIHRoaXMudmVydGljZXNbaSArIDJdKTtcbiAgICAvLyAgICAgaWYgKHByZXYpXG4gICAgLy8gICAgICAgcmVzdWx0LnB1c2goVmVjdG9yMy5ESUZGRVJFTkNFKGN1cnJlbnQsIHByZXYpLm1hZ25pdHVkZSk7XG4gICAgLy8gICAgIGVsc2VcbiAgICAvLyAgICAgICBmaXJzdCA9IGN1cnJlbnQ7XG4gICAgLy8gICAgIHByZXYgPSBjdXJyZW50O1xuICAgIC8vICAgfVxuICAgIC8vICAgcmVzdWx0LnB1c2goVmVjdG9yMy5ESUZGRVJFTkNFKGZpcnN0LCBwcmV2KS5tYWduaXR1ZGUpO1xuICAgIC8vICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvLyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICAvKiogQWxsb3dzIHRvIGNyZWF0ZSBjdXN0b20gbWVzaGVzIGZyb20gZ2l2ZW4gRGF0YSAqL1xuICBleHBvcnQgY2xhc3MgTWVzaEZyb21EYXRhIGV4dGVuZHMgTWVzaCB7XG4gICAgcHJvdGVjdGVkIHZlcnRpY2VzVG9TZXQ6IEZsb2F0MzJBcnJheTtcbiAgICBwcm90ZWN0ZWQgdGV4dHVyZVVWc1RvU2V0OiBGbG9hdDMyQXJyYXk7XG4gICAgcHJvdGVjdGVkIGluZGljZXNUb1NldDogVWludDE2QXJyYXk7XG4gICAgcHJvdGVjdGVkIGZhY2VOb3JtYWxzVG9TZXQ6IEZsb2F0MzJBcnJheTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdmVydGljZXM6IEZsb2F0MzJBcnJheSwgX3RleHR1cmVVVnM6IEZsb2F0MzJBcnJheSwgX2luZGljZXM6IFVpbnQxNkFycmF5LCBfZmFjZU5vcm1hbHM6IEZsb2F0MzJBcnJheSkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMudmVydGljZXNUb1NldCA9IF92ZXJ0aWNlcztcbiAgICAgIHRoaXMudGV4dHVyZVVWc1RvU2V0ID0gX3RleHR1cmVVVnM7XG4gICAgICB0aGlzLmluZGljZXNUb1NldCA9IF9pbmRpY2VzO1xuICAgICAgdGhpcy5mYWNlTm9ybWFsc1RvU2V0ID0gX2ZhY2VOb3JtYWxzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXNUb1NldDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZVVWc1RvU2V0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcbiAgICAgIHJldHVybiB0aGlzLmluZGljZXNUb1NldDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmxhdE5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcbiAgICAgIHJldHVybiB0aGlzLmZhY2VOb3JtYWxzVG9TZXQ7XG4gICAgfVxuICB9XG59XG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIE1lc2ggbG9hZGVkIGZyb20gYSBmaWxlXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjItMjAyM1xuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE1lc2hJbXBvcnQgZXh0ZW5kcyBNZXNoIHtcbiAgICBwdWJsaWMgdXJsOiBSZXF1ZXN0SW5mbztcbiAgICBwcml2YXRlIGxvYWRlcjogdHlwZW9mIE1lc2hMb2FkZXI7XG5cbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi51cmwgPSB0aGlzLnVybC50b1N0cmluZygpO1xuICAgICAgc2VyaWFsaXphdGlvbi5maWxldHlwZSA9IHRoaXMubG9hZGVyLm5hbWUucmVwbGFjZShNZXNoTG9hZGVyLm5hbWUsIFwiXCIpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIHRoaXMudXJsID0gX3NlcmlhbGl6YXRpb24udXJsO1xuICAgICAgdGhpcy5sb2FkZXIgPSBSZWZsZWN0LmdldChGdWRnZUNvcmUsIE1lc2hMb2FkZXIubmFtZS5jb25jYXQoX3NlcmlhbGl6YXRpb24uZmlsZXR5cGUpKTtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIG1lc2ggZnJvbSBmaWxlXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX2xvYWRlcjogdHlwZW9mIE1lc2hMb2FkZXIgPSB0aGlzLmxvYWRlciwgX3VybDogUmVxdWVzdEluZm8gPSB0aGlzLnVybCwgX2RhdGE/OiBPYmplY3QpOiBQcm9taXNlPE1lc2hJbXBvcnQ+IHtcbiAgICAgIHRoaXMudXJsID0gX3VybDtcbiAgICAgIHRoaXMubG9hZGVyID0gX2xvYWRlcjtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIGlmICghdGhpcy5yZW5kZXJNZXNoKVxuICAgICAgICB0aGlzLnJlbmRlck1lc2ggPSBuZXcgUmVuZGVyTWVzaCh0aGlzKTtcbiAgICAgIHJldHVybiBfbG9hZGVyLmxvYWQodGhpcywgX2RhdGEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci51cmwpICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aGlzLmxvYWQodGhpcy5sb2FkZXIsIF9tdXRhdG9yLnVybCk7XG4gICAgfVxuXG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHB5cmFtaWQgd2l0aCBlZGdlcyBhdCB0aGUgYmFzZSBvZiBsZW5ndGggMSBhbmQgYSBoZWlnaHQgb2YgMS4gVGhlIHNpZGVzIGNvbnNpc3Rpbmcgb2Ygb25lLCB0aGUgYmFzZSBvZiB0d28gdHJpZ29uc1xuICAgKiBgYGB0ZXh0XG4gICAqICAgICAgICAgICAgICAgNFxuICAgKiAgICAgICAgICAgICAgL1xcYC5cbiAgICogICAgICAgICAgICAzL19fXFxfXFwgMlxuICAgKiAgICAgICAgICAgMC9fX19fXFwvMVxuICAgKiBgYGBcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNZXNoUHlyYW1pZCBleHRlbmRzIE1lc2gge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFB5cmFtaWQpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hQeXJhbWlkXCIpIHtcbiAgICAgIHN1cGVyKF9uYW1lKTtcbiAgICAgIC8vIHRoaXMuY3JlYXRlKCk7XG5cbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgVmVydGljZXMoXG4gICAgICAgIC8vIGdyb3VuZCB2ZXJ0aWNlc1xuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIDAuMCwgMC41KSwgbmV3IFZlY3RvcjIoMCwgMSkpLFxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgMC4wLCAwLjUpLCBuZXcgVmVjdG9yMigxLCAxKSksXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAwLjAsIC0wLjUpLCBuZXcgVmVjdG9yMigxLCAwKSksXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC4wLCAtMC41KSwgbmV3IFZlY3RvcjIoMCwgMCkpLFxuICAgICAgICAvLyB0aXAgKHZlcnRleCAjNClcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjAsIDEuMCwgMC4wKSwgbmV3IFZlY3RvcjIoMC41LCAwLjUpKSxcbiAgICAgICAgLy8gZmxvb3IgYWdhaW4gZm9yIGRvd25zaWRlIHRleHR1cmVcbiAgICAgICAgbmV3IFZlcnRleCgwLCBuZXcgVmVjdG9yMigwLCAwKSksXG4gICAgICAgIG5ldyBWZXJ0ZXgoMSwgbmV3IFZlY3RvcjIoMSwgMCkpLFxuICAgICAgICBuZXcgVmVydGV4KDIsIG5ldyBWZWN0b3IyKDEsIDEpKSxcbiAgICAgICAgbmV3IFZlcnRleCgzLCBuZXcgVmVjdG9yMigwLCAxKSlcbiAgICAgICk7XG4gICAgICB0aGlzLmZhY2VzID0gW1xuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA0LCAwLCAxKSxcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMSwgMiksXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDQsIDIsIDMpLFxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA0LCAzLCAwKSxcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNSArIDAsIDUgKyAyLCA1ICsgMSksXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDUgKyAwLCA1ICsgMywgNSArIDIpXG4gICAgICBdO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogR2VuZXJhdGUgYSBzaW1wbGUgcXVhZCB3aXRoIGVkZ2VzIG9mIGxlbmd0aCAxLCB0aGUgZmFjZSBjb25zaXN0aW5nIG9mIHR3byB0cmlnb25zXG4gICAqIGBgYHRleHRcbiAgICogICAgICAgIDAgX18gM1xuICAgKiAgICAgICAgIHxfXFx8XG4gICAqICAgICAgICAxICAgIDIgICAgICAgICAgICAgXG4gICAqIGBgYCBcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTktMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE1lc2hRdWFkIGV4dGVuZHMgTWVzaFBvbHlnb24ge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFF1YWQpO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgc2hhcGU6IFZlY3RvcjJbXSA9IFtcbiAgICAgIG5ldyBWZWN0b3IyKC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKC0wLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigwLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigwLjUsIDAuNSlcbiAgICBdO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hRdWFkXCIpIHtcbiAgICAgIHN1cGVyKF9uYW1lLCBNZXNoUXVhZC5zaGFwZSk7XG4gICAgfVxuXG4gICAgLy8gLy8gZmxhdCBlcXVhbHMgc21vb3RoXG4gICAgLy8gcHVibGljIGdldCB2ZXJ0aWNlc0ZsYXQoKTogRmxvYXQzMkFycmF5IHsgcmV0dXJuIHRoaXMudmVydGljZXM7IH1cbiAgICAvLyBwdWJsaWMgZ2V0IGluZGljZXNGbGF0KCk6IFVpbnQxNkFycmF5IHsgcmV0dXJuIHRoaXMuaW5kaWNlczsgfVxuICAgIC8vIHB1YmxpYyBnZXQgbm9ybWFsc0ZsYXQoKTogRmxvYXQzMkFycmF5IHsgcmV0dXJuIHRoaXMubm9ybWFsc1ZlcnRleDsgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZ2VyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIHRoaXMuY3JlYXRlKE1lc2hRdWFkLnNoYXBlLCB0cnVlKTsgLy8gdGhpcyBzZWVtcyB0byBiZSBkaXNwYXRjaGVkIGRvdWJsZWQgd2hpbGUgZGVzZXJpYWxpemluZyB0aGUgcmVzb3VyY2VzXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNoYXBlO1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLmZpdFRleHR1cmU7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgLyoqIFxuICAgKiBUaGlzIGZ1bmN0aW9uIHR5cGUgdGFrZXMgeCBhbmQgeiBhcyBQYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEgdG8gYmUgdXNlZCBhcyBhIGhlaWdodG1hcC4gXG4gICAqIHggKiB6ICogMiByZXByZXNlbnQgdGhlIGFtb3V0IG9mIGZhY2VzIHdoaWNoIGFyZSBjcmVhdGVkLiBBcyBhIHJlc3VsdCB5b3UgZ2V0IDEgdmVydGV4IG1vcmUgaW4gZWFjaCBkaXJlY3Rpb24gKHggYW5kIHogYXhpcylcbiAgICogVGhlIHktY29tcG9uZW50IG9mIHRoZSByZXN1bHRpbmcgbWVzaCBtYXkgYmUgbW92ZWQgdG8gdmFsdWVzIGJldHdlZW4gMCBhbmQgYSBtYXhpbXVtIGhlaWdodC5cbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxuICAgKi9cbiAgZXhwb3J0IHR5cGUgSGVpZ2h0TWFwRnVuY3Rpb24gPSAoeDogbnVtYmVyLCB6OiBudW1iZXIpID0+IG51bWJlcjtcblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlcnRpY2FsIHByb2plY3Rpb24gb2YgYSBnaXZlbiBwb3NpdGlvbiBvbnRvIHRoZSB0ZXJyYWluXG4gICAqL1xuICBleHBvcnQgY2xhc3MgVGVycmFpbkluZm8ge1xuICAgIC8qKiB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50IHZlcnRpY2FsbHkgcHJvamVjdGVkIG9uIHRoZSB0ZXJyYWluIGluIHdvcmxkIGNvb3JkaW5hdGVzICovXG4gICAgcHVibGljIHBvc2l0aW9uOiBWZWN0b3IzO1xuICAgIC8qKiB0aGUgbm9ybWFsIG9mIHRoZSBmYWNlIG9mIHRoZSB0ZXJyYWluIHVuZGVyIHRoZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcyAqL1xuICAgIHB1YmxpYyBub3JtYWw6IFZlY3RvcjM7XG4gICAgLyoqIHZlcnRpY2FsIGRpc3RhbmNlIG9mIHRoZSBwb2ludCB0byB0aGUgdGVycmFpbiwgbmVnYXRpdmUgaWYgYmVsb3cgKi9cbiAgICBwdWJsaWMgZGlzdGFuY2U6IG51bWJlcjtcbiAgICAvKiogdGhlIHBvc2l0aW9uIGluIGZhY2UgY29vcmRpbmF0ZXMgKi9cbiAgICBwdWJsaWMgcG9zaXRpb25GYWNlOiBWZWN0b3IzO1xuICAgIC8qKiB0aGUgaW5kZXggb2YgdGhlIGZhY2UgdGhlIHBvc2l0aW9uIGlzIGluc2lkZSAqL1xuICAgIHB1YmxpYyBpbmRleDogbnVtYmVyO1xuICAgIC8qKiB0aGUgZ3JpZCBjb29yZGluYXRlcyBvZiB0aGUgcXVhZCB0aGUgZmFjZSBiZWxvbmdzIHRvICovXG4gICAgcHVibGljIGdyaWQ6IFZlY3RvcjI7XG4gIH1cblxuICAvKipcbiAgICogQSB0ZXJyYWluIHNwcmVhZHMgb3V0IGluIHRoZSB4LXotcGxhbmUsIHkgaXMgdGhlIGhlaWdodCBkZXJpdmVkIGZyb20gdGhlIGhlaWdodG1hcCBmdW5jdGlvbi4gXG4gICAqIFRoZSB0ZXJyYWluIGlzIGFsd2F5cyAxIGluIHNpemUgaW4gYWxsIGRpbWVuc2lvbnMsIGZpdHRpbmcgaW50byB0aGUgdW5pdC1jdWJlLiBcbiAgICogUmVzb2x1dGlvbiBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgcXVhZHMgaW4geCBhbmQgeiBkaW1lbnNpb24sIHNjYWxlIHRoZSBmYWN0b3IgYXBwbGllZCB0byB0aGUgeCx6LWNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGUgaGVpZ2h0bWFwIGZ1bmN0aW9uLlxuICAgKiBTdGFuZGFyZCBmdW5jdGlvbiBpcyB0aGUgc2ltcGxleCBub2lzZSBpbXBsZW1lbnRlZCB3aXRoIEZVREdFLCBidXQgYW5vdGhlciBmdW5jdGlvbiBjYW4gYmUgZ2l2ZW4uXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxLTIwMjIgfCBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAgfCBNb3JpdHogQmVhdWdyYW5kLCBIRlUsIDIwMjFcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNZXNoVGVycmFpbiBleHRlbmRzIE1lc2gge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFRlcnJhaW4pO1xuICAgIHByb3RlY3RlZCByZXNvbHV0aW9uOiBWZWN0b3IyO1xuICAgIHByb3RlY3RlZCBzY2FsZTogVmVjdG9yMjtcbiAgICBwcm90ZWN0ZWQgc2VlZDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBoZWlnaHRNYXBGdW5jdGlvbjogSGVpZ2h0TWFwRnVuY3Rpb24gPSBudWxsO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hUZXJyYWluXCIsIF9yZXNvbHV0aW9uOiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoMiksIF9zY2FsZUlucHV0OiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoKSwgX2Z1bmN0aW9uT3JTZWVkOiBIZWlnaHRNYXBGdW5jdGlvbiB8IG51bWJlciA9IDApIHtcbiAgICAgIHN1cGVyKF9uYW1lKTtcbiAgICAgIHRoaXMuY3JlYXRlKF9yZXNvbHV0aW9uLCBfc2NhbGVJbnB1dCwgX2Z1bmN0aW9uT3JTZWVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhpcyBtZXNoIGZyb20gdGhlIGdpdmVuIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlKF9yZXNvbHV0aW9uOiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoMiksIF9zY2FsZUlucHV0OiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoKSwgX2Z1bmN0aW9uT3JTZWVkOiBIZWlnaHRNYXBGdW5jdGlvbiB8IG51bWJlciA9IDApOiB2b2lkIHtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuc2VlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyKE1hdGgucm91bmQoX3Jlc29sdXRpb24ueCksIE1hdGgucm91bmQoX3Jlc29sdXRpb24ueSkpO1xuICAgICAgdGhpcy5zY2FsZSA9IF9zY2FsZUlucHV0LmNsb25lO1xuXG4gICAgICBpZiAoX2Z1bmN0aW9uT3JTZWVkIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBfZnVuY3Rpb25PclNlZWQ7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgKF9mdW5jdGlvbk9yU2VlZCkgPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLnNlZWQgPSBfZnVuY3Rpb25PclNlZWQ7XG4gICAgICAgIGxldCBwcm5nOiBSYW5kb20gPSBuZXcgUmFuZG9tKHRoaXMuc2VlZCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBuZXcgTm9pc2UyKCgpID0+IHBybmcuZ2V0Tm9ybSgpKS5zYW1wbGU7IC8vIFRPRE8gY2FsbCBQUk5HXG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5oZWlnaHRNYXBGdW5jdGlvbiA9IG5ldyBOb2lzZTIoKS5zYW1wbGU7XG5cbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcbiAgICAgIC8vSXRlcmF0ZSBvdmVyIGVhY2ggY2VsbCB0byBnZW5lcmF0ZSBncmlkIG9mIHZlcnRpY2VzXG4gICAgICBmb3IgKGxldCB6OiBudW1iZXIgPSAwOyB6IDw9IHRoaXMucmVzb2x1dGlvbi55OyB6KyspIHtcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8PSB0aGlzLnJlc29sdXRpb24ueDsgeCsrKSB7XG4gICAgICAgICAgbGV0IHhOb3JtOiBudW1iZXIgPSB4IC8gdGhpcy5yZXNvbHV0aW9uLng7XG4gICAgICAgICAgbGV0IHpOb3JtOiBudW1iZXIgPSB6IC8gdGhpcy5yZXNvbHV0aW9uLnk7XG4gICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgoXG4gICAgICAgICAgICBuZXcgVmVjdG9yMyh4Tm9ybSAtIDAuNSwgdGhpcy5oZWlnaHRNYXBGdW5jdGlvbih4Tm9ybSAqIHRoaXMuc2NhbGUueCwgek5vcm0gKiB0aGlzLnNjYWxlLnkpLCB6Tm9ybSAtIDAuNSksXG4gICAgICAgICAgICBuZXcgVmVjdG9yMih4Tm9ybSwgek5vcm0pXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHF1YWRzOiBRdWFkW10gPSBbXTtcbiAgICAgIGxldCBzcGxpdDogUVVBRFNQTElUID0gUVVBRFNQTElULkFUXzA7XG4gICAgICBmb3IgKGxldCB6OiBudW1iZXIgPSAwOyB6IDwgdGhpcy5yZXNvbHV0aW9uLnk7IHorKykge1xuICAgICAgICBmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDwgdGhpcy5yZXNvbHV0aW9uLng7IHgrKykge1xuICAgICAgICAgIHF1YWRzLnB1c2gobmV3IFF1YWQoXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLFxuICAgICAgICAgICAgKHggKyAwKSArICh6ICsgMCkgKiAodGhpcy5yZXNvbHV0aW9uLnggKyAxKSxcbiAgICAgICAgICAgICh4ICsgMCkgKyAoeiArIDEpICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXG4gICAgICAgICAgICAoeCArIDEpICsgKHogKyAxKSAqICh0aGlzLnJlc29sdXRpb24ueCArIDEpLFxuICAgICAgICAgICAgKHggKyAxKSArICh6ICsgMCkgKiAodGhpcy5yZXNvbHV0aW9uLnggKyAxKSxcbiAgICAgICAgICAgIHNwbGl0XG4gICAgICAgICAgKSk7XG4gICAgICAgICAgc3BsaXQgPSAoc3BsaXQgPT0gUVVBRFNQTElULkFUXzApID8gUVVBRFNQTElULkFUXzEgOiBRVUFEU1BMSVQuQVRfMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNvbHV0aW9uLnggJSAyID09IDApIC8vIHJldmVyc2UgbGFzdCBzcGxpdCBjaGFuZ2UgaWYgeC1yZXNvbHV0aW9uIGlzIGV2ZW5cbiAgICAgICAgICBzcGxpdCA9IChzcGxpdCA9PSBRVUFEU1BMSVQuQVRfMCkgPyBRVUFEU1BMSVQuQVRfMSA6IFFVQURTUExJVC5BVF8wO1xuICAgICAgfVxuICAgICAgdGhpcy5mYWNlcyA9IHF1YWRzLmZsYXRNYXAoKF9xdWFkOiBRdWFkKSA9PiBfcXVhZC5mYWNlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVydGljYWwgcHJvamVjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gb250byB0aGUgdGVycmFpbi5cbiAgICAgKiBQYXNzIHRoZSBvdmVyYWxsIHdvcmxkIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSB0ZXJyYWluIGlmIHRoZSBwb3NpdGlvbiBpcyBnaXZlbiBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgKiBJZiBhdCBoYW5kLCBwYXNzIHRoZSBpbnZlcnNlIHRvbyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGVycmFpbkluZm8oX3Bvc2l0aW9uOiBWZWN0b3IzLCBfbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpLCBfbXR4SW52ZXJzZT86IE1hdHJpeDR4NCk6IFRlcnJhaW5JbmZvIHtcbiAgICAgIGlmICghX210eEludmVyc2UpXG4gICAgICAgIF9tdHhJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0lPTihfbXR4V29ybGQpO1xuXG4gICAgICBsZXQgdGVycmFpbkluZm86IFRlcnJhaW5JbmZvID0gbmV3IFRlcnJhaW5JbmZvO1xuXG4gICAgICBsZXQgcG9zTG9jYWw6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF9wb3NpdGlvbiwgX210eEludmVyc2UsIHRydWUpO1xuXG5cbiAgICAgIGxldCB6OiBudW1iZXIgPSBNYXRoLmZsb29yKChwb3NMb2NhbC56ICsgMC41KSAqIHRoaXMucmVzb2x1dGlvbi55KTtcbiAgICAgIGxldCB4OiBudW1iZXIgPSBNYXRoLmZsb29yKChwb3NMb2NhbC54ICsgMC41KSAqIHRoaXMucmVzb2x1dGlvbi54KTtcbiAgICAgIGlmICh6IDwgMCB8fCB6ID4gdGhpcy5yZXNvbHV0aW9uLnkgLSAxIHx8IHggPCAwIHx8IHggPiB0aGlzLnJlc29sdXRpb24ueCAtIDEpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICBsZXQgaW5kZXg6IG51bWJlciA9ICh6ICogdGhpcy5yZXNvbHV0aW9uLnggKyB4KSAqIDI7XG4gICAgICBsZXQgZmFjZTogRmFjZSA9IHRoaXMuZmFjZXNbaW5kZXhdO1xuXG4gICAgICBsZXQgcmF5OiBSYXkgPSBuZXcgUmF5KFZlY3RvcjMuWSgpLCBwb3NMb2NhbCk7XG4gICAgICBsZXQgcG9pbnQ6IFZlY3RvcjMgPSByYXkuaW50ZXJzZWN0RmFjZVBsYW5lKGZhY2UpO1xuICAgICAgaWYgKCFmYWNlLmlzSW5zaWRlKHBvaW50KSkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1tpbmRleF07XG4gICAgICAgIHBvaW50ID0gcmF5LmludGVyc2VjdEZhY2VQbGFuZShmYWNlKTtcbiAgICAgIH1cblxuICAgICAgdGVycmFpbkluZm8uaW5kZXggPSBpbmRleDtcbiAgICAgIHRlcnJhaW5JbmZvLnBvc2l0aW9uRmFjZSA9IHBvaW50O1xuICAgICAgdGVycmFpbkluZm8ucG9zaXRpb24gPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHBvaW50LCBfbXR4V29ybGQsIHRydWUpO1xuICAgICAgdGVycmFpbkluZm8ubm9ybWFsID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihmYWNlLm5vcm1hbCwgTWF0cml4NHg0LlRSQU5TUE9TRShfbXR4SW52ZXJzZSksIGZhbHNlKTtcbiAgICAgIHRlcnJhaW5JbmZvLmRpc3RhbmNlID0gX3Bvc2l0aW9uLnkgLSB0ZXJyYWluSW5mby5wb3NpdGlvbi55O1xuICAgICAgdGVycmFpbkluZm8uZ3JpZCA9IHRoaXMuZ2V0R3JpZEZyb21GYWNlSW5kZXgoaW5kZXgpO1xuICAgICAgcmV0dXJuIHRlcnJhaW5JbmZvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyaWQgY29vcmRpbmF0ZXMgb2YgdGhlIHF1YWQgdGhlIGdpdmVuIGZhY2UgYmVsb25ncyB0by5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0R3JpZEZyb21GYWNlSW5kZXgoX2luZGV4OiBudW1iZXIpOiBWZWN0b3IyIHtcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XG4gICAgICBsZXQgaVF1YWQ6IG51bWJlciA9IE1hdGguZmxvb3IoX2luZGV4IC8gMik7XG4gICAgICByZXN1bHQuc2V0KGlRdWFkICUgdGhpcy5yZXNvbHV0aW9uLnksIE1hdGguZmxvb3IoaVF1YWQgLyB0aGlzLnJlc29sdXRpb24ueCkpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRpY2VzIG9mIHRoZSB0d28gZmFjZXMgZm9ybWluZyB0aGUgcXVhZCB0aGUgZ2l2ZW4gZ3JpZCBwb3NpdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRGYWNlSW5kaWNlc0Zyb21HcmlkKF9ncmlkOiBWZWN0b3IyKTogbnVtYmVyW10ge1xuICAgICAgbGV0IGlRdWFkOiBudW1iZXIgPSBfZ3JpZC55ICogMiAqIHRoaXMucmVzb2x1dGlvbi54ICsgX2dyaWQueCAqIDI7XG4gICAgICByZXR1cm4gW2lRdWFkLCBpUXVhZCArIDFdO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5zZWVkID0gdGhpcy5zZWVkO1xuICAgICAgc2VyaWFsaXphdGlvbi5zY2FsZSA9IHRoaXMuc2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICBzZXJpYWxpemF0aW9uLnJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24uc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIGF3YWl0IHRoaXMucmVzb2x1dGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5yZXNvbHV0aW9uKTtcbiAgICAgIGF3YWl0IHRoaXMuc2NhbGUuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uc2NhbGUpO1xuICAgICAgdGhpcy5zZWVkID0gX3NlcmlhbGl6YXRpb24uc2VlZDtcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMucmVzb2x1dGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5zZWVkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnJlc29sdXRpb24sIHRoaXMuc2NhbGUsIHRoaXMuc2VlZCk7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiTWVzaFRlcnJhaW4udHNcIi8+XG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHBsYW5hciBHcmlkIGFuZCBhcHBsaWVzIGEgSGVpZ2h0bWFwLUZ1bmN0aW9uIHRvIGl0LlxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMSB8IE1vcml0eiBCZWF1Z3JhbmQsIEhGVSwgMjAyMFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE1lc2hSZWxpZWYgZXh0ZW5kcyBNZXNoVGVycmFpbiB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUmVsaWVmKTtcbiAgICBwcml2YXRlIHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFJlbGllZlwiLCBfdGV4dHVyZTogVGV4dHVyZUltYWdlID0gbnVsbCkge1xuICAgICAgc3VwZXIoX25hbWUsIFZlY3RvcjIuT05FKDIpLCB1bmRlZmluZWQsIChfeDogbnVtYmVyLCBfejogbnVtYmVyKSA9PiAwKTtcbiAgICAgIHRoaXMuc2V0VGV4dHVyZShfdGV4dHVyZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlSGVpZ2h0TWFwRnVuY3Rpb24oX3RleHR1cmU6IFRleHR1cmVJbWFnZSk6IEhlaWdodE1hcEZ1bmN0aW9uIHtcbiAgICAgIGxldCBhcnJheTogVWludDhDbGFtcGVkQXJyYXkgPSBNZXNoUmVsaWVmLnRleHR1cmVUb0NsYW1wZWRBcnJheShfdGV4dHVyZSk7XG4gICAgICBsZXQgaGVpZ2h0TWFwRnVuY3Rpb246IEhlaWdodE1hcEZ1bmN0aW9uID0gKF94OiBudW1iZXIsIF96OiBudW1iZXIpID0+IHtcbiAgICAgICAgbGV0IHBpeGVsOiBudW1iZXIgPSBNYXRoLnJvdW5kKF96ICogX3RleHR1cmUuaW1hZ2Uud2lkdGggKyBfeCk7XG4gICAgICAgIHJldHVybiBhcnJheVtwaXhlbCAqIDRdIC8gMjU1O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBoZWlnaHRNYXBGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyB0ZXh0dXJlVG9DbGFtcGVkQXJyYXkoX3RleHR1cmU6IFRleHR1cmVJbWFnZSk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IF90ZXh0dXJlLmltYWdlLndpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IF90ZXh0dXJlLmltYWdlLmhlaWdodDtcblxuICAgICAgbGV0IGNyYzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGNyYy5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNyYy5kcmF3SW1hZ2UoX3RleHR1cmUuaW1hZ2UsIDAsIDApO1xuXG4gICAgICByZXR1cm4gY3JjLmdldEltYWdlRGF0YSgwLCAwLCBfdGV4dHVyZS5pbWFnZS53aWR0aCwgX3RleHR1cmUuaW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHR1cmUgdG8gYmUgdXNlZCBhcyBoZWlnaHRtYXBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0VGV4dHVyZShfdGV4dHVyZTogVGV4dHVyZUltYWdlID0gbnVsbCk6IHZvaWQge1xuICAgICAgaWYgKCFfdGV4dHVyZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy50ZXh0dXJlID0gX3RleHR1cmU7XG4gICAgICBsZXQgcmVzb2x1dGlvbjogVmVjdG9yMiA9IF90ZXh0dXJlID8gbmV3IFZlY3RvcjIoX3RleHR1cmUuaW1hZ2Uud2lkdGggLSAxLCBfdGV4dHVyZS5pbWFnZS5oZWlnaHQgLSAxKSA6IHVuZGVmaW5lZDtcbiAgICAgIHN1cGVyLmNyZWF0ZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uLCBNZXNoUmVsaWVmLmNyZWF0ZUhlaWdodE1hcEZ1bmN0aW9uKF90ZXh0dXJlKSk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5zZWVkO1xuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uc2NhbGU7XG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5yZXNvbHV0aW9uO1xuXG4gICAgICBpZiAodGhpcy50ZXh0dXJlKVxuICAgICAgICBzZXJpYWxpemF0aW9uLmlkVGV4dHVyZSA9IHRoaXMudGV4dHVyZS5pZFJlc291cmNlO1xuXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gPFRleHR1cmVJbWFnZT5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSk7XG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZSh0aGlzLnRleHR1cmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IudGV4dHVyZSkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZShfbXV0YXRvci50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XG4gICAgICBkZWxldGUgX211dGF0b3Iuc2VlZDtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zY2FsZTtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5yZXNvbHV0aW9uO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxufSIsIi8vIC88cmVmZXJlbmNlIHBhdGg9XCJNZXNoUG9seWdvbi50c1wiLz5cbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcm90YXRpb24gb2YgYSBwb2x5Z29uIGFyb3VuZCB0aGUgeS1heGlzXG4gICAqIGBgYHRleHQgICAgICAgXG4gICAqICAgICAgICAgICAgICAgICAgICAgeVxuICAgKiAgICAgICAgICAgICAgICAgIF8gIOKGkSAwXzFcbiAgICogICAgICAgICAgICAgICAgIOKUgiAgIOKUguKGkngg4pSCMiAgICAgICAgIFxuICAgKiAgICAgICAgICAgICAgICAgIOKVsiAg4pSCICDilbEzICAgICAgICAgXG4gICAqICAgICAgICAgICAgICAgICAg4pWxICDilIIgIOKVsiAgIFxuICAgKiAgICAgICAgICAgICAgICAg4pWxX19f4pSCX19f4pWyNCBcbiAgICogICAgICAgICAgICAgICAgICAgICAgNVxuICAgKiBgYGBcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE1lc2hSb3RhdGlvbiBleHRlbmRzIE1lc2gge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFJvdGF0aW9uKTtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHZlcnRpY2VzRGVmYXVsdDogVmVjdG9yMltdID0gWyAvLyBsaW5lIGlzIHRoZSBtaW5pbWFsIHNoYXBlXG4gICAgICBuZXcgVmVjdG9yMigwLjUsIDAuNSksXG4gICAgICBuZXcgVmVjdG9yMigwLjUsIC0wLjUpXG4gICAgXTtcbiAgICBwcm90ZWN0ZWQgc2hhcGU6IE11dGFibGVBcnJheTxWZWN0b3IyPiA9IG5ldyBNdXRhYmxlQXJyYXk8VmVjdG9yMj4oVmVjdG9yMik7XG4gICAgcHJvdGVjdGVkIGxvbmdpdHVkZXM6IG51bWJlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoUm90YXRpb25cIiwgX3NoYXBlOiBWZWN0b3IyW10gPSBNZXNoUm90YXRpb24udmVydGljZXNEZWZhdWx0LCBfbG9uZ2l0dWRlczogbnVtYmVyID0gMykge1xuICAgICAgc3VwZXIoX25hbWUpO1xuICAgICAgdGhpcy5yb3RhdGUoX3NoYXBlLCBfbG9uZ2l0dWRlcyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIk11dGF0b3JcIiwgdGhpcy5nZXRNdXRhdG9yKCkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgbWluVmVydGljZXMoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5zaGFwZSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQXJyYXkoVmVjdG9yMiwgdGhpcy5zaGFwZSk7XG4gICAgICBzZXJpYWxpemF0aW9uLmxvbmdpdHVkZXMgPSB0aGlzLmxvbmdpdHVkZXM7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgbGV0IHNoYXBlOiBWZWN0b3IyW10gPSA8VmVjdG9yMltdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi5zaGFwZSk7XG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBfc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzO1xuICAgICAgdGhpcy5yb3RhdGUoc2hhcGUsIHRoaXMubG9uZ2l0dWRlcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5zaGFwZSwgdGhpcy5sb25naXR1ZGVzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgcHJvdGVjdGVkIHJvdGF0ZShfc2hhcGU6IFZlY3RvcjJbXSwgX2xvbmdpdHVkZXM6IG51bWJlcik6IHZvaWQge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhpcy5zaGFwZSA9IDxNdXRhYmxlQXJyYXk8VmVjdG9yMj4+TXV0YWJsZUFycmF5LmZyb20oX3NoYXBlLm1hcChfdmVydGV4ID0+IF92ZXJ0ZXguY2xvbmUpKTtcbiAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IE1hdGgucm91bmQoX2xvbmdpdHVkZXMpO1xuICAgICAgbGV0IGFuZ2xlOiBudW1iZXIgPSAzNjAgLyB0aGlzLmxvbmdpdHVkZXM7XG4gICAgICBsZXQgbXR4Um90YXRlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShhbmdsZSk7XG4gICAgICAvLyBjb3B5IG9yaWdpbmFsIHBvbHlnb24gYXMgVmVjdG9yMyBhcnJheVxuICAgICAgbGV0IHBvbHlnb246IFZlY3RvcjNbXSA9IFtdO1xuICAgICAgbGV0IGRpc3RhbmNlczogbnVtYmVyW10gPSBbMF07XG4gICAgICBsZXQgdG90YWw6IG51bWJlciA9IDA7XG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5zaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2x5Z29uLnB1c2godGhpcy5zaGFwZVtpXS50b1ZlY3RvcjMoKSk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGxldCBkaXN0YW5jZTogbnVtYmVyID0gVmVjdG9yMi5ESUZGRVJFTkNFKHRoaXMuc2hhcGVbaV0sIHRoaXMuc2hhcGVbaSAtIDFdKS5tYWduaXR1ZGU7XG4gICAgICAgICAgdG90YWwgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgZGlzdGFuY2VzLnB1c2godG90YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkaXN0YW5jZXMuZm9yRWFjaCgoX2VudHJ5LCBfaW5kZXgpID0+IHsgZGlzdGFuY2VzW19pbmRleF0gPSBfZW50cnkgLyB0b3RhbDsgfSk7XG5cbiAgICAgIGxldCBuVmVydGljZXNQb2x5Z29uOiBudW1iZXIgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgICAgbGV0IGNsb3VkOiBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xuICAgICAgZm9yIChsZXQgbG9uZ2l0dWRlOiBudW1iZXIgPSAwOyBsb25naXR1ZGUgPD0gdGhpcy5sb25naXR1ZGVzOyBsb25naXR1ZGUrKykge1xuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgblZlcnRpY2VzUG9seWdvbjsgaSsrKSB7XG4gICAgICAgICAgbGV0IHV2OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIobG9uZ2l0dWRlIC8gdGhpcy5sb25naXR1ZGVzLCBkaXN0YW5jZXNbaV0pO1xuICAgICAgICAgIC8vIFRPRE86IGxhc3Qgc2VjdG9yIHNob3VsZCBvbmx5IGJlIHJlZmVyZW5jZXMgdG8gdGhlIGZpcnN0IG1lcmlkaWFuXG4gICAgICAgICAgaWYgKGxvbmdpdHVkZSA9PSB0aGlzLmxvbmdpdHVkZXMpXG4gICAgICAgICAgICBjbG91ZC5wdXNoKG5ldyBWZXJ0ZXgoaSwgdXYpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb25naXR1ZGUgPiAwICYmIHRoaXMuc2hhcGVbaV0ueCA9PSAwKSAvLyB1c2UgYSBzaW5nbGUgdmVydGV4IHdoZW4gaXQncyBvbiB0aGUgcm90YXRpb24gYXhpc1xuICAgICAgICAgICAgICBjbG91ZC5wdXNoKG5ldyBWZXJ0ZXgoaSwgdXYpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgY2xvdWQucHVzaChuZXcgVmVydGV4KHBvbHlnb25baV0uY2xvbmUsIHV2KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaCgoX3ZlY3RvcjogVmVjdG9yMykgPT4gX3ZlY3Rvci50cmFuc2Zvcm0obXR4Um90YXRlKSk7XG4gICAgICB9XG5cblxuICAgICAgLy8gY29weSBpbmRpY2VzIHRvIG5ldyBpbmRleCBhcnJheVxuICAgICAgbGV0IGZhY2VzOiBGYWNlW10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgbG9uZ2l0dWRlOiBudW1iZXIgPSAwOyBsb25naXR1ZGUgPCB0aGlzLmxvbmdpdHVkZXM7IGxvbmdpdHVkZSsrKSB7XG4gICAgICAgIGZvciAobGV0IGxhdGl0dWRlOiBudW1iZXIgPSAwOyBsYXRpdHVkZSA8IG5WZXJ0aWNlc1BvbHlnb24gLSAxOyBsYXRpdHVkZSsrKSB7XG4gICAgICAgICAgbGV0IHN0YXJ0OiBudW1iZXIgPSBsb25naXR1ZGUgKiBuVmVydGljZXNQb2x5Z29uICsgbGF0aXR1ZGU7XG4gICAgICAgICAgbGV0IHF1YWQ6IFF1YWQgPSBuZXcgUXVhZChjbG91ZCwgc3RhcnQgKyAxLCBzdGFydCArIDEgKyBuVmVydGljZXNQb2x5Z29uLCBzdGFydCArIG5WZXJ0aWNlc1BvbHlnb24sIHN0YXJ0KTtcbiAgICAgICAgICBmYWNlcy5wdXNoKC4uLnF1YWQuZmFjZXMpO1xuICAgICAgICAgIC8vIFRPRE86IGNhdGNoIGludmFsaWQgZmFjZXMgcmlnaHQgaGVyZS4uLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmVydGljZXMgPSBjbG91ZDtcbiAgICAgIHRoaXMuZmFjZXMgPSBmYWNlcztcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICAvKipcbiAgICogQnVmZmVycyB0aGUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgTWVzaFNraW59IGludG8gYSBXZWJHTCBCdWZmZXJcbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JNZXNoU2tpbiBleHRlbmRzIFJlbmRlckluamVjdG9yTWVzaCB7XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcInVzZVJlbmRlckJ1ZmZlcnNcIiwge1xuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoU2tpbi51c2VSZW5kZXJCdWZmZXJzXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImdldFJlbmRlckJ1ZmZlcnNcIiwge1xuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoU2tpbi5nZXRSZW5kZXJCdWZmZXJzXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImRlbGV0ZVJlbmRlckJ1ZmZlcnNcIiwge1xuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoU2tpbi5kZWxldGVSZW5kZXJCdWZmZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldFJlbmRlckJ1ZmZlcnModGhpczogTWVzaFNraW4sIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIpOiBSZW5kZXJCdWZmZXJzIHtcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gc3VwZXIuZ2V0UmVuZGVyQnVmZmVycy5jYWxsKHRoaXMsIF9zaGFkZXIpO1xuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcblxuICAgICAgaWYgKCFyZW5kZXJCdWZmZXJzLmJvbmVzKSB7XG4gICAgICAgIHJlbmRlckJ1ZmZlcnMuYm9uZXMgPSBSZW5kZXJXZWJHTC5hc3NlcnQoY3JjMy5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgcmVuZGVyQnVmZmVycy5ib25lcyk7XG4gICAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLmJvbmVzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZW5kZXJCdWZmZXJzLndlaWdodHMpIHtcbiAgICAgICAgcmVuZGVyQnVmZmVycy53ZWlnaHRzID0gUmVuZGVyV2ViR0wuYXNzZXJ0KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHJlbmRlckJ1ZmZlcnMud2VpZ2h0cyk7XG4gICAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLndlaWdodHMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVuZGVyQnVmZmVycztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckJ1ZmZlcnModGhpczogTWVzaFNraW4sIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9tdHhNZXNoVG9Xb3JsZDogTWF0cml4NHg0LCBfbXR4TWVzaFRvVmlldzogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIpOiBSZW5kZXJCdWZmZXJzIHtcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gc3VwZXIudXNlUmVuZGVyQnVmZmVycy5jYWxsKHRoaXMsIF9zaGFkZXIsIF9tdHhNZXNoVG9Xb3JsZCwgX210eE1lc2hUb1ZpZXcsIF9pZCk7XG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xuXG4gICAgICBjb25zdCBhQm9uZTogbnVtYmVyID0gX3NoYWRlci5hdHRyaWJ1dGVzW1wiYV92Y3RCb25lc1wiXTtcbiAgICAgIGlmIChhQm9uZSkge1xuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHJlbmRlckJ1ZmZlcnMuYm9uZXMpO1xuICAgICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFCb25lKTtcbiAgICAgICAgY3JjMy52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihhQm9uZSwgNCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYVdlaWdodDogbnVtYmVyID0gX3NoYWRlci5hdHRyaWJ1dGVzW1wiYV92Y3RXZWlnaHRzXCJdO1xuICAgICAgaWYgKGFXZWlnaHQpIHtcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCByZW5kZXJCdWZmZXJzLndlaWdodHMpO1xuICAgICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFXZWlnaHQpO1xuICAgICAgICBjcmMzLnZlcnRleEF0dHJpYlBvaW50ZXIoYVdlaWdodCwgNCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVuZGVyQnVmZmVycztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMpOiB2b2lkIHtcbiAgICAgIHN1cGVyLmRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnMpO1xuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcblxuICAgICAgaWYgKF9yZW5kZXJCdWZmZXJzKSB7XG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICAgIGNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLmJvbmVzKTtcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMud2VpZ2h0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLy4uL1JlbmRlci9SZW5kZXJJbmplY3Rvck1lc2hTa2luLnRzXCIvPlxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi9NZXNoSW1wb3J0LnRzXCIvPlxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBNZXNoIGluZmx1ZW5jZWQgYnkgYSBza2VsZXRvbiBhbmQgbG9hZGVkIGZyb20gYSBmaWxlXG4gICAqIEBhdXRob3JzIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIyLTIwMjMgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcbiAgICovXG4gIEBSZW5kZXJJbmplY3Rvck1lc2hTa2luLmRlY29yYXRlXG4gIGV4cG9ydCBjbGFzcyBNZXNoU2tpbiBleHRlbmRzIE1lc2hJbXBvcnQge1xuICAgIC8vIFN1YmNsYXNzIHVzZWQgZm9yIHNraW5uaW5nXG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVVYgU3BoZXJlIHdpdGggYSBnaXZlbiBudW1iZXIgb2Ygc2VjdG9ycyBhbmQgc3RhY2tzIChjbGFtcGVkIGF0IDEyOCoxMjgpXG4gICAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9zcGhlcmUuaHRtbFxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIE1lc2hTcGhlcmUgZXh0ZW5kcyBNZXNoUm90YXRpb24ge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFNwaGVyZSk7XG4gICAgcHJpdmF0ZSBsYXRpdHVkZXM6IG51bWJlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoU3BoZXJlXCIsIF9sb25naXR1ZGVzOiBudW1iZXIgPSA4LCBfbGF0aXR1ZGVzOiBudW1iZXIgPSA4KSB7XG4gICAgICBzdXBlcihfbmFtZSk7XG4gICAgICB0aGlzLmNyZWF0ZShfbG9uZ2l0dWRlcywgX2xhdGl0dWRlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoaXMgc3BoZXJlIHdpdGggYSBnaXZlbiBudW1iZXIgb2YgbG9uZ2l0dWRlcyBhbmQgbGF0aXR1ZGVzXG4gICAgICovXG4gICAgcHVibGljIGNyZWF0ZShfbG9uZ2l0dWRlczogbnVtYmVyID0gMywgX2xhdGl0dWRlczogbnVtYmVyID0gMik6IHZvaWQge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgLy9DbGFtcCByZXNvbHV0aW9uIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKF9sb25naXR1ZGVzKSwgMTI4KTtcbiAgICAgIHRoaXMubGF0aXR1ZGVzID0gTWF0aC5taW4oTWF0aC5yb3VuZChfbGF0aXR1ZGVzKSwgMTI4KTtcblxuICAgICAgaWYgKF9sb25naXR1ZGVzIDwgMyB8fCBfbGF0aXR1ZGVzIDwgMikge1xuICAgICAgICBEZWJ1Zy53YXJuKFwiVVYgU3BoZXJlIG11c3QgaGF2ZSBhdCBsZWFzdCAzIGxvbmdpdHVkZXMgYW5kIDIgbGF0aXR1ZGVzIHRvIGZvcm0gYSAzLWRpbWVuc2lvbmFsIHNoYXBlLlwiKTtcbiAgICAgICAgdGhpcy5sb25naXR1ZGVzID0gTWF0aC5tYXgoMywgX2xvbmdpdHVkZXMpO1xuICAgICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWF4KDIsIF9sYXRpdHVkZXMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IFtdO1xuICAgICAgbGV0IHN0ZXA6IG51bWJlciA9IE1hdGguUEkgLyB0aGlzLmxhdGl0dWRlcztcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPD0gdGhpcy5sYXRpdHVkZXM7ICsraSkge1xuICAgICAgICBsZXQgYW5nbGU6IG51bWJlciA9IE1hdGguUEkgLyAyIC0gaSAqIHN0ZXA7XG4gICAgICAgIGxldCB4OiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIGxldCB5OiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgc2hhcGUucHVzaChuZXcgVmVjdG9yMih4IC8gMiwgeSAvIDIpKTtcbiAgICAgIH1cbiAgICAgIC8vIHBsYWNlIGZpcnN0IGFuZCBsYXN0IHZlcnRleCBleGFjdGx5IG9uIHJvdGF0aW9uIGF4aXNcbiAgICAgIHNoYXBlWzBdLnggPSAwO1xuICAgICAgc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV0ueCA9IDA7XG5cbiAgICAgIHN1cGVyLnJvdGF0ZShzaGFwZSwgX2xvbmdpdHVkZXMpO1xuICAgIH1cblxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5zaGFwZTtcbiAgICAgIHNlcmlhbGl6YXRpb24ubGF0aXR1ZGVzID0gdGhpcy5sYXRpdHVkZXM7XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgdGhpcy5jcmVhdGUoX3NlcmlhbGl6YXRpb24ubG9uZ2l0dWRlcywgX3NlcmlhbGl6YXRpb24ubGF0aXR1ZGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLmxvbmdpdHVkZXMsIHRoaXMubGF0aXR1ZGVzKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XG4gICAgICBkZWxldGUgX211dGF0b3Iuc2hhcGU7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSB0d28gcXVhZHMgcGxhY2VkIGJhY2sgdG8gYmFjaywgdGhlIG9uZSBmYWNpbmcgaW4gbmVnYXRpdmUgWi1kaXJlY3Rpb24gaXMgdGV4dHVyZWQgcmV2ZXJzZWRcbiAgICogYGBgdGV4dFxuICAgKiAgICAgICAgMCBfXyAzXG4gICAqICAgICAgICAgfF9ffFxuICAgKiAgICAgICAgMSAgICAyICAgICAgICAgICAgIFxuICAgKiBgYGAgXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXG4gICAqL1xuICBleHBvcnQgY2xhc3MgTWVzaFNwcml0ZSBleHRlbmRzIE1lc2gge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFNwcml0ZSk7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFNwcml0ZVwiKSB7XG4gICAgICBzdXBlcihfbmFtZSk7XG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKFxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIDAuNSwgMCksIG5ldyBWZWN0b3IyKDAsIDApKSxcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAtMC41LCAwKSwgbmV3IFZlY3RvcjIoMCwgMSkpLFxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgLTAuNSwgMCksIG5ldyBWZWN0b3IyKDEsIDEpKSxcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuNSwgMCksIG5ldyBWZWN0b3IyKDEsIDApKVxuICAgICAgKTtcbiAgICAgIHRoaXMuZmFjZXMgPSBbXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDEsIDIsIDApLFxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCAyLCAzLCAwKSxcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgMCwgMywgMSksXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDMsIDIsIDEpXG4gICAgICBdO1xuICAgIH1cblxuICAgIC8vIGZsYXQgaXMgc3RhbmRhcmQgaGVyZVxuICAgIHB1YmxpYyBnZXQgdmVydGljZXNGbGF0KCk6IEZsb2F0MzJBcnJheSB7IHJldHVybiB0aGlzLnJlbmRlck1lc2gudmVydGljZXM7IH1cbiAgICBwdWJsaWMgZ2V0IGluZGljZXNGbGF0KCk6IFVpbnQxNkFycmF5IHsgcmV0dXJuIHRoaXMucmVuZGVyTWVzaC5pbmRpY2VzOyB9XG5cbiAgICAvLyBpbnN0ZWFkLCBzbW9vdGggc2hhZGluZyB3b3VsZCBuZWVkIGV4dHJhIGF0dGVudGlvbiBidXQgaXMgbm90IHJlbGV2YW50Li4uXG5cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogR2VuZXJhdGUgYSBUb3J1cyB3aXRoIGEgZ2l2ZW4gdGhpY2tuZXNzIGFuZCB0aGUgbnVtYmVyIG9mIG1ham9yLSBhbmQgbWlub3Igc2VnbWVudHNcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNZXNoVG9ydXMgZXh0ZW5kcyBNZXNoUm90YXRpb24ge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFRvcnVzKTtcbiAgICBwcml2YXRlIHNpemU6IG51bWJlciA9IDAuMjU7XG4gICAgcHJpdmF0ZSBsYXRpdHVkZXM6IG51bWJlciA9IDEyO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hUb3J1c1wiLCBfc2l6ZTogbnVtYmVyID0gMC4yNSwgX2xvbmdpdHVkZXM6IG51bWJlciA9IDgsIF9sYXRpdHVkZXM6IG51bWJlciA9IDYpIHtcbiAgICAgIHN1cGVyKF9uYW1lLCBNZXNoVG9ydXMuZ2V0U2hhcGUoX3NpemUsIE1hdGgubWF4KDMsIF9sYXRpdHVkZXMpKSwgX2xvbmdpdHVkZXMpO1xuICAgICAgdGhpcy5zaXplID0gX3NpemU7XG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBfbG9uZ2l0dWRlcztcbiAgICAgIHRoaXMubGF0aXR1ZGVzID0gTWF0aC5tYXgoMywgX2xhdGl0dWRlcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0U2hhcGUoX3NpemU6IG51bWJlciwgX2xhdGl0dWRlczogbnVtYmVyKTogVmVjdG9yMltdIHtcbiAgICAgIGxldCBzaGFwZTogVmVjdG9yMltdID0gW107XG4gICAgICBsZXQgcmFkaXVzOiBudW1iZXIgPSBfc2l6ZSAvIDI7XG4gICAgICBsZXQgY2VudGVyOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoMC4yNSArIHJhZGl1cywgMCk7XG4gICAgICBmb3IgKGxldCBsYXRpdHVkZTogbnVtYmVyID0gMDsgbGF0aXR1ZGUgPD0gX2xhdGl0dWRlczsgbGF0aXR1ZGUrKykge1xuICAgICAgICBsZXQgYW5nbGU6IG51bWJlciA9IDIgKiBNYXRoLlBJICogbGF0aXR1ZGUgLyBfbGF0aXR1ZGVzO1xuICAgICAgICBzaGFwZS5wdXNoKFZlY3RvcjIuU1VNKGNlbnRlciwgbmV3IFZlY3RvcjIocmFkaXVzICogLU1hdGguY29zKGFuZ2xlKSwgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGlzIHRvcnVzIGZyb20gdGhlIGdpdmVuIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBwdWJsaWMgY3JlYXRlKF9zaXplOiBudW1iZXIgPSAwLjI1LCBfbG9uZ2l0dWRlczogbnVtYmVyID0gOCwgX2xhdGl0dWRlczogbnVtYmVyID0gNik6IHZvaWQge1xuICAgICAgdGhpcy5zaXplID0gX3NpemU7XG4gICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWF4KDMsIF9sYXRpdHVkZXMpO1xuICAgICAgc3VwZXIucm90YXRlKE1lc2hUb3J1cy5nZXRTaGFwZShfc2l6ZSwgX2xhdGl0dWRlcyksIF9sb25naXR1ZGVzKTtcbiAgICB9XG5cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMgPSB0aGlzLmxhdGl0dWRlcztcbiAgICAgIHNlcmlhbGl6YXRpb24uc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XG4gICAgICB0aGlzLmNyZWF0ZShfc2VyaWFsaXphdGlvbi5zaXplLCBfc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzLCBfc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMuc2l6ZSwgdGhpcy5sb25naXR1ZGVzLCB0aGlzLmxhdGl0dWRlcyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNoYXBlO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgZW51bSBRVUFEU1BMSVQge1xuICAgIFBMQU5BUiwgQVRfMCwgQVRfMVxuICB9XG5cbiAgLyoqXG4gICAqIEEgc3VyZmFjZSBjcmVhdGVkIHdpdGggZm91ciB2ZXJ0aWNlcyB3aGljaCBpbW1lZGlhdGVseSBjcmVhdGVzIG5vbmUsIG9uZSBvciB0d28ge0BsaW5rIEZhY2V9cyBkZXBlbmRpbmcgb24gdmVydGljZXMgYXQgaWRlbnRpY2FsIHBvc2l0aW9ucy5cbiAgICogYGBgdGV4dFxuICAgKiBRVUFEU1BMSVQ6ICBQTEFOQVIgICAgICAgICAgICAgICAgICBBVF8wICAgICAgICAgICAgICAgICAgICAgQVRfMVxuICAgKiAgICAgICAgICAgICAwIF8gMyAgICAgICAgICAgICAgICAgICAwIF8gMyAgICAgICAgICAgICAgICAgICAgMCBfIDMgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAqICAgICAgICAgICAgICB8XFx8ICAgICAgICAgICAgICAgICAgICAgfFxcfCAgICAgICAgICAgICAgICAgICAgICB8L3wgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAqICAgICAgICAgICAgIDEg4oC+IDIgICAgICAgICAgICAgICAgICAgMSDigL4gMiAgICAgICAgICAgICAgICAgICAgMSDigL4gMiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgKiAgc2hhcmVkIGxhc3QgdmVydGV4IDIgICAgICBsYXN0IHZlcnRpY2VzIDIgKyAzICAgICAgbGFzdCB2ZXJ0aWNlcyAzICsgMCBcbiAgICogICAgICBcbiAgICogYGBgIFxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFF1YWQge1xuICAgIHB1YmxpYyBmYWNlczogRmFjZVtdO1xuICAgICNzcGxpdDogUVVBRFNQTElUO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF92ZXJ0aWNlczogVmVydGljZXMsIF9pbmRleDA6IG51bWJlciwgX2luZGV4MTogbnVtYmVyLCBfaW5kZXgyOiBudW1iZXIsIF9pbmRleDM6IG51bWJlciwgX3NwbGl0OiBRVUFEU1BMSVQgPSBRVUFEU1BMSVQuUExBTkFSKSB7XG4gICAgICB0aGlzLmZhY2VzID0gW107XG4gICAgICB0aGlzLiNzcGxpdCA9IF9zcGxpdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfc3BsaXQgIT0gUVVBRFNQTElULkFUXzEpXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MCwgX2luZGV4MSwgX2luZGV4MikpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MSwgX2luZGV4MiwgX2luZGV4MykpO1xuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHtcbiAgICAgICAgRGVidWcuZnVkZ2UoXCJGYWNlIGV4Y2x1ZGVkXCIsICg8RXJyb3I+X2UpLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9zcGxpdCA9PSBRVUFEU1BMSVQuUExBTkFSKVxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDMsIF9pbmRleDAsIF9pbmRleDIpKTtcbiAgICAgICAgZWxzZSBpZiAoX3NwbGl0ID09IFFVQURTUExJVC5BVF8wKVxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDAsIF9pbmRleDIsIF9pbmRleDMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDEsIF9pbmRleDMsIF9pbmRleDApKTtcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7XG4gICAgICAgIERlYnVnLmZ1ZGdlKFwiRmFjZSBleGNsdWRlZFwiLCAoPEVycm9yPl9lKS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHNwbGl0KCk6IFFVQURTUExJVCB7XG4gICAgICByZXR1cm4gdGhpcy4jc3BsaXQ7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBCb25lIHtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIHdlaWdodDogbnVtYmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSB2ZXJ0ZXggb2YgYSBtZXNoIHdpdGggZXh0ZW5kZWQgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdXYgY29vcmRpbmF0ZXMgYW5kIHRoZSB2ZXJ0ZXggbm9ybWFsLlxuICAgKiBJdCBtYXkgcmVmZXIgdG8gYW5vdGhlciB2ZXJ0ZXggdmlhIGFuIGluZGV4IGludG8gc29tZSBhcnJheSwgaW4gd2hpY2ggY2FzZSB0aGUgcG9zaXRpb24gYW5kIHRoZSBub3JtYWwgYXJlIHN0b3JlZCB0aGVyZS5cbiAgICogVGhpcyB3YXksIHZlcnRleCBwb3NpdGlvbiBhbmQgbm9ybWFsIGlzIGEgMToxIGFzc29jaWF0aW9uLCB2ZXJ0ZXggdG8gdGV4dHVyZSBjb29yZGluYXRlcyBhIDE6biBhc3NvY2lhdGlvbi5cbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBWZXJ0ZXgge1xuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcbiAgICBwdWJsaWMgdXY6IFZlY3RvcjI7XG4gICAgcHVibGljIG5vcm1hbDogVmVjdG9yMztcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xuICAgIHB1YmxpYyByZWZlclRvOiBudW1iZXI7XG4gICAgcHVibGljIGJvbmVzOiBCb25lW107XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3Bvc2l0aW9uT3JJbmRleDogVmVjdG9yMyB8IG51bWJlciwgX3V2OiBWZWN0b3IyID0gdW5kZWZpbmVkLCBfbm9ybWFsOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCksIF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSksIF9ib25lczogQm9uZVtdID0gbnVsbCkge1xuICAgICAgaWYgKF9wb3NpdGlvbk9ySW5kZXggaW5zdGFuY2VvZiBWZWN0b3IzKVxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gX3Bvc2l0aW9uT3JJbmRleDtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5yZWZlclRvID0gX3Bvc2l0aW9uT3JJbmRleDtcblxuICAgICAgdGhpcy51diA9IF91djtcbiAgICAgIHRoaXMubm9ybWFsID0gX25vcm1hbDtcbiAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XG4gICAgICB0aGlzLmJvbmVzID0gX2JvbmVzO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQXJyYXkgd2l0aCBleHRlbmRlZCBmdW5jdGlvbmFsaXR5IHRvIHNlcnZlIGFzIGEge0BsaW5rIFZlcnRleH0tY2xvdWQuIFxuICAgKiBBY2Nlc3NvcnMgeWllbGQgcG9zaXRpb24gb3Igbm9ybWFsIGFsc28gZm9yIHZlcnRpY2VzIHJlZmVyZW5jaW5nIG90aGVyIHZlcnRpY2VzXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXG4gICAqL1xuICBleHBvcnQgY2xhc3MgVmVydGljZXMgZXh0ZW5kcyBBcnJheTxWZXJ0ZXg+IHtcbiAgICAvLyBUT0RPOiB0aGlzIGNsYXNzIG1heSBiZWNvbWUgbW9yZSBwb3dlcmZ1bCBieSBoaWRpbmcgdGhlIGFycmF5IGFuZCBhZGQgbW9yZSBzZXJ2aWNlIG1ldGhvZHMgbGlrZSBjYWxjdWxhdGluZyBib3VuZGluZyBib3gsIHJhZGl1cyBldGMuXG4gICAgLy8gc2VlIGlmIGEgcHJveHkgb2YgdGhlIGFycmF5IGludGVyZmFjaW5nIFtdIHdvdWxkIGRvIGEgZ29vZCBqb2IgLT4gdGVzdGVkOiBwcm94eSBpcyBhYm91dCAyMCB0aW1lcyBzbG93ZXIhXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdWJzZXQgb2YgdmVydGljZXMgdGhhdCBkbyBub3QgcmVmZXIgdG8gb3RoZXIgdmVydGljZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG9yaWdpbmFscygpOiBBcnJheTxWZXJ0ZXg+IHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihfdmVydGV4ID0+IF92ZXJ0ZXgucmVmZXJUbyA9PSB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHBvc2l0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZCwgcmVzb2x2aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiB2ZXJ0aWNlcyBcbiAgICAgKi9cbiAgICBwdWJsaWMgcG9zaXRpb24oX2luZGV4OiBudW1iZXIpOiBWZWN0b3IzIHtcbiAgICAgIGxldCB2ZXJ0ZXg6IFZlcnRleCA9IHRoaXNbX2luZGV4XTtcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5wb3NpdGlvbiA6IHRoaXNbdmVydGV4LnJlZmVyVG9dLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIG5vcm1hbCBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWQsIHJlc29sdmluZyByZWZlcmVuY2VzIGJldHdlZW4gdmVydGljZXMgXG4gICAgICovXG4gICAgcHVibGljIG5vcm1hbChfaW5kZXg6IG51bWJlcik6IFZlY3RvcjMge1xuICAgICAgbGV0IHZlcnRleDogVmVydGV4ID0gdGhpc1tfaW5kZXhdO1xuICAgICAgcmV0dXJuICh2ZXJ0ZXgucmVmZXJUbyA9PSB1bmRlZmluZWQpID8gdmVydGV4Lm5vcm1hbCA6IHRoaXNbdmVydGV4LnJlZmVyVG9dLm5vcm1hbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSB1di1jb29yZGluYXRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgdXYoX2luZGV4OiBudW1iZXIpOiBWZWN0b3IyIHtcbiAgICAgIHJldHVybiB0aGlzW19pbmRleF0udXY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgY29sb3IgYXNzb2NpYXRlZCB3aXRoIHRoZSB2ZXJ0ZXggYWRkcmVzc2VkXG4gICAgICovXG4gICAgcHVibGljIGNvbG9yKF9pbmRleDogbnVtYmVyKTogQ29sb3Ige1xuICAgICAgcmV0dXJuIHRoaXNbX2luZGV4XS5jb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBib25lcyBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWQsIHJlc29sdmluZyByZWZlcmVuY2VzIGJldHdlZW4gdmVydGljZXMgXG4gICAgICovXG4gICAgcHVibGljIGJvbmVzKF9pbmRleDogbnVtYmVyKTogQm9uZVtdIHtcbiAgICAgIGxldCB2ZXJ0ZXg6IFZlcnRleCA9IHRoaXNbX2luZGV4XTtcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5ib25lcyA6IHRoaXNbdmVydGV4LnJlZmVyVG9dLmJvbmVzO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQmFzZSBjbGFzcyBmb3IgTWVzaEltcG9ydC1sb2FkZXJzXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcbiAgICovXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNZXNoTG9hZGVyIHtcblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBnaXZlbiBkYXRhIGludG8gdGhlIGdpdmVuIG1lc2hcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWQoX21lc2g6IE1lc2hJbXBvcnQgfCBNZXNoU2tpbiwgX2RhdGE/OiBPYmplY3QpOiBQcm9taXNlPE1lc2hJbXBvcnQ+IHtcbiAgICAgIHJldHVybiBfbWVzaDtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEZpbG1ib3ggbWVzaCBpbXBvcnRcbiAgICogQGF1dGhvcnMgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjMgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcbiAgICogQGlnbm9yZSBjdXJyZW50bHkgbm90IHdvcmtpbmdcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNZXNoTG9hZGVyRkJYIGV4dGVuZHMgTWVzaExvYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkKF9tZXNoOiBNZXNoSW1wb3J0IHwgTWVzaFNraW4sIF9kYXRhOiBGQlguR2VvbWV0cnkpOiBQcm9taXNlPE1lc2hJbXBvcnQ+IHtcbiAgICAgIGNvbnN0IGxvYWRlcjogRkJYTG9hZGVyID0gYXdhaXQgRkJYTG9hZGVyLkxPQUQoX21lc2gudXJsLnRvU3RyaW5nKCkpO1xuICAgICAgY29uc3QgZ2VvbWV0cnlGQlg6IEZCWC5HZW9tZXRyeSA9IChcbiAgICAgICAgX2RhdGEgfHxcbiAgICAgICAgbG9hZGVyLmZieC5vYmplY3RzLmdlb21ldHJpZXMuZmluZChvYmplY3QgPT4gb2JqZWN0Lm5hbWUgPT0gX21lc2gubmFtZSkgfHxcbiAgICAgICAgbG9hZGVyLmZieC5vYmplY3RzLm1vZGVscy5maW5kKG9iamVjdCA9PiBvYmplY3QubmFtZSA9PSBfbWVzaC5uYW1lICYmIG9iamVjdC5zdWJ0eXBlID09IFwiTWVzaFwiKS5jaGlsZHJlblswXVxuICAgICAgKS5sb2FkKCk7XG4gICAgICBpZiAoX2RhdGEpXG4gICAgICAgIF9tZXNoLm5hbWUgPSBfZGF0YS5uYW1lLmxlbmd0aCA+IDAgPyBfZGF0YS5uYW1lIDogX2RhdGEucGFyZW50c1swXS5uYW1lO1xuXG4gICAgICBsZXQgcG9zaXRpb25zOiBWZWN0b3IzW10gPSBbXTtcbiAgICAgIGxldCB2ZXJ0ZXhCdWZmZXI6IEZsb2F0MzJBcnJheSA9IGdlb21ldHJ5RkJYLlZlcnRpY2VzO1xuICAgICAgZm9yIChsZXQgaVZlcnRleDogbnVtYmVyID0gMDsgaVZlcnRleCA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGlWZXJ0ZXggKz0gMykge1xuICAgICAgICBwb3NpdGlvbnMucHVzaChuZXcgVmVjdG9yMyh2ZXJ0ZXhCdWZmZXJbaVZlcnRleCArIDBdLCB2ZXJ0ZXhCdWZmZXJbaVZlcnRleCArIDFdLCB2ZXJ0ZXhCdWZmZXJbaVZlcnRleCArIDJdKSk7XG4gICAgICB9XG5cbiAgICAgIGxldCB1dnM6IFZlY3RvcjJbXSA9IFtdO1xuICAgICAgaWYgKGdlb21ldHJ5RkJYLkxheWVyRWxlbWVudFVWKSB7XG4gICAgICAgIGxldCB1dkJ1ZmZlcjogRmxvYXQzMkFycmF5ID0gZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50VVYuVVY7XG4gICAgICAgIGZvciAobGV0IGl1djogbnVtYmVyID0gMDsgaXV2IDwgdXZCdWZmZXIubGVuZ3RoOyBpdXYgKz0gMikge1xuICAgICAgICAgIHV2cy5wdXNoKG5ldyBWZWN0b3IyKHV2QnVmZmVyW2l1dl0sIDEgLSB1dkJ1ZmZlcltpdXYgKyAxXSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBub3JtYWxzOiBWZWN0b3IzW10gPSBbXTtcbiAgICAgIGlmIChnZW9tZXRyeUZCWC5MYXllckVsZW1lbnROb3JtYWwpIHtcbiAgICAgICAgbGV0IG5vcm1hbEJ1ZmZlcjogRmxvYXQzMkFycmF5ID0gZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50Tm9ybWFsLk5vcm1hbHM7XG4gICAgICAgIGZvciAobGV0IGlOb3JtYWw6IG51bWJlciA9IDA7IGlOb3JtYWwgPCBub3JtYWxCdWZmZXIubGVuZ3RoOyBpTm9ybWFsICs9IDMpIHtcbiAgICAgICAgICBub3JtYWxzLnB1c2gobmV3IFZlY3RvcjMobm9ybWFsQnVmZmVyW2lOb3JtYWxdLCBub3JtYWxCdWZmZXJbaU5vcm1hbCArIDFdLCBub3JtYWxCdWZmZXJbaU5vcm1hbCArIDJdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IG1hcFZlcnRleFRvSW5kZXg6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gICAgICBsZXQgbmV3VmVydGV4SW5kaWNlczogbnVtYmVyW11bXSA9IFtdO1xuICAgICAgbGV0IGlQb2x5Z29uID0gMDtcbiAgICAgIGxldCBpc0VuZE9mUG9seWdvbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgbGV0IHBvbHlnb246IG51bWJlcltdID0gW107XG5cbiAgICAgIGdlb21ldHJ5RkJYLlBvbHlnb25WZXJ0ZXhJbmRleC5mb3JFYWNoKChfaVZlcnRleCwgX2lQb2x5Z29uVmVydGV4KSA9PiB7XG4gICAgICAgIGlmIChfaVZlcnRleCA8IDApIHtcbiAgICAgICAgICBfaVZlcnRleCA9IF9pVmVydGV4IF4gLSAxO1xuICAgICAgICAgIGlzRW5kT2ZQb2x5Z29uID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IHBvc2l0aW9uc1tfaVZlcnRleF07XG4gICAgICAgIGxldCB1djogVmVjdG9yMiA9IHV2c1tnZXREYXRhSW5kZXgoZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50VVYsIF9pVmVydGV4LCBpUG9seWdvbiwgX2lQb2x5Z29uVmVydGV4KV07XG5cbiAgICAgICAgbGV0IHZlcnRleEtleSA9IHBvc2l0aW9uLnRvU3RyaW5nKCkgKyB1di50b1N0cmluZygpO1xuICAgICAgICBpZiAoIW1hcFZlcnRleFRvSW5kZXguaGFzKHZlcnRleEtleSkpIHtcbiAgICAgICAgICBsZXQgbm9ybWFsOiBWZWN0b3IzID0gbm9ybWFsc1tnZXREYXRhSW5kZXgoZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50Tm9ybWFsLCBfaVZlcnRleCwgaVBvbHlnb24sIF9pUG9seWdvblZlcnRleCldO1xuXG4gICAgICAgICAgX21lc2gudmVydGljZXMucHVzaChuZXcgVmVydGV4KHBvc2l0aW9uLCB1diwgbm9ybWFsKSk7XG4gICAgICAgICAgbWFwVmVydGV4VG9JbmRleC5zZXQodmVydGV4S2V5LCBfbWVzaC52ZXJ0aWNlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICBpZiAoIW5ld1ZlcnRleEluZGljZXNbX2lWZXJ0ZXhdKVxuICAgICAgICAgICAgbmV3VmVydGV4SW5kaWNlc1tfaVZlcnRleF0gPSBbXTtcbiAgICAgICAgICBuZXdWZXJ0ZXhJbmRpY2VzW19pVmVydGV4XS5wdXNoKF9tZXNoLnZlcnRpY2VzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb24ucHVzaChtYXBWZXJ0ZXhUb0luZGV4LmdldCh2ZXJ0ZXhLZXkpKTtcblxuICAgICAgICBpZiAoaXNFbmRPZlBvbHlnb24pIHtcbiAgICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgX21lc2guZmFjZXMucHVzaChuZXcgRmFjZShfbWVzaC52ZXJ0aWNlcywgcG9seWdvblswXSwgcG9seWdvblsxXSwgcG9seWdvblsyXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocG9seWdvbi5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICAgbGV0IHF1YWQ6IFF1YWQgPSBuZXcgUXVhZChfbWVzaC52ZXJ0aWNlcywgcG9seWdvblswXSwgcG9seWdvblsxXSwgcG9seWdvblsyXSwgcG9seWdvblszXSk7XG4gICAgICAgICAgICBfbWVzaC5mYWNlcy5wdXNoKC4uLnF1YWQuZmFjZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAyOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgX21lc2guZmFjZXMucHVzaChuZXcgRmFjZShfbWVzaC52ZXJ0aWNlcywgcG9seWdvblswXSwgcG9seWdvbltpIC0gMV0sIHBvbHlnb25baSAtIDBdKSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYCR7TWVzaExvYWRlckZCWC5uYW1lfTogUG9seWdvbnMgd2l0aCBtb3JlIHRoYW4gNCB2ZXJ0aWNlcyBhcmUgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICAgIGlzRW5kT2ZQb2x5Z29uID0gZmFsc2U7XG4gICAgICAgICAgaVBvbHlnb24rKztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChfbWVzaCBpbnN0YW5jZW9mIE1lc2hTa2luKSB7XG4gICAgICAgIGNvbnN0IGZieERlZm9ybWVyOiBGQlguRGVmb3JtZXIgPSBnZW9tZXRyeUZCWC5jaGlsZHJlblswXTtcbiAgICAgICAgY29uc3Qgc2tlbGV0b246IENvbXBvbmVudFNrZWxldG9uID0gYXdhaXQgbG9hZGVyLmdldFNrZWxldG9uKGZieERlZm9ybWVyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdKTsgLy8gRGVmb3JtZXIuU3ViRGVmb3JtZXIuTGltYk5vZGVcbiAgICAgICAgY3JlYXRlQm9uZXMoZmJ4RGVmb3JtZXIsIHNrZWxldG9uLCBfbWVzaC52ZXJ0aWNlcywgbmV3VmVydGV4SW5kaWNlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX21lc2g7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YUluZGV4KF9sYXllckVsZW1lbnQ6IEZCWC5MYXllckVsZW1lbnRVViB8IEZCWC5MYXllckVsZW1lbnROb3JtYWwsIF9pVmVydGV4OiBudW1iZXIsIF9pUG9seWdvbjogbnVtYmVyLCBfaVBvbHlnb25WZXJ0ZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IGluZGV4OiBudW1iZXIgPVxuICAgICAgX2xheWVyRWxlbWVudC5NYXBwaW5nSW5mb3JtYXRpb25UeXBlID09IFwiQnlWZXJ0ZXhcIiA/XG4gICAgICAgIF9pVmVydGV4IDpcbiAgICAgICAgX2xheWVyRWxlbWVudC5NYXBwaW5nSW5mb3JtYXRpb25UeXBlID09IFwiQnlQb2x5Z29uXCIgP1xuICAgICAgICAgIF9pUG9seWdvbiA6XG4gICAgICAgICAgX2lQb2x5Z29uVmVydGV4O1xuXG4gICAgaWYgKF9sYXllckVsZW1lbnQuUmVmZXJlbmNlSW5mb3JtYXRpb25UeXBlID09PSAnSW5kZXhUb0RpcmVjdCcpIHtcbiAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IChfbGF5ZXJFbGVtZW50IGFzIEZCWC5MYXllckVsZW1lbnRVVikuVVZJbmRleCB8fCAoX2xheWVyRWxlbWVudCBhcyBGQlguTGF5ZXJFbGVtZW50Tm9ybWFsKS5Ob3JtYWxzSW5kZXg7XG4gICAgICBpbmRleCA9IGluZGljZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvbmVzKF9kZWZvcm1lckZCWDogRkJYLkRlZm9ybWVyLCBfc2tlbGV0b246IENvbXBvbmVudFNrZWxldG9uLCBfdmVydGljZXM6IFZlcnRpY2VzLCBfbmV3VmVydGV4SW5kaWNlcz86IG51bWJlcltdW10pOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGZieFN1YkRlZm9ybWVyIG9mIF9kZWZvcm1lckZCWC5jaGlsZHJlbiBhcyBGQlguU3ViRGVmb3JtZXJbXSkge1xuICAgICAgZmJ4U3ViRGVmb3JtZXIubG9hZCgpO1xuICAgICAgaWYgKGZieFN1YkRlZm9ybWVyLkluZGV4ZXMpXG4gICAgICAgIGZvciAobGV0IGlCb25lSW5mbHVlbmNlOiBudW1iZXIgPSAwOyBpQm9uZUluZmx1ZW5jZSA8IGZieFN1YkRlZm9ybWVyLkluZGV4ZXMubGVuZ3RoOyBpQm9uZUluZmx1ZW5jZSsrKSB7XG4gICAgICAgICAgY29uc3QgaVZlcnRleDogbnVtYmVyID0gZmJ4U3ViRGVmb3JtZXIuSW5kZXhlc1tpQm9uZUluZmx1ZW5jZV07XG4gICAgICAgICAgZm9yIChjb25zdCBpVmVydGV4TmV3IG9mIF9uZXdWZXJ0ZXhJbmRpY2VzID8gX25ld1ZlcnRleEluZGljZXNbaVZlcnRleF0gOiBbaVZlcnRleF0pIHtcbiAgICAgICAgICAgIChfdmVydGljZXNbaVZlcnRleE5ld10uYm9uZXMgfHwgKF92ZXJ0aWNlc1tpVmVydGV4TmV3XS5ib25lcyA9IFtdKSkucHVzaCh7XG4gICAgICAgICAgICAgIGluZGV4OiBfc2tlbGV0b24uaW5kZXhPZihmYnhTdWJEZWZvcm1lci5jaGlsZHJlblswXS5uYW1lKSxcbiAgICAgICAgICAgICAgd2VpZ2h0OiBmYnhTdWJEZWZvcm1lci5XZWlnaHRzW2lCb25lSW5mbHVlbmNlXSB8fCAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogZ2wgVHJhbnNmZXIgRm9ybWF0IG1lc2ggaW1wb3J0XG4gICAqIEBhdXRob3JzIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIyLTIwMjMgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNZXNoTG9hZGVyR0xURiBleHRlbmRzIE1lc2hMb2FkZXIge1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfbWVzaDogTWVzaEltcG9ydCB8IE1lc2hTa2luLCBfZGF0YT86IHsgaU1lc2g6IG51bWJlcjsgaVByaW1pdGl2ZTogbnVtYmVyIH0pOiBQcm9taXNlPE1lc2hJbXBvcnQ+IHtcbiAgICAgIGNvbnN0IGxvYWRlcjogR0xURkxvYWRlciA9IGF3YWl0IEdMVEZMb2FkZXIuTE9BRChfbWVzaC51cmwudG9TdHJpbmcoKSk7XG4gICAgICBjb25zdCBnbHRmTWVzaDogR0xURi5NZXNoID0gbG9hZGVyLmdsdGYubWVzaGVzW19kYXRhLmlNZXNoXTtcbiAgICAgIGNvbnN0IGdsdGZQcmltaXRpdmU6IEdMVEYuTWVzaFByaW1pdGl2ZSA9IGdsdGZNZXNoLnByaW1pdGl2ZXNbX2RhdGEuaVByaW1pdGl2ZV07XG5cbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmluZGljZXMgPT0gdW5kZWZpbmVkKVxuICAgICAgICBEZWJ1Zy53YXJuKGAke2xvYWRlcn06IE1lc2ggd2l0aCBpbmRleCAke19kYXRhLmlNZXNofSBwcmltaXRpdmUgJHtfZGF0YS5pUHJpbWl0aXZlfSBoYXMgbm8gaW5kaWNlcy4gRlVER0UgZG9lcyBub3Qgc3VwcG9ydCBub24taW5kZXhlZCBtZXNoZXMuYCk7XG5cbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuUE9TSVRJT04gPT0gdW5kZWZpbmVkKVxuICAgICAgICBEZWJ1Zy53YXJuKGAke2xvYWRlcn06IE1lc2ggd2l0aCBpbmRleCAke19kYXRhLmlNZXNofSBwcmltaXRpdmUgJHtfZGF0YS5pUHJpbWl0aXZlfSBoYXMgbm8gcG9zaXRpb24gYXR0cmlidXRlLiBQcmltaXRpdmUgd2lsbCBiZSBpZ25vcmVkLmApO1xuXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5tb2RlICE9IHVuZGVmaW5lZCAmJiBnbHRmUHJpbWl0aXZlLm1vZGUgIT0gR0xURi5NRVNIX1BSSU1JVElWRV9NT0RFLlRSSUFOR0xFUylcbiAgICAgICAgRGVidWcud2FybihgJHtsb2FkZXJ9OiBNZXNoIHdpdGggaW5kZXggJHtfZGF0YS5pTWVzaH0gcHJpbWl0aXZlICR7X2RhdGEuaVByaW1pdGl2ZX0gaGFzIHRvcG9sb2d5IHR5cGUgbW9kZSAke0dMVEYuTUVTSF9QUklNSVRJVkVfTU9ERVtnbHRmUHJpbWl0aXZlLm1vZGVdfS4gRlVER0Ugb25seSBzdXBwb3J0cyAke0dMVEYuTUVTSF9QUklNSVRJVkVfTU9ERVs0XX0uYCk7XG5cbiAgICAgIGNoZWNrTWF4U3VwcG9ydChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMsIFwiVEVYQ09PUkRcIiwgMik7XG4gICAgICBjaGVja01heFN1cHBvcnQoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLCBcIkNPTE9SXCIsIDEpO1xuICAgICAgY2hlY2tNYXhTdXBwb3J0KGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcywgXCJKT0lOVFNcIiwgMSk7XG4gICAgICBjaGVja01heFN1cHBvcnQoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLCBcIldFSUdIVFNcIiwgMSk7XG5cbiAgICAgIF9tZXNoLm5hbWUgPSBnbHRmTWVzaC5uYW1lO1xuXG4gICAgICBsZXQgaW5kaWNlczogVWludDE2QXJyYXk7XG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheTtcbiAgICAgIGxldCBub3JtYWxzOiBGbG9hdDMyQXJyYXk7XG4gICAgICAvLyBsZXQgdGFuZ2VudHM6IEZsb2F0MzJBcnJheTtcbiAgICAgIGxldCB0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXk7XG4gICAgICBsZXQgY29sb3JzOiBGbG9hdDMyQXJyYXk7XG4gICAgICBsZXQgYm9uZXM6IFVpbnQ4QXJyYXk7XG4gICAgICBsZXQgd2VpZ2h0czogRmxvYXQzMkFycmF5O1xuXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5pbmRpY2VzICE9IHVuZGVmaW5lZClcbiAgICAgICAgaW5kaWNlcyA9IGF3YWl0IGxvYWRlci5nZXRWZXJ0ZXhJbmRpY2VzKGdsdGZQcmltaXRpdmUuaW5kaWNlcyk7IC8vIG1heWJlIHRocm93IGVycm9yIGluc3RlYWRcblxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5QT1NJVElPTiAhPSB1bmRlZmluZWQpXG4gICAgICAgIHZlcnRpY2VzID0gYXdhaXQgbG9hZGVyLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuUE9TSVRJT04pOyAvLyBtYXliZSB0aHJvdyBlcnJvciBpbnN0ZWFkXG5cbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuTk9STUFMICE9IHVuZGVmaW5lZClcbiAgICAgICAgbm9ybWFscyA9IGF3YWl0IGxvYWRlci5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLk5PUk1BTCk7XG5cbiAgICAgIC8vIFRPRE86IGFkZCB0YW5nZW50cyB0byBSZW5kZXJNZXNoXG4gICAgICAvLyBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRBTkdFTlQpXG4gICAgICAvLyAgIHRhbmdlbnRzID0gYXdhaXQgbG9hZGVyLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEFOR0VOVCk7XG5cbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEVYQ09PUkRfMSAhPSB1bmRlZmluZWQpXG4gICAgICAgIHRleHR1cmVVVnMgPSBhd2FpdCBsb2FkZXIuZ2V0RmxvYXQzMkFycmF5KGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5URVhDT09SRF8xKTtcbiAgICAgIGVsc2UgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5URVhDT09SRF8wICE9IHVuZGVmaW5lZClcbiAgICAgICAgdGV4dHVyZVVWcyA9IGF3YWl0IGxvYWRlci5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRFWENPT1JEXzApO1xuXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLkNPTE9SXzAgIT0gdW5kZWZpbmVkKVxuICAgICAgICBjb2xvcnMgPSBhd2FpdCBsb2FkZXIuZ2V0VmVydGV4Q29sb3JzKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5DT0xPUl8wKTtcblxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5KT0lOVFNfMCAhPSB1bmRlZmluZWQgJiYgZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLldFSUdIVFNfMCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYm9uZXMgPSBhd2FpdCBsb2FkZXIuZ2V0Qm9uZUluZGljZXMoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLkpPSU5UU18wKTtcbiAgICAgICAgd2VpZ2h0cyA9IGF3YWl0IGxvYWRlci5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLldFSUdIVFNfMCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGlWZXJ0ZXg6IG51bWJlciA9IDAsIGlDb2xvcjogbnVtYmVyID0gMCwgaVRleHR1cmVVVjogbnVtYmVyID0gMCwgaUJvbmVFbnRyeTogbnVtYmVyID0gMDsgaVZlcnRleCA8IHZlcnRpY2VzPy5sZW5ndGg7IGlWZXJ0ZXggKz0gMywgaUNvbG9yICs9IDQsIGlUZXh0dXJlVVYgKz0gMiwgaUJvbmVFbnRyeSArPSA0KSB7XG4gICAgICAgIF9tZXNoLnZlcnRpY2VzLnB1c2goXG4gICAgICAgICAgbmV3IFZlcnRleChcbiAgICAgICAgICAgIG5ldyBWZWN0b3IzKHZlcnRpY2VzW2lWZXJ0ZXggKyAwXSwgdmVydGljZXNbaVZlcnRleCArIDFdLCB2ZXJ0aWNlc1tpVmVydGV4ICsgMl0pLFxuICAgICAgICAgICAgdGV4dHVyZVVWcyA/XG4gICAgICAgICAgICAgIG5ldyBWZWN0b3IyKHRleHR1cmVVVnNbaVRleHR1cmVVViArIDBdLCB0ZXh0dXJlVVZzW2lUZXh0dXJlVVYgKyAxXSkgOlxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBub3JtYWxzID9cbiAgICAgICAgICAgICAgbmV3IFZlY3RvcjMobm9ybWFsc1tpVmVydGV4ICsgMF0sIG5vcm1hbHNbaVZlcnRleCArIDFdLCBub3JtYWxzW2lWZXJ0ZXggKyAyXSkgOlxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2xvcnMgP1xuICAgICAgICAgICAgICBuZXcgQ29sb3IoY29sb3JzW2lDb2xvciArIDBdLCBjb2xvcnNbaUNvbG9yICsgMV0sIGNvbG9yc1tpQ29sb3IgKyAyXSwgY29sb3JzW2lDb2xvciArIDNdKSA6XG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJvbmVzICYmIHdlaWdodHMgP1xuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgeyBpbmRleDogYm9uZXNbaUJvbmVFbnRyeSArIDBdLCB3ZWlnaHQ6IHdlaWdodHNbaUJvbmVFbnRyeSArIDBdIH0sXG4gICAgICAgICAgICAgICAgeyBpbmRleDogYm9uZXNbaUJvbmVFbnRyeSArIDFdLCB3ZWlnaHQ6IHdlaWdodHNbaUJvbmVFbnRyeSArIDFdIH0sXG4gICAgICAgICAgICAgICAgeyBpbmRleDogYm9uZXNbaUJvbmVFbnRyeSArIDJdLCB3ZWlnaHQ6IHdlaWdodHNbaUJvbmVFbnRyeSArIDJdIH0sXG4gICAgICAgICAgICAgICAgeyBpbmRleDogYm9uZXNbaUJvbmVFbnRyeSArIDNdLCB3ZWlnaHQ6IHdlaWdodHNbaUJvbmVFbnRyeSArIDNdIH1cbiAgICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaUZhY2VWZXJ0ZXhJbmRleDogbnVtYmVyID0gMDsgaUZhY2VWZXJ0ZXhJbmRleCA8IGluZGljZXM/Lmxlbmd0aDsgaUZhY2VWZXJ0ZXhJbmRleCArPSAzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX21lc2guZmFjZXMucHVzaChuZXcgRmFjZShcbiAgICAgICAgICAgIF9tZXNoLnZlcnRpY2VzLFxuICAgICAgICAgICAgaW5kaWNlc1tpRmFjZVZlcnRleEluZGV4ICsgMF0sXG4gICAgICAgICAgICBpbmRpY2VzW2lGYWNlVmVydGV4SW5kZXggKyAxXSxcbiAgICAgICAgICAgIGluZGljZXNbaUZhY2VWZXJ0ZXhJbmRleCArIDJdXG4gICAgICAgICAgKSk7XG4gICAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7XG4gICAgICAgICAgRGVidWcuZnVkZ2UoXCJGYWNlIGV4Y2x1ZGVkXCIsICg8RXJyb3I+X2UpLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlck1lc2g6IFJlbmRlck1lc2ggPSBfbWVzaC5yZW5kZXJNZXNoO1xuICAgICAgcmVuZGVyTWVzaC5pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgIHJlbmRlck1lc2gudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgIHJlbmRlck1lc2gubm9ybWFscyA9IG5vcm1hbHM7XG4gICAgICAvLyByZW5kZXJNZXNoLnRhbmdlbnRzID0gdGFuZ2VudHM7XG4gICAgICByZW5kZXJNZXNoLnRleHR1cmVVVnMgPSB0ZXh0dXJlVVZzO1xuICAgICAgcmVuZGVyTWVzaC5jb2xvcnMgPSBjb2xvcnM7XG4gICAgICByZW5kZXJNZXNoLmJvbmVzID0gYm9uZXM7XG4gICAgICByZW5kZXJNZXNoLndlaWdodHMgPSB3ZWlnaHRzO1xuXG4gICAgICByZXR1cm4gX21lc2g7XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrTWF4U3VwcG9ydChfZ2x0ZkF0dHJpYnV0ZXM6IEdMVEYuTWVzaFByaW1pdGl2ZVtcImF0dHJpYnV0ZXNcIl0sIF9jaGVjazogc3RyaW5nLCBfbWF4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcykuZmlsdGVyKChfa2V5OiBzdHJpbmcpID0+IF9rZXkuc3RhcnRzV2l0aChfY2hlY2spKS5sZW5ndGggPiBfbWF4KVxuICAgICAgICAgIERlYnVnLndhcm4oYCR7bG9hZGVyfTogTWVzaCB3aXRoIGluZGV4ICR7X2RhdGEuaU1lc2h9IHByaW1pdGl2ZSAke19kYXRhLmlQcmltaXRpdmV9IGhhcyBtb3JlIHRoYW4gJHtfbWF4fSBzZXRzIG9mICcke19jaGVja30nIGFzc29jaWF0ZWQgd2l0aCBpdC4gRlVHREUgb25seSBzdXBwb3J0cyB1cCB0byAke19tYXh9ICR7X2NoZWNrfSBzZXRzIHBlciBwcmltaXR2ZS5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFNpbXBsZSBXYXZlZnJvbnQgT0JKIGltcG9ydC4gVGFrZXMgYSB3YXZlZnJvbnQgb2JqIHN0cmluZy4gVG8gTG9hZCBmcm9tIGEgZmlsZSB1cmwsIHVzZSB0aGVcbiAgICogc3RhdGljIExPQUQgTWV0aG9kLiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIHRyaWFuZ3VsYXRlZCBNZXNoZXNcbiAgICogKGFjdGl2YXRlICdHZW9tZW50cnkg4oaSIFRyaWFuZ3VsYXRlIEZhY2VzJyBpbiBCbGVuZGVycyBvYmogZXhwb3J0ZXIpXG4gICAqIEB0b2RvIExvYWQgTWF0ZXJpYWxzLCBTdXBwb3J0IFF1YWRzXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UgMjAyMSB8IEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMiB8IE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzXG4gICAqL1xuICBleHBvcnQgY2xhc3MgTWVzaExvYWRlck9CSiBleHRlbmRzIE1lc2hMb2FkZXIge1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfbWVzaDogTWVzaEltcG9ydCk6IFByb21pc2U8TWVzaEltcG9ydD4ge1xuICAgICAgbGV0IHVybDogc3RyaW5nID0gbmV3IFVSTChfbWVzaC51cmwudG9TdHJpbmcoKSwgUHJvamVjdC5iYXNlVVJMKS50b1N0cmluZygpO1xuICAgICAgbGV0IGRhdGE6IHN0cmluZyA9IGF3YWl0IChhd2FpdCBmZXRjaCh1cmwpKS50ZXh0KCk7XG4gICAgICBfbWVzaC5uYW1lID0gdXJsLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgIHBhcnNlT2JqKGRhdGEsIF9tZXNoKTtcbiAgICAgIHJldHVybiBfbWVzaDtcbiAgICB9XG4gIH1cblxuICAvKiogU3BsaXRzIHVwIHRoZSBvYmogc3RyaW5nIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYWNoIGRhdGF0eXBlICovXG4gIGZ1bmN0aW9uIHBhcnNlT2JqKF9kYXRhOiBzdHJpbmcsIF9tZXNoOiBNZXNoSW1wb3J0KTogdm9pZCB7XG4gICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gX2RhdGEuc3BsaXQoXCJcXG5cIik7XG5cbiAgICBsZXQgcG9zaXRpb25zOiBWZWN0b3IzW10gPSBbXTtcbiAgICBsZXQgdXZzOiBWZWN0b3IyW10gPSBbXTtcbiAgICBsZXQgbm9ybWFsczogVmVjdG9yM1tdID0gW107XG4gICAgbGV0IGZhY2VJbmZvOiBGYWNlSW5mb1tdID0gW107XG5cbiAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBsaW5lID0gbGluZS50cmltKCk7XG5cbiAgICAgIGlmICghbGluZSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCIjXCIpKVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gbGluZS5zcGxpdChcIiBcIik7XG4gICAgICBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAvL1ZlcnRleCAtIGV4YW1wbGU6IHYgMC43MCAtMC40NSAtMC41MlxuICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcInYgXCIpKVxuICAgICAgICBwb3NpdGlvbnMucHVzaChuZXcgVmVjdG9yMyguLi5wYXJ0cy5tYXAoX3ZhbHVlID0+ICtfdmFsdWUpKSk7XG5cbiAgICAgIC8vTm9ybWFsIC0gZXhhbXBsZTogdm4gMC4wMCAwLjAwIDEuMDBcbiAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ2biBcIikpXG4gICAgICAgIG5vcm1hbHMucHVzaChuZXcgVmVjdG9yMyguLi5wYXJ0cy5tYXAoX3ZhbHVlID0+ICtfdmFsdWUpKSk7XG5cbiAgICAgIC8vVGV4Y29vcmQgLSBleGFtcGxlOiB2dCAwLjU0NTQ1NCAwLjQ3MjM4MlxuICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwidnQgXCIpKVxuICAgICAgICB1dnMucHVzaChuZXcgVmVjdG9yMiguLi5wYXJ0cy5tYXAoKF92YWx1ZSwgX2luZGV4KSA9PiArX3ZhbHVlICogKF9pbmRleCA9PSAxID8gLTEgOiAxKSkpKTtcblxuICAgICAgLypGYWNlIEluZGljZXMgLSBleGFtcGxlOiBmIDEvMS8xIDIvMi8xIDMvMy8xIC0tPlxuICAgICAgdmVydGV4MS90ZXhjb29yZDEvbm9ybWFsMSB2ZXJ0ZXgyL3RleGNvb3JkMi9ub3JtYWwyIHZlcnRleDMvdGV4Y29vcmQzL25vcm1hbDMqL1xuICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwiZiBcIikpXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpbmRpY2VzOiBzdHJpbmdbXSA9IHBhcnRzW2ldLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICBmYWNlSW5mby5wdXNoKHtcbiAgICAgICAgICAgIGlQb3NpdGlvbjogK2luZGljZXNbMF0gLSAxLFxuICAgICAgICAgICAgaVVWOiAraW5kaWNlc1sxXSAtIDEsXG4gICAgICAgICAgICBpTm9ybWFsOiAraW5kaWNlc1syXSAtIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9tZXNoLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XG4gICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGZhY2VJbmZvLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBsZXQgaW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGZvciAobGV0IHY6IG51bWJlciA9IDA7IHYgPCAzOyB2KyspIHtcbiAgICAgICAgbGV0IGluZm86IEZhY2VJbmZvID0gZmFjZUluZm9baSArIHZdO1xuICAgICAgICAvLyBBIGxvdCBvZiB2ZXJ0aWNlcyB3aXRoIGR1cGxpY2F0ZSBwb3NpdGlvbnMgYXJlIChwcm9iYWJseSkgY3JlYXRlZCBoZXJlLFxuICAgICAgICAvLyBzaW5jZSBpbiBvYmogZmlsZXMgdGhlIGZhY2UgZGVmaW5lcyB0aGUgY29ubmVjdGl2aXR5IG9mIHRoZSB2ZXJ0aWNlcywgVVYgY29vcmRpbmF0ZXMsIGFuZCBub3JtYWxzIChzZWUgYWJvdmUpLlxuICAgICAgICAvLyBIb3dldmVyLCBpbiBGdWRnZSwgZWFjaCB2ZXJ0ZXggaGFzIGl0cyBvd24gVVYgY29vcmRpbmF0ZXMgYW5kIG5vcm1hbHMgZGlyZWN0bGV5IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgICAgX21lc2gudmVydGljZXMucHVzaChuZXcgVmVydGV4KHBvc2l0aW9uc1tpbmZvLmlQb3NpdGlvbl0sIHV2c1tpbmZvLmlVVl0sIG5vcm1hbHNbaW5mby5pTm9ybWFsXSkpO1xuICAgICAgICBpbmRpY2VzLnB1c2goX21lc2gudmVydGljZXMubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBfbWVzaC5mYWNlcy5wdXNoKG5ldyBGYWNlKF9tZXNoLnZlcnRpY2VzLCBpbmRpY2VzWzBdLCBpbmRpY2VzWzFdLCBpbmRpY2VzWzJdKSk7XG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikge1xuICAgICAgICBEZWJ1Zy5mdWRnZShcIkZhY2UgZXhjbHVkZWRcIiwgKDxFcnJvcj5fZSkubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW50ZXJmYWNlIEZhY2VJbmZvIHtcbiAgICBpUG9zaXRpb246IG51bWJlcjtcbiAgICBpVVY6IG51bWJlcjtcbiAgICBpTm9ybWFsOiBudW1iZXI7XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICAvKipcbiAgICogVGhlIG5hbWVzYXBjZSBmb3IgaGFuZGxpbmcgdGhlIHBhcnRpY2xlIGRhdGFcbiAgICovXG4gIGV4cG9ydCBuYW1lc3BhY2UgUGFydGljbGVEYXRhIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgYSBwYXJ0aWNsZSBzeXN0ZW0uIERlc2NyaWJlcyB0aGUgcGFydGljbGUgYmVoYXZpb3IgYW5kIGFwcGVhcmFuY2UuXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBTeXN0ZW0ge1xuICAgICAgdmFyaWFibGVOYW1lcz86IHN0cmluZ1tdO1xuICAgICAgdmFyaWFibGVzPzogRXhwcmVzc2lvbltdOyAvL3sgW25hbWU6IHN0cmluZ106IEV4cHJlc3Npb24gfTtcbiAgICAgIGNvbG9yPzogRXhwcmVzc2lvbltdO1xuICAgICAgbXR4TG9jYWw/OiBUcmFuc2Zvcm1hdGlvbltdO1xuICAgICAgbXR4V29ybGQ/OiBUcmFuc2Zvcm1hdGlvbltdO1xuICAgIH1cblxuICAgIGV4cG9ydCB0eXBlIFJlY3Vyc2l2ZSA9IFN5c3RlbSB8IEV4cHJlc3Npb25bXSB8IFRyYW5zZm9ybWF0aW9uW10gfCBUcmFuc2Zvcm1hdGlvbiB8IEV4cHJlc3Npb247XG5cbiAgICBleHBvcnQgdHlwZSBFeHByZXNzaW9uID0gRnVuY3Rpb24gfCBWYXJpYWJsZSB8IENvbnN0YW50IHwgQ29kZTtcblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgICAgZnVuY3Rpb246IEZVTkNUSU9OO1xuICAgICAgcGFyYW1ldGVyczogRXhwcmVzc2lvbltdO1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgVmFyaWFibGUge1xuICAgICAgdmFsdWU6IHN0cmluZztcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIENvbnN0YW50IHtcbiAgICAgIHZhbHVlOiBudW1iZXI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlIHtcbiAgICAgIGNvZGU6IHN0cmluZztcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybWF0aW9uIHtcbiAgICAgIHRyYW5zZm9ybWF0aW9uOiBcInRyYW5zbGF0ZVwiIHwgXCJyb3RhdGVcIiB8IFwic2NhbGVcIjtcbiAgICAgIHBhcmFtZXRlcnM6IEV4cHJlc3Npb25bXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGRhdGEgaXMgYSB7QGxpbmsgRXhwcmVzc2lvbn1cbiAgICAgKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNFeHByZXNzaW9uKF9kYXRhOiBSZWN1cnNpdmUpOiBfZGF0YSBpcyBFeHByZXNzaW9uIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKF9kYXRhKSB8fCBpc1ZhcmlhYmxlKF9kYXRhKSB8fCBpc0NvbnN0YW50KF9kYXRhKSB8fCBpc0NvZGUoX2RhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihfZGF0YTogUmVjdXJzaXZlKTogX2RhdGEgaXMgRnVuY3Rpb24ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwiZnVuY3Rpb25cIiBpbiBfZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGRhdGEgaXMgYSB7QGxpbmsgVmFyaWFibGV9XG4gICAgICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzVmFyaWFibGUoX2RhdGE6IFJlY3Vyc2l2ZSk6IF9kYXRhIGlzIFZhcmlhYmxlIHtcbiAgICAgIHJldHVybiB0eXBlb2YgX2RhdGEgPT0gXCJvYmplY3RcIiAmJiBcInZhbHVlXCIgaW4gX2RhdGEgJiYgdHlwZW9mIF9kYXRhLnZhbHVlID09IFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBkYXRhIGlzIGEge0BsaW5rIENvbnN0YW50fVxuICAgICAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0NvbnN0YW50KF9kYXRhOiBSZWN1cnNpdmUpOiBfZGF0YSBpcyBDb25zdGFudCB7XG4gICAgICByZXR1cm4gdHlwZW9mIF9kYXRhID09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIF9kYXRhICYmIHR5cGVvZiBfZGF0YS52YWx1ZSA9PSBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBDb2RlfVxuICAgICAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0NvZGUoX2RhdGE6IFJlY3Vyc2l2ZSk6IF9kYXRhIGlzIENvZGUge1xuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwiY29kZVwiIGluIF9kYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBUcmFuc2Zvcm1hdGlvbn1cbiAgICAgKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNUcmFuc2Zvcm1hdGlvbihfZGF0YTogUmVjdXJzaXZlKTogX2RhdGEgaXMgVHJhbnNmb3JtYXRpb24ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwidHJhbnNmb3JtYXRpb25cIiBpbiBfZGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gb24gaG93IHRvIG11dGF0ZSB0aGUgcGFydGljbGVzIG9mIGEgcGFydGljbGUgc3lzdGVtLlxuICAgKiBBIGZ1bGwgcGFydGljbGUgc3lzdGVtIGlzIGNvbXBvc2VkIGJ5IGF0dGFjaGluZyBhIHtAbGluayBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbX0sIHtAbGluayBDb21wb25lbnRNZXNofSBhbmQge0BsaW5rIENvbXBvbmVudE1hdGVyaWFsfSB0byB0aGUgc2FtZSB7QGxpbmsgTm9kZX0uIFxuICAgKiBBZGRpdGlvbmFsbHkgYSB7QGxpbmsgQ29tcG9uZW50RmFjZUNhbWVyYX0gY2FuIGJlIGF0dGFjaGVkIHRvIG1ha2UgdGhlIHBhcnRpY2xlcyBmYWNlIHRoZSBjYW1lcmEuXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFBhcnRpY2xlU3lzdGVtIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAjZGF0YTogUGFydGljbGVEYXRhLlN5c3RlbTtcbiAgICAvKiogTWFwIG9mIHNoYWRlciB1bml2ZXJzYWwgZGVyaXZhdGVzIHRvIGNvcnJlc3BvbmRpbmcgY29tcHV0ZWQge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfS4gXG4gICAgICogVGhpcyB3YXkgZWFjaCBwYXJ0aWNsZSBzeXN0ZW0gcmVzb3VyY2UgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBtdWx0aXBsZSBzaGFkZXIgdW5pdmVyc2FsIGRlcml2YXRlcyAqL1xuICAgICNzaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtOiBNYXA8U2hhZGVySW50ZXJmYWNlLCBTaGFkZXJQYXJ0aWNsZVN5c3RlbT4gPSBuZXcgTWFwKCk7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFBhcnRpY2xlU3lzdGVtLm5hbWUsIF9kYXRhOiBQYXJ0aWNsZURhdGEuU3lzdGVtID0ge30pIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcbiAgICAgIHRoaXMuZGF0YSA9IF9kYXRhO1xuXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBQYXJ0aWNsZURhdGEuU3lzdGVtIHtcbiAgICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZGF0YShfZGF0YTogUGFydGljbGVEYXRhLlN5c3RlbSkge1xuICAgICAgdGhpcy4jZGF0YSA9IF9kYXRhO1xuICAgICAgdGhpcy4jc2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbS5mb3JFYWNoKF9zaGFkZXIgPT4gX3NoYWRlci5kZWxldGVQcm9ncmFtKCkpO1xuICAgICAgdGhpcy4jc2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbS5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3JyZXNwb25kaW5nIHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbX0gZm9yIHRoZSBnaXZlbiBzaGFkZXIgdW5pdmVyc2FsIGRlcml2YXRlLlxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0gdG8gcmVuZGVyIHRoZSBwYXJ0aWNsZSBzeXN0ZW0uXG4gICAgICogQHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTaGFkZXJGcm9tKF9zb3VyY2U6IFNoYWRlckludGVyZmFjZSk6IFNoYWRlclBhcnRpY2xlU3lzdGVtIHtcbiAgICAgIGlmICghdGhpcy4jc2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbS5oYXMoX3NvdXJjZSkpIHtcbiAgICAgICAgbGV0IHBhcnRpY2xlU2hhZGVyOiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSA9IG5ldyBTaGFkZXJQYXJ0aWNsZVN5c3RlbSgpO1xuICAgICAgICBwYXJ0aWNsZVNoYWRlci5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBwYXJ0aWNsZVNoYWRlci5kZWZpbmUgPSBbLi4ucGFydGljbGVTaGFkZXIuZGVmaW5lLCAuLi5fc291cmNlLmRlZmluZV07XG4gICAgICAgIHBhcnRpY2xlU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IF9zb3VyY2UuZ2V0VmVydGV4U2hhZGVyU291cmNlKCk7XG4gICAgICAgIHBhcnRpY2xlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gX3NvdXJjZS5nZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpO1xuICAgICAgICB0aGlzLiNzaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtLnNldChfc291cmNlLCBwYXJ0aWNsZVNoYWRlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiNzaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtLmdldChfc291cmNlKTtcbiAgICB9XG5cbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XG4gICAgICB0aGlzLmRhdGEgPSBfc2VyaWFsaXphdGlvbi5kYXRhO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlKCk6IE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIHtcbiAgICAgIHJldHVybiA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+c3VwZXIuZ2V0TXV0YXRvcigpOyAvLyByZW1vdmUgZGF0YSBmcm9tIG11dGF0b3JcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcbiAgICAgIG11dGF0b3IuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHJldHVybiBtdXRhdG9yO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XG4gICAgICBkZWxldGUgX211dGF0b3IuY2FjaGVkTXV0YXRvcnM7XG4gICAgICBkZWxldGUgX211dGF0b3Iuc2hhZGVyTWFwO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIC8qKlxuICAgKiBBIFdlYkdMIHNoYWRlcnByb2dyYW0gZm9yIGEgcGFydGljbGUgc3lzdGVtLiBNYW5hZ2VkIGJ5IGEge0BsaW5rIFBhcnRpY2xlU3lzdGVtfS4gSXQgdXNlcyB7QGxpbmsgUGFydGljbGVTeXN0ZW0uZGF0YX0gdG8gZ2VuZXJhdGUgYW5kIGluamVjdCBjb2RlIGludG8gYSBzaGFkZXIgdW5pdmVyc2FsIGRlcml2YXRlIChHTFNMKSB0aHVzIGNyZWF0aW5nIGEgc2hhZGVyIHBhcnRpY2xlIHN5c3RlbSBmcm9tIGEgc3VwcGxpZWQge0BsaW5rIFNoYWRlcn1zIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBjb2RlLlxuICAgKiBAYXV0aG9yIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIEBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmRlY29yYXRlXG4gIGV4cG9ydCBjbGFzcyBTaGFkZXJQYXJ0aWNsZVN5c3RlbSBpbXBsZW1lbnRzIFNoYWRlckludGVyZmFjZSB7XG4gICAgcHVibGljIGRhdGE6IFBhcnRpY2xlRGF0YS5TeXN0ZW07XG4gICAgcHVibGljIGRlZmluZTogc3RyaW5nW10gPSBbXCJQQVJUSUNMRVwiXTtcbiAgICBwdWJsaWMgdmVydGV4U2hhZGVyU291cmNlOiBzdHJpbmc7XG4gICAgcHVibGljIGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmc7XG5cbiAgICBwdWJsaWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICAgIHB1YmxpYyBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcbiAgICBwdWJsaWMgdW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH07XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbX0uIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyByZXR1cm4gXCJcIjsgLyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIFwiXCI7IC8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbX0uIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGRlbGV0ZVByb2dyYW0oKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgdXNlUHJvZ3JhbSgpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxuXG4gICAgLyoqXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW19LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBjcmVhdGVQcm9ncmFtKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIGF1dG9tYXRpYyBhZGp1c3RtZW50IG9mIHRoZSBjb2xsaWRlclxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIEJPRFlfSU5JVCB7XHJcbiAgICAvKiogQ29sbGlkZXIgdXNlcyB0aGUgcGl2b3Qgb2YgdGhlIG1lc2ggZm9yIGluaXRpbGlhbGl6YXRpb24gKi9cclxuICAgIFRPX01FU0gsXHJcbiAgICAvKiogQ29sbGlkZXIgdXNlcyB0aGUgdHJhbnNmb3JtIG9mIHRoZSBub2RlIGZvciBpbml0aWxpYWxpemF0aW9uICovXHJcbiAgICBUT19OT0RFLFxyXG4gICAgLyoqIENvbGxpZGVyIHVzZXMgaXRzIG93biBwaXZvdCBmb3IgaW5pdGlsaWFsaXphdGlvbiAqL1xyXG4gICAgVE9fUElWT1RcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjdHMgYXMgdGhlIHBoeXNpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgTm9kZX0gaXQncyBhdHRhY2hlZCB0by5cclxuICAgKiBJdCdzIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gdGhlIEZVREdFIHJlbmRlcmVkIHdvcmxkIGFuZCB0aGUgUGh5c2ljcyB3b3JsZC5cclxuICAgKiBGb3IgdGhlIHBoeXNpY3MgdG8gY29ycmVjdGx5IGdldCB0aGUgdHJhbnNmb3JtYXRpb25zIHJvdGF0aW9ucyBuZWVkIHRvIGJlIGFwcGxpZWQgd2l0aCBmcm9tIGxlZnQgPSB0cnVlLlxyXG4gICAqIE9yIHJvdGF0aW9ucyBuZWVkIHRvIGhhcHBlbiBiZWZvcmUgc2NhbGluZy5cclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFJpZ2lkYm9keSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50UmlnaWRib2R5KTtcclxuICAgIHByaXZhdGUgc3RhdGljIG1hcEJvZHlUeXBlOiB7IFt0eXBlOiBudW1iZXJdOiBudW1iZXIgfSA9ICh0eXBlb2YgT0lNTyA9PSBcInVuZGVmaW5lZFwiKSA/XHJcbiAgICAgIHtcclxuICAgICAgICBbQk9EWV9UWVBFLkRZTkFNSUNdOiBCT0RZX1RZUEUuRFlOQU1JQywgW0JPRFlfVFlQRS5TVEFUSUNdOiBCT0RZX1RZUEUuU1RBVElDLCBbQk9EWV9UWVBFLktJTkVNQVRJQ106IEJPRFlfVFlQRS5LSU5FTUFUSUNcclxuICAgICAgfSA6IHtcclxuICAgICAgICBbQk9EWV9UWVBFLkRZTkFNSUNdOiBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQywgW0JPRFlfVFlQRS5TVEFUSUNdOiBPSU1PLlJpZ2lkQm9keVR5cGUuU1RBVElDLCBbQk9EWV9UWVBFLktJTkVNQVRJQ106IE9JTU8uUmlnaWRCb2R5VHlwZS5LSU5FTUFUSUNcclxuICAgICAgfTtcclxuXHJcbiAgICAvKiogVHJhbnNmb3JtYXRpb24gb2YgdGhlIGNvbGxpZGVyIHJlbGF0aXZlIHRvIHRoZSBub2RlJ3MgdHJhbnNmb3JtLiBPbmNlIHNldCBtb3N0bHkgcmVtYWlucyBjb25zdGFudC4gXHJcbiAgICAgKiBJZiBhbHRlcmVkLCB7QGxpbmsgaXNJbml0aWFsaXplZH0gbXVzdCBiZSByZXNldCB0byBmYWxzZSB0byByZWNyZWF0ZSB0aGUgY29sbGlkZXIgaW4gdGhlIG5leHQge0BsaW5rIFJlbmRlci5wcmVwYXJlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFZlcnRpY2VzIHRoYXQgYnVpbGQgYSBjb252ZXggbWVzaCAoZm9ybSB0aGF0IGlzIGluIGl0c2VsZiBjbG9zZWQpLiBOZWVkcyB0byBzZXQgaW4gdGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgcmIgaWYgbm9uZSBvZiB0aGUgc3RhbmRhcmQgY29sbGlkZXJzIGlzIHVzZWQuIFxyXG4gICAgICogVW50ZXN0ZWQgYW5kIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkIGJ5IHNlcmlhbGl6YXRpb24gYW5kIG11dGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29udmV4TWVzaDogRmxvYXQzMkFycmF5ID0gbnVsbDtcclxuXHJcbiAgICAvKiogQ29sbGlzaW9ucyB3aXRoIHJpZ2lkYm9kaWVzIGhhcHBlbmluZyB0byB0aGlzIGJvZHksIGNhbiBiZSB1c2VkIHRvIGJ1aWxkIGEgY3VzdG9tIG9uQ29sbGlzaW9uU3RheSBmdW5jdGlvbmFsaXR5LiAqL1xyXG4gICAgcHVibGljIGNvbGxpc2lvbnM6IENvbXBvbmVudFJpZ2lkYm9keVtdID0gbmV3IEFycmF5KCk7XHJcbiAgICAvKiogVHJpZ2dlcnMgdGhhdCBhcmUgY3VycmVudGx5IHRyaWdnZXJpbmcgdGhpcyBib2R5ICovXHJcbiAgICBwdWJsaWMgdHJpZ2dlcmluZ3M6IENvbXBvbmVudFJpZ2lkYm9keVtdID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVGhlIGdyb3VwcyB0aGlzIG9iamVjdCBjb2xsaWRlcyB3aXRoLiBHcm91cHMgbXVzdCBiZSB3cml0ZW4gaW4gZm9ybSBvZlxyXG4gICAgICogIGUuZy4gY29sbGlzaW9uTWFzayA9IHtAbGluayBDT0xMSVNJT05fR1JPVVAuREVGQVVMVH0gfCB7QGxpbmsgQ09MTElTSU9OX0dST1VQfS4uLi4gYW5kIHNvIG9uIHRvIGNvbGxpZGUgd2l0aCBtdWx0aXBsZSBncm91cHMuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29sbGlzaW9uTWFzazogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEF1dG9tYXRpYyBhZGp1c3RtZW50IG9mIHRoZSBwaXZvdCB3aGVuIHtAbGluayBSZW5kZXIucHJlcGFyZX0gaXMgY2FsbGVkIGFjY29yZGluZyB0byB7QGxpbmsgQk9EWV9JTklUfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6YXRpb246IEJPRFlfSU5JVCA9IEJPRFlfSU5JVC5UT19QSVZPVDtcclxuICAgIC8qKiBNYXJrcyBpZiBjb2xsaWRlciB3YXMgaW5pdGlhbGl6ZWQuIFJlc2V0IHRvIGZhbHNlIHRvIGluaXRpYWxpemUgYWdhaW4gZS5nLiBhZnRlciBtYW5pcHVsYXRpb24gb2YgbXR4UGl2b3QgKi9cclxuICAgIHB1YmxpYyBpc0luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIElEIHRvIHJlZmVyZW5jZSB0aGlzIHNwZWNpZmljIENvbXBvbmVudFJpZ2lkYm9keSAqL1xyXG4gICAgI2lkOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vUHJpdmF0ZSBpbmZvcm1hdGlvbnMgLSBNb3N0bHkgT2ltb1BoeXNpY3MgdmFyaWFibGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIHRoZSBGVURHRSBVc2VyIGFuZCBtYW5pcHVsYXRlZCBieSB0aGVtXHJcbiAgICAjY29sbGlkZXI6IE9JTU8uU2hhcGU7XHJcbiAgICAjY29sbGlkZXJJbmZvOiBPSU1PLlNoYXBlQ29uZmlnO1xyXG4gICAgI2NvbGxpc2lvbkdyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVDtcclxuICAgICN0eXBlQ29sbGlkZXI6IENPTExJREVSX1RZUEUgPSBDT0xMSURFUl9UWVBFLkNVQkU7XHJcblxyXG4gICAgI3JpZ2lkYm9keTogT0lNTy5SaWdpZEJvZHk7XHJcbiAgICAjcmlnaWRib2R5SW5mbzogT0lNTy5SaWdpZEJvZHlDb25maWcgPSBuZXcgT0lNTy5SaWdpZEJvZHlDb25maWcoKTtcclxuICAgICN0eXBlQm9keTogQk9EWV9UWVBFID0gQk9EWV9UWVBFLkRZTkFNSUM7XHJcblxyXG4gICAgI21hc3NEYXRhOiBPSU1PLk1hc3NEYXRhID0gbmV3IE9JTU8uTWFzc0RhdGEoKTtcclxuICAgICNyZXN0aXR1dGlvbjogbnVtYmVyO1xyXG4gICAgI2ZyaWN0aW9uOiBudW1iZXI7XHJcbiAgICAjZGFtcGluZ0xpbmVhcjogbnVtYmVyID0gMC4xO1xyXG4gICAgI2RhbXBpbmdBbmd1bGFyOiBudW1iZXIgPSAwLjE7XHJcbiAgICAjZWZmZWN0Um90YXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLk9ORSgpO1xyXG4gICAgI2VmZmVjdEdyYXZpdHk6IG51bWJlciA9IDE7XHJcbiAgICAjaXNUcmlnZ2VyOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAjbXR4UGl2b3RVbnNjYWxlZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAjbXR4UGl2b3RJbnZlcnNlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICAjY2FsbGJhY2tzOiBPSU1PLkNvbnRhY3RDYWxsYmFjazsgLy9DYWxsYmFjayBNZXRob2RzIHdoZW4gd2l0aGluIHRoZSBvaW1vU3lzdGVtIGEgZXZlbnQgaXMgaGFwcGVuaW5nXHJcblxyXG4gICAgLy8gI3BoeXNpY3M6IFBoeXNpY3M7IC8vVE9ETzoga2VlcCBhIHBvaW50ZXIgdG8gdGhlIHBoeXNpY3MgaW5zdGFuY2UgdXNlZCBieSB0aGlzIGNvbXBvbmVudFxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIG5ldyByaWdpZGJvZHkgd2l0aCBhIHdlaWdodCBpbiBrZywgYSBwaHlzaWNzIHR5cGUgKGRlZmF1bHQgPSBkeW5hbWljKSwgYSBjb2xsaWRlciB0eXBlIHdoYXQgcGh5c2ljYWwgZm9ybSBoYXMgdGhlIGNvbGxpZGVyLCB0byB3aGF0IGdyb3VwIGRvZXMgaXQgYmVsb25nLCBpcyB0aGVyZSBhIHRyYW5zZm9ybSBNYXRyaXggdGhhdCBzaG91bGQgYmUgdXNlZCwgYW5kIGlzIHRoZSBjb2xsaWRlciBkZWZpbmVkIGFzIGEgZ3JvdXAgb2YgcG9pbnRzIHRoYXQgcmVwcmVzZW50IGEgY29udmV4IG1lc2guICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hc3M6IG51bWJlciA9IDEsIF90eXBlOiBCT0RZX1RZUEUgPSBCT0RZX1RZUEUuRFlOQU1JQywgX2NvbGxpZGVyVHlwZTogQ09MTElERVJfVFlQRSA9IENPTExJREVSX1RZUEUuQ1VCRSwgX2dyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRDb2xsaXNpb25Hcm91cCwgX210eFRyYW5zZm9ybTogTWF0cml4NHg0ID0gbnVsbCwgX2NvbnZleE1lc2g6IEZsb2F0MzJBcnJheSA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX21hc3MsIF90eXBlLCBfY29sbGlkZXJUeXBlLCBfZ3JvdXAsIF9tdHhUcmFuc2Zvcm0sIF9jb252ZXhNZXNoKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhuZEV2ZW50KTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIHRoaXMuaG5kRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIEFjY2Vzc29yc1xyXG4gICAgcHVibGljIGdldCBpZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFVzZWQgZm9yIGNhbGN1bGF0aW9uIG9mIHRoZSBnZW9tZXRyaWNhbCByZWxhdGlvbnNoaXAgb2Ygbm9kZSBhbmQgY29sbGlkZXIgYnkge0BsaW5rIFJlbmRlcn0qL1xyXG4gICAgcHVibGljIGdldCBtdHhQaXZvdEludmVyc2UoKTogTWF0cml4NHg0IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI210eFBpdm90SW52ZXJzZTtcclxuICAgIH1cclxuICAgIC8qKiBVc2VkIGZvciBjYWxjdWxhdGlvbiBvZiB0aGUgZ2VvbWV0cmljYWwgcmVsYXRpb25zaGlwIG9mIG5vZGUgYW5kIGNvbGxpZGVyIGJ5IHtAbGluayBSZW5kZXJ9Ki9cclxuICAgIHB1YmxpYyBnZXQgbXR4UGl2b3RVbnNjYWxlZCgpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4UGl2b3RVbnNjYWxlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmV0cmlldmUgdGhlIGJvZHkgdHlwZS4gU2VlIHtAbGluayBCT0RZX1RZUEV9ICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGVCb2R5KCk6IEJPRFlfVFlQRSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN0eXBlQm9keTtcclxuICAgIH1cclxuICAgIC8qKiBTZXQgdGhlIGJvZHkgdHlwZS4gU2VlIHtAbGluayBCT0RZX1RZUEV9ICovXHJcbiAgICBwdWJsaWMgc2V0IHR5cGVCb2R5KF92YWx1ZTogQk9EWV9UWVBFKSB7XHJcbiAgICAgIHRoaXMuI3R5cGVCb2R5ID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0VHlwZShDb21wb25lbnRSaWdpZGJvZHkubWFwQm9keVR5cGVbdGhpcy4jdHlwZUJvZHldKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE1hc3NEYXRhKHRoaXMuI21hc3NEYXRhKTsgLy9oYXZlIHRvIHJlc2V0IG1hc3MgYWZ0ZXIgY2hhbmdpbmcgdGhlIHR5cGUsIHNpbmNlIE9pbW8gaXMgaGFuZGxpbmcgbWFzcyBpbnRlcm5hbGx5IHdyb25nIHdoZW4gc3dpdGNoaW5nIHR5cGVzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBzaGFwZSB0aGF0IHJlcHJlc2VudHMgdGhlIHtAbGluayBOb2RlfSBpbiB0aGUgcGh5c2ljYWwgd29ybGQuIERlZmF1bHQgaXMgYSBDdWJlLiAqL1xyXG4gICAgcHVibGljIGdldCB0eXBlQ29sbGlkZXIoKTogQ09MTElERVJfVFlQRSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN0eXBlQ29sbGlkZXI7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHR5cGVDb2xsaWRlcihfdmFsdWU6IENPTExJREVSX1RZUEUpIHtcclxuICAgICAgaWYgKF92YWx1ZSAhPSB0aGlzLiN0eXBlQ29sbGlkZXIgJiYgdGhpcy4jcmlnaWRib2R5ICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLiN0eXBlQ29sbGlkZXIgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGNvbGxpc2lvbiBncm91cCB0aGlzIHtAbGluayBOb2RlfSBiZWxvbmdzIHRvIGl0J3MgdGhlIGRlZmF1bHQgZ3JvdXAgbm9ybWFsbHkgd2hpY2ggbWVhbnMgaXQgcGh5c2ljYWxseSBjb2xsaWRlcyB3aXRoIGV2ZXJ5IGdyb3VwIGJlc2lkZXMgdHJpZ2dlci4gKi9cclxuICAgIHB1YmxpYyBnZXQgY29sbGlzaW9uR3JvdXAoKTogQ09MTElTSU9OX0dST1VQIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2NvbGxpc2lvbkdyb3VwO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBjb2xsaXNpb25Hcm91cChfdmFsdWU6IENPTExJU0lPTl9HUk9VUCkge1xyXG4gICAgICB0aGlzLiNjb2xsaXNpb25Hcm91cCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keSAhPSBudWxsKVxyXG4gICAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRDb2xsaXNpb25Hcm91cCh0aGlzLiNjb2xsaXNpb25Hcm91cCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIE1hcmtpbmcgdGhlIEJvZHkgYXMgYSB0cmlnZ2VyIHRoZXJlZm9yZSBub3QgaW5mbHVlbmNpbmcgdGhlIGNvbGxpc2lvbiBzeXN0ZW0gYnV0IG9ubHkgc2VuZGluZyB0cmlnZ2VyRXZlbnRzICovXHJcbiAgICBwdWJsaWMgZ2V0IGlzVHJpZ2dlcigpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2lzVHJpZ2dlcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgaXNUcmlnZ2VyKF92YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICB0aGlzLiNpc1RyaWdnZXIgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmdldE9pbW9SaWdpZGJvZHkoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5nZXRPaW1vUmlnaWRib2R5KCkuX2lzVHJpZ2dlciA9IHRoaXMuI2lzVHJpZ2dlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcGh5c2ljYWwgd2VpZ2h0IG9mIHRoZSB7QGxpbmsgTm9kZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtYXNzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyaWdpZGJvZHkuZ2V0TWFzcygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXR0aW5nIHRoZSBwaHlzaWNhbCB3ZWlnaHQgb2YgdGhlIHtAbGluayBOb2RlfSBpbiBrZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG1hc3MoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWFzc0RhdGEubWFzcyA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMubm9kZSAhPSBudWxsKVxyXG4gICAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkgIT0gbnVsbClcclxuICAgICAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRNYXNzRGF0YSh0aGlzLiNtYXNzRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERyYWcgb2YgbGluZWFyIG1vdmVtZW50LiBBIEJvZHkgZG9lcyBzbG93IGRvd24gZXZlbiBvbiBhIHN1cmZhY2Ugd2l0aG91dCBmcmljdGlvbi4gKi9cclxuICAgIHB1YmxpYyBnZXQgZGFtcFRyYW5zbGF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyaWdpZGJvZHkuZ2V0TGluZWFyRGFtcGluZygpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkYW1wVHJhbnNsYXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jZGFtcGluZ0xpbmVhciA9IF92YWx1ZTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldExpbmVhckRhbXBpbmcoX3ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRHJhZyBvZiByb3RhdGlvbi4gKi9cclxuICAgIHB1YmxpYyBnZXQgZGFtcFJvdGF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyaWdpZGJvZHkuZ2V0QW5ndWxhckRhbXBpbmcoKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGFtcFJvdGF0aW9uKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2RhbXBpbmdBbmd1bGFyID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QW5ndWxhckRhbXBpbmcoX3ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGZhY3RvciB0aGlzIHJpZ2lkYm9keSByZWFjdHMgcm90YXRpb25zIHRoYXQgaGFwcGVuIGluIHRoZSBwaHlzaWNhbCB3b3JsZC4gMCB0byBsb2NrIHJvdGF0aW9uIHRoaXMgYXhpcy4gKi9cclxuICAgIHB1YmxpYyBnZXQgZWZmZWN0Um90YXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNlZmZlY3RSb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZWZmZWN0Um90YXRpb24oX2VmZmVjdDogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNlZmZlY3RSb3RhdGlvbiA9IF9lZmZlY3Q7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRSb3RhdGlvbkZhY3RvcihuZXcgT0lNTy5WZWMzKHRoaXMuI2VmZmVjdFJvdGF0aW9uLngsIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnksIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGZhY3RvciB0aGlzIHJpZ2lkYm9keSByZWFjdHMgdG8gd29ybGQgZ3Jhdml0eS4gRGVmYXVsdCA9IDEgZS5nLiAxKjkuODEgbS9zLiAqL1xyXG4gICAgcHVibGljIGdldCBlZmZlY3RHcmF2aXR5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNlZmZlY3RHcmF2aXR5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBlZmZlY3RHcmF2aXR5KF9lZmZlY3Q6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNlZmZlY3RHcmF2aXR5ID0gX2VmZmVjdDtcclxuICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keSAhPSBudWxsKSB0aGlzLiNyaWdpZGJvZHkuc2V0R3Jhdml0eVNjYWxlKHRoaXMuI2VmZmVjdEdyYXZpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBmcmljdGlvbiBvZiB0aGUgcmlnaWRib2R5LCB3aGljaCBpcyB0aGUgZmFjdG9yIG9mIHNsaWRpbmcgcmVzaXN0YW5jZSBvZiB0aGlzIHJpZ2lkYm9keSBvbiBzdXJmYWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGZyaWN0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNmcmljdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZnJpY3Rpb24gb2YgdGhlIHJpZ2lkYm9keSwgd2hpY2ggaXMgdGhlIGZhY3RvciBvZiAgc2xpZGluZyByZXNpc3RhbmNlIG9mIHRoaXMgcmlnaWRib2R5IG9uIHN1cmZhY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgZnJpY3Rpb24oX2ZyaWN0aW9uOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jZnJpY3Rpb24gPSBfZnJpY3Rpb247XHJcbiAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkgIT0gbnVsbClcclxuICAgICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0RnJpY3Rpb24odGhpcy4jZnJpY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSByZXN0aXR1dGlvbiBvZiB0aGUgcmlnaWRib2R5LCB3aGljaCBpcyB0aGUgZmFjdG9yIG9mIGJvdW5jaW5lc3Mgb2YgdGhpcyByaWdpZGJvZHkgb24gc3VyZmFjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByZXN0aXR1dGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmVzdGl0dXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHJlc3RpdHV0aW9uIG9mIHRoZSByaWdpZGJvZHksIHdoaWNoIGlzIHRoZSBmYWN0b3Igb2YgYm91bmNpbmVzcyBvZiB0aGlzIHJpZ2lkYm9keSBvbiBzdXJmYWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHJlc3RpdHV0aW9uKF9yZXN0aXR1dGlvbjogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3Jlc3RpdHV0aW9uID0gX3Jlc3RpdHV0aW9uO1xyXG4gICAgICBpZiAodGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldFJlc3RpdHV0aW9uKHRoaXMuI3Jlc3RpdHV0aW9uKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJpZ2lkYm9keSBpbiB0aGUgZm9ybSB0aGUgcGh5c2ljcyBlbmdpbmUgaXMgdXNpbmcgaXQsIHNob3VsZCBub3QgYmUgdXNlZCB1bmxlc3MgYSBmdW5jdGlvbmFsaXR5XHJcbiAgICAgKiBpcyBub3QgcHJvdmlkZWQgdGhyb3VnaCB0aGUgRlVER0UgSW50ZWdyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPaW1vUmlnaWRib2R5KCk6IE9JTU8uUmlnaWRCb2R5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JpZ2lkYm9keTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUm90YXRpbmcgdGhlIHJpZ2lkYm9keSB0aGVyZWZvcmUgY2hhbmdpbmcgaXQncyByb3RhdGlvbiBvdmVyIHRpbWUgZGlyZWN0bHkgaW4gcGh5c2ljcy4gVGhpcyB3YXkgcGh5c2ljcyBpcyBjaGFuZ2luZyBpbnN0ZWFkIG9mIHRyYW5zZm9ybS4gXHJcbiAgICAgKiAgQnV0IHlvdSBhcmUgYWJsZSB0byBpbmNyZW1lbnRhbCBjaGFuZ2luZyBpdCBpbnN0ZWFkIG9mIGEgZGlyZWN0IHJvdGF0aW9uLiAgQWx0aG91Z2ggaXQncyBhbHdheXMgcHJlZmVyZWQgdG8gdXNlIGZvcmNlcyBpbiBwaHlzaWNzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlQm9keShfcm90YXRpb25DaGFuZ2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnJvdGF0ZVh5eihuZXcgT0lNTy5WZWMzKF9yb3RhdGlvbkNoYW5nZS54ICogQ2FsYy5kZWcycmFkLCBfcm90YXRpb25DaGFuZ2UueSAqIENhbGMuZGVnMnJhZCwgX3JvdGF0aW9uQ2hhbmdlLnogKiBDYWxjLmRlZzJyYWQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVHJhbnNsYXRpbmcgdGhlIHJpZ2lkYm9keSB0aGVyZWZvcmUgY2hhbmdpbmcgaXQncyBwbGFjZSBvdmVyIHRpbWUgZGlyZWN0bHkgaW4gcGh5c2ljcy4gVGhpcyB3YXkgcGh5c2ljcyBpcyBjaGFuZ2luZyBpbnN0ZWFkIG9mIHRyYW5zZm9ybS4gXHJcbiAgICAgKiAgQnV0IHlvdSBhcmUgYWJsZSB0byBpbmNyZW1lbnRhbGx5IGNoYW5naW5nIGl0IGluc3RlYWQgb2YgYSBkaXJlY3QgcG9zaXRpb24uIEFsdGhvdWdoIGl0J3MgYWx3YXlzIHByZWZlcmVkIHRvIHVzZSBmb3JjZXMgaW4gcGh5c2ljcy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVCb2R5KF90cmFuc2xhdGlvbkNoYW5nZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkudHJhbnNsYXRlKG5ldyBPSU1PLlZlYzMoX3RyYW5zbGF0aW9uQ2hhbmdlLngsIF90cmFuc2xhdGlvbkNoYW5nZS55LCBfdHJhbnNsYXRpb25DaGFuZ2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IFBPU0lUSU9OIG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQb3NpdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHRtcFBvczogT0lNTy5WZWMzID0gdGhpcy4jcmlnaWRib2R5LmdldFBvc2l0aW9uKCk7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0bXBQb3MueCwgdG1wUG9zLnksIHRtcFBvcy56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgUE9TSVRJT04gb2YgdGhlIHtAbGluayBOb2RlfSBpbiB0aGUgcGh5c2ljYWwgc3BhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBvc2l0aW9uKF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0UG9zaXRpb24obmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgUk9UQVRJT04gb2YgdGhlIHtAbGluayBOb2RlfSBpbiB0aGUgcGh5c2ljYWwgc3BhY2UuIE5vdGUgdGhpcyByYW5nZSBmcm9tIC1waSB0byBwaSwgc28gLTkwIHRvIDkwLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Um90YXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBvcmllbnRhdGlvbjogT0lNTy5RdWF0ID0gdGhpcy4jcmlnaWRib2R5LmdldE9yaWVudGF0aW9uKCk7XHJcbiAgICAgIGxldCB0bXBRdWF0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIuZ2V0KFF1YXRlcm5pb24pO1xyXG4gICAgICB0bXBRdWF0LnNldChvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCBvcmllbnRhdGlvbi53KTtcclxuICAgICAgbGV0IGV1bGVyQW5nbGVzOiBWZWN0b3IzID0gdG1wUXVhdC5ldWxlckFuZ2xlcy5jbG9uZTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodG1wUXVhdCk7XHJcbiAgICAgIHJldHVybiBldWxlckFuZ2xlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgUk9UQVRJT04gb2YgdGhlIHtAbGluayBOb2RlfSBpbiB0aGUgcGh5c2ljYWwgc3BhY2UsIGluIGRlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFJvdGF0aW9uKF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgcXVhdDogT0lNTy5RdWF0ID0gbmV3IE9JTU8uUXVhdCgpO1xyXG4gICAgICBsZXQgbXR4Um90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgbXR4Um90LnJvdGF0ZShuZXcgVmVjdG9yMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KSk7XHJcbiAgICAgIGxldCBhcnJheTogRmxvYXQzMkFycmF5ID0gbXR4Um90LmdldCgpO1xyXG4gICAgICBsZXQgcm90OiBPSU1PLk1hdDMgPSBuZXcgT0lNTy5NYXQzKGFycmF5WzBdLCBhcnJheVs0XSwgYXJyYXlbOF0sIGFycmF5WzFdLCBhcnJheVs1XSwgYXJyYXlbOV0sIGFycmF5WzJdLCBhcnJheVs2XSwgYXJyYXlbMTBdKTtcclxuICAgICAgcXVhdC5mcm9tTWF0Myhyb3QpO1xyXG4gICAgICAvLyBxdWF0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0T3JpZW50YXRpb24ocXVhdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCB0aGUgY3VycmVudCBTQ0FMSU5HIGluIHRoZSBwaHlzaWNhbCBzcGFjZS4gKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsaW5nKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMubm9kZS5tdHhXb3JsZC5zY2FsaW5nLmNsb25lO1xyXG4gICAgICBzY2FsaW5nLnggKj0gdGhpcy5tdHhQaXZvdC5zY2FsaW5nLng7XHJcbiAgICAgIHNjYWxpbmcueSAqPSB0aGlzLm10eFBpdm90LnNjYWxpbmcueTtcclxuICAgICAgc2NhbGluZy56ICo9IHRoaXMubXR4UGl2b3Quc2NhbGluZy56O1xyXG4gICAgICByZXR1cm4gc2NhbGluZztcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2NhbGluZyByZXF1aXJlcyB0aGUgY29sbGlkZXIgdG8gYmUgY29tcGxldGVseSByZWNyZWF0ZWQgYW5ldyAqL1xyXG4gICAgcHVibGljIHNldFNjYWxpbmcoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIC8vIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gX3ZhbHVlLmNsb25lOyAgIFxyXG4gICAgICB0aGlzLmNyZWF0ZUNvbGxpZGVyKG5ldyBPSU1PLlZlYzMoX3ZhbHVlLnggLyAyLCBfdmFsdWUueSAvIDIsIF92YWx1ZS56IC8gMiksIHRoaXMuI3R5cGVDb2xsaWRlcik7IC8vcmVjcmVhdGUgdGhlIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyID0gbmV3IE9JTU8uU2hhcGUodGhpcy4jY29sbGlkZXJJbmZvKTtcclxuICAgICAgbGV0IG9sZENvbGxpZGVyOiBPSU1PLlNoYXBlID0gdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkU2hhcGUodGhpcy4jY29sbGlkZXIpOyAvL2FkZCBuZXcgY29sbGlkZXIsIGJlZm9yZSByZW1vdmluZyB0aGUgb2xkLCBzbyB0aGUgcmIgaXMgbmV2ZXIgYWN0aXZlIHdpdGggMCBjb2xsaWRlcnNcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnJlbW92ZVNoYXBlKG9sZENvbGxpZGVyKTsgLy9yZW1vdmUgdGhlIG9sZCBjb2xsaWRlclxyXG4gICAgICB0aGlzLiNjb2xsaWRlci51c2VyRGF0YSA9IHRoaXM7IC8vcmVzZXQgdGhlIGV4dHJhIGluZm9ybWF0aW9uIHNvIHRoYXQgdGhpcyBjb2xsaWRlciBrbm93cyB0byB3aGljaCBGVURHRSBDb21wb25lbnQgaXQncyBjb25uZWN0ZWRcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0Q29sbGlzaW9uR3JvdXAodGhpcy5jb2xsaXNpb25Hcm91cCk7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldENvbGxpc2lvbk1hc2sodGhpcy5jb2xsaXNpb25NYXNrKTtcclxuXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldFJlc3RpdHV0aW9uKHRoaXMuI3Jlc3RpdHV0aW9uKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0RnJpY3Rpb24odGhpcy4jZnJpY3Rpb24pO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb250YWN0Q2FsbGJhY2sodGhpcy4jY2FsbGJhY2tzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSByaWdpZGJvZHkgYWNjb3JkaW5nIHRvIGl0cyBpbml0aWFsaXphdGlvbiBzZXR0aW5nIHRvIG1hdGNoIHRoZSBtZXNoLCB0aGUgbm9kZSBvciBpdHMgb3duIHBpdm90IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLm5vZGUpIC8vIGRlbGF5IGluaXRpYWxpemF0aW9uIHVudGlsIHRoaXMgcmlnaWRib2R5IGlzIGF0dGFjaGVkIHRvIGEgbm9kZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgc3dpdGNoIChOdW1iZXIodGhpcy5pbml0aWFsaXphdGlvbikpIHtcclxuICAgICAgICBjYXNlIEJPRFlfSU5JVC5UT19OT0RFOlxyXG4gICAgICAgICAgdGhpcy5tdHhQaXZvdCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCT0RZX0lOSVQuVE9fTUVTSDpcclxuICAgICAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgICAgIGlmIChjbXBNZXNoKVxyXG4gICAgICAgICAgICB0aGlzLm10eFBpdm90ID0gY21wTWVzaC5tdHhQaXZvdC5jbG9uZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9JTklULlRPX1BJVk9UOlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuXHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IG10eFdvcmxkLnRyYW5zbGF0aW9uOyAvL0FkZGluZyB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBwaXZvdFxyXG4gICAgICBsZXQgcm90YXRpb246IFZlY3RvcjMgPSBtdHhXb3JsZC5yb3RhdGlvbjtcclxuICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSBtdHhXb3JsZC5zY2FsaW5nO1xyXG4gICAgICAvL3NjYWxpbmcgcmVxdWlyZXMgY29sbGlkZXIgdG8gYmUgcmVjcmVhdGVkXHJcbiAgICAgIHRoaXMuc2V0U2NhbGluZyhzY2FsaW5nKTtcclxuXHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRNYXNzRGF0YSh0aGlzLiNtYXNzRGF0YSk7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pOyAvL3NldCB0aGUgYWN0dWFsIG5ldyByb3RhdGlvbi9wb3NpdGlvbiBmb3IgdGhpcyBSYiBhZ2FpbiBzaW5jZSBpdCdzIG5vdyB1cGRhdGVkXHJcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xyXG5cclxuICAgICAgbGV0IHNjYWxpbmdJbnZlcnNlOiBWZWN0b3IzID0gdGhpcy5ub2RlLm10eFdvcmxkLnNjYWxpbmcubWFwKF9pID0+IDEgLyBfaSk7XHJcbiAgICAgIHRoaXMuI210eFBpdm90VW5zY2FsZWQgPSBNYXRyaXg0eDQuQ09OU1RSVUNUSU9OKHRoaXMubXR4UGl2b3QudHJhbnNsYXRpb24sIHRoaXMubXR4UGl2b3Qucm90YXRpb24sIHNjYWxpbmdJbnZlcnNlKTtcclxuICAgICAgdGhpcy4jbXR4UGl2b3RJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLiNtdHhQaXZvdFVuc2NhbGVkKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCgpO1xyXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFZlbG9jaXR5IGFuZCBGb3JjZXNcclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGN1cnJlbnQgVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXRWZWxvY2l0eSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0TGluZWFyVmVsb2NpdHkoKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnopO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VmVsb2NpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWxvY2l0eTogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBBTkdVTEFSIC0gVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QW5ndWxhclZlbG9jaXR5KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVsb2NpdHk6IE9JTU8uVmVjMyA9IHRoaXMuI3JpZ2lkYm9keS5nZXRBbmd1bGFyVmVsb2NpdHkoKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnopO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgQU5HVUxBUiAtIFZFTE9DSVRZIG9mIHRoZSB7QGxpbmsgTm9kZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEFuZ3VsYXJWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QW5ndWxhclZlbG9jaXR5KHZlbG9jaXR5KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBjb250aW5vdXMgRk9SQ0UgYXQgdGhlIGNlbnRlciBvZiB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTUy5cclxuICAgICogVGhlIGZvcmNlIGlzIG1lYXN1cmVkIGluIG5ld3RvbiwgMWtnIG5lZWRzIGFib3V0IDEwIE5ld3RvbiB0byBmaWdodCBhZ2FpbnN0IGdyYXZpdHkuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5Rm9yY2UoX2ZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUZvcmNlVG9DZW50ZXIobmV3IE9JTU8uVmVjMyhfZm9yY2UueCwgX2ZvcmNlLnksIF9mb3JjZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBjb250aW5vdXMgRk9SQ0UgYXQgYSBzcGVjaWZpYyBwb2ludCBpbiB0aGUgd29ybGQgdG8gdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9keSdzIE1BU1NcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlGb3JjZUF0UG9pbnQoX2ZvcmNlOiBWZWN0b3IzLCBfd29ybGRQb2ludDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlGb3JjZShuZXcgT0lNTy5WZWMzKF9mb3JjZS54LCBfZm9yY2UueSwgX2ZvcmNlLnopLCBuZXcgT0lNTy5WZWMzKF93b3JsZFBvaW50LngsIF93b3JsZFBvaW50LnksIF93b3JsZFBvaW50LnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQXBwbGllcyBhIGNvbnRpbm91cyBST1RBVElPTkFMIEZPUkNFIChUb3JxdWUpIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5VG9ycXVlKF9yb3RhdGlvbmFsRm9yY2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5VG9ycXVlKG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uYWxGb3JjZS54LCBfcm90YXRpb25hbEZvcmNlLnksIF9yb3RhdGlvbmFsRm9yY2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgaW5zdGFudCBGT1JDRSBhdCBhIHBvaW50L3JpZ2lkYm9keWNlbnRlciB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2QncyBNQVNTXHJcbiAgICAqIEluZmx1ZW5jaW5nIHRoZSBhbmd1bGFyIHNwZWVkIGFuZCB0aGUgbGluZWFyIHNwZWVkLiBcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlJbXB1bHNlQXRQb2ludChfaW1wdWxzZTogVmVjdG9yMywgX3dvcmxkUG9pbnQ6IFZlY3RvcjMgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIF93b3JsZFBvaW50ID0gX3dvcmxkUG9pbnQgIT0gbnVsbCA/IF93b3JsZFBvaW50IDogdGhpcy5nZXRQb3NpdGlvbigpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlJbXB1bHNlKG5ldyBPSU1PLlZlYzMoX2ltcHVsc2UueCwgX2ltcHVsc2UueSwgX2ltcHVsc2UueiksIG5ldyBPSU1PLlZlYzMoX3dvcmxkUG9pbnQueCwgX3dvcmxkUG9pbnQueSwgX3dvcmxkUG9pbnQueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgaW5zdGFudCBGT1JDRSB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTU1xyXG4gICAgKiBPbmx5IGluZmx1ZW5jaW5nIGl0J3Mgc3BlZWQgbm90IHJvdGF0aW9uLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUxpbmVhckltcHVsc2UoX2ltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5TGluZWFySW1wdWxzZShuZXcgT0lNTy5WZWMzKF9pbXB1bHNlLngsIF9pbXB1bHNlLnksIF9pbXB1bHNlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBpbnN0YW50IFJPVEFUSU9OQUwtRk9SQ0UgdG8gdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9keSdzIE1BU1NcclxuICAgICAqIE9ubHkgaW5mbHVlbmNpbmcgaXQncyByb3RhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5QW5ndWxhckltcHVsc2UoX3JvdGF0aW9uYWxJbXB1bHNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUFuZ3VsYXJJbXB1bHNlKG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uYWxJbXB1bHNlLngsIF9yb3RhdGlvbmFsSW1wdWxzZS55LCBfcm90YXRpb25hbEltcHVsc2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdpbmcgdGhlIFZFTE9DSVRZIG9mIHRoZSBSSUdJREJPRFkuIE9ubHkgaW5mbHVlbmNpbmcgdGhlIGxpbmVhciBzcGVlZCBub3QgYW5ndWxhclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkVmVsb2NpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hZGRMaW5lYXJWZWxvY2l0eShuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5naW5nIHRoZSBWRUxPQ0lUWSBvZiB0aGUgUklHSURCT0RZLiBPbmx5IGluZmx1ZW5jaW5nIHRoZSBhbmd1bGFyIHNwZWVkIG5vdCB0aGUgbGluZWFyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRBbmd1bGFyVmVsb2NpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hZGRBbmd1bGFyVmVsb2NpdHkobmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZSB0aGUgcmlnaWRib2RpZXMgYXV0by1zbGVlcGluZyBmdW5jdGlvbi5cclxuICAgICAqIElmIGFjdGl2YXRlZCB0aGUgcmlnaWRib2R5IHdpbGwgYXV0b21hdGljYWxseSBzbGVlcCB3aGVuIG5lZWRlZCwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuICAgICAqIElmIGRlYWN0aXZhdGVkIHRoZSByaWdpZGJvZHkgZ2V0cyBzdG9wcGVkIGZyb20gc2xlZXBpbmcgd2hlbiBtb3ZlbWVudCBpcyB0b28gbWluaW1hbC4gRGVjcmVhc2luZyBwZXJmb3JtYW5jZSwgZm9yIHJhcmVseSBtb3JlIHByZWNpc2UgcGh5c2ljcyByZXN1bHRzIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVBdXRvU2xlZXAoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRBdXRvU2xlZXAoX29uKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBDb2xsaXNpb25cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tpbmcgZm9yIENvbGxpc2lvbiB3aXRoIG90aGVyIENvbGxpZGVycyBhbmQgZGlzcGF0Y2hlcyBhIGN1c3RvbSBldmVudCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2xsaWRlci5cclxuICAgICAqIEF1dG9tYXRpY2FsbHkgY2FsbGVkIGluIHRoZSBSZW5kZXJNYW5hZ2VyLCBubyBpbnRlcmFjdGlvbiBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjaGVja0NvbGxpc2lvbkV2ZW50cygpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIC8vIGNoZWNrIGNvbGxpc2lvbnMgb25seSBpZiBpbnRpYWxpemF0aW9uIGNvbXBsZXRlZFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgbGV0IGxpc3Q6IE9JTU8uQ29udGFjdExpbmsgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0Q29udGFjdExpbmtMaXN0KCk7IC8vYWxsIHBoeXNpY2FsIGNvbnRhY3RzIGJldHdlZW4gY29sbGlkaW5nIGJvZGllcyBvbiB0aGlzIHJiXHJcbiAgICAgIGxldCBvYmpIaXQ6IENvbXBvbmVudFJpZ2lkYm9keTsgLy9jb2xsaXNpb24gY29uc2lzdGluZyBvZiAyIGJvZGllcywgc28gSGl0MS8yXHJcbiAgICAgIGxldCBvYmpIaXQyOiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAgIGxldCBldmVudDogRXZlbnRQaHlzaWNzOyAgLy9UaGUgZXZlbnQgdGhhdCB3aWxsIGJlIHNlbmQgYW5kIHRoZSBpbmZvcm1hdGlvbnMgYWRkZWQgdG8gaXRcclxuICAgICAgbGV0IG5vcm1hbEltcHVsc2U6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCBiaW5vcm1hbEltcHVsc2U6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0YW5nZW50SW1wdWxzZTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGNvbFBvaW50OiBWZWN0b3IzO1xyXG4gICAgICAvL0FERCBORVcgQ29sbGlzaW9uIC0gVGhhdCBqdXN0IGhhcHBlbmVkXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLiNyaWdpZGJvZHkuZ2V0TnVtQ29udGFjdExpbmtzKCk7IGkrKykge1xyXG4gICAgICAgIGxldCBjb2xsaXNpb25NYW5pZm9sZDogT0lNTy5NYW5pZm9sZCA9IGxpc3QuZ2V0Q29udGFjdCgpLmdldE1hbmlmb2xkKCk7IC8vTWFuaWZvbGQgPSBBZGRpdGlvbmFsIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgY29udGFjdFxyXG4gICAgICAgIG9iakhpdCA9IGxpc3QuZ2V0Q29udGFjdCgpLmdldFNoYXBlMSgpLnVzZXJEYXRhOyAgLy9Vc2VyZGF0YSBpcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSDGki5Db21wb25lbnRSaWdpZGJvZHksIGl0J3MgYW4gZW1wdHkgT2ltb1BoeXNpY3MgVmFyaWFibGVcclxuICAgICAgICAvL09ubHkgcmVnaXN0ZXIgdGhlIGNvbGxpc2lvbiBvbiB0aGUgYWN0dWFsIHRvdWNoLCBub3Qgb24gXCJzaGFkb3dDb2xsaWRlXCIsIHRvIHJlZ2lzdGVyIGluIHRoZSBtb21lbnQgb2YgaW1wdWxzZSBjYWxjdWxhdGlvblxyXG4gICAgICAgIGlmICghb2JqSGl0LmlzSW5pdGlhbGl6ZWQpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAob2JqSGl0ID09IG51bGwgfHwgbGlzdC5nZXRDb250YWN0KCkuaXNUb3VjaGluZygpID09IGZhbHNlKSAvLyBvbmx5IGFjdCBpZiB0aGUgY29sbGlzaW9uIGlzIGFjdHVhbCB0b3VjaGluZywgc28gcmlnaHQgYXQgdGhlIG1vbWVudCB3aGVuIGEgaW1wdWxzZSBpcyBoYXBwZW5pbmcsIG5vdCB3aGVuIHNoYXBlcyBvdmVybGFwXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgb2JqSGl0MiA9IGxpc3QuZ2V0Q29udGFjdCgpLmdldFNoYXBlMigpLnVzZXJEYXRhO1xyXG4gICAgICAgIGlmICghb2JqSGl0Mi5pc0luaXRpYWxpemVkKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKG9iakhpdDIgPT0gbnVsbCB8fCBsaXN0LmdldENvbnRhY3QoKS5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IHBvaW50czogT0lNTy5NYW5pZm9sZFBvaW50W10gPSBjb2xsaXNpb25NYW5pZm9sZC5nZXRQb2ludHMoKTsgLy9BbGwgcG9pbnRzIGluIHRoZSBjb2xsaXNpb24gd2hlcmUgdGhlIHR3byBib2RpZXMgYXJlIHRvdWNoaW5nLCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgZnVsbCBpbXBhY3RcclxuICAgICAgICBsZXQgbm9ybWFsOiBPSU1PLlZlYzMgPSBjb2xsaXNpb25NYW5pZm9sZC5nZXROb3JtYWwoKTtcclxuICAgICAgICBpZiAob2JqSGl0LmdldE9pbW9SaWdpZGJvZHkoKSAhPSB0aGlzLmdldE9pbW9SaWdpZGJvZHkoKSAmJiB0aGlzLmNvbGxpc2lvbnMuaW5kZXhPZihvYmpIaXQpID09IC0xKSB7IC8vRmlyZSwgaWYgdGhlIGhpdCBvYmplY3QgaXMgbm90IHRoZSBCb2R5IGl0c2VsZiBidXQgYW5vdGhlciBhbmQgaXQncyBub3QgYWxyZWFkeSBmaXJlZC5cclxuICAgICAgICAgIGxldCBjb2xQb3M6IE9JTU8uVmVjMyA9IHRoaXMuY29sbGlzaW9uQ2VudGVyUG9pbnQocG9pbnRzLCBjb2xsaXNpb25NYW5pZm9sZC5nZXROdW1Qb2ludHMoKSk7IC8vVEhFIHBvaW50IG9mIGNvbGxpc2lvbiBpcyB0aGUgZmlyc3QgdG91Y2hpbmcgcG9pbnQgKEVYVEVOU0lPTjogY291bGQgYmUgdGhlIGNlbnRlciBvZiBhbGwgdG91Y2hpbmcgcG9pbnRzIGNvbWJpbmVkKVxyXG4gICAgICAgICAgY29sUG9pbnQgPSBuZXcgVmVjdG9yMyhjb2xQb3MueCwgY29sUG9zLnksIGNvbFBvcy56KTtcclxuICAgICAgICAgIHBvaW50cy5mb3JFYWNoKChfdmFsdWU6IE9JTU8uTWFuaWZvbGRQb2ludCk6IHZvaWQgPT4geyAvL1RoZSBpbXBhY3Qgb2YgdGhlIGNvbGxpc2lvbiBpbnZvbHZpbmcgYWxsIHRvdWNoaW5nIHBvaW50c1xyXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlICs9IF92YWx1ZS5nZXROb3JtYWxJbXB1bHNlKCk7XHJcbiAgICAgICAgICAgIGJpbm9ybWFsSW1wdWxzZSArPSBfdmFsdWUuZ2V0Qmlub3JtYWxJbXB1bHNlKCk7XHJcbiAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlICs9IF92YWx1ZS5nZXRUYW5nZW50SW1wdWxzZSgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aGlzLmNvbGxpc2lvbnMucHVzaChvYmpIaXQpOyAvL1RlbGwgdGhlIG9iamVjdCB0aGF0IHRoZSBldmVudCBmb3IgdGhpcyBvYmplY3QgZG9lcyBub3QgbmVlZCB0byBiZSBmaXJlZCBhZ2FpblxyXG4gICAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuQ09MTElTSU9OX0VOVEVSLCBvYmpIaXQsIG5vcm1hbEltcHVsc2UsIHRhbmdlbnRJbXB1bHNlLCBiaW5vcm1hbEltcHVsc2UsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7IC8vQnVpbGRpbmcgdGhlIGFjdHVhbCBldmVudCwgd2l0aCB3aGF0IG9iamVjdCBkaWQgY29sbGlkZSBhbmQgaW5mb3JtYXRpb25zIGFib3V0IGl0XHJcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpOyAvL1NlbmRpbmcgdGhlIGdpdmVuIGV2ZW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmpIaXQyICE9IHRoaXMgJiYgdGhpcy5jb2xsaXNpb25zLmluZGV4T2Yob2JqSGl0MikgPT0gLTEpIHsgLy9TYW1lIGFzIHRoZSBhYm92ZSBidXQgZm9yIHRoZSBjYXNlIHRoZSBTRUNPTkQgaGl0IG9iamVjdCBpcyBub3QgdGhlIGJvZHkgaXRzZWxmXHJcbiAgICAgICAgICBsZXQgY29sUG9zOiBPSU1PLlZlYzMgPSB0aGlzLmNvbGxpc2lvbkNlbnRlclBvaW50KHBvaW50cywgY29sbGlzaW9uTWFuaWZvbGQuZ2V0TnVtUG9pbnRzKCkpO1xyXG4gICAgICAgICAgY29sUG9pbnQgPSBuZXcgVmVjdG9yMyhjb2xQb3MueCwgY29sUG9zLnksIGNvbFBvcy56KTtcclxuICAgICAgICAgIHBvaW50cy5mb3JFYWNoKChfdmFsdWU6IE9JTU8uTWFuaWZvbGRQb2ludCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlICs9IF92YWx1ZS5nZXROb3JtYWxJbXB1bHNlKCk7XHJcbiAgICAgICAgICAgIGJpbm9ybWFsSW1wdWxzZSArPSBfdmFsdWUuZ2V0Qmlub3JtYWxJbXB1bHNlKCk7XHJcbiAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlICs9IF92YWx1ZS5nZXRUYW5nZW50SW1wdWxzZSgpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25zLnB1c2gob2JqSGl0Mik7XHJcbiAgICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRU5URVIsIG9iakhpdDIsIG5vcm1hbEltcHVsc2UsIHRhbmdlbnRJbXB1bHNlLCBiaW5vcm1hbEltcHVsc2UsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7XHJcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaXN0ID0gbGlzdC5nZXROZXh0KCk7IC8vU3RhcnQgdGhlIHNhbWUgcm91dGluZSB3aXRoIHRoZSBuZXh0IGNvbGxpc2lvbiBpbiB0aGUgbGlzdFxyXG4gICAgICB9XHJcbiAgICAgIC8vUkVNT1ZFIE9MRCBDb2xsaXNpb25zIC0gVGhhdCBkbyBub3QgaGFwcGVuIGFueW1vcmVcclxuICAgICAgdGhpcy5jb2xsaXNpb25zLmZvckVhY2goKF92YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KSA9PiB7IC8vRXZlcnkgQ29sbGlkZXIgaW4gdGhlIGxpc3QgaXMgY2hlY2tlZCBpZiB0aGUgY29sbGlzaW9uIGlzIHN0aWxsIGhhcHBlbmluZ1xyXG4gICAgICAgIGxldCBpc0NvbGxpZGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIGxpc3QgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0Q29udGFjdExpbmtMaXN0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuI3JpZ2lkYm9keS5nZXROdW1Db250YWN0TGlua3MoKTsgaSsrKSB7XHJcbiAgICAgICAgICBvYmpIaXQgPSBsaXN0LmdldENvbnRhY3QoKS5nZXRTaGFwZTEoKS51c2VyRGF0YTtcclxuICAgICAgICAgIG9iakhpdDIgPSBsaXN0LmdldENvbnRhY3QoKS5nZXRTaGFwZTIoKS51c2VyRGF0YTtcclxuICAgICAgICAgIGlmIChfdmFsdWUgPT0gb2JqSGl0IHx8IF92YWx1ZSA9PSBvYmpIaXQyKSB7IC8vSWYgdGhlIGdpdmVuIG9iamVjdCBpbiB0aGUgY29sbGlzaW9ucyBsaXN0IGlzIHN0aWxsIG9uZSBvZiB0aGUgb2JqSGl0IHRoZSBjb2xsaXNpb24gaXMgbm90IENvbGxpc2lvbkVYSVRcclxuICAgICAgICAgICAgaXNDb2xsaWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGlzdCA9IGxpc3QuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNDb2xsaWRpbmcgPT0gZmFsc2UpIHsgLy9UaGUgY29sbGlzaW9uIGlzIGV4aXRpbmcgYnV0IHdhcyBpbiB0aGUgY29sbGlzaW9uIGxpc3QsIHRoZW4gRVhJVCBFdmVudCBuZWVkcyB0byBiZSBmaXJlZFxyXG4gICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSB0aGlzLmNvbGxpc2lvbnMuaW5kZXhPZihfdmFsdWUpOyAvL0ZpbmQgb2JqZWN0IGluIHRoZSBhcnJheVxyXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25zLnNwbGljZShpbmRleCk7IC8vcmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5XHJcbiAgICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRVhJVCwgX3ZhbHVlLCAwLCAwLCAwKTtcclxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEgcmF5IHRocm91Z2ggdGhpcyBzcGVjaWZpYyBib2R5IGlnbm9yaW5nIHRoZSByZXN0IG9mIHRoZSB3b3JsZCBhbmQgY2hlY2tzIGlmIHRoaXMgYm9keSB3YXMgaGl0IGJ5IHRoZSByYXksXHJcbiAgICAgKiByZXR1cm5pbmcgaW5mbyBhYm91dCB0aGUgaGl0LiBQcm92aWRlcyB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5IGFuZCBpbmZvcm1hdGlvbiBhIHJlZ3VsYXIgcmF5Y2FzdCBkb2VzIGJ1dCB0aGUgcmF5IGlzIG9ubHkgdGVzdGluZyBhZ2FpbnN0IHRoaXMgc3BlY2lmaWMgYm9keS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJheWNhc3RUaGlzQm9keShfb3JpZ2luOiBWZWN0b3IzLCBfZGlyZWN0aW9uOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIsIF9kZWJ1Z0RyYXc6IGJvb2xlYW4gPSBmYWxzZSk6IFJheUhpdEluZm8ge1xyXG4gICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IG5ldyBSYXlIaXRJbmZvKCk7XHJcbiAgICAgIGxldCBnZW9tZXRyeTogT0lNTy5HZW9tZXRyeSA9IHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5nZXRHZW9tZXRyeSgpO1xyXG4gICAgICBsZXQgdHJhbnNmb3JtOiBPSU1PLlRyYW5zZm9ybSA9IHRoaXMuI3JpZ2lkYm9keS5nZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgbGV0IHNjYWxlZERpcmVjdGlvbjogVmVjdG9yMyA9IF9kaXJlY3Rpb24uY2xvbmU7XHJcbiAgICAgIHNjYWxlZERpcmVjdGlvbi5zY2FsZShfbGVuZ3RoKTtcclxuICAgICAgbGV0IGVuZHBvaW50OiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oc2NhbGVkRGlyZWN0aW9uLCBfb3JpZ2luLmNsb25lKTtcclxuICAgICAgbGV0IG9pbW9SYXk6IE9JTU8uUmF5Q2FzdEhpdCA9IG5ldyBPSU1PLlJheUNhc3RIaXQoKTtcclxuICAgICAgbGV0IGhpdDogYm9vbGVhbiA9IGdlb21ldHJ5LnJheUNhc3QobmV3IE9JTU8uVmVjMyhfb3JpZ2luLngsIF9vcmlnaW4ueSwgX29yaWdpbi56KSwgbmV3IE9JTU8uVmVjMyhlbmRwb2ludC54LCBlbmRwb2ludC55LCBlbmRwb2ludC56KSwgdHJhbnNmb3JtLCBvaW1vUmF5KTsgLy90aGUgYWN0dWFsIE9pbW9QaHlzaWNzIFJheWNhc3RcclxuICAgICAgaWYgKGhpdCkgeyAgLy9JZiBoaXQgcmV0dXJuIGEgYnVuY2ggb2YgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBoaXRcclxuICAgICAgICBoaXRJbmZvLmhpdCA9IHRydWU7XHJcbiAgICAgICAgaGl0SW5mby5oaXRQb2ludCA9IG5ldyBWZWN0b3IzKG9pbW9SYXkucG9zaXRpb24ueCwgb2ltb1JheS5wb3NpdGlvbi55LCBvaW1vUmF5LnBvc2l0aW9uLnopO1xyXG4gICAgICAgIGhpdEluZm8uaGl0Tm9ybWFsID0gbmV3IFZlY3RvcjMob2ltb1JheS5ub3JtYWwueCwgb2ltb1JheS5ub3JtYWwueSwgb2ltb1JheS5ub3JtYWwueik7XHJcbiAgICAgICAgbGV0IGR4OiBudW1iZXIgPSBfb3JpZ2luLnggLSBoaXRJbmZvLmhpdFBvaW50Lng7ICAvL2NhbGN1bGF0ZSBoaXQgZGlzdGFuY2VcclxuICAgICAgICBsZXQgZHk6IG51bWJlciA9IF9vcmlnaW4ueSAtIGhpdEluZm8uaGl0UG9pbnQueTtcclxuICAgICAgICBsZXQgZHo6IG51bWJlciA9IF9vcmlnaW4ueiAtIGhpdEluZm8uaGl0UG9pbnQuejtcclxuICAgICAgICBoaXRJbmZvLmhpdERpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XHJcbiAgICAgICAgaGl0SW5mby5yaWdpZGJvZHlDb21wb25lbnQgPSB0aGlzO1xyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgICBoaXRJbmZvLnJheUVuZCA9IGVuZHBvaW50O1xyXG4gICAgICB9IGVsc2UgeyAvL09ubHkgdGVsbCB0aGUgb3JpZ2luLCBhbmQgdGhlIGhpdCBwb2ludCBpcyB0aGUgZW5kIG9mIHRoZSByYXkuXHJcbiAgICAgICAgaGl0SW5mby5yYXlPcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICAgIGhpdEluZm8uaGl0UG9pbnQgPSBuZXcgVmVjdG9yMyhlbmRwb2ludC54LCBlbmRwb2ludC55LCBlbmRwb2ludC56KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoX2RlYnVnRHJhdykge1xyXG4gICAgICAgIFBoeXNpY3MuZGVidWdEcmF3LmRlYnVnUmF5KGhpdEluZm8ucmF5T3JpZ2luLCBoaXRJbmZvLmhpdFBvaW50LCBuZXcgQ29sb3IoMCwgMSwgMCwgMSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoaXRJbmZvO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZyAtIFNvbWUgcHJvcGVydGllcyBtaWdodCBiZSBtaXNzaW5nLCBlLmcuIGNvbnZleE1lc2ggKEZsb2F0MzJBcnJheSlcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcblxyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5tdHhQaXZvdDtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uYWN0aXZlO1xyXG5cclxuICAgICAgc2VyaWFsaXphdGlvbi50eXBlQm9keSA9IEJPRFlfVFlQRVt0aGlzLiN0eXBlQm9keV07XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZUNvbGxpZGVyID0gQ09MTElERVJfVFlQRVt0aGlzLiN0eXBlQ29sbGlkZXJdO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmluaXRpYWxpemF0aW9uID0gQk9EWV9JTklUW3RoaXMuaW5pdGlhbGl6YXRpb25dO1xyXG5cclxuICAgICAgc2VyaWFsaXphdGlvbi5pZCA9IHRoaXMuI2lkO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnBpdm90ID0gdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHRoaXMubXR4UGl2b3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucGl2b3QpO1xyXG4gICAgICB0aGlzLiNpZCA9IF9zZXJpYWxpemF0aW9uLmlkO1xyXG4gICAgICB0aGlzLm1hc3MgPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5tYXNzLCB0aGlzLm1hc3MpO1xyXG4gICAgICB0aGlzLmRhbXBUcmFuc2xhdGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmRhbXBUcmFuc2xhdGlvbiwgdGhpcy5kYW1wVHJhbnNsYXRpb24pO1xyXG4gICAgICB0aGlzLmRhbXBSb3RhdGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmRhbXBSb3RhdGlvbiwgdGhpcy5kYW1wUm90YXRpb24pO1xyXG4gICAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gaWZOdW1iZXIoX3NlcmlhbGl6YXRpb24uY29sbGlzaW9uR3JvdXAsIHRoaXMuY29sbGlzaW9uR3JvdXApO1xyXG4gICAgICB0aGlzLmVmZmVjdFJvdGF0aW9uID0gX3NlcmlhbGl6YXRpb24uZWZmZWN0Um90YXRpb24gfHwgdGhpcy5lZmZlY3RSb3RhdGlvbjtcclxuICAgICAgdGhpcy5lZmZlY3RHcmF2aXR5ID0gaWZOdW1iZXIoX3NlcmlhbGl6YXRpb24uZWZmZWN0R3Jhdml0eSwgdGhpcy5lZmZlY3RHcmF2aXR5KTtcclxuICAgICAgdGhpcy5mcmljdGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmZyaWN0aW9uLCB0aGlzLmZyaWN0aW9uKTtcclxuICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLnJlc3RpdHV0aW9uLCB0aGlzLnJlc3RpdHV0aW9uKTtcclxuICAgICAgdGhpcy5pc1RyaWdnZXIgPSBfc2VyaWFsaXphdGlvbi5pc1RyaWdnZXIgfHwgdGhpcy5pc1RyaWdnZXI7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbi5pbml0aWFsaXphdGlvbjtcclxuXHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb24gPSA8bnVtYmVyPjx1bmtub3duPkJPRFlfSU5JVFtfc2VyaWFsaXphdGlvbi5pbml0aWFsaXphdGlvbl07XHJcbiAgICAgIHRoaXMudHlwZUJvZHkgPSA8bnVtYmVyPjx1bmtub3duPkJPRFlfVFlQRVtfc2VyaWFsaXphdGlvbi50eXBlQm9keV07XHJcbiAgICAgIHRoaXMudHlwZUNvbGxpZGVyID0gPG51bWJlcj48dW5rbm93bj5DT0xMSURFUl9UWVBFW19zZXJpYWxpemF0aW9uLnR5cGVDb2xsaWRlcl07XHJcbiAgICAgIC8vIHRoaXMuY3JlYXRlKHRoaXMubWFzcywgdGhpcy4jdHlwZUJvZHksIHRoaXMuI3R5cGVDb2xsaWRlciwgdGhpcy5jb2xsaXNpb25Hcm91cCwgbnVsbCwgdGhpcy5jb252ZXhNZXNoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENoYW5nZSBwcm9wZXJ0aWVzIGJ5IGFuIGFzc29jaWF0aXZlIGFycmF5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmIChfbXV0YXRvci50eXBlQm9keSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgX211dGF0b3IudHlwZUJvZHkgPSBwYXJzZUludChfbXV0YXRvci50eXBlQm9keSk7XHJcbiAgICAgIGlmIChfbXV0YXRvci50eXBlQ29sbGlkZXIgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIF9tdXRhdG9yLnR5cGVDb2xsaWRlciA9IHBhcnNlSW50KF9tdXRhdG9yLnR5cGVDb2xsaWRlcik7XHJcbiAgICAgIGlmIChfbXV0YXRvci5pbml0aWFsaXphdGlvbiAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgX211dGF0b3IuaW5pdGlhbGl6YXRpb24gPSBwYXJzZUludChfbXV0YXRvci5pbml0aWFsaXphdGlvbik7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIGlmIChfbXV0YXRvci5pbml0aWFsaXphdGlvbiAhPSB1bmRlZmluZWQgJiYgdGhpcy5pc0FjdGl2ZSlcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgLy8gVE9ETzogc2VlIGlmIHRoaXMgYWx0ZXJuYXRpdmUgc2hvdWxkIGJlLCBhdCBsZWFzdCBwYXJ0aWFsbHksIGRvbmUgd2l0aCBtdXRhdGVTZWxlY3Rpb25cclxuICAgICAgLy8gbGV0IGNhbGxJZkV4aXN0OiBGdW5jdGlvbiA9IChfa2V5OiBzdHJpbmcsIF9zZXR0ZXI6IEZ1bmN0aW9uKSA9PiB7XHJcbiAgICAgIC8vICAgaWYgKF9tdXRhdG9yW19rZXldKVxyXG4gICAgICAvLyAgICAgX3NldHRlcihfbXV0YXRvcltfa2V5XSk7XHJcbiAgICAgIC8vIH07XHJcblxyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcImZyaWN0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5mcmljdGlvbiA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwicmVzdGl0dXRpb25cIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLnJlc3RpdHV0aW9uID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJtYXNzXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5tYXNzID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJkYW1wVHJhbnNsYXRpb25cIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLmRhbXBUcmFuc2xhdGlvbiA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwiZGFtcFJvdGF0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5kYW1wUm90YXRpb24gPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcImVmZmVjdEdyYXZpdHlcIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLmVmZmVjdEdyYXZpdHkgPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcImNvbGxpc2lvbkdyb3VwXCIsIChfdmFsdWU6IENPTExJU0lPTl9HUk9VUCkgPT4gdGhpcy5jb2xsaXNpb25Hcm91cCA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwidHlwZUJvZHlcIiwgKF92YWx1ZTogc3RyaW5nKSA9PiB0aGlzLnR5cGVCb2R5ID0gcGFyc2VJbnQoX3ZhbHVlKSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwidHlwZUNvbGxpZGVyXCIsIChfdmFsdWU6IHN0cmluZykgPT4gdGhpcy50eXBlQ29sbGlkZXIgPSBwYXJzZUludChfdmFsdWUpKTtcclxuXHJcbiAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuXHJcbiAgICAgIG11dGF0b3IuZnJpY3Rpb24gPSB0aGlzLmZyaWN0aW9uO1xyXG4gICAgICBtdXRhdG9yLnJlc3RpdHV0aW9uID0gdGhpcy5yZXN0aXR1dGlvbjtcclxuICAgICAgbXV0YXRvci5tYXNzID0gdGhpcy5tYXNzO1xyXG4gICAgICBtdXRhdG9yLmRhbXBUcmFuc2xhdGlvbiA9IHRoaXMuZGFtcFRyYW5zbGF0aW9uO1xyXG4gICAgICBtdXRhdG9yLmRhbXBSb3RhdGlvbiA9IHRoaXMuZGFtcFJvdGF0aW9uO1xyXG4gICAgICBtdXRhdG9yLmVmZmVjdEdyYXZpdHkgPSB0aGlzLmVmZmVjdEdyYXZpdHk7XHJcbiAgICAgIG11dGF0b3IudHlwZUJvZHkgPSB0aGlzLiN0eXBlQm9keTtcclxuICAgICAgbXV0YXRvci50eXBlQ29sbGlkZXIgPSB0aGlzLiN0eXBlQ29sbGlkZXI7XHJcbiAgICAgIG11dGF0b3IuaXNUcmlnZ2VyID0gdGhpcy4jaXNUcmlnZ2VyO1xyXG5cclxuICAgICAgLy8gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKG11dGF0b3IpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMudHlwZUJvZHkpXHJcbiAgICAgICAgdHlwZXMudHlwZUJvZHkgPSBCT0RZX1RZUEU7XHJcbiAgICAgIGlmICh0eXBlcy50eXBlQ29sbGlkZXIpXHJcbiAgICAgICAgdHlwZXMudHlwZUNvbGxpZGVyID0gQ09MTElERVJfVFlQRTtcclxuICAgICAgaWYgKHR5cGVzLmluaXRpYWxpemF0aW9uKVxyXG4gICAgICAgIHR5cGVzLmluaXRpYWxpemF0aW9uID0gQk9EWV9JTklUO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5jb252ZXhNZXNoOyAvL0NvbnZleCBNZXNoIGNhbid0IGJlIHNob3duIGluIHRoZSBlZGl0b3IgYmVjYXVzZSBmbG9hdDMyQXJyYXkgaXMgbm90IGEgdmlhYmxlIG11dGF0b3JcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmNvbGxpc2lvbk1hc2s7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5pc0luaXRpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gQWN0aXZhdGUgdGhlIGZ1bmN0aW9ucyBvZiB0aGlzIGNvbXBvbmVudCBhcyByZXNwb25zZSB0byBldmVudHNcclxuICAgIHByaXZhdGUgaG5kRXZlbnQgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBzd2l0Y2ggKF9ldmVudC50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfQUREOlxyXG4gICAgICAgICAgLy8gdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BQ1RJVkFURSwgdGhpcy5hZGRSaWdpZGJvZHlUb1dvcmxkKTtcclxuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfREVBQ1RJVkFURSwgdGhpcy5yZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQpO1xyXG4gICAgICAgICAgLy8gdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9BQ1RJVkFURSwgdGhpcy5hZGRSaWdpZGJvZHlUb1dvcmxkLCB0cnVlKTsgLy8gdXNlIGNhcHR1cmUgdG8gcmVhY3QgdG8gYnJvYWRjYXN0IVxyXG4gICAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERUFDVElWQVRFLCB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCwgdHJ1ZSk7XHJcbiAgICAgICAgICBpZiAoIXRoaXMubm9kZS5jbXBUcmFuc2Zvcm0pXHJcbiAgICAgICAgICAgIERlYnVnLndhcm4oXCJDb21wb25lbnRSaWdpZGJvZHkgYXR0YWNoZWQgdG8gbm9kZSBtaXNzaW5nIENvbXBvbmVudFRyYW5zZm9ybVwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfUkVNT1ZFOlxyXG4gICAgICAgICAgLy8gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCk7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5yZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQpO1xyXG4gICAgICAgICAgLy8gdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9BQ1RJVkFURSwgdGhpcy5hZGRSaWdpZGJvZHlUb1dvcmxkLCB0cnVlKTsgLy8gdXNlIGNhcHR1cmUgdG8gcmVhY3QgdG8gYnJvYWRjYXN0IVxyXG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERUFDVElWQVRFLCB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCwgdHJ1ZSk7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRDpcclxuICAgICAgICAgIGlmICghdGhpcy5ub2RlLmNtcFRyYW5zZm9ybSlcclxuICAgICAgICAgICAgRGVidWcuZXJyb3IoXCJDb21wb25lbnRSaWdpZGJvZHkgYXR0YWNoZWQgdG8gbm9kZSBtaXNzaW5nIENvbXBvbmVudFRyYW5zZm9ybVwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8jcmVnaW9uIENyZWF0aW9uXHJcbiAgICBwcml2YXRlIGNyZWF0ZShfbWFzczogbnVtYmVyID0gMSwgX3R5cGU6IEJPRFlfVFlQRSA9IEJPRFlfVFlQRS5EWU5BTUlDLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFID0gQ09MTElERVJfVFlQRS5DVUJFLCBfZ3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdENvbGxpc2lvbkdyb3VwLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBudWxsLCBfY29udmV4TWVzaDogRmxvYXQzMkFycmF5ID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICAvL1NldHRpbmcgdXAgYWxsIGluY29taW5nIHZhbHVlcyB0byBiZSBpbnRlcm5hbCB2YWx1ZXNcclxuICAgICAgdGhpcy5jb252ZXhNZXNoID0gX2NvbnZleE1lc2g7XHJcbiAgICAgIHRoaXMuI3R5cGVCb2R5ID0gX3R5cGU7XHJcbiAgICAgIHRoaXMuI2NvbGxpc2lvbkdyb3VwID0gX2dyb3VwO1xyXG4gICAgICB0aGlzLiN0eXBlQ29sbGlkZXIgPSBfY29sbGlkZXJUeXBlO1xyXG4gICAgICB0aGlzLm1hc3MgPSBfbWFzcztcclxuICAgICAgdGhpcy4jcmVzdGl0dXRpb24gPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRSZXN0aXR1dGlvbjtcclxuICAgICAgdGhpcy4jZnJpY3Rpb24gPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRGcmljdGlvbjtcclxuICAgICAgdGhpcy5jb2xsaXNpb25NYXNrID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgICAgLy9DcmVhdGUgdGhlIGFjdHVhbCByaWdpZGJvZHkgaW4gdGhlIE9pbW9QaHlzaWNzIFNwYWNlXHJcbiAgICAgIHRoaXMuY3JlYXRlUmlnaWRib2R5KF9tYXNzLCBfdHlwZSwgdGhpcy4jdHlwZUNvbGxpZGVyLCBfbXR4VHJhbnNmb3JtLCB0aGlzLiNjb2xsaXNpb25Hcm91cCk7XHJcbiAgICAgIHRoaXMuI2lkID0gUGh5c2ljcy5kaXN0cmlidXRlQm9keUlEKCk7XHJcblxyXG4gICAgICAvLyBFdmVudCBDYWxsYmFja3MgZGlyZWN0bHkgZnJvbSBPSU1PIFBoeXNpY3NcclxuICAgICAgdGhpcy4jY2FsbGJhY2tzID0gbmV3IE9JTU8uQ29udGFjdENhbGxiYWNrKCk7IC8vZmVobVxyXG4gICAgICB0aGlzLiNjYWxsYmFja3MuYmVnaW5UcmlnZ2VyQ29udGFjdCA9IHRoaXMudHJpZ2dlckVudGVyO1xyXG4gICAgICB0aGlzLiNjYWxsYmFja3MuZW5kVHJpZ2dlckNvbnRhY3QgPSB0aGlzLnRyaWdnZXJFeGl0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIHRoZSBhY3R1YWwgT2ltb1BoeXNpY3MgUmlnaWRib2R5IG91dCBvZiBpbmZvcm1hdGlvbnMgdGhlIEZVREdFIENvbXBvbmVudCBoYXMuICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVJpZ2lkYm9keShfbWFzczogbnVtYmVyLCBfdHlwZTogQk9EWV9UWVBFLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9jb2xsaXNpb25Hcm91cDogQ09MTElTSU9OX0dST1VQID0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQpOiB2b2lkIHtcclxuICAgICAgbGV0IG9pbW9UeXBlOiBudW1iZXI7IC8vTmVlZCB0aGUgY29udmVyc2lvbiBmcm9tIHNpbXBsZSBlbnVtIHRvIG51bWJlciBiZWNhdXNlIGlmIGVudW0gaXMgZGVmaW5lZCBhcyBPaW1vLlJpZ2lkeUJvZHlUeXBlIHlvdSBoYXZlIHRvIGluY2x1ZGUgT2ltbyB0byB1c2UgRlVER0UgYXQgYWxsXHJcbiAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICBjYXNlIEJPRFlfVFlQRS5EWU5BTUlDOlxyXG4gICAgICAgICAgb2ltb1R5cGUgPSBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9UWVBFLlNUQVRJQzpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLlNUQVRJQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9UWVBFLktJTkVNQVRJQzpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLktJTkVNQVRJQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBvaW1vVHlwZSA9IE9JTU8uUmlnaWRCb2R5VHlwZS5EWU5BTUlDO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgcHJldmlvdXMgc2hhcGVzIGZyb20gd29ybGQuIE5lY2Vzc2FyeT9cclxuICAgICAgLy8gd2hpbGUgKHRoaXMuI3JpZ2lkYm9keSAmJiB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkgIT0gbnVsbClcclxuICAgICAgLy8gICB0aGlzLiNyaWdpZGJvZHkucmVtb3ZlU2hhcGUodGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpKTtcclxuXHJcbiAgICAgIGxldCB0bXBUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IF9tdHhUcmFuc2Zvcm0gPT0gbnVsbCA/IHN1cGVyLm5vZGUgIT0gbnVsbCA/IHN1cGVyLm5vZGUubXR4V29ybGQgOiBNYXRyaXg0eDQuSURFTlRJVFkoKSA6IF9tdHhUcmFuc2Zvcm07IC8vR2V0IHRyYW5zZm9ybSBpbmZvcm1hdGlvbnMgZnJvbSB0aGUgd29ybGQsIHNpbmNlIHBoeXNpY3MgZG9lcyBub3QgY2FyZSBhYm91dCBoaWVyYXJjaHlcclxuICAgICAgLy9Db252ZXJ0IGluZm9ybWF0aW9ucyBmcm9tIEZVREdFIHRvIE9pbW9QaHlzaWNzIGFuZCBjcmVhdGluZyBhIGNvbGxpZGVyIHdpdGggaXQsIHdoaWxlIGFsc28gYWRkaW5nIGEgcGl2b3QgdG8gZGVyaXZhdGUgZnJvbSB0aGUgdHJhbnNmb3JtIGluZm9ybWF0aW9ucyBpZiBuZWVkZWRcclxuICAgICAgbGV0IHNjYWxlOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKCh0bXBUcmFuc2Zvcm0uc2NhbGluZy54ICogdGhpcy5tdHhQaXZvdC5zY2FsaW5nLngpIC8gMiwgKHRtcFRyYW5zZm9ybS5zY2FsaW5nLnkgKiB0aGlzLm10eFBpdm90LnNjYWxpbmcueSkgLyAyLCAodG1wVHJhbnNmb3JtLnNjYWxpbmcueiAqIHRoaXMubXR4UGl2b3Quc2NhbGluZy56KSAvIDIpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzModG1wVHJhbnNmb3JtLnRyYW5zbGF0aW9uLnggKyB0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLngsIHRtcFRyYW5zZm9ybS50cmFuc2xhdGlvbi55ICsgdGhpcy5tdHhQaXZvdC50cmFuc2xhdGlvbi55LCB0bXBUcmFuc2Zvcm0udHJhbnNsYXRpb24ueiArIHRoaXMubXR4UGl2b3QudHJhbnNsYXRpb24ueik7XHJcbiAgICAgIGxldCByb3RhdGlvbjogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyh0bXBUcmFuc2Zvcm0ucm90YXRpb24ueCArIHRoaXMubXR4UGl2b3Qucm90YXRpb24ueCwgdG1wVHJhbnNmb3JtLnJvdGF0aW9uLnkgKyB0aGlzLm10eFBpdm90LnJvdGF0aW9uLnksIHRtcFRyYW5zZm9ybS5yb3RhdGlvbi56ICsgdGhpcy5tdHhQaXZvdC5yb3RhdGlvbi56KTtcclxuICAgICAgdGhpcy5jcmVhdGVDb2xsaWRlcihzY2FsZSwgX2NvbGxpZGVyVHlwZSk7XHJcbiAgICAgIC8vU2V0dGluZyBpbmZvcm1hdGlvbnMgYWJvdXQgbWFzcywgcG9zaXRpb24vcm90YXRpb24gYW5kIHBoeXNpY2FsIHJlYWN0aW9uIHR5cGVcclxuICAgICAgdGhpcy4jbWFzc0RhdGEubWFzcyA9IF9tYXNzOyAvL190eXBlICE9IFBIWVNJQ1NfVFlQRS5TVEFUSUMgPyBfbWFzcyA6IDA7IC8vSWYgYSBvYmplY3QgaXMgc3RhdGljIGl0IGFjdHMgYXMgaWYgaXQgaGFzIG5vIG1hc3NcclxuICAgICAgdGhpcy4jcmlnaWRib2R5SW5mby50eXBlID0gb2ltb1R5cGU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keUluZm8ucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5SW5mby5yb3RhdGlvbi5mcm9tRXVsZXJYeXoobmV3IE9JTU8uVmVjMyhyb3RhdGlvbi54LCByb3RhdGlvbi55LCByb3RhdGlvbi56KSk7IC8vQ29udmVydCBldWxlckFuZ2xlcyBpbiBkZWdyZWUgdG8gdGhlIGludGVybmFsbHkgdXNlZCBxdWF0ZXJuaW9uc1xyXG4gICAgICAvL0NyZWF0aW5nIHRoZSBhY3R1YWwgcmlnaWRib2R5IGFuZCBpdCdzIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keSA9IG5ldyBPSU1PLlJpZ2lkQm9keSh0aGlzLiNyaWdpZGJvZHlJbmZvKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIgPSBuZXcgT0lNTy5TaGFwZSh0aGlzLiNjb2xsaWRlckluZm8pO1xyXG4gICAgICAvL0ZpbGxpbmcgdGhlIGFkZGl0aW9uYWwgc2V0dGluZ3MgYW5kIGluZm9ybWF0aW9ucyB0aGUgcmlnaWRib2R5IG5lZWRzLiBXaG8gaXMgY29sbGlkaW5nLCBob3cgaXMgdGhlIGNvbGxpc2lvbiBoYW5kbGVkIChkYW1waW5nLCBpbmZsdWVuY2UgZmFjdG9ycylcclxuICAgICAgdGhpcy4jY29sbGlkZXIudXNlckRhdGEgPSB0aGlzO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25Hcm91cChfY29sbGlzaW9uR3JvdXApO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25NYXNrKHRoaXMuY29sbGlzaW9uTWFzayk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hZGRTaGFwZSh0aGlzLiNjb2xsaWRlcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRNYXNzRGF0YSh0aGlzLiNtYXNzRGF0YSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRSZXN0aXR1dGlvbih0aGlzLiNyZXN0aXR1dGlvbik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRGcmljdGlvbih0aGlzLiNmcmljdGlvbik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRDb250YWN0Q2FsbGJhY2sodGhpcy4jY2FsbGJhY2tzKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldExpbmVhckRhbXBpbmcodGhpcy4jZGFtcGluZ0xpbmVhcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRBbmd1bGFyRGFtcGluZyh0aGlzLiNkYW1waW5nQW5ndWxhcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRHcmF2aXR5U2NhbGUodGhpcy4jZWZmZWN0R3Jhdml0eSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRSb3RhdGlvbkZhY3RvcihuZXcgT0lNTy5WZWMzKHRoaXMuI2VmZmVjdFJvdGF0aW9uLngsIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnksIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhIGNvbGxpZGVyIGEgc2hhcGUgdGhhdCByZXByZXNlbnRzIHRoZSBvYmplY3QgaW4gdGhlIHBoeXNpY2FsIHdvcmxkLiAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQ29sbGlkZXIoX3NjYWxlOiBPSU1PLlZlYzMsIF9jb2xsaWRlclR5cGU6IENPTExJREVSX1RZUEUpOiB2b2lkIHtcclxuICAgICAgbGV0IHNoYXBlQ29uZjogT0lNTy5TaGFwZUNvbmZpZyA9IG5ldyBPSU1PLlNoYXBlQ29uZmlnKCk7IC8vQ29sbGlkZXIgd2l0aCBnZW9tZXRyeSBhbmQgaW5mb3MgbGlrZSBmcmljdGlvbi9yZXN0aXR1dGlvbiBhbmQgbW9yZVxyXG4gICAgICBsZXQgZ2VvbWV0cnk6IE9JTU8uR2VvbWV0cnk7XHJcbiAgICAgIGlmICh0aGlzLnR5cGVDb2xsaWRlciAhPSBfY29sbGlkZXJUeXBlKSAvL0lmIHRoZSBjb2xsaWRlciB0eXBlIHdhcyBjaGFuZ2VkIHNldCB0aGUgaW50ZXJuYWwgb25lIG5ldywgZWxzZSBkb24ndCBzbyB0aGVyZSBpcyBub3QgaW5maW5pdGUgc2V0IGNhbGxzXHJcbiAgICAgICAgdGhpcy50eXBlQ29sbGlkZXIgPSBfY29sbGlkZXJUeXBlO1xyXG4gICAgICBzd2l0Y2ggKF9jb2xsaWRlclR5cGUpIHsgIC8vQ3JlYXRlIGEgZGlmZmVyZW50IE9pbW9QaHlzaWNzIGdlb21ldHJ5IGJhc2VkIG9uIHRoZSBnaXZlbiB0eXBlLiBUaGF0IGlzIG9ubHkgdGhlIG1hdGhlbWF0aWNhbCBzaGFwZSBvZiB0aGUgY29sbGlkZXJcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuQ1VCRTpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQm94R2VvbWV0cnkoX3NjYWxlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5TUEhFUkU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLlNwaGVyZUdlb21ldHJ5KF9zY2FsZS54KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DQVBTVUxFOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgT0lNTy5DYXBzdWxlR2VvbWV0cnkoX3NjYWxlLngsIF9zY2FsZS55KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DWUxJTkRFUjpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQ3lsaW5kZXJHZW9tZXRyeShfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNPTkU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLkNvbmVHZW9tZXRyeShfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLlBZUkFNSUQ6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IHRoaXMuY3JlYXRlQ29udmV4R2VvbWV0cnlDb2xsaWRlcih0aGlzLmNyZWF0ZVB5cmFtaWRWZXJ0aWNlcygpLCBfc2NhbGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNPTlZFWDpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVDb252ZXhHZW9tZXRyeUNvbGxpZGVyKHRoaXMuY29udmV4TWVzaCwgX3NjYWxlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHNoYXBlQ29uZi5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICB0aGlzLiNjb2xsaWRlckluZm8gPSBzaGFwZUNvbmY7IC8vdGhlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25zIHRoYXQgYXJlIHVzZWQgdG8gYWRkIGFuIGFjdHVhbCBjb2xsaWRlciB0byB0aGUgcmlnaWRib2R5IGluIGNyZWF0ZVJpZ2lkYm9keVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIHNoYXBlIHRoYXQgcmVwcmVzZW50cyBhIGluIGl0c2VsZiBjbG9zZWQgZm9ybSwgb3V0IG9mIHRoZSBnaXZlbiB2ZXJ0aWNlcy4gKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQ29udmV4R2VvbWV0cnlDb2xsaWRlcihfdmVydGljZXM6IEZsb2F0MzJBcnJheSwgX3NjYWxlOiBPSU1PLlZlYzMpOiBPSU1PLkNvbnZleEh1bGxHZW9tZXRyeSB7XHJcbiAgICAgIGxldCB2ZXJ0aWNlc0FzVmVjMzogT0lNTy5WZWMzW10gPSBuZXcgQXJyYXkoKTsgLy9Db252ZXJ0IEZVREdFIFZlY3RvcjMgdG8gT2ltb1ZlYzNcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF92ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMykgeyAvLzMgVmFsdWVzIGZvciBvbmUgcG9pbnRcclxuICAgICAgICB2ZXJ0aWNlc0FzVmVjMy5wdXNoKG5ldyBPSU1PLlZlYzMoX3ZlcnRpY2VzW2ldICogX3NjYWxlLngsIF92ZXJ0aWNlc1tpICsgMV0gKiBfc2NhbGUueSwgX3ZlcnRpY2VzW2kgKyAyXSAqIF9zY2FsZS56KSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBPSU1PLkNvbnZleEh1bGxHZW9tZXRyeSh2ZXJ0aWNlc0FzVmVjMyk7IC8vVGVsbCBPaW1vUGh5c2ljcyB0byBjcmVhdGUgYSBodWxsIHRoYXQgaW52b2x2ZXMgYWxsIHBvaW50cyBidXQgY2xvc2UgaXQgb2YuIEEgY29udmV4IHNoYXBlIGNhbiBub3QgaGF2ZSBhIGhvbGUgaW4gaXQuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHZlcnRpY2VzIHRoYXQgY29uc3RydWN0IGEgcHlyYW1pZC4gVGhlIHZlcnRpY2VzIG9mIHRoZSBpbXBsZW1lbnRlZCBweXJhbWlkIG1lc2ggY2FuIGJlIHVzZWQgdG9vLiBCdXQgdGhleSBhcmUgaGFsZmVkIGFuZCBkb3VibGUgc2lkZWQsIHNvIGl0J3MgbW9yZSBwZXJmb3JtYW50IHRvIHVzZSB0aGlzLiAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVQeXJhbWlkVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAvKjAqLy0xLCAwLCAxLCAvKjEqLyAxLCAwLCAxLCAgLyoyKi8gMSwgMCwgLTEsIC8qMyovIC0xLCAwLCAtMSxcclxuICAgICAgICAvKjQqLyAwLCAyLCAwXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEFkZGluZyB0aGlzIENvbXBvbmVudFJpZ2lkYm9keSB0byB0aGUgUGh5c2lzY3Mud29ybGQgZ2l2aW5nIHRoZSBvaW1vUGh5c2ljcyBzeXN0ZW0gdGhlIGluZm9ybWF0aW9uIG5lZWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBhZGRSaWdpZGJvZHlUb1dvcmxkID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuI3JpZ2lkYm9keS5fd29ybGQpXHJcbiAgICAgICAgUGh5c2ljcy5hZGRSaWdpZGJvZHkodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBSZW1vdmluZyB0aGlzIENvbXBvbmVudFJpZ2lkYm9keSBmcm9tIHRoZSBQaHlzaXNjcy53b3JsZCB0YWtpbmcgdGhlIGluZm9ybWF0aW9ucyBmcm9tIHRoZSBvaW1vUGh5c2ljcyBzeXN0ZW0gKi9cclxuICAgIHByaXZhdGUgcmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBQaHlzaWNzLnJlbW92ZVJpZ2lkYm9keSh0aGlzKTtcclxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gcHJpdmF0ZSBFVkVOVCBmdW5jdGlvbnNcclxuICAgIC8vQ2FsY3VsYXRpbmcgdGhlIGNlbnRlciBvZiBhIGNvbGxpc2lvbiBhcyBhIHNpbmd1bGFyIHBvaW50IC0gaW4gY2FzZSB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHBvaW50IC0gYnkgZ2V0dGluZyB0aGUgZ2VvbWV0cmljYWwgY2VudGVyIG9mIGFsbCBjb2xsaWRpbmcgcG9pbnRzXHJcbiAgICBwcml2YXRlIGNvbGxpc2lvbkNlbnRlclBvaW50KF9jb2xQb2ludHM6IE9JTU8uTWFuaWZvbGRQb2ludFtdLCBfbnVtUG9pbnRzOiBudW1iZXIpOiBPSU1PLlZlYzMge1xyXG4gICAgICBsZXQgY2VudGVyOiBPSU1PLlZlYzM7XHJcbiAgICAgIGxldCB0b3RhbFBvaW50czogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRvdGFsWDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRvdGFsWTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRvdGFsWjogbnVtYmVyID0gMDtcclxuICAgICAgX2NvbFBvaW50cy5mb3JFYWNoKChfdmFsdWU6IE9JTU8uTWFuaWZvbGRQb2ludCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICh0b3RhbFBvaW50cyA8IF9udW1Qb2ludHMpIHtcclxuICAgICAgICAgIHRvdGFsUG9pbnRzKys7XHJcbiAgICAgICAgICB0b3RhbFggKz0gX3ZhbHVlLmdldFBvc2l0aW9uMigpLng7XHJcbiAgICAgICAgICB0b3RhbFkgKz0gX3ZhbHVlLmdldFBvc2l0aW9uMigpLnk7XHJcbiAgICAgICAgICB0b3RhbFogKz0gX3ZhbHVlLmdldFBvc2l0aW9uMigpLno7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgY2VudGVyID0gbmV3IE9JTU8uVmVjMyh0b3RhbFggLyBfbnVtUG9pbnRzLCB0b3RhbFkgLyBfbnVtUG9pbnRzLCB0b3RhbFogLyBfbnVtUG9pbnRzKTtcclxuICAgICAgcmV0dXJuIGNlbnRlcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogVHJpZ2dlciBFbnRlcmluZ0V2ZW50IENhbGxiYWNrLCBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBPSU1PIFBoeXNpY3Mgd2l0aGluIHRoZWlyIGNhbGN1bGF0aW9ucy5cclxuICAgICogU2luY2UgdGhlIGV2ZW50IGRvZXMgbm90IGtub3cgd2hpY2ggYm9keSBpcyB0aGUgdHJpZ2dlciBpbmlhdG9yLCB0aGUgZXZlbnQgY2FuIGJlIGxpc3RlbmVkIHRvXHJcbiAgICAqIG9uIGVpdGhlciB0aGUgdHJpZ2dlciBvciB0aGUgdHJpZ2dlcmVkLiAoVGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggdGhlIEZVREdFIE9JTU8gRm9yayEpXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRW50ZXIoX2NvbnRhY3Q6IE9JTU8uQ29udGFjdCk6IHZvaWQge1xyXG4gICAgICBsZXQgb2JqSGl0OiBDb21wb25lbnRSaWdpZGJvZHk7IC8vY29sbGlzaW9uIGNvbnNpc3Rpbmcgb2YgMiBib2RpZXMsIHNvIEhpdDEvMlxyXG4gICAgICBsZXQgb2JqSGl0MjogQ29tcG9uZW50UmlnaWRib2R5O1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50UGh5c2ljczsgIC8vVGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBzZW5kIGFuZCB0aGUgaW5mb3JtYXRpb25zIGFkZGVkIHRvIGl0XHJcbiAgICAgIGxldCBjb2xQb2ludDogVmVjdG9yMztcclxuXHJcbiAgICAgIC8vQUREIE5FVyBUcmlnZ2VyaW5nIC0gVGhhdCBqdXN0IGhhcHBlbmVkXHJcbiAgICAgIGxldCBjb2xsaXNpb25NYW5pZm9sZDogT0lNTy5NYW5pZm9sZCA9IF9jb250YWN0LmdldE1hbmlmb2xkKCk7IC8vTWFuaWZvbGQgPSBBZGRpdGlvbmFsIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgY29udGFjdFxyXG4gICAgICBvYmpIaXQgPSBfY29udGFjdC5nZXRTaGFwZTEoKS51c2VyRGF0YTsgIC8vVXNlcmRhdGEgaXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgxpIuQ29tcG9uZW50UmlnaWRib2R5LCBpdCdzIGFuIGVtcHR5IE9pbW9QaHlzaWNzIFZhcmlhYmxlXHJcbiAgICAgIC8vT25seSByZWdpc3RlciB0aGUgY29sbGlzaW9uIG9uIHRoZSBhY3R1YWwgdG91Y2gsIG5vdCBvbiBcInNoYWRvd0NvbGxpZGVcIiwgdG8gcmVnaXN0ZXIgaW4gdGhlIG1vbWVudCBvZiBpbXB1bHNlIGNhbGN1bGF0aW9uXHJcbiAgICAgIGlmIChvYmpIaXQgPT0gbnVsbCB8fCBfY29udGFjdC5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpIC8vIG9ubHkgYWN0IGlmIHRoZSBjb2xsaXNpb24gaXMgYWN0dWFsIHRvdWNoaW5nLCBzbyByaWdodCBhdCB0aGUgbW9tZW50IHdoZW4gYSBpbXB1bHNlIGlzIGhhcHBlbmluZywgbm90IHdoZW4gc2hhcGVzIG92ZXJsYXBcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIG9iakhpdDIgPSBfY29udGFjdC5nZXRTaGFwZTIoKS51c2VyRGF0YTtcclxuICAgICAgaWYgKG9iakhpdDIgPT0gbnVsbCB8fCBfY29udGFjdC5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgcG9pbnRzOiBPSU1PLk1hbmlmb2xkUG9pbnRbXSA9IGNvbGxpc2lvbk1hbmlmb2xkLmdldFBvaW50cygpOyAvL0FsbCBwb2ludHMgaW4gdGhlIGNvbGxpc2lvbiB3aGVyZSB0aGUgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIGltcGFjdFxyXG4gICAgICBsZXQgbm9ybWFsOiBPSU1PLlZlYzMgPSBjb2xsaXNpb25NYW5pZm9sZC5nZXROb3JtYWwoKTtcclxuICAgICAgaWYgKG9iakhpdDIudHJpZ2dlcmluZ3MuaW5kZXhPZihvYmpIaXQpID09IC0xKSB7IC8vRmlyZSwgaWYgdGhlIGhpdCBvYmplY3QgaXMgbm90IHRoZSBCb2R5IGl0c2VsZiBidXQgYW5vdGhlciBhbmQgaXQncyBub3QgYWxyZWFkeSBmaXJlZC5cclxuICAgICAgICBsZXQgY29sUG9zOiBPSU1PLlZlYzMgPSBvYmpIaXQyLmNvbGxpc2lvbkNlbnRlclBvaW50KHBvaW50cywgY29sbGlzaW9uTWFuaWZvbGQuZ2V0TnVtUG9pbnRzKCkpOyAvL1RIRSBwb2ludCBvZiBjb2xsaXNpb24gaXMgdGhlIGZpcnN0IHRvdWNoaW5nIHBvaW50IChFWFRFTlNJT046IGNvdWxkIGJlIHRoZSBjZW50ZXIgb2YgYWxsIHRvdWNoaW5nIHBvaW50cyBjb21iaW5lZClcclxuICAgICAgICBjb2xQb2ludCA9IG5ldyBWZWN0b3IzKGNvbFBvcy54LCBjb2xQb3MueSwgY29sUG9zLnopO1xyXG4gICAgICAgIC8vIEltcHVsc2VzIGFyZSAwIHNpbmNlLCB0aGVyZSBhcmUgbm8gZm9yY2VzL2ltcHVsc2VzIGF0IHdvcmssIGVsc2UgdGhpcyB3b3VsZCBub3QgYmUgYSB0cmlnZ2VyLCBidXQgYSBjb2xsaXNpb25cclxuICAgICAgICBvYmpIaXQyLnRyaWdnZXJpbmdzLnB1c2gob2JqSGl0KTsgLy9UZWxsIHRoZSBvYmplY3QgdGhhdCB0aGUgZXZlbnQgZm9yIHRoaXMgb2JqZWN0IGRvZXMgbm90IG5lZWQgdG8gYmUgZmlyZWQgYWdhaW5cclxuICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5UUklHR0VSX0VOVEVSLCBvYmpIaXQsIDAsIDAsIDAsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7IC8vQnVpbGRpbmcgdGhlIGFjdHVhbCBldmVudCwgd2l0aCB3aGF0IG9iamVjdCBkaWQgY29sbGlkZSBhbmQgaW5mb3JtYXRpb25zIGFib3V0IGl0XHJcbiAgICAgICAgb2JqSGl0Mi5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy9TZW5kaW5nIHRoZSBnaXZlbiBldmVudFxyXG4gICAgICB9XHJcbiAgICAgIGlmIChvYmpIaXQudHJpZ2dlcmluZ3MuaW5kZXhPZihvYmpIaXQyKSA9PSAtMSkgeyAvL1NhbWUgYXMgdGhlIGFib3ZlIGJ1dCBmb3IgdGhlIGNhc2UgdGhlIFNFQ09ORCBoaXQgb2JqZWN0IGlzIG5vdCB0aGUgYm9keSBpdHNlbGZcclxuICAgICAgICBsZXQgY29sUG9zOiBPSU1PLlZlYzMgPSBvYmpIaXQuY29sbGlzaW9uQ2VudGVyUG9pbnQocG9pbnRzLCBjb2xsaXNpb25NYW5pZm9sZC5nZXROdW1Qb2ludHMoKSk7XHJcbiAgICAgICAgY29sUG9pbnQgPSBuZXcgVmVjdG9yMyhjb2xQb3MueCwgY29sUG9zLnksIGNvbFBvcy56KTtcclxuICAgICAgICAvLyBJbXB1bHNlcyBhcmUgMCBzaW5jZSwgdGhlcmUgYXJlIG5vIGZvcmNlcy9pbXB1bHNlcyBhdCB3b3JrLCBlbHNlIHRoaXMgd291bGQgbm90IGJlIGEgdHJpZ2dlciwgYnV0IGEgY29sbGlzaW9uLFxyXG4gICAgICAgIC8vIGFsc28gdGhlIGV2ZW50IGlzIGhhbmRsZWQgYmVmb3JlIHRoZSBhY3R1YWwgc29sdmluZyBpbXB1bHNlIHN0ZXAgaW4gT0lNT1xyXG4gICAgICAgIG9iakhpdC50cmlnZ2VyaW5ncy5wdXNoKG9iakhpdDIpO1xyXG4gICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRU5URVIsIG9iakhpdDIsIDAsIDAsIDAsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7XHJcbiAgICAgICAgb2JqSGl0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXIgTGVhdmluZ0V2ZW50IENhbGxiYWNrLCBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBPSU1PIFBoeXNpY3Mgd2l0aGluIHRoZWlyIGNhbGN1bGF0aW9ucy5cclxuICAgICogU2luY2UgdGhlIGV2ZW50IGRvZXMgbm90IGtub3cgd2hpY2ggYm9keSBpcyB0aGUgdHJpZ2dlciBpbmlhdG9yLCB0aGUgZXZlbnQgY2FuIGJlIGxpc3RlbmVkIHRvXHJcbiAgICAqIG9uIGVpdGhlciB0aGUgdHJpZ2dlciBvciB0aGUgdHJpZ2dlcmVkLiAoVGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggdGhlIEZVREdFIE9JTU8gRm9yayEpXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRXhpdChfY29udGFjdDogT0lNTy5Db250YWN0KTogdm9pZCB7XHJcbiAgICAgIC8vUkVNT1ZFIE9MRCBUcmlnZ2VyaW5nIEJvZHlcclxuICAgICAgbGV0IG9iakhpdDogQ29tcG9uZW50UmlnaWRib2R5OyAvL2NvbGxpc2lvbiBjb25zaXN0aW5nIG9mIDIgYm9kaWVzLCBzbyBIaXQxLzJcclxuICAgICAgbGV0IG9iakhpdDI6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuICAgICAgbGV0IGV2ZW50OiBFdmVudFBoeXNpY3M7ICAvL1RoZSBldmVudCB0aGF0IHdpbGwgYmUgc2VuZCBhbmQgdGhlIGluZm9ybWF0aW9ucyBhZGRlZCB0byBpdFxyXG4gICAgICBvYmpIaXQgPSBfY29udGFjdC5nZXRTaGFwZTEoKS51c2VyRGF0YTtcclxuICAgICAgb2JqSGl0MiA9IF9jb250YWN0LmdldFNoYXBlMigpLnVzZXJEYXRhO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIGJvdGggYm9kaWVzIGluIGJvdGggY2FzZXMsIG9mIHNlbGYgYW5kIG90aGVyXHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gb2JqSGl0LnRyaWdnZXJpbmdzLmluZGV4T2Yob2JqSGl0Mik7IC8vRmluZCBvYmplY3QgaW4gdGhlIGFycmF5XHJcbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgIG9iakhpdC50cmlnZ2VyaW5ncy5zcGxpY2UoaW5kZXgpOyAvL3JlbW92ZSBpdCBmcm9tIHRoZSBhcnJheVxyXG4gICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRVhJVCwgb2JqSGl0MiwgMCwgMCwgMCk7XHJcbiAgICAgICAgb2JqSGl0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGluZGV4ID0gb2JqSGl0Mi50cmlnZ2VyaW5ncy5pbmRleE9mKG9iakhpdCk7IC8vRmluZCBvYmplY3QgaW4gdGhlIGFycmF5XHJcbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgIG9iakhpdDIudHJpZ2dlcmluZ3Muc3BsaWNlKGluZGV4KTsgLy9yZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXlcclxuICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5UUklHR0VSX0VYSVQsIG9iakhpdCwgMCwgMCwgMCk7XHJcbiAgICAgICAgb2JqSGl0Mi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKiBJbnRlcm5hbCBjbGFzcyBmb3IgaG9sZGluZyBkYXRhIGFib3V0IHBoeXNpY3MgZGVidWcgdmVydGljZXMuKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyIHtcclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgIHB1YmxpYyBudW1WZXJ0aWNlczogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBhdHRyaWJzOiBBcnJheTxQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGU+O1xyXG4gICAgcHVibGljIGluZGljZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgb2Zmc2V0czogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBzdHJpZGU6IG51bWJlcjtcclxuICAgIHB1YmxpYyBidWZmZXI6IFdlYkdMQnVmZmVyO1xyXG4gICAgcHVibGljIGRhdGFMZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogU2V0dXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIGJ1ZmZlciBhbmQgY3JlYXRlIHRoZSBhY3R1YWwgYnVmZmVyIGZvciB0aGlzIGNvbnRleHQuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JlbmRlcmluZ0NvbnRleHQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5nbCA9IF9yZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZpbGwgdGhlIGJvdW5kIGJ1ZmZlciB3aXRoIGRhdGEuIFVzZWQgYXQgYnVmZmVyIGluaXRpYWxpemF0aW9uICovXHJcbiAgICBwdWJsaWMgc2V0RGF0YShfYXJyYXk6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuYXR0cmlicyA9PSBudWxsKSB0aHJvdyBcInNldCBhdHRyaWJ1dGVzIGZpcnN0XCI7XHJcbiAgICAgIHRoaXMubnVtVmVydGljZXMgPSBfYXJyYXkubGVuZ3RoIC8gKHRoaXMuc3RyaWRlIC8gNCk7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoX2FycmF5KSwgdGhpcy5nbC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgICAvL25vdCBuZWNlc3NhcnkgYW4gaW4gd2ViZ2wyIGFueW1vcmUgdG8gcmViaW5kIHRoZSBzYW1lIGxhc3QgYnVmZmVyICh3aGljaCBpcyBhY2hpZXZlZCBieSBnaXZpbmcgYSBudWxsIGJ1ZmZlciksIGFmdGVyIGJ1ZmZlciBpcyBjaGFuZ2VkLiBSZW1vdmVkIGl0IG9uIGFsbCBvdGhlciBvY2Nhc2lvbnNcclxuICAgICAgLy8gdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTsgXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNldCBTaGFkZXIgQXR0cmlidXRlcyBpbmZvcm1hdGlvbnMgYnkgZ2V0dGluZyB0aGVpciBwb3NpdGlvbiBpbiB0aGUgc2hhZGVyLCBzZXR0aW5nIHRoZSBvZmZzZXQsIHN0cmlkZSBhbmQgc2l6ZS4gRm9yIGxhdGVyIHVzZSBpbiB0aGUgYmluZGluZyBwcm9jZXNzICovXHJcbiAgICBwdWJsaWMgc2V0QXR0cmlicyhfYXR0cmliczogQXJyYXk8UGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlPik6IHZvaWQge1xyXG4gICAgICB0aGlzLmF0dHJpYnMgPSBfYXR0cmlicztcclxuICAgICAgdGhpcy5vZmZzZXRzID0gW107XHJcbiAgICAgIHRoaXMuc3RyaWRlID0gMDtcclxuICAgICAgbGV0IG46IG51bWJlciA9IF9hdHRyaWJzLmxlbmd0aDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKHRoaXMuc3RyaWRlKTtcclxuICAgICAgICB0aGlzLnN0cmlkZSArPSBfYXR0cmlic1tpXS5mbG9hdDMyQ291bnQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7IC8vIDMyYml0IGZsb2F0IEJ5dGVzIGFyZSBhIGNvbnN0YW50IG9mIDRcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBhdHRyaWJ1dGUgaW4gdGhlIHNoYWRlciAqL1xyXG4gICAgcHVibGljIGxvYWRBdHRyaWJJbmRpY2VzKF9wcm9ncmFtOiBQaHlzaWNzRGVidWdTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gX3Byb2dyYW0uZ2V0QXR0cmliSW5kaWNlcyh0aGlzLmF0dHJpYnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFbmFibGUgYSBhdHRyaWJ1dGUgaW4gYSBzaGFkZXIgZm9yIHRoaXMgY29udGV4dCwgKi9cclxuICAgIHB1YmxpYyBiaW5kQXR0cmlicygpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuaW5kaWNlcyA9PSBudWxsKSB0aHJvdyBcImluZGljZXMgYXJlIG5vdCBsb2FkZWRcIjtcclxuICAgICAgbGV0IG46IG51bWJlciA9IHRoaXMuYXR0cmlicy5sZW5ndGg7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpOyAvL21ha2luZyB0aGUgYnVmZmVyIG9mIHRoaXMgY2xhc3MgdGhlIGN1cnJlbnQgYnVmZmVyXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuaW5kaWNlc1tpXSk7IC8vZW5hYmxlIHRoZSBBdHRyaWJ1dGVcclxuICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5pbmRpY2VzW2ldLCB0aGlzLmF0dHJpYnNbaV0uZmxvYXQzMkNvdW50LCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgdGhpcy5zdHJpZGUsIHRoaXMub2Zmc2V0c1tpXSk7IC8vY3JlYXRlcyBhIHBvaW50ZXIgYW5kIHN0cnVjdHVyZSBmb3IgdGhpcyBhdHRyaWJ1dGVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEludGVybmFsIGNsYXNzIGZvciBob2xkaW5nIGRhdGEgYWJvdXQgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVycyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlciB7XHJcbiAgICBwdWJsaWMgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwdWJsaWMgYnVmZmVyOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBjb3VudDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBTZXR1cCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoaXMgYnVmZmVyIGFuZCBjcmVhdGUgdGhlIGFjdHVhbCBidWZmZXIgZm9yIHRoaXMgY29udGV4dC4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmVuZGVyaW5nQ29udGV4dDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xyXG4gICAgICB0aGlzLmdsID0gX3JlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRmlsbCB0aGUgYm91bmQgYnVmZmVyIHdpdGggZGF0YSBhbW91bnQuIFVzZWQgYXQgYnVmZmVyIGluaXRpYWxpemF0aW9uICovXHJcbiAgICBwdWJsaWMgc2V0RGF0YShfYXJyYXk6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KF9hcnJheSksIHRoaXMuZ2wuRFlOQU1JQ19EUkFXKTtcclxuICAgICAgdGhpcy5jb3VudCA9IF9hcnJheS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBhY3R1YWwgRHJhd0NhbGwgZm9yIHBoeXNpY3NEZWJ1Z0RyYXcgQnVmZmVycy4gVGhpcyBpcyB3aGVyZSB0aGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgZGVidWcgaXMgYWN0dWFsbHkgZHJhd24uICovXHJcbiAgICBwdWJsaWMgZHJhdyhfbW9kZTogbnVtYmVyID0gdGhpcy5nbC5UUklBTkdMRVMsIF9jb3VudDogbnVtYmVyID0gLTEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5kcmF3RWxlbWVudHMoX21vZGUsIF9jb3VudCA+PSAwID8gX2NvdW50IDogdGhpcy5jb3VudCwgdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIG1hbmFnaW5nIGRhdGEgYWJvdXQgd2ViR0wgQXR0cmlidXRlcyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUge1xyXG4gICAgcHVibGljIGZsb2F0MzJDb3VudDogbnVtYmVyO1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2Zsb2F0MzJDb3VudDogbnVtYmVyLCBfbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmZsb2F0MzJDb3VudCA9IF9mbG9hdDMyQ291bnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIFNoYWRlcnMgdXNlZCBvbmx5IGJ5IHRoZSBwaHlzaWNzIGRlYnVnRHJhdyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdTaGFkZXIge1xyXG4gICAgcHVibGljIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgcHVibGljIHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcclxuICAgIHB1YmxpYyB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG4gICAgcHVibGljIGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlcjtcclxuICAgIHB1YmxpYyB1bmlmb3JtTG9jYXRpb25NYXA6IE1hcDxzdHJpbmcsIFdlYkdMVW5pZm9ybUxvY2F0aW9uPjtcclxuXHJcbiAgICAvKiogSW50cm9kdWNlIHRoZSBGVURHRSBSZW5kZXJpbmcgQ29udGV4dCB0byB0aGlzIGNsYXNzLCBjcmVhdGluZyBhIHByb2dyYW0gYW5kIHZlcnRleC9mcmFnbWVudCBzaGFkZXIgaW4gdGhpcyBjb250ZXh0ICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JlbmRlcmluZ0NvbnRleHQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5nbCA9IF9yZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICB0aGlzLnByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUYWtlIGdsc2wgc2hhZGVycyBhcyBzdHJpbmdzIGFuZCBjb21waWxlIHRoZW0sIGF0dGFjaGluZyB0aGUgY29tcGlsZWQgc2hhZGVycyB0byBhIHByb2dyYW0gdGhhdHMgdXNlZCBieSB0aGlzIHJlbmRlcmluZyBjb250ZXh0LiAqL1xyXG4gICAgcHVibGljIGNvbXBpbGUoX3ZlcnRleFNvdXJjZTogc3RyaW5nLCBfZnJhZ21lbnRTb3VyY2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBXZWJHTFVuaWZvcm1Mb2NhdGlvbj4oKTtcclxuICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyLCBfdmVydGV4U291cmNlKTtcclxuICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIsIF9mcmFnbWVudFNvdXJjZSk7XHJcbiAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSwgdGhpcy52ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpIHsgIC8vbWFrZSBzdXJlIHRoZSBsaW5raW5nIHdvcmtlZCwgc28gdGhlIHByb2dyYW0gaXMgdmFsaWQsIGFuZCBzaGFkZXJzIGFyZSB3b3JraW5nXHJcbiAgICAgICAgRGVidWcubG9nKHRoaXMuZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5wcm9ncmFtKSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5nbC52YWxpZGF0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgaWYgKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCB0aGlzLmdsLlZBTElEQVRFX1NUQVRVUykpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1IgdmFsaWRhdGluZyBwcm9ncmFtIVwiLCB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMucHJvZ3JhbSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgaW5kZXggb2YgYSBhdHRyaWJ1dGUgaW4gYSBzaGFkZXIgaW4gdGhpcyBwcm9ncmFtICovXHJcbiAgICBwdWJsaWMgZ2V0QXR0cmliSW5kZXgoX25hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgX25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGxvY2F0aW9uIG9mIGEgdW5pZm9ybSBpbiBhIHNoYWRlciBpbiB0aGlzIHByb2dyYW0gKi9cclxuICAgIHB1YmxpYyBnZXRVbmlmb3JtTG9jYXRpb24oX25hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcclxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxvY2F0aW9uTWFwLmhhcyhfbmFtZSkpIHJldHVybiB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcC5nZXQoX25hbWUpO1xyXG4gICAgICBsZXQgbG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBfbmFtZSk7XHJcbiAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9uTWFwLnNldChfbmFtZSwgbG9jYXRpb24pO1xyXG4gICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCBhbGwgaW5kaWNlcyBmb3IgZXZlcnkgYXR0cmlidXRlIGluIHRoZSBzaGFkZXJzIG9mIHRoaXMgcHJvZ3JhbSAqL1xyXG4gICAgcHVibGljIGdldEF0dHJpYkluZGljZXMoX2F0dHJpYnM6IEFycmF5PFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZT4pOiBBcnJheTxudW1iZXI+IHtcclxuICAgICAgbGV0IGluZGljZXM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICAgICAgX2F0dHJpYnMuZm9yRWFjaChfdmFsdWUgPT4ge1xyXG4gICAgICAgIGluZGljZXMucHVzaCh0aGlzLmdldEF0dHJpYkluZGV4KF92YWx1ZS5uYW1lKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGVsbCB0aGUgRlVER0UgUmVuZGVyaW5nIENvbnRleHQgdG8gdXNlIHRoaXMgcHJvZ3JhbSB0byBkcmF3LiAqL1xyXG4gICAgcHVibGljIHVzZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENvbXBpbGUgYSBzaGFkZXIgb3V0IG9mIGEgc3RyaW5nIGFuZCB2YWxpZGF0ZSBpdC4gKi9cclxuICAgIHB1YmxpYyBjb21waWxlU2hhZGVyKF9zaGFkZXI6IFdlYkdMU2hhZGVyLCBfc291cmNlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UoX3NoYWRlciwgX3NvdXJjZSk7XHJcbiAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihfc2hhZGVyKTtcclxuICAgICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihfc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgIERlYnVnLmxvZyh0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coX3NoYWRlcikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgQ2xhc3MgdXNlZCB0byBkcmF3IGRlYnVnSW5mb3JtYXRpb25zIGFib3V0IHRoZSBwaHlzaWNzIHNpbXVsYXRpb24gb250byB0aGUgcmVuZGVyQ29udGV4dC4gTm8gdXNlciBpbnRlcmFjdGlvbiBuZWVkZWQuIFxyXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjAgLy9CYXNlZCBvbiBPaW1vUGh5c2ljcyBIYXhlIERlYnVnRHJhd0RlbW8gXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NEZWJ1Z0RyYXcgZXh0ZW5kcyBSZW5kZXJXZWJHTCB7XHJcbiAgICBwdWJsaWMgb2ltb0RlYnVnRHJhdzogT0lNTy5EZWJ1Z0RyYXc7IC8vdGhlIG9yaWdpbmFsIHBoeXNpY3MgZW5naW5lIGRlYnVnRHJhdyBjbGFzcyByZWNlaXZpbmcgY2FsbHMgZnJvbSB0aGUgb2ltb1BoeXNpY3MuV29ybGQsIGFuZCBwcm92aWRpbmcgaW5mb3JtYXRpb25zIGluIGZvcm0gb2YgcG9pbnRzL2xpbmVzL3RyaWFuZ2xlcyB3aGF0IHRoZSBwaHlzaWNzIHdvcmxkIGxvb2tzIGxpa2VcclxuICAgIHB1YmxpYyBzdHlsZTogT0lNTy5EZWJ1Z0RyYXdTdHlsZTsgLy9jb2xvcnMgb2YgdGhlIGRlYnVnIGluZm9ybWF0aW9ucywgdW5jaGFuZ2VkIGluIEZVREdFIGludGVncmF0aW9uLCBiYXNpY2FsbHkgY29sb3JpbmcgdGhpbmdzIGxpa2Ugc2xlZXBpbmcvYWN0aXZlIHJiJ3MgZGlmZmVyZW50bHksIGpvaW50cyB3aGl0ZSBhbmQgc3VjaC4gTm8gbmVlZCB0byBoYXZlIHVzZXJzIGNoYW5nZSBhbnl0aGluZy5cclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuXHJcbiAgICBwdWJsaWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtOyAvL3Byb2dyYW0gdGhhdCBpcyB1c2VkIGluIHRoZSBGVURHRSByZW5kZXJpbmcgY29udGV4dCBjb250YWluaW5nIHNoYWRlcnMgYW5kIHVzZSBpbmZvcm1hdGlvbnMgZm9yIHRoZSBjb250ZXh0IHRvIGtub3cgaG93IHRvIGRyYXdcclxuICAgIHB1YmxpYyBzaGFkZXI6IFBoeXNpY3NEZWJ1Z1NoYWRlcjtcclxuXHJcbiAgICAvL0J1ZmZlcnMgZm9yIHBvaW50cy9saW5lcy90cmlhbmdsZXMuIEluZGV4IEJ1ZmZlciBmb3IgdGhlIGFtb3VudCBvZiBkcmF3Q2FsbHMgYW5kIFZlcnRleCBCdWZmZXIgZm9yIHRoZSBpbmZvcm1hdGlvbnNcclxuICAgIHB1YmxpYyBwb2ludFZCTzogUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyO1xyXG4gICAgcHVibGljIHBvaW50SUJPOiBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgbGluZVZCTzogUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyO1xyXG4gICAgcHVibGljIGxpbmVJQk86IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyB0cmlWQk86IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcjtcclxuICAgIHB1YmxpYyB0cmlJQk86IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyBwb2ludERhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgcG9pbnRJYm9EYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIG51bVBvaW50RGF0YTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBsaW5lRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBsaW5lSWJvRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBudW1MaW5lRGF0YTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyB0cmlEYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIHRyaUlib0RhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgbnVtVHJpRGF0YTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBDcmVhdGluZyB0aGUgZGVidWcgZm9yIHBoeXNpY3MgaW4gRlVER0UuIFRlbGwgaXQgdG8gZHJhdyBvbmx5IHdpcmVmcmFtZSBvYmplY3RzLCBzaW5jZSBGVURHRSBpcyBoYW5kbGluZyByZW5kZXJpbmcgb2YgdGhlIG9iamVjdHMgYmVzaWRlcyBwaHlzaWNzLiBcclxuICAgICAqIE92ZXJyaWRlIE9pbW9QaHlzaWNzIEZ1bmN0aW9ucyB3aXRoIG93biByZW5kZXJpbmcuIEluaXRpYWxpemUgYnVmZmVycyBhbmQgY29ubmVjdCB0aGVtIHdpdGggdGhlIGNvbnRleHQgZm9yIGxhdGVyIHVzZS4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIHRoaXMuc3R5bGUgPSBuZXcgT0lNTy5EZWJ1Z0RyYXdTdHlsZSgpO1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcgPSBuZXcgT0lNTy5EZWJ1Z0RyYXcoKTtcclxuICAgICAgdGhpcy5vaW1vRGVidWdEcmF3LndpcmVmcmFtZSA9IHRydWU7IC8vVHJpYW5nbGUgUmVuZGVyaW5nIGlzIGhhbmRsZWQgYnkgRlVER0Ugc28sIG9ubHkgdGhlIHBoeXNpY3MgbGluZXMvcG9pbnRzIG5lZWQgdG8gYmUgcmVuZGVyZWQsIGFsdGhvdWdoIHRyaWFuZ2xlIGlzIHN0aWxsIGltcGxlbWVudGVkXHJcblxyXG4gICAgICB0aGlzLmdsID0gUmVuZGVyV2ViR0wuY3JjMztcclxuICAgICAgdGhpcy5pbml0aWFsaXplT3ZlcnJpZGUoKTtcclxuICAgICAgdGhpcy5zaGFkZXIgPSBuZXcgUGh5c2ljc0RlYnVnU2hhZGVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnNoYWRlci5jb21waWxlKHRoaXMudmVydGV4U2hhZGVyU291cmNlKCksIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UoKSk7XHJcblxyXG4gICAgICB0aGlzLmluaXRpYWxpemVCdWZmZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlY2VpdmUgdGhlIGN1cnJlbnQgRGVidWdNb2RlIGZyb20gdGhlIHBoeXNpY3Mgc2V0dGluZ3MgYW5kIHNldCB0aGUgT2ltb1BoeXNpY3MuRGVidWdEcmF3IGJvb2xlYW5zIHRvIHNob3cgb25seSBjZXJ0YWluIGluZm9ybWF0aW9ucy5cclxuICAgICAqIE5lZWRlZCBzaW5jZSBzb21lIGRlYnVnIGluZm9ybWF0aW9ucyBleGNsdWRlIG90aGVycywgYW5kIGNhbid0IGJlIGRyYXduIGF0IHRoZSBzYW1lIHRpbWUsIGJ5IE9pbW9QaHlzaWNzLiBBbmQgZm9yIHVzZXJzIGl0IHByb3ZpZGVzIG1vcmUgcmVhZGFiaWxpdHlcclxuICAgICAqIHRvIGRlYnVnIG9ubHkgd2hhdCB0aGV5IG5lZWQgYW5kIGlzIGNvbW1vbmx5IGRlYnVnZ2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RGVidWdNb2RlKF9tb2RlOiBQSFlTSUNTX0RFQlVHTU9ERSA9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkUpOiB2b2lkIHtcclxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgIGxldCBkcmF3ID0geyBkcmF3QWFiYnM6IGZhbHNlLCBkcmF3QmFzZXM6IGZhbHNlLCBkcmF3QnZoOiBmYWxzZSwgZHJhd0NvbnRhY3RCYXNlczogZmFsc2UsIGRyYXdDb250YWN0czogZmFsc2UsIGRyYXdKb2ludExpbWl0czogZmFsc2UsIGRyYXdKb2ludHM6IGZhbHNlLCBkcmF3UGFpcnM6IGZhbHNlLCBkcmF3U2hhcGVzOiBmYWxzZSB9O1xyXG5cclxuICAgICAgc3dpdGNoIChfbW9kZSkge1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuQ09MTElERVJTOiAvL0NvbGxpZGVycyBhbmQgQmFzZXNcclxuICAgICAgICAgIGRyYXcuZHJhd0Jhc2VzID0gZHJhdy5kcmF3U2hhcGVzID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuSk9JTlRTX0FORF9DT0xMSURFUjogLy9Db2xsaWRlcnMgYW5kIGpvaW50c1xyXG4gICAgICAgICAgZHJhdy5kcmF3Sm9pbnRzID0gZHJhdy5kcmF3Sm9pbnRMaW1pdHMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5QSFlTSUNfT0JKRUNUU19PTkxZOiAvL1BoeXNpY3MgT2JqZWN0cyBvbmx5LCBzaG93cyBzYW1lIGFzIENvbGxpZGVyIC8gSm9pbnRzIGJ1dCBhbHNvIGhpZGluZyBldmVyeSBvdGhlciBmdWRnZSBvYmplY3RcclxuICAgICAgICAgIGRyYXcuZHJhd0Jhc2VzID0gZHJhdy5kcmF3Sm9pbnRMaW1pdHMgPSBkcmF3LmRyYXdKb2ludHMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5DT05UQUNUUzogLy9Db250YWN0c1xyXG4gICAgICAgICAgZHJhdy5kcmF3QmFzZXMgPSBkcmF3LmRyYXdDb250YWN0QmFzZXMgPSBkcmF3LmRyYXdDb250YWN0cyA9IGRyYXcuZHJhd1BhaXJzID0gZHJhdy5kcmF3U2hhcGVzID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuQk9VTkRJTkdfQk9YRVM6IC8vQm91bmRpbmcgQm94IC8gQnJvYWRwaGFzZSBCdmggLyBCYXNlc1xyXG4gICAgICAgICAgZHJhdy5kcmF3QWFiYnMgPSBkcmF3LmRyYXdCYXNlcyA9IGRyYXcuZHJhd0J2aCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub2ltb0RlYnVnRHJhdywgZHJhdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIHRoZSBlbXB0eSByZW5kZXIgYnVmZmVycy4gRGVmaW5pbmcgdGhlIGF0dHJpYnV0ZXMgdXNlZCBpbiBzaGFkZXJzLlxyXG4gICAgICogTmVlZHMgdG8gY3JlYXRlIGVtcHR5IGJ1ZmZlcnMgdG8gYWxyZWFkeSBoYXZlIHRoZW0gcmVhZHkgdG8gZHJhdyBsYXRlciBvbiwgbGlua2luZyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggZXhpc3RpbmcgYnVmZmVycy4gKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplQnVmZmVycygpOiB2b2lkIHtcclxuICAgICAgbGV0IGF0dHJpYnM6IEFycmF5PFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZT4gPSBbXHJcbiAgICAgICAgbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZSgzLCBcImFQb3NpdGlvblwiKSxcclxuICAgICAgICBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlKDMsIFwiYU5vcm1hbFwiKSxcclxuICAgICAgICBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlKDMsIFwiYUNvbG9yXCIpXHJcbiAgICAgIF07XHJcblxyXG4gICAgICB0aGlzLnBvaW50VkJPID0gbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5wb2ludElCTyA9IG5ldyBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5wb2ludFZCTy5zZXRBdHRyaWJzKGF0dHJpYnMpO1xyXG4gICAgICB0aGlzLnBvaW50VkJPLmxvYWRBdHRyaWJJbmRpY2VzKHRoaXMuc2hhZGVyKTtcclxuICAgICAgdGhpcy5saW5lVkJPID0gbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5saW5lSUJPID0gbmV3IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLmxpbmVWQk8uc2V0QXR0cmlicyhhdHRyaWJzKTtcclxuICAgICAgdGhpcy5saW5lVkJPLmxvYWRBdHRyaWJJbmRpY2VzKHRoaXMuc2hhZGVyKTtcclxuICAgICAgdGhpcy50cmlWQk8gPSBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnRyaUlCTyA9IG5ldyBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy50cmlWQk8uc2V0QXR0cmlicyhhdHRyaWJzKTtcclxuICAgICAgdGhpcy50cmlWQk8ubG9hZEF0dHJpYkluZGljZXModGhpcy5zaGFkZXIpO1xyXG5cclxuICAgICAgdGhpcy5jbGVhckJ1ZmZlcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQmVmb3JlIE9pbW9QaHlzaWNzLndvcmxkIGlzIGZpbGxpbmcgdGhlIGRlYnVnLiBNYWtlIHN1cmUgdGhlIGJ1ZmZlcnMgYXJlIHJlc2V0LiBBbHNvIHJlY2VpdmluZyB0aGUgZGVidWdNb2RlIGZyb20gc2V0dGluZ3MgYW5kIHVwZGF0aW5nIHRoZSBjdXJyZW50IHByb2plY3Rpb24gZm9yIHRoZSB2ZXJ0ZXhTaGFkZXIuICovXHJcbiAgICBwdWJsaWMgY2xlYXJCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmdsLmxpbmVXaWR0aCgyLjApOyAvL0RvZXMgbm90IGFmZmVjdCBhbnl0aGluZyBiZWNhdXNlIGxpbmVXaWR0aCBpcyBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgTWljcm9zb2Z0IEVkZ2UgYW5kIEZVREdFIGlzIG9wdGltaXplZCBmb3IgQ2hyb21lXHJcblxyXG4gICAgICB0aGlzLnBvaW50RGF0YSA9IFtdOyAvL1Jlc2V0dGluZyB0aGUgZGF0YSB0byBiZSBmaWxsZWQgYWdhaW5cclxuICAgICAgdGhpcy5saW5lRGF0YSA9IFtdO1xyXG4gICAgICB0aGlzLnRyaURhdGEgPSBbXTtcclxuXHJcbiAgICAgIHRoaXMubnVtUG9pbnREYXRhID0gMDsgLy9SZXNldHRpbmcgdGhlIGFtb3VudCBvZiBkYXRhIGNhbGxzXHJcbiAgICAgIHRoaXMubnVtTGluZURhdGEgPSAwO1xyXG4gICAgICB0aGlzLm51bVRyaURhdGEgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBZnRlciBPaW1vUGh5c2ljcy53b3JsZCBmaWxsZWQgdGhlIGRlYnVnLiBSZW5kZXJpbmcgY2FsbHMuIFNldHRpbmcgdGhpcyBwcm9ncmFtIHRvIGJlIHVzZWQgYnkgdGhlIEZVREdFIHJlbmRlcmluZyBjb250ZXh0LiBBbmQgZHJhdyBlYWNoIHVwZGF0ZWQgYnVmZmVyIGFuZCByZXNldHRpbmcgdGhlbS4gKi9cclxuICAgIHB1YmxpYyBkcmF3QnVmZmVycygpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaGFkZXIudXNlKCk7XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uOiBGbG9hdDMyQXJyYXkgPSBQaHlzaWNzLm1haW5DYW0ubXR4V29ybGRUb1ZpZXcuZ2V0KCk7XHJcbiAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oXCJ1X210eE1lc2hUb1ZpZXdcIiksIGZhbHNlLCBwcm9qZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICBpZiAodGhpcy5udW1Qb2ludERhdGEgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludElib0RhdGEgPSBbXTsgIC8vQnVmZmVyIHNpemUgbWF0Y2hpbmcgdG8gd2hhdHMgbmVlZGVkXHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubnVtUG9pbnREYXRhOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMucG9pbnRJYm9EYXRhLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9pbnRJQk8uc2V0RGF0YSh0aGlzLnBvaW50SWJvRGF0YSk7IC8vU2V0IEluZGV4IGJ1ZmZlciB0byBjb3JyZWN0IHNpemVcclxuICAgICAgICB0aGlzLnBvaW50VkJPLnNldERhdGEodGhpcy5wb2ludERhdGEpOyAvL1NldCBWZXJ0ZXggQnVmZmVyIHRvIGN1cnJlbnQgRGF0YVxyXG4gICAgICAgIHRoaXMucG9pbnRWQk8uYmluZEF0dHJpYnMoKTtcclxuICAgICAgICB0aGlzLnBvaW50SUJPLmRyYXcodGhpcy5nbC5QT0lOVFMsIHRoaXMubnVtUG9pbnREYXRhKTsgLy9UaGUgYWN0dWFsIGRyYXcgY2FsbCBmb3IgZWFjaCBpbmRleCBpbiBpYm9cclxuICAgICAgICB0aGlzLm51bVBvaW50RGF0YSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubnVtTGluZURhdGEgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5saW5lSWJvRGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm51bUxpbmVEYXRhOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMubGluZUlib0RhdGEucHVzaChpICogMik7XHJcbiAgICAgICAgICB0aGlzLmxpbmVJYm9EYXRhLnB1c2goaSAqIDIgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saW5lSUJPLnNldERhdGEodGhpcy5saW5lSWJvRGF0YSk7XHJcbiAgICAgICAgdGhpcy5saW5lVkJPLnNldERhdGEodGhpcy5saW5lRGF0YSk7XHJcbiAgICAgICAgdGhpcy5saW5lVkJPLmJpbmRBdHRyaWJzKCk7XHJcbiAgICAgICAgdGhpcy5saW5lSUJPLmRyYXcodGhpcy5nbC5MSU5FUywgdGhpcy5udW1MaW5lRGF0YSAqIDIpO1xyXG4gICAgICAgIHRoaXMubnVtTGluZURhdGEgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm51bVRyaURhdGEgPiAwKSB7XHJcbiAgICAgICAgdGhpcy50cmlJYm9EYXRhID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubnVtVHJpRGF0YTsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnRyaUlib0RhdGEucHVzaChpICogMyk7XHJcbiAgICAgICAgICB0aGlzLnRyaUlib0RhdGEucHVzaChpICogMyArIDEpO1xyXG4gICAgICAgICAgdGhpcy50cmlJYm9EYXRhLnB1c2goaSAqIDMgKyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlJQk8uc2V0RGF0YSh0aGlzLnRyaUlib0RhdGEpO1xyXG4gICAgICAgIHRoaXMudHJpVkJPLnNldERhdGEodGhpcy50cmlEYXRhKTtcclxuICAgICAgICB0aGlzLnRyaVZCTy5iaW5kQXR0cmlicygpO1xyXG4gICAgICAgIHRoaXMudHJpSUJPLmRyYXcodGhpcy5nbC5UUklBTkdMRVMsIHRoaXMubnVtVHJpRGF0YSAqIDMpO1xyXG4gICAgICAgIHRoaXMubnVtVHJpRGF0YSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogRHJhd2luZyB0aGUgcmF5IGludG8gdGhlIGRlYnVnRHJhdyBDYWxsLiBCeSB1c2luZyB0aGUgb3ZlcndyaXR0ZW4gbGluZSByZW5kZXJpbmcgZnVuY3Rpb25zIGFuZCBkcmF3aW5nIGEgcG9pbnQgKHBvaW50U2l6ZSBkZWZpbmVkIGluIHRoZSBzaGFkZXIpIGF0IHRoZSBlbmQgb2YgdGhlIHJheS4gKi9cclxuICAgIHB1YmxpYyBkZWJ1Z1JheShfb3JpZ2luOiBWZWN0b3IzLCBfZW5kOiBWZWN0b3IzLCBfY29sb3I6IENvbG9yKTogdm9pZCB7XHJcbiAgICAgIHRoaXMub2ltb0RlYnVnRHJhdy5saW5lKG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueiksIG5ldyBPSU1PLlZlYzMoX2VuZC54LCBfZW5kLnksIF9lbmQueiksIG5ldyBPSU1PLlZlYzMoX2NvbG9yLnIsIF9jb2xvci5nLCBfY29sb3IuYikpO1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcucG9pbnQobmV3IE9JTU8uVmVjMyhfZW5kLngsIF9lbmQueSwgX2VuZC56KSwgbmV3IE9JTU8uVmVjMyhfY29sb3IuciwgX2NvbG9yLmcsIF9jb2xvci5iKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIE92ZXJyaWRpbmcgdGhlIGV4aXN0aW5nIGZ1bmN0aW9ucyBmcm9tIE9pbW9QaHlzaWNzLkRlYnVnRHJhdyB3aXRob3V0IGFjdHVhbGx5IGluaGVyaXQgZnJvbSB0aGUgY2xhc3MsIHRvIGF2b2lkIGNvbXBpbGVyIHByb2JsZW1zLiBcclxuICAgICAqIE92ZXJyaWRpbmcgdGhlbSB0byByZWNlaXZlIGRlYnVnSW5mb3JtYXRpb25zIGluIHRoZSBmb3JtYXQgdGhlIHBoeXNpYyBlbmdpbmUgcHJvdmlkZXMgdGhlbSBidXQgaGFuZGxpbmcgdGhlIHJlbmRlcmluZyBpbiB0aGUgZnVkZ2UgY29udGV4dC4gKi9cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZU92ZXJyaWRlKCk6IHZvaWQge1xyXG4gICAgICAvL092ZXJyaWRlIHBvaW50L2xpbmUvdHJpYW5nbGUgZnVuY3Rpb25zIG9mIE9pbW9QaHlzaWNzIHdoaWNoIGFyZSB1c2VkIHRvIGRyYXcgd2lyZWZyYW1lcyBvZiBvYmplY3RzLCBsaW5lcyBvZiByYXljYXN0cyBvciB0cmlhbmdsZXMgd2hlbiB0aGUgb2JqZWN0cyBhcmUgcmVuZGVyZWQgYnkgdGhlIHBoeXNpY3Mgbm90IEZVREdFICh1bnVzZWQpXHJcblxyXG4gICAgICBPSU1PLkRlYnVnRHJhdy5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiAoX3Y6IE9JTU8uVmVjMywgX2NvbG9yOiBPSU1PLlZlYzMpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZGVidWdXcmFwcGVyOiBQaHlzaWNzRGVidWdEcmF3ID0gUGh5c2ljcy5kZWJ1Z0RyYXc7IC8vR2V0IHRoZSBjdXN0b20gcGh5c2ljcyBkZWJ1ZyBjbGFzcyB0byBoYXZlIGFjY2VzcyB0byB0aGUgZGF0YS5cclxuICAgICAgICBpZiAoUGh5c2ljcy5tYWluQ2FtICE9IG51bGwpIHsgLy9vbmx5IGFjdCB3aGVuIHRoZXJlIGlzIGEgY2FtZXJhIHRoYXQgaXMgcmVuZGVyaW5nXHJcbiAgICAgICAgICBsZXQgZGF0YTogQXJyYXk8TnVtYmVyPiA9IGRlYnVnV3JhcHBlci5wb2ludERhdGE7IC8vZ2V0IHRoZSBhbHJlYWR5IHdyaXR0ZW4gYnVmZmVyIGluZm9ybWF0aW9uc1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92LngsIF92LnksIF92LnopOyAvL0Nvb3JkaW5hdGVzIG9mIHRoZSBwb2ludFxyXG4gICAgICAgICAgZGF0YS5wdXNoKDAsIDAsIDApOyAvL1BvaW50IE5vcm1hbHMgLSBFbXB0eSBzaW5jZSBpdCdzIG5vdCBhIHBvbHlnb25cclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTsgLy9Db2xvciBvZiB0aGUgcG9pbnRcclxuICAgICAgICAgIGRlYnVnV3JhcHBlci5udW1Qb2ludERhdGErKztcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBPSU1PLkRlYnVnRHJhdy5wcm90b3R5cGUubGluZSA9IGZ1bmN0aW9uIChfdjE6IE9JTU8uVmVjMywgX3YyOiBPSU1PLlZlYzMsIF9jb2xvcjogT0lNTy5WZWMzKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGRlYnVnV3JhcHBlcjogUGh5c2ljc0RlYnVnRHJhdyA9IFBoeXNpY3MuZGVidWdEcmF3O1xyXG4gICAgICAgIGlmIChQaHlzaWNzLm1haW5DYW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgbGV0IGRhdGE6IEFycmF5PG51bWJlcj4gPSBkZWJ1Z1dyYXBwZXIubGluZURhdGE7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YxLngsIF92MS55LCBfdjEueik7IC8vUG9pbnQgMSBDb29yZGluYXRlc1xyXG4gICAgICAgICAgZGF0YS5wdXNoKDAsIDAsIDApOyAvL1AxIE5vcm1hbHMgLSBFbXB0eSBzaW5jZSBpdCdzIG5vdCBhIHBvbHlnb25cclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTsgLy9QMSBDb2xvclxyXG4gICAgICAgICAgZGF0YS5wdXNoKF92Mi54LCBfdjIueSwgX3YyLnopOyAvL1BvaW50IDIgQ29vcmRpbmF0ZXNcclxuICAgICAgICAgIGRhdGEucHVzaCgwLCAwLCAwKTtcclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTtcclxuICAgICAgICAgIGRlYnVnV3JhcHBlci5udW1MaW5lRGF0YSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIE9JTU8uRGVidWdEcmF3LnByb3RvdHlwZS50cmlhbmdsZSA9IGZ1bmN0aW9uIChfdjE6IE9JTU8uVmVjMywgX3YyOiBPSU1PLlZlYzMsIF92MzogT0lNTy5WZWMzLCBfbjE6IE9JTU8uVmVjMywgX24yOiBPSU1PLlZlYzMsIF9uMzogT0lNTy5WZWMzLCBfY29sb3I6IE9JTU8uVmVjMyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBkZWJ1Z1dyYXBwZXI6IFBoeXNpY3NEZWJ1Z0RyYXcgPSBQaHlzaWNzLmRlYnVnRHJhdztcclxuICAgICAgICBpZiAoUGh5c2ljcy5tYWluQ2FtICE9IG51bGwpIHtcclxuICAgICAgICAgIGxldCBkYXRhOiBBcnJheTxudW1iZXI+ID0gZGVidWdXcmFwcGVyLnRyaURhdGE7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YxLngsIF92MS55LCBfdjEueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX24xLngsIF9uMS55LCBfbjEueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YyLngsIF92Mi55LCBfdjIueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX24yLngsIF9uMi55LCBfbjIueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YzLngsIF92My55LCBfdjMueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX24zLngsIF9uMy55LCBfbjMueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkZWJ1Z1dyYXBwZXIubnVtVHJpRGF0YSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNvdXJjZSBjb2RlIChzdHJpbmcpIG9mIHRoZSBpbiBwaHlzaWNzRGVidWcgdXNlZCB2ZXJ5IHNpbXBsZSB2ZXJ0ZXhTaGFkZXIuXHJcbiAgICAgKiAgSGFuZGxpbmcgdGhlIHByb2plY3Rpb24gKHdoaWNoIGluY2x1ZGVzLCB2aWV3L3dvcmxkW2lzIGFsd2F5cyBpZGVudGl0eSBpbiB0aGlzIGNhc2VdL3Byb2plY3Rpb24gaW4gRlVER0UpLiBJbmNyZWFzaW5nIHRoZSBzaXplIG9mIHNpbmdsZSBwb2ludHMgZHJhd24uXHJcbiAgICAgKiAgQW5kIHRyYW5zZmVyIHBvc2l0aW9uIGNvbG9yIHRvIHRoZSBmcmFnbWVudFNoYWRlci4gKi9cclxuICAgIHByaXZhdGUgdmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgXHJcblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjMyBhUG9zaXRpb247XHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFDb2xvcjtcclxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcblx0XHRcdHVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0dlBvc2l0aW9uID0gYVBvc2l0aW9uO1xyXG5cdFx0XHRcdHZDb2xvciA9IGFDb2xvcjtcclxuXHRcdFx0XHR2Tm9ybWFsID0gYU5vcm1hbDtcclxuXHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHVfbXR4TWVzaFRvVmlldyAqIHZlYzQoYVBvc2l0aW9uLDEuMCk7XHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gNi4wO1xyXG5cdFx0XHR9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNvdXJjZSBjb2RlIChzdHJpbmcpIG9mIHRoZSBpbiBwaHlzaWNzRGVidWcgdXNlZCBzdXBlciBzaW1wbGUgZnJhZ21lbnRTaGFkZXIuIFVubGl0IC0gb25seSBjb2xvcml6aW5nIHRoZSBkcmF3biBwaXhlbHMsIG5vcm1hbHMvcG9zaXRpb24gYXJlIGdpdmVuIHRvIG1ha2UgaXQgZXhwYW5kYWJsZSAqL1xyXG4gICAgcHJpdmF0ZSBmcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYFxyXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcblxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XHJcblx0XHRcdH1gO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCBhIGRlZmluZWQgYXhlIG9mIHRyYW5zbGF0aW9uIGFuZCByb3RhdGlvbi4gVHdvIERlZ3JlZXMgb2YgRnJlZWRvbSBpbiB0aGUgZGVmaW5lZCBheGlzLlxuICAgKiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gQSBtb3RvciBjYW4gYmUgZGVmaW5lZCBmb3Igcm90YXRpb24gYW5kIHRyYW5zbGF0aW9uLCBhbG9uZyB3aXRoIHNwcmluZyBzZXR0aW5ncy5cbiAgICogXG4gICAqIGBgYHRleHRcbiAgICogICAgICAgICAgSm9pbnRIb2xkZXIgLSBib2R5QW5jaG9yXG4gICAqICAgICAgICAgICAgICAgICAgICDilIzilIDilIDilIDilJBcbiAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxuICAgKiAgICAgICAgICAgPOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgIOKUguKUgOKUgOKUgOKUgOKUgOKUgD4gdGllZCBib2R5LCBzbGlkaW5nIG9uIGF4aXMgPSAxc3QgZGVncmVlIG9mIGZyZWVkb21cbiAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUgiAgICAgICAgcm90YXRpbmcgYXJvdW5kIGF4aXMgPSAybmQgZGVncmVlIG9mIGZyZWVkb20gXG4gICAqICAgICAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJhcbiAgICogYGBgICBcbiAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEpvaW50Q3lsaW5kcmljYWwgZXh0ZW5kcyBKb2ludEF4aWFsIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludEN5bGluZHJpY2FsKTtcblxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5DeWxpbmRyaWNhbEpvaW50O1xuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uQ3lsaW5kcmljYWxKb2ludENvbmZpZyA9IG5ldyBPSU1PLkN5bGluZHJpY2FsSm9pbnRDb25maWcoKTtcbiAgICBwcm90ZWN0ZWQgbW90b3I6IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3I7XG5cbiAgICAjc3ByaW5nRGFtcGluZ1JvdGF0aW9uOiBudW1iZXIgPSAwO1xuICAgICNzcHJpbmdGcmVxdWVuY3lSb3RhdGlvbjogbnVtYmVyID0gMDtcblxuICAgICNtb3RvckZvcmNlOiBudW1iZXIgPSAwO1xuXG4gICAgI21heFJvdG9yOiBudW1iZXIgPSAzNjA7XG4gICAgI21pblJvdG9yOiBudW1iZXIgPSAwO1xuICAgICNyb3RvclRvcnF1ZTogbnVtYmVyID0gMDtcbiAgICAjcm90b3JTcGVlZDogbnVtYmVyID0gMDtcblxuICAgICNyb3RvcjogT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcjtcbiAgICAjcm90b3JTcHJpbmdEYW1wZXI6IE9JTU8uU3ByaW5nRGFtcGVyO1xuXG4gICAgLyoqIENyZWF0aW5nIGEgY3lsaW5kcmljYWwgam9pbnQgYmV0d2VlbiB0d28gQ29tcG9uZW50UmlnaWRib2RpZXMgbW92aW5nIG9uIG9uZSBheGlzIGFuZCByb3RhdGluZyBhcm91bmQgYW5vdGhlciBib3VuZCBvbiBhIGxvY2FsIGFuY2hvcnBvaW50LiAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpczogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIEdldC9TZXQgdHJhbnNmb3Igb2YgZnVkZ2UgcHJvcGVydGllcyB0byB0aGUgcGh5c2ljcyBlbmdpbmVcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXG4gICAgICovXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBzdXBlci5zcHJpbmdEYW1waW5nID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsU3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cbiAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5KF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBzdXBlci5zcHJpbmdGcmVxdWVuY3kgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLiBJbmZsdWVuY2luZyBUT1JRVUUgLyBST1RBVElPTlxuICAgICovXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nUm90YXRpb24oKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nUm90YXRpb247XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRGFtcGluZ1JvdGF0aW9uKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nUm90YXRpb24gPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIEluZmx1ZW5jaW5nIFRPUlFVRSAvIFJPVEFUSU9OXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5Um90YXRpb247XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5Um90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsU3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzLUFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heFJvdG9yKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jbWF4Um90b3I7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgbWF4Um90b3IoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI21heFJvdG9yID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWUgKiBDYWxjLmRlZzJyYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5Sb3RvcigpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21pblJvdG9yO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1pblJvdG9yKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNtaW5Sb3RvciA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogVGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBtb3RvciBpbiBtL3MuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcm90b3JTcGVlZCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yU3BlZWQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgcm90b3JTcGVlZChfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jcm90b3JTcGVlZCA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcm90b3JUb3JxdWUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclRvcnF1ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCByb3RvclRvcnF1ZShfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jcm90b3JUb3JxdWUgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxMaW1pdE1vdG9yKCkubW90b3JUb3JxdWUgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IG1heE1vdG9yKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBzdXBlci5tYXhNb3RvciA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0VHJhbnNsYXRpb25hbExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgbWluTW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHN1cGVyLm1pbk1vdG9yID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcbiAgICAgICAgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBtb3RvclNwZWVkKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICBzdXBlci5tb3RvclNwZWVkID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcbiAgICAgICAgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciBmb3JjZSBpbiBOZXd0b24uIGZvcmNlIDw9IDAgZXF1YWxzIGRpc2FibGVkLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvckZvcmNlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI21vdG9yRm9yY2UgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubW90b3JGb3JjZSA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG5cblxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xuICAgICAgdGhpcy4jcm90b3JTcHJpbmdEYW1wZXIgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3lSb3RhdGlvbiwgdGhpcy5zcHJpbmdEYW1waW5nUm90YXRpb24pO1xuXG4gICAgICB0aGlzLm1vdG9yID0gbmV3IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHMoc3VwZXIubWluTW90b3IsIHN1cGVyLm1heE1vdG9yKTtcbiAgICAgIHRoaXMubW90b3Iuc2V0TW90b3Ioc3VwZXIubW90b3JTcGVlZCwgdGhpcy5tb3RvckZvcmNlKTtcbiAgICAgIHRoaXMuI3JvdG9yID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Sb3RvciAqIENhbGMuZGVnMnJhZCwgdGhpcy5tYXhSb3RvciAqIENhbGMuZGVnMnJhZCk7XG4gICAgICB0aGlzLiNyb3Rvci5zZXRNb3Rvcih0aGlzLnJvdG9yU3BlZWQsIHRoaXMucm90b3JUb3JxdWUpO1xuXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLkN5bGluZHJpY2FsSm9pbnRDb25maWcoKTtcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XG5cbiAgICAgIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uYWxTcHJpbmdEYW1wZXIgPSB0aGlzLnNwcmluZ0RhbXBlcjtcbiAgICAgIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yID0gdGhpcy5tb3RvcjtcbiAgICAgIHRoaXMuY29uZmlnLnJvdGF0aW9uYWxMaW1pdE1vdG9yID0gdGhpcy4jcm90b3I7XG4gICAgICB0aGlzLmNvbmZpZy5yb3RhdGlvbmFsU3ByaW5nRGFtcGVyID0gdGhpcy4jcm90b3JTcHJpbmdEYW1wZXI7XG5cbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5DeWxpbmRyaWNhbEpvaW50KHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuY29uZmlndXJlSm9pbnQoKTtcbiAgICB9XG5cbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xuICAgICAgICBtb3RvckZvcmNlOiB0aGlzLm1vdG9yRm9yY2UsXG4gICAgICAgIHNwcmluZ0RhbXBpbmdSb3RhdGlvbjogdGhpcy5zcHJpbmdEYW1waW5nUm90YXRpb24sXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uOiB0aGlzLnNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uLFxuICAgICAgICBtYXhSb3RvcjogdGhpcy5tYXhSb3RvcixcbiAgICAgICAgbWluUm90b3I6IHRoaXMubWluUm90b3IsXG4gICAgICAgIHJvdG9yVG9ycXVlOiB0aGlzLnJvdG9yVG9ycXVlLFxuICAgICAgICByb3RvclNwZWVkOiB0aGlzLnJvdG9yU3BlZWRcbiAgICAgIH07XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9O1xuXG4gICAgI211dGF0ZSA9IChfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJtb3RvckZvcmNlXCIsIFwicm90b3JUb3JxdWVcIiwgXCJyb3RvclNwZWVkXCIsIFwibWF4Um90b3JcIiwgXCJtaW5Sb3RvclwiLCBcInNwcmluZ0RhbXBpbmdSb3RhdGlvblwiLCBcInNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uXCIsIFwic3ByaW5nRnJlcXVlbmN5XCJdKTtcbiAgICB9O1xuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCBhIGRlZmluZWQgYXhlIG1vdmVtZW50LlxuICAgICAqIFVzZWQgdG8gY3JlYXRlIGEgc2xpZGluZyBqb2ludCBhbG9uZyBvbmUgYXhpcy4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuXG4gICAgICogQSBtb3RvciBjYW4gYmUgZGVmaW5lZCB0byBtb3ZlIHRoZSBjb25uZWN0ZWQgYWxvbmcgdGhlIGRlZmluZWQgYXhpcy4gR3JlYXQgdG8gY29uc3RydWN0IHN0YW5kYXJkIHNwcmluZ3Mgb3IgcGh5c2ljYWwgc2xpZGVycy5cbiAgICAgKiBcbiAgICAgKiBgYGB0ZXh0XG4gICAgICogICAgICAgICAgSm9pbnRIb2xkZXIgLSBib2R5QW5jaG9yXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxuICAgICAqICAgICAgICAgICAgICAgICAgICDilIIgICDilIJcbiAgICAgKiAgICAgICAgICAgPOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgIOKUguKUgOKUgOKUgOKUgOKUgOKUgD4gdGllZCBib2R5LCBzbGlkaW5nIG9uIG9uZSBBeGlzLCAxIERlZ3JlZSBvZiBGcmVlZG9tXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxuICAgICAqICAgICAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJhcbiAgICAgKiBgYGBcbiAgICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXG4gICAgICovXG4gIGV4cG9ydCBjbGFzcyBKb2ludFByaXNtYXRpYyBleHRlbmRzIEpvaW50QXhpYWwge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50UHJpc21hdGljKTtcblxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5QcmlzbWF0aWNKb2ludDtcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLlByaXNtYXRpY0pvaW50Q29uZmlnID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcoKTtcbiAgICBwcm90ZWN0ZWQgbW90b3I6IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3I7XG4gICAgLy9JbnRlcm5hbGx5IHVzZWQgdmFyaWFibGVzIC0gSm9pbnQgUHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGV2ZW4gd2hlbiBubyBhY3R1YWwgam9pbnQgaXMgY3VycmVudGx5IGV4aXN0ZW50XG5cbiAgICAjbW90b3JGb3JjZTogbnVtYmVyID0gMDtcblxuICAgIC8qKiBDcmVhdGluZyBhIHByaXNtYXRpYyBqb2ludCBiZXR3ZWVuIHR3byBDb21wb25lbnRSaWdpZGJvZGllcyBvbmx5IG1vdmluZyBvbiBvbmUgYXhpcyBib3VuZCBvbiBhIGxvY2FsIGFuY2hvcnBvaW50LiAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpczogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XG5cbiAgICAgIHRoaXMubWF4TW90b3IgPSAxMDtcbiAgICAgIHRoaXMubWluTW90b3IgPSAtMTA7XG4gICAgfVxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXG4gICAgLyoqXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFRoaXMgaXMgdGhlIGZvcmNlIHRoYXQgdGhlIG1vdG9yIGlzIHVzaW5nIHRvIGhvbGQgdGhlIHBvc2l0aW9uLCBvciByZWFjaCBpdCBpZiBhIG1vdG9yU3BlZWQgaXMgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvckZvcmNlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI21vdG9yRm9yY2UgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IoKS5tb3RvckZvcmNlID0gX3ZhbHVlO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIHRoaXMubW90b3JGb3JjZSA9IF9zZXJpYWxpemF0aW9uLm1vdG9yRm9yY2U7XG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xuICAgICAgbXV0YXRvci5tb3RvckZvcmNlID0gdGhpcy5tb3RvckZvcmNlO1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IubW90b3JGb3JjZSkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMubW90b3JGb3JjZSA9IF9tdXRhdG9yLm1vdG9yRm9yY2U7XG4gICAgICBkZWxldGUgX211dGF0b3IubW90b3JGb3JjZTtcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLyoqIEFjdHVhbCBjcmVhdGlvbiBvZiBhIGpvaW50IGluIHRoZSBPaW1vUGh5c2ljcyBzeXN0ZW0gKi9cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XG4gICAgICB0aGlzLm1vdG9yID0gbmV3IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Nb3RvciwgdGhpcy5tYXhNb3Rvcik7IC8vQ3JlYXRlIG1vdG9yIHNldHRpbmdzLCB0byBob2xkIHBvc2l0aW9ucywgc2V0IGNvbnN0cmFpbnQgbWluL21heFxuICAgICAgdGhpcy5tb3Rvci5zZXRNb3Rvcih0aGlzLm1vdG9yU3BlZWQsIHRoaXMubW90b3JGb3JjZSk7XG5cbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcoKTsgLy9DcmVhdGUgYSBzcGVjaWZpYyBjb25maWcgZm9yIHRoaXMgam9pbnQgdHlwZSB0aGF0IGlzIGNhbGN1bGF0aW5nIHRoZSBsb2NhbCBheGlzIGZvciBib3RoIGJvZGllc1xuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQoKTtcblxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyID0gdGhpcy5zcHJpbmdEYW1wZXI7IC8vVGVsbGluZyB0aGUgY29uZmlnIHRvIHVzZSB0aGUgbW90b3Ivc3ByaW5nIG9mIHRoZSBGVURHRSBDb21wb25lbnRcbiAgICAgIHRoaXMuY29uZmlnLmxpbWl0TW90b3IgPSB0aGlzLm1vdG9yO1xuXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnQodGhpcy5jb25maWcpO1xuICAgICAgdGhpcy5jb25maWd1cmVKb2ludCgpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMsIGRlc2lnbmVkIHRvIHNpbXVsYXRlIGJlaGF2aW91ciB3aXRoaW4gYSByZWFsIGJvZHkuIEl0IGhhcyB0d28gYXhpcywgYSBzd2luZyBhbmQgdHdpc3QgYXhpcywgYW5kIGFsc28gdGhlIHBlcnBlbmRpY3VsYXIgYXhpcywgXG4gICAgKiBzaW1pbGFyIHRvIGEgU3BoZXJpY2FsIGpvaW50LCBidXQgbW9yZSByZXN0cmljdGl2ZSBpbiBpdCdzIGFuZ2xlcyBhbmQgb25seSB0d28gZGVncmVlcyBvZiBmcmVlZG9tLiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gTW9zdGx5IHVzZWQgdG8gY3JlYXRlIGh1bWFubGlrZSBqb2ludHMgdGhhdCBiZWhhdmUgbGlrZSBhIFxuICAgICogbGlmZWxlc3MgYm9keS5cbiAgICAqIGBgYHRleHQgICAgICAgIFxuICAgICogICAgICAgICAgICAgICAgICBcbiAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciAtIGl0IGNhbiB0d2lzdCBvbiBvbmUgYXhpcyBhbmQgc3dpbmcgb24gYW5vdGhlclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4gICAgKiAgICAgICAgIHogICAgICAgICAgICDilIzilIDilIDilIDilJAg4pSCIOKUjOKUgOKUgOKUgOKUkFxuICAgICogICAgICAgICDihpEgICAgICAgICAgICDilIIgICDilIIg4oaTIOKUgiAgIOKUgiAgICAgICAgZS5nLiB6ID0gVHdpc3RBeGlzLCBpdCBjYW4gcm90YXRlIGluLWl0c2VsZiBhcm91bmQgdGhpcyBheGlzIFxuICAgICogICAgLXgg4oaQ4pSA4pS84pSA4oaSIHggICAgICAgIOKUgiAgIOKUgiB4IOKUgiAgIOKUgiAgICAgICAgZS5nLiB4ID0gU3dpbmdBeGlzLCBpdCBjYW4gcm90YXRlIGFuY2hvcmVkIGFyb3VuZCB0aGUgYmFzZSBvbiB0aGlzIGF4aXMgICBcbiAgICAqICAgICAgICAg4oaTICAgICAgICAgICAg4pSCICAg4pSCICAg4pSCICAg4pSCICAgICAgICAgICBcbiAgICAqICAgICAgICAteiAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUmCAgICAgICAgIGUuZy4geW91IGNhbiB0d2lzdCB0aGUgbGVnIGluLWl0c2VsZiB0byBhIGNlcnRhaW4gZGVncmVlLFxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dCBhbHNvIHJvdGF0ZSBpdCBmb3J3YXJkL2JhY2t3YXJkL2xlZnQvcmlnaHQgdG8gYSBjZXJ0YWluIGRlZ3JlZVxuICAgICogICAgICAgICAgICAgICAgYm9keUFuY2hvciAgICAgICAgICBib2R5VGllZFxuICAgICogICAgICAgICAgICAgIChlLmcuIHBlbHZpcykgICAgICAgICAoZS5nLiB1cHBlci1sZWcpXG4gICAgKiBcbiAgICAqIGBgYFxuICAgICogVHdpc3QgZXF1YWxzIGEgcm90YXRpb24gYXJvdW5kIGEgcG9pbnQgd2l0aG91dCBtb3Zpbmcgb24gYW4gYXhpcy5cbiAgICAqIFN3aW5nIGVxdWFscyBhIHJvdGF0aW9uIG9uIGEgcG9pbnQgd2l0aCBhIG1vdmluZyBsb2NhbCBheGlzLlxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICAqL1xuICBleHBvcnQgY2xhc3MgSm9pbnRSYWdkb2xsIGV4dGVuZHMgSm9pbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50UmFnZG9sbCk7XG5cbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uUmFnZG9sbEpvaW50O1xuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uUmFnZG9sbEpvaW50Q29uZmlnID0gbmV3IE9JTU8uUmFnZG9sbEpvaW50Q29uZmlnKCk7XG5cbiAgICAjc3ByaW5nRGFtcGluZ1R3aXN0OiBudW1iZXIgPSAwO1xuICAgICNzcHJpbmdGcmVxdWVuY3lUd2lzdDogbnVtYmVyID0gMDtcblxuICAgICNzcHJpbmdEYW1waW5nU3dpbmc6IG51bWJlciA9IDA7XG4gICAgI3NwcmluZ0ZyZXF1ZW5jeVN3aW5nOiBudW1iZXIgPSAwO1xuXG4gICAgI21heE1vdG9yVHdpc3Q6IG51bWJlciA9IDM2MDtcbiAgICAjbWluTW90b3JUd2lzdDogbnVtYmVyID0gMDtcbiAgICAjbW90b3JUb3JxdWVUd2lzdDogbnVtYmVyID0gMDtcbiAgICAjbW90b3JTcGVlZFR3aXN0OiBudW1iZXIgPSAwO1xuXG4gICAgI21vdG9yVHdpc3Q6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XG4gICAgI3NwcmluZ0RhbXBlclR3aXN0OiBPSU1PLlNwcmluZ0RhbXBlcjtcbiAgICAjc3ByaW5nRGFtcGVyU3dpbmc6IE9JTU8uU3ByaW5nRGFtcGVyO1xuICAgICNheGlzRmlyc3Q6IE9JTU8uVmVjMztcbiAgICAjYXhpc1NlY29uZDogT0lNTy5WZWMzO1xuXG4gICAgI21heEFuZ2xlRmlyc3Q6IG51bWJlciA9IDA7XG4gICAgI21heEFuZ2xlU2Vjb25kOiBudW1iZXIgPSAwO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzRmlyc3Q6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKSwgX2F4aXNTZWNvbmQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xuICAgICAgdGhpcy5heGlzRmlyc3QgPSBfYXhpc0ZpcnN0O1xuICAgICAgdGhpcy5heGlzU2Vjb25kID0gX2F4aXNTZWNvbmQ7XG4gICAgICB0aGlzLmFuY2hvciA9IF9sb2NhbEFuY2hvcjtcbiAgICB9XG5cbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxuICAgIC8qKlxuICAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cbiAgICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGF4aXNGaXJzdCgpOiBWZWN0b3IzIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzRmlyc3QueCwgdGhpcy4jYXhpc0ZpcnN0LnksIHRoaXMuI2F4aXNGaXJzdC56KTtcbiAgICB9XG4gICAgcHVibGljIHNldCBheGlzRmlyc3QoX3ZhbHVlOiBWZWN0b3IzKSB7XG4gICAgICB0aGlzLiNheGlzRmlyc3QgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXG4gICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgYXhpc1NlY29uZCgpOiBWZWN0b3IzIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzU2Vjb25kLngsIHRoaXMuI2F4aXNTZWNvbmQueSwgdGhpcy4jYXhpc1NlY29uZC56KTtcbiAgICB9XG4gICAgcHVibGljIHNldCBheGlzU2Vjb25kKF92YWx1ZTogVmVjdG9yMykge1xuICAgICAgdGhpcy4jYXhpc1NlY29uZCA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBhbmdsZSBvZiByb3RhdGlvbiBhbG9uZyB0aGUgZmlyc3QgYXhpcy4gVmFsdWUgbmVlZHMgdG8gYmUgcG9zaXRpdmUuIENoYW5nZXMgZG8gcmVidWlsZCB0aGUgam9pbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heEFuZ2xlRmlyc3RBeGlzKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jbWF4QW5nbGVGaXJzdCAqIENhbGMucmFkMmRlZztcbiAgICB9XG4gICAgcHVibGljIHNldCBtYXhBbmdsZUZpcnN0QXhpcyhfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jbWF4QW5nbGVGaXJzdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGFuZ2xlIG9mIHJvdGF0aW9uIGFsb25nIHRoZSBzZWNvbmQgYXhpcy4gVmFsdWUgbmVlZHMgdG8gYmUgcG9zaXRpdmUuIENoYW5nZXMgZG8gcmVidWlsZCB0aGUgam9pbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heEFuZ2xlU2Vjb25kQXhpcygpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21heEFuZ2xlU2Vjb25kICogQ2FsYy5yYWQyZGVnO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1heEFuZ2xlU2Vjb25kQXhpcyhfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jbWF4QW5nbGVTZWNvbmQgPSBfdmFsdWUgKiBDYWxjLmRlZzJyYWQ7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3ByaW5nRGFtcGluZ1R3aXN0KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1R3aXN0O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmdUd2lzdChfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1R3aXN0ID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVR3aXN0KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5VHdpc3Q7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5VHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVR3aXN0ID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3ByaW5nRGFtcGluZ1N3aW5nKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1N3aW5nO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmdTd2luZyhfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1N3aW5nID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTd2luZ1NwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVN3aW5nKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5U3dpbmc7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5U3dpbmcoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVN3aW5nID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTd2luZ1NwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4TW90b3JUd2lzdCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21heE1vdG9yVHdpc3QgKiBDYWxjLnJhZDJkZWc7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgbWF4TW90b3JUd2lzdChfdmFsdWU6IG51bWJlcikge1xuICAgICAgX3ZhbHVlICo9IENhbGMuZGVnMnJhZDtcbiAgICAgIHRoaXMuI21heE1vdG9yVHdpc3QgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFR3aXN0TGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWluTW90b3JUd2lzdCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21pbk1vdG9yVHdpc3QgKiBDYWxjLnJhZDJkZWc7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgbWluTW90b3JUd2lzdChfdmFsdWU6IG51bWJlcikge1xuICAgICAgX3ZhbHVlICo9IENhbGMuZGVnMnJhZDtcbiAgICAgIHRoaXMuI21pbk1vdG9yVHdpc3QgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFR3aXN0TGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgbW90b3IgaW4gbS9zLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1vdG9yU3BlZWRUd2lzdCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yU3BlZWRUd2lzdDtcbiAgICB9XG4gICAgcHVibGljIHNldCBtb3RvclNwZWVkVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI21vdG9yU3BlZWRUd2lzdCA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbW90b3JUb3JxdWVUd2lzdCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yVG9ycXVlVHdpc3Q7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgbW90b3JUb3JxdWVUd2lzdChfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jbW90b3JUb3JxdWVUd2lzdCA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RMaW1pdE1vdG9yKCkubW90b3JUb3JxdWUgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIElmIHRoZSB0d28gY29ubmVjdGVkIFJpZ2lkQm9kaWVzIGNvbGxpZGUgd2l0aCBlYXRoIG90aGVyLiAoRGVmYXVsdCA9IGZhbHNlKVxuICAgICAqL1xuXG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLiNnZXRNdXRhdG9yKCk7XG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbi5heGlzU2Vjb25kID0gdGhpcy5heGlzU2Vjb25kLnNlcmlhbGl6ZSgpO1xuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHRoaXMuYXhpc0ZpcnN0LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXNGaXJzdCk7XG4gICAgICBhd2FpdCB0aGlzLmF4aXNTZWNvbmQuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc1NlY29uZCk7XG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc0ZpcnN0KSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGhpcy5heGlzRmlyc3QgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYXhpc0ZpcnN0KSkpO1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc1NlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMuYXhpc1NlY29uZCA9IG5ldyBWZWN0b3IzKC4uLjxudW1iZXJbXT4oT2JqZWN0LnZhbHVlcyhfbXV0YXRvci5heGlzU2Vjb25kKSkpO1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLmF4aXNGaXJzdDtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICBtdXRhdG9yLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LmdldE11dGF0b3IoKTtcbiAgICAgIG11dGF0b3IuYXhpc1NlY29uZCA9IHRoaXMuYXhpc1NlY29uZC5nZXRNdXRhdG9yKCk7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXJUd2lzdCA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLnNwcmluZ0ZyZXF1ZW5jeVR3aXN0LCB0aGlzLnNwcmluZ0RhbXBpbmdUd2lzdCk7XG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXJTd2luZyA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLnNwcmluZ0ZyZXF1ZW5jeVN3aW5nLCB0aGlzLnNwcmluZ0RhbXBpbmdTd2luZyk7XG5cbiAgICAgIHRoaXMuI21vdG9yVHdpc3QgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLm1pbk1vdG9yVHdpc3QsIHRoaXMubWF4TW90b3JUd2lzdCk7XG4gICAgICB0aGlzLiNtb3RvclR3aXN0LnNldE1vdG9yKHRoaXMubW90b3JTcGVlZFR3aXN0LCB0aGlzLm1vdG9yVG9ycXVlVHdpc3QpO1xuXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlJhZ2RvbGxKb2ludENvbmZpZygpO1xuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy5heGlzRmlyc3QsIHRoaXMuYXhpc1NlY29uZCk7XG4gICAgICB0aGlzLmNvbmZpZy5zd2luZ1NwcmluZ0RhbXBlciA9IHRoaXMuI3NwcmluZ0RhbXBlclN3aW5nO1xuICAgICAgdGhpcy5jb25maWcudHdpc3RTcHJpbmdEYW1wZXIgPSB0aGlzLiNzcHJpbmdEYW1wZXJUd2lzdDtcbiAgICAgIHRoaXMuY29uZmlnLnR3aXN0TGltaXRNb3RvciA9IHRoaXMuI21vdG9yVHdpc3Q7XG4gICAgICB0aGlzLmNvbmZpZy5tYXhTd2luZ0FuZ2xlMSA9IHRoaXMuI21heEFuZ2xlRmlyc3Q7XG4gICAgICB0aGlzLmNvbmZpZy5tYXhTd2luZ0FuZ2xlMiA9IHRoaXMuI21heEFuZ2xlU2Vjb25kO1xuXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uUmFnZG9sbEpvaW50KHRoaXMuY29uZmlnKTtcbiAgICAgIHN1cGVyLmNvbmZpZ3VyZUpvaW50KCk7XG4gICAgfVxuXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcbiAgICAgICAgbWF4QW5nbGVGaXJzdDogdGhpcy4jbWF4QW5nbGVGaXJzdCxcbiAgICAgICAgbWF4QW5nbGVTZWNvbmQ6IHRoaXMuI21heEFuZ2xlU2Vjb25kLFxuICAgICAgICBzcHJpbmdEYW1waW5nVHdpc3Q6IHRoaXMuc3ByaW5nRGFtcGluZ1R3aXN0LFxuICAgICAgICBzcHJpbmdGcmVxdWVuY3lUd2lzdDogdGhpcy5zcHJpbmdGcmVxdWVuY3lUd2lzdCxcbiAgICAgICAgc3ByaW5nRGFtcGluZ1N3aW5nOiB0aGlzLnNwcmluZ0RhbXBpbmdTd2luZyxcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5U3dpbmc6IHRoaXMuc3ByaW5nRnJlcXVlbmN5U3dpbmcsXG4gICAgICAgIG1heE1vdG9yVHdpc3Q6IHRoaXMuI21heE1vdG9yVHdpc3QsXG4gICAgICAgIG1pbk1vdG9yVHdpc3Q6IHRoaXMuI21pbk1vdG9yVHdpc3QsXG4gICAgICAgIG1vdG9yU3BlZWRUd2lzdDogdGhpcy5tb3RvclNwZWVkVHdpc3QsXG4gICAgICAgIG1vdG9yVG9ycXVlVHdpc3Q6IHRoaXMubW90b3JUb3JxdWVUd2lzdFxuICAgICAgfTtcbiAgICAgIHJldHVybiBtdXRhdG9yO1xuICAgIH07XG5cbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tYXhBbmdsZUZpcnN0KSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGhpcy4jbWF4QW5nbGVGaXJzdCA9IF9tdXRhdG9yLm1heEFuZ2xlRmlyc3Q7XG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tYXhBbmdsZVNlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMuI21heEFuZ2xlU2Vjb25kID0gX211dGF0b3IubWF4QW5nbGVTZWNvbmQ7XG4gICAgICB0aGlzLm11dGF0ZUJhc2UoX211dGF0b3IsIFtcbiAgICAgICAgXCJzcHJpbmdEYW1waW5nVHdpc3RcIiwgXCJzcHJpbmdGcmVxdWVuY3lUd2lzdFwiLCBcInNwcmluZ0RhbXBpbmdTd2luZ1wiLCBcInNwcmluZ0ZyZXF1ZW5jeVN3aW5nXCIsIFwibWF4TW90b3JUd2lzdFwiLCBcIm1pbk1vdG9yVHdpc3RcIiwgXCJtb3RvclNwZWVkVHdpc3RcIiwgXCJtb3RvclRvcnF1ZVR3aXN0XCJcbiAgICAgIF0pO1xuICAgIH07XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIGEgZGVmaW5lZCBheGUgb2Ygcm90YXRpb24uIEFsc28ga25vd24gYXMgSElOR0Ugam9pbnQuXG4gICAgICogVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuIEEgbW90b3IgY2FuIGJlIGRlZmluZWQgdG8gcm90YXRlIHRoZSBjb25uZWN0ZWQgYWxvbmcgdGhlIGRlZmluZWQgYXhpcy5cbiAgICAgKiBcbiAgICAgKiBgYGB0ZXh0ICAgICAgICBcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uIGF4aXMsIDFzdCBEZWdyZWUgb2YgZnJlZWRvbVxuICAgICAqICAgICAgICAgICAgICAgICAgICDihpFcbiAgICAgKiAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkOKUguKUjOKUgOKUgOKUgOKUgOKUkCAgICAgXG4gICAgICogICAgICAgICAgICAgICDilIIgICDilILilILilIIgICAg4pSCICBcbiAgICAgKiAgICAgICAgICAgICAgIOKUgiAgIOKUguKUguKUgiAgICDilIIgXG4gICAgICogICAgICAgICAgICAgICDilIIgICDilILilILilIIgICAg4pSCIFxuICAgICAqICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSY4pSC4pSU4pSA4pSA4pSA4pSA4pSYXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIFxuICAgICAqICAgICAgYm9keUFuY2hvciAgICAgICAgIGJvZHlUaWVkXG4gICAgICogICAoZS5nLiBEb29yaGluZ2UpICAgICAgIChlLmcuIERvb3IpXG4gICAgICogYGBgXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxuICAgICAqL1xuICBleHBvcnQgY2xhc3MgSm9pbnRSZXZvbHV0ZSBleHRlbmRzIEpvaW50QXhpYWwge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50UmV2b2x1dGUpO1xuXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLlJldm9sdXRlSm9pbnQ7XG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5SZXZvbHV0ZUpvaW50Q29uZmlnID0gbmV3IE9JTU8uUmV2b2x1dGVKb2ludENvbmZpZygpO1xuXG4gICAgI21vdG9yVG9ycXVlOiBudW1iZXIgPSAwO1xuICAgICNyb3RvcjogT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpczogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XG5cbiAgICAgIHRoaXMubWF4TW90b3IgPSAzNjA7XG4gICAgICB0aGlzLm1pbk1vdG9yID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgbWF4TW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHN1cGVyLm1heE1vdG9yID0gX3ZhbHVlO1xuICAgICAgX3ZhbHVlICo9IENhbGMuZGVnMnJhZDtcbiAgICAgIGlmICh0aGlzLmpvaW50KVxuICAgICAgICB0aGlzLmpvaW50LmdldExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgbWluTW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHN1cGVyLm1pbk1vdG9yID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQpXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWUgKiBDYWxjLmRlZzJyYWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbW90b3JUb3JxdWUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclRvcnF1ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBtb3RvclRvcnF1ZShfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jbW90b3JUb3JxdWUgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IoKS5tb3RvclRvcnF1ZSA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogSWYgdGhlIHR3byBjb25uZWN0ZWQgUmlnaWRCb2RpZXMgY29sbGlkZSB3aXRoIGVhdGggb3RoZXIuIChEZWZhdWx0ID0gZmFsc2UpXG4gICAgICovXG5cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgbW90b3JUb3JxdWU6IHRoaXMubW90b3JUb3JxdWUsXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgdGhpcy5tb3RvclRvcnF1ZSA9IF9zZXJpYWxpemF0aW9uLm1vdG9yVG9ycXVlO1xuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcbiAgICAgIG11dGF0b3IubW90b3JUb3JxdWUgPSB0aGlzLm1vdG9yVG9ycXVlO1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IubW90b3JUb3JxdWUpICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aGlzLm1vdG9yVG9ycXVlID0gX211dGF0b3IubW90b3JUb3JxdWU7XG4gICAgICBkZWxldGUgX211dGF0b3IubW90b3JUb3JxdWU7XG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcbiAgICAgIHRoaXMuI3JvdG9yID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHMoc3VwZXIubWluTW90b3IgKiBDYWxjLmRlZzJyYWQsIHN1cGVyLm1heE1vdG9yICogQ2FsYy5kZWcycmFkKTtcbiAgICAgIHRoaXMuI3JvdG9yLnNldE1vdG9yKHRoaXMubW90b3JTcGVlZCwgdGhpcy5tb3RvclRvcnF1ZSk7XG5cbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uUmV2b2x1dGVKb2ludENvbmZpZygpO1xuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQoKTtcblxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyID0gdGhpcy5zcHJpbmdEYW1wZXI7XG4gICAgICB0aGlzLmNvbmZpZy5saW1pdE1vdG9yID0gdGhpcy4jcm90b3I7XG5cbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5SZXZvbHV0ZUpvaW50KHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuY29uZmlndXJlSm9pbnQoKTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIHRocmVlIERlZ3JlZXMgb2YgRnJlZWRvbSwgYWxzbyBrbm93biBhcyBiYWxsIGFuZCBzb2NrZXQgam9pbnQuIFR3byBib2RpZXMgY29ubmVjdGVkIGF0IHRoZWlyIGFuY2hvciBidXQgZnJlZSB0byByb3RhdGUuXG4gICAgICogVXNlZCBmb3IgdGhpbmdzIGxpa2UgdGhlIGNvbm5lY3Rpb24gb2YgYm9uZXMgaW4gdGhlIGh1bWFuIHNob3VsZGVyIChpZiBzaW1wbGlmaWVkLCBlbHNlIGJldHRlciB1c2UgSm9pbnRSYWdkb2xsKS4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuIE9ubHkgc3ByaW5nIHNldHRpbmdzIGNhbiBiZSBkZWZpbmVkLlxuICAgICAqIDMgRGVncmVlcyBhcmUgc3dpbmcgaG9yaXpvbnRhbCwgc3dpbmcgdmVydGljYWwgYW5kIHR3aXN0LlxuICAgICAqIFxuICAgICAqIGBgYHRleHRcbiAgICAgKiAgICAgICAgICAgICAgSm9pbnRIb2xkZXJcbiAgICAgKiAgICAgICAgIHogICAgICBib2R5QW5jaG9yIChlLmcuIEh1bWFuLVNob3VsZGVyKSAgICAgXG4gICAgICogICAgICB5ICDihpEgICAgICAgICAgXG4gICAgICogICAgICAgIFxcfCAgICAgICAgICDilIDilIDilIAo4peP4pSA4pSA4pSAXG4gICAgICogIC14IDwtLS18LS0tPiB4ICAgICAgICAgICBib2R5VGllZCAgICAgICAgXG4gICAgICogICAgICAgICB8XFwgICAgICAgICAgICAgICAgKGUuZy4gVXBwZXItQXJtKSBcbiAgICAgKiAgICAgICAgIOKGkyAteSAgICAgICBcbiAgICAgKiAgICAgICAgLXogICAgICAgICAgXG4gICAgICogYGBgXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxuICAgICAqL1xuICBleHBvcnQgY2xhc3MgSm9pbnRTcGhlcmljYWwgZXh0ZW5kcyBKb2ludCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRTcGhlcmljYWwpO1xuXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLlNwaGVyaWNhbEpvaW50O1xuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uU3BoZXJpY2FsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5TcGhlcmljYWxKb2ludENvbmZpZygpO1xuXG4gICAgI3NwcmluZ0RhbXBpbmc6IG51bWJlciA9IDA7XG4gICAgI3NwcmluZ0ZyZXF1ZW5jeTogbnVtYmVyID0gMDtcbiAgICAjc3ByaW5nRGFtcGVyOiBPSU1PLlNwcmluZ0RhbXBlcjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XG4gICAgICB0aGlzLmFuY2hvciA9IG5ldyBWZWN0b3IzKF9sb2NhbEFuY2hvci54LCBfbG9jYWxBbmNob3IueSwgX2xvY2FsQW5jaG9yLnopO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3ByaW5nRGFtcGluZygpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmc7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRGFtcGluZyhfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZyA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeShfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5ID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xuICAgICAgICBzcHJpbmdEYW1waW5nOiB0aGlzLnNwcmluZ0RhbXBpbmcsXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeTogdGhpcy5zcHJpbmdGcmVxdWVuY3ksXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgdGhpcy5zcHJpbmdEYW1waW5nID0gX3NlcmlhbGl6YXRpb24uc3ByaW5nRGFtcGluZztcbiAgICAgIHRoaXMuc3ByaW5nRnJlcXVlbmN5ID0gX3NlcmlhbGl6YXRpb24uc3ByaW5nRnJlcXVlbmN5O1xuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcbiAgICAgIG11dGF0b3Iuc3ByaW5nRGFtcGluZyA9IHRoaXMuc3ByaW5nRGFtcGluZztcbiAgICAgIG11dGF0b3Iuc3ByaW5nRnJlcXVlbmN5ID0gdGhpcy5zcHJpbmdGcmVxdWVuY3k7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICB0aGlzLm11dGF0ZUJhc2UoX211dGF0b3IsIFtcInNwcmluZ0RhbXBpbmdcIiwgXCJzcHJpbmdGcmVxdWVuY3lcIl0pO1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNwcmluZ0RhbXBpbmc7XG4gICAgICBkZWxldGUgX211dGF0b3Iuc3ByaW5nRnJlcXVlbmN5O1xuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXIgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3ksIHRoaXMuc3ByaW5nRGFtcGluZyk7XG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlNwaGVyaWNhbEpvaW50Q29uZmlnKCk7XG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCgpO1xuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyO1xuXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uU3BoZXJpY2FsSm9pbnQodGhpcy5jb25maWcpO1xuICAgICAgc3VwZXIuY29uZmlndXJlSm9pbnQoKTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIHR3byBkZWZpbmVkIGF4aXMgKG5vcm1hbGx5IGUuZy4gKDAsMCwxKSBhbmQgcm90YXRpb24oMSwwLDApKSwgdGhleSBzaGFyZSB0aGUgc2FtZSBhbmNob3IgYW5kIGhhdmUgZnJlZSByb3RhdGlvbiwgYnV0IHRyYW5zZmVyIHRoZSB0d2lzdC5cbiAgICAgKiBJbiByZWFsaXR5IHVzZWQgaW4gY2FycyB0byB0cmFuc2ZlciB0aGUgbW9yZSBzdGFibGUgc3RhdGlvbmFyeSBmb3JjZSBvbiB0aGUgdmVsb2NpdHkgYXhpcyB0byB0aGUgYnVtcGluZywgZGFtcGVkIG1vdmluZyB3aGVlbC4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuXG4gICAgICogVGhlIHR3byBtb3RvcnMgY2FuIGJlIGRlZmluZWQgZm9yIHRoZSB0d28gcm90YXRpb24gYXhpcywgYWxvbmcgd2l0aCBzcHJpbmdzLiBcbiAgICAgKiBgYGB0ZXh0ICAgICAgICBcbiAgICAgKiAgICAgICAgICAgICAgICAgIFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciAtIHR3aXN0IGlzIHRyYW5zZmVyZWQgYmV0d2VlbiBib2RpZXNcbiAgICAgKiAgICAgICAgIHogICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAgICAg4oaRICAgICAgICAgICAgLS0tLS0gIHwgIC0tLS0tLS0tLS0tLVxuICAgICAqICAgICAgICAgfCAgICAgICAgICAgfCAgICAgfCDihpMgfCAgICAgICAgICAgIHwgXG4gICAgICogIC14IDwtLS18LS0tPiB4ICAgICB8ICAgICB8IHggfCAgICAgICAgICAgIHwgICAgICAgICAgIGUuZy4gd2hlZWwgY2FuIHN0aWxsIHR1cm4gdXAvZG93biwgXG4gICAgICogICAgICAgICB8ICAgICAgICAgICB8ICAgICB8ICAgfCAgICAgICAgICAgIHwgICAgICAgICAgIGxlZnQgcmlnaHQgYnV0IHRyYW5zZmVyaW5nIGl0J3Mgcm90YXRpb24gb24gdG8gdGhlIHdoZWVsLWF4aXMuXG4gICAgICogICAgICAgICDihpMgICAgICAgICAgICAtLS0tLSAgICAgLS0tLS0tLS0tLS0tXG4gICAgICogICAgICAgIC16ICAgIFxuICAgICAqICAgICAgICAgICAgICAgICBhdHRhY2hlZFJCICAgICAgICAgIGNvbm5lY3RlZFJCXG4gICAgICogICAgICAgICAgICAgICAgKGUuZy4gd2hlZWwpICAgICAgIChlLmcuIHdoZWVsLWF4aXMpXG4gICAgICogYGBgXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICAgKi9cbiAgZXhwb3J0IGNsYXNzIEpvaW50VW5pdmVyc2FsIGV4dGVuZHMgSm9pbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50VW5pdmVyc2FsKTtcblxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5Vbml2ZXJzYWxKb2ludDtcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLlVuaXZlcnNhbEpvaW50Q29uZmlnID0gbmV3IE9JTU8uVW5pdmVyc2FsSm9pbnRDb25maWcoKTtcblxuICAgICNzcHJpbmdEYW1waW5nRmlyc3Q6IG51bWJlciA9IDA7XG4gICAgI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0OiBudW1iZXIgPSAwO1xuXG4gICAgI3NwcmluZ0RhbXBpbmdTZWNvbmQ6IG51bWJlciA9IDA7XG4gICAgI3NwcmluZ0ZyZXF1ZW5jeVNlY29uZDogbnVtYmVyID0gMDtcblxuICAgICNtYXhSb3RvckZpcnN0OiBudW1iZXIgPSAzNjA7XG4gICAgI21pblJvdG9yRmlyc3Q6IG51bWJlciA9IDA7XG4gICAgI3JvdG9yVG9ycXVlRmlyc3Q6IG51bWJlciA9IDA7XG4gICAgI3JvdG9yU3BlZWRGaXJzdDogbnVtYmVyID0gMDtcblxuICAgICNtYXhSb3RvclNlY29uZDogbnVtYmVyID0gMzYwO1xuICAgICNtaW5Sb3RvclNlY29uZDogbnVtYmVyID0gMDtcbiAgICAjcm90b3JUb3JxdWVTZWNvbmQ6IG51bWJlciA9IDA7XG4gICAgI3JvdG9yU3BlZWRTZWNvbmQ6IG51bWJlciA9IDA7XG5cbiAgICAjbW90b3JGaXJzdDogT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcjtcbiAgICAjbW90b3JTZWNvbmQ6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XG4gICAgI2F4aXNTcHJpbmdEYW1wZXJGaXJzdDogT0lNTy5TcHJpbmdEYW1wZXI7XG4gICAgI2F4aXNTcHJpbmdEYW1wZXJTZWNvbmQ6IE9JTU8uU3ByaW5nRGFtcGVyO1xuICAgICNheGlzRmlyc3Q6IE9JTU8uVmVjMztcbiAgICAjYXhpc1NlY29uZDogT0lNTy5WZWMzO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzRmlyc3Q6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKSwgX2F4aXNTZWNvbmQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xuICAgICAgdGhpcy5heGlzRmlyc3QgPSBfYXhpc0ZpcnN0O1xuICAgICAgdGhpcy5heGlzU2Vjb25kID0gX2F4aXNTZWNvbmQ7XG4gICAgICB0aGlzLmFuY2hvciA9IF9sb2NhbEFuY2hvcjtcbiAgICB9XG5cbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxuICAgIC8qKlxuICAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cbiAgICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGF4aXNGaXJzdCgpOiBWZWN0b3IzIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzRmlyc3QueCwgdGhpcy4jYXhpc0ZpcnN0LnksIHRoaXMuI2F4aXNGaXJzdC56KTtcbiAgICB9XG4gICAgcHVibGljIHNldCBheGlzRmlyc3QoX3ZhbHVlOiBWZWN0b3IzKSB7XG4gICAgICB0aGlzLiNheGlzRmlyc3QgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxuICAgICogIFdoZW4gY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiB0aGUgam9pbnQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IGF4aXNTZWNvbmQoKTogVmVjdG9yMyB7XG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy4jYXhpc1NlY29uZC54LCB0aGlzLiNheGlzU2Vjb25kLnksIHRoaXMuI2F4aXNTZWNvbmQueik7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgYXhpc1NlY29uZChfdmFsdWU6IFZlY3RvcjMpIHtcbiAgICAgIHRoaXMuI2F4aXNTZWNvbmQgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmdGaXJzdCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdGaXJzdDtcbiAgICB9XG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmdGaXJzdCA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyMSgpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeUZpcnN0KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5Rmlyc3Q7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5Rmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0ID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIxKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nU2Vjb25kKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZDtcbiAgICB9XG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nU2Vjb25kID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5U2Vjb25kKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5U2Vjb25kO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeVNlY29uZChfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5U2Vjb25kID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhSb3RvckZpcnN0KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jbWF4Um90b3JGaXJzdDtcbiAgICB9XG4gICAgcHVibGljIHNldCBtYXhSb3RvckZpcnN0KF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNtYXhSb3RvckZpcnN0ID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLnVwcGVyTGltaXQgPSBfdmFsdWUgKiBDYWxjLmRlZzJyYWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzIEFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pblJvdG9yRmlyc3QoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLiNtaW5Sb3RvckZpcnN0O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1pblJvdG9yRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI21pblJvdG9yRmlyc3QgPSBfdmFsdWU7XG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IxKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICogVGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBtb3RvciBpbiBtL3MuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcm90b3JTcGVlZEZpcnN0KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JTcGVlZEZpcnN0O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHJvdG9yU3BlZWRGaXJzdChfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jcm90b3JTcGVlZEZpcnN0ID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcm90b3JUb3JxdWVGaXJzdCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yVG9ycXVlRmlyc3Q7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgcm90b3JUb3JxdWVGaXJzdChfdmFsdWU6IG51bWJlcikge1xuICAgICAgdGhpcy4jcm90b3JUb3JxdWVGaXJzdCA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjEoKS5tb3RvclRvcnF1ZSA9IF92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhSb3RvclNlY29uZCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21heFJvdG9yU2Vjb25kO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1heFJvdG9yU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNtYXhSb3RvclNlY29uZCA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjIoKS51cHBlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5Sb3RvclNlY29uZCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuI21pblJvdG9yU2Vjb25kO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IG1pblJvdG9yU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNtaW5Sb3RvclNlY29uZCA9IF92YWx1ZTtcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjIoKS5sb3dlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXG4gICAgICovXG4gICAgcHVibGljIGdldCByb3RvclNwZWVkU2Vjb25kKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JTcGVlZFNlY29uZDtcbiAgICB9XG4gICAgcHVibGljIHNldCByb3RvclNwZWVkU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLiNyb3RvclNwZWVkU2Vjb25kID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSBpbiBOZXd0b24uIGZvcmNlIDw9IDAgZXF1YWxzIGRpc2FibGVkLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJvdG9yVG9ycXVlU2Vjb25kKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JUb3JxdWVTZWNvbmQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgcm90b3JUb3JxdWVTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcbiAgICAgIHRoaXMuI3JvdG9yVG9ycXVlU2Vjb25kID0gX3ZhbHVlO1xuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBJZiB0aGUgdHdvIGNvbm5lY3RlZCBSaWdpZEJvZGllcyBjb2xsaWRlIHdpdGggZWF0aCBvdGhlci4gKERlZmF1bHQgPSBmYWxzZSlcbiAgICAgKi9cblxuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xuICAgICAgc2VyaWFsaXphdGlvbi5maXJzdEF4aXMgPSB0aGlzLmF4aXNGaXJzdC5zZXJpYWxpemUoKTtcbiAgICAgIHNlcmlhbGl6YXRpb24uc2Vjb25kQXhpcyA9IHRoaXMuYXhpc1NlY29uZC5zZXJpYWxpemUoKTtcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICB0aGlzLmF4aXNGaXJzdCA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc0ZpcnN0KTtcbiAgICAgIHRoaXMuYXhpc1NlY29uZCA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc1NlY29uZCk7XG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc0ZpcnN0KSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGhpcy5heGlzRmlyc3QgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYXhpc0ZpcnN0KSkpO1xuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc1NlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRoaXMuYXhpc1NlY29uZCA9IG5ldyBWZWN0b3IzKC4uLjxudW1iZXJbXT4oT2JqZWN0LnZhbHVlcyhfbXV0YXRvci5heGlzU2Vjb25kKSkpO1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLmF4aXNGaXJzdDtcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XG4gICAgICBtdXRhdG9yLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LmdldE11dGF0b3IoKTtcbiAgICAgIG11dGF0b3IuYXhpc1NlY29uZCA9IHRoaXMuYXhpc1NlY29uZC5nZXRNdXRhdG9yKCk7XG4gICAgICByZXR1cm4gbXV0YXRvcjtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XG4gICAgICB0aGlzLiNheGlzU3ByaW5nRGFtcGVyRmlyc3QgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy4jc3ByaW5nRnJlcXVlbmN5Rmlyc3QsIHRoaXMuI3NwcmluZ0RhbXBpbmdGaXJzdCk7XG4gICAgICB0aGlzLiNheGlzU3ByaW5nRGFtcGVyU2Vjb25kID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVNlY29uZCwgdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCk7XG5cbiAgICAgIHRoaXMuI21vdG9yRmlyc3QgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLiNtaW5Sb3RvckZpcnN0ICogQ2FsYy5kZWcycmFkLCB0aGlzLiNtYXhSb3RvckZpcnN0ICogQ2FsYy5kZWcycmFkKTtcbiAgICAgIHRoaXMuI21vdG9yRmlyc3Quc2V0TW90b3IodGhpcy4jcm90b3JTcGVlZEZpcnN0LCB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0KTtcbiAgICAgIHRoaXMuI21vdG9yU2Vjb25kID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy4jbWluUm90b3JGaXJzdCAqIENhbGMuZGVnMnJhZCwgdGhpcy4jbWF4Um90b3JGaXJzdCAqIENhbGMuZGVnMnJhZCk7XG4gICAgICB0aGlzLiNtb3RvclNlY29uZC5zZXRNb3Rvcih0aGlzLiNyb3RvclNwZWVkRmlyc3QsIHRoaXMuI3JvdG9yVG9ycXVlRmlyc3QpO1xuXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlVuaXZlcnNhbEpvaW50Q29uZmlnKCk7XG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCh0aGlzLiNheGlzRmlyc3QsIHRoaXMuI2F4aXNTZWNvbmQpO1xuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvcjEgPSB0aGlzLiNtb3RvckZpcnN0O1xuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvcjIgPSB0aGlzLiNtb3RvclNlY29uZDtcbiAgICAgIHRoaXMuY29uZmlnLnNwcmluZ0RhbXBlcjEgPSB0aGlzLiNheGlzU3ByaW5nRGFtcGVyRmlyc3Q7XG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIyID0gdGhpcy4jYXhpc1NwcmluZ0RhbXBlclNlY29uZDtcblxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLlVuaXZlcnNhbEpvaW50KHRoaXMuY29uZmlnKTtcbiAgICAgIHN1cGVyLmNvbmZpZ3VyZUpvaW50KCk7XG4gICAgfVxuXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcbiAgICAgICAgc3ByaW5nRGFtcGluZ0ZpcnN0OiB0aGlzLiNzcHJpbmdEYW1waW5nRmlyc3QsXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeUZpcnN0OiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lGaXJzdCxcbiAgICAgICAgc3ByaW5nRGFtcGluZ1NlY29uZDogdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCxcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5U2Vjb25kOiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQsXG4gICAgICAgIG1heFJvdG9yRmlyc3Q6IHRoaXMuI21heFJvdG9yRmlyc3QsXG4gICAgICAgIG1pblJvdG9yRmlyc3Q6IHRoaXMuI21pblJvdG9yRmlyc3QsXG4gICAgICAgIHJvdG9yU3BlZWRGaXJzdDogdGhpcy4jcm90b3JTcGVlZEZpcnN0LFxuICAgICAgICByb3RvclRvcnF1ZUZpcnN0OiB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0LFxuICAgICAgICBtYXhSb3RvclNlY29uZDogdGhpcy4jbWF4Um90b3JTZWNvbmQsXG4gICAgICAgIG1pblJvdG9yU2Vjb25kOiB0aGlzLiNtaW5Sb3RvclNlY29uZCxcbiAgICAgICAgcm90b3JTcGVlZFNlY29uZDogdGhpcy4jcm90b3JTcGVlZFNlY29uZCxcbiAgICAgICAgcm90b3JUb3JxdWVTZWNvbmQ6IHRoaXMuI3JvdG9yVG9ycXVlU2Vjb25kXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG11dGF0b3I7XG4gICAgfTtcblxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcbiAgICAgIHRoaXMubXV0YXRlQmFzZShfbXV0YXRvciwgW1xuICAgICAgICBcInNwcmluZ0RhbXBpbmdGaXJzdFwiLCBcInNwcmluZ0ZyZXF1ZW5jeUZpcnN0XCIsIFwic3ByaW5nRGFtcGluZ1NlY29uZFwiLCBcInNwcmluZ0ZyZXF1ZW5jeVNlY29uZFwiLFxuICAgICAgICBcIm1heFJvdG9yRmlyc3RcIiwgXCJtaW5Sb3RvckZpcnN0XCIsIFwicm90b3JTcGVlZEZpcnN0XCIsIFwicm90b3JUb3JxdWVGaXJzdFwiLFxuICAgICAgICBcIm1heFJvdG9yU2Vjb25kXCIsIFwibWluUm90b3JTZWNvbmRcIiwgXCJyb3RvclNwZWVkU2Vjb25kXCIsIFwiLnJvdG9yVG9ycXVlU2Vjb25kXCJdXG4gICAgICApO1xuICAgIH07XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIG5vIG1vdmVtZW50LiBcbiAgICAgKiBCZXN0IHdheSB0byBzaW11bGF0ZSBjb252ZXggb2JqZWN0cyBsaWtlIGEgY2hhaXIgc2VhdCBjb25uZWN0ZWQgdG8gY2hhaXIgbGVncy5cbiAgICAgKiBUaGUgYWN0dWFsIGFuY2hvciBwb2ludCBkb2VzIG5vdCBtYXR0ZXIgdGhhdCBtdWNoLCBvbmx5IGluIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlcy5cbiAgICAgKiBCZWNhdXNlIHdlbGRpbmcgbWVhbnMgdGhleSBzaW1wbHkgZG8gbm90IGRpc2Nvbm5lY3QuICh1bmxlc3MgeW91IGFkZCBCcmVha2FiaWxpdHkpXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICAgKi9cbiAgZXhwb3J0IGNsYXNzIEpvaW50V2VsZGluZyBleHRlbmRzIEpvaW50IHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludFdlbGRpbmcpO1xuXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLkdlbmVyaWNKb2ludDtcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLkdlbmVyaWNKb2ludENvbmZpZyA9IG5ldyBPSU1PLkdlbmVyaWNKb2ludENvbmZpZygpO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcblxuICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyhfbG9jYWxBbmNob3IueCwgX2xvY2FsQW5jaG9yLnksIF9sb2NhbEFuY2hvci56KTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cblxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG5cblxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uR2VuZXJpY0pvaW50Q29uZmlnKCk7XG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludChuZXcgT0lNTy5NYXQzKCksIG5ldyBPSU1PLk1hdDMoKSk7XG5cbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5HZW5lcmljSm9pbnQodGhpcy5jb25maWcpO1xuICAgICAgdGhpcy5qb2ludC5zZXRBbGxvd0NvbGxpc2lvbih0aGlzLmludGVybmFsQ29sbGlzaW9uKTtcbiAgICB9XG4gIH1cbn0iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vUGh5c2ljcy9PaW1vUGh5c2ljcy5kLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIE1hbmFnZXMgdGhlIE9JTU8gcGh5c2ljcyBlbmdpbmUgZm9yIEZVREdFLiBNdWx0aXBsZSBpbnN0YW5jZXMgbWF5IGJlIGNyZWF0ZWQsIG9uZSBpcyBhY3RpdmUgYXQgYSB0aW1lLlxyXG4gICAgKiBBbGwgbWV0aG9kcyBhcmUgc3RhdGljIGFuZCB1c2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UuIEF0IHN0YXJ0dXAsIGEgZGVmYXVsdCBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBiZWNvbWUgdGhlIGFjdGl2ZSBpbnN0YW5jZVxyXG4gICAgKiBBdHRhY2hpbmcgYSB7QGxpbmsgQ29tcG9uZW50UmlnaWRib2R5fSB0byBhIHtAbGluayBOb2RlfSBwbGFjZXMgYSBwaHlzaWNzIGNvbGxpZGVyIGluIHRoZSBwaHlzaWNzIGluc3RhbmNlIGFjdGl2ZSBhdCB0aGF0IHRpbWUuXHJcbiAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjBcclxuICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3Mge1xyXG4gICAgLyoqIFRoZSBTRVRUSU5HUyB0aGF0IGFwcGx5IHRvIHRoZSBwaHlzaWNhbCB3b3JsZC4gUmFuZ2luZyBmcm9tIHRoaW5ncyBsaWtlIHNsZWVwaW5nLCBjb2xsaXNpb25TaGFwZVRoaWNrbmVzcyBhbmQgb3RoZXJzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldHRpbmdzOiBQaHlzaWNzU2V0dGluZ3MgPSBuZXcgUGh5c2ljc1NldHRpbmdzKENPTExJU0lPTl9HUk9VUC5ERUZBVUxULCAoQ09MTElTSU9OX0dST1VQLkRFRkFVTFQgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfMSB8IENPTExJU0lPTl9HUk9VUC5HUk9VUF8yIHwgQ09MTElTSU9OX0dST1VQLkdST1VQXzMgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfNCkpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJhY3RpdmU6IFBoeXNpY3MgPSBuZXcgUGh5c2ljcygpO1xyXG5cclxuICAgIHByaXZhdGUgb2ltb1dvcmxkOiBPSU1PLldvcmxkO1xyXG4gICAgcHJpdmF0ZSBib2R5TGlzdDogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuICAgIHByaXZhdGUgam9pbnRMaXN0OiBKb2ludFtdID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgLyoqIFRoZSByZW5kZXJpbmcgb2YgcGh5c2ljYWwgZGVidWcgaW5mb3JtYXRpb25zLiBVc2VkIGludGVybmFsbHkgbm8gaW50ZXJhY3Rpb24gbmVlZGVkLiovXHJcbiAgICAjZGVidWdEcmF3OiBQaHlzaWNzRGVidWdEcmF3O1xyXG4gICAgLyoqIFRoZSBjYW1lcmEvdmlld3BvcnQgdGhlIHBoeXNpY3MgYXJlIGRlYnVnZ2VkIHRvLiBVc2VkIGludGVybmFsbHkgbm8gaW50ZXJhY3Rpb24gbmVlZGVkLiAqL1xyXG4gICAgI21haW5DYW06IENvbXBvbmVudENhbWVyYTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgT0lNTyA9PSBcInVuZGVmaW5lZFwiKSB7Ly8gQ2hlY2sgaWYgT0lNTyBOYW1lc3BhY2Ugd2FzIGxvYWRlZCwgZWxzZSBkbyBub3QgdXNlIGFueSBwaHlzaWNzLiBDaGVjayBpcyBuZWVkZWQgdG8gZW5zdXJlIEZVREdFIGNhbiBiZSB1c2VkIHdpdGhvdXQgUGh5c2ljc1xyXG4gICAgICAgIERlYnVnLmVycm9yKFwiT0lNTyBwaHlzaWNzIGVuZ2luZSBub3QgY29ubmVjdGVkIVwiKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZCA9IG5ldyBPSU1PLldvcmxkKCk7XHJcbiAgICAgIHRoaXMuI2RlYnVnRHJhdyA9IG5ldyBQaHlzaWNzRGVidWdEcmF3KCk7ICAvL0NyZWF0ZSBhIEZVREdFIFBoeXNpY3MgZGVidWdnaW5nIGhhbmRsaW5nIG9iamVjdFxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZC5zZXREZWJ1Z0RyYXcodGhpcy4jZGVidWdEcmF3Lm9pbW9EZWJ1Z0RyYXcpOyAvL1RlbGwgT2ltb1BoeXNpY3Mgd2hlcmUgdG8gZGVidWcgdG8gYW5kIGhvdyBpdCB3aWxsIGJlIGhhbmRsZWRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjdXJyZW50bHkgYWN0aXZlIFBoeXNpY3MgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXQgYWN0aXZlSW5zdGFuY2UoX3BoeXNpY3M6IFBoeXNpY3MpIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZSA9IF9waHlzaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgUGh5c2ljcyBpbnN0YW5jZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgYWN0aXZlSW5zdGFuY2UoKTogUGh5c2ljcyB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGRlYnVnRHJhdygpOiBQaHlzaWNzRGVidWdEcmF3IHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IG1haW5DYW0oKTogQ29tcG9uZW50Q2FtZXJhIHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI21haW5DYW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhc3QgYSBSQVkgaW50byB0aGUgcGh5c2ljYWwgd29ybGQgZnJvbSBhIG9yaWdpbiBwb2ludCBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBSZWNlaXZpbmcgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBoaXQgb2JqZWN0IGFuZCB0aGVcclxuICAgICogaGl0IHBvaW50LiBEbyBub3Qgc3BlY2lmeSBhIF9ncm91cCB0byByYXljYXN0IHRoZSB3aG9sZSB3b3JsZCwgZWxzZSBvbmx5IGJvZGllcyB3aXRoaW4gdGhlIHNwZWNpZmljIGdyb3VwIGNhbiBiZSBoaXQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByYXljYXN0KF9vcmlnaW46IFZlY3RvcjMsIF9kaXJlY3Rpb246IFZlY3RvcjMsIF9sZW5ndGg6IG51bWJlciA9IDEsIF9kZWJ1Z0RyYXc6IGJvb2xlYW4gPSBmYWxzZSwgX2dyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVCk6IFJheUhpdEluZm8ge1xyXG4gICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IG5ldyBSYXlIaXRJbmZvKCk7XHJcbiAgICAgIGxldCByYXk6IE9JTU8uUmF5Q2FzdENsb3Nlc3QgPSBuZXcgT0lNTy5SYXlDYXN0Q2xvc2VzdCgpO1xyXG4gICAgICBsZXQgYmVnaW46IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueik7XHJcbiAgICAgIGxldCBlbmQ6IE9JTU8uVmVjMyA9IHRoaXMuZ2V0UmF5RW5kUG9pbnQoYmVnaW4sIG5ldyBWZWN0b3IzKF9kaXJlY3Rpb24ueCwgX2RpcmVjdGlvbi55LCBfZGlyZWN0aW9uLnopLCBfbGVuZ3RoKTtcclxuICAgICAgcmF5LmNsZWFyKCk7XHJcbiAgICAgIGlmIChfZ3JvdXAgPT0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQpIHsgLy9DYXNlIDE6IFJheWNhc3RpbmcgdGhlIHdob2xlIHdvcmxkLCBub3JtYWwgbW9kZVxyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnJheUNhc3QoYmVnaW4sIGVuZCwgcmF5KTtcclxuICAgICAgfSBlbHNlIHsgLy9DYXNlMjogUmF5Y2FzdGluZyBvbiBlYWNoIGJvZHkgaW4gYSBzcGVjaWZpYyBncm91cFxyXG4gICAgICAgIGxldCBhbGxIaXRzOiBSYXlIaXRJbmZvW10gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCB7XHJcbiAgICAgICAgICBpZiAoX3ZhbHVlLmNvbGxpc2lvbkdyb3VwID09IF9ncm91cCkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gX3ZhbHVlLnJheWNhc3RUaGlzQm9keShfb3JpZ2luLCBfZGlyZWN0aW9uLCBfbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKGhpdEluZm8uaGl0ID09IHRydWUpIHsgLy9FdmVyeSBoaXQgaXMgY291bGQgcG90ZW50aWFsbHkgYmUgdGhlIGNsb3Nlc3RcclxuICAgICAgICAgICAgICBhbGxIaXRzLnB1c2goaGl0SW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhbGxIaXRzLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZTogUmF5SGl0SW5mbyk6IHZvaWQgeyAvL2dldCB0aGUgY2xvc2VzdCBoaXRJbmZvXHJcbiAgICAgICAgICBpZiAoX3ZhbHVlLmhpdERpc3RhbmNlIDwgaGl0SW5mby5oaXREaXN0YW5jZSB8fCBoaXRJbmZvLmhpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gX3ZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyYXkuaGl0KSB7IC8vRmlsbCBpbiBpbmZvcm1hdGlvbnMgb24gdGhlIGhpdFxyXG4gICAgICAgIGhpdEluZm8uaGl0ID0gdHJ1ZTtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMocmF5LnBvc2l0aW9uLngsIHJheS5wb3NpdGlvbi55LCByYXkucG9zaXRpb24ueik7XHJcbiAgICAgICAgaGl0SW5mby5oaXROb3JtYWwgPSBuZXcgVmVjdG9yMyhyYXkubm9ybWFsLngsIHJheS5ub3JtYWwueSwgcmF5Lm5vcm1hbC56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdERpc3RhbmNlID0gdGhpcy5nZXRSYXlEaXN0YW5jZShfb3JpZ2luLCBoaXRJbmZvLmhpdFBvaW50KTtcclxuICAgICAgICBoaXRJbmZvLnJpZ2lkYm9keUNvbXBvbmVudCA9IHJheS5zaGFwZS51c2VyRGF0YTtcclxuICAgICAgICBoaXRJbmZvLnJheUVuZCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoaXRJbmZvLnJheU9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgICAgaGl0SW5mby5oaXRQb2ludCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfZGVidWdEcmF3KSB7IC8vSGFuZGxlIGRlYnVnZ2luZ1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdy5kZWJ1Z1JheShoaXRJbmZvLnJheU9yaWdpbiwgaGl0SW5mby5oaXRQb2ludCwgbmV3IENvbG9yKDAsIDEsIDAsIDEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGl0SW5mbztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNpbXVsYXRlcyB0aGUgcGh5c2ljYWwgd29ybGQuIF9kZWx0YVRpbWUgaXMgdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gcGh5c2ljYWwgc3RlcHMsIGRlZmF1bHQgaXMgYWJvdXQgMTdtcyAoYXNzdW1pbmcgNjAgZnJhbWVzIHBlciBzZWNvbmQpLlxyXG4gICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBpcyAxLzMwIG9mIGEgc2Vjb25kLCB0byBoYXZlIG1vcmUgY29uc2lzdGVudCBmcmFtZSBjYWxjdWxhdGlvbnMuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzaW11bGF0ZShfZGVsdGFUaW1lOiBudW1iZXIgPSAxIC8gNjApOiB2b2lkIHtcclxuICAgICAgaWYgKFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgUGh5c2ljcy5jb25uZWN0Sm9pbnRzKCk7IC8vQ29ubmVjdCBqb2ludHMgaWYgYW55dGhpbmcgaGFzIGhhcHBlbmVkIGJldHdlZW4gdGhlIGxhc3QgY2FsbCB0byBhbnkgb2YgdGhlIHR3byBwYWlyZWQgcmlnaWRib2RpZXNcclxuICAgICAgaWYgKFRpbWUuZ2FtZS5nZXRTY2FsZSgpICE9IDApIHsgLy9JZiB0aW1lIGlzIHN0b3BwZWQgZG8gbm90IHNpbXVsYXRlIHRvIGF2b2lkIG1pc2JlaGF2aW91clxyXG4gICAgICAgIF9kZWx0YVRpbWUgPSBfZGVsdGFUaW1lID4gMSAvIDMwID8gMSAvIDMwIDogX2RlbHRhVGltZTsgLy9JZiBpbnN0ZWFkIG9mIGEgZml4ZWQgcmF0ZSB0aGUgZ2FtZSBmcmFtZXJhdGUgaXMgdXNlZCwgbWFrZSBzdXJlIGlycmVndWxhciB0aW1pbmdzIGFyZSBmaXhlZCB0byAzMGZwc1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnN0ZXAoX2RlbHRhVGltZSAqIFRpbWUuZ2FtZS5nZXRTY2FsZSgpKTsgIC8vVXBkYXRlIHRoZSBzaW11bGF0aW9uIGJ5IHRoZSBnaXZlbiBkZWx0YVRpbWUgYW5kIHRoZSBGVURHRSBpbnRlcm5hbCBUaW1lU2NhbGVcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudGx5IGFjdGl2ZSBpbnN0YW5jZSB1c2luZyB0aGUge0BsaW5rIENvbXBvbmVudENhbWVyYX0gZ2l2ZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3KF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX21vZGU/OiBQSFlTSUNTX0RFQlVHTU9ERSk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLiNkZWJ1Z0RyYXcuc2V0RGVidWdNb2RlKF9tb2RlKTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jbWFpbkNhbSA9IF9jbXBDYW1lcmE7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLmRlYnVnRHJhdygpOyAvL0ZpbGxpbmcgdGhlIHBoeXNpY3Mgd29ybGQgZGVidWcgaW5mb3JtYXRpb25zIGludG8gdGhlIGRlYnVnIHJlbmRlcmluZyBoYW5kbGVyXHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdy5kcmF3QnVmZmVycygpO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLiNkZWJ1Z0RyYXcuY2xlYXJCdWZmZXJzKCk7ICAvL1VwZGF0ZXMgaW5mbyBhYm91dCB0aGUgY3VycmVudCBwcm9qZWN0aW9uLCByZXNldHRpbmcgdGhlIHBvaW50cy9saW5lcy90cmlhbmdsZXMgdGhhdCBuZWVkIHRvIGJlIGRyYXduIGZyb20gZGVidWdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBBZGp1c3RzIHRoZSB0cmFuc2Zvcm1zIG9mIHRoZSB7QGxpbmsgQ29tcG9uZW50UmlnaWRib2R5fXMgaW4gdGhlIGdpdmVuIGJyYW5jaCB0byBtYXRjaCB0aGVpciBub2RlcyBvciBtZXNoZXNcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRqdXN0VHJhbnNmb3JtcyhfYnJhbmNoOiBOb2RlLCBfdG9NZXNoOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyLnByZXBhcmUoX2JyYW5jaCwgeyBpZ25vcmVQaHlzaWNzOiB0cnVlIH0pO1xyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIFJlbmRlci5ub2Rlc1BoeXNpY3MpXHJcbiAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KS5pbml0aWFsaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldCB0aGUgYXBwbGllZCBncmF2aXRhdGlvbmFsIGZvcmNlIG9mIHRoZSBhY3RpdmUgaW5zdGFuY2UuIERlZmF1bHQgZWFydGggZ3Jhdml0eSA9IDkuODEgbS9zXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRHcmF2aXR5KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdG1wVmVjOiBPSU1PLlZlYzMgPSBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5nZXRHcmF2aXR5KCk7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0bXBWZWMueCwgdG1wVmVjLnksIHRtcFZlYy56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogU2V0IHRoZSBhcHBsaWVkIGdyYXZpdGF0aW9uYWwgZm9yY2Ugb2YgdGhlIGFjdGl2ZSBpbnN0YW5jZS4gRGVmYXVsdCBlYXJ0aCBncmF2aXR5ID0gOS44MSBtL3NcclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldEdyYXZpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCB0bXBWZWM6IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnNldEdyYXZpdHkodG1wVmVjKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQWRkIGEgbmV3IE9JTU8gUmlnaWRib2R5IHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UsIGhhcHBlbnMgYXV0b21hdGljYWxseSB3aGVuIGFkZGluZyBhIEZVREdFIFJpZ2lkYm9keSBDb21wb25lbnQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGRSaWdpZGJvZHkoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5wdXNoKF9jbXBSQik7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLmFkZFJpZ2lkQm9keShfY21wUkIuZ2V0T2ltb1JpZ2lkYm9keSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogUmVtb3ZlIHRoZSBPSU1PIFJpZ2lkYm9keSB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiByZW1vdmluZyBhIEZVREdFIFJpZ2lkYm9keSBDb21wb25lbnRcclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZVJpZ2lkYm9keShfY21wUkI6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiB0d28gbGlzdHMgYXJlIGJlaW5nIG1hbmFnZWQsIGluZm8gbWlnaHQgZGV2aWF0ZS4gQ2xlYW51cCFcclxuICAgICAgbGV0IG9pbW9SaWdpZEJvZHk6IE9JTU8uUmlnaWRCb2R5ID0gX2NtcFJCLmdldE9pbW9SaWdpZGJvZHkoKTtcclxuICAgICAgaWYgKG9pbW9SaWdpZEJvZHkuX3dvcmxkKVxyXG4gICAgICAgIG9pbW9SaWdpZEJvZHkuX3dvcmxkLnJlbW92ZVJpZ2lkQm9keShvaW1vUmlnaWRCb2R5KTtcclxuICAgICAgLy8gd2hhdCBpZiB0aGUgcmlnaWRib2R5cyBvaW1vLXdvcmxkIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgYWN0aXZlIGluc3RhbmNlP1xyXG4gICAgICBsZXQgaWQ6IG51bWJlciA9IFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QuaW5kZXhPZihfY21wUkIpO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LnNwbGljZShpZCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFkZCBhIG5ldyBPSU1PIEpvaW50L0NvbnN0cmFpbnQgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZSwgaGFwcGVucyBhdXRvbWF0aWNhbGx5IHdoZW4gYWRkaW5nIGEgRlVER0UgSm9pbnQgQ29tcG9uZW50XHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGRKb2ludChfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLmFkZEpvaW50KF9jbXBKb2ludC5nZXRPaW1vSm9pbnQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhbGxlZCBpbnRlcm5hbGx5IHRvIGluZm9ybSB0aGUgcGh5c2ljcyBzeXN0ZW0gdGhhdCBhIGpvaW50IGhhcyBhIGNoYW5nZSBvZiBjb3JlIHByb3BlcnRpZXMgYW5kIG5lZWRzIHRvIGJlIHJlY3JlYXRlZC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNoYW5nZUpvaW50U3RhdHVzKF9jbXBKb2ludDogSm9pbnQpOiB2b2lkIHtcclxuICAgICAgaWYgKFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0LmluZGV4T2YoX2NtcEpvaW50KSA8IDApXHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5qb2ludExpc3QucHVzaChfY21wSm9pbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFJlbW92ZSB0aGUgT0lNTyBKb2ludC9Db25zdHJhaW50IHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UsIGhhcHBlbnMgYXV0b21hdGljYWxseSB3aGVuIHJlbW92aW5nIGEgRlVER0UgSm9pbnQgQ29tcG9uZW50XHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZUpvaW50KF9jbXBKb2ludDogSm9pbnQpOiB2b2lkIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5yZW1vdmVKb2ludChfY21wSm9pbnQuZ2V0T2ltb0pvaW50KCkpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3I6IHVua25vd24pIHtcclxuICAgICAgICBEZWJ1Zy5mdWRnZShfZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgYWxsIHRoZSBDb21wb25lbnRSaWdpZGJvZGllcyB0aGF0IGFyZSBrbm93biB0byB0aGUgYWN0aXZlIGluc3RhbmNlLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRCb2R5TGlzdCgpOiBDb21wb25lbnRSaWdpZGJvZHlbXSB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHaXZpbmcgYSBDb21wb25lbnRSaWdpZGJvZHkgYSBzcGVjaWZpYyBpZGVudGlmaWNhdGlvbiBudW1iZXIgc28gaXQgY2FuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIGxvYWRpbmcgcHJvY2Vzcy4gQW5kIHJlbW92ZWQgcmIncyBjYW4gcmVjZWl2ZSBhIG5ldyBpZC4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZGlzdHJpYnV0ZUJvZHlJRCgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgZnJlZUlkOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgZnJlZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmZvckVhY2goKF92YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKF92YWx1ZS5pZCAhPSBmcmVlSWQpIHtcclxuICAgICAgICAgIGZyZWUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmcmVlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZnJlZSkge1xyXG4gICAgICAgICAgZnJlZUlkKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBmcmVlSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQ29ubmVjdCBhbGwgam9pbnRzIHRoYXQgYXJlIG5vdCBjb25uZWN0ZWQgeWV0LiBVc2VkIGludGVybmFsbHkgbm8gdXNlciBpbnRlcmFjdGlvbiBuZWVkZWQuIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBjYWxsZWQgYW5kIG5lZWRlZCB0byBtYWtlIHN1cmUgam9pbnRzIGNvbm5lY3QvZGlzY29ubmVjdFxyXG4gICAgICogaWYgYW55IG9mIHRoZSB0d28gcGFpcmVkIENvbXBvbmVudFJpZ2lkYm9kaWVzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjb25uZWN0Sm9pbnRzKCk6IHZvaWQgeyAvL1RyeSB0byBjb25uZWN0IGRpcnR5IGpvaW50cyB1bnRpbCB0aGV5IGFyZSBjb25uZWN0ZWRcclxuICAgICAgbGV0IGpvaW50c1RvQ29ubmVjdDogSm9pbnRbXSA9IFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0O1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdCA9IFtdO1xyXG4gICAgICBqb2ludHNUb0Nvbm5lY3QuZm9yRWFjaCgoX2pvaW50OiBKb2ludCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChfam9pbnQuaXNDb25uZWN0ZWQoKSA9PSBmYWxzZSlcclxuICAgICAgICAgIGlmIChfam9pbnQuaXNBY3RpdmUpXHJcbiAgICAgICAgICAgIF9qb2ludC5jb25uZWN0KCk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0LnB1c2goX2pvaW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlbW92ZSBhbGwgb2ltbyBqb2ludHMgYW5kIHJpZ2lkYm9kaWVzLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHJldXNlZCBpbiBhbm90aGVyIHdvcmxkICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhbnVwKCk6IHZvaWQge1xyXG4gICAgICBsZXQgb2ltb1dvcmxkOiBPSU1PLldvcmxkID0gUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQ7XHJcbiAgICAgIGlmIChvaW1vV29ybGQgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vUmVzZXR0aW5nIHRoZSB3b3JsZCBzbyBhIG5ldyB3b3JsZCBjYW4gYmUgY3JlYXRlZCwgZml4IGZvciByZS1vcGVuaW5nIGEgcHJvamVjdCBpbiBlZGl0b3IsIG1ha2luZyBzdXJlIHRoZXJlIGFyZSBubyBvbGQgdGhpbmdzIGNhbGN1bGF0ZWRcclxuICAgICAgICBsZXQgam9pbnRzV29ybGQ6IG51bWJlciA9IG9pbW9Xb3JsZC5nZXROdW1Kb2ludHMoKTtcclxuICAgICAgICBsZXQgYm9kaWVzV29ybGQ6IG51bWJlciA9IG9pbW9Xb3JsZC5nZXROdW1SaWdpZEJvZGllcygpO1xyXG4gICAgICAgIGZvciAobGV0IGJvZHkgb2YgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdClcclxuICAgICAgICAgIGJvZHkuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0ID0gbmV3IEFycmF5KCk7IC8vIFRPRE86IHNlZSBpZiBpdCB3b3VsZCBiZSBzbWFydGVyLCBkbyB1c2UgdGhlc2UgYXJyYXlzLiBEZWZpbml0ZWx5IG1vcmUgaW50dWl0aXZlLi4uXHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGpvaW50c1dvcmxkOyBpKyspIHtcclxuICAgICAgICAgIGxldCBvaW1vSm9pbnQ6IE9JTU8uSm9pbnQgPSBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5nZXRKb2ludExpc3QoKTtcclxuICAgICAgICAgIG9pbW9Xb3JsZC5yZW1vdmVKb2ludChvaW1vSm9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgYm9kaWVzV29ybGQ7IGkrKykge1xyXG4gICAgICAgICAgbGV0IG9pbW9Cb2R5OiBPSU1PLlJpZ2lkQm9keSA9IG9pbW9Xb3JsZC5nZXRSaWdpZEJvZHlMaXN0KCk7XHJcbiAgICAgICAgICBvaW1vV29ybGQucmVtb3ZlUmlnaWRCb2R5KG9pbW9Cb2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAvKiogUmV0dXJucyB0aGUgQ29tcG9uZW50UmlnaWRib2R5IHdpdGggdGhlIGdpdmVuIGlkLiBVc2VkIGludGVybmFsbHkgdG8gcmVjb25uZWN0IGpvaW50cyBvbiBsb2FkaW5nIGluIHRoZSBlZGl0b3IuICovXHJcbiAgICAvLyBwcml2YXRlIHN0YXRpYyBnZXRCb2R5QnlJRChfaWQ6IG51bWJlcik6IENvbXBvbmVudFJpZ2lkYm9keSB7XHJcbiAgICAvLyAgIGxldCBib2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsO1xyXG4gICAgLy8gICBQaHlzaWNzLiNhY3RpdmVQaHlzaWNzLmJvZHlMaXN0LmZvckVhY2goKHZhbHVlOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkID0+IHtcclxuICAgIC8vICAgICBpZiAodmFsdWUuaWQgPT0gX2lkKSB7XHJcbiAgICAvLyAgICAgICBib2R5ID0gdmFsdWU7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICB9KTtcclxuICAgIC8vICAgcmV0dXJuIGJvZHk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLyoqIEludGVybmFsIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgZW5kcG9pbnQgb2YgbWF0aGVtYXRpY2FsIHJheS4gQnkgYWRkaW5nIHRoZSBtdWx0aXBsaWVkIGRpcmVjdGlvbiB0byB0aGUgb3JpZ2luLiBcclxuICAgICAgICogVXNlZCBiZWNhdXNlIE9pbW9QaHlzaWNzIGRlZmluZXMgcmF5IGJ5IHN0YXJ0L2VuZC4gQnV0IEdhbWVFbmdpbmVzIGNvbW1vbmx5IHVzZSBvcmlnaW4vZGlyZWN0aW9uLlxyXG4gICAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldFJheUVuZFBvaW50KF9zdGFydDogT0lNTy5WZWMzLCBfZGlyZWN0aW9uOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIpOiBPSU1PLlZlYzMge1xyXG4gICAgICBsZXQgb3JpZ2luOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBvcmlnaW4uc2V0KF9zdGFydC54LCBfc3RhcnQueSwgX3N0YXJ0LnopO1xyXG4gICAgICBsZXQgc2NhbGVkRGlyZWN0aW9uOiBWZWN0b3IzID0gX2RpcmVjdGlvbi5jbG9uZTtcclxuICAgICAgc2NhbGVkRGlyZWN0aW9uLnNjYWxlKF9sZW5ndGgpO1xyXG4gICAgICBsZXQgZW5kcG9pbnQ6IFZlY3RvcjMgPSBWZWN0b3IzLlNVTShzY2FsZWREaXJlY3Rpb24sIG9yaWdpbik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHNjYWxlZERpcmVjdGlvbik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGVuZHBvaW50KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUob3JpZ2luKTtcclxuICAgICAgcmV0dXJuIG5ldyBPSU1PLlZlYzMoZW5kcG9pbnQueCwgZW5kcG9pbnQueSwgZW5kcG9pbnQueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCB0aGUgZGlzdGFuY2UgaW4gd2hpY2ggYSByYXkgaGl0IGJ5IHN1YnRyYWN0aW5nIHBvaW50cyBmcm9tIGVhY2ggb3RoZXIgYW5kIGdldCB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHNxdWFyZWQgcHJvZHVjdCBvZiBlYWNoIGNvbXBvbmVudC4gKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldFJheURpc3RhbmNlKF9vcmlnaW46IFZlY3RvcjMsIF9oaXRQb2ludDogVmVjdG9yMyk6IG51bWJlciB7XHJcbiAgICAgIGxldCBkeDogbnVtYmVyID0gX29yaWdpbi54IC0gX2hpdFBvaW50Lng7XHJcbiAgICAgIGxldCBkeTogbnVtYmVyID0gX29yaWdpbi55IC0gX2hpdFBvaW50Lnk7XHJcbiAgICAgIGxldCBkejogbnVtYmVyID0gX29yaWdpbi56IC0gX2hpdFBvaW50Lno7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmV0dXJucyB0aGUgYWN0dWFsIHVzZWQgd29ybGQgb2YgdGhlIE9JTU8gcGh5c2ljcyBlbmdpbmUuIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkIC0gT25seSBmb3IgYWR2YW5jZWQgdXNlcnMgdGhhdCBuZWVkIHRvIGFjY2VzcyBpdCBkaXJlY3RseSAqL1xyXG4gICAgcHVibGljIGdldE9pbW9Xb3JsZCgpOiBPSU1PLldvcmxkIHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC8qKiBVcGRhdGVzIGFsbCB7QGxpbmsgUmlnaWRib2RpZXN9IGtub3duIHRvIHRoZSBQaHlzaWNzLndvcmxkIHRvIG1hdGNoIHRoZWlyIGNvbnRhaW5lcnMgb3IgbWVzaGVzIHRyYW5zZm9ybWF0aW9ucyAqL1xyXG4gICAgLy8gcHJpdmF0ZSB1cGRhdGVXb3JsZEZyb21Xb3JsZE1hdHJpeChfdG9NZXNoOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgIC8vICAgZm9yIChsZXQgYm9keSBvZiB0aGlzLmJvZHlMaXN0KVxyXG4gICAgLy8gICAgIGJvZHkudXBkYXRlRnJvbVdvcmxkKF90b01lc2gpO1xyXG4gICAgLy8gfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogRGVmaW5lcyBhIHRocmVlZGltZW5zaW9uYWwgYm94IGJ5IHR3byBjb3JuZXItcG9pbnRzLCBvbmUgd2l0aCBtaW5pbWFsIHZhbHVlcyBhbmQgb25lIHdpdGggbWF4aW11bSB2YWx1ZXNcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBCb3ggaW1wbGVtZW50cyBSZWN5Y2FibGUge1xuICAgIHB1YmxpYyBtaW46IFZlY3RvcjM7XG4gICAgcHVibGljIG1heDogVmVjdG9yMztcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWluOiBWZWN0b3IzID0gVmVjdG9yMy5PTkUoSW5maW5pdHkpLCBfbWF4OiBWZWN0b3IzID0gVmVjdG9yMy5PTkUoLUluZmluaXR5KSkge1xuICAgICAgdGhpcy5zZXQoX21pbiwgX21heCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHRoZSBjb3JuZXJzIG9mIHRoaXMgYm94LCBzdGFuZGFyZCB2YWx1ZXMgYXJlIEluZmluaXR5IGZvciBtaW4sIGFuZCAtSW5maW5pdHkgZm9yIG1heCwgXG4gICAgICogY3JlYXRpbmcgYW4gaW1wb3NzaWJsZSBpbnZlcnRlZCBib3ggdGhhdCBjYW4gbm90IGNvbnRhaW4gYW55IHBvaW50c1xuICAgICAqL1xuICAgIHB1YmxpYyBzZXQoX21pbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKEluZmluaXR5KSwgX21heDogVmVjdG9yMyA9IFZlY3RvcjMuT05FKC1JbmZpbml0eSkpOiB2b2lkIHtcbiAgICAgIHRoaXMubWluID0gX21pbjtcbiAgICAgIHRoaXMubWF4ID0gX21heDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmQgdGhlIGJveCBpZiBuZWNlc3NhcnkgdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcG9pbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZXhwYW5kKF9pbmNsdWRlOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgICB0aGlzLm1pbi5taW4oX2luY2x1ZGUpO1xuICAgICAgdGhpcy5tYXgubWF4KF9pbmNsdWRlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcbiAgICAgIHRoaXMubWluLnNldChJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5KTtcbiAgICAgIHRoaXMubWF4LnNldCgtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFN0b3JlcyBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSB7QGxpbmsgUmVuZGVyfS1waWNraW5nIGUuZy4gdXNpbmcge0BsaW5rIFBpY2tlcn0gYW5kIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGZ1cnRoZXIgY2FsY3VsYXRpb24gb2YgcG9zaXRpb25zIGFuZCBub3JtYWxzIGV0Yy5cbiAgICogXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXG4gICAqL1xuICBleHBvcnQgY2xhc3MgUGljayB7XG4gICAgcHVibGljIG5vZGU6IE5vZGU7XG4gICAgcHVibGljIHpCdWZmZXI6IG51bWJlcjtcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xuICAgIHB1YmxpYyB0ZXh0dXJlVVY6IFZlY3RvcjI7XG4gICAgI210eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQ7XG4gICAgI3Bvc1dvcmxkOiBWZWN0b3IzO1xuICAgICNwb3NNZXNoOiBWZWN0b3IzO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ub2RlOiBOb2RlKSB7XG4gICAgICB0aGlzLm5vZGUgPSBfbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3NvciB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHdvcmxkIHBvc2l0aW9uIG9mIGludGVyc2VjdGlvbiBvZiB7QGxpbmsgUmF5fSBhbmQge0BsaW5rIE1lc2h9IG9ubHkgd2hlbiB1c2VkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcG9zV29ybGQoKTogVmVjdG9yMyB7XG4gICAgICBpZiAodGhpcy4jcG9zV29ybGQpXG4gICAgICAgIHJldHVybiB0aGlzLiNwb3NXb3JsZDtcbiAgICAgIGxldCBwb2ludEluQ2xpcFNwYWNlOiBWZWN0b3IzID0gVmVjdG9yMy5aKHRoaXMuekJ1ZmZlcik7XG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gdGhpcy4jbXR4Vmlld1RvV29ybGQuZ2V0KCk7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihwb2ludEluQ2xpcFNwYWNlLCB0aGlzLiNtdHhWaWV3VG9Xb3JsZCwgdHJ1ZSk7XG4gICAgICBsZXQgdzogbnVtYmVyID0gbVszXSAqIHBvaW50SW5DbGlwU3BhY2UueCArIG1bN10gKiBwb2ludEluQ2xpcFNwYWNlLnkgKyBtWzExXSAqIHBvaW50SW5DbGlwU3BhY2UueiArIG1bMTVdO1xuICAgICAgcmVzdWx0LnNjYWxlKDEgLyB3KTtcblxuICAgICAgdGhpcy4jcG9zV29ybGQgPSByZXN1bHQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjY2Vzc29yIHRvIGNhbGN1bGF0ZSBhbmQgc3RvcmUgcG9zaXRpb24gaW4gbWVzaC1zcGFjZSBvZiBpbnRlcnNlY3Rpb24gb2Yge0BsaW5rIFJheX0gYW5kIHtAbGluayBNZXNofSBvbmx5IHdoZW4gdXNlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBvc01lc2goKTogVmVjdG9yMyB7XG4gICAgICBpZiAodGhpcy4jcG9zTWVzaClcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Bvc01lc2g7XG4gICAgICBsZXQgbXR4V29ybGRUb01lc2g6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JTlZFUlNJT04odGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKS5tdHhXb3JsZCk7XG4gICAgICBsZXQgcG9zTWVzaDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5wb3NXb3JsZCwgbXR4V29ybGRUb01lc2gpO1xuICAgICAgdGhpcy4jcG9zTWVzaCA9IHBvc01lc2g7XG4gICAgICByZXR1cm4gcG9zTWVzaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY2Nlc3NvciB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHRoZSBmYWNlIG5vcm1hbCBpbiB3b3JsZC1zcGFjZSBhdCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIG9mIHtAbGluayBSYXl9IGFuZCB7QGxpbmsgTWVzaH0gb25seSB3aGVuIHVzZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBub3JtYWwoKTogVmVjdG9yMyB7XG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzO1xuXG4gICAgICBmb3IgKGxldCBmYWNlIG9mIGNtcE1lc2gubWVzaC5mYWNlcykge1xuICAgICAgICBpZiAoZmFjZS5pc0luc2lkZSh0aGlzLnBvc01lc2gpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFjZS5ub3JtYWwuY2xvbmU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnRyYW5zZm9ybShjbXBNZXNoLm10eFdvcmxkLCBmYWxzZSk7XG4gICAgICByZXN1bHQubm9ybWFsaXplKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBzb2xlbHkgYnkgdGhlIHJlbmRlcmVyIHRvIGVuYWJsZSBjYWxjdWxhdGlvbiBvZiB0aGUgd29ybGQgY29vcmRpbmF0ZXMgb2YgdGhpcyB7QGxpbmsgUGlja31cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IG10eFZpZXdUb1dvcmxkKF9tdHhWaWV3VG9Xb3JsZDogTWF0cml4NHg0KSB7XG4gICAgICB0aGlzLiNtdHhWaWV3VG9Xb3JsZCA9IF9tdHhWaWV3VG9Xb3JsZDtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIFByb3ZpZGVzIHN0YXRpYyBtZXRob2RzIGZvciBwaWNraW5nIHVzaW5nIHtAbGluayBSZW5kZXJ9XG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXG4gICAqL1xuICBleHBvcnQgY2xhc3MgUGlja2VyIHtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHJheSBwbHVzIG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgdGhlIG5lYXIgYW5kIGZhciBwbGFuZXMgdG8gY29uc3RydWN0IHRoZSBwaWNrZXItY2FtZXJhLFxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwaWNrUmF5KF9ub2RlczogTm9kZVtdLCBfcmF5OiBSYXksIF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogUGlja1tdIHtcbiAgICAgIGxldCBjbXBDYW1lcmFQaWNrOiBDb21wb25lbnRDYW1lcmEgPSBuZXcgQ29tcG9uZW50Q2FtZXJhKCk7XG4gICAgICBjbXBDYW1lcmFQaWNrLm10eFBpdm90LnRyYW5zbGF0aW9uID0gX3JheS5vcmlnaW47XG4gICAgICBjbXBDYW1lcmFQaWNrLm10eFBpdm90Lmxvb2tBdChWZWN0b3IzLlNVTShfcmF5Lm9yaWdpbiwgX3JheS5kaXJlY3Rpb24pKTtcbiAgICAgIGNtcENhbWVyYVBpY2sucHJvamVjdENlbnRyYWwoMSwgMC4wMDEsIEZJRUxEX09GX1ZJRVcuRElBR09OQUwsIF9taW4sIF9tYXgpO1xuXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFJlbmRlci5waWNrQnJhbmNoKF9ub2RlcywgY21wQ2FtZXJhUGljayk7XG4gICAgICByZXR1cm4gcGlja3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBjYW1lcmEgYW5kIGEgcG9pbnQgb24gaXRzIHZpcnR1YWwgbm9ybWVkIHByb2plY3Rpb24gcGxhbmUgKGRpc3RhbmNlIDEpIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcbiAgICAgKiB0aGVuIHJlbmRlcnMgdGhlIHBpY2stdGV4dHVyZSBhbmQgcmV0dXJucyBhbiB1bnNvcnRlZCB7QGxpbmsgUGlja30tYXJyYXkgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0cyBvZiB0aGUgcmF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGlja0NhbWVyYShfbm9kZXM6IE5vZGVbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfcG9zUHJvamVjdGlvbjogVmVjdG9yMik6IFBpY2tbXSB7XG4gICAgICBsZXQgcmF5OiBSYXkgPSBuZXcgUmF5KG5ldyBWZWN0b3IzKC1fcG9zUHJvamVjdGlvbi54LCBfcG9zUHJvamVjdGlvbi55LCAxKSk7XG4gICAgICBsZXQgbGVuZ3RoOiBudW1iZXIgPSByYXkuZGlyZWN0aW9uLm1hZ25pdHVkZTtcblxuICAgICAgaWYgKF9jbXBDYW1lcmEubm9kZSkge1xuICAgICAgICBsZXQgbXR4Q2FtZXJhOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX2NtcENhbWVyYS5ub2RlLm10eFdvcmxkLCBfY21wQ2FtZXJhLm10eFBpdm90KTtcbiAgICAgICAgcmF5LnRyYW5zZm9ybShtdHhDYW1lcmEpO1xuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhDYW1lcmEpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJheS50cmFuc2Zvcm0oX2NtcENhbWVyYS5tdHhQaXZvdCk7XG5cbiAgICAgIGxldCBwaWNrczogUGlja1tdID0gUGlja2VyLnBpY2tSYXkoX25vZGVzLCByYXksIGxlbmd0aCAqIF9jbXBDYW1lcmEuZ2V0TmVhcigpLCBsZW5ndGggKiBfY21wQ2FtZXJhLmdldEZhcigpKTtcbiAgICAgIHJldHVybiBwaWNrcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgY2FtZXJhIG9mIHRoZSBnaXZlbiB2aWV3cG9ydCBhbmQgYSBwb2ludCB0aGUgY2xpZW50IHN1cmZhY2UgdG8gY29uc3RydWN0IHRoZSBwaWNrZXItY2FtZXJhLFxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwaWNrVmlld3BvcnQoX3ZpZXdwb3J0OiBWaWV3cG9ydCwgX3Bvc0NsaWVudDogVmVjdG9yMik6IFBpY2tbXSB7XG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IF92aWV3cG9ydC5wb2ludENsaWVudFRvUHJvamVjdGlvbihfcG9zQ2xpZW50KTtcbiAgICAgIGxldCBub2RlczogTm9kZVtdID0gQXJyYXkuZnJvbShfdmlld3BvcnQuZ2V0QnJhbmNoKCkuZ2V0SXRlcmF0b3IodHJ1ZSkpO1xuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBQaWNrZXIucGlja0NhbWVyYShub2RlcywgX3ZpZXdwb3J0LmNhbWVyYSwgcG9zUHJvamVjdGlvbik7XG4gICAgICByZXR1cm4gcGlja3M7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBEZWZpbmVkIGJ5IGFuIG9yaWdpbiBhbmQgYSBkaXJlY3Rpb24gb2YgdHlwZSB7QGxpbmsgUGlja30sIHJheXMgYXJlIHVzZWQgdG8gY2FsY3VsYXRlIHBpY2tpbmcgYW5kIGludGVyc2VjdGlvbnNcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBSYXkge1xuICAgIHB1YmxpYyBvcmlnaW46IFZlY3RvcjM7XG4gICAgcHVibGljIGRpcmVjdGlvbjogVmVjdG9yMztcbiAgICAvKiogVE9ETzogc3VwcG9ydCBsZW5ndGggKi9cbiAgICBwdWJsaWMgbGVuZ3RoOiBudW1iZXI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2RpcmVjdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWigxKSwgX29yaWdpbjogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpLCBfbGVuZ3RoOiBudW1iZXIgPSAxKSB7XG4gICAgICB0aGlzLm9yaWdpbiA9IF9vcmlnaW47XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XG4gICAgICB0aGlzLmxlbmd0aCA9IF9sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIG9mIHRoaXMgcmF5IHdpdGggYSBwbGFuZSBkZWZpbmVkIGJ5IFxuICAgICAqIHRoZSBnaXZlbiBwb2ludCBvZiBvcmlnaW4gYW5kIHRoZSBwbGFuZXMgbm9ybWFsLiBBbGwgdmFsdWVzIGFuZCBjYWxjdWxhdGlvbnNcbiAgICAgKiBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtLCBwcmVmZXJhYmx5IHRoZSB3b3JsZFxuICAgICAqL1xuICAgIHB1YmxpYyBpbnRlcnNlY3RQbGFuZShfb3JpZ2luOiBWZWN0b3IzLCBfbm9ybWFsOiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfb3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgICBsZXQgZmFjdG9yOiBudW1iZXIgPSBWZWN0b3IzLkRPVChkaWZmZXJlbmNlLCBfbm9ybWFsKSAvIFZlY3RvcjMuRE9UKHRoaXMuZGlyZWN0aW9uLCBfbm9ybWFsKTtcbiAgICAgIGxldCBpbnRlcnNlY3Q6IFZlY3RvcjMgPSBWZWN0b3IzLlNVTSh0aGlzLm9yaWdpbiwgVmVjdG9yMy5TQ0FMRSh0aGlzLmRpcmVjdGlvbiwgZmFjdG9yKSk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0aGlzIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSB0aGUgZmFjZS4gXG4gICAgICogQWxsIHZhbHVlcyBhbmQgY2FsY3VsYXRpb25zIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkXG4gICAgICovXG4gICAgcHVibGljIGludGVyc2VjdEZhY2VQbGFuZShfZmFjZTogRmFjZSk6IFZlY3RvcjMge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0UGxhbmUoX2ZhY2UuZ2V0UG9zaXRpb24oMCksIF9mYWNlLm5vcm1hbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgZnJvbSB0aGUgcmF5IHRvIHRoZSBnaXZlbiB0YXJnZXQgcG9pbnQuXG4gICAgICogQWxsIHZhbHVlcyBhbmQgY2FsY3VsYXRpb25zIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXREaXN0YW5jZShfdGFyZ2V0OiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgICBsZXQgb3JpZ2luVG9UYXJnZXQ6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgdGhpcy5vcmlnaW4pO1xuICAgICAgbGV0IHJheVNlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5kaXJlY3Rpb24sIDEpO1xuICAgICAgbGV0IHByb2plY3RlZExlbmd0aDogbnVtYmVyID0gVmVjdG9yMy5ET1Qob3JpZ2luVG9UYXJnZXQsIHJheVNlY3Rpb24pO1xuICAgICAgcmF5U2VjdGlvbi5zY2FsZShwcm9qZWN0ZWRMZW5ndGgpO1xuICAgICAgcmF5U2VjdGlvbi5hZGQodGhpcy5vcmlnaW4pO1xuICAgICAgbGV0IGRpc3RhbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHJheVNlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRpc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgcmF5IGJ5IHRoZSBnaXZlbiBtYXRyaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCk6IHZvaWQge1xuICAgICAgdGhpcy5vcmlnaW4udHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm0pO1xuICAgICAgdGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVhZGFibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmF5XG4gICAgICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gYG9yaWdpbjogJHt0aGlzLm9yaWdpbi50b1N0cmluZygpfSwgZGlyZWN0aW9uOiAke3RoaXMuZGlyZWN0aW9uLnRvU3RyaW5nKCl9LCBsZW5ndGg6ICR7dGhpcy5sZW5ndGgudG9QcmVjaXNpb24oNSl9YDtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IHR5cGUgTWFwTGlnaHRUeXBlVG9MaWdodExpc3QgPSBNYXA8VHlwZU9mTGlnaHQsIFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0Pj47XG5cbiAgZXhwb3J0IGludGVyZmFjZSBSZW5kZXJQcmVwYXJlT3B0aW9ucyB7XG4gICAgaWdub3JlUGh5c2ljcz86IGJvb2xlYW47XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1haW4gaW50ZXJmYWNlIHRvIHRoZSByZW5kZXIgZW5naW5lLCBoZXJlIFdlYkdMIChzZWUgc3VwZXJjbGFzcyB7QGxpbmsgUmVuZGVyV2ViR0x9IGFuZCB0aGUgUmVuZGVySW5qZWN0b3JzXG4gICAqL1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyIGV4dGVuZHMgUmVuZGVyV2ViR0wge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVjdENsaXA6IFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoLTEsIDEsIDIsIC0yKTtcbiAgICBwdWJsaWMgc3RhdGljIHBpY2tCdWZmZXI6IEludDMyQXJyYXk7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBub2Rlc1BoeXNpY3M6IFJlY3ljYWJsZUFycmF5PE5vZGU+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRzUGljazogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50UGljaz4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGxpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QgPSBuZXcgTWFwKCk7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgbm9kZXNTaW1wbGU6IFJlY3ljYWJsZUFycmF5PE5vZGU+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgbm9kZXNBbHBoYTogUmVjeWNhYmxlQXJyYXk8Tm9kZT4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRzU2tlbGV0b246IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudFNrZWxldG9uPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xuICAgIHByaXZhdGUgc3RhdGljIHRpbWVzdGFtcFVwZGF0ZTogbnVtYmVyO1xuXG4gICAgLy8gVE9ETzogcmVzZWFyY2ggaWYgcGlja2luZyBzaG91bGQgYmUgb3B0aW1pemVkIHVzaW5nIHJhZGl1cyBwaWNraW5nIHRvIGZpbHRlclxuXG4gICAgLy8jcmVnaW9uIFByZXBhcmVcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBpdGVyYXRlcyBvdmVyIHRoZSBicmFuY2ggc3RhcnRpbmcgd2l0aCB0aGUgbm9kZSBnaXZlbiwgcmVjYWxjdWxhdGVzIGFsbCB3b3JsZCB0cmFuc2Zvcm1zLCBcbiAgICAgKiBjb2xsZWN0cyBhbGwgbGlnaHRzIGFuZCBmZWVkcyBhbGwgc2hhZGVycyB1c2VkIGluIHRoZSBncmFwaCB3aXRoIHRoZXNlIGxpZ2h0cy4gU29ydHMgbm9kZXMgZm9yIGRpZmZlcmVudFxuICAgICAqIHJlbmRlciBwYXNzZXMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwcmVwYXJlKF9icmFuY2g6IE5vZGUsIF9vcHRpb25zOiBSZW5kZXJQcmVwYXJlT3B0aW9ucyA9IHt9LCBfbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpLCBfc2hhZGVyc1VzZWQ6IChTaGFkZXJJbnRlcmZhY2UpW10gPSBudWxsKTogdm9pZCB7XG4gICAgICBsZXQgZmlyc3RMZXZlbDogYm9vbGVhbiA9IChfc2hhZGVyc1VzZWQgPT0gbnVsbCk7XG4gICAgICBpZiAoZmlyc3RMZXZlbCkge1xuICAgICAgICBfc2hhZGVyc1VzZWQgPSBbXTtcbiAgICAgICAgUmVuZGVyLnRpbWVzdGFtcFVwZGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBSZW5kZXIubm9kZXNTaW1wbGUucmVzZXQoKTtcbiAgICAgICAgUmVuZGVyLm5vZGVzQWxwaGEucmVzZXQoKTtcbiAgICAgICAgUmVuZGVyLm5vZGVzUGh5c2ljcy5yZXNldCgpO1xuICAgICAgICBSZW5kZXIuY29tcG9uZW50c1BpY2sucmVzZXQoKTtcbiAgICAgICAgUmVuZGVyLmNvbXBvbmVudHNTa2VsZXRvbi5yZXNldCgpO1xuICAgICAgICBSZW5kZXIubGlnaHRzLmZvckVhY2goX2FycmF5ID0+IF9hcnJheS5yZXNldCgpKTtcbiAgICAgICAgX2JyYW5jaC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5SRU5ERVJfUFJFUEFSRV9TVEFSVCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9icmFuY2guaXNBY3RpdmUpXG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgYWRkIGJyYW5jaCB0byByZW5kZXIgbGlzdCBpZiBub3QgYWN0aXZlXG5cbiAgICAgIF9icmFuY2gubk5vZGVzSW5CcmFuY2ggPSAxO1xuICAgICAgX2JyYW5jaC5yYWRpdXMgPSAwO1xuXG4gICAgICBfYnJhbmNoLmRpc3BhdGNoRXZlbnRUb1RhcmdldE9ubHkobmV3IEV2ZW50KEVWRU5ULlJFTkRFUl9QUkVQQVJFKSk7XG4gICAgICBfYnJhbmNoLnRpbWVzdGFtcFVwZGF0ZSA9IFJlbmRlci50aW1lc3RhbXBVcGRhdGU7XG5cbiAgICAgIGlmIChfYnJhbmNoLmNtcFRyYW5zZm9ybSAmJiBfYnJhbmNoLmNtcFRyYW5zZm9ybS5pc0FjdGl2ZSkge1xuICAgICAgICBsZXQgbXR4V29ybGRCcmFuY2g6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfbXR4V29ybGQsIF9icmFuY2guY21wVHJhbnNmb3JtLm10eExvY2FsKTtcbiAgICAgICAgX2JyYW5jaC5tdHhXb3JsZC5zZXQobXR4V29ybGRCcmFuY2gpO1xuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhXb3JsZEJyYW5jaCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgX2JyYW5jaC5tdHhXb3JsZC5zZXQoX210eFdvcmxkKTsgLy8gb3ZlcndyaXRlIHJlYWRvbmx5IG10eFdvcmxkIG9mIHRoZSBjdXJyZW50IG5vZGVcblxuICAgICAgbGV0IGNtcFJpZ2lkYm9keTogQ29tcG9uZW50UmlnaWRib2R5ID0gX2JyYW5jaC5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KTtcbiAgICAgIGlmIChjbXBSaWdpZGJvZHkgJiYgY21wUmlnaWRib2R5LmlzQWN0aXZlKSB7IC8vVE9ETzogc3VwcG9ydCBkZS0vYWN0aXZhdGlvbiB0aHJvdWdob3V0XG4gICAgICAgIFJlbmRlci5ub2Rlc1BoeXNpY3MucHVzaChfYnJhbmNoKTsgLy8gYWRkIHRoaXMgbm9kZSB0byBwaHlzaWNzIGxpc3RcbiAgICAgICAgaWYgKCFfb3B0aW9ucz8uaWdub3JlUGh5c2ljcylcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybUJ5UGh5c2ljcyhfYnJhbmNoLCBjbXBSaWdpZGJvZHkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY21wUGljazogQ29tcG9uZW50UGljayA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudFBpY2spO1xuICAgICAgaWYgKGNtcFBpY2sgJiYgY21wUGljay5pc0FjdGl2ZSkge1xuICAgICAgICBSZW5kZXIuY29tcG9uZW50c1BpY2sucHVzaChjbXBQaWNrKTsgLy8gYWRkIHRoaXMgY29tcG9uZW50IHRvIHBpY2sgbGlzdFxuICAgICAgfVxuXG4gICAgICBsZXQgY21wTGlnaHRzOiBDb21wb25lbnRMaWdodFtdID0gX2JyYW5jaC5nZXRDb21wb25lbnRzKENvbXBvbmVudExpZ2h0KTtcbiAgICAgIFJlbmRlci5hZGRMaWdodHMoY21wTGlnaHRzKTtcblxuICAgICAgbGV0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcbiAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XG5cbiAgICAgIGlmIChjbXBNZXNoICYmIGNtcE1lc2guaXNBY3RpdmUgJiYgY21wTWF0ZXJpYWwgJiYgY21wTWF0ZXJpYWwuaXNBY3RpdmUpIHtcbiAgICAgICAgbGV0IG10eFdvcmxkTWVzaDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9icmFuY2gubXR4V29ybGQsIGNtcE1lc2gubXR4UGl2b3QpO1xuICAgICAgICBjbXBNZXNoLm10eFdvcmxkLnNldChtdHhXb3JsZE1lc2gpO1xuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhXb3JsZE1lc2gpOyAvLyBUT0RPOiBleGFtaW5lLCB3aHkgcmVjeWNsaW5nIHRoaXMgY2F1c2VzIG1lc2hlcyB0byBiZSBtaXNwbGFjZWQuLi5cbiAgICAgICAgbGV0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuZ2V0U2hhZGVyKCk7XG4gICAgICAgIGxldCBjbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0gPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk7XG4gICAgICAgIGlmIChjbXBQYXJ0aWNsZVN5c3RlbSAmJiBjbXBQYXJ0aWNsZVN5c3RlbS5pc0FjdGl2ZSAmJiBjbXBQYXJ0aWNsZVN5c3RlbS5wYXJ0aWNsZVN5c3RlbSAhPSBudWxsKVxuICAgICAgICAgIHNoYWRlciA9IGNtcFBhcnRpY2xlU3lzdGVtLnBhcnRpY2xlU3lzdGVtLmdldFNoYWRlckZyb20oc2hhZGVyKTtcbiAgICAgICAgaWYgKF9zaGFkZXJzVXNlZC5pbmRleE9mKHNoYWRlcikgPCAwKVxuICAgICAgICAgIF9zaGFkZXJzVXNlZC5wdXNoKHNoYWRlcik7XG4gICAgICAgIF9icmFuY2gucmFkaXVzID0gY21wTWVzaC5yYWRpdXM7XG4gICAgICAgIGlmIChjbXBNYXRlcmlhbC5zb3J0Rm9yQWxwaGEpXG4gICAgICAgICAgUmVuZGVyLm5vZGVzQWxwaGEucHVzaChfYnJhbmNoKTsgLy8gYWRkIHRoaXMgbm9kZSB0byByZW5kZXIgbGlzdFxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVuZGVyLm5vZGVzU2ltcGxlLnB1c2goX2JyYW5jaCk7IC8vIGFkZCB0aGlzIG5vZGUgdG8gcmVuZGVyIGxpc3RcbiAgICAgIH1cblxuICAgICAgbGV0IGNtcFNrZWxldG9uczogQ29tcG9uZW50U2tlbGV0b25bXSA9IF9icmFuY2guZ2V0Q29tcG9uZW50cyhDb21wb25lbnRTa2VsZXRvbik7XG4gICAgICBmb3IgKGxldCBjbXBTa2VsZXRvbiBvZiBjbXBTa2VsZXRvbnMpIFxuICAgICAgICBpZiAoY21wU2tlbGV0b24gJiYgY21wU2tlbGV0b24uaXNBY3RpdmUpXG4gICAgICAgICAgUmVuZGVyLmNvbXBvbmVudHNTa2VsZXRvbi5wdXNoKGNtcFNrZWxldG9uKTtcblxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgX2JyYW5jaC5nZXRDaGlsZHJlbigpKSB7XG4gICAgICAgIFJlbmRlci5wcmVwYXJlKGNoaWxkLCBfb3B0aW9ucywgX2JyYW5jaC5tdHhXb3JsZCwgX3NoYWRlcnNVc2VkKTtcblxuICAgICAgICBfYnJhbmNoLm5Ob2Rlc0luQnJhbmNoICs9IGNoaWxkLm5Ob2Rlc0luQnJhbmNoO1xuICAgICAgICBsZXQgY21wTWVzaENoaWxkOiBDb21wb25lbnRNZXNoID0gY2hpbGQuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xuICAgICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBjbXBNZXNoQ2hpbGQgPyBjbXBNZXNoQ2hpbGQubXR4V29ybGQudHJhbnNsYXRpb24gOiBjaGlsZC5tdHhXb3JsZC50cmFuc2xhdGlvbjtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZTtcbiAgICAgICAgX2JyYW5jaC5yYWRpdXMgPSBNYXRoLm1heChfYnJhbmNoLnJhZGl1cywgcG9zaXRpb24uZ2V0RGlzdGFuY2UoX2JyYW5jaC5tdHhXb3JsZC50cmFuc2xhdGlvbikgKyBjaGlsZC5yYWRpdXMpO1xuICAgICAgICBSZWN5Y2xlci5zdG9yZShwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdExldmVsKSB7XG4gICAgICAgIGZvciAoY29uc3QgY21wU2tlbGV0b24gb2YgUmVuZGVyLmNvbXBvbmVudHNTa2VsZXRvbikge1xuICAgICAgICAgIGNtcFNrZWxldG9uLnVwZGF0ZSgpO1xuICAgICAgICAgIGNtcFNrZWxldG9uLnVwZGF0ZVJlbmRlckJ1ZmZlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2JyYW5jaC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5SRU5ERVJfUFJFUEFSRV9FTkQpKTtcbiAgICAgICAgUmVuZGVyLnVwZGF0ZUxpZ2h0c1VCTyhSZW5kZXIubGlnaHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGdpdmVuIGxpZ2h0cyB0byB0aGUge0BsaW5rIFJlbmRlci5saWdodHN9LW1hcCwgc29ydGVkIGJ5IHR5cGUuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhZGRMaWdodHMoX2NtcExpZ2h0czogQ29tcG9uZW50TGlnaHRbXSk6IHZvaWQge1xuICAgICAgZm9yIChsZXQgY21wTGlnaHQgb2YgX2NtcExpZ2h0cykge1xuICAgICAgICBpZiAoIWNtcExpZ2h0LmlzQWN0aXZlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCB0eXBlOiBUeXBlT2ZMaWdodCA9IGNtcExpZ2h0LmxpZ2h0LmdldFR5cGUoKTtcbiAgICAgICAgbGV0IGxpZ2h0c09mVHlwZTogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50TGlnaHQ+ID0gUmVuZGVyLmxpZ2h0cy5nZXQodHlwZSk7XG4gICAgICAgIGlmICghbGlnaHRzT2ZUeXBlKSB7XG4gICAgICAgICAgbGlnaHRzT2ZUeXBlID0gbmV3IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0PigpO1xuICAgICAgICAgIFJlbmRlci5saWdodHMuc2V0KHR5cGUsIGxpZ2h0c09mVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlnaHRzT2ZUeXBlLnB1c2goY21wTGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBQaWNraW5nXG4gICAgLyoqXG4gICAgICogVXNlZCB3aXRoIGEge0BsaW5rIFBpY2tlcn0tY2FtZXJhLCB0aGlzIG1ldGhvZCByZW5kZXJzIG9uZSBwaXhlbCB3aXRoIHBpY2tpbmcgaW5mb3JtYXRpb24gXG4gICAgICogZm9yIGVhY2ggbm9kZSBpbiB0aGUgbGluZSBvZiBzaWdodCBhbmQgcmV0dXJuIHRoYXQgYXMgYW4gdW5zb3J0ZWQge0BsaW5rIFBpY2t9LWFycmF5XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBwaWNrQnJhbmNoKF9ub2RlczogTm9kZVtdLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiBQaWNrW10geyAvLyBUT0RPOiBzZWUgaWYgdGhpcmQgcGFyYW1ldGVyIF93b3JsZD86IE1hdHJpeDR4NCB3b3VsZCBiZSB1c2VmdWxsXG4gICAgICBSZW5kZXIuxpJwaWNrZWQgPSBbXTtcbiAgICAgIGxldCBzaXplOiBudW1iZXIgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KF9ub2Rlcy5sZW5ndGgpKTtcbiAgICAgIFJlbmRlci5jcmVhdGVQaWNrVGV4dHVyZShzaXplKTtcbiAgICAgIFJlbmRlci5zZXRCbGVuZE1vZGUoQkxFTkQuT1BBUVVFKTtcblxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbm9kZXMpIHtcbiAgICAgICAgbGV0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcbiAgICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCA9IG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcbiAgICAgICAgaWYgKGNtcE1lc2ggJiYgY21wTWVzaC5pc0FjdGl2ZSAmJiBjbXBNYXRlcmlhbCAmJiBjbXBNYXRlcmlhbC5pc0FjdGl2ZSkge1xuICAgICAgICAgIC8vIGxldCBtdHhNZXNoVG9WaWV3OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX2NtcENhbWVyYS5tdHhXb3JsZFRvVmlldywgY21wTWVzaC5tdHhXb3JsZCk7XG4gICAgICAgICAgUmVuZGVyLnBpY2sobm9kZSwgbm9kZS5tdHhXb3JsZCwgX2NtcENhbWVyYSk7XG4gICAgICAgICAgLy8gUmVuZGVyUGFydGljbGVzLmRyYXdQYXJ0aWNsZXMoKTtcbiAgICAgICAgICAvLyBSZWN5Y2xlci5zdG9yZShtdHhNZXNoVG9WaWV3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSZW5kZXIuc2V0QmxlbmRNb2RlKEJMRU5ELlRSQU5TUEFSRU5UKTtcblxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBSZW5kZXIuZ2V0UGlja3Moc2l6ZSwgX2NtcENhbWVyYSk7XG4gICAgICBSZW5kZXIucmVzZXRGcmFtZUJ1ZmZlcigpO1xuICAgICAgcmV0dXJuIHBpY2tzO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuICAgIC8vI3JlZ2lvbiBEcmF3aW5nXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHNjZW5lIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIGdpdmVuIGNhbWVyYVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiB2b2lkIHtcbiAgICAgIF9jbXBDYW1lcmEucmVzZXRXb3JsZFRvVmlldygpO1xuICAgICAgUmVuZGVyLmRyYXdMaXN0KF9jbXBDYW1lcmEsIHRoaXMubm9kZXNTaW1wbGUpO1xuICAgICAgUmVuZGVyLmRyYXdMaXN0QWxwaGEoX2NtcENhbWVyYSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZHJhd0xpc3RBbHBoYShfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiB2b2lkIHtcbiAgICAgIGZ1bmN0aW9uIHNvcnQoX2E6IE5vZGUsIF9iOiBOb2RlKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIChSZWZsZWN0LmdldChfYSwgXCJ6Q2FtZXJhXCIpIDwgUmVmbGVjdC5nZXQoX2IsIFwiekNhbWVyYVwiKSkgPyAxIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBub2RlIG9mIFJlbmRlci5ub2Rlc0FscGhhKVxuICAgICAgICBSZWZsZWN0LnNldChub2RlLCBcInpDYW1lcmFcIiwgX2NtcENhbWVyYS5wb2ludFdvcmxkVG9DbGlwKG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpLm10eFdvcmxkLnRyYW5zbGF0aW9uKS56KTtcblxuICAgICAgbGV0IHNvcnRlZDogTm9kZVtdID0gUmVuZGVyLm5vZGVzQWxwaGEuZ2V0U29ydGVkKHNvcnQpO1xuICAgICAgUmVuZGVyLmRyYXdMaXN0KF9jbXBDYW1lcmEsIHNvcnRlZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZHJhd0xpc3QoX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfbGlzdDogUmVjeWNhYmxlQXJyYXk8Tm9kZT4gfCBBcnJheTxOb2RlPik6IHZvaWQge1xuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbGlzdCkge1xuICAgICAgICBSZW5kZXIuZHJhd05vZGUobm9kZSwgX2NtcENhbWVyYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFBoeXNpY3NcbiAgICBwcml2YXRlIHN0YXRpYyB0cmFuc2Zvcm1CeVBoeXNpY3MoX25vZGU6IE5vZGUsIF9jbXBSaWdpZGJvZHk6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQge1xuICAgICAgaWYgKCFfY21wUmlnaWRib2R5LmlzSW5pdGlhbGl6ZWQpIC8vIHx8IFByb2plY3QubW9kZSA9PSBNT0RFLkVESVRPUilcbiAgICAgICAgX2NtcFJpZ2lkYm9keS5pbml0aWFsaXplKCk7XG5cbiAgICAgIGlmICghUGh5c2ljcy5nZXRCb2R5TGlzdCgpLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBpZiAoIV9ub2RlLm10eExvY2FsKSB7XG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJDb21wb25lbnRSaWdpZGJvZHkgcmVxdWlyZXMgQ29tcG9uZW50VHJhbnNmb3JtIGF0IHRoZSBzYW1lIE5vZGVcIikpO1xuICAgICAgfVxuXG4gICAgICBfY21wUmlnaWRib2R5LmNoZWNrQ29sbGlzaW9uRXZlbnRzKCk7XG5cbiAgICAgIGlmIChfY21wUmlnaWRib2R5LnR5cGVCb2R5ID09IEJPRFlfVFlQRS5LSU5FTUFUSUMgfHwgUHJvamVjdC5tb2RlID09IE1PREUuRURJVE9SKSB7IC8vQ2FzZSBvZiBLaW5lbWF0aWMgUmlnaWRib2R5XG4gICAgICAgIGxldCBtdHhQaXZvdFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX25vZGUubXR4V29ybGQsIF9jbXBSaWdpZGJvZHkubXR4UGl2b3RVbnNjYWxlZCk7XG4gICAgICAgIF9jbXBSaWdpZGJvZHkuc2V0UG9zaXRpb24obXR4UGl2b3RXb3JsZC50cmFuc2xhdGlvbik7XG4gICAgICAgIF9jbXBSaWdpZGJvZHkuc2V0Um90YXRpb24obXR4UGl2b3RXb3JsZC5yb3RhdGlvbik7XG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFBpdm90V29ybGQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkNPTlNUUlVDVElPTihcbiAgICAgICAgX2NtcFJpZ2lkYm9keS5nZXRQb3NpdGlvbigpLCBfY21wUmlnaWRib2R5LmdldFJvdGF0aW9uKCksIG51bGwpO1xuICAgICAgbXR4V29ybGQubXVsdGlwbHkoX2NtcFJpZ2lkYm9keS5tdHhQaXZvdEludmVyc2UpO1xuICAgICAgX25vZGUubXR4V29ybGQudHJhbnNsYXRpb24gPSBtdHhXb3JsZC50cmFuc2xhdGlvbjtcbiAgICAgIF9ub2RlLm10eFdvcmxkLnJvdGF0aW9uID0gbXR4V29ybGQucm90YXRpb247XG4gICAgICBsZXQgbXR4TG9jYWw6IE1hdHJpeDR4NCA9IF9ub2RlLmdldFBhcmVudCgpID8gTWF0cml4NHg0LlJFTEFUSVZFKF9ub2RlLm10eFdvcmxkLCBfbm9kZS5nZXRQYXJlbnQoKS5tdHhXb3JsZCkgOiBfbm9kZS5tdHhXb3JsZDtcbiAgICAgIF9ub2RlLm10eExvY2FsLnNldChtdHhMb2NhbCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhXb3JsZCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhMb2NhbCk7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9XG59XG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICBleHBvcnQgaW50ZXJmYWNlIFJlbmRlckJ1ZmZlcnMge1xuICAgIHZlcnRpY2VzPzogV2ViR0xCdWZmZXI7XG4gICAgaW5kaWNlcz86IFdlYkdMQnVmZmVyO1xuICAgIHRleHR1cmVVVnM/OiBXZWJHTEJ1ZmZlcjtcbiAgICBub3JtYWxzPzogV2ViR0xCdWZmZXI7XG4gICAgY29sb3JzPzogV2ViR0xCdWZmZXI7XG4gICAgYm9uZXM/OiBXZWJHTEJ1ZmZlcjtcbiAgICB3ZWlnaHRzPzogV2ViR0xCdWZmZXI7XG4gICAgbkluZGljZXM/OiBudW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0ZWQgaW50byBhIHtAbGluayBNZXNofSwgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBjYWxjdWxhdGVzIGFuZCByZXByZXNlbnRzIHRoZSBtZXNoIGRhdGEgaW4gdGhlIGZvcm0gbmVlZGVkIGJ5IHRoZSByZW5kZXIgZW5naW5lXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFJlbmRlck1lc2gge1xuICAgIHB1YmxpYyBidWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gbnVsbDtcbiAgICBwdWJsaWMgbWVzaDogTWVzaDtcblxuICAgIC8vIFRPRE86IGNvdWxkIG1ha2UgdGhlc2UgamF2YSBzY3JpcHQgcHJpdmF0ZSBpLmUuICN2ZXJ0aWNlcywgI2luZGljZXMuLi5cbiAgICAvKiogdmVydGljZXMgb2YgdGhlIGFjdHVhbCBwb2ludCBjbG91ZCwgc29tZSBwb2ludHMgbWlnaHQgYmUgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gb3JkZXIgdG8gcmVmZXIgdG8gZGlmZmVyZW50IHRleGVscyAqL1xuICAgIHByb3RlY3RlZCDGknZlcnRpY2VzOiBGbG9hdDMyQXJyYXk7XG4gICAgLyoqIGluZGljZXMgdG8gY3JlYXRlIGZhY2VzIGZyb20gdGhlIHZlcnRpY2VzLCByb3RhdGlvbiBkZXRlcm1pbmVzIGRpcmVjdGlvbiBvZiBmYWNlLW5vcm1hbCAqL1xuICAgIHByb3RlY3RlZCDGkmluZGljZXM6IFVpbnQxNkFycmF5O1xuICAgIC8qKiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGljZXMgYnkgdGhlIHBvc2l0aW9uIGluIHRoZSBhcnJheSAqL1xuICAgIHByb3RlY3RlZCDGknRleHR1cmVVVnM6IEZsb2F0MzJBcnJheTtcbiAgICAvKiogdmVydGV4IG5vcm1hbHMgZm9yIHNtb290aCBzaGFkaW5nLCBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB2ZXJ0aWNlcyBkdXJpbmcgcmVuZGVyaW5nICovXG4gICAgcHJvdGVjdGVkIMaSbm9ybWFsczogRmxvYXQzMkFycmF5O1xuICAgIC8qIGNvbG9ycyAqL1xuICAgIHByb3RlY3RlZCDGkmNvbG9yczogRmxvYXQzMkFycmF5O1xuICAgIC8qKiBib25lcyAqL1xuICAgIHByb3RlY3RlZCDGkmJvbmVzOiBVaW50OEFycmF5O1xuICAgIHByb3RlY3RlZCDGkndlaWdodHM6IEZsb2F0MzJBcnJheTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWVzaDogTWVzaCkge1xuICAgICAgdGhpcy5tZXNoID0gX21lc2g7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBib25lcygpOiBVaW50OEFycmF5IHtcbiAgICAgIHJldHVybiB0aGlzLsaSYm9uZXMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXG4gICAgICAgIHRoaXMuxpJib25lcyA9IHRoaXMubWVzaC52ZXJ0aWNlcy5zb21lKF92ZXJ0ZXggPT4gX3ZlcnRleC5ib25lcykgP1xuICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMubWVzaC52ZXJ0aWNlcy5mbGF0TWFwKChfdmVydGV4OiBWZXJ0ZXgsIF9pbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib25lczogQm9uZVtdID0gdGhpcy5tZXNoLnZlcnRpY2VzLmJvbmVzKF9pbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gW2JvbmVzPy5bMF0/LmluZGV4IHx8IDAsIGJvbmVzPy5bMV0/LmluZGV4IHx8IDAsIGJvbmVzPy5bMl0/LmluZGV4IHx8IDAsIGJvbmVzPy5bM10/LmluZGV4IHx8IDBdO1xuICAgICAgICAgIH0pKSA6XG4gICAgICAgICAgdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGJvbmVzKF9pQm9uZXM6IFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMuxpJib25lcyA9IF9pQm9uZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB3ZWlnaHRzKCk6IEZsb2F0MzJBcnJheSB7XG4gICAgICByZXR1cm4gdGhpcy7GkndlaWdodHMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXG4gICAgICAgIHRoaXMuxpJ3ZWlnaHRzID0gdGhpcy5tZXNoLnZlcnRpY2VzLnNvbWUoX3ZlcnRleCA9PiBfdmVydGV4LmJvbmVzKSA/XG4gICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lc2gudmVydGljZXMuZmxhdE1hcCgoX3ZlcnRleDogVmVydGV4LCBfaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm9uZXM6IEJvbmVbXSA9IHRoaXMubWVzaC52ZXJ0aWNlcy5ib25lcyhfaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIFtib25lcz8uWzBdPy53ZWlnaHQgfHwgMCwgYm9uZXM/LlsxXT8ud2VpZ2h0IHx8IDAsIGJvbmVzPy5bMl0/LndlaWdodCB8fCAwLCBib25lcz8uWzNdPy53ZWlnaHQgfHwgMF07XG4gICAgICAgICAgfSkpIDpcbiAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgd2VpZ2h0cyhfd2VpZ2h0czogRmxvYXQzMkFycmF5KSB7XG4gICAgICB0aGlzLsaSd2VpZ2h0cyA9IF93ZWlnaHRzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgdmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcbiAgICAgIHJldHVybiB0aGlzLsaSdmVydGljZXMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCB2ZXJ0ZXggcG9zaXRpb25zIGZyb20gY2xvdWQgaW50byBhIHR5cGVkIGFycmF5XG4gICAgICAgIHRoaXMuxpJ2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoKF92ZXJ0ZXg6IFZlcnRleCwgX2luZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICByZXR1cm4gWy4uLnRoaXMubWVzaC52ZXJ0aWNlcy5wb3NpdGlvbihfaW5kZXgpLmdldCgpXTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgcHVibGljIHNldCB2ZXJ0aWNlcyhfdmVydGljZXM6IEZsb2F0MzJBcnJheSkge1xuICAgICAgdGhpcy7GknZlcnRpY2VzID0gX3ZlcnRpY2VzO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaW5kaWNlcygpOiBVaW50MTZBcnJheSB7XG4gICAgICByZXR1cm4gdGhpcy7GkmluZGljZXMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCBpbmRpY2VzIGZyb20gdGhlIGZhY2VzIGludG8gYSB0eXBlZCBhcnJheVxuICAgICAgICB0aGlzLsaSaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLm1lc2guZmFjZXMuZmxhdE1hcCgoX2ZhY2U6IEZhY2UpID0+IFsuLi5fZmFjZS5pbmRpY2VzXSlcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaW5kaWNlcyhfaW5kaWNlczogVWludDE2QXJyYXkpIHtcbiAgICAgIHRoaXMuxpJpbmRpY2VzID0gX2luZGljZXM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBub3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XG4gICAgICBpZiAodGhpcy7Gkm5vcm1hbHMgPT0gbnVsbCkge1xuICAgICAgICAvLyBzdW0gdXAgYWxsIHVuc2NhbGVkIG5vcm1hbHMgb2YgZmFjZXMgY29ubmVjdGVkIHRvIG9uZSB2ZXJ0ZXguLi5cbiAgICAgICAgdGhpcy5tZXNoLnZlcnRpY2VzLmZvckVhY2goX3ZlcnRleCA9PiBfdmVydGV4Lm5vcm1hbC5zZXQoMCwgMCwgMCkpO1xuICAgICAgICBmb3IgKGxldCBmYWNlIG9mIHRoaXMubWVzaC5mYWNlcylcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCBvZiBmYWNlLmluZGljZXMpIHtcbiAgICAgICAgICAgIHRoaXMubWVzaC52ZXJ0aWNlcy5ub3JtYWwoaW5kZXgpLmFkZChmYWNlLm5vcm1hbFVuc2NhbGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIC8vIC4uLiBhbmQgbm9ybWFsaXplIHRoZW1cbiAgICAgICAgdGhpcy5tZXNoLnZlcnRpY2VzLmZvckVhY2goX3ZlcnRleCA9PiB7XG4gICAgICAgICAgLy8gc29tZSB2ZXJ0aWNlcyBtaWdodCBiZSB1bnVzZWQgYW5kIHlpZWxkIGEgemVyby1ub3JtYWwuLi5cbiAgICAgICAgICBpZiAoX3ZlcnRleC5ub3JtYWwubWFnbml0dWRlU3F1YXJlZCA+IDApXG4gICAgICAgICAgICBfdmVydGV4Lm5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcy7Gkm5vcm1hbHNWZXJ0ZXggPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbHNWZXJ0ZXguZmxhdE1hcCgoX25vcm1hbDogVmVjdG9yMykgPT4gWy4uLl9ub3JtYWwuZ2V0KCldKSk7XG5cbiAgICAgICAgdGhpcy7Gkm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubWVzaC52ZXJ0aWNlcy5mbGF0TWFwKChfdmVydGV4OiBWZXJ0ZXgsIF9pbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFsuLi50aGlzLm1lc2gudmVydGljZXMubm9ybWFsKF9pbmRleCkuZ2V0KCldO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLsaSbm9ybWFscztcbiAgICB9XG4gICAgcHVibGljIHNldCBub3JtYWxzKF9ub3JtYWxzOiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRoaXMuxpJub3JtYWxzID0gX25vcm1hbHM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB0ZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XG4gICAgICByZXR1cm4gdGhpcy7GknRleHR1cmVVVnMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCB1dnMgZnJvbSB0aGUgY2xvdXMgaW50byBhIHR5cGVkIGFycmF5XG4gICAgICAgIHRoaXMuxpJ0ZXh0dXJlVVZzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lc2gudmVydGljZXNcbiAgICAgICAgICAuZmlsdGVyKF92ZXJ0ZXggPT4gX3ZlcnRleC51dilcbiAgICAgICAgICAuZmxhdE1hcCgoX3ZlcnRleDogVmVydGV4KSA9PiBbLi4uX3ZlcnRleC51di5nZXQoKV0pXG4gICAgICAgICkpO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHRleHR1cmVVVnMoX3RleHR1cmVVVnM6IEZsb2F0MzJBcnJheSkge1xuICAgICAgdGhpcy7GknRleHR1cmVVVnMgPSBfdGV4dHVyZVVWcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGNvbG9ycygpOiBGbG9hdDMyQXJyYXkge1xuICAgICAgcmV0dXJuIHRoaXMuxpJjb2xvcnMgfHwgKFxuICAgICAgICB0aGlzLsaSY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lc2gudmVydGljZXNcbiAgICAgICAgICAuZmlsdGVyKF92ZXJ0ZXggPT4gX3ZlcnRleC5jb2xvcilcbiAgICAgICAgICAuZmxhdE1hcChfdmVydGV4ID0+IFsuLi5fdmVydGV4LmNvbG9yLmdldEFycmF5KCldKVxuICAgICAgICApKTtcbiAgICB9XG4gICAgcHVibGljIHNldCBjb2xvcnMoX2NvbG9yczogRmxvYXQzMkFycmF5KSB7XG4gICAgICB0aGlzLsaSY29sb3JzID0gX2NvbG9ycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhpcyByZW5kZXIgbWVzaCBhbmQgYWxsIGl0cyBidWZmZXJzXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgICAgdGhpcy5idWZmZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuxpJ2ZXJ0aWNlcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuxpJpbmRpY2VzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy7GknRleHR1cmVVVnMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLsaSbm9ybWFscyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuxpJjb2xvcnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuxpJib25lcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuxpJ3ZWlnaHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQ29udHJvbHMgdGhlIHJlbmRlcmluZyBvZiBhIGJyYW5jaCwgdXNpbmcgdGhlIGdpdmVuIHtAbGluayBDb21wb25lbnRDYW1lcmF9LFxuICAgKiBhbmQgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSByZW5kZXJlZCBpbWFnZSBmcm9tIHRoZSBvZmZzY3JlZW4gcmVuZGVyYnVmZmVyIHRvIHRoZSB0YXJnZXQgY2FudmFzXG4gICAqIHRocm91Z2ggYSBzZXJpZXMgb2Yge0BsaW5rIEZyYW1pbmd9IG9iamVjdHMuIFRoZSBzdGFnZXMgaW52b2x2ZWQgYXJlIGluIG9yZGVyIG9mIHJlbmRlcmluZ1xuICAgKiB7QGxpbmsgUmVuZGVyfS52aWV3cG9ydCAtPiB7QGxpbmsgVmlld3BvcnR9LnNvdXJjZSAtPiB7QGxpbmsgVmlld3BvcnR9LmRlc3RpbmF0aW9uIC0+IERPTS1DYW52YXMgLT4gQ2xpZW50KENTUylcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOS0yMDIyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9WaWV3cG9ydFxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgRXZlbnRUYXJnZXRVbmlmaWVkIHtcbiAgICBwcml2YXRlIHN0YXRpYyBmb2N1czogVmlld3BvcnQ7XG5cbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJWaWV3cG9ydFwiOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgdmlld3BvcnQgYnkuXG4gICAgcHVibGljIGNhbWVyYTogQ29tcG9uZW50Q2FtZXJhID0gbnVsbDsgLy8gVGhlIGNhbWVyYSByZXByZXNlbnRpbmcgdGhlIHZpZXcgcGFyYW1ldGVycyB0byByZW5kZXIgdGhlIGJyYW5jaC5cbiAgICBwdWJsaWMgcmVjdFNvdXJjZTogUmVjdGFuZ2xlO1xuICAgIHB1YmxpYyByZWN0RGVzdGluYXRpb246IFJlY3RhbmdsZTtcblxuICAgIC8vIFRPRE86IHZlcmlmeSBpZiBjbGllbnQgdG8gY2FudmFzIHNob3VsZCBiZSBpbiBWaWV3cG9ydCBvciBzb21ld2hlcmUgZWxzZSAoV2luZG93LCBDb250YWluZXI/KVxuICAgIC8vIE11bHRpcGxlIHZpZXdwb3J0cyB1c2luZyB0aGUgc2FtZSBjYW52YXMgc2hvdWxkbid0IGRpZmZlciBoZXJlLi4uXG4gICAgLy8gZGlmZmVyZW50IGZyYW1pbmcgbWV0aG9kcyBjYW4gYmUgdXNlZCwgdGhpcyBpcyB0aGUgZGVmYXVsdFxuICAgIHB1YmxpYyBmcmFtZUNsaWVudFRvQ2FudmFzOiBGcmFtaW5nU2NhbGVkID0gbmV3IEZyYW1pbmdTY2FsZWQoKTtcbiAgICBwdWJsaWMgZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uOiBGcmFtaW5nQ29tcGxleCA9IG5ldyBGcmFtaW5nQ29tcGxleCgpO1xuICAgIHB1YmxpYyBmcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2U6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xuICAgIHB1YmxpYyBmcmFtZVNvdXJjZVRvUmVuZGVyOiBGcmFtaW5nU2NhbGVkID0gbmV3IEZyYW1pbmdTY2FsZWQoKTtcblxuICAgIHB1YmxpYyBhZGp1c3RpbmdGcmFtZXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHB1YmxpYyBhZGp1c3RpbmdDYW1lcmE6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHB1YmxpYyBwaHlzaWNzRGVidWdNb2RlOiBQSFlTSUNTX0RFQlVHTU9ERSA9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkU7XG5cbiAgICBwdWJsaWMgY29tcG9uZW50c1BpY2s6IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudFBpY2s+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XG5cbiAgICAjYnJhbmNoOiBOb2RlID0gbnVsbDsgLy8gVGhlIHRvIHJlbmRlciB3aXRoIGFsbCBpdHMgZGVzY2VuZGFudHMuXG4gICAgI2NyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IG51bGw7XG4gICAgI2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgIC8vI2VuZHJlZ2lvblxuXG4gICAgLy8gI3JlZ2lvbiBFdmVudHMgKHBhc3NpbmcgZnJvbSBjYW52YXMgdG8gdmlld3BvcnQgYW5kIGZyb20gdGhlcmUgaW50byBicmFuY2gpXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmlld3BvcnQgY3VycmVudGx5IGhhcyBmb2N1cyBhbmQgdGh1cyByZWNlaXZlcyBrZXlib2FyZCBldmVudHNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIChWaWV3cG9ydC5mb2N1cyA9PSB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZGVzdGluYXRpb24gY2FudmFzXG4gICAgICovXG4gICAgcHVibGljIGdldCBjYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICAgICAgcmV0dXJuIHRoaXMuI2NhbnZhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIDJELWNvbnRleHQgYXR0YWNoZWQgdG8gdGhlIGRlc3RpbmF0aW9uIGNhbnZhc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xuICAgICAgcmV0dXJuIHRoaXMuI2NyYzI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdGhlIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBjYW52YXMgdG8gcmVuZGVyIHRoZSBnaXZlbiBicmFuY2ggdG8gdXNpbmcgdGhlIGdpdmVuIGNhbWVyYS1jb21wb25lbnQsIGFuZCBuYW1lcyB0aGUgdmlld3BvcnQgYXMgZ2l2ZW4uXG4gICAgICovXG4gICAgcHVibGljIGluaXRpYWxpemUoX25hbWU6IHN0cmluZywgX2JyYW5jaDogTm9kZSwgX2NhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XG4gICAgICB0aGlzLmNhbWVyYSA9IF9jYW1lcmE7XG4gICAgICB0aGlzLiNjYW52YXMgPSBfY2FudmFzO1xuICAgICAgdGhpcy4jY3JjMiA9IF9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgdGhpcy4jY2FudmFzLnRhYkluZGV4ID0gMDsgLy8gY2FuIGdldCBmb2N1cyBhbmQgcmVjZWl2ZSBrZXlib2FyZCBldmVudHNcblxuICAgICAgdGhpcy5yZWN0U291cmNlID0gUmVuZGVyLmdldENhbnZhc1JlY3QoKTtcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uID0gdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKTtcblxuICAgICAgdGhpcy5zZXRCcmFuY2goX2JyYW5jaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBzaXplIG9mIHRoZSBkZXN0aW5hdGlvbiBjYW52YXMgYXMgYSByZWN0YW5nbGUsIHggYW5kIHkgYXJlIGFsd2F5cyAwIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDYW52YXNSZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMuI2NhbnZhcy53aWR0aCwgdGhpcy4jY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjbGllbnQgcmVjdGFuZ2xlIHRoZSBjYW52YXMgaXMgZGlzcGxheWVkIGFuZCBmaXQgaW4sIHggYW5kIHkgYXJlIGFsd2F5cyAwIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDbGllbnRSZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcbiAgICAgIC8vIEZVREdFIGRvZXNuJ3QgY2FyZSBhYm91dCB3aGVyZSB0aGUgY2xpZW50IHJlY3QgaXMsIG9ubHkgYWJvdXQgdGhlIHNpemUgbWF0dGVycy5cbiAgICAgIC8vIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMuY2FudmFzLm9mZnNldExlZnQsIHRoaXMuY2FudmFzLm9mZnNldFRvcCwgdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7XG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLiNjYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuI2NhbnZhcy5jbGllbnRIZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYnJhbmNoIHRvIGJlIGRyYXduIGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0QnJhbmNoKF9icmFuY2g6IE5vZGUpOiB2b2lkIHtcbiAgICAgIGlmIChfYnJhbmNoKVxuICAgICAgICBfYnJhbmNoLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkFUVEFDSF9CUkFOQ0gpKTtcbiAgICAgIHRoaXMuI2JyYW5jaCA9IF9icmFuY2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGJyYW5jaCB0aGlzIHZpZXdwb3J0IHJlbmRlcnNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QnJhbmNoKCk6IE5vZGUge1xuICAgICAgcmV0dXJuIHRoaXMuI2JyYW5jaDtcbiAgICB9XG5cbiAgICAvLyAjcmVnaW9uIERyYXdpbmdcbiAgICAvKipcbiAgICAgKiBEcmF3IHRoaXMgdmlld3BvcnQgZGlzcGxheWluZyBpdHMgYnJhbmNoLiBCeSBkZWZhdWx0LCB0aGUgdHJhbnNmb3JtcyBpbiB0aGUgYnJhbmNoIGFyZSByZWNhbGN1bGF0ZWQgZmlyc3QuXG4gICAgICogUGFzcyBgZmFsc2VgIGlmIGNhbGN1bGF0aW9uIHdhcyBhbHJlYWR5IGRvbmUgZm9yIHRoaXMgZnJhbWUgXG4gICAgICovXG4gICAgcHVibGljIGRyYXcoX2NhbGN1bGF0ZVRyYW5zZm9ybXM6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICB0aGlzLmNvbXB1dGVEcmF3aW5nKF9jYWxjdWxhdGVUcmFuc2Zvcm1zKTtcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NEZWJ1Z01vZGUgIT0gUEhZU0lDU19ERUJVR01PREUuUEhZU0lDX09CSkVDVFNfT05MWSlcbiAgICAgICAgUmVuZGVyLmRyYXcodGhpcy5jYW1lcmEpO1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0RlYnVnTW9kZSAhPSBQSFlTSUNTX0RFQlVHTU9ERS5OT05FKSB7XG4gICAgICAgIFBoeXNpY3MuZHJhdyh0aGlzLmNhbWVyYSwgdGhpcy5waHlzaWNzRGVidWdNb2RlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4jY3JjMi5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NyYzIuZHJhd0ltYWdlKFxuICAgICAgICBSZW5kZXIuZ2V0Q2FudmFzKCksXG4gICAgICAgIHRoaXMucmVjdFNvdXJjZS54LCB0aGlzLnJlY3RTb3VyY2UueSwgdGhpcy5yZWN0U291cmNlLndpZHRoLCB0aGlzLnJlY3RTb3VyY2UuaGVpZ2h0LFxuICAgICAgICB0aGlzLnJlY3REZXN0aW5hdGlvbi54LCB0aGlzLnJlY3REZXN0aW5hdGlvbi55LCB0aGlzLnJlY3REZXN0aW5hdGlvbi53aWR0aCwgdGhpcy5yZWN0RGVzdGluYXRpb24uaGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB0cmFuc2Zvcm1zIGluIHRoZSBicmFuY2ggYXJlIHJlY2FsY3VsYXRlZCBoZXJlLlxuICAgICovXG4gICAgcHVibGljIGNvbXB1dGVEcmF3aW5nKF9jYWxjdWxhdGVUcmFuc2Zvcm1zOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgaWYgKCF0aGlzLiNicmFuY2gpXG4gICAgICAgIHJldHVybjtcbiAgICAgIFJlbmRlci5yZXNldEZyYW1lQnVmZmVyKCk7XG4gICAgICBpZiAoIXRoaXMuY2FtZXJhLmlzQWN0aXZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdGcmFtZXMpXG4gICAgICAgIHRoaXMuYWRqdXN0RnJhbWVzKCk7XG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdDYW1lcmEpXG4gICAgICAgIHRoaXMuYWRqdXN0Q2FtZXJhKCk7XG5cbiAgICAgIGlmIChfY2FsY3VsYXRlVHJhbnNmb3JtcylcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUcmFuc2Zvcm1zKCk7XG5cbiAgICAgIFJlbmRlci5jbGVhcih0aGlzLmNhbWVyYS5jbHJCYWNrZ3JvdW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjYXNjYWRlIG9mIHRyYW5zZm9ybXMgaW4gdGhpcyBicmFuY2ggYW5kIHN0b3JlIHRoZSByZXN1bHRzIGFzIG10eFdvcmxkIGluIHRoZSB7QGxpbmsgTm9kZX1zIGFuZCB7QGxpbmsgQ29tcG9uZW50TWVzaH1lcyBcbiAgICAgKi9cbiAgICBwdWJsaWMgY2FsY3VsYXRlVHJhbnNmb3JtcygpOiB2b2lkIHtcbiAgICAgIGxldCBtdHhSb290OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcbiAgICAgIGlmICh0aGlzLiNicmFuY2guZ2V0UGFyZW50KCkpXG4gICAgICAgIG10eFJvb3QgPSB0aGlzLiNicmFuY2guZ2V0UGFyZW50KCkubXR4V29ybGQ7XG4gICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULlJFTkRFUl9QUkVQQVJFX1NUQVJUKSk7IC8vIFRPRE86IHRoZXNlIGV2ZW50cyBzZWVtIHRvIGdldCBmaXJlZCBpbiBSZW5kZXIucHJlcGFyZSBhc3dlbGwsIGNoZWNrIHdoZXJlIHRoZSBzaG91bGQgZ2V0IGZpcmVkXG4gICAgICAvLyB0aGlzLmFkanVzdEZyYW1lcygpOyAvLyBUT0RPOiB0aGlzIGdvdCBjYWxsZWQgdHdpY2UgcGVyIGNvbXB1dGVEcmF3aW5nLCBjaGVjayBpZiBpdCdzIG5lY2Vzc2FyeVxuICAgICAgUmVuZGVyLnByZXBhcmUodGhpcy4jYnJhbmNoLCBudWxsLCBtdHhSb290KTtcbiAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkVfRU5EKSk7IC8vIFRPRE86IHRoZXNlIGV2ZW50cyBzZWVtIHRvIGdldCBmaXJlZCBpbiBSZW5kZXIucHJlcGFyZSBhc3dlbGwsIGNoZWNrIHdoZXJlIHRoZSBzaG91bGQgZ2V0IGZpcmVkXG4gICAgICB0aGlzLmNvbXBvbmVudHNQaWNrID0gUmVuZGVyLmNvbXBvbmVudHNQaWNrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGljayBvbiBhbGwge0BsaW5rIENvbXBvbmVudFBpY2t9cyBpbiB0aGUgYnJhbmNoIG9mIHRoaXMgdmlld3BvcnRcbiAgICAgKiB1c2luZyBhIHJheSBmcm9tIGl0cyBjYW1lcmEgdGhyb3VnaCB0aGUgY2xpZW50IGNvb3JkaW5hdGVzIGdpdmVuIGluIHRoZSBldmVudC5cbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBhbGwgbm9kZXMgaGl0LiAgXG4gICAgICogSWYge0BsaW5rIFBJQ0suQ0FNRVJBfSB3YXMgY2hvc2VuIGFzIHRoZSBtZXRob2QgdG8gcGljaywgYSBwaWNrIHByb3BlcnR5IGdldHMgYWRkZWQgdG8gdGhlIGV2ZW50LCBcbiAgICAgKiB3aGljaCBob2xkcyB0aGUgZGV0YWlsZWQgaW5mb3JtYXRpb24sIGJ1dCBpcyBvdmVyd3JpdHRlbiBmb3IgZWFjaCBub2RlLlxuICAgICAqL1xuICAgIHB1YmxpYyBkaXNwYXRjaFBvaW50ZXJFdmVudChfZXZlbnQ6IFBvaW50ZXJFdmVudCk6IHZvaWQge1xuICAgICAgbGV0IHBvc0NsaWVudDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKF9ldmVudC5jbGllbnRYLCBfZXZlbnQuY2xpZW50WSk7XG4gICAgICBsZXQgcmF5OiBSYXkgPSB0aGlzLmdldFJheUZyb21DbGllbnQocG9zQ2xpZW50KTtcbiAgICAgIC8vIGxldCBjYW1lcmFQaWNrczogUmVjeWNhYmxlQXJyYXk8Tm9kZT4gPSBSZWN5Y2xlci5nZXQoUmVjeWNhYmxlQXJyYXkpOyAvL1RPRE86IHRoaW5rIGFib3V0IG9wdGltaXphdGlvbiBsYXRlclxuICAgICAgbGV0IGNhbWVyYVBpY2tzOiBOb2RlW10gPSBbXTtcbiAgICAgIGxldCBvdGhlclBpY2tzOiBDb21wb25lbnRQaWNrW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGNtcFBpY2sgb2YgdGhpcy5jb21wb25lbnRzUGljaylcbiAgICAgICAgY21wUGljay5waWNrID09IFBJQ0suQ0FNRVJBID8gY2FtZXJhUGlja3MucHVzaChjbXBQaWNrLm5vZGUpIDogb3RoZXJQaWNrcy5wdXNoKGNtcFBpY2spO1xuXG4gICAgICBpZiAoY2FtZXJhUGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwaWNrczogUGlja1tdID0gUGlja2VyLnBpY2tDYW1lcmEoY2FtZXJhUGlja3MsIHRoaXMuY2FtZXJhLCB0aGlzLnBvaW50Q2xpZW50VG9Qcm9qZWN0aW9uKHBvc0NsaWVudCkpO1xuICAgICAgICBmb3IgKGxldCBwaWNrIG9mIHBpY2tzKSB7XG4gICAgICAgICAgUmVmbGVjdC5zZXQoX2V2ZW50LCBcInBpY2tcIiwgcGljayk7XG4gICAgICAgICAgcGljay5ub2RlLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBjbXBQaWNrIG9mIG90aGVyUGlja3MpIHtcbiAgICAgICAgY21wUGljay5waWNrQW5kRGlzcGF0Y2gocmF5LCBfZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBhbGwgZnJhbWVzIGludm9sdmVkIGluIHRoZSByZW5kZXJpbmcgcHJvY2VzcyBmcm9tIHRoZSBkaXNwbGF5IGFyZWEgaW4gdGhlIGNsaWVudCB1cCB0byB0aGUgcmVuZGVyZXIgY2FudmFzXG4gICAgICovXG4gICAgcHVibGljIGFkanVzdEZyYW1lcygpOiB2b2lkIHtcbiAgICAgIC8vIGdldCB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBjYW52YXMgYXJlYSBhcyBkaXNwbGF5ZWQgKGNvbnNpZGVyIGNzcylcbiAgICAgIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xuICAgICAgLy8gYWRqdXN0IHRoZSBjYW52YXMgc2l6ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZyYW1pbmcgYXBwbGllZCB0byBjbGllbnRcbiAgICAgIGxldCByZWN0Q2FudmFzOiBSZWN0YW5nbGUgPSB0aGlzLmZyYW1lQ2xpZW50VG9DYW52YXMuZ2V0UmVjdChyZWN0Q2xpZW50KTtcbiAgICAgIHRoaXMuI2NhbnZhcy53aWR0aCA9IHJlY3RDYW52YXMud2lkdGg7XG4gICAgICB0aGlzLiNjYW52YXMuaGVpZ2h0ID0gcmVjdENhbnZhcy5oZWlnaHQ7XG5cbiAgICAgIGxldCByZWN0VGVtcDogUmVjdGFuZ2xlO1xuICAgICAgLy8gYWRqdXN0IHRoZSBkZXN0aW5hdGlvbiBhcmVhIG9uIHRoZSB0YXJnZXQtY2FudmFzIHRvIHJlbmRlciB0byBieSBhcHBseWluZyB0aGUgZnJhbWluZyB0byBjYW52YXNcbiAgICAgIHJlY3RUZW1wID0gdGhpcy5mcmFtZUNhbnZhc1RvRGVzdGluYXRpb24uZ2V0UmVjdChyZWN0Q2FudmFzKTtcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLmNvcHkocmVjdFRlbXApO1xuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdFRlbXApO1xuICAgICAgLy8gYWRqdXN0IHRoZSBhcmVhIG9uIHRoZSBzb3VyY2UtY2FudmFzIHRvIHJlbmRlciBmcm9tIGJ5IGFwcGx5aW5nIHRoZSBmcmFtaW5nIHRvIGRlc3RpbmF0aW9uIGFyZWFcbiAgICAgIHJlY3RUZW1wID0gdGhpcy5mcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2UuZ2V0UmVjdCh0aGlzLnJlY3REZXN0aW5hdGlvbik7XG4gICAgICB0aGlzLnJlY3RTb3VyY2UuY29weShyZWN0VGVtcCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0VGVtcCk7XG5cbiAgICAgIC8vIGhhdmluZyBhbiBvZmZzZXQgc291cmNlIGRvZXMgbWFrZSBzZW5zZSBvbmx5IHdoZW4gbXVsdGlwbGUgdmlld3BvcnRzIGRpc3BsYXkgcGFydHMgb2YgdGhlIHNhbWUgcmVuZGVyaW5nLiBGb3Igbm93OiBzaGlmdCBpdCB0byAwLDBcbiAgICAgIHRoaXMucmVjdFNvdXJjZS54ID0gdGhpcy5yZWN0U291cmNlLnkgPSAwO1xuICAgICAgLy8gc3RpbGwsIGEgcGFydGlhbCBpbWFnZSBvZiB0aGUgcmVuZGVyaW5nIG1heSBiZSByZXRyaWV2ZWQgYnkgbW92aW5nIGFuZCByZXNpemluZyB0aGUgcmVuZGVyIHZpZXdwb3J0LiBGb3Igbm93LCBpdCdzIGFsd2F5cyBhZGp1c3RlZCB0byB0aGUgY3VycmVudCB2aWV3cG9ydFxuICAgICAgbGV0IHJlY3RSZW5kZXI6IFJlY3RhbmdsZSA9IHRoaXMuZnJhbWVTb3VyY2VUb1JlbmRlci5nZXRSZWN0KHRoaXMucmVjdFNvdXJjZSk7XG4gICAgICBSZW5kZXIuc2V0UmVuZGVyUmVjdGFuZ2xlKHJlY3RSZW5kZXIpO1xuICAgICAgLy8gbm8gbW9yZSB0cmFuc2Zvcm1hdGlvbiBhZnRlciB0aGlzIGZvciBub3csIG9mZnNjcmVlbiBjYW52YXMgYW5kIHJlbmRlci12aWV3cG9ydCBoYXZlIHRoZSBzYW1lIHNpemVcbiAgICAgIFJlbmRlci5zZXRDYW52YXNTaXplKHJlY3RSZW5kZXIud2lkdGgsIHJlY3RSZW5kZXIuaGVpZ2h0KTtcblxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdENsaWVudCk7XG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0Q2FudmFzKTtcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlY3RSZW5kZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgY2FtZXJhIHBhcmFtZXRlcnMgdG8gZml0IHRoZSByZW5kZXJpbmcgaW50byB0aGUgcmVuZGVyIHZpZXBvcnRcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRqdXN0Q2FtZXJhKCk6IHZvaWQge1xuICAgICAgbGV0IHJlY3Q6IFJlY3RhbmdsZSA9IFJlbmRlci5nZXRSZW5kZXJSZWN0YW5nbGUoKTtcbiAgICAgIC8vIGlmICh0aGlzLmNhbWVyYS5nZXRQcm9qZWN0aW9uKCkgPT0gUFJPSkVDVElPTi5PUlRIT0dSQVBISUMpXG4gICAgICAvLyAgIHRoaXMuY2FtZXJhLnByb2plY3RPcnRob2dyYXBoaWMoLXJlY3Qud2lkdGggLyAyMCwgcmVjdC53aWR0aCAvIDIwLCByZWN0LmhlaWdodCAvIDIwLCAtcmVjdC5oZWlnaHQgLyAyMCk7XG4gICAgICAvLyBlbHNlXG4gICAgICB0aGlzLmNhbWVyYS5wcm9qZWN0Q2VudHJhbChcbiAgICAgICAgcmVjdC53aWR0aCAvIHJlY3QuaGVpZ2h0LCB0aGlzLmNhbWVyYS5nZXRGaWVsZE9mVmlldygpLCB0aGlzLmNhbWVyYS5nZXREaXJlY3Rpb24oKSwgdGhpcy5jYW1lcmEuZ2V0TmVhcigpLCB0aGlzLmNhbWVyYS5nZXRGYXIoKVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuXG4gICAgLy8jcmVnaW9uIFBvaW50c1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgUmF5fSBpbiB3b3JsZCBjb29yZGluYXRlcyBmcm9tIHRoaXMgY2FtZXJhIHRocm91Z2ggdGhlIHBvaW50IGdpdmVuIGluIGNsaWVudCBzcGFjZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRSYXlGcm9tQ2xpZW50KF9wb2ludDogVmVjdG9yMik6IFJheSB7XG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX3BvaW50KTtcbiAgICAgIGxldCByYXk6IFJheSA9IG5ldyBSYXkobmV3IFZlY3RvcjMoLXBvc1Byb2plY3Rpb24ueCwgcG9zUHJvamVjdGlvbi55LCAxKSk7XG5cbiAgICAgIC8vIHJheS5kaXJlY3Rpb24uc2NhbGUoY2FtZXJhLmRpc3RhbmNlKTtcbiAgICAgIHJheS50cmFuc2Zvcm0odGhpcy5jYW1lcmEubXR4UGl2b3QpO1xuICAgICAgbGV0IGNhbWVyYU5vZGU6IE5vZGUgPSB0aGlzLmNhbWVyYS5ub2RlO1xuICAgICAgaWYgKGNhbWVyYU5vZGUpXG4gICAgICAgIHJheS50cmFuc2Zvcm0oY2FtZXJhTm9kZS5tdHhXb3JsZCk7XG4gICAgICAgIFxuICAgICAgcmV0dXJuIHJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIHByb2plY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGluIHdvcmxkIHNwYWNlXG4gICAgICovXG4gICAgcHVibGljIHBvaW50V29ybGRUb0NsaWVudChfcG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IyIHtcbiAgICAgIGxldCBwcm9qZWN0aW9uOiBWZWN0b3IzID0gdGhpcy5jYW1lcmEucG9pbnRXb3JsZFRvQ2xpcChfcG9zaXRpb24pO1xuICAgICAgbGV0IHBvc0NsaWVudDogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGlwVG9DbGllbnQocHJvamVjdGlvbi50b1ZlY3RvcjIoKSk7XG4gICAgICByZXR1cm4gcG9zQ2xpZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgc291cmNlLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1NvdXJjZShfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFBvaW50KF9jbGllbnQsIHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCkpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5mcmFtZUNhbnZhc1RvRGVzdGluYXRpb24uZ2V0UG9pbnQocmVzdWx0LCB0aGlzLmdldENhbnZhc1JlY3RhbmdsZSgpKTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZnJhbWVEZXN0aW5hdGlvblRvU291cmNlLmdldFBvaW50KHJlc3VsdCwgdGhpcy5yZWN0U291cmNlKTtcbiAgICAgIC8vVE9ETzogd2hlbiBTb3VyY2UsIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgcmVuZGVyLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIHNvdXJjZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBwdWJsaWMgcG9pbnRTb3VyY2VUb1JlbmRlcihfc291cmNlOiBWZWN0b3IyKTogVmVjdG9yMiB7XG4gICAgICBsZXQgcHJvamVjdGlvblJlY3RhbmdsZTogUmVjdGFuZ2xlID0gdGhpcy5jYW1lcmEuZ2V0UHJvamVjdGlvblJlY3RhbmdsZSgpO1xuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFBvaW50KF9zb3VyY2UsIHByb2plY3Rpb25SZWN0YW5nbGUpO1xuICAgICAgLy8gY29uc29sZS5sb2cocHJvamVjdGlvblJlY3RhbmdsZS50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9SZW5kZXIoX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvU291cmNlKF9jbGllbnQpO1xuICAgICAgcG9pbnQgPSB0aGlzLnBvaW50U291cmNlVG9SZW5kZXIocG9pbnQpO1xuICAgICAgLy9UT0RPOiB3aGVuIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIGEgcHJvamVjdGlvbiBzdXJmYWNlIGluIHRoZSBoeXBvdGhldGljYWwgZGlzdGFuY2Ugb2YgMSB0byB0aGUgY2FtZXJhICBcbiAgICAgKiBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGNhbWVyYS1tZXRob2QuIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXMgZm9yIGNlbnRyYWwtcHJvamVjdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBwb2ludENsaWVudFRvUHJvamVjdGlvbihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XG4gICAgICBsZXQgcG9zUmVuZGVyOiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQpO1xuICAgICAgbGV0IHJlY3RSZW5kZXI6IFJlY3RhbmdsZSA9IHRoaXMuZnJhbWVTb3VyY2VUb1JlbmRlci5nZXRSZWN0KHRoaXMucmVjdFNvdXJjZSk7XG4gICAgICBsZXQgcmVjdFByb2plY3Rpb246IFJlY3RhbmdsZSA9IHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb25SZWN0YW5nbGUoKTtcblxuICAgICAgbGV0IHBvc1Byb2plY3Rpb246IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcbiAgICAgICAgcmVjdFByb2plY3Rpb24ud2lkdGggKiBwb3NSZW5kZXIueCAvIHJlY3RSZW5kZXIud2lkdGgsXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAqIHBvc1JlbmRlci55IC8gcmVjdFJlbmRlci5oZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIHBvc1Byb2plY3Rpb24uc3VidHJhY3QobmV3IFZlY3RvcjIocmVjdFByb2plY3Rpb24ud2lkdGggLyAyLCByZWN0UHJvamVjdGlvbi5oZWlnaHQgLyAyKSk7XG4gICAgICBwb3NQcm9qZWN0aW9uLnkgKj0gLTE7XG5cbiAgICAgIHJldHVybiBwb3NQcm9qZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb2ludCBpbiB0aGUgY2xpZW50IHJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgaW4gbm9ybWVkIGNsaXBzcGFjZSByZWN0YW5nbGUsIFxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXG4gICAgICovXG4gICAgcHVibGljIHBvaW50Q2xpcFRvQ2xpZW50KF9ub3JtZWQ6IFZlY3RvcjIpOiBWZWN0b3IyIHtcbiAgICAgIC8vIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xuICAgICAgLy8gbGV0IHJlc3VsdDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDAuNSk7XG4gICAgICAvLyByZXN1bHQueCAqPSAoX25vcm1lZC54ICsgMSkgKiByZWN0Q2xpZW50LndpZHRoO1xuICAgICAgLy8gcmVzdWx0LnkgKj0gKDEgLSBfbm9ybWVkLnkpICogcmVjdENsaWVudC5oZWlnaHQ7XG4gICAgICAvLyByZXN1bHQuYWRkKHJlY3RDbGllbnQucG9zaXRpb24pO1xuICAgICAgLy9UT0RPOiBjaGVjayBpZiByZWN0RGVzdGluYXRpb24gY2FuIHNhZmVseSAoYW5kIG1vcmUgcGVyZm9tYW50KSBiZSB1c2VkIGluc3RlYWQgZ2V0Q2xpZW50UmVjdGFuZ2xlXG4gICAgICBsZXQgcG9pbnRDbGllbnQ6IFZlY3RvcjIgPSBSZW5kZXIucmVjdENsaXAucG9pbnRUb1JlY3QoX25vcm1lZCwgdGhpcy5yZWN0RGVzdGluYXRpb24pO1xuICAgICAgcmV0dXJuIHBvaW50Q2xpZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb2ludCBpbiB0aGUgY2xpZW50IHJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgaW4gbm9ybWVkIGNsaXBzcGFjZSByZWN0YW5nbGUsIFxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXG4gICAgICovXG4gICAgcHVibGljIHBvaW50Q2xpcFRvQ2FudmFzKF9ub3JtZWQ6IFZlY3RvcjIpOiBWZWN0b3IyIHtcbiAgICAgIGxldCBwb2ludENhbnZhczogVmVjdG9yMiA9IFJlbmRlci5yZWN0Q2xpcC5wb2ludFRvUmVjdChfbm9ybWVkLCB0aGlzLmdldENhbnZhc1JlY3RhbmdsZSgpKTtcbiAgICAgIHJldHVybiBwb2ludENhbnZhcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGJyb3dzZXIgcGFnZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb2YgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9TY3JlZW4oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xuICAgICAgbGV0IHNjcmVlbjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKHRoaXMuI2NhbnZhcy5vZmZzZXRMZWZ0ICsgX2NsaWVudC54LCB0aGlzLiNjYW52YXMub2Zmc2V0VG9wICsgX2NsaWVudC55KTtcbiAgICAgIHJldHVybiBzY3JlZW47XG4gICAgfVxuICB9XG59XG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgLyoqXG4gICAqIERpZmZlcmVudCB4ciBzZXNzaW9uIG1vZGVzIGF2YWlsYWJsZS4gQ291bGQgYmUgZXhwYW5kIHdpdGggbW9yZSBtb2RlcyBpbiB0aGUgZnV0dXJlLlxuICAgKiBAYXV0aG9ycyBWYWxlbnRpbiBTY2htaWRiZXJnZXIsIEhGVSwgMjAyMiB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xuICAgKi9cbiAgZXhwb3J0IGVudW0gWFJfU0VTU0lPTl9NT0RFIHtcbiAgICBJTU1FUlNJVkVfVlIgPSBcImltbWVyc2l2ZS12clwiXG4gICAgLy9JTU1FUlNJVkVfQVIgPSBcImltbWVyc2l2ZS1hclwiLFxuICAgIC8vSU5MSU5FID0gXCJpbmxpbmVcIlxuICB9XG5cbiAgLyoqXG4gICAqIERpZmZlcmVudCByZWZlcmVuY2UgdnItc3BhY2VzIGF2YWlsYWJsZSwgY3JlYXRvciBoYXMgdG8gY2hlY2sgaWYgdGhlIHNwYWNlIGlzIHN1cHBvcnRlZCB3aXRoIGl0cyBkZXZpY2UuXG4gICAqIENvdWxkIGJlIGV4cGFuZCB3aXRoIG1vcmUgYXZhaWxhYmxlIHNwYWNlIHR5cGVzIGluIHRoZSBmdXR1cmUuXG4gICAqL1xuICBleHBvcnQgZW51bSBYUl9SRUZFUkVOQ0VfU1BBQ0Uge1xuICAgIFZJRVdFUiA9IFwidmlld2VyXCIsXG4gICAgTE9DQUwgPSBcImxvY2FsXCJcbiAgICAvLyBMT0NBTF9GTE9PUiA9IFwibG9jYWwtZmxvb3JcIixcbiAgICAvLyBCT1VOREVEX0ZMT09SID0gXCJib3VuZGVkLWZsb29yXCIsXG4gICAgLy8gVU5CT1VOREVEID0gXCJ1bmJvdW5kZWRcIlxuICB9XG5cbiAgLyoqXG4gICAqIFhSVmlld3BvcnQgKHdlYlhSKS1leHRlbnNpb24gb2YgVmlld3BvcnQsIHRvIGRpc3BsYXlpbmcgaXRzIGJyYW5jaCBvbiBIZWFkIE1vdW50ZWQgYW5kIEFSIChub3QgaW1wbGVtdGVkIHlldCkgRGV2aWNlcyBcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBYUlZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xuICAgIHByaXZhdGUgc3RhdGljIHhyVmlld3BvcnRJbnN0YW5jZTogWFJWaWV3cG9ydCA9IG51bGw7XG4gICAgcHVibGljIHZyRGV2aWNlOiBDb21wb25lbnRWUkRldmljZSA9IG51bGw7XG4gICAgcHVibGljIHNlc3Npb246IFhSU2Vzc2lvbiA9IG51bGw7XG4gICAgcHVibGljIHJlZmVyZW5jZVNwYWNlOiBYUlJlZmVyZW5jZVNwYWNlID0gbnVsbDtcbiAgICBwcml2YXRlIHVzZVZSQ29udHJvbGxlcjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IG51bGw7XG5cbiAgICAvLyBwcml2YXRlIHBvc2VNdHg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgWFJWaWV3cG9ydC54clZpZXdwb3J0SW5zdGFuY2UgPSB0aGlzO1xuICAgICAgdGhpcy5jcmMzID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvIHJldHJpZXZlIHByaXZhdGUgc3RhdGljIGluc3RhbmNlIG9mIHhyIHZpZXdwb3J0LCByZWFkb25seS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldCBkZWZhdWx0KCk6IFhSVmlld3BvcnQge1xuICAgICAgcmV0dXJuIHRoaXMueHJWaWV3cG9ydEluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBDb25uZWN0cyB0aGUgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGNhbnZhcyB0byByZW5kZXIgdGhlIGdpdmVuIGJyYW5jaCB0byB1c2luZyB0aGUgZ2l2ZW4gY2FtZXJhLWNvbXBvbmVudCwgYW5kIG5hbWVzIHRoZSB2aWV3cG9ydCBhcyBnaXZlbi5cbiAgICAgICovXG4gICAgcHVibGljIGluaXRpYWxpemUoX25hbWU6IHN0cmluZywgX2JyYW5jaDogTm9kZSwgX2NhbWVyYVhSOiBDb21wb25lbnRWUkRldmljZSAvKiB8IENvbXBvbmVudENhbWVyYUFSKi8sIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XG4gICAgICBzdXBlci5pbml0aWFsaXplKF9uYW1lLCBfYnJhbmNoLCBfY2FtZXJhWFIsIF9jYW52YXMpO1xuICAgICAgdGhpcy5jYW1lcmEgPSBfY2FtZXJhWFI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIFZSIFNlc3Npb24gaXMgaW5pdGlhbGl6ZWQgaGVyZSwgYWxzbyBWUiAtIENvbnRyb2xsZXIgYXJlIGluaXRpYWxpemVkLCBpZiBib29sZWFuIGlzIHRydWUuXG4gICAgICogQ3JlYXRvciBoYXMgdG8gY2FsbCBGcmFtZVJlcXVlc3RYUiBhZnRlciB0aGlzIE1ldGhvZCB0byBydW4gdGhlIHZpZXdwb3J0IGluIHZpcnR1YWwgcmVhbGl0eS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZVZSKF92clNlc3Npb25Nb2RlOiBYUl9TRVNTSU9OX01PREUgPSBYUl9TRVNTSU9OX01PREUuSU1NRVJTSVZFX1ZSLCBfdnJSZWZlcmVuY2VTcGFjZVR5cGU6IFhSX1JFRkVSRU5DRV9TUEFDRSA9IFhSX1JFRkVSRU5DRV9TUEFDRS5MT0NBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92ckNvbnRyb2xsZXI6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgbGV0IHNlc3Npb246IFhSU2Vzc2lvbiA9IGF3YWl0IG5hdmlnYXRvci54ci5yZXF1ZXN0U2Vzc2lvbihfdnJTZXNzaW9uTW9kZSk7XG4gICAgICB0aGlzLnJlZmVyZW5jZVNwYWNlID0gYXdhaXQgc2Vzc2lvbi5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UoX3ZyUmVmZXJlbmNlU3BhY2VUeXBlKTtcbiAgICAgIGF3YWl0IHRoaXMuY3JjMy5tYWtlWFJDb21wYXRpYmxlKCk7XG4gICAgICBsZXQgbmF0aXZlU2NhbGVGYWN0b3I6IG51bWJlciA9IFhSV2ViR0xMYXllci5nZXROYXRpdmVGcmFtZWJ1ZmZlclNjYWxlRmFjdG9yKHNlc3Npb24pO1xuICAgICAgLy9UT0RPOiAgRmllbGQgb2YgdmlldyBrw7ZubnRlIGFuIGRlciBTdGVsbGUgbm9jaCB2ZXLDpG5kZXJ0IHdlcmRlbi5cbiAgICAgIGF3YWl0IHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoeyBiYXNlTGF5ZXI6IG5ldyBYUldlYkdMTGF5ZXIoc2Vzc2lvbiwgdGhpcy5jcmMzLCB7IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3I6IG5hdGl2ZVNjYWxlRmFjdG9yIH0pIH0pO1xuXG4gICAgICB0aGlzLnZyRGV2aWNlID0gPENvbXBvbmVudFZSRGV2aWNlPnRoaXMuY2FtZXJhO1xuICAgICAgdGhpcy5pbml0aWFsaXplUmVmZXJlbmNlU3BhY2UoKTtcblxuICAgICAgdGhpcy51c2VWUkNvbnRyb2xsZXIgPSBfdnJDb250cm9sbGVyO1xuICAgICAgaWYgKF92ckNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy52ckRldmljZS5yaWdodENudHJsLmNtcFRyYW5zZm9ybSA9IG5ldyBDb21wb25lbnRUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy52ckRldmljZS5sZWZ0Q250cmwuY21wVHJhbnNmb3JtID0gbmV3IENvbXBvbmVudFRyYW5zZm9ybSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRyYW5zZm9ybXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQVIgc2Vzc2lvbiBjb3VsZCBiZSBpbml0aWFsaXplZCBoZXJlLiBVcCB0aWxsIG5vdyBub3QgaW1wbGVtZW50ZWQuIFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBpbml0aWFsaXplQVIoX2FyU2Vzc2lvbk1vZGU6IFhSX1NFU1NJT05fTU9ERSA9IG51bGwsIF9hclJlZmVyZW5jZVNwYWNlVHlwZTogWFJfUkVGRVJFTkNFX1NQQUNFID0gbnVsbCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgRGVidWcuZXJyb3IoXCJOT1QgSU1QTEVNRU5URUQgWUVUISBDaGVjayBvdXQgaW5pdGlhbGl6ZVZSIVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSB4ciB2aWV3cG9ydCBkaXNwbGF5aW5nIGl0cyBicmFuY2guIEJ5IGRlZmF1bHQsIHRoZSB0cmFuc2Zvcm1zIGluIHRoZSBicmFuY2ggYXJlIHJlY2FsY3VsYXRlZCBmaXJzdC5cbiAgICAgKiBQYXNzIGBmYWxzZWAgaWYgY2FsY3VsYXRpb24gd2FzIGFscmVhZHkgZG9uZSBmb3IgdGhpcyBmcmFtZSBcbiAgICAgKiBDYWxsZWQgZnJvbSBsb29wIG1ldGhvZCB7QGxpbmsgTG9vcH0gYWdhaW4gd2l0aCB0aGUgeHJGcmFtZSBwYXJhbWV0ZXIgaGFuZG92ZXIsIGFzIHNvb24gYXMgRlJBTUVfUkVRVUVTVF9YUiBpcyBjYWxsZWQgZnJvbSBjcmVhdG9yLlxuICAgICAqL1xuICAgIHB1YmxpYyBkcmF3KF9jYWxjdWxhdGVUcmFuc2Zvcm1zOiBib29sZWFuID0gdHJ1ZSwgX3hyRnJhbWU6IFhSRnJhbWUgPSBudWxsKTogdm9pZCB7XG4gICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICBzdXBlci5kcmF3KF9jYWxjdWxhdGVUcmFuc2Zvcm1zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgcG9zZTogWFJWaWV3ZXJQb3NlID0gX3hyRnJhbWU/LmdldFZpZXdlclBvc2UodGhpcy5yZWZlcmVuY2VTcGFjZSk7XG4gICAgICBpZiAoIXBvc2UpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdGhpcy52ckRldmljZS5tdHhMb2NhbC5zZXQocG9zZS50cmFuc2Zvcm0ubWF0cml4KTtcbiAgICAgIHN1cGVyLmNvbXB1dGVEcmF3aW5nKF9jYWxjdWxhdGVUcmFuc2Zvcm1zKTtcblxuICAgICAgbGV0IGdsTGF5ZXI6IFhSV2ViR0xMYXllciA9IHRoaXMuc2Vzc2lvbi5yZW5kZXJTdGF0ZS5iYXNlTGF5ZXI7XG4gICAgICBSZW5kZXIucmVzZXRGcmFtZUJ1ZmZlcihnbExheWVyLmZyYW1lYnVmZmVyKTtcbiAgICAgIFJlbmRlci5jbGVhcih0aGlzLmNhbWVyYS5jbHJCYWNrZ3JvdW5kKTtcbiAgICAgIGZvciAobGV0IHZpZXcgb2YgcG9zZS52aWV3cykge1xuICAgICAgICBsZXQgdmlld3BvcnQ6IGdsb2JhbFRoaXMuWFJWaWV3cG9ydCA9IGdsTGF5ZXIuZ2V0Vmlld3BvcnQodmlldyk7XG4gICAgICAgIHRoaXMuY3JjMy52aWV3cG9ydCh2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KTtcblxuICAgICAgICBpZiAodGhpcy51c2VWUkNvbnRyb2xsZXIpXG4gICAgICAgICAgdGhpcy5zZXRDb250cm9sbGVyQ29uZmlncyhfeHJGcmFtZSk7XG4gICAgICAgIHRoaXMuY2FtZXJhLm10eFByb2plY3Rpb24uc2V0KHZpZXcucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAgIHRoaXMuY2FtZXJhLm10eENhbWVyYUludmVyc2Uuc2V0KHZpZXcudHJhbnNmb3JtLmludmVyc2UubWF0cml4KTtcblxuXG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NEZWJ1Z01vZGUgIT0gUEhZU0lDU19ERUJVR01PREUuUEhZU0lDX09CSkVDVFNfT05MWSlcbiAgICAgICAgICBSZW5kZXIuZHJhdyh0aGlzLmNhbWVyYSk7XG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NEZWJ1Z01vZGUgIT0gUEhZU0lDU19ERUJVR01PREUuTk9ORSkge1xuICAgICAgICAgIFBoeXNpY3MuZHJhdyh0aGlzLmNhbWVyYSwgdGhpcy5waHlzaWNzRGVidWdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUmVuZGVyLnNldFJlbmRlclJlY3RhbmdsZShSZW5kZXIuZ2V0UmVuZGVyUmVjdGFuZ2xlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIHJlZmVyZW5jZSBzcGFjZSB0byBzZXQgdGhlIGluaXRpYWwgcG9zaXRpb24vb3JpZW50YXRpb24gb2YgdGhlIHZyIGRldmljZSBpbiBhY2NvcmRhbmNlIHRvIHRoZSBub2RlIHRoZSB2ciBkZXZpY2UgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplUmVmZXJlbmNlU3BhY2UoKTogdm9pZCB7XG4gICAgICBsZXQgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IHRoaXMudnJEZXZpY2Uubm9kZT8ubXR4V29ybGQ7XG4gICAgICBpZiAoIW10eFdvcmxkKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIG10eFdvcmxkID0gbXR4V29ybGQuY2xvbmU7XG4gICAgICBtdHhXb3JsZC5yb3RhdGVZKDE4MCk7IC8vIHJvdGF0ZSBiZWNhdXNlIHRoZSBYUiBSaWcgaXMgbG9va2luZyBpbiB0aGUgZGlyZWN0aW9uIG9mIG5lZ2F0aXZlIHpcbiAgICAgIGxldCBpbnZNdHhUcmFuc2ZvbTogTWF0cml4NHg0ID0gbXR4V29ybGQuaW52ZXJzZSgpOyAvLyBpbnZlcnNlIGJlY2F1c2Ugd2UgYXJlIG1vdmluZyB0aGUgcmVmZXJlbmNlIHNwYWNlXG4gICAgICAvLyBsZXQgaW52T3JpZW50YXRpb246IFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgLy8gaW52T3JpZW50YXRpb24uZXVsZXJBbmdsZXMgPSBpbnZNdHhUcmFuc2ZvbS5ldWxlckFuZ2xlcztcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShpbnZNdHhUcmFuc2ZvbS50cmFuc2xhdGlvbiwgaW52TXR4VHJhbnNmb20ucXVhdGVybmlvbikpO1xuICAgIH1cblxuICAgIC8vU2V0cyBjb250cm9sbGVyIG1hdHJpY2VzIGFuZCB0aHVtYnN0aWNrcyBtb3ZlbWVudHMuXG4gICAgcHJpdmF0ZSBzZXRDb250cm9sbGVyQ29uZmlncyhfeHJGcmFtZTogWFJGcmFtZSk6IHZvaWQge1xuICAgICAgaWYgKF94ckZyYW1lKSB7XG4gICAgICAgIGlmIChYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbi5pbnB1dFNvdXJjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5zZXNzaW9uLmlucHV0U291cmNlcy5mb3JFYWNoKF9jb250cm9sbGVyID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRyb2xsZXIuaGFuZGVkbmVzcykge1xuICAgICAgICAgICAgICAgIGNhc2UgKFwicmlnaHRcIik6XG4gICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwuY21wVHJhbnNmb3JtLm10eExvY2FsLnNldChfeHJGcmFtZS5nZXRQb3NlKF9jb250cm9sbGVyLnRhcmdldFJheVNwYWNlLCBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UpLnRyYW5zZm9ybS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwuZ2FtZVBhZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5yaWdodENudHJsLmdhbWVQYWQgPSBfY29udHJvbGxlci5nYW1lcGFkO1xuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudnJEZXZpY2UucmlnaHRDbnRybC50aHVtYnN0aWNrWCA9IF9jb250cm9sbGVyLmdhbWVwYWQuYXhlc1syXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5yaWdodENudHJsLnRodW1ic3RpY2tZID0gX2NvbnRyb2xsZXIuZ2FtZXBhZC5heGVzWzNdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAoXCJsZWZ0XCIpOlxuICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5sZWZ0Q250cmwuY21wVHJhbnNmb3JtLm10eExvY2FsLnNldChfeHJGcmFtZS5nZXRQb3NlKF9jb250cm9sbGVyLnRhcmdldFJheVNwYWNlLCBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UpLnRyYW5zZm9ybS5tYXRyaXgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudnJEZXZpY2UubGVmdENudHJsLmdhbWVQYWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudnJEZXZpY2UubGVmdENudHJsLmdhbWVQYWQgPSBfY29udHJvbGxlci5nYW1lcGFkO1xuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudnJEZXZpY2UubGVmdENudHJsLnRodW1ic3RpY2tYID0gX2NvbnRyb2xsZXIuZ2FtZXBhZC5heGVzWzJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLmxlZnRDbnRybC50aHVtYnN0aWNrWSA9IF9jb250cm9sbGVyLmdhbWVwYWQuYXhlc1szXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICAgIERlYnVnLmluZm8oXCJJbnB1dCBTb3VyY2VzIEVycm9yOiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWFwRmlsZW5hbWVUb0NvbnRlbnQge1xuICAgIFtmaWxlbmFtZTogc3RyaW5nXTogc3RyaW5nO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGZpbGUgdHJhbnNmZXIgZnJvbSBhIEZVREdFLUJyb3dzZXJhcHAgdG8gdGhlIGxvY2FsIGZpbGVzeXN0ZW0gd2l0aG91dCBhIGxvY2FsIHNlcnZlci4gIFxuICAgKiBTYXZlcyB0byB0aGUgZG93bmxvYWQtcGF0aCBnaXZlbiBieSB0aGUgYnJvd3NlciwgbG9hZHMgZnJvbSB0aGUgcGxheWVyJ3MgY2hvaWNlLlxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIEZpbGVJb0Jyb3dzZXJMb2NhbCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcbiAgICBwcml2YXRlIHN0YXRpYyBzZWxlY3RvcjogSFRNTElucHV0RWxlbWVudDtcbiAgICAvLyBUT0RPOiByZWZhY3RvciB0byBhc3luYyBmdW5jdGlvbiB0byBiZSBoYW5kbGVkIHVzaW5nIHByb21pc2UsIGluc3RlYWQgb2YgdXNpbmcgZXZlbnQgdGFyZ2V0XG4gICAgLyoqXG4gICAgICogT3BlbiBmaWxlIHNlbGVjdCBkaWFsb2cgdG8gbG9hZCBmaWxlcyBmcm9tIGxvY2FsIGZpbGVzeXN0ZW0gaW50byBicm93c2VyIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfbXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci50eXBlID0gXCJmaWxlXCI7XG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IubXVsdGlwbGUgPSBfbXVsdGlwbGU7XG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIEZpbGVJb0Jyb3dzZXJMb2NhbC5oYW5kbGVGaWxlU2VsZWN0KTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE1hcEZpbGVuYW1lVG9Db250ZW50PihfcmVzb2x2ZSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGhuZExvYWRlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9MT0FERUQsIGhuZExvYWRlZCk7XG4gICAgICAgICAgX3Jlc29sdmUoKDxDdXN0b21FdmVudD5fZXZlbnQpLmRldGFpbC5tYXBGaWxlbmFtZVRvQ29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX0xPQURFRCwgaG5kTG9hZGVkKTtcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmNsaWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZWZhY3RvciB0byBhc3luYyBmdW5jdGlvbiB0byBiZSBoYW5kbGVkIHVzaW5nIHByb21pc2UsIGluc3RlYWQgb2YgdXNpbmcgZXZlbnQgdGFyZ2V0XG4gICAgLyoqXG4gICAgICogT3BlbiBhIGZpbGUgZG93bmxvYWQgZGlhbG9nIHRvIHNhdmUgZmlsZXMgdG8gbG9jYWwgZmlsZXN5c3RlbS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHNhdmUoX3RvU2F2ZTogTWFwRmlsZW5hbWVUb0NvbnRlbnQsIF90eXBlOiBzdHJpbmcgPSBcInRleHQvcGxhaW5cIik6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcbiAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIF90b1NhdmUpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZyA9IF90b1NhdmVbZmlsZW5hbWVdO1xuICAgICAgICBsZXQgYmxvYjogQmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwgeyB0eXBlOiBfdHlwZSB9KTtcbiAgICAgICAgbGV0IHVybDogc3RyaW5nID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIC8vKi8gdXNpbmcgYW5jaG9yIGVsZW1lbnQgZm9yIGRvd25sb2FkXG4gICAgICAgIGxldCBkb3dubG9hZGVyOiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICAgICAgZG93bmxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBkb3dubG9hZGVyLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdXJsKTtcbiAgICAgICAgZG93bmxvYWRlci5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBmaWxlbmFtZSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRlcik7XG4gICAgICAgIGRvd25sb2FkZXIuY2xpY2soKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZGVyKTtcbiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE1hcEZpbGVuYW1lVG9Db250ZW50PihfcmVzb2x2ZSA9PiB7XG4gICAgICAgIF9yZXNvbHZlKF90b1NhdmUpO1xuICAgICAgICAvLyBmdW5jdGlvbiBobmRTYXZlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgICAgIC8vICAgRmlsZUlvQnJvd3NlckxvY2FsLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9TQVZFRCwgaG5kU2F2ZWQpO1xuICAgICAgICAvLyAgIF9yZXNvbHZlKCg8Q3VzdG9tRXZlbnQ+X2V2ZW50KS5kZXRhaWwpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gRmlsZUlvQnJvd3NlckxvY2FsLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9TQVZFRCwgaG5kU2F2ZWQpO1xuICAgICAgICAvLyBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfU0FWRUQsIHsgZGV0YWlsOiB7IG1hcEZpbGVuYW1lVG9Db250ZW50OiBfdG9TYXZlIH0gfSk7XG4gICAgICAgIC8vIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSB0aGUgZmlsZXMgcmVmZXJlbmNlZCBpbiB7QGxpbmsgRmlsZUxpc3R9IGludG8gdGhlIHByb3ZpZGVkIHtAbGluayBNYXBGaWxlbmFtZVRvQ29udGVudH1cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRGaWxlcyhfZmlsZUxpc3Q6IEZpbGVMaXN0LCBfbG9hZGVkOiBNYXBGaWxlbmFtZVRvQ29udGVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgZm9yIChsZXQgZmlsZSBvZiBfZmlsZUxpc3QpIHtcbiAgICAgICAgY29uc3QgY29udGVudDogc3RyaW5nID0gYXdhaXQgbmV3IFJlc3BvbnNlKGZpbGUpLnRleHQoKTtcbiAgICAgICAgX2xvYWRlZFtmaWxlLm5hbWVdID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBoYW5kbGVGaWxlU2VsZWN0KF9ldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIERlYnVnLmZ1ZGdlKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGFuZGxlRmlsZVNlbGVjdFwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcbiAgICAgIGxldCBmaWxlTGlzdDogRmlsZUxpc3QgPSAoPEhUTUxJbnB1dEVsZW1lbnQ+X2V2ZW50LnRhcmdldCkuZmlsZXM7XG4gICAgICBEZWJ1Zy5mdWRnZShmaWxlTGlzdCwgZmlsZUxpc3QubGVuZ3RoKTtcbiAgICAgIGlmIChmaWxlTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBsZXQgbG9hZGVkOiBNYXBGaWxlbmFtZVRvQ29udGVudCA9IHt9O1xuICAgICAgYXdhaXQgRmlsZUlvQnJvd3NlckxvY2FsLmxvYWRGaWxlcyhmaWxlTGlzdCwgbG9hZGVkKTtcblxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVC5GSUxFX0xPQURFRCwgeyBkZXRhaWw6IHsgbWFwRmlsZW5hbWVUb0NvbnRlbnQ6IGxvYWRlZCB9IH0pO1xuICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH1cbn0gIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBNdXRhYmxlIGFycmF5IG9mIHtAbGluayBNdXRhYmxlfXMuIFRoZSB7QGxpbmsgTXV0YXRvcn1zIG9mIHRoZSBlbnRyaWVzIGFyZSBpbmNsdWRlZCBhcyBhcnJheSBpbiB0aGUge0BsaW5rIE11dGF0b3J9XG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBNdXRhYmxlQXJyYXk8VCBleHRlbmRzIE11dGFibGU+IGV4dGVuZHMgQXJyYXk8VD4ge1xuICAgICN0eXBlOiBuZXcgKCkgPT4gVDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdHlwZTogbmV3ICgpID0+IFQsIC4uLl9hcmdzOiBUW10pIHtcbiAgICAgIHN1cGVyKC4uLl9hcmdzKTtcbiAgICAgIHRoaXMuI3R5cGUgPSBfdHlwZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogbmV3ICgpID0+IFQge1xuICAgICAgcmV0dXJuIHRoaXMuI3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhcnJhbmdlIHRoZSBlbnRyaWVzIG9mIHRoZSBhcnJheSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHNlcXVlbmNlIG9mIGluZGljZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhcnJhbmdlKF9zZXF1ZW5jZTogbnVtYmVyW10pOiB2b2lkIHtcbiAgICAgIGxldCBsZW5ndGg6IG51bWJlciA9IHRoaXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaW5kZXggb2YgX3NlcXVlbmNlKSB7XG4gICAgICAgIGxldCBvcmlnaW5hbDogVCA9IHRoaXNbaW5kZXhdO1xuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSwgY29weSBvbmx5IGRvdWJsZSBlbnRyaWVzXG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBsZXQgY29weTogVCA9IG5ldyBvcmlnaW5hbC5jb25zdHJ1Y3RvcigpO1xuICAgICAgICBjb3B5Lm11dGF0ZShvcmlnaW5hbC5nZXRNdXRhdG9yKCkpO1xuICAgICAgICB0aGlzLnB1c2goY29weSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNwbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2l0aCB0aGlzIGFycmF5cyBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHR5cGVzIGFzIHN0cmluZy12YWx1ZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XG4gICAgICBmb3IgKGxldCBlbnRyeSBpbiB0aGlzKVxuICAgICAgICB0eXBlc1tlbnRyeV0gPSB0aGlzW2VudHJ5XS5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIGVhY2ggZWxlbWVudHMgbXV0YXRvciBieSBpbnZva2luZyB7QGxpbmsgTXV0YWJsZS5nZXRNdXRhdG9yfSBvbiB0aGVtXG4gICAgICovXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoKF92YWx1ZSkgPT4gX3ZhbHVlLmdldE11dGF0b3IoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayBNdXRhYmxlLmdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlfVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSgpOiBNdXRhdG9yIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdXRhdGUgZWFjaCBlbGVtZW50IG9mIHRoaXMgYXJyYXkgYnkgaW52b2tpbmcge0BsaW5rIE11dGFibGUubXV0YXRlfSBvbiBpdFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpXG4gICAgICAgIGF3YWl0IHRoaXNbZW50cnldLm11dGF0ZShfbXV0YXRvcltlbnRyeV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbXV0YXRvciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpIHtcbiAgICAgICAgbGV0IG11dGF0b3JWYWx1ZTogT2JqZWN0ID0gX211dGF0b3JbZW50cnldO1xuICAgICAgICBpZiAoIW11dGF0b3JWYWx1ZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHRoaXNbZW50cnldIGluc3RhbmNlb2YgTXV0YWJsZSlcbiAgICAgICAgICBfbXV0YXRvcltlbnRyeV0gPSB0aGlzW2VudHJ5XS5nZXRNdXRhdG9yKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBfbXV0YXRvcltlbnRyeV0gPSB0aGlzW2VudHJ5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGVudW0gTU9ERSB7XG4gICAgRURJVE9SLCBSVU5USU1FXG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZVJlc291cmNlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdHlwZTogc3RyaW5nO1xuICAgIGlkUmVzb3VyY2U6IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VzIHtcbiAgICBbaWRSZXNvdXJjZTogc3RyaW5nXTogU2VyaWFsaXphYmxlUmVzb3VyY2U7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyB7XG4gICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IFNlcmlhbGl6YXRpb247XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFNjcmlwdE5hbWVzcGFjZXMge1xuICAgIFtuYW1lOiBzdHJpbmddOiBPYmplY3Q7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudFNjcmlwdHMge1xuICAgIFtuYW1lc3BhY2U6IHN0cmluZ106IENvbXBvbmVudFNjcmlwdFtdO1xuICB9XG5cbiAgaW50ZXJmYWNlIEdyYXBoSW5zdGFuY2VzVG9SZXN5bmMge1xuICAgIFtpZFJlc291cmNlOiBzdHJpbmddOiBHcmFwaEluc3RhbmNlW107XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIGNsYXNzIGhhbmRsaW5nIHRoZSByZXNvdXJjZXMgdXNlZCB3aXRoIHRoZSBjdXJyZW50IEZVREdFLWluc3RhbmNlLiAgXG4gICAqIEtlZXBzIGEgbGlzdCBvZiB0aGUgcmVzb3VyY2VzIGFuZCBnZW5lcmF0ZXMgaWRzIHRvIHJldHJpZXZlIHRoZW0uICBcbiAgICogUmVzb3VyY2VzIGFyZSBvYmplY3RzIHJlZmVyZW5jZWQgbXVsdGlwbGUgdGltZXMgYnV0IHN1cHBvc2VkIHRvIGJlIHN0b3JlZCBvbmx5IG9uY2VcbiAgICovXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcm9qZWN0IGV4dGVuZHMgRXZlbnRUYXJnZXRTdGF0aWMge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVzb3VyY2VzOiBSZXNvdXJjZXMgPSB7fTtcbiAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyA9IHt9O1xuICAgIHB1YmxpYyBzdGF0aWMgc2NyaXB0TmFtZXNwYWNlczogU2NyaXB0TmFtZXNwYWNlcyA9IHt9O1xuICAgIHB1YmxpYyBzdGF0aWMgYmFzZVVSTDogVVJMID0gbmV3IFVSTChsb2NhdGlvbi50b1N0cmluZygpKTtcbiAgICBwdWJsaWMgc3RhdGljIG1vZGU6IE1PREUgPSBNT0RFLlJVTlRJTUU7XG4gICAgcHVibGljIHN0YXRpYyBncmFwaEluc3RhbmNlc1RvUmVzeW5jOiBHcmFwaEluc3RhbmNlc1RvUmVzeW5jID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIHJlc291cmNlIGFuZCBnZW5lcmF0ZXMgYW4gaWQgZm9yIGl0IGJ5IGRlZmF1bHQuICBcbiAgICAgKiBJZiB0aGUgcmVzb3VyY2UgYWxyZWFkeSBoYXMgYW4gaWQsIHRodXMgaGF2aW5nIGJlZW4gcmVnaXN0ZXJlZCwgaXRzIGRlbGV0ZWQgZnJvbSB0aGUgbGlzdCBhbmQgcmVnaXN0ZXJlZCBhbmV3LlxuICAgICAqIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbiBpZCwgYnV0IHNob3VsZCBub3QgYmUgZG9uZSBleGNlcHQgYnkgdGhlIFNlcmlhbGl6ZXIuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlcihfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlLCBfaWRSZXNvdXJjZT86IHN0cmluZyk6IHZvaWQge1xuICAgICAgaWYgKF9yZXNvdXJjZS5pZFJlc291cmNlKVxuICAgICAgICBpZiAoX3Jlc291cmNlLmlkUmVzb3VyY2UgPT0gX2lkUmVzb3VyY2UpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5kZXJlZ2lzdGVyKF9yZXNvdXJjZSk7XG4gICAgICBfcmVzb3VyY2UuaWRSZXNvdXJjZSA9IF9pZFJlc291cmNlIHx8IFByb2plY3QuZ2VuZXJhdGVJZChfcmVzb3VyY2UpO1xuICAgICAgUHJvamVjdC5yZXNvdXJjZXNbX3Jlc291cmNlLmlkUmVzb3VyY2VdID0gX3Jlc291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHJlc291cmNlIGZyb20gdGhlIGxpc3Qgb2YgcmVzb3VyY2VzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVyZWdpc3RlcihfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlKTogdm9pZCB7XG4gICAgICBkZWxldGUgKFByb2plY3QucmVzb3VyY2VzW19yZXNvdXJjZS5pZFJlc291cmNlXSk7XG4gICAgICBkZWxldGUgKFByb2plY3Quc2VyaWFsaXphdGlvbltfcmVzb3VyY2UuaWRSZXNvdXJjZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgbGlzdCBvZiByZXNvdXJjZXMgYW5kIHRoZWlyIHNlcmlhbGl6YXRpb24sIHRodXMgcmVtb3ZpbmcgYWxsIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xuICAgICAgUHJvamVjdC5yZXNvdXJjZXMgPSB7fTtcbiAgICAgIFByb2plY3Quc2VyaWFsaXphdGlvbiA9IHt9O1xuICAgICAgUHJvamVjdC5jbGVhclNjcmlwdE5hbWVzcGFjZXMoKTtcbiAgICAgIC8vIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlcyA9IHt9O1xuICAgIH1cblxuICAgIC8vIDxUIGV4dGVuZHMgQ29tcG9uZW50PihfY2xhc3M6IG5ldyAoKSA9PiBUKTogVFtdIHtcbiAgICAvLyAgIHJldHVybiA8VFtdPih0aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdIHx8IFtdKS5zbGljZSgwKTtcbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCByZXNvdXJjZXMgb2YgdGhlIHJlcXVlc3RlZCB0eXBlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UmVzb3VyY2VzQnlUeXBlPFQ+KF90eXBlOiBuZXcgKF9hcmdzOiBHZW5lcmFsKSA9PiBUKTogU2VyaWFsaXphYmxlUmVzb3VyY2VbXSB7XG4gICAgICBsZXQgZm91bmQ6IFNlcmlhbGl6YWJsZVJlc291cmNlW10gPSBbXTtcbiAgICAgIGZvciAobGV0IHJlc291cmNlSWQgaW4gUHJvamVjdC5yZXNvdXJjZXMpIHtcbiAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFByb2plY3QucmVzb3VyY2VzW3Jlc291cmNlSWRdO1xuICAgICAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBfdHlwZSlcbiAgICAgICAgICBmb3VuZC5wdXNoKHJlc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCByZXNvdXJjZXMgd2l0aCB0aGUgcmVxdWVzdGVkIG5hbWUuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZXNvdXJjZXNCeU5hbWUoX25hbWU6IHN0cmluZyk6IFNlcmlhbGl6YWJsZVJlc291cmNlW10ge1xuICAgICAgbGV0IGZvdW5kOiBTZXJpYWxpemFibGVSZXNvdXJjZVtdID0gW107XG4gICAgICBmb3IgKGxldCByZXNvdXJjZUlkIGluIFByb2plY3QucmVzb3VyY2VzKSB7XG4gICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tyZXNvdXJjZUlkXTtcbiAgICAgICAgaWYgKHJlc291cmNlLm5hbWUgPT0gX25hbWUpXG4gICAgICAgICAgZm91bmQucHVzaChyZXNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHVzZXIgcmVhZGFibGUgYW5kIHVuaXF1ZSBpZCB1c2luZyB0aGUgdHlwZSBvZiB0aGUgcmVzb3VyY2UsIHRoZSBkYXRlIGFuZCByYW5kb20gbnVtYmVyc1xuICAgICAqIEBwYXJhbSBfcmVzb3VyY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdlbmVyYXRlSWQoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSk6IHN0cmluZyB7XG4gICAgICAvLyBUT0RPOiBidWlsZCBpZCBhbmQgaW50ZWdyYXRlIGluZm8gZnJvbSByZXNvdXJjZSwgbm90IGp1c3QgZGF0ZVxuICAgICAgbGV0IGlkUmVzb3VyY2U6IHN0cmluZztcbiAgICAgIGRvXG4gICAgICAgIGlkUmVzb3VyY2UgPSBfcmVzb3VyY2UuY29uc3RydWN0b3IubmFtZSArIFwifFwiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJ8XCIgKyBNYXRoLnJhbmRvbSgpLnRvUHJlY2lzaW9uKDUpLnN1YnN0cigyLCA1KTtcbiAgICAgIHdoaWxlIChQcm9qZWN0LnJlc291cmNlc1tpZFJlc291cmNlXSk7XG4gICAgICByZXR1cm4gaWRSZXNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cywgaWYgYW4gb2JqZWN0IGlzIGEge0BsaW5rIFNlcmlhbGl6YWJsZVJlc291cmNlfVxuICAgICAqIEBwYXJhbSBfb2JqZWN0IFRoZSBvYmplY3QgdG8gZXhhbWluZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNSZXNvdXJjZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiAoUmVmbGVjdC5oYXMoX29iamVjdCwgXCJpZFJlc291cmNlXCIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlc291cmNlIHN0b3JlZCB3aXRoIHRoZSBnaXZlbiBpZFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0UmVzb3VyY2UoX2lkUmVzb3VyY2U6IHN0cmluZyk6IFByb21pc2U8U2VyaWFsaXphYmxlUmVzb3VyY2U+IHtcbiAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tfaWRSZXNvdXJjZV07XG4gICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gUHJvamVjdC5zZXJpYWxpemF0aW9uW19pZFJlc291cmNlXTtcbiAgICAgICAgaWYgKCFzZXJpYWxpemF0aW9uKSB7XG4gICAgICAgICAgRGVidWcuZXJyb3IoXCJSZXNvdXJjZSBub3QgZm91bmRcIiwgX2lkUmVzb3VyY2UpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc291cmNlID0gYXdhaXQgUHJvamVjdC5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIHJlc291cmNlIGZyb20gYSB7QGxpbmsgTm9kZX0sIGNvcHlpbmcgdGhlIGNvbXBsZXRlIGdyYXBoIHN0YXJ0aW5nIHdpdGggaXRcbiAgICAgKiBAcGFyYW0gX25vZGUgQSBub2RlIHRvIGNyZWF0ZSB0aGUgcmVzb3VyY2UgZnJvbVxuICAgICAqIEBwYXJhbSBfcmVwbGFjZVdpdGhJbnN0YW5jZSBpZiB0cnVlIChkZWZhdWx0KSwgdGhlIG5vZGUgdXNlZCBhcyBvcmlnaW4gaXMgcmVwbGFjZWQgYnkgYSB7QGxpbmsgR3JhcGhJbnN0YW5jZX0gb2YgdGhlIHtAbGluayBHcmFwaH0gY3JlYXRlZFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVnaXN0ZXJBc0dyYXBoKF9ub2RlOiBOb2RlLCBfcmVwbGFjZVdpdGhJbnN0YW5jZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPEdyYXBoPiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IF9ub2RlLnNlcmlhbGl6ZSgpO1xuICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IG5ldyBHcmFwaChfbm9kZS5uYW1lKTtcbiAgICAgIGF3YWl0IGdyYXBoLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb24pO1xuICAgICAgUHJvamVjdC5yZWdpc3RlcihncmFwaCk7XG5cbiAgICAgIGlmIChfcmVwbGFjZVdpdGhJbnN0YW5jZSAmJiBfbm9kZS5nZXRQYXJlbnQoKSkge1xuICAgICAgICBsZXQgaW5zdGFuY2U6IEdyYXBoSW5zdGFuY2UgPSBhd2FpdCBQcm9qZWN0LmNyZWF0ZUdyYXBoSW5zdGFuY2UoZ3JhcGgpO1xuICAgICAgICBfbm9kZS5nZXRQYXJlbnQoKS5yZXBsYWNlQ2hpbGQoX25vZGUsIGluc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgR3JhcGhJbnN0YW5jZX0gb2YgdGhlIGdpdmVuIHtAbGluayBHcmFwaH0gXG4gICAgICogYW5kIGNvbm5lY3RzIGl0IHRvIHRoZSBncmFwaCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIG11dGF0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlR3JhcGhJbnN0YW5jZShfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTxHcmFwaEluc3RhbmNlPiB7XG4gICAgICBsZXQgaW5zdGFuY2U6IEdyYXBoSW5zdGFuY2UgPSBuZXcgR3JhcGhJbnN0YW5jZShfZ3JhcGgpOyAvLyBUT0RPOiBjbGVhbnVwIHNpbmNlIGNyZWF0aW9uIG1vdmVkIGhlcmVcbiAgICAgIGF3YWl0IGluc3RhbmNlLmNvbm5lY3RUb0dyYXBoKCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIHtAbGluayBHcmFwaEluc3RhbmNlfSB0byBiZSByZXN5bmNlZFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJHcmFwaEluc3RhbmNlRm9yUmVzeW5jKF9pbnN0YW5jZTogR3JhcGhJbnN0YW5jZSk6IHZvaWQge1xuICAgICAgbGV0IGluc3RhbmNlczogR3JhcGhJbnN0YW5jZVtdID0gUHJvamVjdC5ncmFwaEluc3RhbmNlc1RvUmVzeW5jW19pbnN0YW5jZS5pZFNvdXJjZV0gfHwgW107XG4gICAgICBpbnN0YW5jZXMucHVzaChfaW5zdGFuY2UpO1xuICAgICAgUHJvamVjdC5ncmFwaEluc3RhbmNlc1RvUmVzeW5jW19pbnN0YW5jZS5pZFNvdXJjZV0gPSBpbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzeW5jIGFsbCB7QGxpbmsgR3JhcGhJbnN0YW5jZX0gcmVnaXN0ZXJlZCB0byB0aGUgZ2l2ZW4ge0BsaW5rIEdyYXBofVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVzeW5jR3JhcGhJbnN0YW5jZXMoX2dyYXBoOiBHcmFwaCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgbGV0IGluc3RhbmNlczogR3JhcGhJbnN0YW5jZVtdID0gUHJvamVjdC5ncmFwaEluc3RhbmNlc1RvUmVzeW5jW19ncmFwaC5pZFJlc291cmNlXTtcbiAgICAgIGlmICghaW5zdGFuY2VzKVxuICAgICAgICByZXR1cm47XG4gICAgICBmb3IgKGxldCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpXG4gICAgICAgIGF3YWl0IGluc3RhbmNlLmNvbm5lY3RUb0dyYXBoKCk7XG4gICAgICBkZWxldGUgKFByb2plY3QuZ3JhcGhJbnN0YW5jZXNUb1Jlc3luY1tfZ3JhcGguaWRSZXNvdXJjZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBuYW1lc3BhY2UgdG8gdGhlIGxpc3Qgb2Ygc2NyaXB0LW5hbWVzcGFjZXMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlclNjcmlwdE5hbWVzcGFjZShfbmFtZXNwYWNlOiBPYmplY3QpOiB2b2lkIHtcbiAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLnJlZ2lzdGVyTmFtZXNwYWNlKF9uYW1lc3BhY2UpO1xuICAgICAgaWYgKCFQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZV0pXG4gICAgICAgIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXSA9IF9uYW1lc3BhY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGxpc3Qgb2Ygc2NyaXB0LW5hbWVzcGFjZXMuXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjbGVhclNjcmlwdE5hbWVzcGFjZXMoKTogdm9pZCB7XG4gICAgICBmb3IgKGxldCBuYW1lIGluIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlcykge1xuICAgICAgICBSZWZsZWN0LnNldCh3aW5kb3csIG5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZGVsZXRlIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0cyBhbGwge0BsaW5rIENvbXBvbmVudFNjcmlwdH1zIHJlZ2lzdGVyZWQgaW4ge0BsaW5rIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc30gYW5kIHJldHVybnMgdGhlbS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldENvbXBvbmVudFNjcmlwdHMoKTogQ29tcG9uZW50U2NyaXB0cyB7XG4gICAgICBsZXQgY29tcG9tZW50czogQ29tcG9uZW50U2NyaXB0cyA9IHt9O1xuICAgICAgZm9yIChsZXQgbmFtZXNwYWNlIGluIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlcykge1xuICAgICAgICBjb21wb21lbnRzW25hbWVzcGFjZV0gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZXNwYWNlXSkge1xuICAgICAgICAgIGxldCBzY3JpcHQ6IENvbXBvbmVudFNjcmlwdCA9IFJlZmxlY3QuZ2V0KFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lc3BhY2VdLCBuYW1lKTtcbiAgICAgICAgICAvLyBVc2luZyBPYmplY3QuY3JlYXRlIGRvZXNuJ3QgY2FsbCB0aGUgY29uc3RydWN0b3IsIGJ1dCBpbnN0YW5jZW9mIGNhbiBiZSB1c2VkLiBNb3JlIGVsZWdhbnQgdGhhbiB0aGUgbG9vcCBhYm92ZSwgdGhvdWdoIG1heWJlIG5vdCBhcyBwZXJmb3JtYW50LiBcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgbzogR2VuZXJhbCA9IE9iamVjdC5jcmVhdGUoc2NyaXB0KTtcbiAgICAgICAgICAgIGlmIChvLnByb3RvdHlwZSBpbnN0YW5jZW9mIENvbXBvbmVudFNjcmlwdClcbiAgICAgICAgICAgICAgY29tcG9tZW50c1tuYW1lc3BhY2VdLnB1c2goc2NyaXB0KTtcbiAgICAgICAgICB9IGNhdGNoIChfZSkgeyAvKiAqLyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb21lbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2NyaXB0IGZyb20gdGhlIGdpdmVuIFVSTCBhbmQgaW50ZWdyYXRlcyBpdCBpbnRvIGEge0BsaW5rIEhUTUxTY3JpcHRFbGVtZW50fSBpbiB0aGUge0BsaW5rIGRvY3VtZW50LmhlYWR9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkU2NyaXB0KF91cmw6IFJlcXVlc3RJbmZvKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBsZXQgc2NyaXB0OiBIVE1MU2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAvLyBzY3JpcHQudHlwZSA9IFwibW9kdWxlXCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBmYWxzZTtcbiAgICAgIC8vIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBoYW5kbGVMb2FkZWRTY3JpcHQpXG4gICAgICBsZXQgaGVhZDogSFRNTEhlYWRFbGVtZW50ID0gZG9jdW1lbnQuaGVhZDtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgIERlYnVnLmxvZyhcIkxvYWRpbmc6IFwiLCBfdXJsKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gX3Jlc29sdmUoKSk7XG4gICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICAgIERlYnVnLmVycm9yKFwiTG9hZGluZyBzY3JpcHRcIiwgX3VybCk7XG4gICAgICAgICAgX3JlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IF91cmwudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQge0BsaW5rIFJlc291cmNlc30gZnJvbSB0aGUgZ2l2ZW4gdXJsXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkUmVzb3VyY2VzKF91cmw6IFJlcXVlc3RJbmZvKTogUHJvbWlzZTxSZXNvdXJjZXM+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IGZldGNoKF91cmwpO1xuICAgICAgY29uc3QgcmVzb3VyY2VGaWxlQ29udGVudDogc3RyaW5nID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IFNlcmlhbGl6ZXIucGFyc2UocmVzb3VyY2VGaWxlQ29udGVudCk7XG4gICAgICBsZXQgcmVjb25zdHJ1Y3Rpb246IFJlc291cmNlcyA9IGF3YWl0IFByb2plY3QuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XG4gICAgICBQcm9qZWN0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULlJFU09VUkNFU19MT0FERUQsIHsgZGV0YWlsOiB7IHVybDogX3VybCwgcmVzb3VyY2VzOiByZWNvbnN0cnVjdGlvbiB9IH0pKTtcbiAgICAgIHJldHVybiByZWNvbnN0cnVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGFsbCByZXNvdXJjZXMgZnJvbSB0aGUge0BsaW5rIGRvY3VtZW50LmhlYWR9XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkUmVzb3VyY2VzRnJvbUhUTUwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBoZWFkOiBIVE1MSGVhZEVsZW1lbnQgPSBkb2N1bWVudC5oZWFkO1xuICAgICAgbGV0IGxpbmtzOiBOb2RlTGlzdE9mPEhUTUxMaW5rRWxlbWVudD4gPSBoZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3R5cGU9cmVzb3VyY2VzXVwiKTtcbiAgICAgIGZvciAobGV0IGxpbmsgb2YgbGlua3MpIHtcbiAgICAgICAgbGV0IHVybDogUmVxdWVzdEluZm8gPSBsaW5rLmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgICAgYXdhaXQgUHJvamVjdC5sb2FkUmVzb3VyY2VzKHVybCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIGFsbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMge1xuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgaWRSZXNvdXJjZSBpbiBQcm9qZWN0LnJlc291cmNlcykge1xuICAgICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gUHJvamVjdC5yZXNvdXJjZXNbaWRSZXNvdXJjZV07XG4gICAgICAgIGlmIChpZFJlc291cmNlICE9IHJlc291cmNlLmlkUmVzb3VyY2UpXG4gICAgICAgICAgRGVidWcuZXJyb3IoXCJSZXNvdXJjZS1pZCBtaXNtYXRjaFwiLCByZXNvdXJjZSk7XG4gICAgICAgIHNlcmlhbGl6YXRpb25baWRSZXNvdXJjZV0gPSBTZXJpYWxpemVyLnNlcmlhbGl6ZShyZXNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgcmVzb3VyY2VzIGZyb20gYSBzZXJpYWxpemF0aW9uLCBkZWxldGluZyBhbGwgcmVzb3VyY2VzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZFxuICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvbiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMpOiBQcm9taXNlPFJlc291cmNlcz4ge1xuICAgICAgUHJvamVjdC5zZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb247XG4gICAgICBQcm9qZWN0LnJlc291cmNlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgaWRSZXNvdXJjZSBpbiBfc2VyaWFsaXphdGlvbikge1xuICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IF9zZXJpYWxpemF0aW9uW2lkUmVzb3VyY2VdO1xuICAgICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gYXdhaXQgUHJvamVjdC5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xuICAgICAgICBpZiAocmVzb3VyY2UpXG4gICAgICAgICAgUHJvamVjdC5yZXNvdXJjZXNbaWRSZXNvdXJjZV0gPSByZXNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9qZWN0LnJlc291cmNlcztcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZVJlc291cmNlKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZT4ge1xuICAgICAgcmV0dXJuIDxQcm9taXNlPFNlcmlhbGl6YWJsZVJlc291cmNlPj5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlLkZCWCB7XG4gIC8qKlxuICAgKiBSZWFkZXIgdG8gcmVhZCBkYXRhIGZyb20gYW4gYXJyYXkgYnVmZmVyIG1vcmUgY29udmVuaWVudGx5LlxuICAgKiBJdCBzYXZlcyBhIGN1cnJlbnQgb2Zmc2V0IHdoaWNoIGlzIHVwZGF0ZWQgd2hlbiBkYXRhIGlzIHJlYWQgZHVlIHRvIGl0cyBieXRlbGVuZ3RoLlxuICAgKiBkZXNwaXRlIGdldFNlcXVlbmNlIGl0IGlzIG1vc3RseSBhIGNvcHkgb2YgdGhlIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3BpY29kZTcvYmluYXJ5LXJlYWRlclxuICAgKiBAYXV0aG9yIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzXG4gICAqL1xuICBleHBvcnQgY2xhc3MgQnVmZmVyUmVhZGVyIHtcbiAgICBwdWJsaWMgb2Zmc2V0OiBudW1iZXI7XG4gICAgcHVibGljIHJlYWRvbmx5IHZpZXc6IERhdGFWaWV3O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9idWZmZXI6IEFycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoX2J1ZmZlcik7XG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgcHVibGljIGdldENoYXIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXRVaW50OChfb2Zmc2V0KSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEJvb2woX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFVpbnQ4KF9vZmZzZXQpICE9IDA7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFVpbnQ4KF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogbnVtYmVyIHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gX29mZnNldCArIDE7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KF9vZmZzZXQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRVaW50MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgNDtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDMyKF9vZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRVaW50NjQoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBiaWdpbnQge1xuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgODtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0QmlnVWludDY0KF9vZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRJbnQxNihfb2Zmc2V0OiBudW1iZXIgPSB0aGlzLm9mZnNldCk6IG51bWJlciB7XG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyAyO1xuICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQxNihfb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0SW50MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgNDtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SW50MzIoX29mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEludDY0KF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogYmlnaW50IHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gX29mZnNldCArIDg7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEJpZ0ludDY0KF9vZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRGbG9hdDMyKF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogbnVtYmVyIHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gX29mZnNldCArIDQ7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0MzIoX29mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldEZsb2F0NjQoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgODtcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NChfb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U3RyaW5nKF9sZW5ndGg6IG51bWJlciwgX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4udGhpcy5nZXRTZXF1ZW5jZSh0aGlzLmdldFVpbnQ4LCBfbGVuZ3RoLCBfb2Zmc2V0KSk7XG4gICAgfVxuXG4gICAgcHVibGljICpnZXRTZXF1ZW5jZTxUIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihfZ2V0dGVyOiAoKSA9PiBULCBfbGVuZ3RoOiBudW1iZXIsIF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogR2VuZXJhdG9yPFQ+IHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gX29mZnNldDtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeWllbGQgX2dldHRlci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIi8qKiBAaWdub3JlIGN1cnJlbnRseSBub3Qgd29ya2luZyAqL1xubmFtZXNwYWNlIEZ1ZGdlQ29yZS5GQlgge1xuICAvKipcbiAgICogSW50ZXJmYWNlIHRvIHJlcHJlc2VudCBmYnggZmlsZXMgY29udGFpbmluZyBpdHMgZG9jdW1lbnRzLCBkZWZpbml0aW9ucywgb2JqZWN0cyBhbmQgY29ubmVjdGlvbnMuXG4gICAqIEl0cyBvYmplY3RzIGFyZSBkZXZpZGVkIGluIGFsbCBhbmQgdGhlIGRpZmZlcmVudCBvYmplY3QgdHlwZXMuXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgRkJYIHtcbiAgICBkb2N1bWVudHM6IERvY3VtZW50W107XG4gICAgZGVmaW5pdGlvbnM/OiBEZWZpbml0aW9ucztcbiAgICBvYmplY3RzOiB7XG4gICAgICBhbGw6IE9iamVjdFtdO1xuICAgICAgbW9kZWxzOiBNb2RlbFtdO1xuICAgICAgZ2VvbWV0cmllczogR2VvbWV0cnlbXTtcbiAgICAgIHBvc2VzOiBPYmplY3RbXTtcbiAgICAgIG1hdGVyaWFsczogTWF0ZXJpYWxbXTtcbiAgICAgIHRleHR1cmVzOiBUZXh0dXJlW107XG4gICAgICBhbmltU3RhY2tzOiBPYmplY3RbXTtcbiAgICB9O1xuICAgIGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uW107XG4gIH1cblxuICBpbnRlcmZhY2UgT2JqZWN0QmFzZSB7XG4gICAgdWlkOiBudW1iZXI7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gICAgc3VidHlwZT86IHN0cmluZztcbiAgICBjaGlsZHJlbj86IE9iamVjdFtdO1xuICAgIHBhcmVudHM/OiBPYmplY3RbXTtcblxuICAgIGxvYWRlZDogYm9vbGVhbjtcbiAgICBsb2FkOiAoKSA9PiBPYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIHRvIHJlcHJlc2VudCBmYngtb2JqZWN0cy5cbiAgICogQWxsIGZpZWxkcyBvdGhlciB0aGFuIHVpZCwgbmFtZSwgdHlwZSwgc3VidHlwZSwgY2hpbGRyZW4gYW5kIHBhcmVudHMgYXJlIGxvYWRlZCB3aXRoIHRoZSBsb2FkLW1ldGhvZC5cbiAgICogRWFjaCBvYmplY3QgY2FuIGJlIGludGVycHJldGVkIGFzIGFuIGV4cGxpY2l0IGZieCBvYmplY3QgdHlwZSBkZWZpbmVkIGluIEZ1ZGdlQ29yZS5GQlguIEV4cGxpY2l0IHR5cGVzIGhhdmUgYmVlbiBkZWZpbmVkXG4gICAqIHdpdGggdGhlIGhlbHAgb2YgZm9sbG93aW5nIHJlZmVyZW5jZTpcbiAgICogaHR0cHM6Ly9hcmNoaXZlLmJsZW5kZXIub3JnL3dpa2kvaW5kZXgucGhwL1VzZXI6TW9udDI5L0ZvdW5kYXRpb24vRkJYX0ZpbGVfU3RydWN0dXJlLyNTb21lX1NwZWNpZmljX1Byb3BlcnR5X1R5cGVzXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBPYmplY3QgZXh0ZW5kcyBPYmplY3RCYXNlIHtcbiAgICBbbmFtZTogc3RyaW5nXTogTm9kZVByb3BlcnR5IHwgeyBbbmFtZTogc3RyaW5nXTogTm9kZVByb3BlcnR5IH0gfCBQcm9wZXJ0eTcwIHwgT2JqZWN0IHwgT2JqZWN0W10gfCAoKCkgPT4gT2JqZWN0KTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnQgZXh0ZW5kcyBPYmplY3RCYXNlIHtcbiAgICBTb3VyY2VPYmplY3Q/OiB1bmRlZmluZWQ7XG4gICAgQWN0aXZlQW5pbVN0YWNrTmFtZT86IHN0cmluZztcbiAgICBSb290Tm9kZT86IG51bWJlcjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgTm9kZUF0dHJpYnV0ZSBleHRlbmRzIE9iamVjdEJhc2Uge1xuICAgIFR5cGVGbGFncz86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgR2VvbWV0cnkgZXh0ZW5kcyBPYmplY3RCYXNlIHtcbiAgICBHZW9tZXRyeVZlcnNpb24/OiBudW1iZXI7XG4gICAgVmVydGljZXM/OiBGbG9hdDMyQXJyYXk7XG4gICAgUG9seWdvblZlcnRleEluZGV4PzogSW50MzJBcnJheTtcbiAgICBMYXllckVsZW1lbnROb3JtYWw/OiBMYXllckVsZW1lbnROb3JtYWw7XG4gICAgTGF5ZXJFbGVtZW50VVY/OiBMYXllckVsZW1lbnRVVjsgLy8gfCBMYXllckVsZW1lbnRVVltdOyAvLyBUT0RPOiBtaWdodCBuZWVkIHRvIHJlYWRkIHRoaXNcbiAgICBMYXllckVsZW1lbnRNYXRlcmlhbD86IExheWVyRWxlbWVudE1hdGVyaWFsO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBNb2RlbCBleHRlbmRzIE9iamVjdEJhc2Uge1xuICAgIFZlcnNpb24/OiBudW1iZXI7XG4gICAgTGNsVHJhbnNsYXRpb24/OiBWZWN0b3IzIHwgQW5pbUN1cnZlTm9kZTtcbiAgICBMY2xSb3RhdGlvbj86IFZlY3RvcjMgfCBBbmltQ3VydmVOb2RlO1xuICAgIExjbFNjYWxpbmc/OiBWZWN0b3IzIHwgQW5pbUN1cnZlTm9kZTtcbiAgICBQcmVSb3RhdGlvbj86IFZlY3RvcjM7XG4gICAgUG9zdFJvdGF0aW9uPzogVmVjdG9yMztcbiAgICBTY2FsaW5nT2Zmc2V0PzogVmVjdG9yMztcbiAgICBTY2FsaW5nUGl2b3Q/OiBWZWN0b3IzO1xuICAgIFJvdGF0aW9uT2Zmc2V0PzogVmVjdG9yMztcbiAgICBSb3RhdGlvblBpdm90PzogVmVjdG9yMztcbiAgICBJbmhlcml0VHlwZT86IG51bWJlcjtcbiAgICBFdWxlck9yZGVyPzogc3RyaW5nO1xuICAgIGN1cnJlbnRVVlNldD86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWF0ZXJpYWwgZXh0ZW5kcyBPYmplY3RCYXNlIHtcbiAgICBWZXJzaW9uPzogbnVtYmVyO1xuICAgIFNoYWRpbmdNb2RlbD86IHN0cmluZztcblxuICAgIERpZmZ1c2U/OiBWZWN0b3IzO1xuICAgIERpZmZ1c2VDb2xvcj86IFZlY3RvcjMgfCBUZXh0dXJlO1xuICAgIERpZmZ1c2VGYWN0b3I/OiBudW1iZXI7XG5cbiAgICBBbWJpZW50PzogVmVjdG9yMztcbiAgICBBbWJpZW50Q29sb3I/OiBWZWN0b3IzIHwgVGV4dHVyZTtcblxuICAgIFNoaW5pbmVzcz86IG51bWJlcjtcbiAgICBTaGluaW5lc3NFeHBvbmVudD86IFZlY3RvcjMgfCBUZXh0dXJlO1xuXG4gICAgU3BlY3VsYXI/OiBWZWN0b3IzO1xuICAgIFNwZWN1bGFyQ29sb3I/OiBWZWN0b3IzIHwgVGV4dHVyZTtcbiAgICBTcGVjdWxhckZhY3Rvcj86IG51bWJlcjtcblxuICAgIFJlZmxlY3Rpdml0eT86IG51bWJlcjtcbiAgICBSZWZsZWN0aW9uRmFjdG9yPzogbnVtYmVyO1xuXG4gICAgT3BhY2l0eT86IG51bWJlcjtcbiAgICBUcmFuc3BhcmVuY3lGYWN0b3I/OiBudW1iZXI7XG5cbiAgICBFbWlzc2l2ZT86IFZlY3RvcjM7XG4gICAgTm9ybWFsTWFwPzogVGV4dHVyZTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRGVmb3JtZXIgZXh0ZW5kcyBPYmplY3RCYXNlIHtcbiAgICBWZXJzaW9uPzogbnVtYmVyO1xuICAgIFNraW5uaW5nVHlwZT86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgU3ViRGVmb3JtZXIgZXh0ZW5kcyBPYmplY3RCYXNlIHtcbiAgICBWZXJzaW9uPzogbnVtYmVyO1xuICAgIFRyYW5zZm9ybT86IEZsb2F0MzJBcnJheTtcbiAgICBUcmFuc2Zvcm1MaW5rPzogRmxvYXQzMkFycmF5O1xuICAgIEluZGV4ZXM/OiBVaW50MTZBcnJheTtcbiAgICBXZWlnaHRzPzogRmxvYXQzMkFycmF5O1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlIGV4dGVuZHMgT2JqZWN0QmFzZSB7XG4gICAgRmlsZU5hbWU/OiBzdHJpbmc7XG4gICAgUmVsYXRpdmVGaWxlbmFtZT86IHN0cmluZztcbiAgICBNb2RlbFVWU2NhbGluZz86IG51bWJlcjtcbiAgICBNb2RlbFVWVHJhbnNsYXRpb24/OiBudW1iZXI7XG4gICAgVVZTZXQ/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFZpZGVvIGV4dGVuZHMgT2JqZWN0QmFzZSB7XG4gICAgRmlsZU5hbWU/OiBzdHJpbmc7XG4gICAgUmVsYXRpdmVGaWxlbmFtZT86IHN0cmluZztcbiAgICBVc2VNaXBNYXA/OiBudW1iZXI7XG4gICAgQ29udGVudD86IFVpbnQ4QXJyYXk7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1DdXJ2ZU5vZGUgZXh0ZW5kcyBPYmplY3RCYXNlIHtcbiAgICBkWD86IG51bWJlciB8IEFuaW1DdXJ2ZTtcbiAgICBkWT86IG51bWJlciB8IEFuaW1DdXJ2ZTtcbiAgICBkWj86IG51bWJlciB8IEFuaW1DdXJ2ZTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbUN1cnZlIGV4dGVuZHMgT2JqZWN0QmFzZSB7XG4gICAgS2V5VmVyPzogbnVtYmVyO1xuICAgIERlZmF1bHQ/OiBudW1iZXI7XG4gICAgS2V5VGltZT86IEJpZ0ludDY0QXJyYXk7XG4gICAgS2V5VmFsdWVGbG9hdD86IEZsb2F0MzJBcnJheTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50IHtcbiAgICBOYW1lOiBzdHJpbmc7XG4gICAgVmVyc2lvbjogbnVtYmVyO1xuICAgIE1hcHBpbmdJbmZvcm1hdGlvblR5cGU6IHN0cmluZztcbiAgICBSZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU6IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50Tm9ybWFsIGV4dGVuZHMgTGF5ZXJFbGVtZW50IHtcbiAgICBOb3JtYWxzOiBGbG9hdDMyQXJyYXk7XG4gICAgTm9ybWFsc1c6IEZsb2F0MzJBcnJheTtcbiAgICBOb3JtYWxzSW5kZXg/OiBVaW50MTZBcnJheTsgLy8gVE9ETzogZmluZCBhbiBGQlggZmlsZSB3aGljaCB1c2VzIG5vcm1hbHMgaW5kZXhcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50VVYgZXh0ZW5kcyBMYXllckVsZW1lbnQge1xuICAgIFVWPzogRmxvYXQzMkFycmF5O1xuICAgIFVWSW5kZXg/OiBVaW50MTZBcnJheTtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50TWF0ZXJpYWwgZXh0ZW5kcyBMYXllckVsZW1lbnQge1xuICAgIE1hdGVyaWFscz86IG51bWJlcjtcbiAgfVxuXG4gIGV4cG9ydCBlbnVtIE1BUFBJTkdfSU5GT1JNQVRJT05fVFlQRSB7XG4gICAgQllfVkVSVEVYLCBCWV9QT0xZR09OLCBCWV9QT0xZR09OX1ZFUlRFWCwgQllfRURHRSwgQUxMX1NBTUVcbiAgfVxuXG4gIGV4cG9ydCBlbnVtIFJFRkVSRU5DRV9JTkZPUk1BVElPTl9UWVBFIHtcbiAgICBESVJFQ1QsIElOREVYX1RPX0RJUkVDVFxuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uIHtcbiAgICBwYXJlbnRVSUQ6IG51bWJlcjtcbiAgICBjaGlsZFVJRDogbnVtYmVyO1xuICAgIHByb3BlcnR5TmFtZTogc3RyaW5nO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBEZWZpbml0aW9ucyB7XG4gICAgdmVyc2lvbjogbnVtYmVyO1xuICAgIG9iamVjdFR5cGVzOiBPYmplY3RUeXBlW107XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIE9iamVjdFR5cGUge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBjb3VudDogbnVtYmVyO1xuICAgIHByb3BlcnR5VGVtcGxhdGU6IFByb3BlcnR5VGVtcGxhdGU7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFByb3BlcnR5VGVtcGxhdGUge1xuICAgIFtwcm9wZXJ0eU5hbWU6IHN0cmluZ106IFByb3BlcnR5NzA7XG4gICAgbmFtZTogc3RyaW5nO1xuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBBc3NldCBsb2FkZXIgZm9yIEZpbG1ib3ggZmlsZXMuXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcbiAgICogQGlnbm9yZSBjdXJyZW50bHkgbm90IHdvcmtpbmdcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBGQlhMb2FkZXIge1xuICAgIHByaXZhdGUgc3RhdGljIGxvYWRlcnM6IHsgW3VyaTogc3RyaW5nXTogRkJYTG9hZGVyIH07XG5cbiAgICBzdGF0aWMgI2RlZmF1bHRNYXRlcmlhbDogTWF0ZXJpYWw7XG4gICAgc3RhdGljICNkZWZhdWx0U2tpbk1hdGVyaWFsOiBNYXRlcmlhbDtcblxuICAgIHB1YmxpYyByZWFkb25seSBmYng6IEZCWC5GQlg7XG4gICAgcHVibGljIHJlYWRvbmx5IG5vZGVzOiBGQlguTm9kZVtdO1xuICAgIHB1YmxpYyByZWFkb25seSB1cmk6IHN0cmluZztcblxuICAgICNzY2VuZXM6IEdyYXBoW107XG4gICAgI25vZGVzOiBOb2RlW107XG4gICAgI21lc2hlczogTWVzaEltcG9ydFtdO1xuICAgICNtYXRlcmlhbHM6IE1hdGVyaWFsW107XG4gICAgI3NraW5NYXRlcmlhbHM6IE1hdGVyaWFsW10gPSBbXTtcbiAgICAjdGV4dHVyZXM6IFRleHR1cmVbXTtcbiAgICAjc2tlbGV0b25zOiBDb21wb25lbnRTa2VsZXRvbltdO1xuICAgICNhbmltYXRpb25zOiBBbmltYXRpb25bXTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYnVmZmVyOiBBcnJheUJ1ZmZlciwgX3VyaTogc3RyaW5nKSB7XG4gICAgICB0aGlzLnVyaSA9IF91cmk7XG4gICAgICB0aGlzLm5vZGVzID0gRkJYLnBhcnNlTm9kZXNGcm9tQmluYXJ5KF9idWZmZXIpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5ub2Rlcyk7XG4gICAgICB0aGlzLmZieCA9IEZCWC5sb2FkRnJvbU5vZGVzKHRoaXMubm9kZXMpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5mYngpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldCBkZWZhdWx0TWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xuICAgICAgcmV0dXJuIHRoaXMuI2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy4jZGVmYXVsdE1hdGVyaWFsID1cbiAgICAgICAgbmV3IE1hdGVyaWFsKFwiRkJYRGVmYXVsdE1hdGVyaWFsXCIsIFNoYWRlckdvdXJhdWQsIG5ldyBDb2F0UmVtaXNzaXZlKENvbG9yLkNTUyhcIndoaXRlXCIpKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IGRlZmF1bHRTa2luTWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xuICAgICAgcmV0dXJuIHRoaXMuI2RlZmF1bHRTa2luTWF0ZXJpYWwgfHwgKHRoaXMuI2RlZmF1bHRTa2luTWF0ZXJpYWwgPVxuICAgICAgICBuZXcgTWF0ZXJpYWwoXCJGQlhEZWZhdWx0U2tpbk1hdGVyaWFsXCIsIFNoYWRlckdvdXJhdWRTa2luLCBuZXcgQ29hdFJlbWlzc2l2ZShDb2xvci5DU1MoXCJ3aGl0ZVwiKSkpXG4gICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgTE9BRChfdXJpOiBzdHJpbmcpOiBQcm9taXNlPEZCWExvYWRlcj4ge1xuICAgICAgaWYgKCF0aGlzLmxvYWRlcnMpXG4gICAgICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgICAgaWYgKCF0aGlzLmxvYWRlcnNbX3VyaV0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goX3VyaSk7XG4gICAgICAgIGNvbnN0IGJpbmFyeTogQXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmxvYWRlcnNbX3VyaV0gPSBuZXcgRkJYTG9hZGVyKGJpbmFyeSwgX3VyaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sb2FkZXJzW191cmldO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBnZXRTY2VuZShfaW5kZXg6IG51bWJlciA9IDApOiBQcm9taXNlPEdyYXBoPiB7XG4gICAgICBpZiAoIXRoaXMuI3NjZW5lcylcbiAgICAgICAgdGhpcy4jc2NlbmVzID0gW107XG4gICAgICBpZiAoIXRoaXMuI3NjZW5lc1tfaW5kZXhdKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50RkJYOiBGQlguRG9jdW1lbnQgPSB0aGlzLmZieC5kb2N1bWVudHNbX2luZGV4XS5sb2FkKCk7XG4gICAgICAgIGNvbnN0IHNjZW5lOiBHcmFwaCA9IG5ldyBHcmFwaChkb2N1bWVudEZCWC5uYW1lKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZEZCWCBvZiBkb2N1bWVudEZCWC5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZEZCWC50eXBlID09IFwiTW9kZWxcIikge1xuICAgICAgICAgICAgc2NlbmUuYWRkQ2hpbGQoYXdhaXQgdGhpcy5nZXROb2RlKHRoaXMuZmJ4Lm9iamVjdHMubW9kZWxzLmluZGV4T2YoY2hpbGRGQlgpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmJ4Lm9iamVjdHMuYW5pbVN0YWNrcyAmJiB0aGlzLmZieC5vYmplY3RzLmFuaW1TdGFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbjogQW5pbWF0aW9uID0gYXdhaXQgdGhpcy5nZXRBbmltYXRpb24oZG9jdW1lbnRGQlguQWN0aXZlQW5pbVN0YWNrTmFtZS5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIHRoaXMuZmJ4Lm9iamVjdHMuYW5pbVN0YWNrcy5maW5kSW5kZXgoX2FuaW1TdGFjayA9PiBfYW5pbVN0YWNrLm5hbWUgPT0gZG9jdW1lbnRGQlguQWN0aXZlQW5pbVN0YWNrTmFtZSkgOiAwKTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uKVxuICAgICAgICAgICAgc2NlbmUuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnRBbmltYXRvcihhbmltYXRpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgc2tlbGV0b24gb2YgdGhpcy4jc2tlbGV0b25zKSBcbiAgICAgICAgICBzY2VuZS5hZGRDb21wb25lbnQoc2tlbGV0b24pO1xuXG4gICAgICAgIFByb2plY3QucmVnaXN0ZXIoc2NlbmUpO1xuICAgICAgICB0aGlzLiNzY2VuZXNbX2luZGV4XSA9IHNjZW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3NjZW5lc1tfaW5kZXhdO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBnZXROb2RlKF9pbmRleDogbnVtYmVyKTogUHJvbWlzZTxOb2RlPiB7XG4gICAgICBpZiAoIXRoaXMuI25vZGVzKVxuICAgICAgICB0aGlzLiNub2RlcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLiNub2Rlc1tfaW5kZXhdKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBub2RlIHdpdGggdHJhbnNmb3JtXG4gICAgICAgIGNvbnN0IG1vZGVsRkJYOiBGQlguTW9kZWwgPSB0aGlzLmZieC5vYmplY3RzLm1vZGVsc1tfaW5kZXhdLmxvYWQoKTtcbiAgICAgICAgY29uc3Qgbm9kZTogTm9kZSA9IG5ldyBOb2RlKG1vZGVsRkJYLm5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLmdlbmVyYXRlVHJhbnNmb3JtKG1vZGVsRkJYLCBub2RlKTtcbiAgICAgICAgdGhpcy4jbm9kZXNbX2luZGV4XSA9IG5vZGU7XG5cbiAgICAgICAgLy8gYXR0YWNoIGNoaWxkcmVuIGFuZCBjb21wb25lbnRzXG4gICAgICAgIGlmIChtb2RlbEZCWC5jaGlsZHJlbikgZm9yIChjb25zdCBjaGlsZEZCWCBvZiBtb2RlbEZCWC5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZEZCWC50eXBlID09IFwiTW9kZWxcIikge1xuICAgICAgICAgICAgbm9kZS5hZGRDaGlsZChhd2FpdCB0aGlzLmdldE5vZGUodGhpcy5mYngub2JqZWN0cy5tb2RlbHMuaW5kZXhPZihjaGlsZEZCWCkpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkRkJYLnR5cGUgPT0gXCJHZW9tZXRyeVwiKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNoOiBNZXNoSW1wb3J0ID0gYXdhaXQgdGhpcy5nZXRNZXNoKHRoaXMuZmJ4Lm9iamVjdHMuZ2VvbWV0cmllcy5pbmRleE9mKGNoaWxkRkJYKSk7XG4gICAgICAgICAgICBjb25zdCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gbmV3IENvbXBvbmVudE1lc2gobWVzaCk7XG4gICAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50TWF0ZXJpYWwoRkJYTG9hZGVyLmRlZmF1bHRNYXRlcmlhbCkpO1xuICAgICAgICAgICAgaWYgKG1lc2ggaW5zdGFuY2VvZiBNZXNoU2tpbikge1xuICAgICAgICAgICAgICBjbXBNZXNoLnNrZWxldG9uID0gYXdhaXQgdGhpcy5nZXRTa2VsZXRvbihjaGlsZEZCWC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgIC8vIGZvciAoY29uc3Qgc3ViRGVmb3JtZXJGQlggb2YgY2hpbGRGQlguY2hpbGRyZW5bMF0uY2hpbGRyZW4gYXMgRkJYLlN1YkRlZm9ybWVyW10pIHtcbiAgICAgICAgICAgICAgLy8gICBjb25zdCBib25lOiBOb2RlID0gY21wTWVzaC5za2VsZXRvbi5ib25lc1tzdWJEZWZvcm1lckZCWC5jaGlsZHJlblswXS5uYW1lXTtcbiAgICAgICAgICAgICAgLy8gICBib25lLm10eExvY2FsLnNldChzdWJEZWZvcm1lckZCWC5UcmFuc2Zvcm1MaW5rKTtcbiAgICAgICAgICAgICAgLy8gICBpZiAoYm9uZS5nZXRQYXJlbnQoKSlcbiAgICAgICAgICAgICAgLy8gICAgIGJvbmUubXR4TG9jYWwubXVsdGlwbHkoYm9uZS5nZXRQYXJlbnQoKS5tdHhXb3JsZEludmVyc2UpO1xuICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKS5tYXRlcmlhbCA9IEZCWExvYWRlci5kZWZhdWx0U2tpbk1hdGVyaWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQoY21wTWVzaCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGlsZEZCWC50eXBlID09IFwiTWF0ZXJpYWxcIikge1xuICAgICAgICAgICAgLy8gVE9ETzogYWRkaXRpb25hbCBza2luIG1hdGVyaWFscyBnZXQgY3JlYXRlZCBoZXJlLCBjaGVjayBpZiB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgaXMgc3RpbGwgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCBpTWF0ZXJpYWw6IG51bWJlciA9IHRoaXMuZmJ4Lm9iamVjdHMubWF0ZXJpYWxzLmluZGV4T2YoY2hpbGRGQlgpO1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWw6IE1hdGVyaWFsID0gYXdhaXQgdGhpcy5nZXRNYXRlcmlhbChpTWF0ZXJpYWwpO1xuICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpLm1hdGVyaWFsID0gbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubWVzaCBpbnN0YW5jZW9mIE1lc2hTa2luID9cbiAgICAgICAgICAgICAgdGhpcy4jc2tpbk1hdGVyaWFsc1tpTWF0ZXJpYWxdIHx8ICh0aGlzLiNza2luTWF0ZXJpYWxzW2lNYXRlcmlhbF0gPSBuZXcgTWF0ZXJpYWwoXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwubmFtZSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5nZXRTaGFkZXIoKSA9PSBTaGFkZXJQaG9uZyA/XG4gICAgICAgICAgICAgICAgICBTaGFkZXJQaG9uZ1NraW4gOlxuICAgICAgICAgICAgICAgICAgU2hhZGVyUGhvbmdUZXh0dXJlZFNraW4sXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuY29hdFxuICAgICAgICAgICAgICApKSA6XG4gICAgICAgICAgICAgIG1hdGVyaWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI25vZGVzW19pbmRleF07XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldE1lc2goX2luZGV4OiBudW1iZXIpOiBQcm9taXNlPE1lc2hJbXBvcnQ+IHtcbiAgICAgIGlmICghdGhpcy4jbWVzaGVzKVxuICAgICAgICB0aGlzLiNtZXNoZXMgPSBbXTtcbiAgICAgIGlmICghdGhpcy4jbWVzaGVzW19pbmRleF0pXG4gICAgICAgIHRoaXMuI21lc2hlc1tfaW5kZXhdID0gYXdhaXQgKFxuICAgICAgICAgIHRoaXMuZmJ4Lm9iamVjdHMuZ2VvbWV0cmllc1tfaW5kZXhdLmNoaWxkcmVuPy5bMF0udHlwZSA9PSBcIkRlZm9ybWVyXCIgP1xuICAgICAgICAgICAgbmV3IE1lc2hTa2luKCkgOlxuICAgICAgICAgICAgbmV3IE1lc2hJbXBvcnQoKVxuICAgICAgICApLmxvYWQoTWVzaExvYWRlckZCWCwgdGhpcy51cmksIHRoaXMuZmJ4Lm9iamVjdHMuZ2VvbWV0cmllc1tfaW5kZXhdKTtcbiAgICAgIHJldHVybiB0aGlzLiNtZXNoZXNbX2luZGV4XTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWF0ZXJpYWwoX2luZGV4OiBudW1iZXIpOiBQcm9taXNlPE1hdGVyaWFsPiB7XG4gICAgICBpZiAoIXRoaXMuI21hdGVyaWFscylcbiAgICAgICAgdGhpcy4jbWF0ZXJpYWxzID0gW107XG4gICAgICBpZiAoIXRoaXMuI21hdGVyaWFsc1tfaW5kZXhdKSB7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsRkJYOiBGQlguTWF0ZXJpYWwgPSB0aGlzLmZieC5vYmplY3RzLm1hdGVyaWFsc1tfaW5kZXhdLmxvYWQoKTtcbiAgICAgICAgaWYgKCEobWF0ZXJpYWxGQlguRGlmZnVzZUNvbG9yIGluc3RhbmNlb2YgVmVjdG9yMykpXG4gICAgICAgICAgbWF0ZXJpYWxGQlguRGlmZnVzZUNvbG9yPy5jaGlsZHJlblswXS5sb2FkKCk7XG4gICAgICAgIC8vIEZCWCBzdXBwb3J0cyBsYW1iZXJ0IGFuZCBwaG9uZyBzaGFkaW5nLCBlaXRoZXIgd2F5IGZ1ZGdlIGhhcyBubyBsYW1iZXJ0IHNoYWRlciBzbyB3ZSBhbHdheXMgdXNlIHBob25nLlxuICAgICAgICAvLyBJbiBEaWZmdXNlQ29sb3IgdGhlIHRleHR1cmUgb2YgdGhlIG1hdGVyaWFsIGNvbG9yIGlzIHN0b3JlZCwgaWYgaXQncyBkZWZpbmVkIHdlIHVzZSBhIHRleHR1cmUgc2hhZGVyLlxuICAgICAgICAvLyBUT0RPOiBtYXRlcmlhbEZCWCBhbHNvIGNvbnRhaW5zIGFkZGl0aW9uYWwgdmFsdWVzIGxpa2Ugc2hpbmluZXNzIGFuZCByZWZsZWN0aXZpdHkgKGFuZCBvdGhlcnMpIHdoaWNoIGFyZSBub3Qgc3VwcHBvcnRlZC5cbiAgICAgICAgdGhpcy4jbWF0ZXJpYWxzW19pbmRleF0gPSBuZXcgTWF0ZXJpYWwoXG4gICAgICAgICAgbWF0ZXJpYWxGQlgubmFtZSxcbiAgICAgICAgICBtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgJiYgIShtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgaW5zdGFuY2VvZiBWZWN0b3IzKSA/XG4gICAgICAgICAgICBTaGFkZXJQaG9uZ1RleHR1cmVkIDpcbiAgICAgICAgICAgIFNoYWRlclBob25nLFxuICAgICAgICAgIG1hdGVyaWFsRkJYLkRpZmZ1c2VDb2xvciAmJiAhKG1hdGVyaWFsRkJYLkRpZmZ1c2VDb2xvciBpbnN0YW5jZW9mIFZlY3RvcjMpID9cbiAgICAgICAgICAgIG5ldyBDb2F0UmVtaXNzaXZlVGV4dHVyZWQoXG4gICAgICAgICAgICAgIG5ldyBDb2xvciguLi5tYXRlcmlhbEZCWC5EaWZmdXNlLmdldCgpKSxcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKHRoaXMuZmJ4Lm9iamVjdHMudGV4dHVyZXMuaW5kZXhPZihtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IpKSxcbiAgICAgICAgICAgICAgbWF0ZXJpYWxGQlguRGlmZnVzZUZhY3RvciA/PyAxLFxuICAgICAgICAgICAgICBtYXRlcmlhbEZCWC5TcGVjdWxhckZhY3RvciA/PyBhdmVyYWdlKG1hdGVyaWFsRkJYLlNwZWN1bGFyPy5nZXQoKSkgPz8gMFxuICAgICAgICAgICAgKSA6XG4gICAgICAgICAgICBuZXcgQ29hdFJlbWlzc2l2ZShcbiAgICAgICAgICAgICAgbmV3IENvbG9yKC4uLihtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgYXMgVmVjdG9yMyA/PyBtYXRlcmlhbEZCWC5EaWZmdXNlKS5nZXQoKSksXG4gICAgICAgICAgICAgIG1hdGVyaWFsRkJYLkRpZmZ1c2VGYWN0b3IgPz8gMSxcbiAgICAgICAgICAgICAgbWF0ZXJpYWxGQlguU3BlY3VsYXJGYWN0b3IgPz8gYXZlcmFnZShtYXRlcmlhbEZCWC5TcGVjdWxhcj8uZ2V0KCkpID8/IDBcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNtYXRlcmlhbHNbX2luZGV4XTtcblxuICAgICAgZnVuY3Rpb24gYXZlcmFnZShfYXJyYXk6IEZsb2F0MzJBcnJheSk6IG51bWJlciB7IC8vIFRPRE86IHNwZWN1bGFyIGZhY3RvciB2ZWN0b3IgKHRvZ2V0aGVyIHdpdGggc3BlY3VsYXIgY29sb3IgdGV4dHVyZSkgaXMgbm90IHN1cHBvcnRlZCBzbyB3ZSB1c2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHZlY3RvciB0byBhcHByb3hpbWF0ZSBhIHNpbmd1bGFyIHNwZWN1bGFyIGZhY3Rvci5cbiAgICAgICAgaWYgKF9hcnJheSlcbiAgICAgICAgICByZXR1cm4gX2FycmF5LnJlZHVjZSgoX2EsIF9iKSA9PiBfYSArIF9iKSAvIF9hcnJheS5sZW5ndGg7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBnZXRUZXh0dXJlKF9pbmRleDogbnVtYmVyKTogUHJvbWlzZTxUZXh0dXJlPiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4jdGV4dHVyZXMpXG4gICAgICAgICAgdGhpcy4jdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuI3RleHR1cmVzW19pbmRleF0pXG4gICAgICAgICAgcmV0dXJuIF9yZXNvbHZlKHRoaXMuI3RleHR1cmVzW19pbmRleF0pO1xuXG4gICAgICAgIGNvbnN0IHZpZGVvRkJYOiBGQlguVmlkZW8gPSB0aGlzLmZieC5vYmplY3RzLnRleHR1cmVzW19pbmRleF0uY2hpbGRyZW5bMF07XG4gICAgICAgIGNvbnN0IHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG5ldyBUZXh0dXJlSW1hZ2UoKTtcbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0ZXh0dXJlLmltYWdlLm9ubG9hZCA9ICgpID0+IF9yZXNvbHZlKHRleHR1cmUpO1xuICAgICAgICB0ZXh0dXJlLmltYWdlLm9uZXJyb3IgPSBfcmVqZWN0O1xuICAgICAgICB0ZXh0dXJlLmltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3ZpZGVvRkJYLkNvbnRlbnRdLCB7IHR5cGU6IFwiaW1hZ2UvcG5nXCIgfSkpO1xuICAgICAgICB0aGlzLiN0ZXh0dXJlc1tfaW5kZXhdID0gdGV4dHVyZTtcbiAgICAgICAgLy8gVE9ETzogZ2V0IGFuZCBzZXQgbWlwbWFwIGluZm9ybWF0aW9uID8/P1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUHJvYmxlbTogbWVocmVyZSBEZWZvcm1lciB2ZXJ3ZWlzZW4gYXVmIGRhcyBzZWxiZSBTa2VsZXR0IGFiZXIgbnV0emVuIGRhYmVpIG5pY2h0IGltbWVyIGFsbGUgS25vY2hlblxuICAgIC8vID0+IFByb2JsZW0gYmVzdGVodCBhdWNoIGltIEdMVEZMb2FkZXJcbiAgICAvKipcbiAgICAgKiBSZXRyaWVmcyB0aGUgc2tlbGV0b24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGltYiBub2RlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRTa2VsZXRvbihfZmJ4TGltYk5vZGU6IEZCWC5Nb2RlbCk6IFByb21pc2U8Q29tcG9uZW50U2tlbGV0b24+IHtcbiAgICAgIGlmICghdGhpcy4jc2tlbGV0b25zKVxuICAgICAgICB0aGlzLiNza2VsZXRvbnMgPSBbXTtcbiAgICAgIHJldHVybiB0aGlzLiNza2VsZXRvbnMuZmluZChfc2tlbGV0b24gPT4gX2ZieExpbWJOb2RlLm5hbWUgaW4gX3NrZWxldG9uLmJvbmVzKSB8fCBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBza2VsZXRvbjogQ29tcG9uZW50U2tlbGV0b24gPSBuZXcgQ29tcG9uZW50U2tlbGV0b24oKTsgLy8gbmV3IFNrZWxldG9uKGBTa2VsZXRvbiR7dGhpcy4jc2tlbGV0b25zLmxlbmd0aH1gKTtcbiAgICAgICAgbGV0IHJvb3ROb2RlOiBGQlguTW9kZWwgPSBfZmJ4TGltYk5vZGU7XG4gICAgICAgIHdoaWxlIChyb290Tm9kZS5wYXJlbnRzICYmIHJvb3ROb2RlLnBhcmVudHMuc29tZShfcGFyZW50ID0+IF9wYXJlbnQuc3VidHlwZSA9PSBcIkxpbWJOb2RlXCIpKVxuICAgICAgICAgIHJvb3ROb2RlID0gcm9vdE5vZGUucGFyZW50cy5maW5kKF9wYXJlbnQgPT4gX3BhcmVudC5zdWJ0eXBlID09IFwiTGltYk5vZGVcIik7XG4gICAgICAgIGNvbnN0IGlSb290Tm9kZTogbnVtYmVyID0gdGhpcy5mYngub2JqZWN0cy5tb2RlbHMuZmluZEluZGV4KF9tb2RlbCA9PiBfbW9kZWwubmFtZSA9PSByb290Tm9kZS5uYW1lKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYXdhaXQgdGhpcy5nZXROb2RlKGlSb290Tm9kZSkpIHtcbiAgICAgICAgICAvLyBUT0RPOiBtYXliZSBtb3ZlIHRoaXMgaW50byB0aGUgY29tcG9uZW50LCBhcyB0aGlzIGlzIHByb2JhYmx5IG5lZWRlZCBpbiBnbHRmIGltcG9ydCBhc3dlbGxcbiAgICAgICAgICBpZiAodGhpcy5mYngub2JqZWN0cy5tb2RlbHNbdGhpcy4jbm9kZXMuaW5kZXhPZihub2RlKV0uc3VidHlwZSA9PSBcIkxpbWJOb2RlXCIpIHtcbiAgICAgICAgICAgIG5vZGUubXR4V29ybGQuc2V0KFxuICAgICAgICAgICAgICBub2RlLmNtcFRyYW5zZm9ybSA/XG4gICAgICAgICAgICAgICAgTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKG5vZGUuZ2V0UGFyZW50KCkubXR4V29ybGQsIG5vZGUubXR4TG9jYWwpIDpcbiAgICAgICAgICAgICAgICBub2RlLmdldFBhcmVudCgpLm10eFdvcmxkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5tdHhXb3JsZEludmVyc2Uuc2V0KE1hdHJpeDR4NC5JTlZFUlNJT04obm9kZS5tdHhXb3JsZCkpO1xuICAgICAgICAgICAgc2tlbGV0b24uYWRkQm9uZShub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNza2VsZXRvbnMucHVzaChza2VsZXRvbik7XG4gICAgICAgIHJldHVybiBza2VsZXRvbjtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGdldEFuaW1hdGlvbihfaW5kZXg6IG51bWJlcik6IFByb21pc2U8QW5pbWF0aW9uPiB7XG4gICAgICBpZiAoIXRoaXMuI2FuaW1hdGlvbnMpXG4gICAgICAgIHRoaXMuI2FuaW1hdGlvbnMgPSBbXTtcbiAgICAgIGlmICghdGhpcy4jYW5pbWF0aW9uc1tfaW5kZXhdKSB7XG4gICAgICAgIGNvbnN0IGFuaW1TdGFjazogRkJYLk9iamVjdCA9IHRoaXMuZmJ4Lm9iamVjdHMuYW5pbVN0YWNrc1tfaW5kZXhdO1xuICAgICAgICBjb25zdCBhbmltTm9kZXNGQlg6IEZCWC5BbmltQ3VydmVOb2RlW10gPSBhbmltU3RhY2suY2hpbGRyZW5bMF0uY2hpbGRyZW47XG5cbiAgICAgICAgbGV0IGZieEFuaW1Ob2RlR3JvdXBlZDogTWFwPEZCWC5Nb2RlbCwgRkJYLkFuaW1DdXJ2ZU5vZGVbXT4gPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgZmJ4QW5pbU5vZGUgb2YgYW5pbU5vZGVzRkJYKSB7XG4gICAgICAgICAgY29uc3Qga2V5OiBGQlguTW9kZWwgPSBmYnhBbmltTm9kZS5wYXJlbnRzLmZpbmQoX3BhcmVudCA9PiBfcGFyZW50LnR5cGUgPT0gXCJNb2RlbFwiKTtcbiAgICAgICAgICBpZiAoa2V5ID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICghZmJ4QW5pbU5vZGVHcm91cGVkLmhhcyhrZXkpKVxuICAgICAgICAgICAgZmJ4QW5pbU5vZGVHcm91cGVkLnNldChrZXksIFtdKTtcbiAgICAgICAgICBmYnhBbmltTm9kZUdyb3VwZWQuZ2V0KGtleSkucHVzaChmYnhBbmltTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbmltYXRpb25TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3QgW2ZieE1vZGVsLCBmYnhBbmltTm9kZXNdIG9mIGZieEFuaW1Ob2RlR3JvdXBlZCkge1xuICAgICAgICAgIGxldCBjdXJyZW50U3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSBhbmltYXRpb25TdHJ1Y3R1cmU7XG5cbiAgICAgICAgICBsZXQgcGFyZW50OiBGQlguTW9kZWwgPSBmYnhNb2RlbC5wYXJlbnRzLmZpbmQoX3BhcmVudCA9PiBfcGFyZW50LnR5cGUgPT0gXCJNb2RlbFwiKTtcbiAgICAgICAgICBsZXQgcGF0aDogRkJYLk1vZGVsW10gPSBbXTtcbiAgICAgICAgICBwYXRoLnB1c2goZmJ4TW9kZWwpO1xuICAgICAgICAgIHdoaWxlIChwYXJlbnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRzLmZpbmQoX3BhcmVudCA9PiBfcGFyZW50LnR5cGUgPT0gXCJNb2RlbFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGZieFBhdGhNb2RlbCBvZiBwYXRoLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLmNoaWxkcmVuID0ge307XG5cbiAgICAgICAgICAgIGlmICgoY3VycmVudFN0cnVjdHVyZS5jaGlsZHJlbiBhcyBBbmltYXRpb25TdHJ1Y3R1cmUpW2ZieFBhdGhNb2RlbC5uYW1lXSA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIChjdXJyZW50U3RydWN0dXJlLmNoaWxkcmVuIGFzIEFuaW1hdGlvblN0cnVjdHVyZSlbZmJ4UGF0aE1vZGVsLm5hbWVdID0ge307XG4gICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlID0gKGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gYXMgQW5pbWF0aW9uU3RydWN0dXJlKVtmYnhQYXRoTW9kZWwubmFtZV0gYXMgQW5pbWF0aW9uU3RydWN0dXJlO1xuXG4gICAgICAgICAgICBpZiAoZmJ4UGF0aE1vZGVsID09IGZieE1vZGVsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG10eExvY2FsOiBBbmltYXRpb25TZXF1ZW5jZU1hdHJpeDR4NCA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZieEFuaW1Ob2RlIG9mIGZieEFuaW1Ob2RlcylcbiAgICAgICAgICAgICAgICBtdHhMb2NhbFt7XG4gICAgICAgICAgICAgICAgICBUOiBcInRyYW5zbGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBSOiBcInJvdGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBTOiBcInNjYWxlXCJcbiAgICAgICAgICAgICAgICB9W2ZieEFuaW1Ob2RlLm5hbWVdXSA9IHRoaXMuZ2V0QW5pbWF0aW9uVmVjdG9yMyhmYnhBbmltTm9kZSwgZmJ4UGF0aE1vZGVsKTtcbiAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZS5jb21wb25lbnRzID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudFRyYW5zZm9ybTogW1xuICAgICAgICAgICAgICAgICAgeyBtdHhMb2NhbDogbXR4TG9jYWwgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNhbmltYXRpb25zW19pbmRleF0gPSBuZXcgQW5pbWF0aW9uKGFuaW1TdGFjay5uYW1lLCBhbmltYXRpb25TdHJ1Y3R1cmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2FuaW1hdGlvbnNbX2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmZXRjaGVkIGZyb20gdGhyZWUuanMsIGFkYXB0ZWQgdG8gRlVER0UgYW5kIG9wdGltaXplZFxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZXYvZXhhbXBsZXMvanNtL2xvYWRlcnMvRkJYTG9hZGVyLmpzXG4gICAgICogbGluZSAzOTUwXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVRyYW5zZm9ybShfbW9kZWxGQlg6IEZCWC5Nb2RlbCwgX25vZGU6IE5vZGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudEluZGV4OiBudW1iZXIgPSB0aGlzLmZieC5vYmplY3RzLm1vZGVscy5pbmRleE9mKF9tb2RlbEZCWC5wYXJlbnRzLmZpbmQoX3BhcmVudCA9PiBfcGFyZW50LnR5cGUgPT0gXCJNb2RlbFwiKSk7XG4gICAgICBjb25zdCBwYXJlbnQ6IE5vZGUgPSBwYXJlbnRJbmRleCA+PSAwID8gYXdhaXQgdGhpcy5nZXROb2RlKHBhcmVudEluZGV4KSA6IHVuZGVmaW5lZDtcblxuICAgICAgY29uc3QgbXR4TG9jYWxSb3RhdGlvbjogTWF0cml4NHg0ID0gX21vZGVsRkJYLlByZVJvdGF0aW9uIHx8IF9tb2RlbEZCWC5MY2xSb3RhdGlvbiB8fCBfbW9kZWxGQlguUG9zdFJvdGF0aW9uID9cbiAgICAgICAgTWF0cml4NHg0LklERU5USVRZKCkgOlxuICAgICAgICB1bmRlZmluZWQ7XG4gICAgICBpZiAoX21vZGVsRkJYLlByZVJvdGF0aW9uKSB7XG4gICAgICAgIG10eExvY2FsUm90YXRpb24ucm90YXRlKHRoaXMuZ2V0T3JkZXJlZChfbW9kZWxGQlguUHJlUm90YXRpb24sIF9tb2RlbEZCWCkpO1xuICAgICAgfVxuICAgICAgaWYgKF9tb2RlbEZCWC5MY2xSb3RhdGlvbikge1xuICAgICAgICBtdHhMb2NhbFJvdGF0aW9uLnJvdGF0ZSh0aGlzLmdldE9yZGVyZWQodGhpcy5nZXRUcmFuc2Zvcm1WZWN0b3IoX21vZGVsRkJYLkxjbFJvdGF0aW9uLCBWZWN0b3IzLlpFUk8pLCBfbW9kZWxGQlgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChfbW9kZWxGQlguUG9zdFJvdGF0aW9uKSB7XG4gICAgICAgIGxldCBtdHhQb3N0Um90YXRpb25JbnZlcnNlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT04odGhpcy5nZXRPcmRlcmVkKF9tb2RlbEZCWC5Qb3N0Um90YXRpb24sIF9tb2RlbEZCWCkpO1xuICAgICAgICBtdHhQb3N0Um90YXRpb25JbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0lPTihtdHhQb3N0Um90YXRpb25JbnZlcnNlKTtcbiAgICAgICAgbXR4TG9jYWxSb3RhdGlvbi5tdWx0aXBseShtdHhQb3N0Um90YXRpb25JbnZlcnNlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbXR4TG9jYWxTY2FsaW5nOiBNYXRyaXg0eDQgPSBfbW9kZWxGQlguTGNsU2NhbGluZyA/XG4gICAgICAgIE1hdHJpeDR4NC5TQ0FMSU5HKHRoaXMuZ2V0VHJhbnNmb3JtVmVjdG9yKF9tb2RlbEZCWC5MY2xTY2FsaW5nLCBWZWN0b3IzLk9ORSkpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCBtdHhQYXJlbnRXb3JsZFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBwYXJlbnQgPyBNYXRyaXg0eDQuUk9UQVRJT04ocGFyZW50Lm10eFdvcmxkLnJvdGF0aW9uKSA6IHVuZGVmaW5lZDtcblxuICAgICAgY29uc3QgbXR4UGFyZW50V29ybGRTY2FsZTogTWF0cml4NHg0ID0gcGFyZW50ID8gKCgpID0+IHtcbiAgICAgICAgY29uc3QgbXR4UGFyZW50V29ybGRTY2FsZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0lPTihtdHhQYXJlbnRXb3JsZFJvdGF0aW9uKTtcbiAgICAgICAgbXR4UGFyZW50V29ybGRTY2FsZS50cmFuc2xhdGUoVmVjdG9yMy5TQ0FMRShwYXJlbnQubXR4V29ybGQudHJhbnNsYXRpb24sIC0xKSk7XG4gICAgICAgIG10eFBhcmVudFdvcmxkU2NhbGUubXVsdGlwbHkocGFyZW50Lm10eFdvcmxkKTtcbiAgICAgICAgcmV0dXJuIG10eFBhcmVudFdvcmxkU2NhbGU7XG4gICAgICB9KSgpIDogdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCBtdHhXb3JsZFJvdGF0aW9uU2NhbGU6IE1hdHJpeDR4NCA9IHBhcmVudCB8fCBtdHhMb2NhbFJvdGF0aW9uIHx8IG10eExvY2FsU2NhbGluZyA/IE1hdHJpeDR4NC5JREVOVElUWSgpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHBhcmVudCB8fCBtdHhMb2NhbFJvdGF0aW9uIHx8IG10eExvY2FsU2NhbGluZykge1xuICAgICAgICBjb25zdCBpbmhlcml0VHlwZTogbnVtYmVyID0gX21vZGVsRkJYLkluaGVyaXRUeXBlIHx8IDA7XG4gICAgICAgIGlmIChpbmhlcml0VHlwZSA9PSAwKSB7XG4gICAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhQYXJlbnRXb3JsZFJvdGF0aW9uKTtcbiAgICAgICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhMb2NhbFJvdGF0aW9uKTtcbiAgICAgICAgICBpZiAocGFyZW50KVxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eFBhcmVudFdvcmxkU2NhbGUpO1xuICAgICAgICAgIGlmIChtdHhMb2NhbFNjYWxpbmcpXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4TG9jYWxTY2FsaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmhlcml0VHlwZSA9PSAxKSB7XG4gICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eFBhcmVudFdvcmxkUm90YXRpb24pO1xuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eFBhcmVudFdvcmxkU2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhMb2NhbFJvdGF0aW9uKTtcbiAgICAgICAgICBpZiAobXR4TG9jYWxTY2FsaW5nKVxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eExvY2FsU2NhbGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhQYXJlbnRXb3JsZFJvdGF0aW9uKTtcbiAgICAgICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhMb2NhbFJvdGF0aW9uKTtcbiAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50V29ybGRTY2FsZSk7XG4gICAgICAgICAgICBsZXQgbXR4UGFyZW50TG9jYWxTY2FsaW5nSW52ZXJzZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlNDQUxJTkcocGFyZW50Lm10eExvY2FsLnNjYWxpbmcpO1xuICAgICAgICAgICAgbXR4UGFyZW50TG9jYWxTY2FsaW5nSW52ZXJzZSA9IE1hdHJpeDR4NC5JTlZFUlNJT04obXR4UGFyZW50TG9jYWxTY2FsaW5nSW52ZXJzZSk7XG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50TG9jYWxTY2FsaW5nSW52ZXJzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtdHhMb2NhbFNjYWxpbmcpXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4TG9jYWxTY2FsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGxvY2FsIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMztcbiAgICAgIHRyYW5zbGF0aW9uID0gVmVjdG9yMy5aRVJPKCk7XG4gICAgICBpZiAoX21vZGVsRkJYLkxjbFRyYW5zbGF0aW9uKVxuICAgICAgICB0cmFuc2xhdGlvbi5hZGQodGhpcy5nZXRUcmFuc2Zvcm1WZWN0b3IoX21vZGVsRkJYLkxjbFRyYW5zbGF0aW9uLCBWZWN0b3IzLlpFUk8pKTtcbiAgICAgIGlmIChfbW9kZWxGQlguUm90YXRpb25PZmZzZXQpXG4gICAgICAgIHRyYW5zbGF0aW9uLmFkZChfbW9kZWxGQlguUm90YXRpb25PZmZzZXQpO1xuICAgICAgaWYgKF9tb2RlbEZCWC5Sb3RhdGlvblBpdm90KVxuICAgICAgICB0cmFuc2xhdGlvbi5hZGQoX21vZGVsRkJYLlJvdGF0aW9uUGl2b3QpO1xuXG4gICAgICBjb25zdCBtdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5UUkFOU0xBVElPTih0cmFuc2xhdGlvbik7XG4gICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcbiAgICAgICAgbXR4VHJhbnNmb3JtLm11bHRpcGx5KG10eExvY2FsUm90YXRpb24pO1xuXG4gICAgICB0cmFuc2xhdGlvbiA9IFZlY3RvcjMuWkVSTygpO1xuICAgICAgaWYgKF9tb2RlbEZCWC5Sb3RhdGlvblBpdm90KVxuICAgICAgICB0cmFuc2xhdGlvbi5zdWJ0cmFjdChfbW9kZWxGQlguUm90YXRpb25QaXZvdCk7XG4gICAgICBpZiAoX21vZGVsRkJYLlNjYWxpbmdPZmZzZXQpXG4gICAgICAgIHRyYW5zbGF0aW9uLmFkZChfbW9kZWxGQlguU2NhbGluZ09mZnNldCk7XG4gICAgICBpZiAoX21vZGVsRkJYLlNjYWxpbmdQaXZvdClcbiAgICAgICAgdHJhbnNsYXRpb24uYWRkKF9tb2RlbEZCWC5TY2FsaW5nUGl2b3QpO1xuICAgICAgbXR4VHJhbnNmb3JtLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbik7XG5cbiAgICAgIGlmIChtdHhMb2NhbFNjYWxpbmcpXG4gICAgICAgIG10eFRyYW5zZm9ybS5tdWx0aXBseShtdHhMb2NhbFNjYWxpbmcpO1xuICAgICAgaWYgKF9tb2RlbEZCWC5TY2FsaW5nUGl2b3QpXG4gICAgICAgIG10eFRyYW5zZm9ybS50cmFuc2xhdGUoVmVjdG9yMy5TQ0FMRShfbW9kZWxGQlguU2NhbGluZ1Bpdm90LCAtMSkpO1xuXG4gICAgICBjb25zdCBtdHhXb3JsZFRyYW5zbGF0aW9uOiBNYXRyaXg0eDQgPSBwYXJlbnQgP1xuICAgICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04oTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKFxuICAgICAgICAgIHBhcmVudC5tdHhXb3JsZCxcbiAgICAgICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04obXR4VHJhbnNmb3JtLnRyYW5zbGF0aW9uKVxuICAgICAgICApLnRyYW5zbGF0aW9uKSA6XG4gICAgICAgIE1hdHJpeDR4NC5UUkFOU0xBVElPTihtdHhUcmFuc2Zvcm0udHJhbnNsYXRpb24pO1xuXG4gICAgICBtdHhUcmFuc2Zvcm0uc2V0KG10eFdvcmxkVHJhbnNsYXRpb24pO1xuICAgICAgbXR4VHJhbnNmb3JtLm11bHRpcGx5KG10eFdvcmxkUm90YXRpb25TY2FsZSk7XG4gICAgICBfbm9kZS5tdHhXb3JsZC5zZXQobXR4VHJhbnNmb3JtKTtcblxuICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgbXR4VHJhbnNmb3JtLm11bHRpcGx5KE1hdHJpeDR4NC5JTlZFUlNJT04ocGFyZW50Lm10eFdvcmxkKSwgdHJ1ZSk7XG4gICAgICBfbm9kZS5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudFRyYW5zZm9ybShtdHhUcmFuc2Zvcm0pKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRyYW5zZm9ybVZlY3RvcihfdmVjdG9yOiBWZWN0b3IzIHwgRkJYLkFuaW1DdXJ2ZU5vZGUsIF9kZWZhdWx0OiAoKSA9PiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBfdmVjdG9yID09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgX2RlZmF1bHQoKSA6XG4gICAgICAgICAgX3ZlY3RvciBpbnN0YW5jZW9mIFZlY3RvcjMgP1xuICAgICAgICAgICAgX3ZlY3RvciA6XG4gICAgICAgICAgICBuZXcgVmVjdG9yMyhcbiAgICAgICAgICAgICAgdHlwZW9mIChfdmVjdG9yID0gX3ZlY3Rvci5sb2FkKCkpLmRYID09IFwibnVtYmVyXCIgP1xuICAgICAgICAgICAgICAgIF92ZWN0b3IuZFggOlxuICAgICAgICAgICAgICAgIChfdmVjdG9yLmRYLmxvYWQoKSBhcyBGQlguQW5pbUN1cnZlKS5EZWZhdWx0LFxuICAgICAgICAgICAgICB0eXBlb2YgX3ZlY3Rvci5kWSA9PSBcIm51bWJlclwiID9cbiAgICAgICAgICAgICAgICBfdmVjdG9yLmRZIDpcbiAgICAgICAgICAgICAgICAoX3ZlY3Rvci5kWS5sb2FkKCkgYXMgRkJYLkFuaW1DdXJ2ZSkuRGVmYXVsdCxcbiAgICAgICAgICAgICAgdHlwZW9mIF92ZWN0b3IuZFogPT0gXCJudW1iZXJcIiA/XG4gICAgICAgICAgICAgICAgX3ZlY3Rvci5kWiA6XG4gICAgICAgICAgICAgICAgKF92ZWN0b3IuZFoubG9hZCgpIGFzIEZCWC5BbmltQ3VydmUpLkRlZmF1bHRcbiAgICAgICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRBbmltYXRpb25WZWN0b3IzKF9hbmltTm9kZTogRkJYLkFuaW1DdXJ2ZU5vZGUsIF90YXJnZXQ6IEZCWC5Nb2RlbCk6IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMyB7XG4gICAgICBjb25zdCB2ZWN0b3JTZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IzID0ge307XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlTmFtZSBpbiBfYW5pbU5vZGUpIGlmICh2YWx1ZU5hbWUgPT0gXCJkWFwiIHx8IHZhbHVlTmFtZSA9PSBcImRZXCIgfHwgdmFsdWVOYW1lID09IFwiZFpcIikge1xuICAgICAgICBjb25zdCB2YWx1ZTogRkJYLkFuaW1DdXJ2ZSB8IG51bWJlciA9IF9hbmltTm9kZVt2YWx1ZU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjb25zdCBzZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcbiAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdmFsdWUuS2V5VGltZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSByZWZlcmVuY2UgdGltZSBpcyBkZWZpbmVkIGFzIGEgc2lnbmVkIGludDY0LCB1bml0IGJlaW5nIDEvNDYxODYxNTgwMDAgc2Vjb25kc1xuICAgICAgICAgICAgLy8gcmVmOiBodHRwczovL2FyY2hpdmUuYmxlbmRlci5vcmcvd2lraS9pbmRleC5waHAvVXNlcjpNb250MjkvRm91bmRhdGlvbi9GQlhfRmlsZV9TdHJ1Y3R1cmUvI1NvbWVfU3BlY2lmaWNfUHJvcGVydHlfVHlwZXNcbiAgICAgICAgICAgIHNlcXVlbmNlLmFkZEtleShuZXcgQW5pbWF0aW9uS2V5KFxuICAgICAgICAgICAgICBOdW1iZXIoKHZhbHVlLktleVRpbWVbaV0gLSB2YWx1ZS5LZXlUaW1lLnJlZHVjZSgoX21pbiwgX3YpID0+IF92IDwgX21pbiA/IF92IDogX21pbikpIC8gQmlnSW50KFwiNDYxODYxNThcIikpLFxuICAgICAgICAgICAgICB2YWx1ZS5LZXlWYWx1ZUZsb2F0W2ldXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmVjdG9yU2VxdWVuY2VbdmFsdWVOYW1lWzFdLnRvTG93ZXJDYXNlKCldID0gc2VxdWVuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9hbmltTm9kZS5uYW1lID09IFwiUlwiICYmIChfdGFyZ2V0LlByZVJvdGF0aW9uIHx8IF90YXJnZXQuUG9zdFJvdGF0aW9uKSkge1xuICAgICAgICBsZXQgcHJlUm90b3RhdGlvbjogTWF0cml4NHg0O1xuICAgICAgICBpZiAoX3RhcmdldC5QcmVSb3RhdGlvbilcbiAgICAgICAgICBwcmVSb3RvdGF0aW9uID0gTWF0cml4NHg0LlJPVEFUSU9OKF90YXJnZXQuUHJlUm90YXRpb24pO1xuICAgICAgICBsZXQgcG9zdFJvdGF0aW9uOiBNYXRyaXg0eDQ7XG4gICAgICAgIGlmIChfdGFyZ2V0LlBvc3RSb3RhdGlvbilcbiAgICAgICAgICBwb3N0Um90YXRpb24gPSBNYXRyaXg0eDQuUk9UQVRJT04oX3RhcmdldC5Qb3N0Um90YXRpb24pO1xuXG4gICAgICAgIFt2ZWN0b3JTZXF1ZW5jZS54LCB2ZWN0b3JTZXF1ZW5jZS55LCB2ZWN0b3JTZXF1ZW5jZS56XVxuICAgICAgICAgIC5mbGF0TWFwKF9zZXEgPT4gX3NlcT8uZ2V0S2V5cygpKVxuICAgICAgICAgIC5tYXAoX2tleSA9PiBfa2V5Py50aW1lKVxuICAgICAgICAgIC5zb3J0KChfdGltZUEsIF90aW1lQikgPT4gX3RpbWVBIC0gX3RpbWVCKSAvLyBzb3J0IHRpbWVzXG4gICAgICAgICAgLmZpbHRlcigoX3RpbWUsIF9pbmRleCwgX3RpbWVzKSA9PiBfdGltZSAhPSBfdGltZXNbX2luZGV4ICsgMV0pIC8vIHJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgICAgLm1hcChfdGltZSA9PiB7IC8vIGZpbmQga2V5cyBmb3IgYWxsIGF4ZXMgYXQgdGltZVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogZmluZEtleSh2ZWN0b3JTZXF1ZW5jZS54KSwgeTogZmluZEtleSh2ZWN0b3JTZXF1ZW5jZS55KSwgejogZmluZEtleSh2ZWN0b3JTZXF1ZW5jZS56KSB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEtleShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlKTogQW5pbWF0aW9uS2V5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zZXF1ZW5jZT8uZ2V0S2V5cygpLmZpbmQoX2tleSA9PiBfa2V5LnRpbWUgPT0gX3RpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZvckVhY2goX2ZyYW1lID0+IHtcbiAgICAgICAgICAgIGxldCB2Y3RFdWxlckFuZ2xlczogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcbiAgICAgICAgICAgIHZjdEV1bGVyQW5nbGVzLnNldChcbiAgICAgICAgICAgICAgX2ZyYW1lLng/LnZhbHVlID8/IDAsXG4gICAgICAgICAgICAgIF9mcmFtZS55Py52YWx1ZSA/PyAwLFxuICAgICAgICAgICAgICBfZnJhbWUuej8udmFsdWUgPz8gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT04odmN0RXVsZXJBbmdsZXMpO1xuICAgICAgICAgICAgaWYgKHByZVJvdG90YXRpb24pXG4gICAgICAgICAgICAgIG10eFJvdGF0aW9uLm11bHRpcGx5KHByZVJvdG90YXRpb24sIHRydWUpO1xuICAgICAgICAgICAgaWYgKHBvc3RSb3RhdGlvbilcbiAgICAgICAgICAgICAgbXR4Um90YXRpb24ubXVsdGlwbHkocG9zdFJvdGF0aW9uKTtcbiAgICAgICAgICAgIHZjdEV1bGVyQW5nbGVzID0gbXR4Um90YXRpb24ucm90YXRpb247XG4gICAgICAgICAgICBpZiAoX2ZyYW1lLngpXG4gICAgICAgICAgICAgIF9mcmFtZS54LnZhbHVlID0gdmN0RXVsZXJBbmdsZXMueDtcbiAgICAgICAgICAgIGlmIChfZnJhbWUueSlcbiAgICAgICAgICAgICAgX2ZyYW1lLnkudmFsdWUgPSB2Y3RFdWxlckFuZ2xlcy55O1xuICAgICAgICAgICAgaWYgKF9mcmFtZS56KVxuICAgICAgICAgICAgICBfZnJhbWUuei52YWx1ZSA9IHZjdEV1bGVyQW5nbGVzLno7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2ZWN0b3JTZXF1ZW5jZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9yZGVyZWQoX3JvdGF0aW9uOiBWZWN0b3IzLCBfbW9kZWxGQlg6IEZCWC5Nb2RlbCk6IFZlY3RvcjMge1xuICAgICAgaWYgKCFfbW9kZWxGQlguRXVsZXJPcmRlcilcbiAgICAgICAgcmV0dXJuIF9yb3RhdGlvbjtcblxuICAgICAgY29uc3QgZGF0YTogRmxvYXQzMkFycmF5ID0gX3JvdGF0aW9uLmdldCgpO1xuICAgICAgY29uc3QgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgZGF0YVtfbW9kZWxGQlguRXVsZXJPcmRlci5pbmRleE9mKFwiWlwiKV0sXG4gICAgICAgIGRhdGFbX21vZGVsRkJYLkV1bGVyT3JkZXIuaW5kZXhPZihcIllcIildLFxuICAgICAgICBkYXRhW19tb2RlbEZCWC5FdWxlck9yZGVyLmluZGV4T2YoXCJYXCIpXVxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlLkZCWCB7XG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgdG8gcmVwcmVzZW50IGZieC1ub2RlcyBjb250YWluaW5nIGl0cyBuYW1lLCBjaGlsZHJlbiBhbmQgcHJvcGVydGllcy5cbiAgICogQ2hpbGRyZW4gYW5kIHByb3Blcml0ZXMgYXJlIGxhenkuXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xuICAgIFxuICAgIHByaXZhdGUgbG9hZFByb3BlcnRpZXM6ICgpID0+IE5vZGVQcm9wZXJ0eVtdO1xuICAgIHByaXZhdGUgbG9hZENoaWxkcmVuOiAoKSA9PiBOb2RlW107XG4gICAgXG4gICAgI2NoaWxkcmVuOiBOb2RlW107XG4gICAgI3Byb3BlcnRpZXM6IE5vZGVQcm9wZXJ0eVtdO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9sb2FkUHJvcGVydGllczogKCkgPT4gTm9kZVByb3BlcnR5W10sIF9sb2FkQ2hpbGRyZW46ICgpID0+IE5vZGVbXSkge1xuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XG4gICAgICB0aGlzLmxvYWRQcm9wZXJ0aWVzID0gX2xvYWRQcm9wZXJ0aWVzO1xuICAgICAgdGhpcy5sb2FkQ2hpbGRyZW4gPSBfbG9hZENoaWxkcmVuO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgcHJvcGVydGllcygpOiBOb2RlUHJvcGVydHlbXSB7XG4gICAgICByZXR1cm4gdGhpcy4jcHJvcGVydGllcyB8fCAodGhpcy4jcHJvcGVydGllcyA9IHRoaXMubG9hZFByb3BlcnRpZXMoKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBjaGlsZHJlbigpOiBOb2RlW10ge1xuICAgICAgcmV0dXJuIHRoaXMuI2NoaWxkcmVuIHx8ICh0aGlzLiNjaGlsZHJlbiA9IHRoaXMubG9hZENoaWxkcmVuKCkpO1xuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFByb3BlcnR5NzAgPSBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgVmVjdG9yMztcblxuICBleHBvcnQgdHlwZSBOb2RlUHJvcGVydHkgPSBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgRmxvYXQzMkFycmF5O1xuXG4gIGV4cG9ydCBlbnVtIEFSUkFZX0VOQ09ESU5HIHtcbiAgICBVTkNPTVBSRVNTRUQsIENPTVBSRVNTRURcbiAgfVxuICBcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlLkZCWCB7XG4gIC8qKlxuICAgKiBMb2FkcyBhbiBmYnggZmlsZSBmcm9tIGl0cyBmYngtbm9kZSBhcnJheSB3aGljaCBtYXkgYmUgcmV0cmlldmVkIGJ5IHBhcnNlTm9kZXNGcm9tQmluYXJ5LlxuICAgKiBAYXV0aG9yIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gbG9hZEZyb21Ob2Rlcyhfbm9kZXM6IE5vZGVbXSk6IEZCWCB7XG4gICAgY29uc3QgZmJ4OiBGQlggPSB7XG4gICAgICBkb2N1bWVudHM6IHVuZGVmaW5lZCxcbiAgICAgIG9iamVjdHM6IHtcbiAgICAgICAgYWxsOiB1bmRlZmluZWQsXG4gICAgICAgIG1vZGVsczogW10sXG4gICAgICAgIGdlb21ldHJpZXM6IFtdLFxuICAgICAgICBtYXRlcmlhbHM6IFtdLFxuICAgICAgICBwb3NlczogW10sXG4gICAgICAgIHRleHR1cmVzOiBbXSxcbiAgICAgICAgYW5pbVN0YWNrczogW11cbiAgICAgIH0sXG4gICAgICBjb25uZWN0aW9uczogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBfbm9kZXMpIHtcbiAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJEb2N1bWVudHNcIilcbiAgICAgICAgZmJ4LmRvY3VtZW50cyA9IG5vZGUuY2hpbGRyZW5cbiAgICAgICAgICAuZmlsdGVyKF9kb2N1bWVudE5vZGUgPT4gX2RvY3VtZW50Tm9kZS5uYW1lID09IFwiRG9jdW1lbnRcIilcbiAgICAgICAgICAubWFwKF9kb2N1bWVudE5vZGUgPT4gZ2V0RG9jdW1lbnQoX2RvY3VtZW50Tm9kZSkpO1xuICAgICAgZWxzZSBpZiAobm9kZS5uYW1lID09IFwiT2JqZWN0c1wiKVxuICAgICAgICBmYngub2JqZWN0cy5hbGwgPSBub2RlLmNoaWxkcmVuLm1hcChfb2JqZWN0Tm9kZSA9PiBnZXRPYmplY3QoX29iamVjdE5vZGUsIGZieCkpO1xuICAgICAgZWxzZSBpZiAobm9kZS5uYW1lID09IFwiQ29ubmVjdGlvbnNcIilcbiAgICAgICAgZmJ4LmNvbm5lY3Rpb25zID0gbm9kZS5jaGlsZHJlbi5tYXAoX2Nvbm5lY3Rpb25Ob2RlID0+IGdldENvbm5lY3Rpb24oX2Nvbm5lY3Rpb25Ob2RlKSk7XG4gICAgICBpZiAoZmJ4LmRvY3VtZW50cyAmJiBmYngub2JqZWN0cy5hbGwgJiYgZmJ4LmNvbm5lY3Rpb25zKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBncm91cE9iamVjdHMoZmJ4KTtcbiAgICBhcHBseUNvbm5lY3Rpb25zKGZieC5jb25uZWN0aW9ucywgZmJ4LmRvY3VtZW50cywgZmJ4Lm9iamVjdHMuYWxsKTtcblxuICAgIHJldHVybiBmYng7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREb2N1bWVudChfbm9kZTogTm9kZSk6IERvY3VtZW50IHtcbiAgICBjb25zdCBkb2N1bWVudDogT2JqZWN0ID0ge1xuICAgICAgdWlkOiBfbm9kZS5wcm9wZXJ0aWVzWzBdIGFzIG51bWJlcixcbiAgICAgIG5hbWU6IF9ub2RlLnByb3BlcnRpZXNbMl0gYXMgc3RyaW5nLFxuICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgIGxvYWQ6ICgpID0+IGxvYWRPYmplY3RQcm9wZXJ0aWVzKF9ub2RlLCBkb2N1bWVudClcbiAgICB9O1xuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9iamVjdChfbm9kZTogTm9kZSwgX2ZieDogRkJYKTogT2JqZWN0IHtcbiAgICBjb25zdCBuYW1lQW5kVHlwZTogc3RyaW5nW10gPSAoX25vZGUucHJvcGVydGllc1sxXSBhcyBzdHJpbmcpLnNwbGl0KFwiOjpcIik7XG4gICAgY29uc3Qgb2JqZWN0OiBPYmplY3QgPSB7XG4gICAgICB1aWQ6IF9ub2RlLnByb3BlcnRpZXNbMF0gYXMgbnVtYmVyLFxuICAgICAgbmFtZTogbmFtZUFuZFR5cGVbMF0sXG4gICAgICB0eXBlOiBuYW1lQW5kVHlwZVsxXSxcbiAgICAgIHN1YnR5cGU6IF9ub2RlLnByb3BlcnRpZXNbMl0gYXMgc3RyaW5nLFxuICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgIGxvYWQ6ICgpID0+IGxvYWRPYmplY3RQcm9wZXJ0aWVzKF9ub2RlLCBvYmplY3QpXG4gICAgfTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ3JvdXBPYmplY3RzKF9mYng6IEZCWCk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIF9mYngub2JqZWN0cy5hbGwpIHtcbiAgICAgIGlmIChvYmplY3QudHlwZSA9PSBcIk1vZGVsXCIpXG4gICAgICAgIF9mYngub2JqZWN0cy5tb2RlbHMucHVzaChvYmplY3QpO1xuICAgICAgZWxzZSBpZiAob2JqZWN0LnR5cGUgPT0gXCJHZW9tZXRyeVwiKVxuICAgICAgICBfZmJ4Lm9iamVjdHMuZ2VvbWV0cmllcy5wdXNoKG9iamVjdCk7XG4gICAgICBlbHNlIGlmIChvYmplY3QudHlwZSA9PSBcIk1hdGVyaWFsXCIpXG4gICAgICAgIF9mYngub2JqZWN0cy5tYXRlcmlhbHMucHVzaChvYmplY3QpO1xuICAgICAgZWxzZSBpZiAob2JqZWN0LnR5cGUgPT0gXCJQb3NlXCIpXG4gICAgICAgIF9mYngub2JqZWN0cy5wb3Nlcy5wdXNoKG9iamVjdCk7XG4gICAgICBlbHNlIGlmIChvYmplY3QudHlwZSA9PSBcIlRleHR1cmVcIilcbiAgICAgICAgX2ZieC5vYmplY3RzLnRleHR1cmVzLnB1c2gob2JqZWN0KTtcbiAgICAgIGVsc2UgaWYgKG9iamVjdC50eXBlID09IFwiQW5pbVN0YWNrXCIpXG4gICAgICAgIF9mYngub2JqZWN0cy5hbmltU3RhY2tzLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb25uZWN0aW9uKF9ub2RlOiBOb2RlKTogQ29ubmVjdGlvbiB7XG4gICAgaWYgKCEoX25vZGUucHJvcGVydGllc1swXSA9PSBcIk9PXCIgfHwgX25vZGUucHJvcGVydGllc1swXSA9PSBcIk9QXCIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvbm5lY3Rpb24gdHlwZSAke19ub2RlLnByb3BlcnRpZXNbMF19IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRVSUQ6IF9ub2RlLnByb3BlcnRpZXNbMV0gYXMgbnVtYmVyLFxuICAgICAgcGFyZW50VUlEOiBfbm9kZS5wcm9wZXJ0aWVzWzJdIGFzIG51bWJlcixcbiAgICAgIHByb3BlcnR5TmFtZTogX25vZGUucHJvcGVydGllc1swXSA9PSBcIk9QXCIgPyBfbm9kZS5wcm9wZXJ0aWVzWzNdIGFzIHN0cmluZyA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlDb25uZWN0aW9ucyhfY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXSwgX2RvY3VtZW50czogRG9jdW1lbnRbXSwgX29iamVjdHM6IE9iamVjdFtdKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIF9jb25uZWN0aW9ucykge1xuICAgICAgbGV0IHBhcmVudDogT2JqZWN0ID0gX2RvY3VtZW50cy5maW5kKF9kb2N1bWVudCA9PiBfZG9jdW1lbnQubG9hZCgpLlJvb3ROb2RlID09IGNvbm5lY3Rpb24ucGFyZW50VUlEKSBhcyBPYmplY3Q7XG4gICAgICBsZXQgY2hpbGQ6IE9iamVjdDtcbiAgICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIF9vYmplY3RzKSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gdW5kZWZpbmVkICYmIG9iamVjdC51aWQgPT0gY29ubmVjdGlvbi5wYXJlbnRVSUQpXG4gICAgICAgICAgcGFyZW50ID0gb2JqZWN0O1xuICAgICAgICBpZiAoY2hpbGQgPT0gdW5kZWZpbmVkICYmIG9iamVjdC51aWQgPT0gY29ubmVjdGlvbi5jaGlsZFVJRClcbiAgICAgICAgICBjaGlsZCA9IG9iamVjdDtcbiAgICAgICAgaWYgKHBhcmVudCAhPSB1bmRlZmluZWQgJiYgY2hpbGQgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAoY2hpbGQucGFyZW50cyB8fCAoY2hpbGQucGFyZW50cyA9IFtdKSkucHVzaChwYXJlbnQpO1xuICAgICAgaWYgKGNvbm5lY3Rpb24ucHJvcGVydHlOYW1lID09IG51bGwpXG4gICAgICAgIChwYXJlbnQuY2hpbGRyZW4gfHwgKHBhcmVudC5jaGlsZHJlbiA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgICBlbHNlXG4gICAgICAgIChwYXJlbnQgYXMgT2JqZWN0KVtmb3JtYXRQcm9wZXJ0eU5hbWUoY29ubmVjdGlvbi5wcm9wZXJ0eU5hbWUpXSA9IGNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRPYmplY3RQcm9wZXJ0aWVzKF9ub2RlOiBOb2RlLCBfb2JqZWN0OiBPYmplY3QpOiBPYmplY3Qge1xuICAgIGlmIChfb2JqZWN0LmxvYWRlZClcbiAgICAgIHJldHVybiBfb2JqZWN0O1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgX25vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZC5uYW1lID09IFwiUHJvcGVydGllczcwXCIpXG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHk3MCBvZiBjaGlsZC5jaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IG5hbWU6IHN0cmluZyA9IGZvcm1hdFByb3BlcnR5TmFtZShwcm9wZXJ0eTcwLnByb3BlcnRpZXNbMF0gYXMgc3RyaW5nKTtcbiAgICAgICAgICBpZiAoIV9vYmplY3RbbmFtZV0pXG4gICAgICAgICAgICBfb2JqZWN0W25hbWVdID0gZ2V0UHJvcGVydHk3MFZhbHVlKHByb3BlcnR5NzApO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZTogc3RyaW5nID0gZm9ybWF0UHJvcGVydHlOYW1lKGNoaWxkLm5hbWUpO1xuICAgICAgICBpZiAoIV9vYmplY3RbbmFtZV0pXG4gICAgICAgICAgX29iamVjdFtuYW1lXSA9IGdldFByb3BlcnR5VmFsdWUoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBfb2JqZWN0LmxvYWRlZCA9IHRydWU7XG4gICAgcmV0dXJuIF9vYmplY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlKF9ub2RlOiBOb2RlKTogTm9kZVByb3BlcnR5IHwgT2JqZWN0IHtcbiAgICByZXR1cm4gX25vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMFxuICAgICAgPyBfbm9kZS5jaGlsZHJlbi5yZWR1Y2UoXG4gICAgICAgIChfc3ViUHJvcGVydGllcywgX3N1YlByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgY29uc3QgbmFtZTogc3RyaW5nID0gZm9ybWF0UHJvcGVydHlOYW1lKF9zdWJQcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICBpZiAoX3N1YlByb3BlcnRpZXNbbmFtZV0gPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgX3N1YlByb3BlcnRpZXNbbmFtZV0gPSBnZXRQcm9wZXJ0eVZhbHVlKF9zdWJQcm9wZXJ0eSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShfc3ViUHJvcGVydGllc1tuYW1lXSBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgICAgX3N1YlByb3BlcnRpZXNbbmFtZV0gPSBbX3N1YlByb3BlcnRpZXNbbmFtZV0gYXMgT2JqZWN0XTtcbiAgICAgICAgICAgIChfc3ViUHJvcGVydGllc1tuYW1lXSBhcyBPYmplY3RbXSkucHVzaChnZXRQcm9wZXJ0eVZhbHVlKF9zdWJQcm9wZXJ0eSkgYXMgT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9zdWJQcm9wZXJ0aWVzO1xuICAgICAgICB9LFxuICAgICAgICB7fSBhcyBPYmplY3RcbiAgICAgIClcbiAgICAgIDogX25vZGUucHJvcGVydGllc1swXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByb3BlcnR5NzBWYWx1ZShfbm9kZTogTm9kZSk6IFByb3BlcnR5NzAge1xuICAgIHN3aXRjaCAoX25vZGUucHJvcGVydGllc1sxXSBhcyBzdHJpbmcpIHtcbiAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgIHJldHVybiBfbm9kZS5wcm9wZXJ0aWVzWzRdIGFzIGJvb2xlYW47XG5cbiAgICAgIGNhc2UgXCJpbnRcIjpcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICBjYXNlIFwiVUxvbmdMb25nXCI6XG4gICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICBjYXNlIFwiTnVtYmVyXCI6XG4gICAgICBjYXNlIFwiRmllbGRPZlZpZXdcIjpcbiAgICAgICAgcmV0dXJuIF9ub2RlLnByb3BlcnRpZXNbNF0gYXMgbnVtYmVyO1xuXG4gICAgICBjYXNlIFwiQ29sb3JcIjpcbiAgICAgIGNhc2UgXCJDb2xvclJHQlwiOlxuICAgICAgY2FzZSBcIlZlY3RvcjNEXCI6XG4gICAgICBjYXNlIFwiTGNsIFRyYW5zbGF0aW9uXCI6XG4gICAgICBjYXNlIFwiTGNsIFJvdGF0aW9uXCI6XG4gICAgICBjYXNlIFwiTGNsIFNjYWxpbmdcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKC4uLl9ub2RlLnByb3BlcnRpZXMuc2xpY2UoNCwgNykgYXMgbnVtYmVyW10pO1xuXG4gICAgICBjYXNlIFwiS1N0cmluZ1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9ub2RlLnByb3BlcnRpZXNbNF0gYXMgc3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5TmFtZShfbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gX25hbWUucmVwbGFjZSgvW15hLXpBLVpdLywgXCJcIik7XG4gIH1cblxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUuRkJYIHtcbiAgLyoqXG4gICAqIFBhcnNlcyBmYngtbm9kZXMgYXJyYXkgZnJvbSBhIGJpbmFyeSBmYngtZmlsZS5cbiAgICogZGVzcGl0ZSB0aGUgbGF6eSBub2RlIGltcGxlbWVudGF0aW9uIGl0IGlzIG1vc3RseSBhIGNvcHkgb2YgdGhlIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3BpY29kZTcvZmJ4LXBhcnNlclxuICAgKiBAYXV0aG9yIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gcGFyc2VOb2Rlc0Zyb21CaW5hcnkoX2J1ZmZlcjogQXJyYXlCdWZmZXIpOiBOb2RlW10ge1xuICAgIGlmIChfYnVmZmVyLmJ5dGVMZW5ndGggPCBiaW5hcnlTdGFydENoYXJzLmxlbmd0aClcbiAgICAgIHRocm93IFwiTm90IGEgYmluYXJ5IEZCWCBmaWxlXCI7XG5cbiAgICBjb25zdCBkYXRhOiBCdWZmZXJSZWFkZXIgPSBuZXcgQnVmZmVyUmVhZGVyKF9idWZmZXIpO1xuICAgIGNvbnN0IGZpcnN0Q2hhcnM6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhLmdldFNlcXVlbmNlKGRhdGEuZ2V0VWludDgsIGJpbmFyeVN0YXJ0Q2hhcnMubGVuZ3RoKSk7XG4gICAgY29uc3QgbWF0Y2hlc0ZCWEJpbmFyeUZpcnN0Q2hhcnM6IGJvb2xlYW5cbiAgICAgID0gZmlyc3RDaGFycy5ldmVyeSgoX3ZhbHVlLCBfaW5kZXgpID0+IF92YWx1ZSA9PSBiaW5hcnlTdGFydENoYXJzW19pbmRleF0pO1xuICAgIGlmICghbWF0Y2hlc0ZCWEJpbmFyeUZpcnN0Q2hhcnMpXG4gICAgICB0aHJvdyBcIk5vdCBhIGJpbmFyeSBGQlggZmlsZVwiO1xuXG4gICAgY29uc3QgdmVyc2lvbjogbnVtYmVyID0gZGF0YS5nZXRVaW50MzIoKTtcbiAgICBjb25zdCBub2RlQXR0cmlidXRlc0FzVUludDY0OiBib29sZWFuID0gdmVyc2lvbiA+PSA3NTAwOyAvLyBXYXJ1bSA+PSA3NTAwP1xuICAgIGNvbnN0IG5vZGVzOiBOb2RlW10gPSBbXTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBub2RlOiBOb2RlID0gcmVhZE5vZGUoZGF0YSwgbm9kZUF0dHJpYnV0ZXNBc1VJbnQ2NCk7XG4gICAgICBpZiAobm9kZSA9PSBudWxsKSBicmVhaztcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZE5vZGUoX2RhdGE6IEJ1ZmZlclJlYWRlciwgX2F0dHJpYnV0ZXNBc1VpbnQ2NDogYm9vbGVhbik6IE5vZGUge1xuICAgIGNvbnN0IGVuZE9mZnNldDogbnVtYmVyID0gX2F0dHJpYnV0ZXNBc1VpbnQ2NCA/IE51bWJlcihfZGF0YS5nZXRVaW50NjQoKSkgOiBfZGF0YS5nZXRVaW50MzIoKTtcbiAgICBpZiAoZW5kT2Zmc2V0ID09IDApXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHByb3BlcnRpZXNMZW5ndGg6IG51bWJlciA9IF9hdHRyaWJ1dGVzQXNVaW50NjQgPyBOdW1iZXIoX2RhdGEuZ2V0VWludDY0KCkpIDogX2RhdGEuZ2V0VWludDMyKCk7XG4gICAgY29uc3QgcHJvcGVydGllc0J5dGVMZW5ndGg6IG51bWJlciA9IF9hdHRyaWJ1dGVzQXNVaW50NjQgPyBOdW1iZXIoX2RhdGEuZ2V0VWludDY0KCkpIDogX2RhdGEuZ2V0VWludDMyKCk7XG4gICAgY29uc3QgbmFtZUxlbmd0aDogbnVtYmVyID0gX2RhdGEuZ2V0VWludDgoKTtcbiAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSBfZGF0YS5nZXRTdHJpbmcobmFtZUxlbmd0aCk7XG4gICAgY29uc3QgcHJvcGVydGllc09mZnNldDogbnVtYmVyID0gX2RhdGEub2Zmc2V0O1xuICAgIGNvbnN0IGNoaWxkcmVuT2Zmc2V0OiBudW1iZXIgPSBwcm9wZXJ0aWVzT2Zmc2V0ICsgcHJvcGVydGllc0J5dGVMZW5ndGg7XG5cbiAgICBjb25zdCBub2RlOiBOb2RlID0gbmV3IE5vZGUoXG4gICAgICBuYW1lLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBfZGF0YS5vZmZzZXQgPSBwcm9wZXJ0aWVzT2Zmc2V0O1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzOiBOb2RlUHJvcGVydHlbXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpUHJvcGVydHk6IG51bWJlciA9IDA7IGlQcm9wZXJ0eSA8IHByb3BlcnRpZXNMZW5ndGg7IGlQcm9wZXJ0eSsrKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHJlYWRQcm9wZXJ0eShfZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgX2RhdGEub2Zmc2V0ID0gY2hpbGRyZW5PZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuOiBOb2RlW10gPSBbXTtcbiAgICAgICAgd2hpbGUgKGVuZE9mZnNldCAtIF9kYXRhLm9mZnNldCA+IG51bGxDb3VudEF0Tm9kZUVuZCkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkOiBGQlguTm9kZSA9IHJlYWROb2RlKF9kYXRhLCBfYXR0cmlidXRlc0FzVWludDY0KTtcbiAgICAgICAgICBpZiAoY2hpbGQpIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgX2RhdGEub2Zmc2V0ID0gZW5kT2Zmc2V0O1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUHJvcGVydHkoX2RhdGE6IEJ1ZmZlclJlYWRlcik6IEZCWC5Ob2RlUHJvcGVydHkge1xuICAgIGNvbnN0IHR5cGVDb2RlOiBzdHJpbmcgPSBfZGF0YS5nZXRDaGFyKCk7XG5cbiAgICBjb25zdCB2YWx1ZTogRkJYLk5vZGVQcm9wZXJ0eSA9IHtcbiAgICAgIEM6IF9kYXRhLmdldEJvb2wsXG4gICAgICBZOiBfZGF0YS5nZXRJbnQxNixcbiAgICAgIEk6IF9kYXRhLmdldEludDMyLFxuICAgICAgTDogX2RhdGEuZ2V0SW50NjQsXG4gICAgICBGOiBfZGF0YS5nZXRGbG9hdDMyLFxuICAgICAgRDogX2RhdGEuZ2V0RmxvYXQ2NCxcbiAgICAgIFM6ICgpID0+IF9kYXRhLmdldFN0cmluZyhfZGF0YS5nZXRVaW50MzIoKSkucmVwbGFjZShcIlxceDAwXFx4MDFcIiwgXCI6OlwiKSxcbiAgICAgIHM6ICgpID0+IF9kYXRhLmdldFN0cmluZyhfZGF0YS5nZXRVaW50MzIoKSkucmVwbGFjZShcIlxceDAwXFx4MDFcIiwgXCI6OlwiKSxcbiAgICAgIFI6ICgpID0+IG5ldyBVaW50OEFycmF5KHJlYWRSYXcoX2RhdGEsIF9kYXRhLmdldFVpbnQ4KSksXG4gICAgICByOiAoKSA9PiBuZXcgVWludDhBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldFVpbnQ4KSksXG4gICAgICBiOiAoKSA9PiBuZXcgVWludDhBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldFVpbnQ4KSksXG4gICAgICBpOiAoKSA9PiBuZXcgSW50MzJBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldEludDMyKSksXG4gICAgICBsOiAoKSA9PiBuZXcgQmlnSW50NjRBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldEludDY0KSksXG4gICAgICBmOiAoKSA9PiBuZXcgRmxvYXQzMkFycmF5KHJlYWRBcnJheShfZGF0YSwgX2RhdGEuZ2V0RmxvYXQzMikpLFxuICAgICAgZDogKCkgPT4gbmV3IEZsb2F0MzJBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldEZsb2F0NjQpKVxuICAgIH1bdHlwZUNvZGVdPy5jYWxsKF9kYXRhKTtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgRGVidWcud2FybihgVW5rbm93biBwcm9wZXJ0eSB0eXBlICR7dHlwZUNvZGUuY2hhckNvZGVBdCgwKX1gKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheTxUIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihfZGF0YTogQnVmZmVyUmVhZGVyLCBfZ2V0dGVyOiAoKSA9PiBUKTogR2VuZXJhdG9yPFQ+IHtcbiAgICBjb25zdCBsZW5ndGg6IG51bWJlciA9IF9kYXRhLmdldFVpbnQzMigpO1xuICAgIGNvbnN0IGVuY29kaW5nOiBGQlguQVJSQVlfRU5DT0RJTkcgPSBfZGF0YS5nZXRVaW50MzIoKTtcbiAgICBjb25zdCBieXRlTGVuZ3RoOiBudW1iZXIgPSBfZGF0YS5nZXRVaW50MzIoKTtcbiAgICBjb25zdCBlbmRPZmZzZXQ6IG51bWJlciA9IF9kYXRhLm9mZnNldCArIGJ5dGVMZW5ndGg7XG5cbiAgICBjb25zdCBpdGVyYWJsZTogR2VuZXJhdG9yPFQ+ID0gZW5jb2RpbmcgPT0gRkJYLkFSUkFZX0VOQ09ESU5HLkNPTVBSRVNTRUQgP1xuICAgICAgKCgpID0+IHtcbiAgICAgICAgY29uc3QgYXJyYXlEYXRhOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoX2RhdGEudmlldy5idWZmZXIsIF9kYXRhLm9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGluZmxhdGVkRGF0YTogVWludDhBcnJheSA9IChSZWZsZWN0LmdldChnbG9iYWxUaGlzLCBcInBha29cIikgPyBwYWtvLmluZmxhdGUgOiBmZmxhdGUuaW5mbGF0ZVN5bmMpKGFycmF5RGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyUmVhZGVyKGluZmxhdGVkRGF0YS5idWZmZXIpLmdldFNlcXVlbmNlKF9nZXR0ZXIsIGxlbmd0aCk7XG4gICAgICB9KSgpIDpcbiAgICAgIF9kYXRhLmdldFNlcXVlbmNlKF9nZXR0ZXIsIGxlbmd0aCk7XG5cbiAgICBfZGF0YS5vZmZzZXQgPSBlbmRPZmZzZXQ7XG5cbiAgICByZXR1cm4gaXRlcmFibGU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUmF3PFQgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KF9kYXRhOiBCdWZmZXJSZWFkZXIsIF9nZXR0ZXI6ICgpID0+IFQpOiBHZW5lcmF0b3I8VD4ge1xuICAgIC8vIHJhdyBiaW5hcnkgZGF0YSBuZWVkcyB0byBiZSBpbnRlcnByZXRlZCBpbiBhIHNwZWNpYWwgd2F5IHNlZTpcbiAgICAvLyBodHRwczovL2NvZGUuYmxlbmRlci5vcmcvMjAxMy8wOC9mYngtYmluYXJ5LWZpbGUtZm9ybWF0LXNwZWNpZmljYXRpb24vXG4gICAgY29uc3QgbGVuZ3RoOiBudW1iZXIgPSBfZGF0YS5nZXRVaW50MzIoKTtcbiAgICByZXR1cm4gX2RhdGEuZ2V0U2VxdWVuY2UoX2dldHRlciwgbGVuZ3RoKTs7XG4gIH1cblxuICBjb25zdCBiaW5hcnlTdGFydENoYXJzOiBVaW50OEFycmF5XG4gICAgPSBVaW50OEFycmF5LmZyb20oXCJLYXlkYXJhIEZCWCBCaW5hcnlcXHgyMFxceDIwXFx4MDBcXHgxYVxceDAwXCIuc3BsaXQoXCJcIiksIF92ID0+IF92LmNoYXJDb2RlQXQoMCkpO1xuXG4gIGNvbnN0IG51bGxDb3VudEF0Tm9kZUVuZDogbnVtYmVyID0gMTM7XG5cbn0iLCJuYW1lc3BhY2UgR0xURiB7XG4gIGV4cG9ydCB0eXBlIEdsVGZJZCA9IG51bWJlcjtcbiAgLyoqXG4gICAqIEFuIG9iamVjdCBwb2ludGluZyB0byBhIGJ1ZmZlciB2aWV3IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgZGV2aWF0aW5nIGFjY2Vzc29yIHZhbHVlcy4gVGhlIG51bWJlciBvZiBpbmRpY2VzIGlzIGVxdWFsIHRvIGBhY2Nlc3Nvci5zcGFyc2UuY291bnRgLiBJbmRpY2VzICoqTVVTVCoqIHN0cmljdGx5IGluY3JlYXNlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBBY2Nlc3NvclNwYXJzZUluZGljZXMge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIHZpZXcgd2l0aCBzcGFyc2UgaW5kaWNlcy4gVGhlIHJlZmVyZW5jZWQgYnVmZmVyIHZpZXcgKipNVVNUIE5PVCoqIGhhdmUgaXRzIGB0YXJnZXRgIG9yIGBieXRlU3RyaWRlYCBwcm9wZXJ0aWVzIGRlZmluZWQuIFRoZSBidWZmZXIgdmlldyBhbmQgdGhlIG9wdGlvbmFsIGBieXRlT2Zmc2V0YCAqKk1VU1QqKiBiZSBhbGlnbmVkIHRvIHRoZSBgY29tcG9uZW50VHlwZWAgYnl0ZSBsZW5ndGguXG4gICAgICovXG4gICAgXCJidWZmZXJWaWV3XCI6IEdsVGZJZDtcbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIHZpZXcgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgXCJieXRlT2Zmc2V0XCI/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGljZXMgZGF0YSB0eXBlLlxuICAgICAqL1xuICAgIFwiY29tcG9uZW50VHlwZVwiOiBDT01QT05FTlRfVFlQRS5VTlNJR05FRF9CWVRFIHwgQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlQgfCBDT01QT05FTlRfVFlQRS5VTlNJR05FRF9JTlQ7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBBbiBvYmplY3QgcG9pbnRpbmcgdG8gYSBidWZmZXIgdmlldyBjb250YWluaW5nIHRoZSBkZXZpYXRpbmcgYWNjZXNzb3IgdmFsdWVzLiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIGVxdWFsIHRvIGBhY2Nlc3Nvci5zcGFyc2UuY291bnRgIHRpbWVzIG51bWJlciBvZiBjb21wb25lbnRzLiBUaGUgZWxlbWVudHMgaGF2ZSB0aGUgc2FtZSBjb21wb25lbnQgdHlwZSBhcyB0aGUgYmFzZSBhY2Nlc3Nvci4gVGhlIGVsZW1lbnRzIGFyZSB0aWdodGx5IHBhY2tlZC4gRGF0YSAqKk1VU1QqKiBiZSBhbGlnbmVkIGZvbGxvd2luZyB0aGUgc2FtZSBydWxlcyBhcyB0aGUgYmFzZSBhY2Nlc3Nvci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzb3JTcGFyc2VWYWx1ZXMge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYnVmZmVyVmlldyB3aXRoIHNwYXJzZSB2YWx1ZXMuIFRoZSByZWZlcmVuY2VkIGJ1ZmZlciB2aWV3ICoqTVVTVCBOT1QqKiBoYXZlIGl0cyBgdGFyZ2V0YCBvciBgYnl0ZVN0cmlkZWAgcHJvcGVydGllcyBkZWZpbmVkLlxuICAgICAqL1xuICAgIFwiYnVmZmVyVmlld1wiOiBHbFRmSWQ7XG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlclZpZXcgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgXCJieXRlT2Zmc2V0XCI/OiBudW1iZXI7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBTcGFyc2Ugc3RvcmFnZSBvZiBhY2Nlc3NvciB2YWx1ZXMgdGhhdCBkZXZpYXRlIGZyb20gdGhlaXIgaW5pdGlhbGl6YXRpb24gdmFsdWUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yU3BhcnNlIHtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZGV2aWF0aW5nIGFjY2Vzc29yIHZhbHVlcyBzdG9yZWQgaW4gdGhlIHNwYXJzZSBhcnJheS5cbiAgICAgKi9cbiAgICBcImNvdW50XCI6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcG9pbnRpbmcgdG8gYSBidWZmZXIgdmlldyBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuIFRoZSBudW1iZXIgb2YgaW5kaWNlcyBpcyBlcXVhbCB0byBgY291bnRgLiBJbmRpY2VzICoqTVVTVCoqIHN0cmljdGx5IGluY3JlYXNlLlxuICAgICAqL1xuICAgIFwiaW5kaWNlc1wiOiBBY2Nlc3NvclNwYXJzZUluZGljZXM7XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHBvaW50aW5nIHRvIGEgYnVmZmVyIHZpZXcgY29udGFpbmluZyB0aGUgZGV2aWF0aW5nIGFjY2Vzc29yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBcInZhbHVlc1wiOiBBY2Nlc3NvclNwYXJzZVZhbHVlcztcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcbiAgICBcImV4dHJhc1wiPzogYW55O1xuICAgIFtrOiBzdHJpbmddOiBhbnk7XG4gIH1cbiAgLyoqXG4gICAqIEEgdHlwZWQgdmlldyBpbnRvIGEgYnVmZmVyIHZpZXcgdGhhdCBjb250YWlucyByYXcgYmluYXJ5IGRhdGEuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGJ1ZmZlclZpZXcuXG4gICAgICovXG4gICAgXCJidWZmZXJWaWV3XCI/OiBHbFRmSWQ7XG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlciB2aWV3IGluIGJ5dGVzLlxuICAgICAqL1xuICAgIFwiYnl0ZU9mZnNldFwiPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhdHlwZSBvZiB0aGUgYWNjZXNzb3IncyBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIFwiY29tcG9uZW50VHlwZVwiOiBDT01QT05FTlRfVFlQRTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBpbnRlZ2VyIGRhdGEgdmFsdWVzIGFyZSBub3JtYWxpemVkIGJlZm9yZSB1c2FnZS5cbiAgICAgKi9cbiAgICBcIm5vcm1hbGl6ZWRcIj86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBlbGVtZW50cyByZWZlcmVuY2VkIGJ5IHRoaXMgYWNjZXNzb3IuXG4gICAgICovXG4gICAgXCJjb3VudFwiOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIGlmIHRoZSBhY2Nlc3NvcidzIGVsZW1lbnRzIGFyZSBzY2FsYXJzLCB2ZWN0b3JzLCBvciBtYXRyaWNlcy5cbiAgICAgKi9cbiAgICBcInR5cGVcIjogQUNDRVNTT1JfVFlQRTtcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHZhbHVlIG9mIGVhY2ggY29tcG9uZW50IGluIHRoaXMgYWNjZXNzb3IuXG4gICAgICovXG4gICAgXCJtYXhcIj86IG51bWJlcltdO1xuICAgIC8qKlxuICAgICAqIE1pbmltdW0gdmFsdWUgb2YgZWFjaCBjb21wb25lbnQgaW4gdGhpcyBhY2Nlc3Nvci5cbiAgICAgKi9cbiAgICBcIm1pblwiPzogbnVtYmVyW107XG4gICAgLyoqXG4gICAgICogU3BhcnNlIHN0b3JhZ2Ugb2YgZWxlbWVudHMgdGhhdCBkZXZpYXRlIGZyb20gdGhlaXIgaW5pdGlhbGl6YXRpb24gdmFsdWUuXG4gICAgICovXG4gICAgXCJzcGFyc2VcIj86IEFjY2Vzc29yU3BhcnNlO1xuICAgIFwibmFtZVwiPzogYW55O1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuXG4gIC8qKlxuICAgKiBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL2dsVEYvc3BlY3MvMi4wL2dsVEYtMi4wLmh0bWwjYWNjZXNzb3ItZGF0YS10eXBlc1xuICAgKi9cbiAgZXhwb3J0IGVudW0gQ09NUE9ORU5UX1RZUEUge1xuICAgIEJZVEUgPSA1MTIwLFxuICAgIFVOU0lHTkVEX0JZVEUgPSA1MTIxLFxuICAgIFNIT1JUID0gNTEyMixcbiAgICBVTlNJR05FRF9TSE9SVCA9IDUxMjMsXG4gICAgVU5TSUdORURfSU5UID0gNTEyNSxcbiAgICBGTE9BVCA9IDUxMjZcbiAgfVxuXG4gIGV4cG9ydCBlbnVtIEFDQ0VTU09SX1RZUEUge1xuICAgIFNDQUxBUiA9IFwiU0NBTEFSXCIsXG4gICAgVkVDMiA9IFwiVkVDMlwiLFxuICAgIFZFQzMgPSBcIlZFQzNcIixcbiAgICBWRUM0ID0gXCJWRUM0XCIsXG4gICAgTUFUMiA9IFwiTUFUMlwiLFxuICAgIE1BVDMgPSBcIk1BVDNcIixcbiAgICBNQVQ0ID0gXCJNQVQ0XCJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRvciBvZiB0aGUgYW5pbWF0ZWQgcHJvcGVydHkuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkNoYW5uZWxUYXJnZXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBhbmltYXRlLiBXaGVuIHVuZGVmaW5lZCwgdGhlIGFuaW1hdGVkIG9iamVjdCAqKk1BWSoqIGJlIGRlZmluZWQgYnkgYW4gZXh0ZW5zaW9uLlxuICAgICAqL1xuICAgIFwibm9kZVwiPzogR2xUZklkO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBub2RlJ3MgVFJTIHByb3BlcnR5IHRvIGFuaW1hdGUsIG9yIHRoZSBgXCJ3ZWlnaHRzXCJgIG9mIHRoZSBNb3JwaCBUYXJnZXRzIGl0IGluc3RhbnRpYXRlcy4gRm9yIHRoZSBgXCJ0cmFuc2xhdGlvblwiYCBwcm9wZXJ0eSwgdGhlIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgc2FtcGxlciBhcmUgdGhlIHRyYW5zbGF0aW9uIGFsb25nIHRoZSBYLCBZLCBhbmQgWiBheGVzLiBGb3IgdGhlIGBcInJvdGF0aW9uXCJgIHByb3BlcnR5LCB0aGUgdmFsdWVzIGFyZSBhIHF1YXRlcm5pb24gaW4gdGhlIG9yZGVyICh4LCB5LCB6LCB3KSwgd2hlcmUgdyBpcyB0aGUgc2NhbGFyLiBGb3IgdGhlIGBcInNjYWxlXCJgIHByb3BlcnR5LCB0aGUgdmFsdWVzIGFyZSB0aGUgc2NhbGluZyBmYWN0b3JzIGFsb25nIHRoZSBYLCBZLCBhbmQgWiBheGVzLlxuICAgICAqL1xuICAgIFwicGF0aFwiOiBcInRyYW5zbGF0aW9uXCIgfCBcInJvdGF0aW9uXCIgfCBcInNjYWxlXCIgfCBcIndlaWdodHNcIjsgLy8gaHR0cHM6Ly9yZWdpc3RyeS5raHJvbm9zLm9yZy9nbFRGL3NwZWNzLzIuMC9nbFRGLTIuMC5odG1sI2FuaW1hdGlvbnNcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcbiAgICBcImV4dHJhc1wiPzogYW55O1xuICAgIFtrOiBzdHJpbmddOiBhbnk7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGFuaW1hdGlvbiBjaGFubmVsIGNvbWJpbmVzIGFuIGFuaW1hdGlvbiBzYW1wbGVyIHdpdGggYSB0YXJnZXQgcHJvcGVydHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkNoYW5uZWwge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiBhIHNhbXBsZXIgaW4gdGhpcyBhbmltYXRpb24gdXNlZCB0byBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRhcmdldC5cbiAgICAgKi9cbiAgICBcInNhbXBsZXJcIjogR2xUZklkO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdG9yIG9mIHRoZSBhbmltYXRlZCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBcInRhcmdldFwiOiBBbmltYXRpb25DaGFubmVsVGFyZ2V0O1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICAvKipcbiAgICogQW4gYW5pbWF0aW9uIHNhbXBsZXIgY29tYmluZXMgdGltZXN0YW1wcyB3aXRoIGEgc2VxdWVuY2Ugb2Ygb3V0cHV0IHZhbHVlcyBhbmQgZGVmaW5lcyBhbiBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uU2FtcGxlciB7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIGFuIGFjY2Vzc29yIGNvbnRhaW5pbmcga2V5ZnJhbWUgdGltZXN0YW1wcy5cbiAgICAgKi9cbiAgICBcImlucHV0XCI6IEdsVGZJZDtcbiAgICAvKipcbiAgICAgKiBJbnRlcnBvbGF0aW9uIGFsZ29yaXRobS5cbiAgICAgKi9cbiAgICBcImludGVycG9sYXRpb25cIj86IFwiTElORUFSXCIgfCBcIlNURVBcIiB8IFwiQ1VCSUNTUExJTkVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgYW4gYWNjZXNzb3IsIGNvbnRhaW5pbmcga2V5ZnJhbWUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBcIm91dHB1dFwiOiBHbFRmSWQ7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBBIGtleWZyYW1lIGFuaW1hdGlvbi5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbmltYXRpb24gY2hhbm5lbHMuIEFuIGFuaW1hdGlvbiBjaGFubmVsIGNvbWJpbmVzIGFuIGFuaW1hdGlvbiBzYW1wbGVyIHdpdGggYSB0YXJnZXQgcHJvcGVydHkgYmVpbmcgYW5pbWF0ZWQuIERpZmZlcmVudCBjaGFubmVscyBvZiB0aGUgc2FtZSBhbmltYXRpb24gKipNVVNUIE5PVCoqIGhhdmUgdGhlIHNhbWUgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICBcImNoYW5uZWxzXCI6IEFuaW1hdGlvbkNoYW5uZWxbXTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbmltYXRpb24gc2FtcGxlcnMuIEFuIGFuaW1hdGlvbiBzYW1wbGVyIGNvbWJpbmVzIHRpbWVzdGFtcHMgd2l0aCBhIHNlcXVlbmNlIG9mIG91dHB1dCB2YWx1ZXMgYW5kIGRlZmluZXMgYW4gaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0uXG4gICAgICovXG4gICAgXCJzYW1wbGVyc1wiOiBBbmltYXRpb25TYW1wbGVyW107XG4gICAgXCJuYW1lXCI/OiBhbnk7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBNZXRhZGF0YSBhYm91dCB0aGUgZ2xURiBhc3NldC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQXNzZXQge1xuICAgIC8qKlxuICAgICAqIEEgY29weXJpZ2h0IG1lc3NhZ2Ugc3VpdGFibGUgZm9yIGRpc3BsYXkgdG8gY3JlZGl0IHRoZSBjb250ZW50IGNyZWF0b3IuXG4gICAgICovXG4gICAgXCJjb3B5cmlnaHRcIj86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUb29sIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZ2xURiBtb2RlbC4gIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgICAqL1xuICAgIFwiZ2VuZXJhdG9yXCI/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGdsVEYgdmVyc2lvbiBpbiB0aGUgZm9ybSBvZiBgPG1ham9yPi48bWlub3I+YCB0aGF0IHRoaXMgYXNzZXQgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICBcInZlcnNpb25cIjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGdsVEYgdmVyc2lvbiBpbiB0aGUgZm9ybSBvZiBgPG1ham9yPi48bWlub3I+YCB0aGF0IHRoaXMgYXNzZXQgdGFyZ2V0cy4gVGhpcyBwcm9wZXJ0eSAqKk1VU1QgTk9UKiogYmUgZ3JlYXRlciB0aGFuIHRoZSBhc3NldCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIFwibWluVmVyc2lvblwiPzogc3RyaW5nO1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICAvKipcbiAgICogQSBidWZmZXIgcG9pbnRzIHRvIGJpbmFyeSBnZW9tZXRyeSwgYW5pbWF0aW9uLCBvciBza2lucy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgVVJJIChvciBJUkkpIG9mIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgXCJ1cmlcIj86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgXCJieXRlTGVuZ3RoXCI6IG51bWJlcjtcbiAgICBcIm5hbWVcIj86IGFueTtcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcbiAgICBcImV4dHJhc1wiPzogYW55O1xuICAgIFtrOiBzdHJpbmddOiBhbnk7XG4gIH1cbiAgLyoqXG4gICAqIEEgdmlldyBpbnRvIGEgYnVmZmVyIGdlbmVyYWxseSByZXByZXNlbnRpbmcgYSBzdWJzZXQgb2YgdGhlIGJ1ZmZlci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgQnVmZmVyVmlldyB7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgXCJidWZmZXJcIjogR2xUZklkO1xuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgaW50byB0aGUgYnVmZmVyIGluIGJ5dGVzLlxuICAgICAqL1xuICAgIFwiYnl0ZU9mZnNldFwiPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlclZpZXcgaW4gYnl0ZXMuXG4gICAgICovXG4gICAgXCJieXRlTGVuZ3RoXCI6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaWRlLCBpbiBieXRlcy5cbiAgICAgKi9cbiAgICBcImJ5dGVTdHJpZGVcIj86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGludCByZXByZXNlbnRpbmcgdGhlIGludGVuZGVkIEdQVSBidWZmZXIgdHlwZSB0byB1c2Ugd2l0aCB0aGlzIGJ1ZmZlciB2aWV3LlxuICAgICAqL1xuICAgIFwidGFyZ2V0XCI/OiBudW1iZXIgfCBudW1iZXIgfCBudW1iZXI7XG4gICAgXCJuYW1lXCI/OiBhbnk7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBBbiBvcnRob2dyYXBoaWMgY2FtZXJhIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjcmVhdGUgYW4gb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4LlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDYW1lcmFPcnRob2dyYXBoaWMge1xuICAgIC8qKlxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCBob3Jpem9udGFsIG1hZ25pZmljYXRpb24gb2YgdGhlIHZpZXcuIFRoaXMgdmFsdWUgKipNVVNUIE5PVCoqIGJlIGVxdWFsIHRvIHplcm8uIFRoaXMgdmFsdWUgKipTSE9VTEQgTk9UKiogYmUgbmVnYXRpdmUuXG4gICAgICovXG4gICAgXCJ4bWFnXCI6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgdmVydGljYWwgbWFnbmlmaWNhdGlvbiBvZiB0aGUgdmlldy4gVGhpcyB2YWx1ZSAqKk1VU1QgTk9UKiogYmUgZXF1YWwgdG8gemVyby4gVGhpcyB2YWx1ZSAqKlNIT1VMRCBOT1QqKiBiZSBuZWdhdGl2ZS5cbiAgICAgKi9cbiAgICBcInltYWdcIjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCBkaXN0YW5jZSB0byB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLiBUaGlzIHZhbHVlICoqTVVTVCBOT1QqKiBiZSBlcXVhbCB0byB6ZXJvLiBgemZhcmAgKipNVVNUKiogYmUgZ3JlYXRlciB0aGFuIGB6bmVhcmAuXG4gICAgICovXG4gICAgXCJ6ZmFyXCI6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgZGlzdGFuY2UgdG8gdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gICAgICovXG4gICAgXCJ6bmVhclwiOiBudW1iZXI7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBBIHBlcnNwZWN0aXZlIGNhbWVyYSBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY3JlYXRlIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENhbWVyYVBlcnNwZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgYXNwZWN0IHJhdGlvIG9mIHRoZSBmaWVsZCBvZiB2aWV3LlxuICAgICAqL1xuICAgIFwiYXNwZWN0UmF0aW9cIj86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgdmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zLiBUaGlzIHZhbHVlICoqU0hPVUxEKiogYmUgbGVzcyB0aGFuIM+ALlxuICAgICAqL1xuICAgIFwieWZvdlwiOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGRpc3RhbmNlIHRvIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUuXG4gICAgICovXG4gICAgXCJ6ZmFyXCI/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGRpc3RhbmNlIHRvIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqL1xuICAgIFwiem5lYXJcIjogbnVtYmVyO1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICAvKipcbiAgICogQSBjYW1lcmEncyBwcm9qZWN0aW9uLiAgQSBub2RlICoqTUFZKiogcmVmZXJlbmNlIGEgY2FtZXJhIHRvIGFwcGx5IGEgdHJhbnNmb3JtIHRvIHBsYWNlIHRoZSBjYW1lcmEgaW4gdGhlIHNjZW5lLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDYW1lcmEge1xuICAgIC8qKlxuICAgICAqIEFuIG9ydGhvZ3JhcGhpYyBjYW1lcmEgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhbiBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguIFRoaXMgcHJvcGVydHkgKipNVVNUIE5PVCoqIGJlIGRlZmluZWQgd2hlbiBgcGVyc3BlY3RpdmVgIGlzIGRlZmluZWQuXG4gICAgICovXG4gICAgXCJvcnRob2dyYXBoaWNcIj86IENhbWVyYU9ydGhvZ3JhcGhpYztcbiAgICAvKipcbiAgICAgKiBBIHBlcnNwZWN0aXZlIGNhbWVyYSBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY3JlYXRlIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguIFRoaXMgcHJvcGVydHkgKipNVVNUIE5PVCoqIGJlIGRlZmluZWQgd2hlbiBgb3J0aG9ncmFwaGljYCBpcyBkZWZpbmVkLlxuICAgICAqL1xuICAgIFwicGVyc3BlY3RpdmVcIj86IENhbWVyYVBlcnNwZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBpZiB0aGUgY2FtZXJhIHVzZXMgYSBwZXJzcGVjdGl2ZSBvciBvcnRob2dyYXBoaWMgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBcInR5cGVcIjogYW55IHwgYW55IHwgc3RyaW5nO1xuICAgIFwibmFtZVwiPzogYW55O1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICAvKipcbiAgICogSW1hZ2UgZGF0YSB1c2VkIHRvIGNyZWF0ZSBhIHRleHR1cmUuIEltYWdlICoqTUFZKiogYmUgcmVmZXJlbmNlZCBieSBhbiBVUkkgKG9yIElSSSkgb3IgYSBidWZmZXIgdmlldyBpbmRleC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSBVUkkgKG9yIElSSSkgb2YgdGhlIGltYWdlLlxuICAgICAqL1xuICAgIFwidXJpXCI/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlJ3MgbWVkaWEgdHlwZS4gVGhpcyBmaWVsZCAqKk1VU1QqKiBiZSBkZWZpbmVkIHdoZW4gYGJ1ZmZlclZpZXdgIGlzIGRlZmluZWQuXG4gICAgICovXG4gICAgXCJtaW1lVHlwZVwiPzogYW55IHwgYW55IHwgc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYnVmZmVyVmlldyB0aGF0IGNvbnRhaW5zIHRoZSBpbWFnZS4gVGhpcyBmaWVsZCAqKk1VU1QgTk9UKiogYmUgZGVmaW5lZCB3aGVuIGB1cmlgIGlzIGRlZmluZWQuXG4gICAgICovXG4gICAgXCJidWZmZXJWaWV3XCI/OiBHbFRmSWQ7XG4gICAgXCJuYW1lXCI/OiBhbnk7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gYSB0ZXh0dXJlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlSW5mbyB7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIFwiaW5kZXhcIjogR2xUZklkO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXQgaW5kZXggb2YgdGV4dHVyZSdzIFRFWENPT1JEIGF0dHJpYnV0ZSB1c2VkIGZvciB0ZXh0dXJlIGNvb3JkaW5hdGUgbWFwcGluZy5cbiAgICAgKi9cbiAgICBcInRleENvb3JkXCI/OiBudW1iZXI7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBBIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gZGVmaW5lIHRoZSBtZXRhbGxpYy1yb3VnaG5lc3MgbWF0ZXJpYWwgbW9kZWwgZnJvbSBQaHlzaWNhbGx5LUJhc2VkIFJlbmRlcmluZyAoUEJSKSBtZXRob2RvbG9neS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWF0ZXJpYWxQYnJNZXRhbGxpY1JvdWdobmVzcyB7XG4gICAgLyoqXG4gICAgICogVGhlIGZhY3RvcnMgZm9yIHRoZSBiYXNlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbC5cbiAgICAgKi9cbiAgICBcImJhc2VDb2xvckZhY3RvclwiPzogbnVtYmVyW107XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29sb3IgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBcImJhc2VDb2xvclRleHR1cmVcIj86IFRleHR1cmVJbmZvO1xuICAgIC8qKlxuICAgICAqIFRoZSBmYWN0b3IgZm9yIHRoZSBtZXRhbG5lc3Mgb2YgdGhlIG1hdGVyaWFsLlxuICAgICAqL1xuICAgIFwibWV0YWxsaWNGYWN0b3JcIj86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmFjdG9yIGZvciB0aGUgcm91Z2huZXNzIG9mIHRoZSBtYXRlcmlhbC5cbiAgICAgKi9cbiAgICBcInJvdWdobmVzc0ZhY3RvclwiPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZXRhbGxpYy1yb3VnaG5lc3MgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBcIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZVwiPzogVGV4dHVyZUluZm87XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWF0ZXJpYWxOb3JtYWxUZXh0dXJlSW5mbyB7XG4gICAgXCJpbmRleFwiPzogYW55O1xuICAgIFwidGV4Q29vcmRcIj86IGFueTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGFyIHBhcmFtZXRlciBhcHBsaWVkIHRvIGVhY2ggbm9ybWFsIHZlY3RvciBvZiB0aGUgbm9ybWFsIHRleHR1cmUuXG4gICAgICovXG4gICAgXCJzY2FsZVwiPzogbnVtYmVyO1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE1hdGVyaWFsT2NjbHVzaW9uVGV4dHVyZUluZm8ge1xuICAgIFwiaW5kZXhcIj86IGFueTtcbiAgICBcInRleENvb3JkXCI/OiBhbnk7XG4gICAgLyoqXG4gICAgICogQSBzY2FsYXIgbXVsdGlwbGllciBjb250cm9sbGluZyB0aGUgYW1vdW50IG9mIG9jY2x1c2lvbiBhcHBsaWVkLlxuICAgICAqL1xuICAgIFwic3RyZW5ndGhcIj86IG51bWJlcjtcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcbiAgICBcImV4dHJhc1wiPzogYW55O1xuICAgIFtrOiBzdHJpbmddOiBhbnk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBtYXRlcmlhbCBhcHBlYXJhbmNlIG9mIGEgcHJpbWl0aXZlLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbCB7XG4gICAgXCJuYW1lXCI/OiBhbnk7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gZGVmaW5lIHRoZSBtZXRhbGxpYy1yb3VnaG5lc3MgbWF0ZXJpYWwgbW9kZWwgZnJvbSBQaHlzaWNhbGx5IEJhc2VkIFJlbmRlcmluZyAoUEJSKSBtZXRob2RvbG9neS4gV2hlbiB1bmRlZmluZWQsIGFsbCB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgYHBick1ldGFsbGljUm91Z2huZXNzYCAqKk1VU1QqKiBhcHBseS5cbiAgICAgKi9cbiAgICBcInBick1ldGFsbGljUm91Z2huZXNzXCI/OiBNYXRlcmlhbFBick1ldGFsbGljUm91Z2huZXNzO1xuICAgIC8qKlxuICAgICAqIFRoZSB0YW5nZW50IHNwYWNlIG5vcm1hbCB0ZXh0dXJlLlxuICAgICAqL1xuICAgIFwibm9ybWFsVGV4dHVyZVwiPzogTWF0ZXJpYWxOb3JtYWxUZXh0dXJlSW5mbztcbiAgICAvKipcbiAgICAgKiBUaGUgb2NjbHVzaW9uIHRleHR1cmUuXG4gICAgICovXG4gICAgXCJvY2NsdXNpb25UZXh0dXJlXCI/OiBNYXRlcmlhbE9jY2x1c2lvblRleHR1cmVJbmZvO1xuICAgIC8qKlxuICAgICAqIFRoZSBlbWlzc2l2ZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIFwiZW1pc3NpdmVUZXh0dXJlXCI/OiBUZXh0dXJlSW5mbztcbiAgICAvKipcbiAgICAgKiBUaGUgZmFjdG9ycyBmb3IgdGhlIGVtaXNzaXZlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbC5cbiAgICAgKi9cbiAgICBcImVtaXNzaXZlRmFjdG9yXCI/OiBudW1iZXJbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWxwaGEgcmVuZGVyaW5nIG1vZGUgb2YgdGhlIG1hdGVyaWFsLlxuICAgICAqL1xuICAgIFwiYWxwaGFNb2RlXCI/OiBcIk9QQVFVRVwiIHwgXCJNQVNLXCIgfCBcIkJMRU5EXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGFscGhhIGN1dG9mZiB2YWx1ZSBvZiB0aGUgbWF0ZXJpYWwuXG4gICAgICovXG4gICAgXCJhbHBoYUN1dG9mZlwiPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtYXRlcmlhbCBpcyBkb3VibGUgc2lkZWQuXG4gICAgICovXG4gICAgXCJkb3VibGVTaWRlZFwiPzogYm9vbGVhbjtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBHZW9tZXRyeSB0byBiZSByZW5kZXJlZCB3aXRoIHRoZSBnaXZlbiBtYXRlcmlhbC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzaFByaW1pdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQSBwbGFpbiBKU09OIG9iamVjdCwgd2hlcmUgZWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYSBtZXNoIGF0dHJpYnV0ZSBzZW1hbnRpYyBhbmQgZWFjaCB2YWx1ZSBpcyB0aGUgaW5kZXggb2YgdGhlIGFjY2Vzc29yIGNvbnRhaW5pbmcgYXR0cmlidXRlJ3MgZGF0YS5cbiAgICAgKi9cbiAgICBcImF0dHJpYnV0ZXNcIjoge1xuICAgICAgW2s6IHN0cmluZ106IEdsVGZJZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYWNjZXNzb3IgdGhhdCBjb250YWlucyB0aGUgdmVydGV4IGluZGljZXMuXG4gICAgICovXG4gICAgXCJpbmRpY2VzXCI/OiBHbFRmSWQ7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBtYXRlcmlhbCB0byBhcHBseSB0byB0aGlzIHByaW1pdGl2ZSB3aGVuIHJlbmRlcmluZy5cbiAgICAgKi9cbiAgICBcIm1hdGVyaWFsXCI/OiBHbFRmSWQ7XG4gICAgLyoqXG4gICAgICogVGhlIHRvcG9sb2d5IHR5cGUgb2YgcHJpbWl0aXZlcyB0byByZW5kZXIuXG4gICAgICovXG4gICAgXCJtb2RlXCI/OiBNRVNIX1BSSU1JVElWRV9NT0RFO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIG1vcnBoIHRhcmdldHMuXG4gICAgICovXG4gICAgXCJ0YXJnZXRzXCI/OiB7XG4gICAgICBbazogc3RyaW5nXTogR2xUZklkO1xuICAgIH1bXTtcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcbiAgICBcImV4dHJhc1wiPzogYW55O1xuICAgIFtrOiBzdHJpbmddOiBhbnk7XG4gIH1cblxuICBleHBvcnQgZW51bSBNRVNIX1BSSU1JVElWRV9NT0RFIHtcbiAgICBQT0lOVFMsXG4gICAgTElORVMsXG4gICAgTElORV9MT09QLFxuICAgIExJTkVfU1RSSVAsXG4gICAgVFJJQU5HTEVTLFxuICAgIFRSSUFOR0xFX1NUUklQLFxuICAgIFRSSUFOR0xFX0ZBTlxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIHByaW1pdGl2ZXMgdG8gYmUgcmVuZGVyZWQuICBJdHMgZ2xvYmFsIHRyYW5zZm9ybSBpcyBkZWZpbmVkIGJ5IGEgbm9kZSB0aGF0IHJlZmVyZW5jZXMgaXQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE1lc2gge1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHByaW1pdGl2ZXMsIGVhY2ggZGVmaW5pbmcgZ2VvbWV0cnkgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgXCJwcmltaXRpdmVzXCI6IE1lc2hQcmltaXRpdmVbXTtcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiB3ZWlnaHRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG1vcnBoIHRhcmdldHMuIFRoZSBudW1iZXIgb2YgYXJyYXkgZWxlbWVudHMgKipNVVNUKiogbWF0Y2ggdGhlIG51bWJlciBvZiBtb3JwaCB0YXJnZXRzLlxuICAgICAqL1xuICAgIFwid2VpZ2h0c1wiPzogbnVtYmVyW107XG4gICAgXCJuYW1lXCI/OiBhbnk7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuICB9XG4gIC8qKlxuICAgKiBBIG5vZGUgaW4gdGhlIG5vZGUgaGllcmFyY2h5LiAgV2hlbiB0aGUgbm9kZSBjb250YWlucyBgc2tpbmAsIGFsbCBgbWVzaC5wcmltaXRpdmVzYCAqKk1VU1QqKiBjb250YWluIGBKT0lOVFNfMGAgYW5kIGBXRUlHSFRTXzBgIGF0dHJpYnV0ZXMuICBBIG5vZGUgKipNQVkqKiBoYXZlIGVpdGhlciBhIGBtYXRyaXhgIG9yIGFueSBjb21iaW5hdGlvbiBvZiBgdHJhbnNsYXRpb25gL2Byb3RhdGlvbmAvYHNjYWxlYCAoVFJTKSBwcm9wZXJ0aWVzLiBUUlMgcHJvcGVydGllcyBhcmUgY29udmVydGVkIHRvIG1hdHJpY2VzIGFuZCBwb3N0bXVsdGlwbGllZCBpbiB0aGUgYFQgKiBSICogU2Agb3JkZXIgdG8gY29tcG9zZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4OyBmaXJzdCB0aGUgc2NhbGUgaXMgYXBwbGllZCB0byB0aGUgdmVydGljZXMsIHRoZW4gdGhlIHJvdGF0aW9uLCBhbmQgdGhlbiB0aGUgdHJhbnNsYXRpb24uIElmIG5vbmUgYXJlIHByb3ZpZGVkLCB0aGUgdHJhbnNmb3JtIGlzIHRoZSBpZGVudGl0eS4gV2hlbiBhIG5vZGUgaXMgdGFyZ2V0ZWQgZm9yIGFuaW1hdGlvbiAocmVmZXJlbmNlZCBieSBhbiBhbmltYXRpb24uY2hhbm5lbC50YXJnZXQpLCBgbWF0cml4YCAqKk1VU1QgTk9UKiogYmUgcHJlc2VudC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgTm9kZSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjYW1lcmEgcmVmZXJlbmNlZCBieSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgXCJjYW1lcmFcIj86IEdsVGZJZDtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kaWNlcyBvZiB0aGlzIG5vZGUncyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBcImNoaWxkcmVuXCI/OiBHbFRmSWRbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHNraW4gcmVmZXJlbmNlZCBieSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgXCJza2luXCI/OiBHbFRmSWQ7XG4gICAgLyoqXG4gICAgICogQSBmbG9hdGluZy1wb2ludCA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IHN0b3JlZCBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXG4gICAgICovXG4gICAgXCJtYXRyaXhcIj86IG51bWJlcltdO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbWVzaCBpbiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgXCJtZXNoXCI/OiBHbFRmSWQ7XG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUncyB1bml0IHF1YXRlcm5pb24gcm90YXRpb24gaW4gdGhlIG9yZGVyICh4LCB5LCB6LCB3KSwgd2hlcmUgdyBpcyB0aGUgc2NhbGFyLlxuICAgICAqL1xuICAgIFwicm90YXRpb25cIj86IG51bWJlcltdO1xuICAgIC8qKlxuICAgICAqIFRoZSBub2RlJ3Mgbm9uLXVuaWZvcm0gc2NhbGUsIGdpdmVuIGFzIHRoZSBzY2FsaW5nIGZhY3RvcnMgYWxvbmcgdGhlIHgsIHksIGFuZCB6IGF4ZXMuXG4gICAgICovXG4gICAgXCJzY2FsZVwiPzogbnVtYmVyW107XG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUncyB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeCwgeSwgYW5kIHogYXhlcy5cbiAgICAgKi9cbiAgICBcInRyYW5zbGF0aW9uXCI/OiBudW1iZXJbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgd2VpZ2h0cyBvZiB0aGUgaW5zdGFudGlhdGVkIG1vcnBoIHRhcmdldC4gVGhlIG51bWJlciBvZiBhcnJheSBlbGVtZW50cyAqKk1VU1QqKiBtYXRjaCB0aGUgbnVtYmVyIG9mIG1vcnBoIHRhcmdldHMgb2YgdGhlIHJlZmVyZW5jZWQgbWVzaC4gV2hlbiBkZWZpbmVkLCBgbWVzaGAgKipNVVNUKiogYWxzbyBiZSBkZWZpbmVkLlxuICAgICAqL1xuICAgIFwid2VpZ2h0c1wiPzogbnVtYmVyW107XG4gICAgXCJuYW1lXCI/OiBzdHJpbmc7XG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XG4gICAgXCJleHRyYXNcIj86IGFueTtcbiAgICBbazogc3RyaW5nXTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHByb3BlcnR5IHNldCBieSBGVURHRSBsb2FkZXIuIE5vdCBwYXJ0IG9mIGdsVEYgc3RhbmRhcmQgMi4wLlxuICAgICAqL1xuICAgIGlzQW5pbWF0ZWQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBwcm9wZXJ0eSBzZXQgYnkgRlVER0UgbG9hZGVyLiBOb3QgcGFydCBvZiBnbFRGIHN0YW5kYXJkIDIuMC5cbiAgICAgKi9cbiAgICBwYXJlbnQ/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHByb3BlcnR5IHNldCBieSBGVURHRSBsb2FkZXIuIE5vdCBwYXJ0IG9mIGdsVEYgc3RhbmRhcmQgMi4wLlxuICAgICAqL1xuICAgIHBhdGg/OiBudW1iZXJbXTtcbiAgfVxuICAvKipcbiAgICogVGV4dHVyZSBzYW1wbGVyIHByb3BlcnRpZXMgZm9yIGZpbHRlcmluZyBhbmQgd3JhcHBpbmcgbW9kZXMuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNhbXBsZXIge1xuICAgIC8qKlxuICAgICAqIE1hZ25pZmljYXRpb24gZmlsdGVyLlxuICAgICAqL1xuICAgIFwibWFnRmlsdGVyXCI/OiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0W1wiTkVBUkVTVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJMSU5FQVJcIl07XG4gICAgLyoqXG4gICAgICogTWluaWZpY2F0aW9uIGZpbHRlci5cbiAgICAgKi9cbiAgICBcIm1pbkZpbHRlclwiPzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk5FQVJFU1RcIl0gfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0W1wiTElORUFSXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk5FQVJFU1RfTUlQTUFQX05FQVJFU1RcIl0gfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0W1wiTElORUFSX01JUE1BUF9ORUFSRVNUXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk5FQVJFU1RfTUlQTUFQX0xJTkVBUlwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJMSU5FQVJfTUlQTUFQX0xJTkVBUlwiXTtcbiAgICAvKipcbiAgICAgKiBTIChVKSB3cmFwcGluZyBtb2RlLlxuICAgICAqL1xuICAgIFwid3JhcFNcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJDTEFNUF9UT19FREdFXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk1JUlJPUkVEX1JFUEVBVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJSRVBFQVRcIl07XG4gICAgLyoqXG4gICAgICogVCAoVikgd3JhcHBpbmcgbW9kZS5cbiAgICAgKi9cbiAgICBcIndyYXBUXCI/OiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0W1wiQ0xBTVBfVE9fRURHRVwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJNSVJST1JFRF9SRVBFQVRcIl0gfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0W1wiUkVQRUFUXCJdO1xuICAgIFwibmFtZVwiPzogc3RyaW5nO1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJvb3Qgbm9kZXMgb2YgYSBzY2VuZS5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2NlbmUge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRpY2VzIG9mIGVhY2ggcm9vdCBub2RlLlxuICAgICAqL1xuICAgIFwibm9kZXNcIj86IEdsVGZJZFtdO1xuICAgIFwibmFtZVwiPzogYW55O1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICAvKipcbiAgICogSm9pbnRzIGFuZCBtYXRyaWNlcyBkZWZpbmluZyBhIHNraW4uXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNraW4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYWNjZXNzb3IgY29udGFpbmluZyB0aGUgZmxvYXRpbmctcG9pbnQgNHg0IGludmVyc2UtYmluZCBtYXRyaWNlcy5cbiAgICAgKi9cbiAgICBcImludmVyc2VCaW5kTWF0cmljZXNcIj86IEdsVGZJZDtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdXNlZCBhcyBhIHNrZWxldG9uIHJvb3QuXG4gICAgICovXG4gICAgXCJza2VsZXRvblwiPzogR2xUZklkO1xuICAgIC8qKlxuICAgICAqIEluZGljZXMgb2Ygc2tlbGV0b24gbm9kZXMsIHVzZWQgYXMgam9pbnRzIGluIHRoaXMgc2tpbi5cbiAgICAgKi9cbiAgICBcImpvaW50c1wiOiBHbFRmSWRbXTtcbiAgICBcIm5hbWVcIj86IGFueTtcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcbiAgICBcImV4dHJhc1wiPzogYW55O1xuICAgIFtrOiBzdHJpbmddOiBhbnk7XG4gIH1cbiAgLyoqXG4gICAqIEEgdGV4dHVyZSBhbmQgaXRzIHNhbXBsZXIuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRleHR1cmUge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgc2FtcGxlciB1c2VkIGJ5IHRoaXMgdGV4dHVyZS4gV2hlbiB1bmRlZmluZWQsIGEgc2FtcGxlciB3aXRoIHJlcGVhdCB3cmFwcGluZyBhbmQgYXV0byBmaWx0ZXJpbmcgKipTSE9VTEQqKiBiZSB1c2VkLlxuICAgICAqL1xuICAgIFwic2FtcGxlclwiPzogR2xUZklkO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgaW1hZ2UgdXNlZCBieSB0aGlzIHRleHR1cmUuIFdoZW4gdW5kZWZpbmVkLCBhbiBleHRlbnNpb24gb3Igb3RoZXIgbWVjaGFuaXNtICoqU0hPVUxEKiogc3VwcGx5IGFuIGFsdGVybmF0ZSB0ZXh0dXJlIHNvdXJjZSwgb3RoZXJ3aXNlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBcInNvdXJjZVwiPzogR2xUZklkO1xuICAgIFwibmFtZVwiPzogYW55O1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJvb3Qgb2JqZWN0IGZvciBhIGdsVEYgYXNzZXQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIEdsVGYge1xuICAgIC8qKlxuICAgICAqIE5hbWVzIG9mIGdsVEYgZXh0ZW5zaW9ucyB1c2VkIGluIHRoaXMgYXNzZXQuXG4gICAgICovXG4gICAgXCJleHRlbnNpb25zVXNlZFwiPzogc3RyaW5nW107XG4gICAgLyoqXG4gICAgICogTmFtZXMgb2YgZ2xURiBleHRlbnNpb25zIHJlcXVpcmVkIHRvIHByb3Blcmx5IGxvYWQgdGhpcyBhc3NldC5cbiAgICAgKi9cbiAgICBcImV4dGVuc2lvbnNSZXF1aXJlZFwiPzogc3RyaW5nW107XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYWNjZXNzb3JzLlxuICAgICAqL1xuICAgIFwiYWNjZXNzb3JzXCI/OiBBY2Nlc3NvcltdO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGtleWZyYW1lIGFuaW1hdGlvbnMuXG4gICAgICovXG4gICAgXCJhbmltYXRpb25zXCI/OiBBbmltYXRpb25bXTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSBhYm91dCB0aGUgZ2xURiBhc3NldC5cbiAgICAgKi9cbiAgICBcImFzc2V0XCI6IEFzc2V0O1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4gICAgICovXG4gICAgXCJidWZmZXJzXCI/OiBCdWZmZXJbXTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBidWZmZXJWaWV3cy5cbiAgICAgKi9cbiAgICBcImJ1ZmZlclZpZXdzXCI/OiBCdWZmZXJWaWV3W107XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgY2FtZXJhcy5cbiAgICAgKi9cbiAgICBcImNhbWVyYXNcIj86IENhbWVyYVtdO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGltYWdlcy5cbiAgICAgKi9cbiAgICBcImltYWdlc1wiPzogSW1hZ2VbXTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBtYXRlcmlhbHMuXG4gICAgICovXG4gICAgXCJtYXRlcmlhbHNcIj86IE1hdGVyaWFsW107XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgbWVzaGVzLlxuICAgICAqL1xuICAgIFwibWVzaGVzXCI/OiBNZXNoW107XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2Ygbm9kZXMuXG4gICAgICovXG4gICAgXCJub2Rlc1wiPzogTm9kZVtdO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHNhbXBsZXJzLlxuICAgICAqL1xuICAgIFwic2FtcGxlcnNcIj86IFNhbXBsZXJbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGRlZmF1bHQgc2NlbmUuXG4gICAgICovXG4gICAgXCJzY2VuZVwiPzogR2xUZklkO1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIHNjZW5lcy5cbiAgICAgKi9cbiAgICBcInNjZW5lc1wiPzogU2NlbmVbXTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBza2lucy5cbiAgICAgKi9cbiAgICBcInNraW5zXCI/OiBTa2luW107XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgdGV4dHVyZXMuXG4gICAgICovXG4gICAgXCJ0ZXh0dXJlc1wiPzogVGV4dHVyZVtdO1xuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xuICAgIFwiZXh0cmFzXCI/OiBhbnk7XG4gICAgW2s6IHN0cmluZ106IGFueTtcbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogQXNzZXQgbG9hZGVyIGZvciBnbCBUcmFuc2ZlciBGb3JtYXQgZmlsZXMuXG4gICAqIEBhdXRob3JzIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIyIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXG4gICAqL1xuICBleHBvcnQgY2xhc3MgR0xURkxvYWRlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9hZGVyczogeyBbdXJsOiBzdHJpbmddOiBHTFRGTG9hZGVyIH07XG5cbiAgICBzdGF0aWMgI2RlZmF1bHRNYXRlcmlhbDogTWF0ZXJpYWw7XG4gICAgc3RhdGljICNkZWZhdWx0U2tpbk1hdGVyaWFsOiBNYXRlcmlhbDtcblxuICAgIHB1YmxpYyByZWFkb25seSBnbHRmOiBHTFRGLkdsVGY7XG4gICAgcHVibGljIHJlYWRvbmx5IHVybDogc3RyaW5nO1xuXG4gICAgI3NjZW5lczogR3JhcGhbXTtcbiAgICAjbm9kZXM6IE5vZGVbXSA9IFtdO1xuICAgICNjYW1lcmFzOiBDb21wb25lbnRDYW1lcmFbXTtcbiAgICAjYW5pbWF0aW9uczogQW5pbWF0aW9uW107XG4gICAgI21lc2hlczogTWVzaEltcG9ydFtdW107XG4gICAgI21hdGVyaWFsczogTWF0ZXJpYWxbXTtcbiAgICAjc2tlbGV0b25zOiBDb21wb25lbnRTa2VsZXRvbltdO1xuICAgICN0ZXh0dXJlczogVGV4dHVyZVtdO1xuICAgICNidWZmZXJzOiBBcnJheUJ1ZmZlcltdO1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihfZ2x0ZjogR0xURi5HbFRmLCBfdXJsOiBzdHJpbmcpIHtcbiAgICAgIHRoaXMuZ2x0ZiA9IF9nbHRmO1xuICAgICAgdGhpcy51cmwgPSBfdXJsO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldCBkZWZhdWx0TWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xuICAgICAgaWYgKCF0aGlzLiNkZWZhdWx0TWF0ZXJpYWwpXG4gICAgICAgIHRoaXMuI2RlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChcIkdMVEZEZWZhdWx0TWF0ZXJpYWxcIiwgU2hhZGVyUGhvbmcsIG5ldyBDb2F0UmVtaXNzaXZlKENvbG9yLkNTUyhcIndoaXRlXCIpLCAxLCAwLjUpKTtcbiAgICAgIHJldHVybiB0aGlzLiNkZWZhdWx0TWF0ZXJpYWw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IGRlZmF1bHRTa2luTWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xuICAgICAgaWYgKCF0aGlzLiNkZWZhdWx0U2tpbk1hdGVyaWFsKVxuICAgICAgICB0aGlzLiNkZWZhdWx0U2tpbk1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKFwiR0xURkRlZmF1bHRTa2luTWF0ZXJpYWxcIiwgU2hhZGVyUGhvbmdTa2luLCBuZXcgQ29hdFJlbWlzc2l2ZShDb2xvci5DU1MoXCJ3aGl0ZVwiKSwgMSwgMC41KSk7XG4gICAgICByZXR1cm4gdGhpcy4jZGVmYXVsdFNraW5NYXRlcmlhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIEdMVEZMb2FkZXJ9IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gdXJsLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgTE9BRChfdXJsOiBzdHJpbmcpOiBQcm9taXNlPEdMVEZMb2FkZXI+IHtcbiAgICAgIGNvbnN0IHVybDogc3RyaW5nID0gbmV3IFVSTChfdXJsLCBQcm9qZWN0LmJhc2VVUkwpLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmICghdGhpcy5sb2FkZXJzKVxuICAgICAgICBHTFRGTG9hZGVyLmxvYWRlcnMgPSB7fTtcblxuICAgICAgaWYgKCF0aGlzLmxvYWRlcnNbdXJsXSkge1xuICAgICAgICBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgICAgICBjb25zdCBnbHRmOiBHTFRGLkdsVGYgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgR0xURkxvYWRlci5jaGVja0NvbXBhdGliaWxpdHkoZ2x0ZiwgdXJsKTtcbiAgICAgICAgR0xURkxvYWRlci5wcmVQcm9jZXNzKGdsdGYsIHVybCk7XG5cbiAgICAgICAgR0xURkxvYWRlci5sb2FkZXJzW3VybF0gPSBuZXcgR0xURkxvYWRlcihnbHRmLCB1cmwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gR0xURkxvYWRlci5sb2FkZXJzW3VybF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY2hlY2tDb21wYXRpYmlsaXR5KF9nbHRmOiBHTFRGLkdsVGYsIF91cmw6IHN0cmluZyk6IHZvaWQge1xuICAgICAgaWYgKF9nbHRmLmFzc2V0LnZlcnNpb24gIT0gXCIyLjBcIilcbiAgICAgICAgRGVidWcud2FybihgJHtHTFRGTG9hZGVyLm5hbWV9IHwgJHtfdXJsfTogVGhpcyBsb2FkZXIgd2FzIGRldmVsb3BlZCBmb3IgZ2xURiAyLjAuIEl0IG1heSBub3Qgd29yayBhcyBpbnRlbmRlZCB3aXRoIHZlcnNpb24gJHtfZ2x0Zi5hc3NldC52ZXJzaW9ufS5gKTtcbiAgICAgIGlmIChfZ2x0Zi5hc3NldC5taW5WZXJzaW9uICE9IHVuZGVmaW5lZCAmJiBfZ2x0Zi5hc3NldC5taW5WZXJzaW9uICE9IFwiMi4wXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtHTFRGTG9hZGVyLm5hbWV9IHwgJHtfdXJsfTogVGhpcyBsb2FkZXIgd2FzIGRldmVsb3BlZCBmb3IgZ2xURiAyLjAuIEl0IGRvZXMgbm90IHdvcmsgd2l0aCByZXF1aXJlZCBtaW4gdmVyc2lvbiAke19nbHRmLmFzc2V0Lm1pblZlcnNpb259LmApO1xuICAgICAgaWYgKF9nbHRmLmV4dGVuc2lvbnNVc2VkPy5sZW5ndGggPiAwKVxuICAgICAgICBEZWJ1Zy53YXJuKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBUaGlzIGxvYWRlciBkb2VzIG5vdCBzdXBwb3J0IGdsVEYgZXh0ZW5zaW9ucy4gSXQgbWF5IG5vdCB3b3JrIGFzIGludGVuZGVkIHdpdGggZXh0ZW5zaW9ucyAke19nbHRmLmV4dGVuc2lvbnNVc2VkLnRvU3RyaW5nKCl9LmApO1xuICAgICAgaWYgKF9nbHRmLmV4dGVuc2lvbnNSZXF1aXJlZD8ubGVuZ3RoID4gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBUaGlzIGxvYWRlciBkb2VzIG5vdCBzdXBwb3J0IGdsVEYgZXh0ZW5zaW9ucy4gSXQgZG9lcyBub3Qgd29yayB3aXRoIHJlcXVpcmVkIGV4dGVuc2lvbnMgJHtfZ2x0Zi5leHRlbnNpb25zUmVxdWlyZWQudG9TdHJpbmcoKX0uYCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJlUHJvY2VzcyhfZ2x0ZjogR0xURi5HbFRmLCBfdXJsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGlmIChfZ2x0Zi5ub2Rlcykge1xuICAgICAgICAvLyBtYXJrIGFsbCBub2RlcyB0aGF0IGFyZSBhbmltYXRlZFxuICAgICAgICBfZ2x0Zi5hbmltYXRpb25zPy5mb3JFYWNoKF9hbmltYXRpb24gPT4ge1xuICAgICAgICAgIF9hbmltYXRpb24uY2hhbm5lbHMuZm9yRWFjaChfY2hhbm5lbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpTm9kZTogbnVtYmVyID0gX2NoYW5uZWwudGFyZ2V0Lm5vZGU7XG4gICAgICAgICAgICBpZiAoaU5vZGUgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICBfZ2x0Zi5ub2Rlc1tpTm9kZV0uaXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1hcmsgcGFyZW50IG9mIGVhY2ggbm9kZVxuICAgICAgICBfZ2x0Zi5ub2Rlcy5mb3JFYWNoKChfbm9kZSwgX2lOb2RlKSA9PiBfbm9kZS5jaGlsZHJlbj8uZm9yRWFjaChfaUNoaWxkID0+IF9nbHRmLm5vZGVzW19pQ2hpbGRdLnBhcmVudCA9IF9pTm9kZSkpO1xuXG4gICAgICAgIF9nbHRmLm5vZGVzLmZvckVhY2goKF9ub2RlLCBfaU5vZGUpID0+IHtcbiAgICAgICAgICAvLyBhZGQgbmFtZXMgdG8gbm9kZXMgdGhhdCBkb24ndCBoYXZlIG9uZVxuICAgICAgICAgIGlmICghX25vZGUubmFtZSlcbiAgICAgICAgICAgIF9ub2RlLm5hbWUgPSBgTm9kZSR7X2lOb2RlfWA7XG5cbiAgICAgICAgICBpZiAoX25vZGUuaXNBbmltYXRlZCkge1xuICAgICAgICAgICAgLy8gYWRkIHBhdGggdG8gZWFjaCBhbmltYXRlZCBub2RlXG4gICAgICAgICAgICBsZXQgaVBhcmVudDogbnVtYmVyID0gX25vZGUucGFyZW50O1xuICAgICAgICAgICAgbGV0IHBhdGg6IG51bWJlcltdID0gW107XG4gICAgICAgICAgICBwYXRoLnB1c2goX2lOb2RlKTtcbiAgICAgICAgICAgIHdoaWxlIChpUGFyZW50ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXRoLnB1c2goaVBhcmVudCk7XG4gICAgICAgICAgICAgIGlQYXJlbnQgPSBfZ2x0Zi5ub2Rlc1tpUGFyZW50XS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbm9kZS5wYXRoID0gcGF0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBHcmFwaEluc3RhbmNlfSBmb3IgdGhlIGdpdmVuIHNjZW5lIG5hbWUgb3IgdGhlIGRlZmF1bHQgc2NlbmUgaWYgbm8gbmFtZSBpcyBnaXZlbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2NlbmUoX25hbWU/OiBzdHJpbmcpOiBQcm9taXNlPEdyYXBoPiB7XG4gICAgICBjb25zdCBpU2NlbmU6IG51bWJlciA9IF9uYW1lID8gdGhpcy5nbHRmLnNjZW5lcy5maW5kSW5kZXgoX3NjZW5lID0+IF9zY2VuZS5uYW1lID09IF9uYW1lKSA6IHRoaXMuZ2x0Zi5zY2VuZTtcbiAgICAgIGlmIChpU2NlbmUgPT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBuYW1lICcke19uYW1lfScgaW4gZ2x0ZiBzY2VuZXMuYCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRTY2VuZUJ5SW5kZXgoaVNjZW5lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIEdyYXBoSW5zdGFuY2V9IGZvciB0aGUgZ2l2ZW4gc2NlbmUgaW5kZXggb3IgdGhlIGRlZmF1bHQgc2NlbmUgaWYgbm8gaW5kZXggaXMgZ2l2ZW4uXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFNjZW5lQnlJbmRleChfaVNjZW5lOiBudW1iZXIgPSB0aGlzLmdsdGYuc2NlbmUpOiBQcm9taXNlPEdyYXBoPiB7XG4gICAgICBpZiAoIXRoaXMuI3NjZW5lcylcbiAgICAgICAgdGhpcy4jc2NlbmVzID0gW107XG4gICAgICBpZiAoIXRoaXMuI3NjZW5lc1tfaVNjZW5lXSkge1xuICAgICAgICBjb25zdCBnbHRmU2NlbmU6IEdMVEYuU2NlbmUgPSB0aGlzLmdsdGYuc2NlbmVzW19pU2NlbmVdO1xuICAgICAgICBjb25zdCBzY2VuZTogR3JhcGggPSBuZXcgR3JhcGgoZ2x0ZlNjZW5lLm5hbWUpO1xuXG4gICAgICAgIGZvciAoY29uc3QgaU5vZGUgb2YgZ2x0ZlNjZW5lLm5vZGVzKVxuICAgICAgICAgIHNjZW5lLmFkZENoaWxkKGF3YWl0IHRoaXMuZ2V0Tm9kZUJ5SW5kZXgoaU5vZGUpKTtcblxuICAgICAgICBpZiAodGhpcy5nbHRmLmFuaW1hdGlvbnM/Lmxlbmd0aCA+IDApXG4gICAgICAgICAgc2NlbmUuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnRBbmltYXRvcihhd2FpdCB0aGlzLmdldEFuaW1hdGlvbkJ5SW5kZXgoMCkpKTtcbiAgICAgICAgLy8gVE9ETzogbG9hZCBhbGwgYW5pbWF0aW9ucywgbm90IGp1c3QgdGhlIGZpcnN0IG9uZVxuXG4gICAgICAgIC8vIFRPRE86IGxvYWQgb25seSBza2VsZXRvbnMgd2hpY2ggYmVsb25nIHRvIHRoZSBzY2VuZT8/P1xuICAgICAgICAvLyBpZiAodGhpcy5nbHRmLnNraW5zPy5sZW5ndGggPiAwKVxuICAgICAgICAvLyAgIGZvciAobGV0IGlTa2luOiBudW1iZXIgPSAwOyBpU2tpbiA8IHRoaXMuZ2x0Zi5za2lucy5sZW5ndGg7IGlTa2luKyspXG4gICAgICAgIC8vICAgICBzY2VuZS5hZGRDb21wb25lbnQoYXdhaXQgdGhpcy5nZXRTa2VsZXRvbkJ5SW5kZXgoaVNraW4pKTtcbiAgICAgICAgZm9yIChjb25zdCBza2VsZXRvbiBvZiB0aGlzLiNza2VsZXRvbnMpIFxuICAgICAgICAgIHNjZW5lLmFkZENvbXBvbmVudChza2VsZXRvbik7XG5cbiAgICAgICAgUHJvamVjdC5yZWdpc3RlcihzY2VuZSk7XG4gICAgICAgIHRoaXMuI3NjZW5lc1tfaVNjZW5lXSA9IHNjZW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3NjZW5lc1tfaVNjZW5lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB7QGxpbmsgTm9kZX0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0Tm9kZShfbmFtZTogc3RyaW5nKTogUHJvbWlzZTxOb2RlPiB7XG4gICAgICBjb25zdCBpTm9kZTogbnVtYmVyID0gdGhpcy5nbHRmLm5vZGVzLmZpbmRJbmRleChfbm9kZSA9PiBfbm9kZS5uYW1lID09IF9uYW1lKTtcbiAgICAgIGlmIChpTm9kZSA9PSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIG5hbWUgJyR7X25hbWV9JyBpbiBnbHRmIG5vZGVzLmApO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Tm9kZUJ5SW5kZXgoaU5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBOb2RlfSBmb3IgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXROb2RlQnlJbmRleChfaU5vZGU6IG51bWJlcik6IFByb21pc2U8Tm9kZT4ge1xuICAgICAgaWYgKCF0aGlzLiNub2Rlc1tfaU5vZGVdKSB7XG4gICAgICAgIGNvbnN0IGdsdGZOb2RlOiBHTFRGLk5vZGUgPSB0aGlzLmdsdGYubm9kZXNbX2lOb2RlXTtcbiAgICAgICAgY29uc3Qgbm9kZTogTm9kZSA9IG5ldyBOb2RlKGdsdGZOb2RlLm5hbWUpO1xuXG4gICAgICAgIHRoaXMuI25vZGVzW19pTm9kZV0gPSBub2RlO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBjaGlsZHJlblxuICAgICAgICBpZiAoZ2x0Zk5vZGUuY2hpbGRyZW4pXG4gICAgICAgICAgZm9yIChjb25zdCBpTm9kZSBvZiBnbHRmTm9kZS5jaGlsZHJlbilcbiAgICAgICAgICAgIG5vZGUuYWRkQ2hpbGQoYXdhaXQgdGhpcy5nZXROb2RlQnlJbmRleChpTm9kZSkpO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciB0cmFuc2Zvcm1hdGlvblxuICAgICAgICBpZiAoZ2x0Zk5vZGUubWF0cml4IHx8IGdsdGZOb2RlLnJvdGF0aW9uIHx8IGdsdGZOb2RlLnNjYWxlIHx8IGdsdGZOb2RlLnRyYW5zbGF0aW9uIHx8IGdsdGZOb2RlLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50VHJhbnNmb3JtKCkpO1xuICAgICAgICAgIGlmIChnbHRmTm9kZS5tYXRyaXgpIHtcbiAgICAgICAgICAgIG5vZGUubXR4TG9jYWwuc2V0KEZsb2F0MzJBcnJheS5mcm9tKGdsdGZOb2RlLm1hdHJpeCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZ2x0Zk5vZGUudHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XG4gICAgICAgICAgICAgIHRyYW5zbGF0aW9uLnNldChnbHRmTm9kZS50cmFuc2xhdGlvblswXSwgZ2x0Zk5vZGUudHJhbnNsYXRpb25bMV0sIGdsdGZOb2RlLnRyYW5zbGF0aW9uWzJdKTtcbiAgICAgICAgICAgICAgbm9kZS5tdHhMb2NhbC50cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2x0Zk5vZGUucm90YXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc3Qgcm90YXRpb246IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XG4gICAgICAgICAgICAgIHJvdGF0aW9uLnNldChnbHRmTm9kZS5yb3RhdGlvblswXSwgZ2x0Zk5vZGUucm90YXRpb25bMV0sIGdsdGZOb2RlLnJvdGF0aW9uWzJdLCBnbHRmTm9kZS5yb3RhdGlvblszXSk7XG4gICAgICAgICAgICAgIG5vZGUubXR4TG9jYWwucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgICAgICAgUmVjeWNsZXIuc3RvcmUocm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdsdGZOb2RlLnNjYWxlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjYWxlOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xuICAgICAgICAgICAgICBzY2FsZS5zZXQoZ2x0Zk5vZGUuc2NhbGVbMF0sIGdsdGZOb2RlLnNjYWxlWzFdLCBnbHRmTm9kZS5zY2FsZVsyXSk7XG4gICAgICAgICAgICAgIG5vZGUubXR4TG9jYWwuc2NhbGluZyA9IHNjYWxlO1xuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGNhbWVyYVxuICAgICAgICBpZiAoZ2x0Zk5vZGUuY2FtZXJhICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUuYWRkQ29tcG9uZW50KGF3YWl0IHRoaXMuZ2V0Q2FtZXJhQnlJbmRleChnbHRmTm9kZS5jYW1lcmEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtZXNoIGFuZCBtYXRlcmlhbFxuICAgICAgICBpZiAoZ2x0Zk5vZGUubWVzaCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBnbHRmTWVzaDogR0xURi5NZXNoID0gdGhpcy5nbHRmLm1lc2hlcz8uW2dsdGZOb2RlLm1lc2hdO1xuICAgICAgICAgIC8vIFRPRE86IHJldmlldyB0aGlzXG4gICAgICAgICAgY29uc3Qgc3ViQ29tcG9uZW50czogW0NvbXBvbmVudE1lc2gsIENvbXBvbmVudE1hdGVyaWFsXVtdID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaVByaW1pdGl2ZTogbnVtYmVyID0gMDsgaVByaW1pdGl2ZSA8IGdsdGZNZXNoLnByaW1pdGl2ZXMubGVuZ3RoOyBpUHJpbWl0aXZlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBuZXcgQ29tcG9uZW50TWVzaChhd2FpdCB0aGlzLmdldE1lc2hCeUluZGV4KGdsdGZOb2RlLm1lc2gsIGlQcmltaXRpdmUpKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNrZWxldG9uXG4gICAgICAgICAgICBpZiAoZ2x0Zk5vZGUuc2tpbiAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGNtcE1lc2guc2tlbGV0b24gPSBhd2FpdCB0aGlzLmdldFNrZWxldG9uQnlJbmRleChnbHRmTm9kZS5za2luKTtcblxuICAgICAgICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbDtcbiAgICAgICAgICAgIGNvbnN0IGlNYXRlcmlhbDogbnVtYmVyID0gZ2x0Zk1lc2gucHJpbWl0aXZlcz8uW2lQcmltaXRpdmVdPy5tYXRlcmlhbDtcbiAgICAgICAgICAgIGlmIChpTWF0ZXJpYWwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNtcE1hdGVyaWFsID0gbmV3IENvbXBvbmVudE1hdGVyaWFsKGNtcE1lc2gubWVzaCBpbnN0YW5jZW9mIE1lc2hTa2luID9cbiAgICAgICAgICAgICAgICBHTFRGTG9hZGVyLmRlZmF1bHRTa2luTWF0ZXJpYWwgOlxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXIuZGVmYXVsdE1hdGVyaWFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNtcE1hdGVyaWFsID0gbmV3IENvbXBvbmVudE1hdGVyaWFsKGF3YWl0IHRoaXMuZ2V0TWF0ZXJpYWxCeUluZGV4KGlNYXRlcmlhbCwgY21wTWVzaC5tZXNoIGluc3RhbmNlb2YgTWVzaFNraW4pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3ViQ29tcG9uZW50cy5wdXNoKFtjbXBNZXNoLCBjbXBNYXRlcmlhbF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdWJDb21wb25lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChzdWJDb21wb25lbnRzWzBdWzBdKTtcbiAgICAgICAgICAgIG5vZGUuYWRkQ29tcG9uZW50KHN1YkNvbXBvbmVudHNbMF1bMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJDb21wb25lbnRzLmZvckVhY2goKFtfY21wTWVzaCwgX2NtcE1hdGVyaWFsXSwgX2kpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZVBhcnQ6IE5vZGUgPSBuZXcgTm9kZShub2RlLm5hbWUgKyBcIl9wcmltaXRpdmVcIiArIF9pKTtcbiAgICAgICAgICAgICAgbm9kZVBhcnQuYWRkQ29tcG9uZW50KF9jbXBNZXNoKTtcbiAgICAgICAgICAgICAgbm9kZVBhcnQuYWRkQ29tcG9uZW50KF9jbXBNYXRlcmlhbCk7XG4gICAgICAgICAgICAgIG5vZGUuYWRkQ2hpbGQobm9kZVBhcnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiNub2Rlc1tfaU5vZGVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IHtAbGluayBDb21wb25lbnRDYW1lcmF9IHdpdGggdGhlIGdpdmVuIGNhbWVyYSBuYW1lLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRDYW1lcmEoX25hbWU6IHN0cmluZyk6IFByb21pc2U8Q29tcG9uZW50Q2FtZXJhPiB7XG4gICAgICBjb25zdCBpQ2FtZXJhOiBudW1iZXIgPSB0aGlzLmdsdGYuY2FtZXJhcy5maW5kSW5kZXgoX2NhbWVyYSA9PiBfY2FtZXJhLm5hbWUgPT0gX25hbWUpO1xuICAgICAgaWYgKGlDYW1lcmEgPT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBuYW1lICcke19uYW1lfScgaW4gZ2x0ZiBjYW1lcmFzLmApO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Q2FtZXJhQnlJbmRleChpQ2FtZXJhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgQ29tcG9uZW50Q2FtZXJhfSBmb3IgdGhlIGdpdmVuIGNhbWVyYSBpbmRleC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0Q2FtZXJhQnlJbmRleChfaUNhbWVyYTogbnVtYmVyKTogUHJvbWlzZTxDb21wb25lbnRDYW1lcmE+IHtcbiAgICAgIGlmICghdGhpcy4jY2FtZXJhcylcbiAgICAgICAgdGhpcy4jY2FtZXJhcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLiNjYW1lcmFzW19pQ2FtZXJhXSkge1xuICAgICAgICBjb25zdCBnbHRmQ2FtZXJhOiBHTFRGLkNhbWVyYSA9IHRoaXMuZ2x0Zi5jYW1lcmFzW19pQ2FtZXJhXTtcbiAgICAgICAgY29uc3QgY2FtZXJhOiBDb21wb25lbnRDYW1lcmEgPSBuZXcgQ29tcG9uZW50Q2FtZXJhKCk7XG5cbiAgICAgICAgaWYgKGdsdGZDYW1lcmEucGVyc3BlY3RpdmUpXG4gICAgICAgICAgY2FtZXJhLnByb2plY3RDZW50cmFsKFxuICAgICAgICAgICAgZ2x0ZkNhbWVyYS5wZXJzcGVjdGl2ZS5hc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIGdsdGZDYW1lcmEucGVyc3BlY3RpdmUueWZvdiAqIENhbGMucmFkMmRlZyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBnbHRmQ2FtZXJhLnBlcnNwZWN0aXZlLnpuZWFyLFxuICAgICAgICAgICAgZ2x0ZkNhbWVyYS5wZXJzcGVjdGl2ZS56ZmFyXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNhbWVyYS5wcm9qZWN0T3J0aG9ncmFwaGljKFxuICAgICAgICAgICAgLWdsdGZDYW1lcmEub3J0aG9ncmFwaGljLnhtYWcsXG4gICAgICAgICAgICBnbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy54bWFnLFxuICAgICAgICAgICAgLWdsdGZDYW1lcmEub3J0aG9ncmFwaGljLnltYWcsXG4gICAgICAgICAgICBnbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy55bWFnXG4gICAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gY2FtZXJhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2NhbWVyYXNbX2lDYW1lcmFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IHtAbGluayBBbmltYXRpb259IHdpdGggdGhlIGdpdmVuIGFuaW1hdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRBbmltYXRpb24oX25hbWU6IHN0cmluZyk6IFByb21pc2U8QW5pbWF0aW9uPiB7XG4gICAgICBjb25zdCBpQW5pbWF0aW9uOiBudW1iZXIgPSB0aGlzLmdsdGYuYW5pbWF0aW9ucy5maW5kSW5kZXgoX2FuaW1hdGlvbiA9PiBfYW5pbWF0aW9uLm5hbWUgPT0gX25hbWUpO1xuICAgICAgaWYgKGlBbmltYXRpb24gPT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBuYW1lICcke19uYW1lfScgaW4gZ2x0ZiBhbmltYXRpb25zLmApO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QW5pbWF0aW9uQnlJbmRleChpQW5pbWF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgQW5pbWF0aW9ufSBmb3IgdGhlIGdpdmVuIGFuaW1hdGlvbiBpbmRleC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0QW5pbWF0aW9uQnlJbmRleChfaUFuaW1hdGlvbjogbnVtYmVyKTogUHJvbWlzZTxBbmltYXRpb24+IHtcbiAgICAgIGlmICghdGhpcy4jYW5pbWF0aW9ucylcbiAgICAgICAgdGhpcy4jYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLiNhbmltYXRpb25zW19pQW5pbWF0aW9uXSkge1xuICAgICAgICBjb25zdCBnbHRmQW5pbWF0aW9uOiBHTFRGLkFuaW1hdGlvbiA9IHRoaXMuZ2x0Zi5hbmltYXRpb25zPy5bX2lBbmltYXRpb25dO1xuXG4gICAgICAgIGlmICghZ2x0ZkFuaW1hdGlvbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IENvdWxkbid0IGZpbmQgYW5pbWF0aW9uIHdpdGggaW5kZXggJHtfaUFuaW1hdGlvbn0uYCk7XG5cbiAgICAgICAgLy8gZ3JvdXAgY2hhbm5lbHMgYnkgbm9kZVxuICAgICAgICBsZXQgZ2x0ZkNoYW5uZWxzR3JvdXBlZDogR0xURi5BbmltYXRpb25DaGFubmVsW11bXSA9IFtdOyAvLyBUT0RPOiBtYXliZSBjaGFuZ2UgdGhpcyB0byBtYXAgb3IganMgb2JqZWN0XG4gICAgICAgIGZvciAoY29uc3QgZ2x0ZkNoYW5uZWwgb2YgZ2x0ZkFuaW1hdGlvbi5jaGFubmVscykge1xuICAgICAgICAgIGNvbnN0IGlOb2RlOiBudW1iZXIgPSBnbHRmQ2hhbm5lbC50YXJnZXQubm9kZTtcbiAgICAgICAgICBpZiAoaU5vZGUgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKCFnbHRmQ2hhbm5lbHNHcm91cGVkW2lOb2RlXSlcbiAgICAgICAgICAgIGdsdGZDaGFubmVsc0dyb3VwZWRbaU5vZGVdID0gW107XG4gICAgICAgICAgZ2x0ZkNoYW5uZWxzR3JvdXBlZFtpTm9kZV0ucHVzaChnbHRmQ2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IGVudHJpZXNcbiAgICAgICAgZ2x0ZkNoYW5uZWxzR3JvdXBlZCA9IGdsdGZDaGFubmVsc0dyb3VwZWQuZmlsdGVyKF9jaGFubmVscyA9PiBfY2hhbm5lbHMgIT0gdW5kZWZpbmVkKTtcblxuICAgICAgICBjb25zdCBhbmltYXRpb25TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGdsdGZDaGFubmVscyBvZiBnbHRmQ2hhbm5lbHNHcm91cGVkKSB7XG4gICAgICAgICAgY29uc3QgZ2x0Zk5vZGU6IEdMVEYuTm9kZSA9IHRoaXMuZ2x0Zi5ub2Rlc1tnbHRmQ2hhbm5lbHNbMF0udGFyZ2V0Lm5vZGVdO1xuXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IGFuaW1hdGlvblN0cnVjdHVyZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlQYXRoTm9kZSBvZiBnbHRmTm9kZS5wYXRoLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0aE5vZGU6IEdMVEYuTm9kZSA9IHRoaXMuZ2x0Zi5ub2Rlc1tpUGF0aE5vZGVdO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0cnVjdHVyZS5jaGlsZHJlbiA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gPSB7fTtcblxuICAgICAgICAgICAgaWYgKChjdXJyZW50U3RydWN0dXJlLmNoaWxkcmVuIGFzIEFuaW1hdGlvblN0cnVjdHVyZSlbcGF0aE5vZGUubmFtZV0gPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAoY3VycmVudFN0cnVjdHVyZS5jaGlsZHJlbiBhcyBBbmltYXRpb25TdHJ1Y3R1cmUpW3BhdGhOb2RlLm5hbWVdID0ge307XG4gICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlID0gKGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gYXMgQW5pbWF0aW9uU3RydWN0dXJlKVtwYXRoTm9kZS5uYW1lXSBhcyBBbmltYXRpb25TdHJ1Y3R1cmU7XG5cbiAgICAgICAgICAgIGlmIChwYXRoTm9kZSA9PSBnbHRmTm9kZSkge1xuICAgICAgICAgICAgICBjb25zdCBtdHhMb2NhbDogQW5pbWF0aW9uU2VxdWVuY2VNYXRyaXg0eDQgPSB7fTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBnbHRmQ2hhbm5lbCBvZiBnbHRmQ2hhbm5lbHMpXG4gICAgICAgICAgICAgICAgbXR4TG9jYWxbdG9JbnRlcm5UcmFuc2Zvcm1hdGlvbltnbHRmQ2hhbm5lbC50YXJnZXQucGF0aF1dID1cbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0QW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IoZ2x0ZkFuaW1hdGlvbi5zYW1wbGVyc1tnbHRmQ2hhbm5lbC5zYW1wbGVyXSwgZ2x0ZkNoYW5uZWwudGFyZ2V0LnBhdGgpO1xuICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLmNvbXBvbmVudHMgPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50VHJhbnNmb3JtOiBbXG4gICAgICAgICAgICAgICAgICB7IG10eExvY2FsOiBtdHhMb2NhbCB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI2FuaW1hdGlvbnNbX2lBbmltYXRpb25dID0gbmV3IEFuaW1hdGlvbihnbHRmQW5pbWF0aW9uLm5hbWUsIGFuaW1hdGlvblN0cnVjdHVyZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jYW5pbWF0aW9uc1tfaUFuaW1hdGlvbl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3Qge0BsaW5rIE1lc2hJbXBvcnR9IHdpdGggdGhlIGdpdmVuIG1lc2ggbmFtZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWVzaChfbmFtZTogc3RyaW5nKTogUHJvbWlzZTxNZXNoSW1wb3J0PiB7XG4gICAgICBjb25zdCBpTWVzaDogbnVtYmVyID0gdGhpcy5nbHRmLm1lc2hlcy5maW5kSW5kZXgoX21lc2ggPT4gX21lc2gubmFtZSA9PSBfbmFtZSk7XG4gICAgICBpZiAoaU1lc2ggPT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBuYW1lICcke19uYW1lfScgaW4gZ2x0ZiBtZXNoZXMuYCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRNZXNoQnlJbmRleChpTWVzaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIE1lc2hJbXBvcnR9IGZvciB0aGUgZ2l2ZW4gbWVzaCBpbmRleC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWVzaEJ5SW5kZXgoX2lNZXNoOiBudW1iZXIsIF9pUHJpbWl0aXZlOiBudW1iZXIgPSAwKTogUHJvbWlzZTxNZXNoSW1wb3J0PiB7XG4gICAgICBpZiAoIXRoaXMuI21lc2hlcylcbiAgICAgICAgdGhpcy4jbWVzaGVzID0gW107XG4gICAgICBpZiAoIXRoaXMuI21lc2hlc1tfaU1lc2hdKVxuICAgICAgICB0aGlzLiNtZXNoZXNbX2lNZXNoXSA9IFtdO1xuXG4gICAgICBpZiAoIXRoaXMuI21lc2hlc1tfaU1lc2hdW19pUHJpbWl0aXZlXSkge1xuICAgICAgICBjb25zdCBnbHRmTWVzaDogR0xURi5NZXNoID0gdGhpcy5nbHRmLm1lc2hlc1tfaU1lc2hdO1xuXG4gICAgICAgIHRoaXMuI21lc2hlc1tfaU1lc2hdW19pUHJpbWl0aXZlXSA9IGF3YWl0IChcbiAgICAgICAgICBnbHRmTWVzaC5wcmltaXRpdmVzW19pUHJpbWl0aXZlXS5hdHRyaWJ1dGVzLkpPSU5UU18wICE9IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBuZXcgTWVzaFNraW4oKSA6XG4gICAgICAgICAgICBuZXcgTWVzaEltcG9ydCgpXG4gICAgICAgICkubG9hZChNZXNoTG9hZGVyR0xURiwgdGhpcy51cmwsIHsgaU1lc2g6IF9pTWVzaCwgaVByaW1pdGl2ZTogX2lQcmltaXRpdmUgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiNtZXNoZXNbX2lNZXNoXVtfaVByaW1pdGl2ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIE1hdGVyaWFsfSBmb3IgdGhlIGdpdmVuIG1hdGVyaWFsIGluZGV4LlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRNYXRlcmlhbEJ5SW5kZXgoX2lNYXRlcmlhbDogbnVtYmVyLCBfc2tpbjogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxNYXRlcmlhbD4ge1xuICAgICAgaWYgKCF0aGlzLiNtYXRlcmlhbHMpXG4gICAgICAgIHRoaXMuI21hdGVyaWFscyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLiNtYXRlcmlhbHNbX2lNYXRlcmlhbF0pIHtcbiAgICAgICAgLy8gVE9ETzogaW4gdGhlIGZ1dHVyZSBjcmVhdGUgYW4gYXBwcm9wcmlhdGUgc2hhZGVyIGJhc2VkIG9uIHRoZSBnbHRmIG1hdGVyaWFsIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgZ2x0Zk1hdGVyaWFsOiBHTFRGLk1hdGVyaWFsID0gdGhpcy5nbHRmLm1hdGVyaWFsc1tfaU1hdGVyaWFsXTtcblxuICAgICAgICBpZiAoIWdsdGZNYXRlcmlhbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IENvdWxkbid0IGZpbmQgbWF0ZXJpYWwgd2l0aCBpbmRleCAke19pTWF0ZXJpYWx9LmApO1xuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBvdGhlciBnbHRmIG1hdGVyaWFsIHByb3BlcnRpZXM6IGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvZ2xURi9zcGVjcy8yLjAvZ2xURi0yLjAuaHRtbCNyZWZlcmVuY2UtbWF0ZXJpYWxcbiAgICAgICAgLy8gZS5nLiBub3JtYWwsIG9jY2x1c2lvbiBhbmQgZW1pc3NpdmUgdGV4dHVyZXM7IGFscGhhTW9kZTsgYWxwaGFDdXRvZmY7IGRvdWJsZVNpZGVkXG4gICAgICAgIGNvbnN0IGdsdGZCYXNlQ29sb3JUZXh0dXJlOiBHTFRGLlRleHR1cmVJbmZvID0gZ2x0Zk1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzPy5iYXNlQ29sb3JUZXh0dXJlO1xuXG4gICAgICAgIGNvbnN0IGNvbG9yOiBDb2xvciA9IG5ldyBDb2xvciguLi5nbHRmTWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3M/LmJhc2VDb2xvckZhY3RvciB8fCBbMSwgMSwgMSwgMV0pO1xuICAgICAgICBjb25zdCBjb2F0OiBDb2F0ID0gZ2x0ZkJhc2VDb2xvclRleHR1cmUgP1xuICAgICAgICAgIG5ldyBDb2F0UmVtaXNzaXZlVGV4dHVyZWQoY29sb3IsIGF3YWl0IHRoaXMuZ2V0VGV4dHVyZUJ5SW5kZXgoZ2x0ZkJhc2VDb2xvclRleHR1cmUuaW5kZXgpLCAxLCAxKSA6XG4gICAgICAgICAgbmV3IENvYXRSZW1pc3NpdmUoY29sb3IsIDEsIDAuNSk7XG5cbiAgICAgICAgY29uc3QgbWF0ZXJpYWw6IE1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKFxuICAgICAgICAgIGdsdGZNYXRlcmlhbC5uYW1lLFxuICAgICAgICAgIGdsdGZCYXNlQ29sb3JUZXh0dXJlID9cbiAgICAgICAgICAgIChfc2tpbiA/IFNoYWRlclBob25nVGV4dHVyZWRTa2luIDogU2hhZGVyUGhvbmdUZXh0dXJlZCkgOlxuICAgICAgICAgICAgKF9za2luID8gU2hhZGVyUGhvbmdTa2luIDogU2hhZGVyUGhvbmcpLFxuICAgICAgICAgIGNvYXQpO1xuXG4gICAgICAgIHRoaXMuI21hdGVyaWFsc1tfaU1hdGVyaWFsXSA9IG1hdGVyaWFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy4jbWF0ZXJpYWxzW19pTWF0ZXJpYWxdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBUZXh0dXJlfSBmb3IgdGhlIGdpdmVuIHRleHR1cmUgaW5kZXguXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFRleHR1cmVCeUluZGV4KF9pVGV4dHVyZTogbnVtYmVyKTogUHJvbWlzZTxUZXh0dXJlPiB7XG4gICAgICBpZiAoIXRoaXMuI3RleHR1cmVzKVxuICAgICAgICB0aGlzLiN0ZXh0dXJlcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLiN0ZXh0dXJlc1tfaVRleHR1cmVdKSB7XG4gICAgICAgIGNvbnN0IGdsdGZUZXh0dXJlOiBHTFRGLlRleHR1cmUgPSB0aGlzLmdsdGYudGV4dHVyZXNbX2lUZXh0dXJlXTtcbiAgICAgICAgY29uc3QgZ2x0ZlNhbXBsZXI6IEdMVEYuU2FtcGxlciA9IHRoaXMuZ2x0Zi5zYW1wbGVycz8uW2dsdGZUZXh0dXJlLnNhbXBsZXJdO1xuICAgICAgICBjb25zdCBnbHRmSW1hZ2U6IEdMVEYuSW1hZ2UgPSB0aGlzLmdsdGYuaW1hZ2VzPy5bZ2x0ZlRleHR1cmUuc291cmNlXTtcblxuICAgICAgICBpZiAoZ2x0ZkltYWdlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IFRleHR1cmUgd2l0aCBpbmRleCAke19pVGV4dHVyZX0gaGFzIG5vIGltYWdlLmApO1xuICAgICAgICAgIHJldHVybiBUZXh0dXJlRGVmYXVsdC50ZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsdGZTYW1wbGVyPy53cmFwUyAhPSB1bmRlZmluZWQgJiYgZ2x0ZlNhbXBsZXI/LndyYXBTICE9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkVQRUFUKVxuICAgICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IFRleHR1cmUgd2l0aCBpbmRleCAke19pVGV4dHVyZX0gaGFzIGEgd3JhcFMgb2YgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLndyYXBTKX0nLiBGVURHRSBvbmx5IHN1cHBvcnRzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mICcke2dldFdlYkdMUGFyYW1ldGVyTmFtZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJFUEVBVCl9Jy5gKTtcbiAgICAgICAgaWYgKGdsdGZTYW1wbGVyPy53cmFwVCAhPSB1bmRlZmluZWQgJiYgZ2x0ZlNhbXBsZXI/LndyYXBUICE9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkVQRUFUKVxuICAgICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IFRleHR1cmUgd2l0aCBpbmRleCAke19pVGV4dHVyZX0gaGFzIGEgd3JhcFQgb2YgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLndyYXBUKX0nLiBGVURHRSBvbmx5IHN1cHBvcnRzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mICcke2dldFdlYkdMUGFyYW1ldGVyTmFtZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJFUEVBVCl9Jy5gKTtcblxuICAgICAgICBsZXQgdXJsOiBzdHJpbmcgPSBuZXcgVVJMKGdsdGZJbWFnZS51cmksIHRoaXMudXJsKS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICghZ2x0ZkltYWdlLnVyaSAmJiBnbHRmSW1hZ2UuYnVmZmVyVmlldykge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgZHVwbGljYXRlIGNvZGUgZnJvbSBnZXRCdWZmZXJEYXRhLCBtYXliZSByZWZhY3RvciBnZXRCdWZmZXJEYXRhIHRvIGhhbmRsZSBidWZmZXJWaWV3SW5kZXggaW5wdXRcbiAgICAgICAgICBjb25zdCBnbHRmQnVmZmVyVmlldzogR0xURi5CdWZmZXJWaWV3ID0gdGhpcy5nbHRmLmJ1ZmZlclZpZXdzW2dsdGZJbWFnZS5idWZmZXJWaWV3XTtcblxuICAgICAgICAgIGNvbnN0IGJ1ZmZlcjogQXJyYXlCdWZmZXIgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlcihnbHRmQnVmZmVyVmlldy5idWZmZXIpO1xuICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQ6IG51bWJlciA9IGdsdGZCdWZmZXJWaWV3LmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoOiBudW1iZXIgPSBnbHRmQnVmZmVyVmlldy5ieXRlTGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgICB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFxuICAgICAgICAgICAgW25ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCAvIFVpbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQpXSxcbiAgICAgICAgICAgIHsgdHlwZTogZ2x0ZkltYWdlLm1pbWVUeXBlIH1cbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG5ldyBUZXh0dXJlSW1hZ2UoKTtcbiAgICAgICAgYXdhaXQgdGV4dHVyZS5sb2FkKHVybCk7XG4gICAgICAgIGlmIChnbHRmU2FtcGxlciAmJiBnbHRmU2FtcGxlci5tYWdGaWx0ZXIgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUICYmIGdsdGZTYW1wbGVyLm1pbkZpbHRlciA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpXG4gICAgICAgICAgdGV4dHVyZS5taXBtYXAgPSBNSVBNQVAuQ1JJU1A7XG4gICAgICAgIGVsc2UgaWYgKGdsdGZTYW1wbGVyICYmIGdsdGZTYW1wbGVyLm1hZ0ZpbHRlciA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QgJiYgZ2x0ZlNhbXBsZXIubWluRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVF9NSVBNQVBfTElORUFSKVxuICAgICAgICAgIHRleHR1cmUubWlwbWFwID0gTUlQTUFQLk1FRElVTTtcbiAgICAgICAgZWxzZSBpZiAoZ2x0ZlNhbXBsZXIgJiYgZ2x0ZlNhbXBsZXIubWFnRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSICYmIGdsdGZTYW1wbGVyLm1pbkZpbHRlciA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUl9NSVBNQVBfTElORUFSKVxuICAgICAgICAgIHRleHR1cmUubWlwbWFwID0gTUlQTUFQLkJMVVJSWTtcbiAgICAgICAgZWxzZSBpZiAoZ2x0ZlNhbXBsZXIgJiYgKGdsdGZTYW1wbGVyLm1hZ0ZpbHRlciAhPSB1bmRlZmluZWQgfHwgZ2x0ZlNhbXBsZXIubWluRmlsdGVyICE9IHVuZGVmaW5lZCkpXG4gICAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogVGV4dHVyZSB3aXRoIGluZGV4ICR7X2lUZXh0dXJlfSBoYXMgYSBtYWdGaWx0ZXIgYW5kIG1pbkZpbHRlciBvZiAnJHtnZXRXZWJHTFBhcmFtZXRlck5hbWUoZ2x0ZlNhbXBsZXIubWFnRmlsdGVyKX0nIGFuZCAnJHtnZXRXZWJHTFBhcmFtZXRlck5hbWUoZ2x0ZlNhbXBsZXIubWluRmlsdGVyKX0nIHJlc3BlY3RpdmVseS4gRlVER0Ugb25seSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIGNvbWJpbmF0aW9uczogTkVBUkVTVCBhbmQgTkVBUkVTVCB8IE5FQVJFU1QgYW5kIE5FQVJFU1RfTUlQTUFQX0xJTkVBUiB8IExJTkVBUiBhbmQgTElORUFSX01JUE1BUF9MSU5FQVIuYCk7XG5cbiAgICAgICAgdGhpcy4jdGV4dHVyZXNbX2lUZXh0dXJlXSA9IHRleHR1cmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiN0ZXh0dXJlc1tfaVRleHR1cmVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZmlyc3Qge0BsaW5rIENvbXBvbmVudFNrZWxldG9ufSB3aXRoIHRoZSBnaXZlbiBza2VsZXRvbiBuYW1lLlxuICAgICovXG4gICAgcHVibGljIGFzeW5jIGdldFNrZWxldG9uKF9uYW1lOiBzdHJpbmcpOiBQcm9taXNlPENvbXBvbmVudFNrZWxldG9uPiB7XG4gICAgICBjb25zdCBpU2tlbGV0b246IG51bWJlciA9IHRoaXMuZ2x0Zi5za2lucy5maW5kSW5kZXgoX3NrZWxldG9uID0+IF9za2VsZXRvbi5uYW1lID09IF9uYW1lKTtcbiAgICAgIGlmIChpU2tlbGV0b24gPT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBuYW1lICcke19uYW1lfScgaW4gZ2x0ZiBza2lucy5gKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFNrZWxldG9uQnlJbmRleChpU2tlbGV0b24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBDb21wb25lbnRTa2VsZXRvbn0gZm9yIHRoZSBnaXZlbiBza2VsZXRvbiBpbmRleC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2tlbGV0b25CeUluZGV4KF9pU2tlbGV0b246IG51bWJlcik6IFByb21pc2U8Q29tcG9uZW50U2tlbGV0b24+IHtcbiAgICAgIGlmICghdGhpcy4jc2tlbGV0b25zKVxuICAgICAgICB0aGlzLiNza2VsZXRvbnMgPSBbXTtcbiAgICAgIGlmICghdGhpcy4jc2tlbGV0b25zW19pU2tlbGV0b25dKSB7XG4gICAgICAgIGNvbnN0IGdsdGZTa2luOiBHTFRGLlNraW4gPSB0aGlzLmdsdGYuc2tpbnNbX2lTa2VsZXRvbl07XG4gICAgICAgIGNvbnN0IGJvbmVzOiBOb2RlW10gPSBbXTtcblxuICAgICAgICAvLyBjb252ZXJ0IGZsb2F0IGFycmF5IHRvIGFycmF5IG9mIG1hdHJpY2VzIGFuZCByZWdpc3RlciBib25lc1xuICAgICAgICBsZXQgbXR4RGF0YTogRmxvYXQzMkFycmF5O1xuICAgICAgICBpZiAoZ2x0ZlNraW4uaW52ZXJzZUJpbmRNYXRyaWNlcyAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgbXR4RGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmxvYXQzMkFycmF5KGdsdGZTa2luLmludmVyc2VCaW5kTWF0cmljZXMpO1xuICAgICAgICBjb25zdCBtdHhEYXRhU3BhbjogbnVtYmVyID0gMTY7IC8vIHNpemUgb2YgbWF0cml4XG5cbiAgICAgICAgY29uc3QgbXR4QmluZEludmVyc2VzOiBNYXRyaXg0eDRbXSA9IFtdO1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgam9pbnRzIGFuZCBnZXQgY29ycmVzcG9uZGluZyBtYXRyaXggZnJvbSBmbG9hdCBhcnJheVxuICAgICAgICBmb3IgKGxldCBpQm9uZTogbnVtYmVyID0gMDsgaUJvbmUgPCBnbHRmU2tpbi5qb2ludHMubGVuZ3RoOyBpQm9uZSsrKSB7XG4gICAgICAgICAgbGV0IG10eEJpbmRJbnZlcnNlOiBNYXRyaXg0eDQ7XG4gICAgICAgICAgaWYgKG10eERhdGEpIHtcbiAgICAgICAgICAgIG10eEJpbmRJbnZlcnNlID0gbmV3IE1hdHJpeDR4NCgpO1xuICAgICAgICAgICAgbXR4QmluZEludmVyc2Uuc2V0KG10eERhdGEuc3ViYXJyYXkoaUJvbmUgKiBtdHhEYXRhU3BhbiwgaUJvbmUgKiBtdHhEYXRhU3BhbiArIG10eERhdGFTcGFuKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm9uZXMucHVzaChhd2FpdCB0aGlzLmdldE5vZGVCeUluZGV4KGdsdGZTa2luLmpvaW50c1tpQm9uZV0pKTtcbiAgICAgICAgICBtdHhCaW5kSW52ZXJzZXMucHVzaChtdHhCaW5kSW52ZXJzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNza2VsZXRvbnNbX2lTa2VsZXRvbl0gPSBuZXcgQ29tcG9uZW50U2tlbGV0b24oYm9uZXMsIG10eEJpbmRJbnZlcnNlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiNza2VsZXRvbnNbX2lTa2VsZXRvbl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBVaW50OEFycmF5fSBmb3IgdGhlIGdpdmVuIGFjY2Vzc29yIGluZGV4LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRCb25lSW5kaWNlcyhfaUFjY2Vzc29yOiBudW1iZXIpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgICAgIGNvbnN0IGFycmF5OiBUeXBlZEFycmF5ID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJEYXRhKF9pQWNjZXNzb3IpO1xuICAgICAgY29uc3QgY29tcG9uZW50VHlwZTogR0xURi5DT01QT05FTlRfVFlQRSA9IHRoaXMuZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl0/LmNvbXBvbmVudFR5cGU7XG5cbiAgICAgIGlmIChjb21wb25lbnRUeXBlID09IEdMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURSlcbiAgICAgICAgcmV0dXJuIGFycmF5IGFzIFVpbnQ4QXJyYXk7XG5cbiAgICAgIGlmIChjb21wb25lbnRUeXBlID09IEdMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlQpIHtcbiAgICAgICAgRGVidWcubG9nKGAke3RoaXN9OiBCb25lIGluZGljZXMgYXJlIHN0b3JlZCBhcyAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlRdfScuIEZVREdFIHdpbGwgY29udmVydCB0aGVtIHRvICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9CWVRFXX0nLiBGVURHRSBvbmx5IHN1cHBvcnRzIHNrZWxldG9ucyB3aXRoIHVwIHRvIDI1NiBib25lcywgc28gbWFrZSBzdXJlIHlvdXIgc2tlbGV0b24gaGFzIG5vIG1vcmUgdGhhbiAyNTYgYm9uZXMuYCk7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXJyYXkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IEludmFsaWQgY29tcG9uZW50IHR5cGUgJyR7R0xURi5DT01QT05FTlRfVFlQRVtjb21wb25lbnRUeXBlXX0nIGZvciBib25lIGluZGljZXMuIEV4cGVjdGVkICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9CWVRFXX0nIG9yICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9TSE9SVF19Jy5gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIEZsb2F0MzJBcnJheX0gZm9yIHRoZSBnaXZlbiBhY2Nlc3NvciBpbmRleC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0RmxvYXQzMkFycmF5KF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8RmxvYXQzMkFycmF5PiB7XG4gICAgICBjb25zdCBhcnJheTogVHlwZWRBcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRGF0YShfaUFjY2Vzc29yKTtcbiAgICAgIGNvbnN0IGdsdGZBY2Nlc3NvcjogR0xURi5BY2Nlc3NvciA9IHRoaXMuZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl07XG5cbiAgICAgIGlmIChnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLkZMT0FUKVxuICAgICAgICByZXR1cm4gYXJyYXkgYXMgRmxvYXQzMkFycmF5O1xuXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgc3dpdGNoIChnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgIGNhc2UgR0xURi5DT01QT05FTlRfVFlQRS5CWVRFOlxuICAgICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5LCBfdmFsdWUgPT4gTWF0aC5tYXgoX3ZhbHVlIC8gMTI3LCAtMSkpO1xuICAgICAgICAgIGNhc2UgR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9CWVRFOlxuICAgICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5LCBfdmFsdWUgPT4gX3ZhbHVlIC8gMjU1KTtcbiAgICAgICAgICBjYXNlIEdMVEYuQ09NUE9ORU5UX1RZUEUuU0hPUlQ6XG4gICAgICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5LmZyb20oYXJyYXksIF92YWx1ZSA9PiBNYXRoLm1heChfdmFsdWUgLyAzMjc2NywgLTEpKTtcbiAgICAgICAgICBjYXNlIEdMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlQ6XG4gICAgICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5LmZyb20oYXJyYXksIF92YWx1ZSA9PiBfdmFsdWUgLyA2NTUzNSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogSW52YWxpZCBjb21wb25lbnQgdHlwZSAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW2dsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlXX0nIGZvciBub3JtYWxpemVkIGFjY2Vzc29yLmApO1xuICAgICAgICAgIC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvZ2xURi9zcGVjcy8yLjAvZ2xURi0yLjAuaHRtbCNfYWNjZXNzb3Jfbm9ybWFsaXplZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IEV4cGVjdGVkIGNvbXBvbmVudCB0eXBlICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbR0xURi5DT01QT05FTlRfVFlQRS5GTE9BVF19JyBidXQgd2FzICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbZ2x0ZkFjY2Vzc29yPy5jb21wb25lbnRUeXBlXX0nLmApO1xuICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFVpbnQxNkFycmF5fSBmb3IgdGhlIGdpdmVuIGFjY2Vzc29yIGluZGV4LiBPbmx5IHVzZWQgdG8gZ2V0IHRoZSB2ZXJ0ZXggaW5kaWNlcy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VmVydGV4SW5kaWNlcyhfaUFjY2Vzc29yOiBudW1iZXIpOiBQcm9taXNlPFVpbnQxNkFycmF5PiB7XG4gICAgICBjb25zdCBhcnJheTogVHlwZWRBcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRGF0YShfaUFjY2Vzc29yKTtcbiAgICAgIGNvbnN0IGdsdGZBY2Nlc3NvcjogR0xURi5BY2Nlc3NvciA9IHRoaXMuZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl07XG5cbiAgICAgIGlmIChnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX1NIT1JUKVxuICAgICAgICByZXR1cm4gYXJyYXkgYXMgVWludDE2QXJyYXk7XG5cbiAgICAgIGlmIChnbHRmQWNjZXNzb3IuY291bnQgPiA2NTUzNSAmJiBnbHRmQWNjZXNzb3IudHlwZSA9PSBcIlNDQUxBUlwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IEZpbGUgaW5jbHVkZXMgYSBtZXNoIHdpdGggbW9yZSB0aGFuIDY1NTM1IHZlcnRpY2VzLiBGVURHRSBkb2VzIG5vdCBzdXBwb3J0IG1lc2hlcyB3aXRoIG1vcmUgdGhhbiA2NTUzNSB2ZXJ0aWNlcy5gKTtcblxuICAgICAgaWYgKGdsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlID09IEdMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURSB8fCBnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0lOVClcbiAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5LmZyb20oYXJyYXkpO1xuXG4gICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBFeHBlY3RlZCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGNvbXBvbmVudCB0eXBlIGJ1dCB3YXMgJyR7R0xURi5DT01QT05FTlRfVFlQRVt0aGlzLmdsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdPy5jb21wb25lbnRUeXBlXX0nLmApO1xuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5LmZyb20oYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHtAbGluayBGbG9hdDMyQXJyYXl9IGZvciB0aGUgZ2l2ZW4gYWNjZXNzb3IgaW5kZXguIFRoZSBhcnJheSBjb250YWlucyB0aGUgdmVydGV4IGNvbG9ycyBpbiBSR0JBIGZvcm1hdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VmVydGV4Q29sb3JzKF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8RmxvYXQzMkFycmF5PiB7XG4gICAgICBjb25zdCBhcnJheTogRmxvYXQzMkFycmF5ID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoX2lBY2Nlc3Nvcik7XG4gICAgICBjb25zdCBnbHRmQWNjZXNzb3I6IEdMVEYuQWNjZXNzb3IgPSB0aGlzLmdsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdO1xuXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLnR5cGUgPT0gR0xURi5BQ0NFU1NPUl9UWVBFLlZFQzMpIHtcbiAgICAgICAgY29uc3QgcmdiYUFycmF5OiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5Lmxlbmd0aCAqIDQgLyAzKTtcbiAgICAgICAgZm9yIChsZXQgaVZlYzM6IG51bWJlciA9IDAsIGlWZWM0OiBudW1iZXIgPSAwOyBpVmVjMyA8IGFycmF5Lmxlbmd0aDsgaVZlYzMgKz0gMywgaVZlYzQgKz0gNCkge1xuICAgICAgICAgIHJnYmFBcnJheVtpVmVjNF0gPSBhcnJheVtpVmVjM107XG4gICAgICAgICAgcmdiYUFycmF5W2lWZWM0ICsgMV0gPSBhcnJheVtpVmVjMyArIDFdO1xuICAgICAgICAgIHJnYmFBcnJheVtpVmVjNCArIDJdID0gYXJyYXlbaVZlYzMgKyAyXTtcbiAgICAgICAgICByZ2JhQXJyYXlbaVZlYzQgKyAzXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYmFBcnJheTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIGAke0dMVEZMb2FkZXIubmFtZX0gfCAke3RoaXMudXJsfWA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRCdWZmZXJEYXRhKF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8VHlwZWRBcnJheT4ge1xuICAgICAgY29uc3QgZ2x0ZkFjY2Vzc29yOiBHTFRGLkFjY2Vzc29yID0gdGhpcy5nbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXTtcbiAgICAgIGlmICghZ2x0ZkFjY2Vzc29yKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IENvdWxkbid0IGZpbmQgYWNjZXNzb3Igd2l0aCBpbmRleCAke19pQWNjZXNzb3J9LmApO1xuXG4gICAgICBsZXQgYXJyYXk6IFR5cGVkQXJyYXk7XG4gICAgICBjb25zdCBjb21wb25lbnRUeXBlOiBHTFRGLkNPTVBPTkVOVF9UWVBFID0gZ2x0ZkFjY2Vzc29yLmNvbXBvbmVudFR5cGU7XG4gICAgICBjb25zdCBhY2Nlc3NvclR5cGU6IEdMVEYuQUNDRVNTT1JfVFlQRSA9IGdsdGZBY2Nlc3Nvci50eXBlO1xuXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLmJ1ZmZlclZpZXcgIT0gdW5kZWZpbmVkKVxuICAgICAgICBhcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyVmlld0RhdGEodGhpcy5nbHRmLmJ1ZmZlclZpZXdzW2dsdGZBY2Nlc3Nvci5idWZmZXJWaWV3XSwgZ2x0ZkFjY2Vzc29yLmJ5dGVPZmZzZXQsIGNvbXBvbmVudFR5cGUsIGFjY2Vzc29yVHlwZSk7XG5cbiAgICAgIGlmIChnbHRmQWNjZXNzb3Iuc3BhcnNlKSB7XG4gICAgICAgIGNvbnN0IGdsdGZCdWZmZXJWaWV3SW5kaWNlczogR0xURi5CdWZmZXJWaWV3ID0gdGhpcy5nbHRmLmJ1ZmZlclZpZXdzW2dsdGZBY2Nlc3Nvci5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3XTtcbiAgICAgICAgY29uc3QgZ2x0ZkJ1ZmZlclZpZXdWYWx1ZXM6IEdMVEYuQnVmZmVyVmlldyA9IHRoaXMuZ2x0Zi5idWZmZXJWaWV3c1tnbHRmQWNjZXNzb3Iuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3XTtcblxuICAgICAgICBpZiAoIWdsdGZCdWZmZXJWaWV3SW5kaWNlcyB8fCAhZ2x0ZkJ1ZmZlclZpZXdWYWx1ZXMpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIGJ1ZmZlciB2aWV3cyBmb3Igc3BhcnNlIGluZGljZXMgb3IgdmFsdWVzIG9mIGFjY2Vzc29yIHdpdGggaW5kZXggJHtfaUFjY2Vzc29yfS5gKTtcblxuICAgICAgICBjb25zdCBhcnJheUluZGljZXM6IFR5cGVkQXJyYXkgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlclZpZXdEYXRhKGdsdGZCdWZmZXJWaWV3SW5kaWNlcywgZ2x0ZkFjY2Vzc29yLnNwYXJzZS5pbmRpY2VzLmJ5dGVPZmZzZXQsIGdsdGZBY2Nlc3Nvci5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlLCBHTFRGLkFDQ0VTU09SX1RZUEUuU0NBTEFSKTtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZXM6IFR5cGVkQXJyYXkgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlclZpZXdEYXRhKGdsdGZCdWZmZXJWaWV3VmFsdWVzLCBnbHRmQWNjZXNzb3Iuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0LCBjb21wb25lbnRUeXBlLCBhY2Nlc3NvclR5cGUpO1xuXG4gICAgICAgIGNvbnN0IGFjY2Vzc29yVHlwZUxlbmd0aDogbnVtYmVyID0gdG9BY2Nlc3NvclR5cGVMZW5ndGhbZ2x0ZkFjY2Vzc29yLnR5cGVdO1xuICAgICAgICBpZiAoZ2x0ZkFjY2Vzc29yLmJ1ZmZlclZpZXcgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGFycmF5ID0gbmV3IHRvQXJyYXlDb25zdHJ1Y3RvcltnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZV0oZ2x0ZkFjY2Vzc29yLmNvdW50ICogYWNjZXNzb3JUeXBlTGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgZ2x0ZkFjY2Vzc29yLnNwYXJzZS5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgYXJyYXkuc2V0KGFycmF5VmFsdWVzLnNsaWNlKGkgKiBhY2Nlc3NvclR5cGVMZW5ndGgsIChpICsgMSkgKiBhY2Nlc3NvclR5cGVMZW5ndGgpLCBhcnJheUluZGljZXNbaV0gKiBhY2Nlc3NvclR5cGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGdldEJ1ZmZlclZpZXdEYXRhKF9idWZmZXJWaWV3OiBHTFRGLkJ1ZmZlclZpZXcsIF9ieXRlT2Zmc2V0OiBudW1iZXIsIF9jb21wb25lbnRUeXBlOiBHTFRGLkNPTVBPTkVOVF9UWVBFLCBfYWNjZXNzb3JUeXBlOiBHTFRGLkFDQ0VTU09SX1RZUEUpOiBQcm9taXNlPFR5cGVkQXJyYXk+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlcjogQXJyYXlCdWZmZXIgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlcihfYnVmZmVyVmlldy5idWZmZXIpO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldDogbnVtYmVyID0gKF9idWZmZXJWaWV3LmJ5dGVPZmZzZXQgPz8gMCkgKyAoX2J5dGVPZmZzZXQgPz8gMCk7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoOiBudW1iZXIgPSBfYnVmZmVyVmlldy5ieXRlTGVuZ3RoID8/IDA7XG4gICAgICBjb25zdCBieXRlU3RyaWRlOiBudW1iZXIgPSBfYnVmZmVyVmlldy5ieXRlU3RyaWRlO1xuXG4gICAgICBjb25zdCBhcnJheUNvbnN0cnVjdG9yOiBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB0b0FycmF5Q29uc3RydWN0b3JbX2NvbXBvbmVudFR5cGVdO1xuICAgICAgY29uc3QgYXJyYXk6IFR5cGVkQXJyYXkgPSBuZXcgYXJyYXlDb25zdHJ1Y3RvcihidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggLyBhcnJheUNvbnN0cnVjdG9yLkJZVEVTX1BFUl9FTEVNRU5UKTtcblxuICAgICAgaWYgKGJ5dGVTdHJpZGUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRPRE86IGluc3RlYWQgb2YgY3JlYXRpbmcgbmV3IGJ1ZmZlcnMgbWF5YmUgcmF0aGVyIHBhc3Mgc3RyaWRlIGludG8gdGhlIHJlbmRlciBtZXNoPyBhbmQgc2V0IGl0IHdoZW4gZGF0YSBpcyBwYXNzZWQgdG8gdGhlIGdwdT9cbiAgICAgICAgY29uc3QgbkNvbXBvbmVudHNQZXJFbGVtZW50OiBudW1iZXIgPSB0b0FjY2Vzc29yVHlwZUxlbmd0aFtfYWNjZXNzb3JUeXBlXTsgLy8gYW1vdW50IG9mIGNvbXBvbmVudHMgcGVyIGVsZW1lbnQgb2YgdGhlIGFjY2Vzc29yIHR5cGUsIGkuZS4gMyBmb3IgVkVDM1xuICAgICAgICBjb25zdCBuRWxlbWVudHM6IG51bWJlciA9IGJ5dGVMZW5ndGggLyBieXRlU3RyaWRlOyAvLyBhbW91bnQgb2YgZWxlbWVudHMsIGkuZS4gbipWRUMzIFxuICAgICAgICBjb25zdCBzdHJpZGU6IG51bWJlciA9IGJ5dGVTdHJpZGUgLyBhcnJheUNvbnN0cnVjdG9yLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBjb25zdCBuZXdBcnJheTogVHlwZWRBcnJheSA9IG5ldyBhcnJheUNvbnN0cnVjdG9yKG5FbGVtZW50cyAqIG5Db21wb25lbnRzUGVyRWxlbWVudCk7XG4gICAgICAgIGZvciAobGV0IGlOZXdFbGVtZW50OiBudW1iZXIgPSAwOyBpTmV3RWxlbWVudCA8IG5FbGVtZW50czsgaU5ld0VsZW1lbnQrKykge1xuICAgICAgICAgIGNvbnN0IGlFbGVtZW50OiBudW1iZXIgPSBpTmV3RWxlbWVudCAqIHN0cmlkZTtcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBsb29wIGlzIGZhc3RlciB0aGFuIHNldCArIHNsaWNlXG4gICAgICAgICAgZm9yIChsZXQgaUNvbXBvbmVudDogbnVtYmVyID0gMDsgaUNvbXBvbmVudCA8IG5Db21wb25lbnRzUGVyRWxlbWVudDsgaUNvbXBvbmVudCsrKVxuICAgICAgICAgICAgbmV3QXJyYXlbaU5ld0VsZW1lbnQgKiBuQ29tcG9uZW50c1BlckVsZW1lbnQgKyBpQ29tcG9uZW50XSA9IGFycmF5W2lFbGVtZW50ICsgaUNvbXBvbmVudF07XG4gICAgICAgICAgLy8gbmV3QXJyYXkuc2V0KGFycmF5LnNsaWNlKGlFbGVtZW50LCBpRWxlbWVudCArIG5Db21wb25lbnRzUGVyRWxlbWVudCksIGlOZXdFbGVtZW50ICogbkNvbXBvbmVudHNQZXJFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0QnVmZmVyKF9pQnVmZmVyOiBudW1iZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgICBjb25zdCBnbHRmQnVmZmVyOiBHTFRGLkJ1ZmZlciA9IHRoaXMuZ2x0Zi5idWZmZXJzW19pQnVmZmVyXTtcbiAgICAgIGlmICghZ2x0ZkJ1ZmZlcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIGJ1ZmZlciB3aXRoIGluZGV4ICR7X2lCdWZmZXJ9LmApO1xuXG4gICAgICBpZiAoIXRoaXMuI2J1ZmZlcnMpXG4gICAgICAgIHRoaXMuI2J1ZmZlcnMgPSBbXTtcbiAgICAgIGlmICghdGhpcy4jYnVmZmVyc1tfaUJ1ZmZlcl0pIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobmV3IFVSTChnbHRmQnVmZmVyLnVyaSwgdGhpcy51cmwpKTtcbiAgICAgICAgdGhpcy4jYnVmZmVyc1tfaUJ1ZmZlcl0gPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy4jYnVmZmVyc1tfaUJ1ZmZlcl07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRBbmltYXRpb25TZXF1ZW5jZVZlY3Rvcihfc2FtcGxlcjogR0xURi5BbmltYXRpb25TYW1wbGVyLCBfdHJhbnNmb3JtYXRpb25UeXBlOiBHTFRGLkFuaW1hdGlvbkNoYW5uZWxUYXJnZXRbXCJwYXRoXCJdKTogUHJvbWlzZTxBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjMgfCBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjQ+IHtcbiAgICAgIGNvbnN0IGlucHV0OiBGbG9hdDMyQXJyYXkgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShfc2FtcGxlci5pbnB1dCk7XG4gICAgICBjb25zdCBvdXRwdXQ6IEZsb2F0MzJBcnJheSA9IGF3YWl0IHRoaXMuZ2V0RmxvYXQzMkFycmF5KF9zYW1wbGVyLm91dHB1dCk7XG5cbiAgICAgIGNvbnN0IG1pbGxpc1BlclNlY29uZDogbnVtYmVyID0gMTAwMDtcbiAgICAgIGNvbnN0IGlzUm90YXRpb246IGJvb2xlYW4gPSBfdHJhbnNmb3JtYXRpb25UeXBlID09IFwicm90YXRpb25cIjtcbiAgICAgIGNvbnN0IHZlY3Rvckxlbmd0aDogbnVtYmVyID0gaXNSb3RhdGlvbiA/IDQgOiAzOyAvLyByb3RhdGlvbiBpcyBzdG9yZWQgYXMgcXVhdGVybmlvblxuICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbjogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04gPSB0aGlzLnRvSW50ZXJuSW50ZXJwb2xhdGlvbihfc2FtcGxlci5pbnRlcnBvbGF0aW9uKTtcbiAgICAgIGNvbnN0IGlzQ3ViaWM6IHRydWUgfCB1bmRlZmluZWQgPSBpbnRlcnBvbGF0aW9uID09IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNVQklDID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHZlY3RvcnNQZXJJbnB1dDogbnVtYmVyID0gaXNDdWJpYyA/IDMgOiAxOyAvLyBjdWJpYyBpbnRlcnBvbGF0aW9uIHVzZXMgMyB2YWx1ZXMgcGVyIGlucHV0OiBpbi10YW5nZW50LCBwcm9wZXJ0eSB2YWx1ZSBhbmQgb3V0LXRhbmdlbnQuIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvZ2xURi9zcGVjcy8yLjAvZ2xURi0yLjAuaHRtbCNpbnRlcnBvbGF0aW9uLWN1YmljXG5cbiAgICAgIC8vIHVzZWQgb25seSBmb3Igcm90YXRpb24gaW50ZXJwb2xhdGlvblxuICAgICAgbGV0IGxhc3RSb3RhdGlvbjogUXVhdGVybmlvbjtcbiAgICAgIGxldCBuZXh0Um90YXRpb246IFF1YXRlcm5pb247XG5cbiAgICAgIGNvbnN0IHNlcXVlbmNlVmVjdG9yOiBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjMgfCBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjQgPSB7fTtcbiAgICAgIHNlcXVlbmNlVmVjdG9yLnggPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcbiAgICAgIHNlcXVlbmNlVmVjdG9yLnkgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcbiAgICAgIHNlcXVlbmNlVmVjdG9yLnogPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcbiAgICAgIGlmIChpc1JvdGF0aW9uKSB7XG4gICAgICAgIHNlcXVlbmNlVmVjdG9yLncgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcbiAgICAgICAgbGFzdFJvdGF0aW9uID0gUmVjeWNsZXIuZ2V0KFF1YXRlcm5pb24pO1xuICAgICAgICBuZXh0Um90YXRpb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGlJbnB1dDogbnVtYmVyID0gMDsgaUlucHV0IDwgaW5wdXQubGVuZ3RoOyBpSW5wdXQrKykge1xuICAgICAgICBjb25zdCBpT3V0cHV0OiBudW1iZXIgPSBpSW5wdXQgKiB2ZWN0b3JzUGVySW5wdXQgKiB2ZWN0b3JMZW5ndGggKyAoaXNDdWJpYyA/IHZlY3Rvckxlbmd0aCA6IDApO1xuICAgICAgICBjb25zdCBpT3V0cHV0U2xvcGVJbjogbnVtYmVyID0gaU91dHB1dCAtIHZlY3Rvckxlbmd0aDtcbiAgICAgICAgY29uc3QgaU91dHB1dFNsb3BlT3V0OiBudW1iZXIgPSBpT3V0cHV0ICsgdmVjdG9yTGVuZ3RoO1xuICAgICAgICBjb25zdCB0aW1lOiBudW1iZXIgPSBtaWxsaXNQZXJTZWNvbmQgKiBpbnB1dFtpSW5wdXRdO1xuXG4gICAgICAgIGlmIChpc1JvdGF0aW9uKSB7XG4gICAgICAgICAgLy8gVGFrZSB0aGUgc2hvcnRlc3QgcGF0aCBiZXR3ZWVuIHR3byByb3RhdGlvbnMsIGkuZS4gaWYgdGhlIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlIHRoZW4gdGhlIG5leHQgcXVhdGVybmlvbiBuZWVkcyB0byBiZSBuZWdhdGVkLlxuICAgICAgICAgIC8vIHEgYW5kIC1xIHJlcHJlc2VudCB0aGUgc2FtZSByb3RhdGlvbiBidXQgaW50ZXJwb2xhdGlvbiB3aWxsIHRha2UgZWl0aGVyIHRoZSBsb25nIHdheSBvciB0aGUgc2hvcnQgd2F5IGFyb3VuZCB0aGUgc3BoZXJlIGRlcGVuZGluZyBvbiB3aGljaCB3ZSB1c2UuXG4gICAgICAgICAgbmV4dFJvdGF0aW9uLnNldChvdXRwdXRbaU91dHB1dCArIDBdLCBvdXRwdXRbaU91dHB1dCArIDFdLCBvdXRwdXRbaU91dHB1dCArIDJdLCBvdXRwdXRbaU91dHB1dCArIDNdKTtcbiAgICAgICAgICBpZiAoUXVhdGVybmlvbi5ET1QobGFzdFJvdGF0aW9uLCBuZXh0Um90YXRpb24pIDwgMClcbiAgICAgICAgICAgIG5leHRSb3RhdGlvbi5uZWdhdGUoKTtcbiAgICAgICAgICBvdXRwdXRbaU91dHB1dCArIDBdID0gbmV4dFJvdGF0aW9uLng7XG4gICAgICAgICAgb3V0cHV0W2lPdXRwdXQgKyAxXSA9IG5leHRSb3RhdGlvbi55O1xuICAgICAgICAgIG91dHB1dFtpT3V0cHV0ICsgMl0gPSBuZXh0Um90YXRpb24uejtcbiAgICAgICAgICBvdXRwdXRbaU91dHB1dCArIDNdID0gbmV4dFJvdGF0aW9uLnc7XG4gICAgICAgICAgbGFzdFJvdGF0aW9uLnNldChuZXh0Um90YXRpb24ueCwgbmV4dFJvdGF0aW9uLnksIG5leHRSb3RhdGlvbi56LCBuZXh0Um90YXRpb24udyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXF1ZW5jZVZlY3Rvci54LmFkZEtleShuZXcgQW5pbWF0aW9uS2V5KHRpbWUsIG91dHB1dFtpT3V0cHV0ICsgMF0sIGludGVycG9sYXRpb24sIGlzQ3ViaWMgJiYgb3V0cHV0W2lPdXRwdXRTbG9wZUluICsgMF0gLyBtaWxsaXNQZXJTZWNvbmQsIGlzQ3ViaWMgJiYgb3V0cHV0W2lPdXRwdXRTbG9wZU91dCArIDBdIC8gbWlsbGlzUGVyU2Vjb25kKSk7XG4gICAgICAgIHNlcXVlbmNlVmVjdG9yLnkuYWRkS2V5KG5ldyBBbmltYXRpb25LZXkodGltZSwgb3V0cHV0W2lPdXRwdXQgKyAxXSwgaW50ZXJwb2xhdGlvbiwgaXNDdWJpYyAmJiBvdXRwdXRbaU91dHB1dFNsb3BlSW4gKyAxXSAvIG1pbGxpc1BlclNlY29uZCwgaXNDdWJpYyAmJiBvdXRwdXRbaU91dHB1dFNsb3BlT3V0ICsgMV0gLyBtaWxsaXNQZXJTZWNvbmQpKTtcbiAgICAgICAgc2VxdWVuY2VWZWN0b3Iuei5hZGRLZXkobmV3IEFuaW1hdGlvbktleSh0aW1lLCBvdXRwdXRbaU91dHB1dCArIDJdLCBpbnRlcnBvbGF0aW9uLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVJbiArIDJdIC8gbWlsbGlzUGVyU2Vjb25kLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVPdXQgKyAyXSAvIG1pbGxpc1BlclNlY29uZCkpO1xuICAgICAgICAoPEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yND5zZXF1ZW5jZVZlY3Rvcikudz8uYWRkS2V5KG5ldyBBbmltYXRpb25LZXkodGltZSwgb3V0cHV0W2lPdXRwdXQgKyAzXSwgaW50ZXJwb2xhdGlvbiwgaXNDdWJpYyAmJiBvdXRwdXRbaU91dHB1dFNsb3BlSW4gKyAzXSAvIG1pbGxpc1BlclNlY29uZCwgaXNDdWJpYyAmJiBvdXRwdXRbaU91dHB1dFNsb3BlT3V0ICsgM10gLyBtaWxsaXNQZXJTZWNvbmQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUm90YXRpb24pIHtcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobGFzdFJvdGF0aW9uKTtcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobmV4dFJvdGF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcXVlbmNlVmVjdG9yO1xuICAgIH1cblxuICAgIHByaXZhdGUgdG9JbnRlcm5JbnRlcnBvbGF0aW9uKF9pbnRlcnBvbGF0aW9uOiBHTFRGLkFuaW1hdGlvblNhbXBsZXJbXCJpbnRlcnBvbGF0aW9uXCJdKTogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04ge1xuICAgICAgc3dpdGNoIChfaW50ZXJwb2xhdGlvbikge1xuICAgICAgICBjYXNlIFwiTElORUFSXCI6XG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkxJTkVBUjtcbiAgICAgICAgY2FzZSBcIlNURVBcIjpcbiAgICAgICAgICByZXR1cm4gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ09OU1RBTlQ7XG4gICAgICAgIGNhc2UgXCJDVUJJQ1NQTElORVwiOlxuICAgICAgICAgIHJldHVybiBBTklNQVRJT05fSU5URVJQT0xBVElPTi5DVUJJQztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoX2ludGVycG9sYXRpb24gIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogVW5rbm93biBpbnRlcnBvbGF0aW9uIHR5cGUgJHtfaW50ZXJwb2xhdGlvbn0uYCk7XG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkxJTkVBUjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXZWJHTFBhcmFtZXRlck5hbWUoX3ZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0KS5maW5kKF9rZXkgPT4gUmVmbGVjdC5nZXQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgX2tleSkgPT0gX3ZhbHVlKTtcbiAgfVxuXG4gIHR5cGUgVHlwZWRBcnJheSA9IFVpbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IFVpbnQzMkFycmF5IHwgSW50OEFycmF5IHwgSW50MTZBcnJheSB8IEZsb2F0MzJBcnJheTtcbiAgdHlwZSBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBVaW50OEFycmF5Q29uc3RydWN0b3IgfCBVaW50MTZBcnJheUNvbnN0cnVjdG9yIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvciB8IEludDhBcnJheUNvbnN0cnVjdG9yIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3I7XG5cbiAgY29uc3QgdG9JbnRlcm5UcmFuc2Zvcm1hdGlvbjogUmVjb3JkPEdMVEYuQW5pbWF0aW9uQ2hhbm5lbFRhcmdldFtcInBhdGhcIl0sIHN0cmluZz4gPSB7XG4gICAgXCJ0cmFuc2xhdGlvblwiOiBcInRyYW5zbGF0aW9uXCIsXG4gICAgXCJyb3RhdGlvblwiOiBcInJvdGF0aW9uXCIsXG4gICAgXCJzY2FsZVwiOiBcInNjYWxpbmdcIixcbiAgICBcIndlaWdodHNcIjogXCJ3ZWlnaHRzXCJcbiAgfTtcblxuICAvLyBudW1iZXIgb2YgY29tcG9uZW50cyBkZWZpbmVkIGJ5ICd0eXBlJ1xuICBjb25zdCB0b0FjY2Vzc29yVHlwZUxlbmd0aDogUmVjb3JkPEdMVEYuQUNDRVNTT1JfVFlQRSwgbnVtYmVyPiA9IHtcbiAgICBcIlNDQUxBUlwiOiAxLFxuICAgIFwiVkVDMlwiOiAyLFxuICAgIFwiVkVDM1wiOiAzLFxuICAgIFwiVkVDNFwiOiA0LFxuICAgIFwiTUFUMlwiOiA0LFxuICAgIFwiTUFUM1wiOiA5LFxuICAgIFwiTUFUNFwiOiAxNlxuICB9O1xuXG4gIGNvbnN0IHRvQXJyYXlDb25zdHJ1Y3RvcjogUmVjb3JkPEdMVEYuQ09NUE9ORU5UX1RZUEUsIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcj4gPSB7XG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURV06IFVpbnQ4QXJyYXksXG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuQllURV06IEludDhBcnJheSxcbiAgICBbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9TSE9SVF06IFVpbnQxNkFycmF5LFxuICAgIFtHTFRGLkNPTVBPTkVOVF9UWVBFLlNIT1JUXTogSW50MTZBcnJheSxcbiAgICBbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9JTlRdOiBVaW50MzJBcnJheSxcbiAgICBbR0xURi5DT01QT05FTlRfVFlQRS5GTE9BVF06IEZsb2F0MzJBcnJheVxuICB9O1xuXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBsZXQgc2hhZGVyU291cmNlczoge1tzb3VyY2U6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclBob25nLmZyYWdcIl0gPSAvKmdsc2wqLyBgI3ZlcnNpb24gMzAwIGVzXG4vKipcbiogUGhvbmcgc2hhZGluZ1xuKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMiB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xuKi9cblxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5wcmVjaXNpb24gaGlnaHAgaW50O1xuXG4gIC8vIFRFWFRVUkU6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XG4gICNlbmRpZlxuXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcbnVuaWZvcm0gZmxvYXQgdV9mRGlmZnVzZTtcbnVuaWZvcm0gZmxvYXQgdV9mU3BlY3VsYXI7XG4vLyB1bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDsgLy8gY2FuJ3QgdXNlIHRoaXMgd2hlbiBza2lubmluZ1xudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xuXG5pbiB2ZWM0IHZfdmN0Q29sb3I7XG5pbiB2ZWMzIHZfdmN0UG9zaXRpb247XG5cbiAgI2lmIGRlZmluZWQoUEhPTkcpXG5pbiB2ZWMzIHZfdmN0Tm9ybWFsO1xuICAjZW5kaWZcblxuICAjaWYgZGVmaW5lZChGTEFUKVxuZmxhdCBpbiB2ZWMzIHZfdmN0UG9zaXRpb25GbGF0O1xuICAjZW5kaWZcblxub3V0IHZlYzQgdmN0RnJhZztcblxuc3RydWN0IExpZ2h0IHtcbiAgdmVjNCB2Y3RDb2xvcjtcbiAgbWF0NCBtdHhTaGFwZTtcbiAgbWF0NCBtdHhTaGFwZUludmVyc2U7XG59O1xuXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgPSAxNXU7XG5jb25zdCB1aW50IE1BWF9MSUdIVFNfUE9JTlQgPSAxMDB1O1xuY29uc3QgdWludCBNQVhfTElHSFRTX1NQT1QgPSAxMDB1O1xuXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIExpZ2h0cyB7XG4gIHVpbnQgdV9uTGlnaHRzRGlyZWN0aW9uYWw7XG4gIHVpbnQgdV9uTGlnaHRzUG9pbnQ7XG4gIHVpbnQgdV9uTGlnaHRzU3BvdDtcbiAgTGlnaHQgdV9hbWJpZW50O1xuICBMaWdodCB1X2RpcmVjdGlvbmFsW01BWF9MSUdIVFNfRElSRUNUSU9OQUxdO1xuICBMaWdodCB1X3BvaW50W01BWF9MSUdIVFNfUE9JTlRdO1xuICBMaWdodCB1X3Nwb3RbTUFYX0xJR0hUU19TUE9UXTtcbn07XG5cbmZsb2F0IGNhbGN1bGF0ZVJlZmxlY3Rpb24odmVjMyBfdmN0TGlnaHQsIHZlYzMgX3ZjdFZpZXcsIHZlYzMgX3ZjdE5vcm1hbCwgZmxvYXQgX2ZTcGVjdWxhcikge1xuICBpZihfZlNwZWN1bGFyIDw9IDAuMClcbiAgICByZXR1cm4gMC4wO1xuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdCgtX3ZjdExpZ2h0LCBfdmN0Tm9ybWFsKSk7XG4gIGZsb2F0IGZIaXRDYW1lcmEgPSBkb3QodmN0UmVmbGVjdGlvbiwgX3ZjdFZpZXcpO1xuICAvLyBhdHRlbXB0ZWQgQkxJTk4gXG4gIC8vIHZlYzMgaGFsZndheSA9IG5vcm1hbGl6ZShfdmN0VmlldyArIF92Y3RMaWdodCk7XG4gIC8vIGZsb2F0IGZIaXRDYW1lcmEgPSBkb3QoLWhhbGZ3YXksIF92Y3ROb3JtYWwpO1xuICByZXR1cm4gcG93KG1heChmSGl0Q2FtZXJhLCAwLjApLCBfZlNwZWN1bGFyICogMTAuMCkgKiBfZlNwZWN1bGFyOyAvLyAxMC4wID0gbWFnaWMgbnVtYmVyLCBsb29rcyBnb29kLi4uIFxufVxuXG52ZWM0IGlsbHVtaW5hdGVEaXJlY3RlZCh2ZWMzIF92Y3REaXJlY3Rpb24sIHZlYzMgX3ZjdE5vcm1hbCwgdmVjNCBfdmN0Q29sb3IsIHZlYzMgX3ZjdFZpZXcsIGZsb2F0IF9mU3BlY3VsYXIpIHtcbiAgdmVjNCB2Y3RSZXN1bHQgPSB2ZWM0KDAsIDAsIDAsIDEpO1xuICB2ZWMzIHZjdERpcmVjdGlvbiA9IG5vcm1hbGl6ZShfdmN0RGlyZWN0aW9uKTtcbiAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QoX3ZjdE5vcm1hbCwgdmN0RGlyZWN0aW9uKTtcbiAgaWYoZklsbHVtaW5hdGlvbiA+IDAuMGYpIHtcbiAgICB2Y3RSZXN1bHQgKz0gdV9mRGlmZnVzZSAqIGZJbGx1bWluYXRpb24gKiBfdmN0Q29sb3I7XG4gICAgZmxvYXQgZlJlZmxlY3Rpb24gPSBjYWxjdWxhdGVSZWZsZWN0aW9uKHZjdERpcmVjdGlvbiwgX3ZjdFZpZXcsIF92Y3ROb3JtYWwsIF9mU3BlY3VsYXIpO1xuICAgIHZjdFJlc3VsdCArPSBmUmVmbGVjdGlvbiAqIF92Y3RDb2xvcjtcbiAgfVxuICByZXR1cm4gdmN0UmVzdWx0O1xufVxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzMgdmN0UG9zaXRpb24gPSB2X3ZjdFBvc2l0aW9uO1xuXG4gICAgI2lmIGRlZmluZWQoUEhPTkcpXG4gIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKHZfdmN0Tm9ybWFsKTtcbiAgdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHZfdmN0UG9zaXRpb24gLSB1X3ZjdENhbWVyYSk7XG4gICAgI2VuZGlmXG5cbiAgICAjaWYgZGVmaW5lZChGTEFUKVxuICB2ZWMzIHZjdFhUYW5nZW50ID0gZEZkeCh2Y3RQb3NpdGlvbik7XG4gIHZlYzMgdmN0WVRhbmdlbnQgPSBkRmR5KHZjdFBvc2l0aW9uKTtcbiAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUoY3Jvc3ModmN0WFRhbmdlbnQsIHZjdFlUYW5nZW50KSk7XG4gIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2X3ZjdFBvc2l0aW9uRmxhdCAtIHVfdmN0Q2FtZXJhKTtcbiAgICAjZW5kaWZcblxuICB2Y3RGcmFnID0gdV9mRGlmZnVzZSAqIHVfYW1iaWVudC52Y3RDb2xvcjtcbiAgXG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcbiAgICB2ZWMzIHZjdERpcmVjdGlvbiA9IHZlYzModV9kaXJlY3Rpb25hbFtpXS5tdHhTaGFwZSAqIHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKSk7XG4gICAgdmN0RnJhZyArPSBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3IsIHZjdFZpZXcsIHVfZlNwZWN1bGFyKTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBwb2ludCBsaWdodCBlZmZlY3RcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzUG9pbnQ7IGkrKykge1xuICAgIHZlYzMgdmN0UG9zaXRpb25MaWdodCA9IHZlYzModV9wb2ludFtpXS5tdHhTaGFwZSAqIHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKSk7XG4gICAgdmVjMyB2Y3REaXJlY3Rpb24gPSB2Y3RQb3NpdGlvbiAtIHZjdFBvc2l0aW9uTGlnaHQ7XG4gICAgZmxvYXQgZkludGVuc2l0eSA9IDEuMCAtIGxlbmd0aChtYXQzKHVfcG9pbnRbaV0ubXR4U2hhcGVJbnZlcnNlKSAqIHZjdERpcmVjdGlvbik7XG4gICAgaWYoZkludGVuc2l0eSA8IDAuMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIHZjdEZyYWcgKz0gaWxsdW1pbmF0ZURpcmVjdGVkKHZjdERpcmVjdGlvbiwgdmN0Tm9ybWFsLCBmSW50ZW5zaXR5ICogdV9wb2ludFtpXS52Y3RDb2xvciwgdmN0VmlldywgdV9mU3BlY3VsYXIpO1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHNwb3QgbGlnaHQgZWZmZWN0XG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c1Nwb3Q7IGkrKykge1xuICAgIHZlYzMgdmN0UG9zaXRpb25MaWdodCA9IHZlYzModV9zcG90W2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcbiAgICB2ZWMzIHZjdERpcmVjdGlvbiA9IHZjdFBvc2l0aW9uIC0gdmN0UG9zaXRpb25MaWdodDtcbiAgICB2ZWMzIHZjdERpcmVjdGlvbkludmVydGVkID0gbWF0Myh1X3Nwb3RbaV0ubXR4U2hhcGVJbnZlcnNlKSAqIHZjdERpcmVjdGlvbjtcbiAgICBpZih2Y3REaXJlY3Rpb25JbnZlcnRlZC56IDw9IDAuMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGZsb2F0IGZJbnRlbnNpdHkgPSAxLjAgLSBtaW4oMS4wLCAyLjAgKiBsZW5ndGgodmN0RGlyZWN0aW9uSW52ZXJ0ZWQueHkpIC8gdmN0RGlyZWN0aW9uSW52ZXJ0ZWQueik7XG4gICAgZkludGVuc2l0eSAqPSAxLjAgLSBwb3codmN0RGlyZWN0aW9uSW52ZXJ0ZWQueiwgMi4wKTtcbiAgICBpZihmSW50ZW5zaXR5IDwgMC4wKVxuICAgICAgY29udGludWU7XG4gICAgdmN0RnJhZyArPSBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3ROb3JtYWwsIGZJbnRlbnNpdHkgKiB1X3Nwb3RbaV0udmN0Q29sb3IsIHZjdFZpZXcsIHVfZlNwZWN1bGFyKTtcbiAgfVxuXG4gIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKVxuICB2ZWM0IHZjdENvbG9yVGV4dHVyZSA9IHRleHR1cmUodV90ZXh0dXJlLCB2X3ZjdFRleHR1cmUpO1xuICB2Y3RGcmFnICo9IHZjdENvbG9yVGV4dHVyZTtcbiAgICAjZW5kaWZcbiAgICBcbiAgdmN0RnJhZyAqPSB1X3ZjdENvbG9yICogdl92Y3RDb2xvcjtcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGljay5mcmFnXCJdID0gLypnbHNsKi8gYCN2ZXJzaW9uIDMwMCBlc1xuLyoqXG4qIFJlbmRlcnMgZm9yIFJheWNhc3RpbmdcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiovXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5cbnVuaWZvcm0gaW50IHVfaWQ7XG51bmlmb3JtIHZlYzIgdV92Y3RTaXplO1xudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XG5vdXQgaXZlYzQgdmN0RnJhZztcblxudm9pZCBtYWluKCkge1xuICAgIGludCBwaXhlbCA9IGludCh0cnVuYyhnbF9GcmFnQ29vcmQueCkgKyB1X3ZjdFNpemUueCAqIHRydW5jKGdsX0ZyYWdDb29yZC55KSk7XG5cbiAgICBpZiAocGl4ZWwgIT0gdV9pZClcbiAgICAgIGRpc2NhcmQ7XG5cbiAgICB1aW50IGljb2xvciA9IHVpbnQodV92Y3RDb2xvci5yICogMjU1LjApIDw8IDI0IHwgdWludCh1X3ZjdENvbG9yLmcgKiAyNTUuMCkgPDwgMTYgfCB1aW50KHVfdmN0Q29sb3IuYiAqIDI1NS4wKSA8PCA4IHwgdWludCh1X3ZjdENvbG9yLmEgKiAyNTUuMCk7XG4gICAgICAgICAgICAgICAgXG4gICAgdmN0RnJhZyA9IGl2ZWM0KGZsb2F0Qml0c1RvSW50KGdsX0ZyYWdDb29yZC56KSwgaWNvbG9yLCAwLCAwKTtcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGljay52ZXJ0XCJdID0gLypnbHNsKi8gYCN2ZXJzaW9uIDMwMCBlc1xuLyoqXG4qIFJlbmRlcnMgZm9yIFJheWNhc3RpbmdcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiovXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb247ICAgICAgIFxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcblxudm9pZCBtYWluKCkgeyAgIFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tdHhNZXNoVG9WaWV3ICogdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xufWA7XG4gIHNoYWRlclNvdXJjZXNbXCJTaGFkZXJQaWNrVGV4dHVyZWQuZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcbi8qKlxuKiBSZW5kZXJzIGZvciBSYXljYXN0aW5nXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XG4qL1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5wcmVjaXNpb24gaGlnaHAgaW50O1xuXG51bmlmb3JtIGludCB1X2lkO1xudW5pZm9ybSB2ZWMyIHVfdmN0U2l6ZTtcbmluIHZlYzIgdl92Y3RUZXh0dXJlO1xudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XG5cbm91dCBpdmVjNCB2Y3RGcmFnO1xuXG52b2lkIG1haW4oKSB7XG4gICAgaW50IHBpeGVsID0gaW50KHRydW5jKGdsX0ZyYWdDb29yZC54KSArIHVfdmN0U2l6ZS54ICogdHJ1bmMoZ2xfRnJhZ0Nvb3JkLnkpKTtcblxuICAgIGlmIChwaXhlbCAhPSB1X2lkKVxuICAgICAgZGlzY2FyZDtcbiAgICBcbiAgICB2ZWM0IHZjdENvbG9yID0gdV92Y3RDb2xvciAqIHRleHR1cmUodV90ZXh0dXJlLCB2X3ZjdFRleHR1cmUpO1xuICAgIHVpbnQgaWNvbG9yID0gdWludCh2Y3RDb2xvci5yICogMjU1LjApIDw8IDI0IHwgdWludCh2Y3RDb2xvci5nICogMjU1LjApIDw8IDE2IHwgdWludCh2Y3RDb2xvci5iICogMjU1LjApIDw8IDggfCB1aW50KHZjdENvbG9yLmEgKiAyNTUuMCk7XG4gIFxuICB2Y3RGcmFnID0gaXZlYzQoZmxvYXRCaXRzVG9JbnQoZ2xfRnJhZ0Nvb3JkLnopLCBpY29sb3IsIGZsb2F0Qml0c1RvSW50KHZfdmN0VGV4dHVyZS54KSwgZmxvYXRCaXRzVG9JbnQodl92Y3RUZXh0dXJlLnkpKTtcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGlja1RleHR1cmVkLnZlcnRcIl0gPSAvKmdsc2wqLyBgI3ZlcnNpb24gMzAwIGVzXG4vKipcbiogUmVuZGVycyBmb3IgUmF5Y2FzdGluZ1xuKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuKi9cbmluIHZlYzMgYV92Y3RQb3NpdGlvbjsgICAgICAgXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XG51bmlmb3JtIG1hdDMgdV9tdHhQaXZvdDtcblxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xuXG52b2lkIG1haW4oKSB7ICAgXG4gICAgZ2xfUG9zaXRpb24gPSB1X210eE1lc2hUb1ZpZXcgKiB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XG4gICAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xufWA7XG4gIHNoYWRlclNvdXJjZXNbXCJTaGFkZXJVbml2ZXJzYWwuZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcbi8qKlxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcbiovXG5cbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xucHJlY2lzaW9uIGhpZ2hwIGludDtcblxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcbmluIHZlYzQgdl92Y3RDb2xvcjtcblxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXG5pbiB2ZWMyIHZfdmN0VGV4dHVyZTtcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcbiAgI2VuZGlmXG5cbm91dCB2ZWM0IHZjdEZyYWc7XG5cbnZvaWQgbWFpbigpIHtcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcbiAgdmN0RnJhZyA9IHVfdmN0Q29sb3IgKiB2X3ZjdENvbG9yO1xuXG4gICAgLy8gVEVYVFVSRTogbXVsdGlwbHkgd2l0aCB0ZXhlbCBjb2xvclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxuICB2ZWM0IHZjdENvbG9yVGV4dHVyZSA9IHRleHR1cmUodV90ZXh0dXJlLCB2X3ZjdFRleHR1cmUpO1xuICB2Y3RGcmFnICo9IHZjdENvbG9yVGV4dHVyZTtcbiAgICAjZW5kaWZcblxuICAgIC8vIGRpc2NhcmQgcGl4ZWwgYWxsdG9nZXRoZXIgd2hlbiB0cmFuc3BhcmVudDogZG9uJ3Qgc2hvdyBpbiBaLUJ1ZmZlclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxuICAgIGRpc2NhcmQ7XG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclVuaXZlcnNhbC52ZXJ0XCJdID0gLypnbHNsKi8gYCN2ZXJzaW9uIDMwMCBlc1xuLyoqXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xuKiBAYXV0aG9ycyAyMDIxLCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXG4qL1xuXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5cbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybWF0aW9uXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9WaWV3O1xuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xuLy8gVE9ETzogdGhpbmsgYWJvdXQgbWFraW5nIHZlcnRleCBjb2xvciBvcHRpb25hbFxuaW4gdmVjNCBhX3ZjdENvbG9yO1xub3V0IHZlYzQgdl92Y3RDb2xvcjtcblxuICAvLyBQQVJUSUNMRTogb2ZmZXIgYnVmZmVyIGFuZCBmdW5jdGlvbmFsaXR5IGZvciBpbiBzaGFkZXIgcG9zaXRpb24gY2FsY3VsYXRpb25cbiAgLy8gQ0FNRVJBOiBvZmZlciBidWZmZXIgYW5kIGZ1bmN0aW9uYWxpdHkgZm9yIHNwZWN1bGFyIHJlZmxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjYW1lcmEtcG9zaXRpb25cbiAgI2lmIGRlZmluZWQoQ0FNRVJBKSB8fCBkZWZpbmVkKFBBUlRJQ0xFKVxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XG51bmlmb3JtIHZlYzMgdV92Y3RDYW1lcmE7XG4gICNlbmRpZlxuXG4gICNpZiBkZWZpbmVkKENBTUVSQSlcbnVuaWZvcm0gZmxvYXQgdV9mU3BlY3VsYXI7XG5cbmZsb2F0IGNhbGN1bGF0ZVJlZmxlY3Rpb24odmVjMyBfdmN0TGlnaHQsIHZlYzMgX3ZjdFZpZXcsIHZlYzMgX3ZjdE5vcm1hbCwgZmxvYXQgX2ZTcGVjdWxhcikge1xuICBpZihfZlNwZWN1bGFyIDw9IDAuMClcbiAgICByZXR1cm4gMC4wO1xuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdCgtX3ZjdExpZ2h0LCBfdmN0Tm9ybWFsKSk7XG4gIGZsb2F0IGZIaXRDYW1lcmEgPSBkb3QodmN0UmVmbGVjdGlvbiwgX3ZjdFZpZXcpO1xuICByZXR1cm4gcG93KG1heChmSGl0Q2FtZXJhLCAwLjApLCBfZlNwZWN1bGFyICogMTAuMCkgKiBfZlNwZWN1bGFyOyAvLyAxMC4wID0gbWFnaWMgbnVtYmVyLCBsb29rcyBnb29kLi4uIFxufVxuICAjZW5kaWZcblxuICAvLyBMSUdIVDogb2ZmZXIgYnVmZmVycyBmb3IgbGlnaHRpbmcgdmVydGljZXMgd2l0aCBkaWZmZXJlbnQgbGlnaHQgdHlwZXNcbiAgI2lmIGRlZmluZWQoTElHSFQpXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcbmluIHZlYzMgYV92Y3ROb3JtYWw7XG51bmlmb3JtIGZsb2F0IHVfZkRpZmZ1c2U7XG5cbnN0cnVjdCBMaWdodCB7XG4gIHZlYzQgdmN0Q29sb3I7XG4gIG1hdDQgbXR4U2hhcGU7XG4gIG1hdDQgbXR4U2hhcGVJbnZlcnNlO1xufTtcblxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTV1O1xuY29uc3QgdWludCBNQVhfTElHSFRTX1BPSU5UID0gMTAwdTtcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19TUE9UID0gMTAwdTtcblxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBMaWdodHMge1xuICB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xuICB1aW50IHVfbkxpZ2h0c1BvaW50O1xuICB1aW50IHVfbkxpZ2h0c1Nwb3Q7XG4gIExpZ2h0IHVfYW1iaWVudDtcbiAgTGlnaHQgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcbiAgTGlnaHQgdV9wb2ludFtNQVhfTElHSFRTX1BPSU5UXTtcbiAgTGlnaHQgdV9zcG90W01BWF9MSUdIVFNfU1BPVF07XG59O1xuXG52ZWM0IGlsbHVtaW5hdGVEaXJlY3RlZCh2ZWMzIF92Y3REaXJlY3Rpb24sIHZlYzMgX3ZjdE5vcm1hbCwgdmVjNCBfdmN0Q29sb3IsIHZlYzMgX3ZjdFZpZXcsIGZsb2F0IF9mU3BlY3VsYXIpIHtcbiAgdmVjNCB2Y3RSZXN1bHQgPSB2ZWM0KDAsIDAsIDAsIDEpO1xuICB2ZWMzIHZjdERpcmVjdGlvbiA9IG5vcm1hbGl6ZShfdmN0RGlyZWN0aW9uKTtcbiAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QoX3ZjdE5vcm1hbCwgdmN0RGlyZWN0aW9uKTtcbiAgaWYoZklsbHVtaW5hdGlvbiA+IDAuMGYpIHtcbiAgICB2Y3RSZXN1bHQgKz0gdV9mRGlmZnVzZSAqIGZJbGx1bWluYXRpb24gKiBfdmN0Q29sb3I7XG4gICAgICAgICNpZiBkZWZpbmVkKENBTUVSQSlcbiAgICBmbG9hdCBmUmVmbGVjdGlvbiA9IGNhbGN1bGF0ZVJlZmxlY3Rpb24odmN0RGlyZWN0aW9uLCBfdmN0VmlldywgX3ZjdE5vcm1hbCwgX2ZTcGVjdWxhcik7XG4gICAgdmN0UmVzdWx0ICs9IGZSZWZsZWN0aW9uICogX3ZjdENvbG9yO1xuICAgICAgICAjZW5kaWZcbiAgfVxuICByZXR1cm4gdmN0UmVzdWx0O1xufVxuICAjZW5kaWYgXG5cbiAgLy8gVEVYVFVSRTogb2ZmZXIgYnVmZmVycyBmb3IgVVZzIGFuZCBwaXZvdCBtYXRyaXhcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xuaW4gdmVjMiBhX3ZjdFRleHR1cmU7XG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XG4gICNlbmRpZlxuXG4gICNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xuaW4gdmVjMyBhX3ZjdE5vcm1hbDtcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xudW5pZm9ybSBtYXQ0IHVfbXR4V29ybGRUb0NhbWVyYTtcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcbiAgI2VuZGlmXG5cbiAgI2lmIGRlZmluZWQoUEhPTkcpXG5vdXQgdmVjMyB2X3ZjdE5vcm1hbDtcbm91dCB2ZWMzIHZfdmN0UG9zaXRpb247XG4gICNlbmRpZlxuXG4gICNpZiBkZWZpbmVkKEZMQVQpXG5vdXQgdmVjMyB2X3ZjdFBvc2l0aW9uO1xuZmxhdCBvdXQgdmVjMyB2X3ZjdFBvc2l0aW9uRmxhdDtcbiAgI2VuZGlmXG5cbiAgI2lmIGRlZmluZWQoU0tJTilcbnVuaWZvcm0gbWF0NCB1X210eFdvcmxkVG9WaWV3OyAvLyBcbi8vIEJvbmVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvZGV2L3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ19wYXJzX3ZlcnRleC5nbHNsLmpzXG5pbiB1dmVjNCBhX3ZjdEJvbmVzO1xuaW4gdmVjNCBhX3ZjdFdlaWdodHM7XG5jb25zdCB1aW50IE1BWF9CT05FUyA9IDI1NnU7IC8vIENBVVRJT046IHRoaXMgbnVtYmVyIG11c3QgYmUgdGhlIHNhbWUgYXMgaW4gUmVuZGVySW5qZWN0b3JTa2VsZXRvbkluc3RhbmNlIHdoZXJlIHRoZSBjb3JyZXNwb25kaW5nIGJ1ZmZlcnMgYXJlIGNyZWF0ZWRcbmxheW91dCAoc3RkMTQwKSB1bmlmb3JtIFNraW4ge1xuICBtYXQ0IHVfbXR4Qm9uZXNbTUFYX0JPTkVTXTtcbn07XG4gICNlbmRpZlxuXG4gICNpZiBkZWZpbmVkKFBBUlRJQ0xFKVxudW5pZm9ybSBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7XG51bmlmb3JtIGZsb2F0IHVfZlBhcnRpY2xlU3lzdGVtRHVyYXRpb247XG51bmlmb3JtIGZsb2F0IHVfZlBhcnRpY2xlU3lzdGVtU2l6ZTtcbnVuaWZvcm0gZmxvYXQgdV9mUGFydGljbGVTeXN0ZW1UaW1lO1xudW5pZm9ybSBzYW1wbGVyMkQgdV9mUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzO1xudW5pZm9ybSBib29sIHVfYlBhcnRpY2xlU3lzdGVtRmFjZUNhbWVyYTtcbnVuaWZvcm0gYm9vbCB1X2JQYXJ0aWNsZVN5c3RlbVJlc3RyaWN0O1xuXG5tYXQ0IGxvb2tBdCh2ZWMzIF92Y3RUcmFuc2xhdGlvbiwgdmVjMyBfdmN0VGFyZ2V0KSB7XG4gIHZlYzMgdmN0VXAgPSB2ZWMzKDAuMCwgMS4wLCAwLjApO1xuICB2ZWMzIHpBeGlzID0gbm9ybWFsaXplKF92Y3RUYXJnZXQgLSBfdmN0VHJhbnNsYXRpb24pO1xuICB2ZWMzIHhBeGlzID0gbm9ybWFsaXplKGNyb3NzKHZjdFVwLCB6QXhpcykpO1xuICB2ZWMzIHlBeGlzID0gdV9iUGFydGljbGVTeXN0ZW1SZXN0cmljdCA/IHZjdFVwIDogbm9ybWFsaXplKGNyb3NzKHpBeGlzLCB4QXhpcykpO1xuICB6QXhpcyA9IHVfYlBhcnRpY2xlU3lzdGVtUmVzdHJpY3QgPyBub3JtYWxpemUoY3Jvc3MoeEF4aXMsIHZjdFVwKSkgOiB6QXhpcztcblxuICByZXR1cm4gbWF0NChcbiAgICB4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCAwLjAsXG4gICAgeUF4aXMueCwgeUF4aXMueSwgeUF4aXMueiwgMC4wLFxuICAgIHpBeGlzLngsIHpBeGlzLnksIHpBeGlzLnosIDAuMCxcbiAgICBfdmN0VHJhbnNsYXRpb24ueCwgIF92Y3RUcmFuc2xhdGlvbi55LCAgX3ZjdFRyYW5zbGF0aW9uLnosIDEuMFxuICApO1xufVxuXG5mbG9hdCBmZXRjaFJhbmRvbU51bWJlcihpbnQgX2lJbmRleCwgaW50IF9pUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSwgaW50IF9pUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzTGVuZ3RoKSB7XG4gIF9pSW5kZXggPSBfaUluZGV4ICUgX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGg7XG4gIHJldHVybiB0ZXhlbEZldGNoKHVfZlBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVycywgaXZlYzIoX2lJbmRleCAlIF9pUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSwgX2lJbmRleCAvIF9pUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSksIDApLnI7XG59XG4gICNlbmRpZlxuXG52b2lkIG1haW4oKSB7XG4gIHZlYzQgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XG5cbiAgICAjaWYgZGVmaW5lZChDQU1FUkEpIHx8IGRlZmluZWQoUEFSVElDTEUpIHx8IGRlZmluZWQoU0tJTikgfHwgZGVmaW5lZChNQVRDQVApXG4gIG1hdDQgbXR4TWVzaFRvV29ybGQgPSB1X210eE1lc2hUb1dvcmxkO1xuICAgICNlbmRpZlxuXG4gICAgI2lmIGRlZmluZWQoUEFSVElDTEUpXG4gIGZsb2F0IGZQYXJ0aWNsZUlkID0gZmxvYXQoZ2xfSW5zdGFuY2VJRCk7XG4gIGludCBpUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSA9IHRleHR1cmVTaXplKHVfZlBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVycywgMCkueDsgLy8gdGhlIGRpbWVuc2lvbiBvZiB0aGUgcXVhZHJhdGljIHRleHR1cmVcbiAgaW50IGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGggPSBpUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSAqIGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNTaXplOyAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHRleGVscyBpbiB0aGUgdGV4dHVyZVxuICAvKiR2YXJpYWJsZXMqL1xuICAvKiRtdHhMb2NhbCovXG4gIC8qJG10eFdvcmxkKi9cbiAgbXR4TWVzaFRvV29ybGQgPSAvKiRtdHhXb3JsZCovIG10eE1lc2hUb1dvcmxkIC8qJG10eExvY2FsKi87XG4gIGlmICh1X2JQYXJ0aWNsZVN5c3RlbUZhY2VDYW1lcmEpIFxuICAgIG10eE1lc2hUb1dvcmxkID0gXG4gICAgICBsb29rQXQodmVjMyhtdHhNZXNoVG9Xb3JsZFszXVswXSwgbXR4TWVzaFRvV29ybGRbM11bMV0sIG10eE1lc2hUb1dvcmxkWzNdWzJdKSwgdV92Y3RDYW1lcmEpICogXG4gICAgICBtYXQ0KFxuICAgICAgICBsZW5ndGgodmVjMyhtdHhNZXNoVG9Xb3JsZFswXVswXSwgbXR4TWVzaFRvV29ybGRbMV1bMF0sIG10eE1lc2hUb1dvcmxkWzJdWzBdKSksIDAuMCwgMC4wLCAwLjAsXG4gICAgICAgIDAuMCwgbGVuZ3RoKHZlYzMobXR4TWVzaFRvV29ybGRbMF1bMV0sIG10eE1lc2hUb1dvcmxkWzFdWzFdLCBtdHhNZXNoVG9Xb3JsZFsyXVsxXSkpLCAwLjAsIDAuMCxcbiAgICAgICAgMC4wLCAwLjAsIGxlbmd0aCh2ZWMzKG10eE1lc2hUb1dvcmxkWzBdWzJdLCBtdHhNZXNoVG9Xb3JsZFsxXVsyXSwgbXR4TWVzaFRvV29ybGRbMl1bMl0pKSwgMC4wLFxuICAgICAgICAwLjAsIDAuMCwgMC4wLCAxLjBcbiAgICAgICk7XG4gIG1hdDQgbXR4TWVzaFRvVmlldyA9IHVfbXR4V29ybGRUb1ZpZXcgKiBtdHhNZXNoVG9Xb3JsZDtcbiAgICAjZWxzZVxuICBtYXQ0IG10eE1lc2hUb1ZpZXcgPSB1X210eE1lc2hUb1ZpZXc7XG4gICAgI2VuZGlmXG5cbiAgICAjaWYgZGVmaW5lZChMSUdIVCkgfHwgZGVmaW5lZChNQVRDQVApXG4gIHZlYzMgdmN0Tm9ybWFsID0gYV92Y3ROb3JtYWw7XG4gICAgICAjaWYgZGVmaW5lZChQQVJUSUNMRSlcbiAgbWF0NCBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHRyYW5zcG9zZShpbnZlcnNlKG10eE1lc2hUb1dvcmxkKSk7XG4gICAgICAjZWxzZVxuICBtYXQ0IG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcbiAgICAgICNlbmRpZlxuICAgICNlbmRpZlxuXG4gICAgI2lmIGRlZmluZWQoU0tJTilcbiAgbXR4TWVzaFRvV29ybGQgPSBhX3ZjdFdlaWdodHMueCAqIHVfbXR4Qm9uZXNbYV92Y3RCb25lcy54XSArXG4gICAgYV92Y3RXZWlnaHRzLnkgKiB1X210eEJvbmVzW2FfdmN0Qm9uZXMueV0gK1xuICAgIGFfdmN0V2VpZ2h0cy56ICogdV9tdHhCb25lc1thX3ZjdEJvbmVzLnpdICtcbiAgICBhX3ZjdFdlaWdodHMudyAqIHVfbXR4Qm9uZXNbYV92Y3RCb25lcy53XTtcbiAgXG4gIG10eE1lc2hUb1ZpZXcgPSB1X210eFdvcmxkVG9WaWV3ICogbXR4TWVzaFRvV29ybGQ7XG4gIG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdHJhbnNwb3NlKGludmVyc2UobXR4TWVzaFRvV29ybGQpKTtcbiAgICAjZW5kaWZcblxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBhbmQgbm9ybWFsIGFjY29yZGluZyB0byBpbnB1dCBhbmQgZGVmaW5lc1xuICBnbF9Qb3NpdGlvbiA9IG10eE1lc2hUb1ZpZXcgKiB2Y3RQb3NpdGlvbjtcbiAgdl92Y3RDb2xvciA9IGFfdmN0Q29sb3I7XG5cbiAgICAjaWYgZGVmaW5lZChDQU1FUkEpIHx8IGRlZmluZWQoTUFUQ0FQKVxuICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodmVjMyhtdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uKSAtIHVfdmN0Q2FtZXJhKTtcbiAgICAjZW5kaWZcblxuICAgICNpZiBkZWZpbmVkKExJR0hUKVxuICB2Y3ROb3JtYWwgPSBtYXQzKG10eE5vcm1hbE1lc2hUb1dvcmxkKSAqIHZjdE5vcm1hbDtcblxuICAgICAgI2lmIGRlZmluZWQoUEhPTkcpXG4gIHZfdmN0Tm9ybWFsID0gdmN0Tm9ybWFsOyAvLyBwYXNzIG5vcm1hbCB0byBmcmFnbWVudCBzaGFkZXJcbiAgdl92Y3RQb3NpdGlvbiA9IHZlYzMobXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbik7XG4gICAgICAjZW5kaWZcblxuICAgICAgI2lmIGRlZmluZWQoRkxBVClcbiAgdl92Y3RQb3NpdGlvbiA9IHZlYzMobXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbik7XG4gIHZfdmN0UG9zaXRpb25GbGF0ID0gdl92Y3RQb3NpdGlvbjtcbiAgICAgICNlbmRpZlxuXG4gICAgI2lmICFkZWZpbmVkKFBIT05HKSAmJiAhZGVmaW5lZChGTEFUKSAvLyBnb3VyYXVkXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZSh2Y3ROb3JtYWwpO1xuICB2X3ZjdENvbG9yID0gdV9mRGlmZnVzZSAqIHVfYW1iaWVudC52Y3RDb2xvcjtcblxuICAvLyBjYWxjdWxhdGUgZGlyZWN0aW9uYWwgbGlnaHQgZWZmZWN0XG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcbiAgICB2ZWMzIHZjdERpcmVjdGlvbiA9IHZlYzModV9kaXJlY3Rpb25hbFtpXS5tdHhTaGFwZSAqIHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKSk7XG4gICAgdl92Y3RDb2xvciArPSBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3IsIHZjdFZpZXcsIHVfZlNwZWN1bGFyKTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBwb2ludCBsaWdodCBlZmZlY3RcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzUG9pbnQ7IGkrKykge1xuICAgIHZlYzMgdmN0UG9zaXRpb25MaWdodCA9IHZlYzModV9wb2ludFtpXS5tdHhTaGFwZSAqIHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKSk7XG4gICAgdmVjMyB2Y3REaXJlY3Rpb24gPSB2ZWMzKG10eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb24pIC0gdmN0UG9zaXRpb25MaWdodDtcbiAgICBmbG9hdCBmSW50ZW5zaXR5ID0gMS4wIC0gbGVuZ3RoKG1hdDModV9wb2ludFtpXS5tdHhTaGFwZUludmVyc2UpICogdmN0RGlyZWN0aW9uKTtcbiAgICBpZihmSW50ZW5zaXR5IDwgMC4wKVxuICAgICAgY29udGludWU7XG4gICAgdl92Y3RDb2xvciArPSBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3ROb3JtYWwsIGZJbnRlbnNpdHkgKiB1X3BvaW50W2ldLnZjdENvbG9yLCB2Y3RWaWV3LCB1X2ZTcGVjdWxhcik7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgc3BvdCBsaWdodCBlZmZlY3RcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzU3BvdDsgaSsrKSB7XG4gICAgdmVjMyB2Y3RQb3NpdGlvbkxpZ2h0ID0gdmVjMyh1X3Nwb3RbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkpO1xuICAgIHZlYzMgdmN0RGlyZWN0aW9uID0gdmVjMyhtdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uKSAtIHZjdFBvc2l0aW9uTGlnaHQ7XG4gICAgdmVjMyB2Y3REaXJlY3Rpb25JbnZlcnRlZCA9IG1hdDModV9zcG90W2ldLm10eFNoYXBlSW52ZXJzZSkgKiB2Y3REaXJlY3Rpb247XG4gICAgaWYodmN0RGlyZWN0aW9uSW52ZXJ0ZWQueiA8PSAwLjApXG4gICAgICBjb250aW51ZTtcbiAgICBmbG9hdCBmSW50ZW5zaXR5ID0gMS4wIC0gbWluKDEuMCwgMi4wICogbGVuZ3RoKHZjdERpcmVjdGlvbkludmVydGVkLnh5KSAvIHZjdERpcmVjdGlvbkludmVydGVkLnopO1xuICAgIGZJbnRlbnNpdHkgKj0gMS4wIC0gcG93KHZjdERpcmVjdGlvbkludmVydGVkLnosIDIuMCk7XG4gICAgaWYoZkludGVuc2l0eSA8IDAuMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIHZfdmN0Q29sb3IgKz0gaWxsdW1pbmF0ZURpcmVjdGVkKHZjdERpcmVjdGlvbiwgdmN0Tm9ybWFsLCBmSW50ZW5zaXR5ICogdV9zcG90W2ldLnZjdENvbG9yLCB2Y3RWaWV3LCB1X2ZTcGVjdWxhcik7XG4gIH1cbiAgXG4gIHZfdmN0Q29sb3IgKj0gYV92Y3RDb2xvcjtcbiAgICAgICNlbmRpZiAvLyBQSE9OR1xuICAgICNlbmRpZlxuXG4gICAgLy8gVEVYVFVSRTogdHJhbnNmb3JtIFVWc1xuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpXG4gIHZfdmN0VGV4dHVyZSA9IHZlYzIodV9tdHhQaXZvdCAqIHZlYzMoYV92Y3RUZXh0dXJlLCAxLjApKS54eTtcbiAgICAjZW5kaWZcblxuICAgICNpZiBkZWZpbmVkKE1BVENBUClcbiAgdmVjNCB2Y3RWZXJ0ZXhJbkNhbWVyYSA9IG5vcm1hbGl6ZSh1X210eFdvcmxkVG9DYW1lcmEgKiB2Y3RQb3NpdGlvbik7XG4gIHZjdFZlcnRleEluQ2FtZXJhLnh5ICo9IC0xLjA7XG4gIG1hdDQgbXR4X1JvdFggPSBtYXQ0KDEsIDAsIDAsIDAsIDAsIHZjdFZlcnRleEluQ2FtZXJhLnosIHZjdFZlcnRleEluQ2FtZXJhLnksIDAsIDAsIC12Y3RWZXJ0ZXhJbkNhbWVyYS55LCB2Y3RWZXJ0ZXhJbkNhbWVyYS56LCAwLCAwLCAwLCAwLCAxKTtcbiAgbWF0NCBtdHhfUm90WSA9IG1hdDQodmN0VmVydGV4SW5DYW1lcmEueiwgMCwgLXZjdFZlcnRleEluQ2FtZXJhLngsIDAsIDAsIDEsIDAsIDAsIHZjdFZlcnRleEluQ2FtZXJhLngsIDAsIHZjdFZlcnRleEluQ2FtZXJhLnosIDAsIDAsIDAsIDAsIDEpO1xuXG4gIHZjdE5vcm1hbCA9IG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbDtcblxuICAvLyBhZGRzIGNvcnJlY3Rpb24gZm9yIHRoaW5ncyBiZWluZyBmYXIgYW5kIHRvIHRoZSBzaWRlLCBidXQgZGlzdG9ydGlvbiBmb3IgdGhpbmdzIGJlaW5nIGNsb3NlXG4gIHZjdE5vcm1hbCA9IG1hdDMobXR4X1JvdFggKiBtdHhfUm90WSkgKiB2Y3ROb3JtYWw7XG4gIFxuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUobWF0Myh1X210eFdvcmxkVG9DYW1lcmEpICogbm9ybWFsaXplKHZjdE5vcm1hbCkpO1xuICB2Y3RSZWZsZWN0aW9uLnkgPSAtdmN0UmVmbGVjdGlvbi55O1xuXG4gIHZfdmN0VGV4dHVyZSA9IDAuNSAqIHZjdFJlZmxlY3Rpb24ueHkgKyAwLjU7XG4gICAgI2VuZGlmXG5cbiAgICAjaWYgZGVmaW5lZChQQVJUSUNMRV9DT0xPUilcbiAgdmVjNCB2Y3RQYXJ0aWNsZUNvbG9yID0gLyokY29sb3IqLztcbiAgICAgICNpZiBkZWZpbmVkKExJR0hUKVxuICB2X3ZjdENvbG9yICo9IHZjdFBhcnRpY2xlQ29sb3I7XG4gIHZfdmN0Q29sb3IuYSA9IHZjdFBhcnRpY2xlQ29sb3IuYTtcbiAgICAgICNlbHNlXG4gIHZfdmN0Q29sb3IgPSB2Y3RQYXJ0aWNsZUNvbG9yO1xuICAgICAgI2VuZGlmXG4gICAgI2Vsc2VcbiAgICAvLyBhbHdheXMgZnVsbCBvcGFjaXR5IGZvciBub3cuLi5cbiAgICAgICNpZiBkZWZpbmVkKExJR0hUKVxuICB2X3ZjdENvbG9yLmEgPSAxLjA7XG4gICAgICAjZW5kaWZcbiAgICAjZW5kaWZcbn1gO1xuXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9Db2F0L0NvYXQudHNcIi8+XG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcblxuICAvKipcbiAgICogSW50ZXJmYWNlIHRvIGFjY2VzcyBkYXRhIGZyb20gYSBXZWJHbCBzaGFkZXJwcm9ncmFtLiBcbiAgICogVGhpcyBzaG91bGQgYWx3YXlzIG1pcnJvciB0aGUgKHN0YXRpYykgaW50ZXJmYWNlIG9mIHtAbGluayBTaGFkZXJ9LiBJdCBleHBvc2VzIHRoZSBzdGF0aWMgbWVtYmVycyBvZiBTaGFkZXIgaW4gYW4gaW5zdGFuY2UtYmFzZWQgd2F5LiBlLmcuOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGxldCBzaGFkZXI6IFNoYWRlckludGVyZmFjZTtcbiAgICogYGBgXG4gICAqIGNhbiB0YWtlIHZhbHVlcyBvZiB0eXBlIFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIHR5cGVvZiBTaGFkZXIgfCBTaGFkZXJJbnRlZmFjZVxuICAgKiBgYGBcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2hhZGVySW50ZXJmYWNlIHtcbiAgICBkZWZpbmU6IHN0cmluZ1tdO1xuICAgIHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcbiAgICBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcbiAgICB1bmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfTtcbiAgICAvKiogUmV0dXJucyB0aGUgdmVydGV4IHNoYWRlciBzb3VyY2UgY29kZSBmb3IgdGhlIHJlbmRlciBlbmdpbmUgKi9cbiAgICBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nO1xuICAgIC8qKiBSZXR1cm5zIHRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGNvZGUgZm9yIHRoZSByZW5kZXIgZW5naW5lICovXG4gICAgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nO1xuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0ZWQgYnkgZGVjb3JhdG9yLiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLiAqL1xuICAgIGRlbGV0ZVByb2dyYW0odGhpczogU2hhZGVySW50ZXJmYWNlKTogdm9pZDtcbiAgICAvKiogQGludGVybmFsIEluamVjdGVkIGJ5IGRlY29yYXRvci4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS4gKi9cbiAgICB1c2VQcm9ncmFtKHRoaXM6IFNoYWRlckludGVyZmFjZSk6IHZvaWQ7XG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RlZCBieSBkZWNvcmF0b3IuIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uICovXG4gICAgY3JlYXRlUHJvZ3JhbSh0aGlzOiBTaGFkZXJJbnRlcmZhY2UpOiB2b2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBzdXBlcmNsYXNzIGZvciB0aGUgcmVwcmVzZW50YXRpb24gb2YgV2ViR2wgc2hhZGVycHJvZ3JhbXMuIFxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XG4gICAqL1xuICAvLyBUT0RPOiBkZWZpbmUgYXR0cmlidXRlL3VuaWZvcm1zIGFzIGxheW91dCBhbmQgdXNlIHRob3NlIGNvbnNpc3RlbnRseSBpbiBzaGFkZXJzXG4gIEBSZW5kZXJJbmplY3RvclNoYWRlci5kZWNvcmF0ZVxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyIHtcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgU2hhZGVyID0gU2hhZGVyO1xuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBTaGFkZXJbXSA9IFtdO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdO1xuICAgIC8vIHB1YmxpYyBzdGF0aWMgdmVydGV4U2hhZGVyU291cmNlOiBzdHJpbmc7XG4gICAgLy8gcHVibGljIHN0YXRpYyBmcmFnbWVudFNoYWRlclNvdXJjZTogc3RyaW5nO1xuXG4gICAgcHVibGljIHN0YXRpYyBwcm9ncmFtOiBXZWJHTFByb2dyYW07XG4gICAgcHVibGljIHN0YXRpYyBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcbiAgICBwdWJsaWMgc3RhdGljIHVuaWZvcm1zOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9O1xuXG4gICAgLyoqIFRoZSB0eXBlIG9mIGNvYXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoaXMgc2hhZGVyIHRvIGNyZWF0ZSBhIG1hdGVyaWFsICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRDb2xvcmVkOyB9XG4gICAgLyoqIFJldHVybnMgdGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGNvZGUgZm9yIHRoZSByZW5kZXIgZW5naW5lICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclVuaXZlcnNhbC52ZXJ0XCJdLCB0aGlzLmRlZmluZSk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGNvZGUgZm9yIHRoZSByZW5kZXIgZW5naW5lICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyVW5pdmVyc2FsLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJ9LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cbiAgICAvKiogQGludGVybmFsIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclNoYWRlcn0uIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uICovXG4gICAgcHVibGljIHN0YXRpYyB1c2VQcm9ncmFtKHRoaXM6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS4gKi8gLy8gVE9ETzogbWF5YmUgZG9uJ3QgZmxhZyB0aGlzIGFzIGludGVybmFsLCBzbyBzaGFkZXJzIGNhbiBiZSBwcmVjb21waWxlZCBpbiBmdXR1cmUgRlVER0UgYXBwcy4gT3IgY3JlYXRlIGFuIEFQSSB0byBwcmVjb21waWxlIHNoYWRlcnMsIGxvYWQgdGV4dHVyZXMgZXRjLlxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBTaGFkZXIpOiBudW1iZXIgeyByZXR1cm4gU2hhZGVyLnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxuXG4gICAgLy8gcmVwbGFjZSB0aGUgbWFuZGF0b3J5IGhlYWRlciBvZiB0aGUgc2hhZGVyIHdpdGggaXRzZWxmIHBsdXMgdGhlIGRlZmluaXRpb25zIGdpdmVuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbnNlcnREZWZpbmVzKF9zaGFkZXI6IHN0cmluZywgX2RlZmluZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICAgIGlmICghX2RlZmluZXMpXG4gICAgICAgIHJldHVybiBfc2hhZGVyO1xuXG4gICAgICBsZXQgY29kZTogc3RyaW5nID0gXCIjdmVyc2lvbiAzMDAgZXNcXG5cIjtcbiAgICAgIGZvciAobGV0IGRlZmluZSBvZiBfZGVmaW5lcylcbiAgICAgICAgY29kZSArPSBgI2RlZmluZSAke2RlZmluZX1cXG5gO1xuXG4gICAgICByZXR1cm4gX3NoYWRlci5yZXBsYWNlKFwiI3ZlcnNpb24gMzAwIGVzXCIsIGNvZGUpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdCBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXQpO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJMSUdIVFwiLFxuICAgICAgXCJDQU1FUkFcIixcbiAgICAgIFwiRkxBVFwiXG4gICAgXTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlOyB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJQaG9uZy5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0U2tpbiBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXRTa2luKTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcbiAgICAgIFwiTElHSFRcIixcbiAgICAgIFwiQ0FNRVJBXCIsXG4gICAgICBcIkZMQVRcIixcbiAgICAgIFwiU0tJTlwiXG4gICAgXTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlOyB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJQaG9uZy5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0VGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJGbGF0VGV4dHVyZWQpO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJMSUdIVFwiLFxuICAgICAgXCJDQU1FUkFcIixcbiAgICAgIFwiRkxBVFwiLFxuICAgICAgXCJURVhUVVJFXCJcbiAgICBdO1xuXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGhvbmcuZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdFRleHR1cmVkU2tpbiBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXRUZXh0dXJlZFNraW4pO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJMSUdIVFwiLFxuICAgICAgXCJDQU1FUkFcIixcbiAgICAgIFwiRkxBVFwiLFxuICAgICAgXCJURVhUVVJFXCIsXG4gICAgICBcIlNLSU5cIlxuICAgIF07XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJQaG9uZy5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJHb3VyYXVkIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyR291cmF1ZCk7XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgICBcIkxJR0hUXCIsXG4gICAgICBcIkNBTUVSQVwiXG4gICAgXTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlOyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckdvdXJhdWRTa2luIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyR291cmF1ZFNraW4pO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJMSUdIVFwiLFxuICAgICAgXCJTS0lOXCIsXG4gICAgICBcIkNBTUVSQVwiXG4gICAgXTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlOyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckdvdXJhdWRUZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckdvdXJhdWRUZXh0dXJlZCk7XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgICBcIkxJR0hUXCIsXG4gICAgICBcIlRFWFRVUkVcIixcbiAgICAgIFwiQ0FNRVJBXCJcbiAgICBdO1xuXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJHb3VyYXVkVGV4dHVyZWRTa2luIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyR291cmF1ZFRleHR1cmVkU2tpbik7XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgICBcIkxJR0hUXCIsXG4gICAgICBcIlRFWFRVUkVcIixcbiAgICAgIFwiQ0FNRVJBXCIsXG4gICAgICBcIlNLSU5cIlxuICAgIF07XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckxpdCBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckxpdCk7XG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW107XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckxpdFNraW4gZXh0ZW5kcyBTaGFkZXIge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJMaXRTa2luKTtcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgICBcIlNLSU5cIlxuICAgIF07XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckxpdFRleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTGl0VGV4dHVyZWQpO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJURVhUVVJFXCJcbiAgICBdO1xuXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUZXh0dXJlZDsgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJMaXRUZXh0dXJlZFNraW4gZXh0ZW5kcyBTaGFkZXIge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJMaXRUZXh0dXJlZFNraW4pO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJURVhUVVJFXCIsXG4gICAgICBcIlNLSU5cIlxuICAgIF07XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFRleHR1cmVkOyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlck1hdENhcCBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlck1hdENhcCk7XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgICBcIk1BVENBUFwiLFxuICAgICAgXCJDQU1FUkFcIlxuICAgIF07XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFRleHR1cmVkOyB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyUGhvbmcpO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJMSUdIVFwiLFxuICAgICAgXCJDQU1FUkFcIixcbiAgICAgIFwiUEhPTkdcIlxuICAgIF07XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGhvbmcuZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGhvbmdTa2luIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyUGhvbmdTa2luKTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcbiAgICAgIFwiTElHSFRcIixcbiAgICAgIFwiQ0FNRVJBXCIsXG4gICAgICBcIlBIT05HXCIsXG4gICAgICBcIlNLSU5cIlxuICAgIF07XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGhvbmcuZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGhvbmdUZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclBob25nVGV4dHVyZWQpO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJMSUdIVFwiLFxuICAgICAgXCJDQU1FUkFcIixcbiAgICAgIFwiUEhPTkdcIixcbiAgICAgIFwiVEVYVFVSRVwiXG4gICAgXTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlVGV4dHVyZWQ7IH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBob25nLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcbiAgICB9XG4gIH1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nVGV4dHVyZWRTa2luIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyUGhvbmdUZXh0dXJlZFNraW4pO1xuXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgICAgXCJMSUdIVFwiLFxuICAgICAgXCJDQU1FUkFcIixcbiAgICAgIFwiUEhPTkdcIixcbiAgICAgIFwiVEVYVFVSRVwiLFxuICAgICAgXCJTS0lOXCJcbiAgICBdO1xuXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGhvbmcuZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGljayBleHRlbmRzIFNoYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2sudmVydFwiXSwgdGhpcy5kZWZpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2suZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGlja1RleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJQaWNrVGV4dHVyZWQudmVydFwiXSwgdGhpcy5kZWZpbmUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2tUZXh0dXJlZC5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKiB7QGxpbmsgVGV4SW1hZ2VTb3VyY2V9IGlzIGEgdW5pb24gdHlwZSB3aGljaCBhcyBvZiBub3cgaW5jbHVkZXMge0BsaW5rIFZpZGVvRnJhbWV9LiBBbGwgb3RoZXIgcGFydHMgb2YgdGhpcyB1bmlvbiBoYXZlIGEgLndpZHRoIGFuZCAuaGVpZ2h0IHByb3BlcnR5IGJ1dCBWaWRlb0ZyYW1lIGRvZXMgbm90LiBBbmQgc2luY2Ugd2Ugb25seSBldmVyIHVzZSB7QGxpbmsgSFRNTEltYWdlRWxlbWVudH0gYW5kIHtAbGluayBPZmZzY3JlZW5DYW52YXN9IGN1cnJlbnRseSBWaWRlb0ZyYW1lIGNhbiBiZSBleGNsdWRlZCBmb3IgY29udmVuaWVuY2Ugb2YgYWNjZXNzaW5nIC53aWR0aCBhbmQgLmhlaWdodCAqL1xuICB0eXBlIEltYWdlU291cmNlID0gRXhjbHVkZTxUZXhJbWFnZVNvdXJjZSwgVmlkZW9GcmFtZT47XG5cbiAgZXhwb3J0IGVudW0gTUlQTUFQIHtcbiAgICBDUklTUCwgTUVESVVNLCBCTFVSUllcbiAgfVxuICAvKipcbiAgICogQmFzZWNsYXNzIGZvciBkaWZmZXJlbnQga2luZHMgb2YgdGV4dHVyZXMuIFxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKi9cbiAgQFJlbmRlckluamVjdG9yVGV4dHVyZS5kZWNvcmF0ZVxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dHVyZSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xuICAgIHB1YmxpYyBtaXBtYXA6IE1JUE1BUCA9IE1JUE1BUC5DUklTUDtcbiAgICAvKiogQGludGVybmFsIEEgbWFwIG9mIHRleHR1cmVzLiBVc2VkIGJ5IHRoZSByZW5kZXIgZW5naW5lICovXG4gICAgcHJvdGVjdGVkIHJlbmRlckRhdGE6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9OyAvLyBUT0RPOiBjaGVjayBpZiBhIG1hcCBpcyBuZWNlc3NhcnkgaGVyZSwgdGhlIGNvcnJlc3BvbmRpbmcgcmVuZGVyIGluamVjdG9yIG9ubHkgZXZlciBhY2Nlc3NlcyBcInRleHR1cmUwXCJcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJUZXh0dXJlXCIpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW5kIGJpbmRzIHRoZSB0ZXh0dXJlIGluIFdlYkdMIGZyb20gdGhlIHtAbGluayB0ZXhJbWFnZVNvdXJjZX0uIFxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclRleHR1cmV9LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBpbiBXZWJHTCBmcmVlaW5nIHRoZSBhbGxvY2F0ZWQgZ3B1IG1lbW9yeS5cbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JUZXh0dXJlfS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVsZXRlUmVuZGVyRGF0YSgpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cblxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgaW1hZ2UgZGF0YSBpbiB0aGUgcmVuZGVyIGVuZ2luZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVmcmVzaCgpOiB2b2lkIHtcbiAgICAgIHRoaXMuZGVsZXRlUmVuZGVyRGF0YSgpO1xuICAgIH1cblxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG1pcG1hcDogTUlQTUFQW3RoaXMubWlwbWFwXVxuICAgICAgfTtcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xuICAgIH1cbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XG4gICAgICB0aGlzLm1pcG1hcCA9IDxudW1iZXI+PHVua25vd24+TUlQTUFQW19zZXJpYWxpemF0aW9uLm1pcG1hcF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcbiAgICAgIGlmICh0eXBlcy5taXBtYXApXG4gICAgICAgIHR5cGVzLm1pcG1hcCA9IE1JUE1BUDtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xuICAgICAgZGVsZXRlIF9tdXRhdG9yLmlkUmVzb3VyY2U7XG4gICAgICBkZWxldGUgX211dGF0b3IucmVuZGVyRGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGV4dHVyZSBjcmVhdGVkIGZyb20gYW4gZXhpc3RpbmcgaW1hZ2VcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlSW1hZ2UgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgICBwdWJsaWMgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBudWxsO1xuICAgIHB1YmxpYyB1cmw6IFJlcXVlc3RJbmZvO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF91cmw/OiBSZXF1ZXN0SW5mbykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGlmIChfdXJsKSB7XG4gICAgICAgIHRoaXMubG9hZChfdXJsKTtcbiAgICAgICAgdGhpcy5uYW1lID0gX3VybC50b1N0cmluZygpLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBpbWFnZSBmcm9tIHRoZSBnaXZlbiB1cmxcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgdGhpcy51cmwgPSBfdXJsO1xuICAgICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgLy8gY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgd2luZG93LmZldGNoKHRoaXMudXJsKTtcbiAgICAgIC8vIGNvbnN0IGJsb2I6IEJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAvLyBsZXQgb2JqZWN0VVJMOiBzdHJpbmcgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgLy8gdGhpcy5pbWFnZS5zcmMgPSBvYmplY3RVUkw7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJEYXRhID0gbnVsbDsgLy8gcmVmcmVzaCByZW5kZXIgZGF0YSBvbiBuZXh0IGRyYXcgY2FsbFxuICAgICAgICAgIF9yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiBfcmVqZWN0KCkpO1xuICAgICAgICB0aGlzLmltYWdlLnNyYyA9IG5ldyBVUkwodGhpcy51cmwudG9TdHJpbmcoKSwgUHJvamVjdC5iYXNlVVJMKS50b1N0cmluZygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSwgLy8gc2VyaWFsaXplIGZvciBlZGl0b3Igdmlld3NcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxuICAgICAgfTtcbiAgICB9XG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcbiAgICAgIGF3YWl0IHRoaXMubG9hZChfc2VyaWFsaXphdGlvbi51cmwpO1xuICAgICAgLy8gdGhpcy50eXBlIGlzIGFuIGFjY2Vzc29yIG9mIE11dGFibGUgZG9lc24ndCBuZWVkIHRvIGJlIGRlc2VyaWFsaXplZFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKF9tdXRhdG9yLnVybCAhPSB0aGlzLnVybC50b1N0cmluZygpKVxuICAgICAgICBhd2FpdCB0aGlzLmxvYWQoX211dGF0b3IudXJsKTtcbiAgICAgIC8vIGV4Y2VwdCB1cmwgZnJvbSBtdXRhdG9yIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICAgIGRlbGV0ZSAoX211dGF0b3IudXJsKTtcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XG4gICAgICAvLyBUT0RPOiBleGFtaW5lIG5lY2Vzc2l0eSB0byByZWNvbnN0cnVjdCwgaWYgbXV0YXRvciBpcyBrZXB0IGJ5IGNhbGxlclxuICAgICAgLy8gX211dGF0b3IudXJsID0gdGhpcy51cmw7IFxuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIGNhbnZhc1xuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVCYXNlNjQgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgICBwdWJsaWMgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfYmFzZTY0OiBzdHJpbmcsIF9taXBtYXA6IE1JUE1BUCA9IE1JUE1BUC5DUklTUCkge1xuICAgICAgc3VwZXIoX25hbWUpO1xuICAgICAgdGhpcy5pbWFnZS5zcmMgPSBfYmFzZTY0O1xuICAgICAgdGhpcy5taXBtYXAgPSBfbWlwbWFwO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGV4dHVyZSBjcmVhdGVkIGZyb20gYSBjYW52YXNcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlQ2FudmFzIGV4dGVuZHMgVGV4dHVyZSB7XG4gICAgcHVibGljIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgICBzdXBlcihfbmFtZSk7XG4gICAgICB0aGlzLmNyYzIgPSBfY3JjMjtcbiAgICB9XG4gICAgcHVibGljIGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBJbWFnZVNvdXJjZSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmMyLmNhbnZhcztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgRlVER0UtU2tldGNoXG4gICAqL1xuICBleHBvcnQgY2xhc3MgVGV4dHVyZVNrZXRjaCBleHRlbmRzIFRleHR1cmVDYW52YXMge1xuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhbiBIVE1MLXBhZ2VcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlSFRNTCBleHRlbmRzIFRleHR1cmVDYW52YXMge1xuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlRGVmYXVsdCBleHRlbmRzIFRleHR1cmVCYXNlNjQge1xuICAgIHB1YmxpYyBzdGF0aWMgdGV4dHVyZTogVGV4dHVyZUJhc2U2NCA9IG5ldyBUZXh0dXJlRGVmYXVsdChcIlRleHR1cmVEZWZhdWx0XCIsIFRleHR1cmVEZWZhdWx0LmdldCgpLCBNSVBNQVAuTUVESVVNKTtcbiAgICBwcml2YXRlIHN0YXRpYyBnZXQoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBWkFBQUFHUUNBWUFBQUNBdnpiTUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQURXTFNVUkJWSGhlN2QwSG5GVGx2Zi94SDl1WFpZR2w5eXJTUkpwRVVleFlzSkliYThSZTQ5OFdOY1pFYis0MWVwT0lzV3MwTml5eG0yZzBkdXdhZXdPN29xSkNBR25TdDdILzgzMDRCNGRsZHBrNVozYjN6TzduemV1ODVwd3pNOHZNczdQUGIzNVBPNjFxUEJaanJWcTE4dmZpS2ViRlIvbEZSUGxGUS9sRkUvZnl5L0Z2QVFCSUN3RUVBQkFLQVFRQUVBcDlJQkhSaGhvTjVSY041UmROU3lnLy9ZekN3a0pyM2JxMU8xNjllclhiTW9FQUVoRi93TkZRZnRGUWZ0RTA5L0xMemMyMUxsMjYyRTkrOGhNYlAzNjhWVmRYMit1dnYyN1RwMDkzUVNUcSt5ZUFSTVFmY0RTVVh6U1VYelROdGZ4eWNuS3NwS1RFQmcwYVpFY2VlYVFkZXVpaHRtTEZDdnZzczg5czNyeDU5dmpqajl2RER6OGNPUk9KSEVDcXFxcHM5dXpadG16Wk1sdTVjcVZMbGRxMWEyZDkrL1oxKzFIeEFZeUc4b3VHOG91Rzhvc21UUG5sNStkYjkrN2RiZmZkZDdkVFR6M1YxY1h2dnZ1dXZmenl5eTREa1ZXclZ0bU5OOTVvUzVZc2NjZGhoUTRnNWVYbDl1eXp6OXFNR1ROc3pabzEvdGtmS1FJcSt1Mjk5OTVXV2xycW4wMGZIOEJvS0w5b0tMOW9LTDlvMGlrL1BiWk5temEyeFJaYjJISEhIV2VUSjArMmhRc1gycE5QUG1tTEZ5LzJIN1hPZi83ekg3djExbHRkUFI1RnFBQ3lZTUVDdStlZWUxS0tYbXZYcnJYOTl0dlBSbzhlN1lKS3V2Z0FSa1A1UlJPVW56NjcraUtVbDVkbmxaV1Z0bno1OGxpOGRqNS8wVFNuOGxPVDFiNzc3bXNYWEhDQmRlN2MyVjU3N1RWNzg4MDNrNzdIYjcvOTF1NjQ0dzZycUtqd3o0U1RkZ0JSdHFIVUo0aG9DaENmZlBLSmZmWFZWNjQ5clgzNzlqWmd3QUMzQlpRdVRabzB5YmJiYmp1WFhxV0REMkEwbEY4MFFmbDE3TmpSampubUdPdlVxWk45ODgwMzlzQUREN2d2VWszOSt2bjhSZE9jeXE5cjE2NDJkZXBVMjNycnJlM1JSeDkxWDNKRWRiU2FzSXFMaTIzWXNHSHVYS1lDU05vcGdYcnZnK0NoL28vNzdydlB2Vmk5K0ovLy9PZDI5TkZIMjlDaFE5MExER2o0bU5JbEJabTQvOExRc3N5Y09kTTF4Yjc2NnF0Sm0ySkYyVWZQbmozdDE3Lyt0VTJZTU1GMjNYVlhPL2JZWTExUVFmTTFmLzU4dSttbW0xemZnZnA0NDA3MXNWNnpQc3RCOEZBOXJDLzhUejMxbE9zWHliUzBNcEFmZnZqQnJyNzY2dlVkTVVFZmlGS20vZmZmMzhyS3l0YW4rTXBHVlBqQlkvWEhxZXpqckxQT2NwM3NxZUliVERTVVgvMys4SWMvdU0rcjZFdlFUMy82VXpmc01TZzMzU3FBcUYzNW1XZWVzV3V2dmRhZGw0Y2Vlc2plZSs4OS82aHA4UG1McHI3eTA2aWxLNis4MGxYTTByOS9meHM1Y3FUN2dseFFVT0RPTmJSMHlpLzRvblBFRVVlNFk0MjBldWVkZDl4Z3BxT09Pc3AyM0hGSE53cExtaVFEK2VDRER6Ym94WC83N2JkZHhuSGdnUWRhbno1OXJHM2J0aTdiVUlEbzFxMmI2MEFQRkJVVjJYUFBQUmVMdEI5SVJuOVFMNzMwVXNvZGk3VTdKdEc4cUVONmwxMTI4WS9NdnY3NmEvdm5QLzlwZi83em4rM0JCeCswTDcvOE1sWjFtWnFxNXM2ZDZ6N0grcUtqWml2UisxRGdDeVlTWmxKYUFlU0xMNzd3OTh3Ky8veHo5OElVN2ZUTkxWbWtIREZpeEFZZDUzcTgzbFRVbm4rZ0lTakQxbEQwVkN1RjRNc1VtaS8xSjZoeldwK0pZRlBHcXFaUFZkU1hYbnFweTB3MTJpa085SmxVZHJGMDZkTDFuMk5OSm15b2pDbmxBS0lYODkxMzMvbEg1aUtkMm9QVnJwWVlKQktwT1V1akFRTHFnSHpycmJmcWJHc0dnRGhSM1RadTNMaU42cmlnY3RZWGpsZGVlY1Y5NDcvKyt1dnRqVGZlY0swelRTbDRiWTBoNVFDaWIyZEJXNkJvQ0srRzVxcG52ejdLVGdKcTJ2cjAwMC9KUUFCa0RUWC8xRmNwQi9lcEExdjlEbXJpdXZ2dXUrM2pqejl1OWxscXlnR2s5cHdQUlZrTjFkM1VzRndONncyb2owUkRJSU5PU3dDSU85Vmg2VXlHVmtCUkUvKzk5OTVyRjE5OGNTejdTeklsNVFCU095MVQ3NzBLVnUxcjlVa01NTnBYbEtidEdFQTI2ZDI3ZDUxTjlja29XS2hmV0YrV1AvendROWRmY3RWVlY3bEJHbXJOYVM1U0hzYXI0WW9hZ1JDNC9QTEwzV0pjMjI2N3JldnJxSXRXZm56aWlTZjhJN01ycnJqQ0RTM1RrTGhVMU82Y1YyZVFSbnpGeFdPUFBlYnZ4ZE5lZSszbDc4VlRVNVdmdnN6MDZ0WExUYndLTW1MTmFkS293ajMzM0hQOU9tNHFQMVVjbTIrK3VkMTIyMjF1R0h0QTQrczE4a1dkckUyRnoxODBxWmFmUnB4cUNHelVMQ0tvejNyMDZPRzZBRFE4dkw0MUE5TVp4bHNYRFV2WGNIWDFRUWZEempNMWpEZmxBS0lwOFltRnJYYStGMTU0d1VhTkdsVnZaRmF3ZU9TUlIveWpkWUZISFUzNmcweEY3UUpVbjhvdmZ2RUwvd2dJcDBPSERpNVk2RnRoRUVEVTVEQjgrSEFiUEhqd0JwbXpQb1A2STV3eVpZb2JkUk80NVpaYjNFQ1NWRC9MUUcyYTN2Q3JYLzJxempxMDJRU1Eyb0hnc3NzdWN6TWVOYW1tdmpkWk8vQmNjc2tsYm8wV1JkNVUxUDdaYWpaTG5GL1MxUFJ0TmM0U3M3ODRhcXJ5VTMvY2JydnQ1cjdRQkFGRTY3dHAzUC9Zc1dQWEQzdFUrZW1QV3hPMHpqMzNYSmRCQnpSUmRyUE5OblAzTlJVK2Y5R2tXbjZMRmkxeVEyTXpTYXZrYW9TWHZyVFVwZGtFRU0wNFYyZFFRRE0wbFlFb0VOVDNKaFZrTkkxZTFQZWhBS0kzb1c5NXFjaEVBVGFrRkl1dnlWQis5VXVjaWY3M3YvL2RyWlJ3MEVFSHJSOWRxUEpUUDUrYUcxUVpYblBOTmU2OHFBbHJ6cHc1L2xIVDRQTVhUYXJscCtaNjFWdGh5MXVmSWRWL1dxMWp6Smd4dHVXV1c3b3ZNWnVTaWZKcnlBQ1NjcTlRN1lrb210V29QN3hORldqaWtOMWdPWlBFNWdHZ0tTWDIzNmt2UTBQVkV6L1QrZ1BXOEhObEplbDBvcUo1MFVXWTFOK1ZqcUR5VngrSGdvYVdXRC90dE5OY3MyY3F3U01icFB3WFVYc1ltMmFWYThHdVRSVnE0aUprV3ZwQlAyZFRJN2VBeHBMWWdha0FvaEV5aWFNRTlZMVJGK1pSODFWY1podWpjZWxMaFFKSU90bUFIanR3NEVDM3pKUDZPRFNZb0NtYk9odEt5Z0VrY1Q2SDZQajc3Ny9mWUhKaE1vbnJCV2t1aVVhKzFEZHFDMmhNaVN2cXFqOURRU0x4TTYzbXJELzk2VTh1KzBoc3drWExvVGtkbTJwcENZS0xWdVpRc0ZEUU9PeXd3OXp5NmMzNUMzUEtBVVJ0d29tTGNhbWd0TFJKZlFGRVRWeGE4aVNnOW1JTndhVUpDM0doanN5QVB0TWFxcGs0NSttUGYveWphNFpWQjN2VTYwY2pPMmtxUXJMc0kyalNWTDJvenZDVFRqckpUampoQkxlL3FSVTZHb3RlZHpxWlU3cFNEaUFxck1TNUc1cUZycW42OWExcnBkbVhRUWVsYURWTGRSNXA2Qm9RQjFxbUlwRkd4R2craUJiTDB3U3dwNTkrZW4zd1VJZGpwa2ZpSU43MEpYbjI3Tm5yTTVDZ1FsWXJpaGFMMVdLeVo1OTl0cnRnWHVLeVRVMUJyMHRkQzVyMHFDL3F3YWFtczJSemxkU3ZyZnYwZUhXd2g1RnlBSkVoUTRiNGUrdUdRZW9DVVhVdEhLWUMxeUpqQWYwUzFMNDhmdno0MkVSblFKL2piYmJaeGo5YTkwVkovWGIvK01jLzNGVUhQL3JvSS9kWjFxSjV0OTkrZTFaY1dBaVpvZjVkamI1S3BDL1J1dGI0T2VlYzQyNTEzSkRmOE5PaFRFaVh0TDN6emp2ZG5LWmd1K0dHRzJ5SEhYYlk0SFVHQ1lFV2dOVGp6ei8vZkxmd2JicnZKYTBBb2prZmlmMFhta1NvSWJxMVUzdjl3V21KWXcwVkMyanVoeDZ2U1ZjMFlTRk9KazZjNkVaYUpjdW1WWWtvRzlId1hWM0xSa01pQXl6SjA3eHAzVDcxODJyU3FUNGp2L3psTCszd3d3OTNyU2h4ck1QVXNxTTZWdjNUR3E2clMyZG8vcDRtYm1zVkVWMTZQS0Jnb1N0cnFwVkkxM2xTUDgzSko1K2M5cW9LYVYyUlVQU0NGSldEU0tVbUtuVSticlhWVmk0Q3FxTmNMejV4NlhjZGF3eTlKaDhxNVV2blJjWWx1dGNsemVKcmRKUmZhblQxT2EyZ3FtOXNDZ3o2b3FTTVdYOTB3ZVZCZFU3emw5Uk1vTTkzVTg4QkVUNS8wZFJYZnJwUDlaa0NTRk5KcC94VXJ5b3Iwa1RyNE1xRDZkSThQV1hicVVvN2dJald2bGRrVHVYTmFRU0RMdjI1eHg1N3VGbS9hbTlMcDFDb0FLT2gvRktuSUtMaG1sbzlZZGFzV2E2NVNrdjJKTDVHcGY0cVU1MUxkMTVBUStEekYwMXpLejk5dVRuNDRJUGRhRmYxMmFYei9qUmlWczFkNlFnVlFOVHZvV3dpU08rU1VXZWovaEMxQ0prV1hOVGpOV3M5M1NGdGZBQ2pvZnpTcHlaWlpkWUtFSm9IRW1kOC9xSnBidVdueHlzVFVYTlc3VGxObTZLeVNMYzhRZ1VRMGJleko1OTgwaTBvcHpSUHpWZDY4Zm9XcDBpbUZGL1hSVC9ra0VQY29uVWF0UlZtL2djZndHZ292MmdvdjJnb3YyamlYbjZoQTRqb201cUNoWWJ6NmtxRFN2ODFMMFNUc3pSOFRCMDY2blRVU0pkZ3pIUzYrQUJHUS9sRlEvbEZRL2xGMDZ3RFNFRHB2dHJiRkR6MDQ5Uk1wVkVLV2lZaWFnSHdBWXlHOG91RzhvdUc4b3NtN3VXWGtRRFNrUGdBUmtQNVJVUDVSVVA1UlJQMzhndlhyZ1FBYVBFSUlBQ0FVQWdnQUlCUTFNQVc3MGJBZGE4UklZMGRPemJ1djk5WWUrdnR0LzA5aE5FcTVuME1jUmYzMGlNREFRQ0VRZ0FCQUlSQ0FBRUFoRUlBQVFDRVFnQUJBSVJDQUFFQWhKS1JBS0tyRE9wS1hWdHZ2YlYvQmdEUTNHVWtnT2h5b0FNSERneDlZWFlBUVBhaENRc0FFRXBHQWtqY1Y3UUVBR1FlR1FnQUlCUUNDQUFnRkFJSUFDQ1VqQWFRdUY4OUN3Q1FPV1FnQUlCUUNDQUFnRkF5RWtBWXhnc0FMUThaQ0FBZ0ZBSUlBQ0NVakFZUVJtRUJRTXRCQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkN5V2dBWVJndkFMUWNaQ0FBZ0ZBSUlBQ0FVQWdnQUlCUU1oSkFHTVlMQUMwUEdRZ0FJQlFDQ0FBZ2xJd0dFSWJ4QWtETFFRWUNBQWlGQUFJQUNJVUFBZ0FJSlNNQmhHRzhBTkR5a0lFQUFFTEpVZllRZFpzMmJacjdZVWNkZFZUUys2TnNBTkJTYVdScm5MZU1aQ0Q2UVFDQWxvVW1MQUJBS0FRUUFFQW9HUTBnOUZrQVFNdEJCZ0lBQ0lVQUFnQUloUUFDQUFnbEl3R0VZYndBMFBLUWdRQUFRaUdBQUFCQ3lXZ0FZUmd2QUxRY1pDQUFnRkFJSUFDQVVBZ2dBSUJRTWhKQUdNWUxBQzBQR1FnQUlCUUNDQUFnbEl3R0VJYnhBa0RMUVFZQ0FBaUZBQUlBQ0lVQUFnQUlKU01CaEdHOEFORHlrSUVBQUVJaGdBQUFRc2xvQUdFWUx3QzBIR1FnQUlCUUNDQUFnRkF5RWtBWWhRVUFMUThaQ0FBZ0ZBSUlBQ0FVQWdnQUlKU01CaENHOFFKQXkwRUdBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkNJWUFBQUVMSmFBQmhHQzhBdEJ6cS9ZNWM2dzhiTnN3T091Z2crL0RERCszKysrLzN6MmFHRjVSMjluY1J3b2tubnZpY3Y0c1FidmpyRGY0ZXdxaHB4WmZLU0dKZWZEUmhBUUJDeVVnQUNacXVHTTRMQUMwSEdRZ0FJQlFDQ0FBZ0ZBSUlBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQ1VqQVFRaHZFQ1FNdERCZ0lBQ0lVQUFnQUloUUFDQUFpRkFBSUFDSVVBQWdBSWhRQUNBQWdsSXdHRVlid0EwUEtRZ1FBQVFpR0FBQUJDSVlBQUFFSWhnQUFBUWlHQUFBQkNJWUFBQUVMSlNBQmhHQzhBdER4a0lBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQVVBZ2dBSUJRTWhKQUdJVUZBQzBQR1FnQUlCUUNDQUFnRkFJSUFDQVVBZ2dBSUJRQ0NBQWdGQUlJQUNDVWpBUVFodkVDUU10REJnSUFDSVVBQWdBSWhRQUNBQWdsUi8wWFViZkhIMy9jL2JBOTk5d3o2ZjFSTmdCb3FkU3ZIT2VOREFRQUVBb0JCQUFRQ2dFRUFCQUtBUVFBRUFvQkJBQVFDZ0VFQUJCS1JnS0lobk1KdzI0Qm9PVWdBd0VBaEVJQUFRQ0VRZ0FCQUlSQ0FBRUFoRUlBQVFDRWtwRUF3aWdzQUdoNXlFQUFBS0VRUUFBQW9SQkFBQUNoRUVBQUFLRVFRQUFBb1JCQUFBQ2haQ1NBTUl3WEFGb2VNaEFBUUNnRUVBQkFLQVFRQUVBb0JCQUFRQ2dFRUFCQUtBUVFBRUFvR1FrZ0RPTUZnSmFIREFRQUVFcEdBa2h1YnE2N3JhNnVkcmNBZ09ZdjVRQ3lZc1VLdStPT08rekdHMiswZSs2NXg1WXZYKzdmVTc4MzNuakRwazJiWmpmZmZMTjkvUEhIL2xrQVFMWkxPWUFveTVnOWU3Yk5uVHZYUHYzMFU3dnd3Z3Z0ODg4L3Q3VnIxL3FQMkpneWttZWZmZGErK2VZYisrNjc3K3lxcTY3eTd3RUFaTHVVQTBoeGNiSDE3OS9mUHpKYnZYcTEzWC8vL1M0ekNRU2Q2WUV2dnZqQ3lzdkwzYjZDeWNNUFArejJBUURaTDYwK2tGR2pSdmw3WnAwNmRiTG5ubnV1M3Fhc21UTm4rbnRtWDM3NXBTMWJ0c3cvQWdCa3U3UUN5T0RCZzlkM21JdjJQL3ZzTTZ1cXF2TFAvRWpubElFRVB2cm9JeHMzYnB4L0JBRElkbWtGa0x5OFBCc3laSWgvdEM2Z1BQUE1NN1pxMVNyL3pJL1VQeEkwWDFWVVZMaGdNbW5TSkhjTUFNaCthUVVRR1RObWpMOW4xcUZEQjN2dHRkZldCNURFUHBBUFAvelEzelBYNlY1UVVHQVRKMDcwendBQXNsM2FBYVJmdjM1V1dGam9INW5ibnpWcmx1c2tWNUNReXNwSzE3UVZVRERaZnZ2dHJVZVBIdjRaQUVDMlN6dUE1T1RrMkpaYmJ1a2ZtV3ZTZXZIRkYxMmZoNXE0Uk1GRFFVUTBTa3ZEZVBmZWUyOHJMUzExNXdBQTJTL3RBQ0pqeDQ3MTk4emF0bTFyTTJiTWNQTkIyclJwNDg0bE5sK3A4N3lzck15MjIyNDdOeFFZQU5BOHFOTWlyUlVRMjdkdmI2ZWNjb29MSEVIZng1dHZ2bW05ZXZXeW5YYmF5WGJmZlhlNzdycnIxby9NdXVHR0cyeisvUG1obHptcHFhbTV3TjlGQ0Y3NS80Ky9peEJPUFBFRWZ3OWgxTlJzT0RjTTZZcjNBclZwWnlCcWtwbytmYm9OSHo3Y1AyTTJkT2hRTjB1OVQ1OCticjVIRUR5Ky8vNTdOM09kTmJJQW9QbEpPNEFvT0doWmtzUWxUTlIwdFdUSkVtdlhycDBiY1JYUVJNTGFzOU1CQU0xRHFENFF6U2gvNnFtbjNHejBRUGZ1M2UyRER6NndyNy8rMmgzcjJpRHFHd0VBTkUraEFvaWFzVFR5YXRDZ1FmNFpzODAzMzl5dHZCczBYNmxKYStuU3BWeGtDZ0NhcVZBQlJNMVhDeFlzc0lVTEY2NXZvbXJkdXJYbDUrZTdmVkUya3Jqc0NRQ2dlUWtWUUNSb3h1clpzNmQvWnQyS3ZhSXNSRU41eVQ0QW9Qa0tIVUEwaEZmTldJbXowZ09hU0tqbDN1dTdWZ2dBSUx1RkRpREtMdFRQY2RGRkY3bkZFb05nb2Y0UjlZVm94bm95ZFowSEFHU1h0Q2NTMXFaK2poRWpScmlBb2lHOGE5YXM4ZTlKVG85UFoxNkk5M09aU0JnQkV3bWpZU0poTkV3a2pLcVpUU1NzVGNGQW82MDBBMzJmZmZieHo5YU5TWVVBMER5a0ZFRFV6NkhPY2kxWDByVnIxL1dMSmdZVUZFcEtTdHhFd29DYXFyVGN1NTZqVlhnMVNnc0EwSHlrRkVCMFlhZzVjK2E0R2VoYTF5cVk2MUVmOVlrc1hyellQVWZMbVNTNzZCUUFJSHZSb3cwQUNDVWpBWVQ1SGdEUThwQ0JBQUJDSVlBQUFFSWhnQUFBUXNsb0FPSGFId0RRY3BDQkFBQkNJWUFBQUVMSlNBQmhHQzhBdER4a0lBQ0FVQWdnQUlCUUNDQUFnRkF5R2tBWXhnc0FMUWNaQ0FBZ0ZBSUlBQ0NVakFRUWh2RUNRTXREQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xvd0dFWWJ3QTBIS1FnUUFBUWlHQUFBQkN5VWdBWVJndkFMUThaQ0FBZ0ZBSUlBQ0FVRExhaE1Vb0xBQm9PY2hBQUFDaDVDaDdpTHE5ODg0NzdvZU5IajA2NmYxUk5nQm9xZFNxRStlTkRBUUFFRXBHQW9naWtaQXhBRURMUVFZQ0FBaUZBQUlBQ0lVQUFnQUloUUFDQUFpRkFBSUFDSVVBQWdBSUpTTUJoR0c4QU5EeWtJRUFBRUloZ0FBQVFpR0FBQUJDSVlBQUFFSWhnQUFBUWlHQUFBQkN5VWdBWVJndkFMUThaQ0FBZ0ZBSUlBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQVVESVNRQmlGQlFBdER4a0lBQ0FVQWdnQUlCUUNDQUFnbEl6MmdRQUFXZzR5RUFCQUtBUVFBRUFvR1EwZ0RPTUZnSmFEREFRQUVBb0JCQUFRQ2dFRUFCQktSZ0lJdzNnQm9PVWhBd0VBaEVJQUFRQ0VrdEVBd2pCZUFHZzV5RUFBQUtFUVFBQUFvV1FrZ0RBS0N3QmFIdFg4a1RzdU9uYnNhS2VlZXFvdFdyVElycjc2YXY5c1p0VFUxTHpnN3lLRXQ5OStlMGQvRnlHTUhUdlczMXVuOXBlbDJ2MStUWDEvYmJVZlgxdERQeC9ORzAxWUFJQlFDQ0FBV2h4bFRtNWJ1M2I5UHRLWGtRQkM0UU9JTTlWUlZaV1Z0bURlZDNiam44Nnh2WVlVZUZ1KzdUWFV2L1cyc3cvYnlUNTY5MVdycUNpM3RWNWd3YWFSZ1FEMVVCOUE0aFo4V3cyMnByNGZkVk1RV0xKb2diM3k5RU4yMGo0amJkOHRpdTNJSGZ2WlA2WmQ1dDI3Y2RsOStOYkxkdFloMjl2K0kwcnNvSzI3MkQ5dnY4WVd6WjlyMWRWVi9pTlFHd0VFUUxPaG9QSDE1eC9hdlgrOTJBV0JuMi9id3k0NjVRRDc1b3VQL0Vla1p1V3lwWGI5LzUxaFUzYm9ZejhiMjlGdW52b2JtL1h4ZTE0d3FmWWZBY2xvRTVhK0lRRkFZMUkveGdkZTluRG5OUmZaejhhVTJTKzhiT1BXeTg1elFTQVR5bGV2dEFkdXZzUk9tYnlWKy9sL3UvcjM5c0diTC9uM3RteGtJQUN5UnRCMHQzWnR0YzE4ODBXYmR1bDV0dCtJRXZ2VllUdDVGZnYvMmhxdnNtOUk1V3RXZVlIcTkvYXJLVHZidnQ3L2UrYzFGOXBuTTk5eW1VOUxiRkpVeWhENVhaZVZsZG5wcDU5dWl4Y3Z0cXV1dXNvL214bmVMNFY1SUJFd0R5U2F1TThEMlpUYXo2OXRVeit2b1orZkt2MmM2cW9xbS8zRlJ6Yjl3ZHZ0eVFlbTJlcVZ5L3g3bTE1WnAyNjI2K1REYmU5RFQ3RE8zWHRiVGs1dTJyK3JiRVFHQWlDV2dxQXg1K3ZQN2RvTFRyVmpkeDlpcDB3ZWF3L2RkbVdzZ29jc1dUalBIcmpwRWp0NjEwRjIrcysyc1R1dnZjZ1dmei9QMWxaWFp5eUl4aEVCQkVDc3FLUDZoeVVMN2I0YnB0cnBCNHkzNC9ZWWFvL2VmYjB0bUR2YmYwUzhxYlA5enFzdnNDTjI2bWZuSHJXN1BmK3ZlMnpsOGgrYVpTQWhnQUNJaFZVcmx0a0xqOTFuWngyNmcwM1p2cmZyQ0ovMThidit2UTBuSjZlVjVlWGx1dmI4VEZMMk5QT05GMnpxMlllN3pPU0NYMHkyVDk5L3c4clhyUFlma2YxVVpwSERJbjBnOFVVZlNEUmJiYldWdjdkTzdXK1I2ZlpaTlBUOXRkVitmRzFOL1h6TnNWZ3c1eHU3NjlxTDdNMFhIbk9aUjBNb0xDaXdmbjE3MkU0VHhsbEpTWkU3cDVkZVhGeHNuVHVWV1Y1dXJwVlhWTmlzcjc2MUJ4NmFidk1YTEhLUHlUU1ZsL3BJZHZ1dm8yM1BnNDZ4amwxNmJMSU00MHl2dlA3ZmNBcmF0Mjl2WjV4eGhpMVpzc1N1dlBKSy8yeG1lQjlBQWtnRUJKQm9DQ0FOOC96S2luSTM5UGE2QzArM09iTS9kMzBGRGFWM3o2NzIyN09QZDRGaVU2OVgxSVEyNDhQUDdmSnI3N0NWS3hzdVc4Z3ZLTFMrZzRiYktmOTdyVzAyYkxUbDV1WDU5MlFQbXJBQU5DcjFaUnl6MjJENzdkRjcyTGRmZnRLZ3dTTS9QOC9PK2VVeDFxVnpoNVNDaCtSNjJjaW9FWVB0N0ZPUDlNODBEQVhSTHo1OHg4NDRjRnM3WXVmKzl2RjdyL24zWkE4Q0NJQkdOZlBaaDJ6TjkzUDhvNGJWeXZ0WFZWVzF5VXlxTmdXYkZTdFgrVWNOcmNiV0xKcG5qMTc1Ry84NGV4QkFnSHFvNGtuY1ZMRWtibkc3di9aVysvRzF0MlRQU2R5U1BTZHhTL2FjeEMyWlpRdm5XWTgyaGRhM3BNQ0tjMVBMQ3NLcXFLeTBzMzU3cWQxMjF5UDIzc3hQYmVrUHl6ZTVVS0plOThMRlMrM08reDcxenpRY3ZmOStKZm5XeXlzUFZjWjFsVmxjNmJjWCtSWFRCeEpmOUlGRXd3V2xvajAvbVFjdU9jdGV1dit2L3BIWm1xcHFXN2lteWxaVnAvK3p3aWd1S3JSUld3NjJ6cDA2V052U0Vpc295SGZuU2xvWHU4NXpCWnIzUC9qTWYzVERLTWxyWlowSzg2d3dMOWMvWTlacnlHZzc2OVlYTENjbmU3N1hrNEVBYUZSVmxSWCszanBGWGlXcWIrQjl2Vy9pcFY3RjJ0QldyeW0zVjkrWVlROC85cno5N2Q1SDdaWTdIckpyYjd6WHBsNTVxOTEyOXlNTkdqemE1dWRZdnpZRjFyT2tjSVBnSVRWYTlUZEVRRzVLQkJBQWphcTZzdExmMjVBcTFPNWV4ZHJmcTJBN0ZHeFl1V1l6aGNST2hiazJvTFRBdXJVdXNJTGM1Tld1Um4rRnllaWFVa1lEeUtiU1hTRGI2RE9kdU9rUFBIRnI2dnV6VWUwTXBMWjhyNEx0V0pSbkEwc0xyWXQzbTYwVUFyc1ZlKytqYmFHVkZlWlozaWFhcHJKeDJSTXlFQUNOcXJxcS9nQWlDcGE1T2Eyc3ZWZnhidVpWd0QxYjUxdCtsbncvTGZaZWQrL1dlVGJBZTkxdEMvSXN4dy8rbTFLelZzT1pDU0FBVUtkV3JkS3JkbFFCbCtUbldqOHZJMUgvUVp1OEhOY3NGQ2Q2UjJYNU9kYS90TUI2ZTYrek9EOHZwYUN4Z1N4c3dNbElBTW5XVkJwQTQ4dk56L2YzMHFNS1dmMEgzYjFzUkJWMXA0SmNhNFErOTNvVmVEVm85K0k4Ny9VVVd1ZldCWllmWVFSVnVvRTFEckx2RlFPTktMRy9RWnNxc2NTdHFlL2YxRmI3K2JXM1pNOUozSkk5SjNGTDlwekVMWm5jdkhBQkpLQ2ZxLzZFc3FJOGw1WDA5Z0pLNjF6di8vUHZiMmlxTk50NldaQTYrL3UyS2JUU2dqelgzQlpWSys5bjFGVm1jVVVBQWRDb29nYVFnQ3BiTlc4VjUrZGF6NUlDZi9SV1RvUDFsUlI1Rlh4WEwyZ3ArK21xUGhrdkc4cGtoYjh1QXlHQUFFQ2RrZ1dRYmoyNjJlbm5uVzdIbjM2Y2pkbDZ0QlVVRlBqM3BNWmxKVzcwVnI2WEZSUllMNitDYjVNWFBTdFJFMWw3THlpcDc2VzN0N1V0eVBXeWpjd0dqb0FMSU5rVlB6SWJRTEl0L1FMUStKTDFnUnh3K00rOElOTFZCbXcrd05zL3dNNmZlcDV0dit2Mi9yMnBjMW1KVjhHMzlyS1M3cTBMM055TExrVzVWcFRta2ltYThLY2dwTURSMlF0SzZudlJ6MjdJT3E2VkFoTVpDTkI4QkpWR3NHMnFENkN4Nzg5R3lUS1E3ajI3KzN2cnlqemZDektUZnJxbi9mellRLzJ6NmRQUFViYlF2akRmZXZ0TlhKclFwNDd2Wk5wNVFhTmJVWjV0NWsvNFV4QlNNTkxQaWFwenQ4NjI1K1E5WFlDc1N5YituOFpHQUFIUXFKSUZrRVVMTjc2QWt5clVMVVp2WVdQSGI3Z2VXUmd1S0hsWlJBY3ZtK2hYV21RRHZTRFJvempmdW5tYk91RVZOTHA2UWFOdFlWN0cxNkthZk1oa08rTzhNMnpIM1hhd1kwODl4cjJuWkZybDVHWmRFTWxJU1dYck55RUFqUzlaQVBsazVpZiszb1pVb1U3Y2ExZi9LSE9VbWJRcHlIVjlHdXFFYjRnRkRQUHk4dXlZVTQ2Mm4wd1k1LzM4ZFlGQi84OUJSeDdvN3F2TlhWQ3FKUVlRQUVoVnNnRHl6T1BQdXJXZ2ttbFgxczdhbExieGo3SkRVWEdSbmZrL3Y3UkJRd2R0bEZXb2VhNW4zNTcrVWFKMXpaVFpoQUFDMUtOMm40UCt3Qk8zdU4xZmU2djkrTnBic3Vja2JzbWVrN2dsZTA3aWxreE9rZ0JTdnFiYzNuemxyYVRQMGYvVHRuMWIveWc3SEhiOFlWYldvY3cvMnBEZTQvSWZsdnRIMlkwQUFxQlJGUlMxOXZjMjlNOTcvMm16WjgzZUtJam9lRldqWFIwd09tVkxBd2ZWM1ZtK2N2bEtXN3h3c1grVTNUTGFCNkp2Q2dCUW42S1NVbjl2WTMrOS9BYWIvdWgwVzdsaTVmcDZaZmFYMzlqU3hVdmRmallZc3NWZ042czhHVjBOOFpFSC91VWZaVDh5RUFDTnFxaWsvdWFvWng5L3ppNzY5Zi9aZjUvK08vdmRMLy9IL25yWmoxY3ZqRDB2Ym96NnlTai9ZR1BQUGZHOHpYaDdobitVL1FnZ1FEMFMyL3UxNlZ0eDR0YlU5MmVqMGxhcnJYMUJsYmRYLzdYSjFhbGVXWkg4NGxOeGxadVR1OEdjbG9CK1Y3Ty9uTzJ5cTQydHRUS3ZQSWEzTC9lUHN3Y0JCRUNqcWx3NjE2c3NLMjE0dXdvcnpNbSthMkRVcDNwdHRjMzVkcTUvdEM1d3FObnFxVWVldHVzdnJaMUoxVmhwWHJXTjlBTEhNSzg4Y2x0bFh6a1FRQUEwcXZKbDZ5WU50aStzc1RFZEsyeEFTWVhsdW15a0dRUVM3eTFvTU1DeUg1YTV3TEZ3L2tLYmR1MnQ5dnlUei9zUGtCb3I4Z0xuMExibE5xS3N3dHFrdCt4WHJCQkFBRFNxdFFtWHRGVmZjL2VTdGJaVnAzTHIwN3JTV2pXRFFMSm93U0s3NUhlWDJNWC9QZFV1dStoeSsrS1RML3g3YWl5LzFWb2JWRnBob3p0VVdJY2lOVkg2ZC9teXJWa3lKMmhMamJMTm1UUEgvYkFlUFhva3ZUL0tCalNsNERPWStGbFVYMFJ3MjlUM0I3U2Y3RmpQUzN4dTdlTkFRejAvbWJYVkcxL1NOcy83S3R1N1RiVnQxYkhjdWhWVmVZRms0LzhqbTFSVlZkdXlwY3U4QXROUmpaZGgxZGlBTmhVMjFudC9YWXJYV3JLSjd6VmV4dUkvWWIyZ0hPTzZaU1FEMFE4Q21pTjl0bFZoeHZVMkc2MnRxcnRqdkNEWGJHRGJLdThiK2hwcmw2ZU85dXdPSkRuZTYrL3RaVlpqTzY2eGJsN2d5SzJueGwxYldlNEhrZXhCRXhaUWoxUXE4YWE4RFRZZEo1Nkx5M0V5TlFsTldIVXB6ak1iWGxacG84dldXRWx1OW5XMGV5VmdYUXZYQlk3ZUpkV1c3d1ZHcjFqcVZiUFdlNTkxbEZsY0VVQ0FlZ1NWWVZ4dnM5SGE2dFNHNW5wdjBWcm5tNDNzVUdGanZJeEVIYzk1K1huV3FVc242OUNwZy8rb09OSHZvOGJhNTFmWk9DOXdLSk5TUnFYM2tZcWFtdXpLUGlTakFTUmJQOUJBWGVxcnZPTnlHK3pIOFRpWitwcXdrdEdQVVVhaUVWdG4vdW80Ty9OM3Y3U3ovL2NzTy9hMFk5TytjbUhEcWJFMmVkVzJkYWMxYmtodUtobEhiV3ErOGtyUFA4b09aQ0JBUFlKS01hNjMyV2h0MWFhYnNKSnBYZGJCeW5yMmNlOWQyMmFEQjlxdkx6ckhpbG9YK1k5b0NtdmRYSTZ4WG9ZMHNrT2xHd3pndmJSd2FtakNBcHFWVkNyeHByd05OaDBubm92TGNUS3BObUhWVnJscXBadGJrYWgxU1dzNzRvVEQvYVBHRkV3Q3JMQXRPMVJZMGNhWDkwaGJ0bldnQ3dFRXFFZFFHY2IxTmh1bDI0UVZxS29vdHprejN2S1BmdFM1WTZrTmJSZDB0amUwR211YlgyVmJ0bC9qQWtlYmdzejlEbHdBeWJMZktRRUVxRWNxbFhoVDN3YjdjVHhPcGlaa0JpSXpIcm5YbHMzL2Nha1FaU1R2UFhTWGRTaXNjWjN0dzd4QTBycUJBb21HRlk5b1gyNWJ0SyswMGdicGVzbStMd1FwQlpBMWE5Yll5cFVyL2FQd0ZpMWFWT2RWeDRBNENpckZ1TjVtbzV5ODhMV3Z2cVgvZTlyVk52L3pqNnhpeldwNysvNWJiZW0zWDduN3ZDS3hNaStRak5vZ2tFUXRJelZWcmNzNE5LeTRyWmR4NlA5cENMb21lb1A5OEFhU1VnQjU5dGxuN1lvcnJyQlhYbmxsb3piSVZLeGF0Y29lZXVnaHUrYWFhK3lUVDVKZit4aUlvMVFxOGFhOERUWWRKNTZMeTNFeU9mblJPcjJyeXRmWW0zZmRhRTlkL0Z1Yi84bE0vK3lQdlA5K2ZTQlJ4dEJtL1lURVZJUEp1c2UyZFlGRDYxVXA0OUI3VzNkdlE4bkp6WGRsbDAxU0NpQURCdzYwcXFvcW16NTl1Z3NrTDcvOHNxMVlzY0svZDkyM05LbjlnVkhHOGNRVFQ3am52UC8rKys1eC9mdjM5KzhGNGkrb0RPTjZtNDF5Q3hwbjFKUlhSQzVqMk5JTEFDUEx5cTE5ZnJXL1JFcGQ1ZWFWcTdkcEhzY283L0ZiTkZMZ0NMVEtWVTk4ZGdXUVZ0NkhjSk9mUW1VZGwxeHlpV3ZLa3VERDI2bFRKK3ZidDY4VkZSVzU3S1N3c05ER2p4OXZpeGN2dHErKytzcVdMMTl1T1RrNTd2bTYzV3l6emV6UVF3OTFQeU1OTC9pM0NPSHR0OS9lMGQ5RkNHUEhqdDJvMG83YnJXaGY0bnFjNk0yclRyQ3ZucnJaUDJvOGVpbHJxczNtcmM2MTc5ZmtXV1dOWHFNMkxYSllZNTJMcXF4YmNiVVZOVkZMVXJ2K0kyMjNLOTcwTWhIdkJmaUNjb3lybERJUVZmNWJicm1sNWZwdkxQaFFMRnk0ME41OTkxMTc5ZFZYM2JFQ3pJc3Z2bWd6Wjg1MHdVT0NKaS8xZll3Y09kTHRBOWxDZjhENnZNZjFOaHRGYmNJS3l5c3lOeUd4ZjJtMWplbFlic1BhbFZ2WG9rcDNxK04rYmFyZC9YcGNVOGoxeXFWVnNsVVdZeXpsVnp0cTFLaWtIZUFLRUVHUTBJZGErOGsrMk1wT0JnOGU3QjhCMmFHK3lqc090OEdtNDhSemNUbE9wckJ0UjMrdjZXakNuL3BKTm10YjVXNGpUUURNRk8vL1Y5bGxrNVFEU1BmdTNhMWp4L1IvOGZvUUtYTkp6R0NBYkJGVWhuRzl6VVlkTmgvbjd5RlI2ODU5L0wzc2tWYStOSHIwYVBmQlRZY2VUL01Wc2xVcWxYaFQzd2I3Y1R4T3B0dVkzYTNYOWdmNlI5bWhiYmVlMW52MDF0WjNxKzBzdHdIVzMyby9ZTFNOTysxRy95aDdwQlZBbEVYb3c1RU9QYjVkdTNiV3MyZFAvd3lRUFlKS01hNjMyU2duTjgvR24zTzNiWEg0UlY0QnAxVUZOYnFpMG5ZMjd1ZkgyNFRqejdTUit4MWlJL1krd0hiNmY3LzE3ODJNbnR2OXpIYjk4OHVXMzdyVVA1TTkwdnJ0bFphV3VtRzQrdkNtU2gzd1lUSVhJQTVTcWNTYjhqYllkSng0TGk3SGRkRmpoaDM4Rzl2cEQ4OVlibkZtSzg3ODRoSnJsWUhtY21VZE81M3lHK3M2YUppcnh3S0ZyVXN5RnZpR1Q3bkF0djMxM1kwMnREblQwaTRGQllPZzB6d1YraEFwY3dHeVVWQVp4dlUyMjNVWnNZUHRmZE5uMW1YVVJQOU1OTnNjL2d2YjQ1eUxiTkp2cDlyNG8wNnhqZ00yOSs5Smo1cXBmbkxZQ1paWFVPaWYrVkg1cXBWZXhaYitoT3BFdVVVbHR2UEZMOWp3UTg1Zk53TTlTNlVkUUlZT0hacldHdnk5ZXZXeXNySXkvd2pJTHFsVTRrMTlHK3pIOFRnVlJlMjYySTYvZjl6R25QSlgvMHc0SGZvTXNFNSt3RkRHMExIdlFOdG15a2xlRnZGYkt5aEpMOHZwUFhxOEZkYnhuTXJ5MWY1ZU9GMUdUclI5Yi8zR09nK2Y0Si9KWG1rSGtMeThQQnMrZkxqN0JlbURzaW5LV0lCc0ZWU0tjYjF0TGpUL1liTTlqN1A5N3BocmVjVnQvYlBwNlRseTQ5RmRLcWMySFR2YjFsTk9UUG1idmg0M2VPYzkzWE9US1M1dDUrK2xiOXdadDlpT0Z6NXVCVzNhKzJleVc2aUdQTTBKVVROV1hRVWNVSkFaTm15WWZ3UmtuMVFxOGFhOERUWWRKNTZMeTNHNmlzcTYydVM3RjlqUWc4L3pqdExyTjYxdmRGVGJyajFzMkc3NytVZjFLKzNhUFduVDFZL1M3ODh0N1RYRTlyMWpqdldmZUtRTGxzMUZxSGZTcDA4Zk43S3FQdm9RRFJreXhDMXpBbVNyb0RLTTYyMXpsSk9YYjF0TXVjQW0zZmlwRlhWSWZmVG0zSm52K25zYlUzbDE3TDlaU3BWM2FlZnU3dkhKVkphdnNWZHV2dHcvMnJSV3VmbXVvM3lQYTk2M292WmQvYlBOUjZnQW9zTFZ2STY2Q2xuMDRXYnVCN0pkZlpWM1hHNkQvVGdlaDZYbnR1azJ3UGErWlpZTm1IU2lmN1orUzc3NzJ0YldjN21JVkpkTFg3Rm92bnNQaWJTTS9QZGZmVzVQWC9MZnRtTGhBdjlzL1VwN0Q3VkpmLzNFaG5uWlZFNWVYcVR5aUt2UXVaU0NRKzFDVHFUTVE0c25BdGtzcUJUamV0dWM2VDNtZXRuSTJKT3Z0WWxYdkdHdHU5Vy9rbmZscWhYMjluM1Q2aXlYdk1KQ3kwbWhIK1NIT2QvWWR6UGVzdXFxU3ZlemxzejUxcDY1OHZmMit1MS84UUtVbG9hdm43S09RZnVmN21VZDczbEJzSjk3SDgxVlNxdngxdVhHRzIrMHVYTi92RHBZUUV1V2pCczN6dmJZWXcvL1RDU3N4aHNCcS9GR0UvZlZlQU02bHVCY1hJNHpxV1p0dGIxMzh6bjIrYit1TWE5Mjk4OXVyUHV3VVRaOHo4bHVFbUNpbFlzWDJndlhYV3hycXpZZEJFVExxK2NYRmxtRkY1aFMxVzdBS052NjdEdXNuWmQ5QkdVUlJTWitSa09LMUpzelpzd1lmMjlEV3JxRXVSOW9EdlFIck1vd3JyY3RpWnFnUmgzM1o1dDQ2V3ZXdHQ4Vy90bU4vZWVqOTJ6NkZiKzNMMTUrMXFvcjExMCtWMDFicy83OVhNckJRMnE4SUpWcThOQUt3eU9PL3BQdGZ1VmIxcjdQTVBmN2FRa2laU0RsNWVVMmRlclVqU1lXZHVqUXdVNDk5VlQvS0RJeWtBaklRS0xoZWlDWk9jNDBOU1Y5OXRBVk51TzI4N3lEdW9OQ2JrR2h0ZTNleThxWC8yQ3J2QXlrSVhRY3RwMXRmZVp0MW1ZVFRXeGhCT1VZVjVFeUVDM1Jyb21GaVc5UyszVmxKa0MyMGVkWmxXQmNiMXNxcmFjMStML09za2szZkd4bG00MzF6MjZzdXFMY2xzeWUxU0RCUTlkMjMrYWN1MnlYaTU5dmtPQ1JEU0lGRUttOXdLTDJSNHdZNFI4QjJTMVpwUjJuMjJEVGNlSzV1QnczSlAwL3BkMEcySzZYL3R1Mk9mY2UxM25kV0hwdGY1RHQrN2U1MW1lSGc3M1hFYmthelZxUjM3bEdXaVhPOVJnd1lJQzFiUnR1SmlrUU4wRmxHTmRick10RytrdzQwUGEvYTRIMTJla3c3MHpETmZ2a0ZaZmF4Q3Zmc3ZGZTVsSFloaVdhSWdjUXpUYlh6SFI5b0xVeDl3UE5TU3FWZUZQZkJ2dHhQRzVNQlNWdGJadXpiN2M5L2pMVDhrczcrR2N6UTgxVlkwNjV6aWJmL2IxMUdNanE0b0dNNUY3Qm5CQUZFODArQjVxTG9GS002eTAyMXE3UFVOdi96bmsyK0lCZnU0by9FcStjMnc4Y2EvdmZ2ZEFHN25HOG15V1BIMlVrZ0hUcjFzMjZkdTNxK2o3U1dha1hpTHRVS3ZHbXZBMDJIU2VlaTh0eFU5R0V3WkZIL2NIMjh3Skp4MkVUWENCSWx5NHh1OHNsTDl0dVY3eSs3aG9qSVg1R2N4ZHBHRzhpRGVuVlNyME5jTjF6aHZGR3dERGVhTGJhYXF2MUZXTmNiMFg3RXJmanVKajMzalAyOWpVbjJjcDVYL3BuNnBiWHVxMWJ2MnJ6ZlUveDNrL1RkcEFINVJsWEdTc2REZWx0Z09BQk5DbFZoUG9qanZOdHNCL0g0N2pvTm1wWG0zVDlSMTVnK0wzbEZyWHh6OWJpdmQ1K0U0KzIvZjgyendidmQ1cDMyTFRCSXh0UVFrQTlna294cnJkSW5mb3ZoaDl5bnJ2bXlLRDl6L0RQcnJQWjNpZmI1SHNXMlUvT3VNbE5Qa1JxTXRhRTFZQm93b3FBSnF4b1dBc3IybkdjVmE1ZWJuTmUvYWYxbW5DQTVjWDBtdVJCZWNZVkdRaFFELzBCcXpLTTZ5M0N5eTh1dFg2N1RJbHQ4TWdHQ20reC9oVEcvWTlFZjhoeFJ2bEZRL2xGUS9sRkUvZnlJd01CQUlSQ0FBR0FGa0RaeklvVks5eFduNHFLQ2x1NmRLbFZwYkQwUFUxWUVaRUNSMFA1UlVQNVJkT2N5dS94eHgrM045NTR3enAzN213bm4zeXlmM2Fkano3NnlKNTg4a2xidG15Wk85WWxOL2JaWngvcjMvL0hWWVJYclZwbC8vclh2K3lUVHo1eC82K21aV2lacWttVEp0VTVSWU1NQkFDeTNILys4eDk3ODgwM3JheXN6R1VRaVdiUG5tMFBQUENBOWUzYjEwNDg4VVE3L1BERDNhVHZ1KysrMjM3NDRRZi9VV2IzM1hlZmUreUJCeDVvSjUxMGtrMllNRUdqT0czNjlPbitJellXT1lBb01uWHMyTkg2OU9uak5yMEJBRURqVUxidzZLT1AyckJodzZ4WHIxNysyUis5K09LTDFxNWRPNXM4ZWJKYmRrb3Jwdi8wcHorMXlzcEtlK2VkZDl4anZ2NzZheGM4ZHQ5OWQzZU5KeTFOdGROT085bWdRWVBzcmJmZXFyTTVLM1FBVWVwWFVsSmlXMnl4aFoxenpqbDJ6ejMzMkoxMzNtbW5uSEtLUzQvaW5ob0NRSFB3L3Z2djI0SUZDMXpsWDV1dUZxdmdNSERnUUxmWWJVQ0JSSmZkK082Nzc5enhsMSt1VytKRkFTUFI1cHR2N29LSGZuNHlvUUtJMHA4ZVBYcTRpSGJERFRlNHRFalI3SU1QUG5BWnlISEhIZWNpSGdDZzRXZ05RalV4N2JERERrbXZ3NlFPY3dVUnRSTFZwcnA2NWNxVmJsOTlJOFhGeGRhNmRXdDNIQWhhbE9ycWVFOHJnQ2lDNlVYcWtyWG5uMysrWFhIRkZhN0RSbTFwenozM25NMmZQOSs5RUwycDZ1cHEvMWtBZ0lhZ2VsZnJFSTRmUDk0L3M2RWdRT2d4dGVtY09zNUZqNnZyTWJKNjlXcDNXMXZLQVVUQlEyblBsQ2xUYk5xMGFYYnd3UWZidSsrKzY1cXRGRGdTNlVVcGlBQUFHc2IzMzMvdk9zNzMzSFBQVFM1a3F5d2ttY1RuMWZlbFAvSW9MR1VlUng1NXBGMTQ0WVV1bU54MjIyMzI3My8vMi8ybjZzUlpzMmFOLzhoMW5UcnBERDhEQUtSSHczTFYyZDJtVFJzM0NrdWJNZ1hWeWRwWG5SdzBTU1hXendHZFV6KzJxUG1xcnNkSThMamFVZzRndWxDVXJuLys0WWNmMnIzMzNydCsrTmVpUll0Y0U1Yk9Bd0FheDd4NTgxeWdVRDkwc0gzeHhSZXV2MEw3cjczMm1nc2dHdEMwY09GQy8xbnI2QXUrenJWdjM5NGRLd2lwSHp1WUp4SlEvUzUxOVdtbkhFQVVpVFJKWmNhTUdlNVlUVlJQUC8yMC9lVXZmN0hseTVmYnR0dHU2ODREQUJxZTVtcWNkdHBwRzJ5REJ3KzIwdEpTdDY5NUhQbjUrZGF6WjA4WFdCS0g0czZhTmN0MU5XaVVsV2lPaUh6NjZhZnVWaFJrVk45MzZ0VEpqYXhOSnVVQW9zaWtvYnFhMGZqdHQ5KzZ3UEhLSzYrNFRwYmpqei9lWlNjQWdNYWhyRUdqcEJJM3RSU3BpMEg3R2kwcjIyKy92ZXNrRDFxS1huLzlkWHZ3d1FkZG43YW1ZWWdDaVk0MW91dlZWMTkxajlQRXdybHo1OXJFaVJQZFk1TFJaSTJVT3l1VUNnV3BUdEJKcnVGaEYxMTBrWFh2M3QxMXFvdkdGcXVQUkkrTEt1NTlLYzFwS1lTbVFQbEZRL2xGMDl6S1R3RkFsZjRSUnh6aG4xbEhVeXhlZXVrbDF5UlZWRlRrQW9ZQ1ErS3dYVFY5UGZYVVV5NWJVZDNkcFVzWEYzeUdEQm5pUDJKamFRV1FaUFNmcUdOZDBZc0FFaitVWHpTVVh6U1VYelJ4TDcrVW03QUFBRWhFQUFHQVprN05VcGRmZnJucmVsQldjOHN0dDJSazVDd0JCQUNhT1ExeVVqLzE4ODgvN3haUVZFZTdGbCtNaWdBQ0FDM0FYbnZ0WmUrOTk1NWIvbVMvL2ZiTFNQOFBBUVFBV2dBTjhkV21tZXJCRU4rb0NDQUEwQUpvaU82SUVTTnM1TWlSN3VxRm1VQUFBWUJtVHRjRTBleHpMZnUrODg0N3U2a1d1blJ0VkFRUUFHam10Qmp1VVVjZDVacXd0SHJJMFVjZjdTN0ZFUlVCQkFDYUFmVnRMRm15WlAwMVBoSnBMU3ZOT3RjeVZOcTBYbGF5aTB5Smxvbi82cXV2YlBIaXhmNlp1cWtiUHRKVVIyYWlNNU0xQ3Nvdkdzb3ZtdVpVZmxvbFhjMVNXZ2RMaXlrbTBxVTNOUG9xV0ZCUm1jZysrK3pqK2tRQ0NoajMzMysvVytVM29FdmhIbmpnZ1Vrdk5pVmtJQUNRNVRSUlVDdnA2Z3Q5N2FDakJYQzFjdm8yMjJ4ajU1NTdycDE2NnFudWt1UVBQZlRRK21YZWRjRXBMWlpiVVZIaExsSCttOS84eGwyeVhOZEtmK0tKSjl4amtrazdnR2dDU3JEcEtsVzZyU3VLYitwK0FFQTBhcnBTSlQ5dTNEZ1hRR3BUOXFIK2psMTIyY1ZsRW1yTzJuZmZmVjNRQ0ZxTlB2LzhjOWQwdGZ2dXU3dldKR1VvR3EybHlZWmEwbDJCSlptVUE0Z0NnZGFGSHpWcTFBYWJsZ05PMXBhbUsxZ05IejdjdlFpbFFYbytBQ0N6ZE9Fb1hZbFFvNnRxVTVQVm5EbHpYQjJjK0VWZVFVUVhrOUlGcVdUMjdObnUvbjc5K3JuandJQUJBMXlnVVhCSkp1VmFYYjM0eHg1N3JFdUZIbnZzc2ZYYlhYZmRaVHZ1dUtPTGdnRk5VaGs2ZEtqZGZ2dnQ5c2dqajdpclkya3FQVUVFQURKSDEybDY0WVVYM05Mc1dxYTlOaTNSTHNHVkJ4UHBuSzRUSW5xY090bHI5M1VFVnlJTUhsZGJXaG1Jc29yMzMzL2Zyci8rZXJkZGQ5MTE3c0pTMTF4enpmb3JGWXBTb0QzMjJNTzFzZDEwMDAzMjRvc3YycFFwVTF6UFB3QWdNL1NGWHMxV2FnMUtKcWo0azNXQzYycUZ5bHhFajFPelZXM0I4NExIMVpaeUFGR0VVc2J4OGNjZisyZlNvelFvdUFnVkFDQ2FiNzc1eHEyb08yblNwQTJhcHhJRnJUNkpsN01OcUxOZFFVVDB1TG9lSThIamFrczVnS2dUUlIwdUR6endnQzFZc01CbXpwenBqbFBkTklSTTExVUhBRVNucFVtNmR1MXFQL3p3Z3h0cHBVMzdxcXUxdjNUcDB2VlhIRXhXOXlxclVLdVNGQmNYSjMxTU1LZEVWNkpOUm1FcnJZSGFTblBVMXBadU5xRU1KTXk4RU1hUlIwUDVSVVA1UlVQNVJWTmYrVjEyMldXMmZQbHkvMmhqdSs2NnF4dTYrOGMvL3RIMVNSOXd3QUgrUGV2cTQ2bFRwN3JMMVdxNHJpNkYrOG9ycjdqNUk1cEhFdEJsY0o5OTlsazc4OHd6azNaQnBCMUFHaHNmd0dnb3YyZ292MmdvdjJqU0xiKy8vLzN2YmlMMzZhZWY3cDh4TjZsYmt3TjFMdWhvVjUvMWd3OCthSWNjY29nTkhqell6VHpYb0NjRm5Ra1RKcmpIYUdDVStyaVZuUngzM0hIdVhHME1pd0tBWmt6elA5U3NOVzNhTkpkbGFDWGVoeDkrMkEzdDNYenp6ZDFqTkh5M2YvLytycXRCOTcvODhzdDI4ODAzdXlZeERZaXFDeGxJUkh3RGpJYnlpNGJ5aTZhNWxkK3JyNzdxNW16b2dsR0oxT0d1Q1lXTEZpMXlXWWdDeDdiYmJ1c21ld2ZVeGFBbUs2M2FxMzJON3RwdXUrM2NsUXpyUWdDSmlEL2dhQ2kvYUNpL2FDaS9hR2pDQWdDRVFnQUJBSVJnOXY4QjRoTU9wSStYbHRzQUFBQUFTVVZPUks1Q1lJST1cIjtcbiAgICB9XG4gIH1cbn0iLCIvLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnQudHNcIi8+XG4vLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vVGltZS9UaW1lLnRzXCIvPlxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBtb2RlIGEgbG9vcCBydW5zIGluXG4gICAqL1xuICBleHBvcnQgZW51bSBMT09QX01PREUge1xuICAgIC8qKiBMb29wIGN5Y2xlcyBjb250cm9sbGVkIGJ5IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cbiAgICBGUkFNRV9SRVFVRVNUID0gXCJmcmFtZVJlcXVlc3RcIixcbiAgICAvKiogTG9vcCBjeWNsZXMgY29udHJvbGxlZCBieSB4clNlc3Npb24ucmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXG4gICAgRlJBTUVfUkVRVUVTVF9YUiA9IFwiZnJhbWVSZXF1ZXN0WFJcIixcbiAgICAvKiogTG9vcCBjeWNsZXMgd2l0aCB0aGUgZ2l2ZW4gZnJhbWVyYXRlIGluIHtAbGluayBUaW1lLmdhbWV9ICovXG4gICAgVElNRV9HQU1FID0gXCJ0aW1lR2FtZVwiLFxuICAgIC8qKiBMb29wIGN5Y2xlcyB3aXRoIHRoZSBnaXZlbiBmcmFtZXJhdGUgaW4gcmVhbHRpbWUsIGluZGVwZW5kZW50IG9mIHtAbGluayBUaW1lLmdhbWV9ICovXG4gICAgVElNRV9SRUFMID0gXCJ0aW1lUmVhbFwiXG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb29wIG9mIGEgRlVER0UgYXBwbGljYXRpb24uIEluaXRpYWxpemVzIGF1dG9tYXRpY2FsbHkgYW5kIG11c3QgYmUgc3RhcnRlZCBleHBsaWNpdGx5LlxuICAgKiBJdCB0aGVuIGZpcmVzIHtAbGluayBFVkVOVC5MT09QX0ZSQU1FfSB0byBhbGwgYWRkZWQgbGlzdGVuZXJzIGF0IGVhY2ggZnJhbWVcbiAgICogXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcbiAgICovXG4gIGV4cG9ydCBjbGFzcyBMb29wIGV4dGVuZHMgRXZlbnRUYXJnZXRTdGF0aWMge1xuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZVN0YXJ0R2FtZTogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVTdGFydFJlYWw6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lRnJhbWVHYW1lOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lUmVhbDogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVGcmFtZVN0YXJ0R2FtZTogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVGcmFtZVN0YXJ0UmVhbDogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVMYXN0RnJhbWVHYW1lQXZnOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUxhc3RGcmFtZVJlYWxBdmc6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJGcmFtZXM6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgc3RhdGljIG1vZGU6IExPT1BfTU9ERSA9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUO1xuICAgIHByaXZhdGUgc3RhdGljIGlkSW50ZXJ2YWxsOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgc3RhdGljIGlkUmVxdWVzdDogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN0YXRpYyBmcHNEZXNpcmVkOiBudW1iZXIgPSAzMDtcbiAgICBwcml2YXRlIHN0YXRpYyBmcmFtZXNUb0F2ZXJhZ2U6IG51bWJlciA9IDMwO1xuICAgIHByaXZhdGUgc3RhdGljIHN5bmNXaXRoQW5pbWF0aW9uRnJhbWU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lU3RhcnRHYW1lKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZVN0YXJ0R2FtZTsgfVxuICAgIC8qKiBUaGUgcmVhbHRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lU3RhcnRSZWFsKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZVN0YXJ0UmVhbDsgfVxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBsb29wIGN5Y2xlICovXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZUZyYW1lR2FtZSgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVGcmFtZUdhbWU7IH1cbiAgICAvKiogVGhlIHJlYWx0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgbG9vcCBjeWNsZSAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZVJlYWwoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVSZWFsOyB9XG4gICAgLyoqIFRoZSBnYW1ldGltZSB0aGUgbGFzdCBsb29wIGN5Y2xlIHN0YXJ0ZWQqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZVN0YXJ0R2FtZSgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZTsgfVxuICAgIC8qKiBUaGUgcmVhbHRpbWUgdGhlIGxhc3QgbG9vcCBjeWNsZSBzdGFydGVkKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lRnJhbWVTdGFydFJlYWwoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWw7IH1cbiAgICAvKiogVGhlIGF2ZXJhZ2UgbnVtYmVyIG9mIGZyYW1lcyBwZXIgc2Vjb25kIGluIGdhbWV0aW1lICovXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZnBzR2FtZUF2ZXJhZ2UoKTogbnVtYmVyIHsgcmV0dXJuIDEwMDAgLyBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmc7IH1cbiAgICAvKiogVGhlIGF2ZXJhZ2UgbnVtYmVyIG9mIGZyYW1lcyBwZXIgc2Vjb25kIGluIHJlYWx0aW1lICovXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZnBzUmVhbEF2ZXJhZ2UoKTogbnVtYmVyIHsgcmV0dXJuIDEwMDAgLyBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmc7IH1cbiAgICAvKiogVGhlIG51bWJlciBvZiBmcmFtZXMgdHJpZ2dlcmVkIHNvIGZhciAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGZyYW1lcygpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GkkZyYW1lczsgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBsb29wIHdpdGggdGhlIGdpdmVuIG1vZGUgYW5kIGZwcy4gIFxuICAgICAqIFRoZSBkZWZhdWx0IGZvciBfbW9kZSBpcyBGUkFNRV9SRVFVRVNULCBzZWUge0BsaW5rIExPT1BfTU9ERX0sIGhvb2tpbmcgdGhlIGxvb3AgdG8gdGhlIGJyb3dzZXIncyBhbmltYXRpb24gZnJhbWUuXG4gICAgICogSXMgb25seSBhcHBsaWNhYmxlIGluIFRJTUUtbW9kZXMuXG4gICAgICogX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWUgaXMgZXhwZXJpbWVudGFsIGFuZCBvbmx5IGFwcGxpY2FibGUgaW4gVElNRS1tb2RlcywgZGVmZXJyaW5nIHRoZSBsb29wLWN5Y2xlIHVudGlsIHRoZSBuZXh0IHBvc3NpYmxlIGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0KF9tb2RlOiBMT09QX01PREUgPSBMT09QX01PREUuRlJBTUVfUkVRVUVTVCwgX2ZwczogbnVtYmVyID0gNjAsIF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgIExvb3Auc3RvcCgpO1xuXG4gICAgICBMb29wLsaSVGltZVN0YXJ0R2FtZSA9IFRpbWUuZ2FtZS5nZXQoKTtcbiAgICAgIExvb3AuxpJUaW1lU3RhcnRSZWFsID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRHYW1lID0gTG9vcC7GklRpbWVTdGFydEdhbWU7XG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRSZWFsID0gTG9vcC7GklRpbWVTdGFydFJlYWw7XG4gICAgICBMb29wLmZwc0Rlc2lyZWQgPSAoX21vZGUgPT0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1QpID8gNjAgOiBfZnBzO1xuICAgICAgTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgPSBMb29wLmZwc0Rlc2lyZWQ7XG4gICAgICBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmcgPSBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmcgPSAxMDAwIC8gTG9vcC5mcHNEZXNpcmVkO1xuICAgICAgTG9vcC5tb2RlID0gX21vZGU7XG4gICAgICBMb29wLnN5bmNXaXRoQW5pbWF0aW9uRnJhbWUgPSBfc3luY1dpdGhBbmltYXRpb25GcmFtZTtcblxuICAgICAgbGV0IGxvZzogc3RyaW5nID0gYExvb3Agc3RhcnRpbmcgaW4gbW9kZSAke0xvb3AubW9kZX1gO1xuICAgICAgaWYgKExvb3AubW9kZSAhPSBMT09QX01PREUuRlJBTUVfUkVRVUVTVClcbiAgICAgICAgbG9nICs9IGAgd2l0aCBhdHRlbXB0ZWQgJHtfZnBzfSBmcHNgO1xuICAgICAgRGVidWcuZnVkZ2UobG9nKTtcblxuICAgICAgc3dpdGNoIChfbW9kZSkge1xuICAgICAgICBjYXNlIExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUOlxuICAgICAgICAgIExvb3AubG9vcEZyYW1lKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1RfWFI6XG4gICAgICAgICAgTG9vcC5sb29wRnJhbWVYUigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX1JFQUw6XG4gICAgICAgICAgTG9vcC5pZEludGVydmFsbCA9IHdpbmRvdy5zZXRJbnRlcnZhbChMb29wLmxvb3BUaW1lLCAxMDAwIC8gTG9vcC5mcHNEZXNpcmVkKTtcbiAgICAgICAgICBMb29wLmxvb3BUaW1lKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfR0FNRTpcbiAgICAgICAgICBMb29wLmlkSW50ZXJ2YWxsID0gVGltZS5nYW1lLnNldFRpbWVyKDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQsIDAsIExvb3AubG9vcFRpbWUpO1xuICAgICAgICAgIExvb3AubG9vcFRpbWUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgTG9vcC5ydW5uaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgbG9vcFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc3RvcCgpOiB2b2lkIHtcbiAgICAgIGlmICghTG9vcC5ydW5uaW5nKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHN3aXRjaCAoTG9vcC5tb2RlKSB7XG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q6XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMT09QX01PREUuRlJBTUVfUkVRVUVTVF9YUjpcbiAgICAgICAgICBYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbi5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XG4gICAgICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX1JFQUw6XG4gICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoTG9vcC5pZEludGVydmFsbCk7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9HQU1FOlxuICAgICAgICAgIFRpbWUuZ2FtZS5kZWxldGVUaW1lcihMb29wLmlkSW50ZXJ2YWxsKTtcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBMb29wLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIERlYnVnLmZ1ZGdlKFwiTG9vcCBzdG9wcGVkIVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb250aW51ZSBydW5uaW5nIHRoZSBsb29wXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBjb250aW51ZSgpOiB2b2lkIHtcbiAgICAgIGlmIChMb29wLnJ1bm5pbmcpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgTG9vcC5zdGFydChMb29wLm1vZGUsIExvb3AuZnBzRGVzaXJlZCwgTG9vcC5zeW5jV2l0aEFuaW1hdGlvbkZyYW1lKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsb29wKCk6IHZvaWQge1xuICAgICAgbGV0IHRpbWU6IG51bWJlcjtcbiAgICAgIHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVSZWFsID0gdGltZSAtIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWw7XG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRSZWFsID0gdGltZTtcblxuICAgICAgdGltZSA9IFRpbWUuZ2FtZS5nZXQoKTtcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVHYW1lID0gdGltZSAtIExvb3AuxpJUaW1lRnJhbWVTdGFydEdhbWU7XG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRHYW1lID0gdGltZTtcblxuICAgICAgTG9vcC7GklRpbWVMYXN0RnJhbWVHYW1lQXZnID0gKChMb29wLmZyYW1lc1RvQXZlcmFnZSAtIDEpICogTG9vcC7GklRpbWVMYXN0RnJhbWVHYW1lQXZnICsgTG9vcC7GklRpbWVGcmFtZUdhbWUpIC8gTG9vcC5mcmFtZXNUb0F2ZXJhZ2U7XG4gICAgICBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmcgPSAoKExvb3AuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmcgKyBMb29wLsaSVGltZUZyYW1lUmVhbCkgLyBMb29wLmZyYW1lc1RvQXZlcmFnZTtcblxuICAgICAgLy8gVE9ETzogY29uc2lkZXIgTG9vcEV2ZW50IHdoaWNoIGNvbnZleXMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aW1lRWxhcHNlZCBldGMuLi5cbiAgICAgIExvb3AuxpJGcmFtZXMrKztcbiAgICAgIGxldCBldmVudDogRXZlbnQgPSBuZXcgRXZlbnQoRVZFTlQuTE9PUF9GUkFNRSk7XG4gICAgICBMb29wLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsb29wRnJhbWUoKTogdm9pZCB7XG4gICAgICBMb29wLmxvb3AoKTtcbiAgICAgIExvb3AuaWRSZXF1ZXN0ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShMb29wLmxvb3BGcmFtZSk7XG4gICAgfVxuICAgIHByaXZhdGUgc3RhdGljIGxvb3BGcmFtZVhSKF90aW1lOiBudW1iZXIgPSBudWxsLCBfeHJGcmFtZTogWFJGcmFtZSA9IG51bGwpOiB2b2lkIHtcbiAgICAgIExvb3AubG9vcCgpO1xuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LmRyYXcodHJ1ZSwgX3hyRnJhbWUpO1xuICAgICAgTG9vcC5pZFJlcXVlc3QgPSBYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoTG9vcC5sb29wRnJhbWVYUik7XG4gICAgfVxuICAgIHByaXZhdGUgc3RhdGljIGxvb3BUaW1lKCk6IHZvaWQge1xuICAgICAgaWYgKExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSlcbiAgICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcCk7XG4gICAgICBlbHNlXG4gICAgICAgIExvb3AubG9vcCgpO1xuICAgIH1cbiAgfVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGltZVVuaXRzIHtcbiAgICBob3Vycz86IG51bWJlcjtcbiAgICBtaW51dGVzPzogbnVtYmVyO1xuICAgIHNlY29uZHM/OiBudW1iZXI7XG4gICAgdGVudGhzPzogbnVtYmVyO1xuICAgIGh1bmRyZWRzPzogbnVtYmVyO1xuICAgIHRob3VzYW5kcz86IG51bWJlcjtcbiAgICBmcmFjdGlvbj86IG51bWJlcjtcbiAgICBhc0hvdXJzPzogbnVtYmVyO1xuICAgIGFzTWludXRlcz86IG51bWJlcjtcbiAgICBhc1NlY29uZHM/OiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVycyBleHRlbmRzIE9iamVjdCB7XG4gICAgW2lkOiBudW1iZXJdOiBUaW1lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBnZW5lcmF0ZSBhIHRpbWVzdGFtcCB0aGF0IGNvcnJlbGF0ZXMgd2l0aCB0aGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBidXQgYWxsb3dzIGZvciByZXNldHRpbmcgYW5kIHNjYWxpbmcuICBcbiAgICogU3VwcG9ydHMge0BsaW5rIFRpbWVyfXMgc2ltaWxhciB0byB3aW5kb3cuc2V0SW50ZXJ2YWwgYnV0IHdpdGggcmVzcGVjdCB0byB0aGUgc2NhbGVkIHRpbWUuXG4gICAqIEFsbCB0aW1lIHZhbHVlcyBhcmUgZ2l2ZW4gaW4gbWlsbGlzZWNvbmRzXG4gICAqIFxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxuICAgKi9cbiAgZXhwb3J0IGNsYXNzIFRpbWUgZXh0ZW5kcyBFdmVudFRhcmdldFVuaWZpZWQge1xuICAgIC8qKiBTdGFuZGFyZCBnYW1lIHRpbWUgc3RhcnRpbmcgYXV0b21hdGljYWxseSB3aXRoIHRoZSBhcHBsaWNhdGlvbiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZ2FtZTogVGltZSA9IG5ldyBUaW1lKCk7XG4gICAgcHJpdmF0ZSBzdGFydDogbnVtYmVyO1xuICAgIHByaXZhdGUgc2NhbGU6IG51bWJlcjtcbiAgICBwcml2YXRlIG9mZnNldDogbnVtYmVyO1xuICAgIHByaXZhdGUgbGFzdENhbGxUb0VsYXBzZWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIHRpbWVyczogVGltZXJzID0ge307XG4gICAgcHJpdmF0ZSBpZFRpbWVyQWRkZWRMYXN0OiBudW1iZXIgPSAwO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuc2NhbGUgPSAxLjA7XG4gICAgICB0aGlzLm9mZnNldCA9IDAuMDtcbiAgICAgIHRoaXMubGFzdENhbGxUb0VsYXBzZWQgPSAwLjA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByZXByZXNlbnRpb25zIG9mIHRoZSB0aW1lIGdpdmVuIGluIG1pbGxpc2Vjb25kcyBpbiB2YXJpb3VzIGZvcm1hdHMgZGVmaW5lZCBpbiB7QGxpbmsgVGltZVVuaXRzfVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VW5pdHMoX21pbGxpc2Vjb25kczogbnVtYmVyKTogVGltZVVuaXRzIHtcbiAgICAgIGxldCB1bml0czogVGltZVVuaXRzID0ge307XG5cbiAgICAgIHVuaXRzLmFzU2Vjb25kcyA9IF9taWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgdW5pdHMuYXNNaW51dGVzID0gdW5pdHMuYXNTZWNvbmRzIC8gNjA7XG4gICAgICB1bml0cy5hc0hvdXJzID0gdW5pdHMuYXNNaW51dGVzIC8gNjA7XG5cbiAgICAgIHVuaXRzLmhvdXJzID0gTWF0aC5mbG9vcih1bml0cy5hc0hvdXJzKTtcbiAgICAgIHVuaXRzLm1pbnV0ZXMgPSBNYXRoLmZsb29yKHVuaXRzLmFzTWludXRlcykgJSA2MDtcbiAgICAgIHVuaXRzLnNlY29uZHMgPSBNYXRoLmZsb29yKHVuaXRzLmFzU2Vjb25kcykgJSA2MDtcblxuICAgICAgdW5pdHMuZnJhY3Rpb24gPSBfbWlsbGlzZWNvbmRzICUgMTAwMDtcbiAgICAgIHVuaXRzLnRob3VzYW5kcyA9IF9taWxsaXNlY29uZHMgJSAxMDtcbiAgICAgIHVuaXRzLmh1bmRyZWRzID0gX21pbGxpc2Vjb25kcyAlIDEwMCAtIHVuaXRzLnRob3VzYW5kcztcbiAgICAgIHVuaXRzLnRlbnRocyA9IHVuaXRzLmZyYWN0aW9uIC0gdW5pdHMuaHVuZHJlZHMgLSB1bml0cy50aG91c2FuZHM7XG5cbiAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICAvLyNyZWdpb24gR2V0L1NldCB0aW1lIGFuZCBzY2FsaW5nXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHNjYWxlZCB0aW1lc3RhbXAgb2YgdGhpcyBpbnN0YW5jZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLnNjYWxlICogKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVtYWluaW5nIHRpbWUgdG8gdGhlIGdpdmVuIHBvaW50IG9mIHRpbWVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UmVtYWluZGVyKF90bzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiBfdG8gLSB0aGlzLmdldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIChSZS0pIFNldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGlzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lc3RhbXAgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHRpbWUgKGRlZmF1bHQgMC4wKVxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQoX3RpbWU6IG51bWJlciA9IDApOiB2b2lkIHtcbiAgICAgIHRoaXMub2Zmc2V0ID0gX3RpbWU7XG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLmdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjYWxpbmcgb2YgdGhpcyB0aW1lLCBhbGxvd2luZyBmb3Igc2xvd21vdGlvbiAoPDEpIG9yIGZhc3Rmb3J3YXJkICg+MSkgXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgZGVzaXJlZCBzY2FsaW5nIChkZWZhdWx0IDEuMClcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0U2NhbGUoX3NjYWxlOiBudW1iZXIgPSAxLjApOiB2b2lkIHtcbiAgICAgIHRoaXMuc2V0KHRoaXMuZ2V0KCkpO1xuICAgICAgdGhpcy5zY2FsZSA9IF9zY2FsZTtcbiAgICAgIC8vVE9ETzogY2F0Y2ggc2NhbGU9MFxuICAgICAgdGhpcy5yZXNjYWxlQWxsVGltZXJzKCk7XG4gICAgICB0aGlzLmdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5USU1FX1NDQUxFRCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzY2FsaW5nIG9mIHRoaXMgdGltZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTY2FsZSgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBvZmZzZXQgb2YgdGhpcyB0aW1lXG4gICAgICovXG4gICAgcHVibGljIGdldE9mZnNldCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc2NhbGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgbWV0aG9kXG4gICAgICogQXV0b21hdGljYWxseSByZXNldCBhdCBldmVyeSBjYWxsIHRvIHNldCguLi4pIGFuZCBzZXRTY2FsZSguLi4pXG4gICAgICovXG4gICAgcHVibGljIGdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpOiBudW1iZXIge1xuICAgICAgbGV0IGN1cnJlbnQ6IG51bWJlciA9IHRoaXMuZ2V0KCk7XG4gICAgICBsZXQgZWxhcHNlZDogbnVtYmVyID0gY3VycmVudCAtIHRoaXMubGFzdENhbGxUb0VsYXBzZWQ7XG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gY3VycmVudDtcbiAgICAgIHJldHVybiBlbGFwc2VkO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cblxuXG4gICAgLy8jcmVnaW9uIFRpbWVyc1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBQcm9taXNlPHZvaWQ+IHRvIGJlIHJlc29sdmVkIGFmdGVyIHRoZSB0aW1lIGdpdmVuLiBUbyBiZSB1c2VkIHdpdGggYXN5bmMvYXdhaXRcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVsYXkoX2xhcHNlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShfcmVzb2x2ZSA9PiB0aGlzLnNldFRpbWVyKF9sYXBzZSwgMSwgKCkgPT4gX3Jlc29sdmUoKSkpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGV4YW1pbmUgaWYgd2ViLXdvcmtlcnMgd291bGQgZW5oYW5jZSBwZXJmb3JtYW5jZSBoZXJlIVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuZCBkZWxldGVzIGFsbCB7QGxpbmsgVGltZXJ9cyBhdHRhY2hlZC4gU2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBUaW1lLW9iamVjdCBsZWF2ZXMgc2NvcGVcbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJBbGxUaW1lcnMoKTogdm9pZCB7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xuICAgICAgICB0aGlzLmRlbGV0ZVRpbWVyKE51bWJlcihpZCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMge0BsaW5rIFRpbWVyfSBmb3VuZCB1c2luZyB0aGUgaW50ZXJuYWwgaWQgb2YgdGhlIGNvbm5lY3RlZCBpbnRlcnZhbC1vYmplY3RcbiAgICAgKiBAcGFyYW0gX2lkIFxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZChfaWQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcbiAgICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW2lkXTtcbiAgICAgICAgaWYgKHRpbWVyLmlkID09IF9pZCkge1xuICAgICAgICAgIHRpbWVyLmNsZWFyKCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGltZXJzW2lkXTtcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbiBlYXJseSBvdXQgaXMgT0sgaGVyZS4uLiBzaG91bGQgYmUhXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxscyBhIHRpbWVyIGF0IHRoaXMgdGltZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gX2xhcHNlIFRoZSBvYmplY3QtdGltZSB0byBlbGFwc2UgYmV0d2VlbiB0aGUgY2FsbHMgdG8gX2NhbGxiYWNrXG4gICAgICogQHBhcmFtIF9jb3VudCBUaGUgbnVtYmVyIG9mIGNhbGxzIGRlc2lyZWQsIDAgPSBJbmZpbml0ZVxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCBlYWNoIHRoZSBnaXZlbiBsYXBzZSBoYXMgZWxhcHNlZFxuICAgICAqIEBwYXJhbSBfYXJndW1lbnRzIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRvIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcHVibGljIHNldFRpbWVyKF9sYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pOiBudW1iZXIge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bnVzZWQtZXhwcmVzc2lvblxuICAgICAgbmV3IFRpbWVyKHRoaXMsIF9sYXBzZSwgX2NvdW50LCBfaGFuZGxlciwgX2FyZ3VtZW50cyk7XG4gICAgICAvL3RoaXMuYWRkVGltZXIodGltZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuaWRUaW1lckFkZGVkTGFzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgVGltZX0gYW5kIHtAbGluayBUaW1lcn0gYW5kIG11c3Qgbm90IGJlIGNhbGxlZCBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkVGltZXIoX3RpbWVyOiBUaW1lcik6IG51bWJlciB7XG4gICAgICB0aGlzLnRpbWVyc1srK3RoaXMuaWRUaW1lckFkZGVkTGFzdF0gPSBfdGltZXI7XG4gICAgICByZXR1cm4gdGhpcy5pZFRpbWVyQWRkZWRMYXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIHRpbWVyIHdpdGggdGhlIGlkIGdpdmVuIGJ5IHRoaXMgdGltZSBvYmplY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVsZXRlVGltZXIoX2lkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tfaWRdO1xuICAgICAgaWYgKCF0aW1lcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGltZXIuY2xlYXIoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tfaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHRpbWVyIHdpdGggdGhlIGdpdmVuIGlkIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUaW1lcihfaWQ6IG51bWJlcik6IFRpbWVyIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVyc1tfaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaXN0IG9mIHRpbWVycyBjdXJyZW50bHkgaW5zdGFsbGVkIG9uIHRoaXMgdGltZSBvYmplY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGltZXJzKCk6IFRpbWVycyB7XG4gICAgICBsZXQgcmVzdWx0OiBUaW1lcnMgPSB7fTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdGhpcy50aW1lcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUge0BsaW5rIFRpbWVyc30gaW5zdGFsbGVkIHRvIHRoaXNcbiAgICAgKi9cbiAgICBwdWJsaWMgaGFzVGltZXJzKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIChPYmplY3Qua2V5cyh0aGlzLnRpbWVycykubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjcmVhdGVzIHtAbGluayBUaW1lcn1zIHdoZW4gc2NhbGluZyBjaGFuZ2VzXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXNjYWxlQWxsVGltZXJzKCk6IHZvaWQge1xuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcbiAgICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW2lkXTtcbiAgICAgICAgdGltZXIuY2xlYXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGltZXJzW2lkXTtcbiAgICAgICAgaWYgKCF0aGlzLnNjYWxlKVxuICAgICAgICAgIC8vIFRpbWUgaGFzIHN0b3BwZWQsIG5vIG5lZWQgdG8gcmVwbGFjZSBjbGVhcmVkIHRpbWVyc1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8qIHRoaXMudGltZXJzW2lkXSA9ICAqL1xuICAgICAgICB0aW1lciA9IHRpbWVyLmluc3RhbGxDb3B5KCk7IC8vIHRoZSB0aW1lciBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoaXMgdGltZSBpbnN0YW5jZVxuICAgICAgICBkZWxldGUgdGhpcy50aW1lcnNbdGhpcy5pZFRpbWVyQWRkZWRMYXN0XTsgLy8gcmVtb3ZlIHRoZSBjb3B5IGFnYWluIC4uLlxuICAgICAgICB0aGlzLnRpbWVyc1tpZF0gPSB0aW1lcjsgLy8gLi4uIGFuZCBwbGFjZSBpdCBhdCB0aGUgaWQgb2YgdGhlIG9yaWdpbmFsXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vI2VuZHJlZ2lvblxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuICAvKipcbiAgICogRGVmaW5lcyB0aGUgc2lnbmF0dXJlIG9mIGhhbmRsZXIgZnVuY3Rpb25zIGZvciB7QGxpbmsgRXZlbnRUaW1lcn1zLCB2ZXJ5IHNpbWlsYXIgdG8gdXN1YWwgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGltZXJIYW5kbGVyID0gKF9ldmVudDogRXZlbnRUaW1lcikgPT4gdm9pZDtcblxuICAvKipcbiAgICogQSB7QGxpbmsgVGltZXJ9LWluc3RhbmNlIGludGVybmFsbHkgdXNlcyB3aW5kb3cuc2V0SW50ZXJ2YWwgdG8gY2FsbCBhIGdpdmVuIGhhbmRsZXIgd2l0aCBhIGdpdmVuIGZyZXF1ZW5jeSBhIGdpdmVuIG51bWJlciBvZiB0aW1lcyxcbiAgICogcGFzc2luZyBhbiB7QGxpbmsgRXZlbnRUaW1lcn0taW5zdGFuY2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFuZCBnaXZlbiBhcmd1bWVudHMuIFxuICAgKiBUaGUgZnJlcXVlbmN5IHNjYWxlcyB3aXRoIHRoZSB7QGxpbmsgVGltZX0taW5zdGFuY2UgdGhlIHtAbGluayBUaW1lcn0taW5zdGFuY2UgaXMgYXR0YWNoZWQgdG8uXG4gICAqIFxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XG4gICAqL1xuICBleHBvcnQgY2xhc3MgVGltZXIge1xuICAgIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW47XG4gICAgcHVibGljIGNvdW50OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBoYW5kbGVyOiBUaW1lckhhbmRsZXI7XG4gICAgcHJpdmF0ZSB0aW1lOiBUaW1lO1xuICAgIHByaXZhdGUgZWxhcHNlOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBldmVudDogRXZlbnRUaW1lcjtcbiAgICBwcml2YXRlIHRpbWVvdXRSZWFsOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBpZFdpbmRvdzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBUaW1lcn0gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB7QGxpbmsgVGltZX0gaW5zdGFuY2UsIHRoZSB0aW1lciBhdHRhY2hlcyB0b1xuICAgICAqIEBwYXJhbSBfZWxhcHNlIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBlbGFwc2UsIHRvIHRoZSBuZXh0IGNhbGwgb2YgX2hhbmRsZXIsIG1lYXN1cmVkIGluIF90aW1lXG4gICAgICogQHBhcmFtIF9jb3VudCBUaGUgZGVzaXJlZCBudW1iZXIgb2YgY2FsbHMgdG8gX2hhbmRsZXIsIFRpbWVyIGRlaW5zdGFsbHMgYXV0b21hdGljYWxseSBhZnRlciBsYXN0IGNhbGwuIFBhc3NpbmcgMCBpbnZva2VzIGluZmluaXRlIGNhbGxzXG4gICAgICogQHBhcmFtIF9oYW5kbGVyIFRoZSB7QGxpbmsgVGltZXJIYW5kbGVyfSBpbnN0YW5jZSB0byBjYWxsXG4gICAgICogQHBhcmFtIF9hcmd1bWVudHMgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byBfaGFuZGxlclxuICAgICAqIFxuICAgICAqIFRPRE86IGZvciBwcm9wZXIgaGFuZGxpbmcgYW5kIGRlbGV0aW9uLCB1c2UgVGltZS5zZXRUaW1lciBpbnN0ZWFkIG9mIGluc3RhbnRpYXRpbmcgdGltZXJzIHlvdXJzZWxmLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdGltZTogVGltZSwgX2VsYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xuICAgICAgdGhpcy5lbGFwc2UgPSBfZWxhcHNlO1xuICAgICAgdGhpcy5ldmVudCA9IG5ldyBFdmVudFRpbWVyKHRoaXMsIF9hcmd1bWVudHMpO1xuICAgICAgdGhpcy5oYW5kbGVyID0gX2hhbmRsZXI7XG4gICAgICB0aGlzLmNvdW50ID0gX2NvdW50O1xuXG4gICAgICBsZXQgc2NhbGU6IG51bWJlciA9IE1hdGguYWJzKF90aW1lLmdldFNjYWxlKCkpO1xuXG4gICAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAgIC8vIFRpbWUgaXMgc3RvcHBlZCwgdGltZXIgd29uJ3QgYmUgYWN0aXZlXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy50aW1lb3V0UmVhbCA9IHRoaXMuZWxhcHNlIC8gc2NhbGU7XG5cbiAgICAgIGxldCBjYWxsYmFjazogRnVuY3Rpb24gPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuZXZlbnQuY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICB0aGlzLmV2ZW50Lmxhc3RDYWxsID0gKHRoaXMuY291bnQgPT0gMSk7XG4gICAgICAgIF9oYW5kbGVyKHRoaXMuZXZlbnQpO1xuICAgICAgICB0aGlzLmV2ZW50LmZpcnN0Q2FsbCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmNvdW50ID4gMClcbiAgICAgICAgICBpZiAoLS10aGlzLmNvdW50ID09IDApXG4gICAgICAgICAgICBfdGltZS5kZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZCh0aGlzLmlkV2luZG93KTtcblxuICAgICAgfTtcblxuICAgICAgdGhpcy5pZFdpbmRvdyA9IHdpbmRvdy5zZXRJbnRlcnZhbChjYWxsYmFjaywgdGhpcy50aW1lb3V0UmVhbCwgX2FyZ3VtZW50cyk7XG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICBfdGltZS5hZGRUaW1lcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aW5kb3ctaWQgb2YgdGhlIHRpbWVyLCB3aGljaCB3YXMgcmV0dXJuZWQgYnkgc2V0SW50ZXJ2YWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5pZFdpbmRvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lLWludGVydmFsbCBmb3IgY2FsbHMgdG8gdGhlIGhhbmRsZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxhcHNlKCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5lbGFwc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYSBjb3B5IG9mIHRoaXMgYXQgaXRzIGN1cnJlbnQgc3RhdGUgdG8gdGhlIHNhbWUge0BsaW5rIFRpbWV9LWluc3RhbmNlLiBVc2VkIGludGVybmFsbHkgd2hlbiByZXNjYWxpbmcge0BsaW5rIFRpbWV9XG4gICAgICovXG4gICAgcHVibGljIGluc3RhbGxDb3B5KCk6IFRpbWVyIHtcbiAgICAgIHJldHVybiBuZXcgVGltZXIodGhpcy50aW1lLCB0aGlzLmVsYXBzZSwgdGhpcy5jb3VudCwgdGhpcy5oYW5kbGVyLCB0aGlzLmV2ZW50LmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSB0aW1lciwgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgaW50ZXJ2YWwtdGltZXJzIGhhbmRsZWQgYnkgd2luZG93XG4gICAgICovXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgICAgLy8gaWYgKHRoaXMudHlwZSA9PSBUSU1FUl9UWVBFLlRJTUVPVVQpIHtcbiAgICAgIC8vICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAvLyAgICAgICAgIC8vIHNhdmUgcmVtYWluaW5nIHRpbWUgdG8gdGltZW91dCBhcyBuZXcgdGltZW91dCBmb3IgcmVzdGFydFxuICAgICAgLy8gICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQgKiAoMSAtIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lUmVhbCkgLyB0aGlzLnRpbWVvdXRSZWFsKTtcbiAgICAgIC8vICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgLy8gfVxuICAgICAgLy8gZWxzZVxuICAgICAgLy8gVE9ETzogcmV1c2luZyB0aW1lciBzdGFydHMgaW50ZXJ2YWwgYW5ldy4gU2hvdWxkIGJlIHJlbWFpbmluZyBpbnRlcnZhbCBhcyB0aW1lb3V0LCB0aGVuIHN0YXJ0aW5nIGludGVydmFsIGFuZXcgXG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmlkV2luZG93KTtcbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59Il19