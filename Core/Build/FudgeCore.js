"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["SOURCE"] = 512] = "SOURCE";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "‚úì",
        [DEBUG_FILTER.LOG]: "‚úé",
        [DEBUG_FILTER.WARN]: "‚ö†",
        [DEBUG_FILTER.ERROR]: "‚ùå",
        [DEBUG_FILTER.FUDGE]: "üé≤",
        [DEBUG_FILTER.SOURCE]: "üîó"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    class DebugConsole extends FudgeCore.DebugTarget {
        /**
         * Should be used to display uncritical state information of FUDGE, only visible in browser's verbose mode
         */
        static fudge(_message, ..._args) {
            console.debug(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE], _message, ..._args);
        }
        /**
         * Displays an extra line with information about the source of the debug message
         */
        static source(_message, ..._args) {
            console.log(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE], _message, ..._args);
        }
    }
    DebugConsole.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: console.info,
        [FudgeCore.DEBUG_FILTER.LOG]: console.log,
        [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
        [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
        [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,
        [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source
    };
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various {@link DebugTarget}s that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of {@link DebugTarget} and register them as their delegates
     */
    class Debug {
        /**
         * De- / Activate a filter for the given DebugTarget.
         */
        static setFilter(_target, _filter) {
            for (let filter in Debug.delegates)
                Debug.delegates[filter].delete(_target);
            for (let filter in FudgeCore.DEBUG_FILTER) {
                let parsed = parseInt(filter);
                if (isNaN(parsed))
                    break;
                if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                    // dont delegate combos... 
                    continue;
                if (_filter & parsed)
                    Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
            }
        }
        /**
         * Info(...) displays additional information with low priority
         */
        static info(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
        }
        /**
         * Displays information with medium priority
         */
        static log(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
        }
        /**
         * Displays information about non-conformities in usage, which is emphasized e.g. by color
         */
        static warn(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
        }
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static error(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
        }
        /**
         * Displays messages from FUDGE
         */
        static fudge(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
        }
        /**
         * Clears the output and removes previous messages if possible
         */
        static clear() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
        }
        /**
         * Opens a new group for messages
         */
        static group(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
        }
        /**
         * Opens a new group for messages that is collapsed at first
         */
        static groupCollapsed(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
        }
        /**
         * Closes the youngest group
         */
        static groupEnd() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
        }
        /**
         * Log a branch of the node hierarchy
         */
        static branch(_branch) {
            if (_branch.nChildren > 0)
                Debug.group(_branch.name);
            else
                Debug.fudge(_branch.name);
            for (let child of _branch.getChildren())
                Debug.branch(child);
            if (_branch.nChildren > 0)
                Debug.groupEnd();
        }
        /**
         * Displays messages about the source of the debug call
         */
        static source(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.SOURCE, _message, _args);
        }
        /**
         * Lookup all delegates registered to the filter and call them using the given arguments
         */
        static delegate(_filter, _message, _args) {
            if (_filter == FudgeCore.DEBUG_FILTER.LOG || _filter == FudgeCore.DEBUG_FILTER.WARN || _filter == FudgeCore.DEBUG_FILTER.ERROR) {
                if (Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE])
                    for (let delegate of Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE].values())
                        if (delegate) {
                            let trace = new Error("Test").stack.split("\n");
                            delegate(trace[3]);
                        }
            }
            let delegates = Debug.delegates[_filter];
            for (let delegate of delegates.values())
                if (delegate)
                    if (_args && _args.length > 0)
                        delegate(_message, ..._args);
                    else
                        delegate(_message);
        }
        /**
         * setup routing to standard console
         */
        static setupConsole() {
            let result = {};
            let filters = [
                FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND,
                FudgeCore.DEBUG_FILTER.SOURCE
            ];
            for (let filter of filters)
                result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
            result[FudgeCore.DEBUG_FILTER.SOURCE].delete(FudgeCore.DebugConsole);
            return result;
        }
    }
    /**
     * For each set filter, this associative array keeps references to the registered delegate functions of the chosen {@link DebugTarget}s
     */
    Debug.delegates = Debug.setupConsole();
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // export type EventListener∆í = ((_event: Event∆í) => void) | EventListener | EventListenerObject;
    class EventTarget∆í extends EventTarget {
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTarget∆í = EventTarget∆í;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of Fudge, such as the core loop
     */
    class EventTargetStatic extends EventTarget∆í {
        constructor() {
            super();
        }
        static addEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.addEventListener(_type, _handler);
        }
        static removeEventListener(_type, _handler) {
            EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
        }
        static dispatchEvent(_event) {
            EventTargetStatic.targetStatic.dispatchEvent(_event);
            return true;
        }
    }
    EventTargetStatic.targetStatic = new EventTargetStatic();
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    /**
     * Base class for all types being mutable using {@link Mutator}-objects, thus providing and using interfaces created at runtime.
     * Mutables provide a {@link Mutator} that is build by collecting all object-properties that are either of a primitive type or again Mutable.
     * Subclasses can either reduce the standard {@link Mutator} built by this base class by deleting properties or implement an individual getMutator-method.
     * The provided properties of the {@link Mutator} must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored if not handled by an override of the mutate-method in the subclass and throw errors in an automatically generated user-interface for the object.
     */
    class Mutable extends FudgeCore.EventTarget∆í {
        /**
         * Decorator allows to attach {@link Mutable} functionality to existing classes.
         */
        // public static decorate(_constructor: Function): void {
        //   Object.defineProperty(_constructor.prototype, "useRenderData", {
        //     value: function getMutator(this: MutableForUserInterface): Mutator {
        //       return getMutatorOfArbitrary(this);
        //     }
        //   });
        // }
        static getMutatorFromPath(_mutator, _path) {
            let key = _path[0];
            let mutator = {};
            if (!_mutator[key]) // if the path deviates from mutator structure, return the mutator
                return _mutator;
            mutator[key] = _mutator[key];
            if (_path.length > 1)
                mutator[key] = Mutable.getMutatorFromPath(mutator[key], _path.slice(1, _path.length));
            return mutator;
        }
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object.
         * By default, a mutator cannot be extended, since extensions are not available in the object the mutator belongs to.
         * A mutator may be reduced by the descendants of {@link Mutable} to contain only the properties needed.
         */
        getMutator(_extendable = false) {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable) && !(value instanceof FudgeCore.MutableArray) && !(value.hasOwnProperty("idResource")))
                    continue;
                mutator[attribute] = this[attribute];
            }
            if (!_extendable)
                // mutator can be reduced but not extended!
                Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to mutators
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
                if (value instanceof FudgeCore.MutableArray)
                    mutator[attribute] = value.map((_value) => _value.getMutator());
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values
         * Does not recurse into objects!
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let attribute in _mutator) {
                let type = null;
                let value = _mutator[attribute];
                if (_mutator[attribute] != undefined)
                    if (typeof (value) == "object")
                        type = this[attribute].constructor.name;
                    else if (typeof (value) == "function")
                        type = value["name"];
                    else
                        type = _mutator[attribute].constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = _mutator[attribute];
                if (value instanceof Mutable)
                    _mutator[attribute] = value.getMutator();
                else
                    _mutator[attribute] = this[attribute];
            }
        }
        /**
         * Updates the attribute values of the instance according to the state of the mutator.
         * The mutation may be restricted to a subset of the mutator and the event dispatching suppressed.
         * Uses mutateBase, but can be overwritten in subclasses
         */
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await this.mutateBase(_mutator, _selection);
            if (_dispatchMutate)
                this.dispatchEvent(new CustomEvent("mutate" /* MUTATE */, { bubbles: true, detail: { mutator: _mutator } }));
        }
        /**
         * Base method for mutation, always available to subclasses. Do not overwrite in subclasses!
         */
        async mutateBase(_mutator, _selection) {
            let mutator = {};
            if (!_selection)
                mutator = _mutator;
            else
                for (let attribute of _selection) // reduce the mutator to the selection
                    if (typeof (_mutator[attribute]) !== "undefined")
                        mutator[attribute] = _mutator[attribute];
            for (let attribute in mutator) {
                if (!Reflect.has(this, attribute))
                    continue;
                let mutant = Reflect.get(this, attribute);
                let value = mutator[attribute];
                if (mutant instanceof FudgeCore.MutableArray || mutant instanceof Mutable)
                    await mutant.mutate(value, null, false);
                else
                    Reflect.set(this, attribute, value);
            }
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the external serialization and deserialization of {@link Serializable} objects. The internal process is handled by the objects themselves.
     * A {@link Serialization} object can be created from a {@link Serializable} object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a {@link Serialization} which can be deserialized to a {@link Serializable} object.
     * ```plaintext
     *  [Serializable] ‚Üí (serialize) ‚Üí [Serialization] ‚Üí (stringify) ‚Üí [String] ‚Üí (save or send)
     *                                        ‚Üì                            ‚Üì                  ‚Üì
     *                [Serializable] ‚Üê (deserialize) ‚Üê [Serialization] ‚Üê (parse) ‚Üê (load) ‚Üê [Medium]
     * ```
     * While the internal serialize/deserialize method1s of the objects care of the selection of information needed to recreate the object and its structure,
     * the {@link Serializer} keeps track of the namespaces and classes in order to recreate {@link Serializable} objects. The general structure of a {@link Serialization} is as follows
     * ```plaintext
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    class Serializer {
        /**
         * Registers a namespace to the {@link Serializer}, to enable automatic instantiation of classes defined within
         * @param _namespace
         */
        static registerNamespace(_namespace) {
            for (let name in Serializer.namespaces)
                if (Serializer.namespaces[name] == _namespace)
                    return name;
            let name = Serializer.findNamespaceIn(_namespace, window);
            if (!name)
                for (let parentName in Serializer.namespaces) {
                    name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                    if (name) {
                        name = parentName + "." + name;
                        break;
                    }
                }
            if (!name)
                throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
            Serializer.namespaces[name] = _namespace;
            return name;
        }
        /**
         * Returns a javascript object representing the serializable FUDGE-object given,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serialize(_object) {
            let serialization = {};
            // TODO: save the namespace with the constructors name
            // serialization[_object.constructor.name] = _object.serialize();
            let path = this.getFullPath(_object);
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            serialization[path] = _object.serialize();
            return serialization;
            // return _object.serialize();
        }
        /**
         * Returns a FUDGE-object reconstructed from the information in the {@link Serialization} given,
         * including attached components, children, superclass-objects
         * @param _serialization
         */
        static async deserialize(_serialization) {
            let reconstruct;
            let path;
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (path in _serialization) {
                    // reconstruct = new (<General>Fudge)[typeName];
                    reconstruct = Serializer.reconstruct(path);
                    reconstruct = await reconstruct.deserialize(_serialization[path]);
                    return reconstruct;
                }
            }
            catch (_error) {
                throw new Error(`Deserialization of ${path} failed: ` + _error);
            }
            return null;
        }
        /**
         * Returns an Array of javascript object representing the serializable FUDGE-objects given in the array,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serializeArray(_type, _objects) {
            let serializations = [];
            let path = this.getFullPath(new _type());
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_type.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            for (let object of _objects)
                serializations.push(object.serialize());
            let serialization = {};
            serialization[path] = serializations;
            return serialization;
        }
        /**
         * Returns an Array of FUDGE-objects reconstructed from the information in the array of {@link Serialization}s given,
         * including attached components, children, superclass-objects
         * @param _serializations
         */
        static async deserializeArray(_serialization) {
            let serializables = [];
            let construct;
            let serializations = [];
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (let path in _serialization) {
                    construct = Serializer.getConstructor(path);
                    serializations = _serialization[path];
                    break;
                }
            }
            catch (_error) {
                throw new Error("Deserialization failed: " + _error);
            }
            for (let serialization of serializations) {
                let serializable = new construct();
                await serializable.deserialize(serialization);
                serializables.push(serializable);
            }
            return serializables;
        }
        //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
        static prettify(_json) { return _json; }
        /**
         * Returns a formatted, human readable JSON-String, representing the given {@link Serialization} that may have been created by {@link Serializer}.serialize
         * @param _serialization
         */
        static stringify(_serialization) {
            // adjustments to serialization can be made here before stringification, if desired
            let json = JSON.stringify(_serialization, null, 2);
            let pretty = Serializer.prettify(json);
            return pretty;
        }
        /**
         * Returns a {@link Serialization} created from the given JSON-String. Result may be passed to {@link Serializer.deserialize}
         * @param _json
         */
        static parse(_json) {
            return JSON.parse(_json);
        }
        /**
         * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
         * @param _path
         */
        static reconstruct(_path) {
            let constructor = Serializer.getConstructor(_path);
            let reconstruction = new constructor();
            return reconstruction;
        }
        // public static getConstructor<T extends Serializable>(_type: string, _namespace: Object = FudgeCore): new () => T {
        static getConstructor(_path) {
            let typeName = _path.substring(_path.lastIndexOf(".") + 1);
            let namespace = Serializer.getNamespace(_path);
            if (!namespace)
                throw new Error(`Constructor of serializable object of type ${_path} not found. Maybe the namespace hasn't been registered?`);
            return namespace[typeName];
        }
        /**
         * Returns the full path to the class of the object, if found in the registered namespaces
         * @param _object
         */
        static getFullPath(_object) {
            let typeName = _object.constructor.name;
            // Debug.log("Searching namespace of: " + typeName);
            for (let namespaceName in Serializer.namespaces) {
                let found = Serializer.namespaces[namespaceName][typeName];
                if (found && _object instanceof found)
                    return namespaceName + "." + typeName;
            }
            return null;
        }
        /**
         * Returns the namespace-object defined within the full path, if registered
         * @param _path
         */
        static getNamespace(_path) {
            let namespaceName = _path.substr(0, _path.lastIndexOf("."));
            return Serializer.namespaces[namespaceName] || FudgeCore;
        }
        /**
         * Finds the namespace-object in properties of the parent-object (e.g. window), if present
         * @param _namespace
         * @param _parent
         */
        static findNamespaceIn(_namespace, _parent) {
            for (let prop in _parent)
                if (_parent[prop] == _namespace)
                    return prop;
            return null;
        }
    }
    /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
    Serializer.namespaces = { "∆í": FudgeCore };
    FudgeCore.Serializer = Serializer;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all {@link Component}s that can be attached to {@link Node}s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karag√∂l, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class Component extends FudgeCore.Mutable {
        constructor() {
            super();
            this.#node = null;
            this.singleton = true;
            this.active = true;
            this.addEventListener("mutate" /* MUTATE */, (_event) => {
                if (this.#node) {
                    // TODO: find the number of the component in the array if not singleton
                    _event.detail.component = this;
                    //@ts-ignore
                    _event.detail.componentIndex = this.node.getComponents(this.constructor).indexOf(this);
                    this.#node.dispatchEvent(_event);
                }
            });
        }
        #node;
        static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
        get isActive() {
            return this.active;
        }
        /**
         * Is true, when only one instance of the component class can be attached to a node
         */
        get isSingleton() {
            return this.singleton;
        }
        /**
         * Retrieves the node, this component is currently attached to
         */
        get node() {
            return this.#node;
        }
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* COMPONENT_ACTIVATE */ : "componentDeactivate" /* COMPONENT_DEACTIVATE */));
        }
        /**
         * Tries to attach the component to the given node, removing it from the node it was attached to if applicable
         */
        attachToNode(_container) {
            if (this.#node == _container)
                return;
            let previousContainer = this.#node;
            try {
                if (previousContainer)
                    previousContainer.removeComponent(this);
                this.#node = _container;
                if (this.#node)
                    this.#node.addComponent(this);
            }
            catch (_error) {
                this.#node = previousContainer;
            }
        }
        //#region Transfer
        serialize() {
            let serialization = {
                active: this.active
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.activate(_serialization.active);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            if (typeof (_mutator.active) !== "undefined")
                this.activate(_mutator.active);
        }
        reduceMutator(_mutator) {
            delete _mutator.singleton;
            delete _mutator.mtxWorld;
        }
    }
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Component.baseClass = Component;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Component.subclasses = [];
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Wraps a regular Javascript Array and offers very limited functionality geared solely towards avoiding garbage colletion.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Recycler
     */
    class RecycableArray {
        constructor() {
            this.#length = 0;
            this.#array = new Array();
        }
        #length;
        #array;
        // #type: new () => T;
        // //tslint:disable-next-line:no-any
        // constructor(_type: new (...args: any[]) => T) {
        //   this.#type = _type;
        // }
        get length() {
            return this.#length;
        }
        /**
         * Sets the virtual length of the array to zero but keeps the entries beyond.
         */
        reset() {
            this.#length = 0;
        }
        recycle() {
            this.reset();
        }
        push(_entry) {
            this.#array[this.#length] = _entry;
            this.#length++;
            return this.#length;
        }
        pop() {
            this.#length--;
            return this.#array[this.#length];
        }
        /**
         * Recycles the object following the last in the array and increases the array length
         * It must be assured, that none of the objects in the array is still in any use of any kind!
         */
        // public recycle(): T {
        //   if (this.#length < this.#array.length) {
        //     this.#length++;
        //     return this.#array[this.#length++];
        //   }
        //   this.#array.push(Recycler.get(this.#type));
        //   return this.#array[this.#length++];
        // }
        *[Symbol.iterator]() {
            for (let i = 0; i < this.#length; i++)
                yield this.#array[i];
        }
        getSorted(_sort) {
            let sorted = this.#array.slice(0, this.#length);
            sorted.sort(_sort);
            return sorted;
        }
    }
    FudgeCore.RecycableArray = RecycableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //Baseclass for {@link RenderInjectorCoat} and {@link RenderInjectorTexture]]
    class RenderInjector {
        static inject(_constructor, _injector) {
            let injection = Reflect.get(_injector, "inject" + _constructor.name);
            if (!injection) {
                FudgeCore.Debug.error("No injection decorator defined for " + _constructor.name);
            }
            Object.defineProperty(_constructor.prototype, "useRenderData", {
                value: injection
            });
        }
    }
    FudgeCore.RenderInjector = RenderInjector;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //gives WebGL Buffer the data from the {@link Shader}
    class RenderInjectorShader {
        static decorate(_constructor) {
            Object.defineProperty(_constructor, "useProgram", {
                value: RenderInjectorShader.useProgram
            });
            Object.defineProperty(_constructor, "deleteProgram", {
                value: RenderInjectorShader.deleteProgram
            });
            Object.defineProperty(_constructor, "createProgram", {
                value: RenderInjectorShader.createProgram
            });
        }
        static useProgram() {
            if (!this.program)
                this.createProgram();
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.useProgram(this.program);
        }
        static deleteProgram() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.program) {
                crc3.deleteProgram(this.program);
                delete this.attributes;
                delete this.uniforms;
            }
        }
        static createProgram() {
            FudgeCore.Debug.fudge("Create shader program", this.name);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let program = crc3.createProgram();
            try {
                let shdVertex = compileShader(this.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER);
                let shdFragment = compileShader(this.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER);
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdVertex));
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdFragment));
                crc3.linkProgram(program);
                let error = FudgeCore.RenderWebGL.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                this.program = program;
                this.attributes = detectAttributes();
                this.uniforms = detectUniforms();
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = FudgeCore.RenderWebGL.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectAttributes() {
                let detectedAttributes = {};
                let attributeCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_ATTRIBUTES);
                for (let i = 0; i < attributeCount; i++) {
                    let attributeInfo = FudgeCore.RenderWebGL.assert(crc3.getActiveAttrib(program, i));
                    if (!attributeInfo) {
                        break;
                    }
                    detectedAttributes[attributeInfo.name] = crc3.getAttribLocation(program, attributeInfo.name);
                }
                return detectedAttributes;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = FudgeCore.RenderWebGL.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    detectedUniforms[info.name] = FudgeCore.RenderWebGL.assert(crc3.getUniformLocation(program, info.name));
                }
                return detectedUniforms;
            }
        }
    }
    FudgeCore.RenderInjectorShader = RenderInjectorShader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //gives WebGL Buffer the data from the {@link Coat}
    class RenderInjectorCoat extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorCoat);
        }
        static injectCoatColored(_shader, _cmpMaterial) {
            let uniform = _shader.uniforms["u_vctColor"];
            let color = FudgeCore.Color.MULTIPLY(this.color, _cmpMaterial.clrPrimary);
            FudgeCore.RenderWebGL.getRenderingContext().uniform4fv(uniform, color.getArray());
        }
        static injectCoatRemissive(_shader, _cmpMaterial) {
            RenderInjectorCoat.injectCoatColored.call(this, _shader, _cmpMaterial);
            let uniform;
            uniform = _shader.uniforms["u_fSpecular"];
            FudgeCore.RenderWebGL.getRenderingContext().uniform1f(uniform, this.specular);
            uniform = _shader.uniforms["u_fDiffuse"];
            FudgeCore.RenderWebGL.getRenderingContext().uniform1f(uniform, this.diffuse);
        }
        static injectCoatTextured(_shader, _cmpMaterial) {
            RenderInjectorCoat.injectCoatColored.call(this, _shader, _cmpMaterial);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            this.texture.useRenderData();
            crc3.uniform1i(_shader.uniforms["u_texture"], 0);
            crc3.uniformMatrix3fv(_shader.uniforms["u_mtxPivot"], false, _cmpMaterial.mtxPivot.get());
        }
        static injectCoatRemissiveTextured(_shader, _cmpMaterial) {
            RenderInjectorCoat.injectCoatRemissive.call(this, _shader, _cmpMaterial);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            this.texture.useRenderData();
            crc3.uniform1i(_shader.uniforms["u_texture"], 0);
            crc3.uniformMatrix3fv(_shader.uniforms["u_mtxPivot"], false, _cmpMaterial.mtxPivot.get());
        }
    }
    FudgeCore.RenderInjectorCoat = RenderInjectorCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //Feeds WebGL Buffers with data calculated from the {@link Mesh]]
    class RenderInjectorMesh {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "getRenderBuffers", {
                value: RenderInjectorMesh.getRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static getRenderBuffers(_shader) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            this.renderMesh = this.renderMesh || new FudgeCore.RenderMesh(this);
            if (_shader.define.includes("FLAT")) {
                if (this.renderMesh.flat == null)
                    this.renderMesh.flat = {
                        vertices: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.verticesFlat),
                        indices: createBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderMesh.indicesFlat),
                        normals: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.normalsFlat),
                        textureUVs: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.textureUVsFlat),
                        nIndices: this.renderMesh.indicesFlat.length
                    };
                return this.renderMesh.flat;
            }
            else {
                if (this.renderMesh.smooth == null)
                    this.renderMesh.smooth = {
                        vertices: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.vertices),
                        indices: createBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderMesh.indices),
                        normals: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.normalsVertex),
                        textureUVs: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.textureUVs),
                        nIndices: this.renderMesh.indices.length
                    };
                return this.renderMesh.smooth;
            }
            function createBuffer(_type, _array) {
                let buffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(_type, buffer);
                crc3.bufferData(_type, _array, WebGL2RenderingContext.STATIC_DRAW);
                return buffer;
            }
        }
        static useRenderBuffers(_shader, _mtxMeshToWorld, _mtxMeshToView, _id) {
            let renderBuffers = this.getRenderBuffers(_shader);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            function setBuffer(_name, _buffer) {
                let attribute = _shader.attributes[_name];
                if (attribute == undefined)
                    return;
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, _buffer);
                crc3.enableVertexAttribArray(attribute);
                FudgeCore.RenderWebGL.setAttributeStructure(attribute, { size: 3, dataType: WebGL2RenderingContext.FLOAT, normalize: false, stride: 0, offset: 0 });
            }
            let uniform;
            uniform = _shader.uniforms["u_mtxMeshToView"];
            crc3.uniformMatrix4fv(uniform, false, _mtxMeshToView.get());
            uniform = _shader.uniforms["u_mtxMeshToWorld"];
            if (uniform)
                crc3.uniformMatrix4fv(uniform, false, _mtxMeshToWorld.get());
            uniform = _shader.uniforms["u_mtxNormalMeshToWorld"];
            if (uniform) {
                let normalMatrix = FudgeCore.Matrix4x4.TRANSPOSE(FudgeCore.Matrix4x4.INVERSION(_mtxMeshToWorld));
                crc3.uniformMatrix4fv(uniform, false, normalMatrix.get());
            }
            setBuffer("a_vctPosition", renderBuffers.vertices);
            setBuffer("a_vctNormal", renderBuffers.normals);
            // feed in texture coordinates if shader accepts a_vctTexture
            let attribute = _shader.attributes["a_vctTexture"];
            if (attribute) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.textureUVs);
                crc3.enableVertexAttribArray(attribute); // enable the buffer
                crc3.vertexAttribPointer(attribute, 2, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            // feed in an id of the node if shader accepts u_id. Used for picking
            uniform = _shader.uniforms["u_id"];
            if (uniform)
                FudgeCore.RenderWebGL.getRenderingContext().uniform1i(uniform, _id);
            crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, renderBuffers.indices);
            return renderBuffers;
        }
        static deleteRenderBuffers(_renderBuffers) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_renderBuffers) {
                // TODO: cleanup all buffers, flat/normals is missing...
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.vertices);
                crc3.deleteBuffer(_renderBuffers.textureUVs);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.indices);
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using {@link Recycler} reduces load on the carbage collector and thus supports smooth performance.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Recycler
     */
    class Recycler {
        /**
         * Fetches an object of the requested type from the depot, calls its recycle-method and returns it.
         * If the depot for that type is empty it returns a new object of the requested type
         * @param _T The class identifier of the desired object
         */
        static get(_T) {
            let key = _T.name;
            let instances = Recycler.depot[key];
            if (instances && instances.length > 0) {
                let instance = instances.pop();
                instance.recycle();
                return instance;
            }
            else
                return new _T();
        }
        /**
         * Returns a reference to an object of the requested type in the depot, but does not remove it there.
         * If no object of the requested type was in the depot, one is created, stored and borrowed.
         * For short term usage of objects in a local scope, when there will be no other call to Recycler.get or .borrow!
         * @param _T The class identifier of the desired object
         */
        static borrow(_T) {
            let t;
            let key = _T.name;
            let instances = Recycler.depot[key];
            if (!instances || instances.length == 0) {
                t = new _T();
                Recycler.store(t);
                return t;
            }
            let instance = instances[0];
            instance.recycle();
            return instance;
        }
        /**
         * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
         * @param _instance
         */
        static store(_instance) {
            let key = _instance.constructor.name;
            //Debug.log(key);
            let instances = Recycler.depot[key] || [];
            instances.push(_instance);
            Recycler.depot[key] = instances;
            // Debug.log(`ObjectManager.depot[${key}]: ${ObjectManager.depot[key].length}`);
            //Debug.log(this.depot);
        }
        /**
         * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
         * @param _T
         */
        static dump(_T) {
            let key = _T.name;
            Recycler.depot[key] = [];
        }
        /**
         * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
         */
        static dumpAll() {
            Recycler.depot = {};
        }
    }
    Recycler.depot = {};
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```plaintext
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.data = new Float32Array([_x, _y]);
        }
        //#region Static
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(0, 0);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_scale, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(0, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_scale, 0);
            return vector;
        }
        static TRANSFORMATION(_vector, _mtxTransform, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector2);
            let m = _mtxTransform.get();
            let [x, y] = _vector.get();
            result.x = m[0] * x + m[3] * y;
            result.y = m[1] * x + m[4] * y;
            if (_includeTranslation) {
                result.add(_mtxTransform.translation);
            }
            return result;
        }
        /**
         * Normalizes a given vector to the given length without editing the original vector.
         * @param _vector the vector to normalize
         * @param _length the length of the resulting vector. defaults to 1
         * @returns a new vector representing the normalised vector scaled by the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let vector = Vector2.ZERO();
            try {
                let [x, y] = _vector.data;
                let factor = _length / Math.hypot(x, y);
                vector.set(_vector.x * factor, _vector.y * factor);
            }
            catch (_error) {
                FudgeCore.Debug.warn(_error);
            }
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scale) {
            let vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_vector.x * _scale, _vector.y * _scale);
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector2);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector2);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y;
            return scalarProduct;
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         * @param _a Vector to compute the cross product on
         * @param _b Vector to compute the cross product with
         * @returns A number representing result of the cross product.
         */
        static CROSS(_a, _b) {
            let crossProduct = _a.x * _b.y - _a.y * _b.x;
            return crossProduct;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```plaintext
         * ‚Üë => ‚Üê => ‚Üì => ‚Üí => ‚Üë
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false) {
            let result = FudgeCore.Recycler.get(Vector2);
            if (_clockwise)
                result.set(_vector.y, -_vector.x);
            else
                result.set(-_vector.y, _vector.x);
            return result;
        }
        /**
         * Creates a cartesian vector from polar coordinates
         */
        static GEO(_angle = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.get(Vector2);
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.set(_angle, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        //#endregion
        //#region Accessors
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector2.DOT(this, this);
        }
        /**
         * @returns A deep copy of the vector.
         * TODO: rename this clone and create a new method copy, which copies the values from a vector given
         */
        get clone() {
            let clone = FudgeCore.Recycler.get(Vector2);
            clone.data.set(this.data);
            return clone;
        }
        /**
         * Returns a polar representation of this vector
         */
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.angle = 180 * Math.atan2(this.y / geo.magnitude, this.x / geo.magnitude) / Math.PI;
            return geo;
        }
        /**
         * Adjust the cartesian values of this vector to represent the given as polar coordinates
         */
        set geo(_geo) {
            this.set(_geo.magnitude, 0);
            this.transform(FudgeCore.Matrix3x3.ROTATION(_geo.angle));
        }
        //#endregion
        recycle() {
            this.data.set([0, 0]);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Adds the given vector to the executing vector, changing the executor.
         * @param _addend The vector to add.
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y]);
        }
        /**
         * Subtracts the given vector from the executing vector, changing the executor.
         * @param _subtrahend The vector to subtract.
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y]);
        }
        /**
         * Scales the Vector by the given _scalar.
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector2.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0) {
            this.data[0] = _x;
            this.data[1] = _y;
        }
        /**
         * @returns An array of the data of the vector
         */
        get() {
            return new Float32Array(this.data);
        }
        transform(_mtxTransform, _includeTranslation = true) {
            this.data = Vector2.TRANSFORMATION(this, _mtxTransform, _includeTranslation).data;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
        }
        /**
         * Adds a z-component of the given magnitude (default=0) to the vector and returns a new Vector3
         */
        toVector3(_z = 0) {
            return new FudgeCore.Vector3(this.x, this.y, _z);
        }
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
var FudgeCore;
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            let rect = FudgeCore.Recycler.get(Rectangle);
            rect.setPositionAndSize(_x, _y, _width, _height);
            return rect;
        }
        get x() {
            return this.position.x;
        }
        get y() {
            return this.position.y;
        }
        get width() {
            return this.size.x;
        }
        get height() {
            return this.size.y;
        }
        /**
         * Return the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        /**
         * Return the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        /**
         * Return the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        /**
         * Return the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set x(_x) {
            this.position.x = _x;
        }
        set y(_y) {
            this.position.y = _y;
        }
        set width(_width) {
            this.size.x = _width;
        }
        set height(_height) {
            this.size.y = _height;
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get clone() {
            return Rectangle.GET(this.x, this.y, this.width, this.height);
        }
        recycle() {
            this.setPositionAndSize();
        }
        copy(_rect) {
            this.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
        }
        pointToRect(_point, _target) {
            let result = _point.clone;
            result.subtract(this.position);
            result.x *= _target.width / this.width;
            result.y *= _target.height / this.height;
            result.add(_target.position);
            return result;
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border
         * @param _point
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        /**
         * Returns true if this rectangle collides with the rectangle given
         * @param _rect
         */
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        /**
         * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
         */
        getIntersection(_rect) {
            if (!this.collides(_rect))
                return null;
            let intersection = new Rectangle();
            intersection.x = Math.max(this.left, _rect.left);
            intersection.y = Math.max(this.top, _rect.top);
            intersection.width = Math.min(this.right, _rect.right) - intersection.x;
            intersection.height = Math.min(this.bottom, _rect.bottom) - intersection.y;
            return intersection;
        }
        /**
     * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
     */
        covers(_rect) {
            if (this.left > _rect.left)
                return false;
            if (this.right < _rect.right)
                return false;
            if (this.top > _rect.top)
                return false;
            if (this.bottom < _rect.bottom)
                return false;
            return true;
        }
        /**
         * Creates a string representation of this rectangle
         */
        toString() {
            let result = `∆í.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}`;
            result += `, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)}`;
            return result;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
var FudgeCore;
///<reference path="RenderInjector.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorCoat.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    let BLEND;
    (function (BLEND) {
        BLEND[BLEND["OPAQUE"] = 0] = "OPAQUE";
        BLEND[BLEND["TRANSPARENT"] = 1] = "TRANSPARENT";
        BLEND[BLEND["PARTICLE"] = 2] = "PARTICLE";
    })(BLEND = FudgeCore.BLEND || (FudgeCore.BLEND = {}));
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through {@link Render}
     */
    class RenderWebGL extends FudgeCore.EventTargetStatic {
        /**
         * Initializes offscreen-canvas, renderingcontext and hardware viewport. Call once before creating any resources like meshes or shaders
         */
        static initialize(_antialias, _alpha) {
            FudgeCore.fudgeConfig = FudgeCore.fudgeConfig || {};
            let contextAttributes = {
                alpha: (_alpha != undefined) ? _alpha : FudgeCore.fudgeConfig.alpha || false,
                antialias: (_antialias != undefined) ? _antialias : FudgeCore.fudgeConfig.antialias || false,
                premultipliedAlpha: false
            };
            FudgeCore.Debug.fudge("Initialize RenderWebGL", contextAttributes);
            let canvas = document.createElement("canvas");
            let crc3;
            crc3 = RenderWebGL.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
            RenderWebGL.crc3 = crc3;
            // Enable backface- and zBuffer-culling.
            crc3.enable(WebGL2RenderingContext.CULL_FACE);
            crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            crc3.enable(WebGL2RenderingContext.BLEND);
            crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
            RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            // RenderOperator.crc3.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, true);
            RenderWebGL.rectRender = RenderWebGL.getCanvasRect();
            return crc3;
        }
        /**
         * Wrapper function to utilize the bufferSpecification interface when passing data to the shader via a buffer.
         * @param _attributeLocation  The location of the attribute on the shader, to which they data will be passed.
         * @param _bufferSpecification  Interface passing datapullspecifications to the buffer.
         */
        static setAttributeStructure(_attributeLocation, _bufferSpecification) {
            RenderWebGL.crc3.vertexAttribPointer(_attributeLocation, _bufferSpecification.size, _bufferSpecification.dataType, _bufferSpecification.normalize, _bufferSpecification.stride, _bufferSpecification.offset);
        }
        /**
        * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
        * @param _value  value to check against null
        * @param _message  optional, additional message for the exception
        */
        static assert(_value, _message = "") {
            if (_value === null)
                throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderWebGL.crc3 ? RenderWebGL.crc3.getError() : ""}`);
            return _value;
        }
        /**
         * Return a reference to the offscreen-canvas
         */
        static getCanvas() {
            return RenderWebGL.crc3.canvas; // TODO: enable OffscreenCanvas
        }
        /**
         * Return a reference to the rendering context
         */
        static getRenderingContext() {
            return RenderWebGL.crc3;
        }
        /**
         * Return a rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
         */
        static getCanvasRect() {
            let canvas = RenderWebGL.crc3.canvas;
            return FudgeCore.Rectangle.GET(0, 0, canvas.width, canvas.height);
        }
        /**
         * Set the size of the offscreen-canvas.
         */
        static setCanvasSize(_width, _height) {
            RenderWebGL.crc3.canvas.width = _width;
            RenderWebGL.crc3.canvas.height = _height;
        }
        /**
         * Set the area on the offscreen-canvas to render the camera image to.
         * @param _rect
         */
        static setRenderRectangle(_rect) {
            RenderWebGL.rectRender.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
            RenderWebGL.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Clear the offscreen renderbuffer with the given {@link Color}
         */
        static clear(_color = null) {
            RenderWebGL.crc3.clearColor(_color.r, _color.g, _color.b, _color.a);
            RenderWebGL.crc3.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT);
        }
        /**
         * Reset the offscreen framebuffer to the original RenderingContext
         */
        static resetFrameBuffer(_color = null) {
            RenderWebGL.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        /**
         * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
         */
        static getRenderRectangle() {
            return RenderWebGL.rectRender;
        }
        static setDepthTest(_test) {
            if (_test)
                RenderWebGL.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            else
                RenderWebGL.crc3.disable(WebGL2RenderingContext.DEPTH_TEST);
        }
        static setBlendMode(_mode) {
            switch (_mode) {
                case BLEND.OPAQUE:
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO);
                    break;
                case BLEND.TRANSPARENT:
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                    // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.DST_ALPHA, WebGL2RenderingContext.ONE_MINUS_DST_ALPHA);
                    break;
                case BLEND.PARTICLE:
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.DST_ALPHA);
                    break;
                default:
                    break;
            }
        }
        //#region Picking
        /**
         * Creates a texture buffer to be used as pick-buffer
         */
        static createPickTexture(_size) {
            // create to render to
            const targetTexture = FudgeCore.Render.crc3.createTexture();
            FudgeCore.Render.crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, targetTexture);
            {
                const internalFormat = WebGL2RenderingContext.RGBA32I;
                const format = WebGL2RenderingContext.RGBA_INTEGER;
                const type = WebGL2RenderingContext.INT;
                FudgeCore.Render.pickBuffer = new Int32Array(_size * _size * 4);
                FudgeCore.Render.crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, internalFormat, _size, _size, 0, format, type, FudgeCore.Render.pickBuffer);
                // set the filtering so we don't need mips
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                FudgeCore.Render.crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
            }
            const framebuffer = FudgeCore.Render.crc3.createFramebuffer();
            FudgeCore.Render.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, framebuffer);
            const attachmentPoint = WebGL2RenderingContext.COLOR_ATTACHMENT0;
            FudgeCore.Render.crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, attachmentPoint, WebGL2RenderingContext.TEXTURE_2D, targetTexture, 0);
            RenderWebGL.sizePick = _size;
            return targetTexture;
        }
        static getPicks(_size, _cmpCamera) {
            // evaluate texture by reading pixels and extract, convert and store the information about each mesh hit
            let data = new Int32Array(_size * _size * 4);
            FudgeCore.Render.crc3.readPixels(0, 0, _size, _size, WebGL2RenderingContext.RGBA_INTEGER, WebGL2RenderingContext.INT, data);
            let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSION(_cmpCamera.mtxWorldToView);
            let picked = [];
            for (let i = 0; i < FudgeCore.Render.∆ípicked.length; i++) {
                let zBuffer = data[4 * i + 0] + data[4 * i + 1] / 256;
                if (zBuffer == 0) // discard misses 
                    continue;
                let pick = FudgeCore.Render.∆ípicked[i];
                pick.zBuffer = convertInt32toFloat32(data, 4 * i + 0) * 2 - 1;
                pick.color = convertInt32toColor(data, 4 * i + 1);
                pick.textureUV = FudgeCore.Recycler.get(FudgeCore.Vector2);
                pick.textureUV.set(convertInt32toFloat32(data, 4 * i + 2), convertInt32toFloat32(data, 4 * i + 3));
                pick.mtxViewToWorld = mtxViewToWorld;
                picked.push(pick);
            }
            return picked;
            function convertInt32toFloat32(_int32Array, _index) {
                let buffer = new ArrayBuffer(4);
                let view = new DataView(buffer);
                view.setInt32(0, _int32Array[_index]);
                return view.getFloat32(0);
            }
            function convertInt32toColor(_int32Array, _index) {
                let buffer = new ArrayBuffer(4);
                let view = new DataView(buffer);
                view.setInt32(0, _int32Array[_index]);
                let color = FudgeCore.Color.CSS(`rgb(${view.getUint8(0)}, ${view.getUint8(1)}, ${view.getUint8(2)})`, view.getUint8(3) / 255);
                return color;
            }
        }
        /**
        * The render function for picking a single node.
        * A cameraprojection with extremely narrow focus is used, so each pixel of the buffer would hold the same information from the node,
        * but the fragment shader renders only 1 pixel for each node into the render buffer, 1st node to 1st pixel, 2nd node to second pixel etc.
        */
        static pick(_node, _mtxMeshToWorld, _mtxWorldToView) {
            try {
                let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
                let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
                let coat = cmpMaterial.material.coat;
                let shader = coat instanceof FudgeCore.CoatTextured ? FudgeCore.ShaderPickTextured : FudgeCore.ShaderPick;
                shader.useProgram();
                coat.useRenderData(shader, cmpMaterial);
                let sizeUniformLocation = shader.uniforms["u_vctSize"];
                RenderWebGL.getRenderingContext().uniform2fv(sizeUniformLocation, [RenderWebGL.sizePick, RenderWebGL.sizePick]);
                let mesh = cmpMesh.mesh;
                let renderBuffers = mesh.useRenderBuffers(shader, _mtxMeshToWorld, _mtxWorldToView, FudgeCore.Render.∆ípicked.length);
                RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                let pick = new FudgeCore.Pick(_node);
                FudgeCore.Render.∆ípicked.push(pick);
            }
            catch (_error) {
                //
            }
        }
        //#endregion
        //#region Lights
        /**
         * Set light data in shaders
         */
        static setLightsInShader(_shader, _lights) {
            _shader.useProgram();
            let uni = _shader.uniforms;
            // Ambient
            let ambient = uni["u_ambient.vctColor"];
            if (ambient) {
                RenderWebGL.crc3.uniform4fv(ambient, [0, 0, 0, 0]);
                let cmpLights = _lights.get(FudgeCore.LightAmbient);
                if (cmpLights) {
                    // TODO: add up ambient lights to a single color
                    let result = new FudgeCore.Color(0, 0, 0, 1);
                    for (let cmpLight of cmpLights)
                        result.add(cmpLight.light.color);
                    RenderWebGL.crc3.uniform4fv(ambient, result.getArray());
                }
            }
            // Directional
            let nDirectional = uni["u_nLightsDirectional"];
            if (nDirectional) {
                RenderWebGL.crc3.uniform1ui(nDirectional, 0);
                let cmpLights = _lights.get(FudgeCore.LightDirectional);
                if (cmpLights) {
                    let n = cmpLights.length;
                    RenderWebGL.crc3.uniform1ui(nDirectional, n);
                    for (let i = 0; i < n; i++) {
                        let cmpLight = cmpLights[i];
                        RenderWebGL.crc3.uniform4fv(uni[`u_directional[${i}].vctColor`], cmpLight.light.color.getArray());
                        let direction = FudgeCore.Vector3.Z();
                        direction.transform(cmpLight.mtxPivot, false);
                        direction.transform(cmpLight.node.mtxWorld, false);
                        direction.normalize();
                        RenderWebGL.crc3.uniform3fv(uni[`u_directional[${i}].vctDirection`], direction.get());
                    }
                }
            }
        }
        //#endregion
        /**
         * Draw a mesh buffer using the given infos and the complete projection matrix
         */
        static drawMesh(_cmpMesh, cmpMaterial, _cmpCamera) {
            let shader = cmpMaterial.material.getShader();
            let coat = cmpMaterial.material.coat;
            let mtxMeshToView = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.mtxWorldToView, _cmpMesh.mtxWorld);
            shader.useProgram();
            let renderBuffers;
            if (_cmpMesh.mesh instanceof FudgeCore.MeshSkin)
                renderBuffers = _cmpMesh.mesh.useRenderBuffers(shader, _cmpMesh.mtxWorld, mtxMeshToView, null, _cmpMesh.skeleton.mtxBones);
            else
                renderBuffers = _cmpMesh.mesh.useRenderBuffers(shader, _cmpMesh.mtxWorld, mtxMeshToView);
            coat.useRenderData(shader, cmpMaterial);
            let uCamera = shader.uniforms["u_vctCamera"];
            if (uCamera)
                RenderWebGL.crc3.uniform3fv(uCamera, _cmpCamera.mtxWorld.translation.get());
            let uWorldToView = shader.uniforms["u_mtxWorldToView"];
            if (uWorldToView)
                RenderWebGL.crc3.uniformMatrix4fv(uWorldToView, false, _cmpCamera.mtxWorldToView.get());
            RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
    }
    RenderWebGL.crc3 = RenderWebGL.initialize();
    RenderWebGL.rectRender = RenderWebGL.getCanvasRect();
    FudgeCore.RenderWebGL = RenderWebGL;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    //gives WebGL Buffer the data from the {@link Texture]]
    class RenderInjectorTexture extends FudgeCore.RenderInjector {
        static decorate(_constructor) {
            FudgeCore.RenderInjector.inject(_constructor, RenderInjectorTexture);
        }
        static injectTexture() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderData) {
                // buffers exist
                crc3.activeTexture(WebGL2RenderingContext.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData["texture0"]);
            }
            else {
                this.renderData = {};
                // TODO: check if all WebGL-Creations are asserted
                const texture = FudgeCore.Render.assert(crc3.createTexture());
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                try {
                    crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, crc3.RGBA, crc3.UNSIGNED_BYTE, this.texImageSource);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texImageSource);
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
                switch (this.mipmap) {
                    case FudgeCore.MIPMAP.CRISP:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                        break;
                    case FudgeCore.MIPMAP.MEDIUM:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR);
                        crc3.generateMipmap(crc3.TEXTURE_2D);
                        break;
                    case FudgeCore.MIPMAP.BLURRY:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR);
                        crc3.generateMipmap(crc3.TEXTURE_2D);
                        break;
                }
                this.renderData["texture0"] = texture;
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                this.useRenderData();
            }
        }
    }
    FudgeCore.RenderInjectorTexture = RenderInjectorTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Graph
     */
    class Node extends FudgeCore.EventTarget∆í {
        /**
         * Creates a new node with a name and initializes all attributes
         */
        constructor(_name) {
            super();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.timestampUpdate = 0;
            /** The number of nodes of the whole branch including this node and all successors */
            this.nNodesInBranch = 0;
            /** The radius of the bounding sphere in world dimensions enclosing the geometry of this node and all successors in the branch */
            this.radius = 0;
            this.parent = null; // The parent of this node.
            this.children = []; // array of child nodes appended to this node.
            this.components = {};
            // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
            // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
            this.listeners = {};
            this.captures = {};
            this.active = true;
            /**
             * Simply calls {@link addChild}. This reference is here solely because appendChild is the equivalent method in DOM.
             * See and preferably use {@link addChild}
             */
            // tslint:disable-next-line: member-ordering
            this.appendChild = this.addChild;
            this.name = _name;
        }
        #mtxWorldInverseUpdated;
        #mtxWorldInverse;
        get isActive() {
            return this.active;
        }
        /**
         * Shortcut to retrieve this nodes {@link ComponentTransform}
         */
        get cmpTransform() {
            return this.getComponents(FudgeCore.ComponentTransform)[0];
        }
        /**
         * Shortcut to retrieve the local {@link Matrix4x4} attached to this nodes {@link ComponentTransform}
         * Fails if no {@link ComponentTransform} is attached
         */
        get mtxLocal() {
            return this.cmpTransform.mtxLocal;
        }
        get mtxWorldInverse() {
            if (this.#mtxWorldInverseUpdated != this.timestampUpdate)
                this.#mtxWorldInverse = FudgeCore.Matrix4x4.INVERSION(this.mtxWorld);
            this.#mtxWorldInverseUpdated = this.timestampUpdate;
            return this.#mtxWorldInverse;
        }
        /**
         * Returns the number of children attached to this
         */
        get nChildren() {
            return this.children.length;
        }
        /**
         * Generator yielding the node and all decendants in the graph below for iteration
         * Inactive nodes and their descendants can be filtered
         */
        *getIterator(_active = false) {
            if (!_active || this.isActive) {
                yield this;
                for (let child of this.children)
                    yield* child.getIterator(_active);
            }
        }
        [Symbol.iterator]() {
            return this.getIterator();
        }
        activate(_on) {
            this.active = _on;
            // TODO: check if COMPONENT_ACTIVATE/DEACTIVATE is the correct event to dispatch. Shouldn't it be something like NODE_ACTIVATE/DEACTIVATE?
            this.dispatchEvent(new Event(_on ? "nodeActivate" /* NODE_ACTIVATE */ : "nodeDeactivate" /* NODE_DEACTIVATE */, { bubbles: true }));
            this.broadcastEvent(new Event(_on ? "nodeActivate" /* NODE_ACTIVATE */ : "nodeDeactivate" /* NODE_DEACTIVATE */));
        }
        // #region Scenetree
        /**
         * Returns a reference to this nodes parent node
         */
        getParent() {
            return this.parent;
        }
        /**
         * Traces back the ancestors of this node and returns the first
         */
        getAncestor() {
            let ancestor = this;
            while (ancestor.getParent())
                ancestor = ancestor.getParent();
            return ancestor;
        }
        /**
         * Traces the hierarchy upwards to the first ancestor and returns the path through the graph to this node
         */
        getPath() {
            let ancestor = this;
            let path = [this];
            while (ancestor.getParent())
                path.unshift(ancestor = ancestor.getParent());
            return path;
        }
        /**
         * Returns child at the given index in the list of children
         */
        getChild(_index) {
            return this.children[_index];
        }
        /**
         * Returns a clone of the list of children
         */
        getChildren() {
            return this.children.slice(0);
        }
        /**
         * Returns an array of references to childnodes with the supplied name.
         */
        getChildrenByName(_name) {
            let found = [];
            found = this.children.filter((_node) => _node.name == _name);
            return found;
        }
        /**
         * Adds the given reference to a node to the list of children, if not already in
         * @throws Error when trying to add an ancestor of this
         */
        addChild(_child) {
            if (this.children.includes(_child))
                // _node is already a child of this
                return;
            let inAudioGraph = false;
            let graphListened = FudgeCore.AudioManager.default.getGraphListeningTo();
            let ancestor = this;
            while (ancestor) {
                ancestor.timestampUpdate = 0;
                inAudioGraph = inAudioGraph || (ancestor == graphListened);
                if (ancestor == _child)
                    throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                else
                    ancestor = ancestor.parent;
            }
            let previousParent = _child.parent;
            if (previousParent)
                previousParent.removeChild(_child);
            this.children.push(_child);
            _child.parent = this;
            _child.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (inAudioGraph)
                _child.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
        }
        /**
         * Removes the reference to the give node from the list of children
         */
        removeChild(_child) {
            let found = this.findChild(_child);
            if (found < 0)
                return;
            _child.dispatchEvent(new Event("childRemove" /* CHILD_REMOVE */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _child.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
            this.children.splice(found, 1);
            _child.parent = null;
        }
        /**
         * Removes all references in the list of children
         */
        removeAllChildren() {
            while (this.children.length)
                this.removeChild(this.children[0]);
        }
        /**
         * Returns the position of the node in the list of children or -1 if not found
         */
        findChild(_search) {
            return this.children.indexOf(_search);
        }
        /**
         * Replaces a child node with another, preserving the position in the list of children
         */
        replaceChild(_replace, _with) {
            let found = this.findChild(_replace);
            if (found < 0)
                return false;
            let previousParent = _with.getParent();
            if (previousParent)
                previousParent.removeChild(_with);
            _replace.parent = null;
            this.children[found] = _with;
            _with.parent = this;
            _with.dispatchEvent(new Event("childAppend" /* CHILD_APPEND */, { bubbles: true }));
            if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                _with.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
            return true;
        }
        isUpdated(_timestampUpdate) {
            return (this.timestampUpdate == _timestampUpdate);
        }
        isDescendantOf(_ancestor) {
            let node = this;
            while (node && node != _ancestor)
                node = node.parent;
            return (node != null);
        }
        /**
         * Applies a Mutator from {@link Animation} to all its components and transfers it to its children.
         */
        applyAnimation(_mutator) {
            if (_mutator.components) {
                for (let componentName in _mutator.components) {
                    if (this.components[componentName]) {
                        let mutatorOfComponent = _mutator.components;
                        for (let i in mutatorOfComponent[componentName]) {
                            if (this.components[componentName][+i]) {
                                let componentToMutate = this.components[componentName][+i];
                                let mutatorArray = mutatorOfComponent[componentName];
                                let mutatorWithComponentName = mutatorArray[+i];
                                for (let cname in mutatorWithComponentName) { // trick used to get the only entry in the list
                                    let mutatorToGive = mutatorWithComponentName[cname];
                                    componentToMutate.mutate(mutatorToGive);
                                }
                            }
                        }
                    }
                }
            }
            if (_mutator.children) {
                for (let i = 0; i < _mutator.children.length; i++) {
                    let name = _mutator.children[i]["∆í.Node"].name;
                    let childNodes = this.getChildrenByName(name);
                    for (let childNode of childNodes) {
                        childNode.applyAnimation(_mutator.children[i]["∆í.Node"]);
                    }
                }
            }
        }
        // #endregion
        // #region Components
        /**
         * Returns a list of all components attached to this node, independent of type.
         */
        getAllComponents() {
            let all = [];
            for (let type in this.components) {
                all = all.concat(this.components[type]);
            }
            return all;
        }
        /**
         * Returns a clone of the list of components of the given class attached to this node.
         */
        getComponents(_class) {
            return (this.components[_class.name] || []).slice(0);
        }
        /**
         * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
         */
        getComponent(_class) {
            let list = this.components[_class.name];
            if (list)
                return list[0];
            return null;
        }
        /**
         * Attach the given component to this node. Identical to {@link addComponent}
         */
        attach(_component) {
            this.addComponent(_component);
        }
        /**
         * Attach the given component to this node
         */
        addComponent(_component) {
            if (_component.node == this)
                return;
            let cmpList = this.components[_component.type];
            if (cmpList === undefined)
                this.components[_component.type] = [_component];
            else if (cmpList.length && _component.isSingleton)
                throw new Error("Component is marked singleton and can't be attached, no more than one allowed");
            else
                cmpList.push(_component);
            _component.attachToNode(this);
            _component.dispatchEvent(new Event("componentAdd" /* COMPONENT_ADD */));
            this.dispatchEventToTargetOnly(new CustomEvent("componentAdd" /* COMPONENT_ADD */, { detail: _component })); // TODO: see if this is be feasable
        }
        /**
         * Detach the given component from this node. Identical to {@link removeComponent}
         */
        detach(_component) {
            this.removeComponent(_component);
        }
        /**
         * Removes the given component from the node, if it was attached, and sets its parent to null.
         */
        removeComponent(_component) {
            try {
                let componentsOfType = this.components[_component.type];
                let foundAt = componentsOfType.indexOf(_component);
                if (foundAt < 0)
                    return;
                _component.dispatchEvent(new Event("componentRemove" /* COMPONENT_REMOVE */));
                this.dispatchEventToTargetOnly(new CustomEvent("componentRemove" /* COMPONENT_REMOVE */, { detail: _component })); // TODO: see if this would be feasable
                componentsOfType.splice(foundAt, 1);
                _component.attachToNode(null);
            }
            catch (_error) {
                throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
            }
        }
        // #endregion
        // #region Serialization
        serialize() {
            let serialization = {
                name: this.name,
                active: this.active
            };
            let components = {};
            for (let type in this.components) {
                components[type] = [];
                for (let component of this.components[type]) {
                    // components[type].push(component.serialize());
                    components[type].push(FudgeCore.Serializer.serialize(component));
                }
            }
            serialization["components"] = components;
            let children = [];
            for (let child of this.children) {
                children.push(FudgeCore.Serializer.serialize(child));
            }
            serialization["children"] = children;
            this.dispatchEvent(new Event("nodeSerialized" /* NODE_SERIALIZED */));
            return serialization;
        }
        async deserialize(_serialization) {
            this.name = _serialization.name;
            // this.parent = is set when the nodes are added
            // deserialize components first so scripts can react to children being appended
            for (let type in _serialization.components) {
                for (let serializedComponent of _serialization.components[type]) {
                    let deserializedComponent = await FudgeCore.Serializer.deserialize(serializedComponent);
                    this.addComponent(deserializedComponent);
                }
            }
            for (let serializedChild of _serialization.children) {
                let deserializedChild = await FudgeCore.Serializer.deserialize(serializedChild);
                this.appendChild(deserializedChild);
            }
            this.dispatchEvent(new Event("nodeDeserialized" /* NODE_DESERIALIZED */));
            for (let component of this.getAllComponents())
                component.dispatchEvent(new Event("nodeDeserialized" /* NODE_DESERIALIZED */));
            this.activate(_serialization.active);
            return this;
        }
        // #endregion
        /**
         * Creates a string as representation of this node and its descendants
         */
        toHierarchyString(_node = null, _level = 0) {
            // TODO: refactor for better readability
            if (!_node)
                _node = this;
            let prefix = "+".repeat(_level);
            let output = prefix + " " + _node.name + " | ";
            for (let type in _node.components)
                output += _node.components[type].length + " " + type.split("Component").pop() + ", ";
            output = output.slice(0, -2) + "</br>";
            for (let child of _node.children) {
                output += this.toHierarchyString(child, _level + 1);
            }
            return output;
        }
        // #region Events
        /**
         * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
         * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
         */
        addEventListener(_type, _handler, _capture = false) {
            let listListeners = _capture ? this.captures : this.listeners;
            if (!listListeners[_type])
                listListeners[_type] = [];
            listListeners[_type].push(_handler);
        }
        /**
         * Removes an event listener from the node. The signature must match the one used with addEventListener
         */
        removeEventListener(_type, _handler, _capture = false) {
            let listenersForType = _capture ? this.captures[_type] : this.listeners[_type];
            if (listenersForType)
                for (let i = listenersForType.length - 1; i >= 0; i--)
                    if (listenersForType[i] == _handler)
                        listenersForType.splice(i, 1);
        }
        /**
         * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
         * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
         * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
         */
        dispatchEvent(_event) {
            let ancestors = [];
            let upcoming = this;
            // overwrite event target
            Object.defineProperty(_event, "target", { writable: true, value: this });
            // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
            while (upcoming.parent)
                ancestors.push(upcoming = upcoming.parent);
            Object.defineProperty(_event, "path", { writable: true, value: new Array(this, ...ancestors) });
            // capture phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            for (let i = ancestors.length - 1; i >= 0; i--) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                this.callListeners(ancestor.captures[_event.type], _event);
            }
            // target phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            this.callListeners(this.captures[_event.type], _event);
            this.callListeners(this.listeners[_event.type], _event);
            if (!_event.bubbles)
                return true;
            // bubble phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
            for (let i = 0; i < ancestors.length; i++) {
                let ancestor = ancestors[i];
                Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                this.callListeners(ancestor.listeners[_event.type], _event);
            }
            return true; //TODO: return a meaningful value, see documentation of dispatch event
        }
        /**
         * Dispatches a synthetic event to target without travelling through the graph hierarchy neither during capture nor bubbling phase
         */
        dispatchEventToTargetOnly(_event) {
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            this.callListeners(this.listeners[_event.type], _event); // TODO: examine if this should go to the captures instead of the listeners
            return true;
        }
        /**
         * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
         * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
         */
        broadcastEvent(_event) {
            // overwrite event target and phase
            Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
            Object.defineProperty(_event, "target", { writable: true, value: this });
            this.broadcastEventRecursive(_event);
        }
        broadcastEventRecursive(_event) {
            // capture phase only
            Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
            let captures = this.captures[_event.type] || [];
            for (let handler of captures)
                // @ts-ignore
                handler(_event);
            // appears to be slower, astonishingly...
            // captures.forEach(function (handler: Function): void {
            //     handler(_event);
            // });
            // same for children
            for (let child of this.children) {
                child.broadcastEventRecursive(_event);
            }
        }
        callListeners(_listeners, _event) {
            if (_listeners?.length > 0)
                for (let handler of _listeners)
                    // @ts-ignore
                    handler(_event);
        }
    }
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class EventPhysics extends Event {
        /** Creates a new event customized for physics. Holding informations about impulses. Collision point and the body that is colliding */
        constructor(_type, _hitRigidbody, _normalImpulse, _tangentImpulse, _binormalImpulse, _collisionPoint = null, _collisionNormal = null) {
            super(_type);
            this.cmpRigidbody = _hitRigidbody;
            this.normalImpulse = _normalImpulse;
            this.tangentImpulse = _tangentImpulse;
            this.binomalImpulse = _binormalImpulse;
            this.collisionPoint = _collisionPoint;
            this.collisionNormal = _collisionNormal;
        }
    }
    FudgeCore.EventPhysics = EventPhysics;
    /**
    * Groups to place a node in, not every group should collide with every group. Use a Mask in to exclude collisions
    */
    let COLLISION_GROUP;
    (function (COLLISION_GROUP) {
        COLLISION_GROUP[COLLISION_GROUP["DEFAULT"] = 1] = "DEFAULT";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_1"] = 2] = "GROUP_1";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_2"] = 4] = "GROUP_2";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_3"] = 8] = "GROUP_3";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_4"] = 16] = "GROUP_4";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_5"] = 32] = "GROUP_5";
    })(COLLISION_GROUP = FudgeCore.COLLISION_GROUP || (FudgeCore.COLLISION_GROUP = {}));
    /**
    * Defines the type of the rigidbody which determines the way it interacts with the physical and the visual world
    */
    let BODY_TYPE;
    (function (BODY_TYPE) {
        /** The body ignores the hierarchy of the render graph, is completely controlled  by physics and takes its node with it  */
        BODY_TYPE[BODY_TYPE["DYNAMIC"] = 0] = "DYNAMIC";
        /** The body ignores the hierarchy of the render graph, is completely immoveble and keeps its node from moving  */
        BODY_TYPE[BODY_TYPE["STATIC"] = 1] = "STATIC";
        /** The body is controlled by its node and moves with it, while it impacts the physical world e.g. by collisions */
        BODY_TYPE[BODY_TYPE["KINEMATIC"] = 2] = "KINEMATIC"; // = OIMO.RigidBodyType.KINEMATIC
    })(BODY_TYPE = FudgeCore.BODY_TYPE || (FudgeCore.BODY_TYPE = {}));
    /**
    * Different types of collider shapes, with different options in scaling BOX = Vector3(length, height, depth),
    * SPHERE = Vector3(diameter, x, x), CAPSULE = Vector3(diameter, height, x), CYLINDER = Vector3(diameter, height, x),
    * CONE = Vector(diameter, height, x), PYRAMID = Vector3(length, height, depth); x == unused.
    * CONVEX = ComponentMesh needs to be available in the RB Property convexMesh, the points of that component are used to create a collider that matches,
    * the closest possible representation of that form, in form of a hull. Convex is experimental and can produce unexpected behaviour when vertices
    * are too close to one another and the given vertices do not form a in itself closed shape and having a genus of 0 (no holes). Vertices in the ComponentMesh can be scaled differently
    * for texturing/normal or other reasons, so the collider might be off compared to the visual shape, this can be corrected by changing the pivot scale of the ComponentRigidbody.
    */
    let COLLIDER_TYPE;
    (function (COLLIDER_TYPE) {
        COLLIDER_TYPE[COLLIDER_TYPE["CUBE"] = 0] = "CUBE";
        COLLIDER_TYPE[COLLIDER_TYPE["SPHERE"] = 1] = "SPHERE";
        COLLIDER_TYPE[COLLIDER_TYPE["CAPSULE"] = 2] = "CAPSULE";
        COLLIDER_TYPE[COLLIDER_TYPE["CYLINDER"] = 3] = "CYLINDER";
        COLLIDER_TYPE[COLLIDER_TYPE["CONE"] = 4] = "CONE";
        COLLIDER_TYPE[COLLIDER_TYPE["PYRAMID"] = 5] = "PYRAMID";
        COLLIDER_TYPE[COLLIDER_TYPE["CONVEX"] = 6] = "CONVEX";
    })(COLLIDER_TYPE = FudgeCore.COLLIDER_TYPE || (FudgeCore.COLLIDER_TYPE = {}));
    /** Displaying different types of debug information about different physic features. Default = JOINTS_AND_COLLIDER. */
    let PHYSICS_DEBUGMODE;
    (function (PHYSICS_DEBUGMODE) {
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["NONE"] = 0] = "NONE";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["COLLIDERS"] = 1] = "COLLIDERS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["JOINTS_AND_COLLIDER"] = 2] = "JOINTS_AND_COLLIDER";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["BOUNDING_BOXES"] = 3] = "BOUNDING_BOXES";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["CONTACTS"] = 4] = "CONTACTS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["PHYSIC_OBJECTS_ONLY"] = 5] = "PHYSIC_OBJECTS_ONLY";
    })(PHYSICS_DEBUGMODE = FudgeCore.PHYSICS_DEBUGMODE || (FudgeCore.PHYSICS_DEBUGMODE = {}));
    /** Info about Raycasts shot from the physics system. */
    class RayHitInfo {
        constructor() {
            this.hitPoint = FudgeCore.Vector3.ZERO();
            this.hitNormal = FudgeCore.Vector3.ZERO();
            this.rayEnd = FudgeCore.Vector3.ZERO();
            this.rayOrigin = FudgeCore.Vector3.ZERO();
            this.recycle();
        }
        recycle() {
            this.hit = false;
            this.hitDistance = 0;
            this.hitPoint.recycle();
            this.rigidbodyComponent = null;
            this.hitNormal.recycle();
            this.rayOrigin.recycle();
            this.rayEnd.recycle();
        }
    }
    FudgeCore.RayHitInfo = RayHitInfo;
    /** General settings for the physic simulation and the debug of it. */
    class PhysicsSettings {
        constructor(_defaultCollisionGroup, _defaultCollisionMask) {
            if (typeof OIMO == "undefined")
                return;
            this.defaultCollisionGroup = _defaultCollisionGroup;
            this.defaultCollisionMask = _defaultCollisionMask;
        }
        /** Change if rigidbodies are able to sleep (don't be considered in physical calculations) when their movement is below a threshold. Deactivation is decreasing performance for minor advantage in precision. */
        get disableSleeping() {
            return OIMO.Setting.disableSleeping;
        }
        set disableSleeping(_value) {
            OIMO.Setting.disableSleeping = _value;
        }
        /** Sleeping Threshold for Movement Veloctiy. */
        get sleepingVelocityThreshold() {
            return OIMO.Setting.sleepingVelocityThreshold;
        }
        set sleepingVelocityThreshold(_value) {
            OIMO.Setting.sleepingVelocityThreshold = _value;
        }
        /** Sleeping Threshold for Rotation Velocity. */
        get sleepingAngularVelocityThreshold() {
            return OIMO.Setting.sleepingAngularVelocityThreshold;
        }
        set sleepingAngularVelocityThreshold(_value) {
            OIMO.Setting.sleepingAngularVelocityThreshold = _value;
        }
        /** Threshold how long the Rigidbody must be below/above the threshold to count as sleeping. */
        get sleepingTimeThreshold() {
            return OIMO.Setting.sleepingTimeThreshold;
        }
        set sleepingTimeThreshold(_value) {
            OIMO.Setting.sleepingTimeThreshold = _value;
        }
        /** Error threshold. Default is 0.05. The higher the more likely collisions get detected before actual impact at high speeds but it's visually less accurate. */
        get defaultCollisionMargin() {
            return OIMO.Setting.defaultGJKMargin;
        }
        set defaultCollisionMargin(_thickness) {
            OIMO.Setting.defaultGJKMargin = _thickness;
        }
        /** The default applied friction between two rigidbodies with the default value. How much velocity is slowed down when moving accross this surface. */
        get defaultFriction() {
            return OIMO.Setting.defaultFriction;
        }
        set defaultFriction(_value) {
            OIMO.Setting.defaultFriction = _value;
        }
        /** Bounciness of rigidbodies. How much of the impact is restituted. */
        get defaultRestitution() {
            return OIMO.Setting.defaultRestitution;
        }
        set defaultRestitution(_value) {
            OIMO.Setting.defaultRestitution = _value;
        }
        /** Groups the default rigidbody will collide with. Set it like: (PHYSICS_GROUP.DEFAULT | PHYSICS_GROUP.GROUP_1 | PHYSICS_GROUP.GROUP_2 | PHYSICS_GROUP.GROUP_3)
         * to collide with multiple groups. Default is collision with everything but triggers.
        */
        get defaultCollisionMask() {
            return OIMO.Setting.defaultCollisionMask;
        }
        set defaultCollisionMask(_value) {
            OIMO.Setting.defaultCollisionMask = _value;
        }
        /** The group that this rigidbody belongs to. Default is the DEFAULT Group which means its just a normal Rigidbody not a trigger nor anything special. */
        get defaultCollisionGroup() {
            return OIMO.Setting.defaultCollisionGroup;
        }
        set defaultCollisionGroup(_value) {
            OIMO.Setting.defaultCollisionGroup = _value;
        }
        /** Change the type of joint solver algorithm. Default Iterative == 0, is faster but less stable. Direct == 1, slow but more stable, recommended for complex joint work. Change this setting only at the start of your game. */
        get defaultConstraintSolverType() {
            return OIMO.Setting.defaultJointConstraintSolverType;
        }
        set defaultConstraintSolverType(_value) {
            OIMO.Setting.defaultJointConstraintSolverType = _value;
        }
        /** The correction algorithm used to correct physics calculations. Change this only at the beginning of your game. Each has different approaches, so if you have problems test another
         *  Default 0 = Baumgarte (fast but less correct induces some energy errors), 1 = Split-Impulse (fast and no engery errors, but more inaccurate for joints), 2 = Non-linear Gauss Seidel (slowest but most accurate)*/
        get defaultCorrectionAlgorithm() {
            return OIMO.Setting.defaultJointPositionCorrectionAlgorithm;
        }
        set defaultCorrectionAlgorithm(_value) {
            OIMO.Setting.defaultJointPositionCorrectionAlgorithm = _value;
        }
        /** The precision of the simulation in form of number of iterations the simulations runs through until it accepts the result.
         *  10 Default - Higher means more precision but results in a performance decrease. This helps especially with joints,
         * but also the general stability of the simulation due to simulation steps being rechecked multiple times before being set.
         */
        get solverIterations() {
            return FudgeCore.Physics.activeInstance.getOimoWorld().getNumPositionIterations();
        }
        set solverIterations(_value) {
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumPositionIterations(_value);
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumVelocityIterations(_value);
        }
    }
    FudgeCore.PhysicsSettings = PhysicsSettings;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Acts as the physical representation of a connection between two {@link Node}'s.
       * The type of conncetion is defined by the subclasses like prismatic joint, cylinder joint etc.
       * A Rigidbody on the {@link Node} that this component is added to is needed. Setting the connectedRigidbody and
       * initializing the connection creates a physical connection between them. This differs from a connection through hierarchy
       * in the node structure of fudge. Joints can have different DOF's (Degrees Of Freedom), 1 Axis that can either twist or swing is a degree of freedom.
       * A joint typically consists of a motor that limits movement/rotation or is activly trying to move to a limit. And a spring which defines the rigidity.
       * @author Marko Fehrenbach, HFU 2020
       */
    class Joint extends FudgeCore.Component {
        /** Create a joint connection between the two given RigidbodyComponents. */
        constructor(_bodyAnchor = null, _bodyTied = null) {
            super();
            this.#idBodyAnchor = 0;
            this.#idBodyTied = 0;
            this.#connected = false;
            this.#internalCollision = false;
            this.#breakForce = 0;
            this.#breakTorque = 0;
            // public static readonly iSubclass: number = Component.registerSubclass(ComponentJoint);
            this.singleton = false; //Multiple joints can be attached to one Node
            this.#getMutator = () => {
                let mutator = {
                    nameChildToConnect: this.#nameChildToConnect,
                    internalCollision: this.#internalCollision,
                    breakForce: this.#breakForce,
                    breakTorque: this.#breakTorque
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["internalCollision", "breakForce", "breakTorque"]);
            };
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* COMPONENT_ADD */:
                        this.node.addEventListener("disconnectJoint" /* DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.dirtyStatus();
                        break;
                    case "componentRemove" /* COMPONENT_REMOVE */:
                        this.node.removeEventListener("disconnectJoint" /* DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.removeJoint();
                        break;
                }
            };
            this.bodyAnchor = _bodyAnchor;
            this.bodyTied = _bodyTied;
            /*
              Tell the physics that there is a new joint and on the physics start the actual joint is first created. Values can be set but the
              actual constraint ain't existent until the game starts
            */
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndEvent);
        }
        #idBodyAnchor;
        #idBodyTied;
        #bodyAnchor;
        #bodyTied;
        #connected;
        #anchor;
        #internalCollision;
        #breakForce;
        #breakTorque;
        #nameChildToConnect;
        static registerSubclass(_subclass) { return Joint.subclasses.push(_subclass) - 1; }
        /** Get/Set the first ComponentRigidbody of this connection. It should always be the one that this component is attached too in the sceneTree. */
        get bodyAnchor() {
            return this.#bodyAnchor;
        }
        set bodyAnchor(_cmpRB) {
            this.#idBodyAnchor = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyAnchor = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /** Get/Set the second ComponentRigidbody of this connection. */
        get bodyTied() {
            return this.#bodyTied;
        }
        set bodyTied(_cmpRB) {
            this.#idBodyTied = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyTied = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The exact position where the two {@link Node}s are connected. When changed after initialization the joint needs to be reconnected.
         */
        get anchor() {
            return new FudgeCore.Vector3(this.#anchor.x, this.#anchor.y, this.#anchor.z);
        }
        set anchor(_value) {
            this.#anchor = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The amount of force needed to break the JOINT, while rotating, in Newton. 0 equals unbreakable (default)
        */
        get breakTorque() {
            return this.#breakTorque;
        }
        set breakTorque(_value) {
            this.#breakTorque = _value;
            if (this.joint != null)
                this.joint.setBreakTorque(this.#breakTorque);
        }
        /**
         * The amount of force needed to break the JOINT, in Newton. 0 equals unbreakable (default)
         */
        get breakForce() {
            return this.#breakForce;
        }
        set breakForce(_value) {
            this.#breakForce = _value;
            if (this.joint != null)
                this.joint.setBreakForce(this.#breakForce);
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
          * On a welding joint the connected bodies should not be colliding with each other,
          * for best results
         */
        get internalCollision() {
            return this.#internalCollision;
        }
        set internalCollision(_value) {
            this.#internalCollision = _value;
            if (this.joint != null)
                this.joint.setAllowCollision(this.#internalCollision);
        }
        connectChild(_name) {
            this.#nameChildToConnect = _name;
            if (!this.node)
                return;
            let children = this.node.getChildrenByName(_name);
            if (children.length == 1)
                this.connectNode(children.pop());
            else
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails to connect child with non existent or ambigous name ${_name}`);
        }
        connectNode(_node) {
            if (!_node || !this.node)
                return;
            FudgeCore.Debug.fudge(`${this.constructor.name} connected ${this.node.name} and ${_node.name}`);
            let connectBody = _node.getComponent(FudgeCore.ComponentRigidbody);
            let thisBody = this.node.getComponent(FudgeCore.ComponentRigidbody);
            if (!connectBody || !thisBody) {
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails due to missing rigidbodies on ${this.node.name} or ${_node.name}`);
                return;
            }
            this.bodyAnchor = thisBody;
            this.bodyTied = connectBody;
        }
        /** Check if connection is dirty, so when either rb is changed disconnect and reconnect. Internally used no user interaction needed. */
        isConnected() {
            return this.#connected;
        }
        /**
         * Initializing and connecting the two rigidbodies with the configured joint properties
         * is automatically called by the physics system. No user interaction needed.
         */
        connect() {
            if (this.#connected == false) {
                if (this.#idBodyAnchor == -1 || this.#idBodyTied == -1) {
                    if (this.#nameChildToConnect)
                        this.connectChild(this.#nameChildToConnect);
                    return;
                }
                this.constructJoint();
                this.#connected = true;
                this.addJoint();
            }
        }
        /**
         * Disconnecting the two rigidbodies and removing them from the physics system,
         * is automatically called by the physics system. No user interaction needed.
         */
        disconnect() {
            if (this.#connected == true) {
                this.removeJoint();
                this.#connected = false;
            }
        }
        /**
         * Returns the original Joint used by the physics engine. Used internally no user interaction needed.
         * Only to be used when functionality that is not added within Fudge is needed.
        */
        getOimoJoint() {
            return this.joint;
        }
        serialize() {
            let serialization = this.#getMutator();
            serialization.anchor = this.anchor.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.anchor = await new FudgeCore.Vector3().deserialize(_serialization.anchor);
            this.#mutate(_serialization);
            await super.deserialize(_serialization[super.constructor.name]);
            this.connectChild(_serialization.nameChildToConnect);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            Object.assign(mutator, this.#getMutator());
            mutator.anchor = this.anchor.getMutator();
            return mutator;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.anchor) !== "undefined")
                this.anchor = new FudgeCore.Vector3(...(Object.values(_mutator.anchor)));
            delete _mutator.anchor;
            if (typeof (_mutator.nameChildToConnect) !== "undefined")
                this.connectChild(_mutator.nameChildToConnect);
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        #getMutator;
        #mutate;
        reduceMutator(_mutator) {
            delete _mutator.springDamper;
            delete _mutator.joint;
            delete _mutator.motor;
            super.reduceMutator(_mutator);
        }
        /** Tell the FudgePhysics system that this joint needs to be handled in the next frame. */
        dirtyStatus() {
            FudgeCore.Physics.changeJointStatus(this);
        }
        addJoint() {
            FudgeCore.Physics.addJoint(this);
        }
        removeJoint() {
            FudgeCore.Physics.removeJoint(this);
        }
        constructJoint(..._configParams) {
            let posBodyAnchor = this.bodyAnchor.node.mtxWorld.translation; //Setting the anchor position locally from the first rigidbody
            let worldAnchor = new OIMO.Vec3(posBodyAnchor.x + this.#anchor.x, posBodyAnchor.y + this.#anchor.y, posBodyAnchor.z + this.#anchor.z);
            // @ts-ignore    // unfortunately, method init is not a member of the base class OIMO.JointConfig
            this.config.init(this.#bodyAnchor.getOimoRigidbody(), this.#bodyTied.getOimoRigidbody(), worldAnchor, ..._configParams);
        }
        configureJoint() {
            this.joint.setBreakForce(this.breakForce);
            this.joint.setBreakTorque(this.breakTorque);
            this.joint.setAllowCollision(this.#internalCollision);
        }
        deleteFromMutator(_mutator, _delete) {
            for (let key in _delete)
                delete _mutator[key];
        }
    }
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Joint.baseClass = Joint;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Joint.subclasses = [];
    FudgeCore.Joint = Joint;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Base class for joints operating with exactly one axis
       * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointAxial extends FudgeCore.Joint {
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            //Internal Variables
            this.#maxMotor = 10;
            this.#minMotor = -10;
            this.#motorSpeed = 0;
            this.#springFrequency = 0;
            this.#springDamping = 0;
            this.#getMutator = () => {
                let mutator = {
                    springDamping: this.#springDamping,
                    springFrequency: this.#springFrequency,
                    maxMotor: this.#maxMotor,
                    minMotor: this.#minMotor,
                    motorSpeed: this.#motorSpeed
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["springDamping", "springFrequency", "maxMotor", "minMotor", "motorSpeed"]);
            };
            this.axis = _axis;
            this.anchor = _localAnchor;
            this.minMotor = -10;
            this.maxMotor = 10;
        }
        //Internal Variables
        #maxMotor;
        #minMotor;
        #motorSpeed;
        #axis;
        #springFrequency;
        #springDamping;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axis() {
            return new FudgeCore.Vector3(this.#axis.x, this.#axis.y, this.#axis.z);
        }
        set axis(_value) {
            this.#axis = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get maxMotor() {
            return this.#maxMotor;
        }
        set maxMotor(_value) {
            this.#maxMotor = _value;
            try {
                this.joint.getLimitMotor().upperLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get minMotor() {
            return this.#minMotor;
        }
        set minMotor(_value) {
            this.#minMotor = _value;
            try {
                this.joint.getLimitMotor().lowerLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            try {
                this.joint.getSpringDamper().dampingRatio = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The target speed of the motor in m/s.
         */
        get motorSpeed() {
            return this.#motorSpeed;
        }
        set motorSpeed(_value) {
            this.#motorSpeed = _value;
            try {
                this.joint.getLimitMotor().motorSpeed = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            try {
                this.joint.getSpringDamper().frequency = _value;
            }
            catch (_e) { /* */ }
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axis = this.axis.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axis = await new FudgeCore.Vector3().deserialize(_serialization.axis);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.axis) !== "undefined")
                this.axis = new FudgeCore.Vector3(...(Object.values(_mutator.axis)));
            delete _mutator.axis;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.axis = this.axis.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.springDamper = new OIMO.SpringDamper().setSpring(this.#springFrequency, this.#springDamping);
            super.constructJoint(this.#axis);
        }
    }
    FudgeCore.JointAxial = JointAxial;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Debug/Debug.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Serialization/Mutable.ts"/>
/// <reference path="Serialization/Serializer.ts"/> 
/// <reference path="Component/Component.ts"/>
/// <reference path="Recycle/RecycableArray.ts"/>
/// <reference path="Render/RenderWebGL.ts"/>
/// <reference path="Render/RenderInjectorTexture.ts"/>
/// <reference path="Graph/Node.ts"/>
/// <reference path="Physics/HelpersPhysics.ts"/>
/// <reference path="Physics/Joint.ts"/>
/// <reference path="Physics/JointAxial.ts"/>
//global functions
function ifNumber(_check, _default) {
    return typeof _check == "undefined" ? _default : _check;
}
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCE"] = 1] = "PLAYONCE";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["PLAYONCESTOPAFTER"] = 2] = "PLAYONCESTOPAFTER";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["REVERSELOOP"] = 3] = "REVERSELOOP";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE[ANIMATION_PLAYMODE["STOP"] = 4] = "STOP";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_PLAYBACK;
    (function (ANIMATION_PLAYBACK) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the Playback. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_CONTINOUS"] = 0] = "TIMEBASED_CONTINOUS";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["TIMEBASED_RASTERED_TO_FPS"] = 1] = "TIMEBASED_RASTERED_TO_FPS";
        /** Advances the time each frame according to the FPS value of the animation, ignoring the actual duration of the frames. Doesn't skip any frames.*/
        ANIMATION_PLAYBACK[ANIMATION_PLAYBACK["FRAMEBASED"] = 2] = "FRAMEBASED";
    })(ANIMATION_PLAYBACK = FudgeCore.ANIMATION_PLAYBACK || (FudgeCore.ANIMATION_PLAYBACK = {}));
    /**
     * Animation Class to hold all required Objects that are part of an Animation.
     * Also holds functions to play said Animation.
     * Can be added to a Node and played through {@link ComponentAnimator}.
     * @author Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Animation extends FudgeCore.Mutable {
        constructor(_name, _animStructure = {}, _fps = 60) {
            super();
            this.totalTime = 0;
            this.labels = {};
            this.events = {};
            this.framesPerSecond = 60;
            // processed eventlist and animation strucutres for playback.
            this.eventsProcessed = new Map();
            this.animationStructuresProcessed = new Map();
            this.name = _name;
            this.animationStructure = _animStructure;
            this.animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
            this.framesPerSecond = _fps;
            this.calculateTotalTime();
            FudgeCore.Project.register(this);
        }
        get getLabels() {
            //TODO: this actually needs testing
            let en = new Enumerator(this.labels);
            return en;
        }
        get fps() {
            return this.framesPerSecond;
        }
        set fps(_fps) {
            this.framesPerSecond = _fps;
            this.eventsProcessed.clear();
            this.animationStructuresProcessed.clear();
        }
        /**
         * Generates a new "Mutator" with the information to apply to the {@link Node} the {@link ComponentAnimator} is attached to with {@link Node.applyAnimation}.
         * @param _time The time at which the animation currently is at
         * @param _direction The direction in which the animation is supposed to be playing back. >0 == forward, 0 == stop, <0 == backwards
         * @param _playback The playbackmode the animation is supposed to be calculated with.
         * @returns a "Mutator" to apply.
         */
        getMutated(_time, _direction, _playback) {
            let m = {};
            let animationStructure;
            if (_playback == ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS)
                animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.REVERSE : ANIMATION_STRUCTURE_TYPE.NORMAL;
            else
                animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE : ANIMATION_STRUCTURE_TYPE.RASTERED;
            m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(animationStructure), _time);
            return m;
        }
        /**
         * Returns a list of the names of the events the {@link ComponentAnimator} needs to fire between _min and _max.
         * @param _min The minimum time (inclusive) to check between
         * @param _max The maximum time (exclusive) to check between
         * @param _playback The playback mode to check in. Has an effect on when the Events are fired.
         * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
         * @returns a list of strings with the names of the custom events to fire.
         */
        getEventsToFire(_min, _max, _playback, _direction) {
            let eventList = [];
            let minSection = Math.floor(_min / this.totalTime);
            let maxSection = Math.floor(_max / this.totalTime);
            _min = _min % this.totalTime;
            _max = _max % this.totalTime;
            while (minSection <= maxSection) {
                let eventTriggers = this.getCorrectEventList(_direction, _playback);
                if (minSection == maxSection) {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, _max));
                }
                else {
                    eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, this.totalTime));
                    _min = 0;
                }
                minSection++;
            }
            return eventList;
        }
        /**
         * Adds an Event to the List of events.
         * @param _name The name of the event (needs to be unique per Animation).
         * @param _time The timestamp of the event (in milliseconds).
         */
        setEvent(_name, _time) {
            this.events[_name] = _time;
            this.eventsProcessed.clear();
        }
        /**
         * Removes the event with the given name from the list of events.
         * @param _name name of the event to remove.
         */
        removeEvent(_name) {
            delete this.events[_name];
            this.eventsProcessed.clear();
        }
        /**
         * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
         */
        calculateTotalTime() {
            this.totalTime = 0;
            this.traverseStructureForTime(this.animationStructure);
        }
        /**
         * Returns the time to use for animation sampling when applying a playmode
         */
        getModalTime(_time, _playmode, _timeStop = _time) {
            switch (_playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    // return this.localTime.getOffset();
                    return _timeStop;
                case ANIMATION_PLAYMODE.PLAYONCE:
                    if (_time >= this.totalTime)
                        return this.totalTime - 0.01; //TODO: this might cause some issues
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.totalTime)
                        // TODO: return _timeStop instead?
                        return this.totalTime + 0.01; //TODO: this might cause some issues
            }
            return _time;
        }
        /**
         * Calculates and returns the direction the animation should currently be playing in.
         * @param _time the time at which to calculate the direction
         * @returns 1 if forward, 0 if stop, -1 if backwards
         */
        calculateDirection(_time, _playmode) {
            switch (_playmode) {
                case ANIMATION_PLAYMODE.STOP:
                    return 0;
                // case ANIMATION_PLAYMODE.PINGPONG:
                //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                //     return 1;
                //   else
                //     return -1;
                case ANIMATION_PLAYMODE.REVERSELOOP:
                    return -1;
                case ANIMATION_PLAYMODE.PLAYONCE:
                case ANIMATION_PLAYMODE.PLAYONCESTOPAFTER:
                    if (_time >= this.totalTime) {
                        return 0;
                    }
                default:
                    return 1;
            }
        }
        //#region transfer
        serialize() {
            let s = {
                idResource: this.idResource,
                name: this.name,
                labels: {},
                events: {},
                fps: this.framesPerSecond,
                // sps: this.stepsPerSecond
            };
            for (let name in this.labels) {
                s.labels[name] = this.labels[name];
            }
            for (let name in this.events) {
                s.events[name] = this.events[name];
            }
            s.animationStructure = this.traverseStructureForSerialisation(this.animationStructure);
            return s;
        }
        async deserialize(_serialization) {
            this.idResource = _serialization.idResource;
            this.name = _serialization.name;
            this.framesPerSecond = _serialization.fps;
            // this.stepsPerSecond = _serialization.sps;
            this.labels = {};
            for (let name in _serialization.labels) {
                this.labels[name] = _serialization.labels[name];
            }
            this.events = {};
            for (let name in _serialization.events) {
                this.events[name] = _serialization.events[name];
            }
            this.eventsProcessed = new Map();
            this.animationStructure = await this.traverseStructureForDeserialisation(_serialization.animationStructure);
            this.animationStructuresProcessed = new Map();
            this.calculateTotalTime();
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            delete _mutator.totalTime;
        }
        /**
         * Traverses an AnimationStructure and returns the Serialization of said Structure.
         * @param _structure The Animation Structure at the current level to transform into the Serialization.
         * @returns the filled Serialization.
         */
        traverseStructureForSerialisation(_structure) {
            let newSerialization = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newSerialization[n] = _structure[n].serialize();
                }
                else {
                    newSerialization[n] = this.traverseStructureForSerialisation(_structure[n]);
                }
            }
            return newSerialization;
        }
        /**
         * Traverses a Serialization to create a new AnimationStructure.
         * @param _serialization The serialization to transfer into an AnimationStructure
         * @returns the newly created AnimationStructure.
         */
        async traverseStructureForDeserialisation(_serialization) {
            let newStructure = {};
            for (let n in _serialization) {
                if (_serialization[n].animationSequence) {
                    let animSeq = new FudgeCore.AnimationSequence();
                    newStructure[n] = await animSeq.deserialize(_serialization[n]);
                }
                else {
                    newStructure[n] = await this.traverseStructureForDeserialisation(_serialization[n]);
                }
            }
            return newStructure;
        }
        //#endregion
        /**
         * Finds the list of events to be used with these settings.
         * @param _direction The direction the animation is playing in.
         * @param _playback The playbackmode the animation is playing in.
         * @returns The correct AnimationEventTrigger Object to use
         */
        getCorrectEventList(_direction, _playback) {
            if (_playback != ANIMATION_PLAYBACK.FRAMEBASED) {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                }
            }
            else {
                if (_direction >= 0) {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                }
                else {
                    return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                }
            }
        }
        /**
         * Traverses an AnimationStructure to turn it into the "Mutator" to return to the Component.
         * @param _structure The strcuture to traverse
         * @param _time the point in time to write the animation numbers into.
         * @returns The "Mutator" filled with the correct values at the given time.
         */
        traverseStructureForMutator(_structure, _time) {
            let newMutator = {};
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    newMutator[n] = _structure[n].evaluate(_time);
                }
                else {
                    newMutator[n] = this.traverseStructureForMutator(_structure[n], _time);
                }
            }
            return newMutator;
        }
        /**
         * Traverses the current AnimationStrcuture to find the totalTime of this animation.
         * @param _structure The structure to traverse
         */
        traverseStructureForTime(_structure) {
            for (let n in _structure) {
                if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                    let sequence = _structure[n];
                    if (sequence.length > 0) {
                        let sequenceTime = sequence.getKey(sequence.length - 1).Time;
                        this.totalTime = sequenceTime > this.totalTime ? sequenceTime : this.totalTime;
                    }
                }
                else {
                    this.traverseStructureForTime(_structure[n]);
                }
            }
        }
        /**
         * Ensures the existance of the requested {@link AnimationStrcuture} and returns it.
         * @param _type the type of the structure to get
         * @returns the requested {@link AnimationStructure]]
         */
        getProcessedAnimationStructure(_type) {
            if (!this.animationStructuresProcessed.has(_type)) {
                this.calculateTotalTime();
                let ae = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ae = this.animationStructure;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ae = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                        break;
                    default:
                        return {};
                }
                this.animationStructuresProcessed.set(_type, ae);
            }
            return this.animationStructuresProcessed.get(_type);
        }
        /**
         * Ensures the existance of the requested {@link AnimationEventTrigger} and returns it.
         * @param _type The type of AnimationEventTrigger to get
         * @returns the requested {@link AnimationEventTrigger]]
         */
        getProcessedEventTrigger(_type) {
            if (!this.eventsProcessed.has(_type)) {
                this.calculateTotalTime();
                let ev = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        ev = this.events;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        ev = this.calculateReverseEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        ev = this.calculateRasteredEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        ev = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                        break;
                    default:
                        return {};
                }
                this.eventsProcessed.set(_type, ev);
            }
            return this.eventsProcessed.get(_type);
        }
        /**
         * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
         * @param _oldStructure The old structure to traverse
         * @param _functionToUse The function to use to recalculated the structure.
         * @returns A new Animation Structure with the recalulated Animation Sequences.
         */
        traverseStructureForNewStructure(_oldStructure, _functionToUse) {
            let newStructure = {};
            for (let n in _oldStructure) {
                if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                    newStructure[n] = _functionToUse(_oldStructure[n]);
                }
                else {
                    newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                }
            }
            return newStructure;
        }
        /**
         * Creates a reversed Animation Sequence out of a given Sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns The reversed Sequence
         */
        calculateReverseSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            for (let i = 0; i < _sequence.length; i++) {
                let oldKey = _sequence.getKey(i);
                let key = new FudgeCore.AnimationKey(this.totalTime - oldKey.Time, oldKey.Value, oldKey.SlopeOut, oldKey.SlopeIn, oldKey.Constant);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a rastered {@link AnimationSequence} out of a given sequence.
         * @param _sequence The sequence to calculate the new sequence out of
         * @returns the rastered sequence.
         */
        calculateRasteredSequence(_sequence) {
            let seq = new FudgeCore.AnimationSequence();
            let frameTime = 1000 / this.framesPerSecond;
            for (let i = 0; i < this.totalTime; i += frameTime) {
                let key = new FudgeCore.AnimationKey(i, _sequence.evaluate(i), 0, 0, true);
                seq.addKey(key);
            }
            return seq;
        }
        /**
         * Creates a new reversed {@link AnimationEventTrigger} object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the reversed event object
         */
        calculateReverseEventTriggers(_events) {
            let ae = {};
            for (let name in _events) {
                ae[name] = this.totalTime - _events[name];
            }
            return ae;
        }
        /**
         * Creates a rastered {@link AnimationEventTrigger} object based on the given one.
         * @param _events the event object to calculate the new one out of
         * @returns the rastered event object
         */
        calculateRasteredEventTriggers(_events) {
            let ae = {};
            let frameTime = 1000 / this.framesPerSecond;
            for (let name in _events) {
                ae[name] = _events[name] - (_events[name] % frameTime);
            }
            return ae;
        }
        /**
         * Checks which events lay between two given times and returns the names of the ones that do.
         * @param _eventTriggers The event object to check the events inside of
         * @param _min the minimum of the range to check between (inclusive)
         * @param _max the maximum of the range to check between (exclusive)
         * @returns an array of the names of the events in the given range.
         */
        checkEventsBetween(_eventTriggers, _min, _max) {
            let eventsToTrigger = [];
            for (let name in _eventTriggers) {
                if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                    eventsToTrigger.push(name);
                }
            }
            return eventsToTrigger;
        }
    }
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Calculates the values between {@link AnimationKey}s.
     * Represented internally by a cubic function (`f(x) = ax¬≥ + bx¬≤ + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Calculates the value of the function at the given time.
         * @param _time the point in time at which to evaluate the function in milliseconds. Will be corrected for offset internally.
         * @returns the value at the given time
         */
        evaluate(_time) {
            _time -= this.keyIn.Time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        set setKeyIn(_keyIn) {
            this.keyIn = _keyIn;
            this.calculate();
        }
        set setKeyOut(_keyOut) {
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * (Re-)Calculates the parameters of the cubic function.
         * See https://math.stackexchange.com/questions/3173469/calculate-cubic-equation-from-two-points-and-two-slopes-variably
         * and https://jirkadelloro.github.io/FUDGE/Documentation/Logs/190410_Notizen_LS
         */
        calculate() {
            if (!this.keyIn) {
                this.d = this.c = this.b = this.a = 0;
                return;
            }
            if (!this.keyOut || this.keyIn.Constant) {
                this.d = this.keyIn.Value;
                this.c = this.b = this.a = 0;
                return;
            }
            let x1 = this.keyOut.Time - this.keyIn.Time;
            this.d = this.keyIn.Value;
            this.c = this.keyIn.SlopeOut;
            this.a = (-x1 * (this.keyIn.SlopeOut + this.keyOut.SlopeIn) - 2 * this.keyIn.Value + 2 * this.keyOut.Value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.SlopeIn - this.keyIn.SlopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Holds information about set points in time, their accompanying values as well as their slopes.
     * Also holds a reference to the {@link AnimationFunction}s that come in and out of the sides. The {@link AnimationFunction}s are handled by the {@link AnimationSequence}s.
     * Saved inside an {@link AnimationSequence}.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationKey extends FudgeCore.Mutable {
        constructor(_time = 0, _value = 0, _slopeIn = 0, _slopeOut = 0, _constant = false) {
            super();
            this.constant = false;
            this.slopeIn = 0;
            this.slopeOut = 0;
            this.time = _time;
            this.value = _value;
            this.slopeIn = _slopeIn;
            this.slopeOut = _slopeOut;
            this.constant = _constant;
            this.broken = this.slopeIn != -this.slopeOut;
            this.functionOut = new FudgeCore.AnimationFunction(this, null);
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        get Time() {
            return this.time;
        }
        set Time(_time) {
            this.time = _time;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Value() {
            return this.value;
        }
        set Value(_value) {
            this.value = _value;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get Constant() {
            return this.constant;
        }
        set Constant(_constant) {
            this.constant = _constant;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get SlopeIn() {
            return this.slopeIn;
        }
        set SlopeIn(_slope) {
            this.slopeIn = _slope;
            this.functionIn.calculate();
        }
        get SlopeOut() {
            return this.slopeOut;
        }
        set SlopeOut(_slope) {
            this.slopeOut = _slope;
            this.functionOut.calculate();
        }
        //#region transfer
        serialize() {
            let s = {};
            s.time = this.time;
            s.value = this.value;
            s.slopeIn = this.slopeIn;
            s.slopeOut = this.slopeOut;
            s.constant = this.constant;
            return s;
        }
        async deserialize(_serialization) {
            this.time = _serialization.time;
            this.value = _serialization.value;
            this.slopeIn = _serialization.slopeIn;
            this.slopeOut = _serialization.slopeOut;
            this.constant = _serialization.constant;
            this.broken = this.slopeIn != -this.slopeOut;
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of {@link AnimationKey}s that is mapped to an attribute of a {@link Node} or its {@link Component}s inside the {@link Animation}.
     * Provides functions to modify said keys
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationSequence extends FudgeCore.Mutable {
        constructor() {
            super(...arguments);
            this.keys = [];
        }
        get length() {
            return this.keys.length;
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. 0 if there are no keys.
         */
        evaluate(_time) {
            if (this.keys.length == 0)
                return 0; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            if (this.keys.length == 1 || this.keys[0].Time >= _time)
                return this.keys[0].Value;
            for (let i = 0; i < this.keys.length - 1; i++) {
                if (this.keys[i].Time <= _time && this.keys[i + 1].Time > _time) {
                    return this.keys[i].functionOut.evaluate(_time);
                }
            }
            return this.keys[this.keys.length - 1].Value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        //#region transfer
        serialize() {
            let s = {
                keys: [],
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        async deserialize(_serialization) {
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                await k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        reduceMutator(_mutator) {
            //
        }
        //#endregion
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions() {
            for (let i = 0; i < this.keys.length; i++) {
                let f = new FudgeCore.AnimationFunction(this.keys[i]);
                this.keys[i].functionOut = f;
                if (i == this.keys.length - 1) {
                    //TODO: check if this is even useful. Maybe update the runcondition to length - 1 instead. Might be redundant if functionIn is removed, see TODO in AnimationKey.
                    f.setKeyOut = this.keys[0];
                    this.keys[0].functionIn = f;
                    break;
                }
                f.setKeyOut = this.keys[i + 1];
                this.keys[i + 1].functionIn = f;
            }
        }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the {@link AudioManager}.default to be used with {@link ComponentAudio}
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Audio extends FudgeCore.Mutable {
        constructor(_url) {
            super();
            this.name = "Audio";
            this.idResource = undefined;
            this.buffer = undefined;
            this.path = undefined;
            this.url = undefined;
            this.ready = false;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get isReady() {
            return this.ready;
        }
        /**
         * Asynchronously loads the audio (mp3) from the given url
         */
        async load(_url) {
            FudgeCore.Debug.fudge("AudioLoad", _url);
            this.url = _url;
            this.ready = false;
            this.path = new URL(this.url.toString(), FudgeCore.Project.baseURL);
            const response = await window.fetch(this.path.toString());
            const arrayBuffer = await response.arrayBuffer();
            let buffer = await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer);
            this.buffer = buffer;
            this.ready = true;
            this.dispatchEvent(new Event("ready" /* READY */));
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                idResource: this.idResource,
                name: this.name,
                type: this.type
            };
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            await this.load(_serialization.url);
            this.name = _serialization.name;
            return this;
        }
        async mutate(_mutator) {
            let url = _mutator.url; // save url for reconstruction after exclusion
            if (_mutator.url != this.url.toString())
                this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            super.mutate(_mutator);
            // reconstruct, for mutator may be kept by caller
            Reflect.set(_mutator, "url", url);
        }
        reduceMutator(_mutator) {
            // delete _mutator.idResource; 
            delete _mutator.ready;
        }
    }
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with FUDGE-graphs.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    class AudioManager extends AudioContext {
        constructor(contextOptions) {
            super(contextOptions);
            this.graph = null;
            this.cmpListener = null;
            /**
             * Determines FUDGE-graph to listen to. Each {@link ComponentAudio} in the graph will connect to this contexts master gain, all others disconnect.
             */
            this.listenTo = (_graph) => {
                if (this.graph)
                    this.graph.broadcastEvent(new Event("childRemoveFromAudioGraph" /* CHILD_REMOVE */));
                if (!_graph)
                    return;
                this.graph = _graph;
                this.graph.broadcastEvent(new Event("childAppendToAudioGraph" /* CHILD_APPEND */));
            };
            /**
             * Retrieve the FUDGE-graph currently listening to
             */
            this.getGraphListeningTo = () => {
                return this.graph;
            };
            /**
             * Set the {@link ComponentAudioListener} that serves the spatial location and orientation for this contexts listener
             */
            this.listenWith = (_cmpListener) => {
                this.cmpListener = _cmpListener;
            };
            /**
             * Updates the spatial settings of the AudioNodes effected in the current FUDGE-graph
             */
            this.update = () => {
                this.graph.broadcastEvent(new Event("updateAudioGraph" /* UPDATE */));
                if (this.cmpListener)
                    this.cmpListener.update(this.listener);
            };
            this.gain = this.createGain();
            this.gain.connect(this.destination);
        }
        /**
         * Set the master volume
         */
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        /**
         * Get the master volume
         */
        get volume() {
            return this.gain.gain.value;
        }
    }
    /** The default context that may be used throughout the project without the need to create others */
    AudioManager.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 });
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an {@link AudioFilter} to an {@link Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds a reference to an {@link Animation} and controls it. Controls playback and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class ComponentAnimator extends FudgeCore.Component {
        constructor(_animation = new FudgeCore.Animation(""), _playmode = FudgeCore.ANIMATION_PLAYMODE.LOOP, _playback = FudgeCore.ANIMATION_PLAYBACK.TIMEBASED_CONTINOUS) {
            super();
            this.scaleWithGameTime = true;
            this.#scale = 1;
            this.#previous = 0;
            //#endregion
            //#region updateAnimation
            /**
             * Updates the Animation.
             * Gets called every time the Loop fires the LOOP_FRAME Event.
             * Uses the built-in time unless a different time is specified.
             * May also be called from updateAnimation().
             */
            this.updateAnimationLoop = (_e, _time) => {
                if (this.animation.totalTime == 0)
                    return [null, 0];
                let time = _time || this.#timeLocal.get();
                if (this.playback == FudgeCore.ANIMATION_PLAYBACK.FRAMEBASED) {
                    time = this.#previous + (1000 / this.animation.fps);
                }
                let direction = this.animation.calculateDirection(time, this.playmode);
                time = this.animation.getModalTime(time, this.playmode, this.#timeLocal.getOffset());
                this.executeEvents(this.animation.getEventsToFire(this.#previous, time, this.playback, direction));
                if (this.#previous != time) {
                    this.#previous = time;
                    time = time % this.animation.totalTime;
                    let mutator = this.animation.getMutated(time, direction, this.playback);
                    if (this.node) {
                        this.node.applyAnimation(mutator);
                    }
                    return [mutator, time];
                }
                return [null, time];
            };
            /**
             * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
             */
            this.updateScale = () => {
                let newScale = this.#scale;
                if (this.scaleWithGameTime)
                    newScale *= FudgeCore.Time.game.getScale();
                this.#timeLocal.setScale(newScale);
            };
            this.animation = _animation;
            this.playmode = _playmode;
            this.playback = _playback;
            this.#timeLocal = new FudgeCore.Time();
            //TODO: update animation total time when loading a different animation?
            this.animation.calculateTotalTime();
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, () => this.activate(false));
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, () => {
                this.node.addEventListener("childRemove" /* CHILD_REMOVE */, () => this.activate(false));
                this.activate(true);
            });
        }
        #scale;
        #timeLocal;
        #previous;
        set scale(_scale) {
            this.#scale = _scale;
            this.updateScale();
        }
        get scale() {
            return this.#scale;
        }
        /**
         * Returns the current sample time of the animation
         */
        get time() {
            return this.#timeLocal.get() % this.animation.totalTime;
        }
        activate(_on) {
            super.activate(_on);
            if (!this.node)
                return;
            if (_on) {
                FudgeCore.Time.game.addEventListener("timeScaled" /* TIME_SCALED */, this.updateScale);
                this.node.addEventListener("renderPrepare" /* RENDER_PREPARE */, this.updateAnimationLoop);
            }
            else {
                FudgeCore.Time.game.addEventListener("timeScaled" /* TIME_SCALED */, this.updateScale);
                this.node.removeEventListener("renderPrepare" /* RENDER_PREPARE */, this.updateAnimationLoop);
            }
        }
        /**
         * Jumps to a certain time in the animation to play from there.
         */
        jumpTo(_time) {
            this.#timeLocal.set(_time);
            this.#previous = _time;
            _time = _time % this.animation.totalTime;
            let mutator = this.animation.getMutated(_time, this.animation.calculateDirection(_time, this.playmode), this.playback);
            this.node.applyAnimation(mutator);
        }
        /**
         * Jumps to a certain label in the animation if defined
         */
        jumpToLabel(_label) {
            let time = this.animation.labels[_label];
            if (time)
                this.jumpTo(time);
        }
        /**
         * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
         * @param _time the (unscaled) time to update the animation with.
         * @returns a Tupel containing the Mutator for Animation and the playmode corrected time.
         */
        updateAnimation(_time) {
            return this.updateAnimationLoop(null, _time);
        }
        //#region transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idAnimation = this.animation.idResource;
            serialization.playmode = this.playmode;
            serialization.playback = this.playback;
            serialization.scale = this.scale;
            serialization.scaleWithGameTime = this.scaleWithGameTime;
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            this.animation = await FudgeCore.Project.getResource(_serialization.idAnimation);
            this.playback = _serialization.playback;
            this.playmode = _serialization.playmode;
            this.scale = _serialization.scale;
            this.scaleWithGameTime = _serialization.scaleWithGameTime;
            return this;
        }
        /**
         * Fires all custom events the Animation should have fired between the last frame and the current frame.
         * @param events a list of names of custom events to fire
         */
        executeEvents(events) {
            for (let i = 0; i < events.length; i++) {
                this.dispatchEvent(new Event(events[i]));
            }
        }
    }
    ComponentAnimator.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimator);
    FudgeCore.ComponentAnimator = ComponentAnimator;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in {@link AudioManager}.default) and synchronizes it with the containing {@link Node}
     * ```plaintext
     * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
     * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudio extends FudgeCore.Component {
        constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
            super();
            /** places and directs the panner relative to the world transform of the {@link Node}  */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.singleton = false;
            this.playing = false;
            this.listened = false;
            //#endregion
            this.hndAudioReady = (_event) => {
                FudgeCore.Debug.fudge("Audio start", Reflect.get(_event.target, "url"));
                if (this.playing)
                    this.play(true);
            };
            this.hndAudioEnded = (_event) => {
                // Debug.fudge("Audio ended", Reflect.get(_event.target, "url"));
                this.playing = false;
            };
            /**
             * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
             * Therefore unused AudioNodes may be garbage collected when an unused component is collected
             */
            this.handleAttach = (_event) => {
                // Debug.log(_event);
                if (_event.type == "componentAdd" /* COMPONENT_ADD */) {
                    this.node.addEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                    this.node.addEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                    this.node.addEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                    this.listened = this.node.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo());
                }
                else {
                    this.node.removeEventListener("childAppendToAudioGraph" /* CHILD_APPEND */, this.handleGraph, true);
                    this.node.removeEventListener("childRemoveFromAudioGraph" /* CHILD_REMOVE */, this.handleGraph, true);
                    this.node.removeEventListener("updateAudioGraph" /* UPDATE */, this.update, true);
                    this.listened = false;
                }
                this.updateConnection();
            };
            /**
             * Automatically connects/disconnects AudioNodes when appending/removing the FUDGE-graph the component is in.
             */
            this.handleGraph = (_event) => {
                // Debug.log(_event);
                this.listened = (_event.type == "childAppendToAudioGraph" /* CHILD_APPEND */);
                this.updateConnection();
            };
            /**
             * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
             */
            this.update = (_event) => {
                let mtxResult = this.mtxPivot;
                if (this.node)
                    mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
                // Debug.log(mtxResult.toString());
                let position = mtxResult.translation;
                let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                this.panner.positionX.value = position.x;
                this.panner.positionY.value = position.y;
                this.panner.positionZ.value = position.z;
                this.panner.orientationX.value = forward.x;
                this.panner.orientationY.value = forward.y;
                this.panner.orientationZ.value = forward.z;
                FudgeCore.Recycler.store(forward);
                // TODO: examine why the following produces erroneous results, see test "Spatial Audio"
                if (this.node)
                    FudgeCore.Recycler.store(mtxResult);
            };
            this.install(_audioManager);
            this.createSource(_audio, _loop);
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.handleAttach);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.handleAttach);
            if (_start)
                this.play(_start);
        }
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        get volume() {
            return this.gain.gain.value;
        }
        set loop(_on) {
            this.source.loop = _on;
        }
        get loop() {
            return this.source.loop;
        }
        get isPlaying() {
            return this.playing;
        }
        get isAttached() {
            return this.node != null;
        }
        get isListened() {
            return this.listened;
        }
        setAudio(_audio) {
            this.createSource(_audio, this.source.loop);
        }
        getAudio() {
            return this.audio;
        }
        /**
         * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
         */
        setPanner(_property, _value) {
            Reflect.set(this.panner, _property, _value);
        }
        // TODO: may be used for serialization of AudioNodes
        getMutatorOfNode(_type) {
            let node = this.getAudioNode(_type);
            let mutator = FudgeCore.getMutatorOfArbitrary(node);
            return mutator;
        }
        /**
         * Returns the specified AudioNode of the standard graph for further manipulation
         */
        getAudioNode(_type) {
            switch (_type) {
                case AUDIO_NODE_TYPE.SOURCE: return this.source;
                case AUDIO_NODE_TYPE.PANNER: return this.panner;
                case AUDIO_NODE_TYPE.GAIN: return this.gain;
            }
        }
        /**
         * Start or stop playing the audio
         */
        play(_on) {
            if (_on) {
                if (this.audio.isReady) {
                    this.createSource(this.audio, this.source.loop);
                    this.source.start(0, 0);
                }
                else {
                    this.audio.addEventListener("ready" /* READY */, this.hndAudioReady);
                }
                this.source.addEventListener("ended" /* ENDED */, this.hndAudioEnded);
            }
            else
                try {
                    this.source.stop();
                }
                catch (_error) { /* catch exception when source hasn't been started... */ }
            this.playing = _on;
        }
        /**
         * Inserts AudioNodes between the panner and the local gain of this {@link ComponentAudio}
         * _input and _output may be the same AudioNode, if there is only one to insert,
         * or may have multiple AudioNode between them to create an effect-graph.\
         * Note that {@link ComponentAudio} does not keep track of inserted AudioNodes!
         * ```plaintext
         * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
         * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
         * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ_input‚îÇ ‚Üí ...  ‚Üí ‚îÇ_output‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
         * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
         * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
         * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         * ```
         */
        insertAudioNodes(_input, _output) {
            this.panner.disconnect(0);
            if (!_input && !_output) {
                this.panner.connect(this.gain);
                return;
            }
            this.panner.connect(_input);
            _output.connect(this.gain);
        }
        /**
         * Activate override. Connects or disconnects AudioNodes
         */
        activate(_on) {
            super.activate(_on);
            this.updateConnection();
        }
        /**
         * Connects this components gain-node to the gain node of the AudioManager this component runs on.
         * Only call this method if the component is not attached to a {@link Node} but needs to be heard.
         */
        connect(_on) {
            if (_on)
                this.gain.connect(this.audioManager.gain);
            else
                this.gain.disconnect(this.audioManager.gain);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idResource = this.audio.idResource;
            serialization.playing = this.playing;
            serialization.loop = this.loop;
            serialization.volume = this.volume;
            // console.log(this.getMutatorOfNode(AUDIO_NODE_TYPE.PANNER));
            // TODO: serialize panner parameters
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let audio = await FudgeCore.Project.getResource(_serialization.idResource);
            this.createSource(audio, _serialization.loop);
            this.volume = _serialization.volume;
            this.play(_serialization.playing);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            let audio = mutator.audio;
            delete mutator.audio; // just to rearrange in interfaces...
            mutator.loop = this.loop;
            mutator.volume = this.volume;
            mutator.audio = audio; //... so audio comes last
            return mutator;
        }
        // public async mutate(_mutator: Mutator): Promise<void> {
        //   await super.mutate(_mutator);
        //   // this.volume = _mutator.volume;
        //   // this.loop = _mutator.loop;
        // }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.listened;
        }
        install(_audioManager = FudgeCore.AudioManager.default) {
            let active = this.isActive;
            this.activate(false);
            this.audioManager = _audioManager;
            this.panner = _audioManager.createPanner();
            this.gain = _audioManager.createGain();
            this.panner.connect(this.gain);
            this.gain.connect(_audioManager.gain);
            this.activate(active);
        }
        createSource(_audio, _loop) {
            if (this.source) {
                this.source.disconnect();
                this.source.buffer = null;
            }
            this.source = this.audioManager.createBufferSource();
            this.source.connect(this.panner);
            if (_audio) {
                this.audio = _audio;
                this.source.buffer = _audio.buffer;
            }
            this.source.loop = _loop;
        }
        updateConnection() {
            try {
                this.connect(this.isActive && this.isAttached && this.listened);
            }
            catch (_error) {
                // nop
            }
        }
    }
    ComponentAudio.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio);
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the {@link Node} it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudioListener extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
        }
        /**
         * Updates the position and orientation of the given AudioListener
         */
        update(_listener) {
            let mtxResult = this.mtxPivot;
            if (this.node)
                mtxResult = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            // Debug.log(mtxResult.toString());
            let position = mtxResult.translation;
            let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
            let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
            if (_listener.positionX != undefined) {
                _listener.positionX.value = position.x;
                _listener.positionY.value = position.y;
                _listener.positionZ.value = position.z;
                _listener.forwardX.value = forward.x;
                _listener.forwardY.value = forward.y;
                _listener.forwardZ.value = forward.z;
                _listener.upX.value = up.x;
                _listener.upY.value = up.y;
                _listener.upZ.value = up.z;
            }
            else {
                // Firefox still uses deprecated methods. TODO: delete as soon as possible!
                _listener.setPosition(position.x, position.y, position.z);
                _listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
            }
            FudgeCore.Recycler.store(forward);
            FudgeCore.Recycler.store(up);
            // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
        }
    }
    ComponentAudioListener.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener);
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW[FIELD_OF_VIEW["HORIZONTAL"] = 0] = "HORIZONTAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["VERTICAL"] = 1] = "VERTICAL";
        FIELD_OF_VIEW[FIELD_OF_VIEW["DIAGONAL"] = 2] = "DIAGONAL";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentCamera extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.clrBackground = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
            this.projection = PROJECTION.CENTRAL;
            this.mtxProjection = new FudgeCore.Matrix4x4; // The matrix to multiply each scene objects transformation by, to determine where it will be drawn.
            this.fieldOfView = 45; // The camera's sensorangle.
            this.aspectRatio = 1.0;
            this.direction = FIELD_OF_VIEW.DIAGONAL;
            this.near = 1;
            this.far = 2000;
            this.backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered.
            //#endregion
        }
        //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
        #mtxWorldToView;
        // TODO: examine, if background should be an attribute of Camera or Viewport
        get mtxWorld() {
            let mtxCamera = this.mtxPivot.clone;
            try {
                mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            }
            catch (_error) {
                // no container node or no world transformation found -> continue with pivot only
            }
            return mtxCamera;
        }
        /**
         * Returns the multiplication of the worldtransformation of the camera container, the pivot of this camera and the inversion of the projection matrix
         * yielding the worldspace to viewspace matrix
         */
        get mtxWorldToView() {
            if (this.#mtxWorldToView)
                return this.#mtxWorldToView;
            //TODO: optimize, no need to recalculate if neither mtxWorld nor pivot have changed
            let mtxCamera = this.mtxWorld;
            let mtxInversion = FudgeCore.Matrix4x4.INVERSION(mtxCamera);
            this.#mtxWorldToView = FudgeCore.Matrix4x4.MULTIPLICATION(this.mtxProjection, mtxInversion);
            FudgeCore.Recycler.store(mtxCamera);
            FudgeCore.Recycler.store(mtxInversion);
            return this.#mtxWorldToView;
        }
        resetWorldToView() {
            this.#mtxWorldToView = null;
        }
        getProjection() {
            return this.projection;
        }
        getBackgroundEnabled() {
            return this.backgroundEnabled;
        }
        getAspect() {
            return this.aspectRatio;
        }
        getFieldOfView() {
            return this.fieldOfView;
        }
        getDirection() {
            return this.direction;
        }
        getNear() {
            return this.near;
        }
        getFar() {
            return this.far;
        }
        /**
         * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfView The field of view in Degrees. (Default = 45)
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        projectCentral(_aspect = this.aspectRatio, _fieldOfView = this.fieldOfView, _direction = this.direction, _near = 1, _far = 2000) {
            this.aspectRatio = _aspect;
            this.fieldOfView = _fieldOfView;
            this.direction = _direction;
            this.projection = PROJECTION.CENTRAL;
            this.near = _near;
            this.far = _far;
            this.mtxProjection = FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.fieldOfView, _near, _far, this.direction); // TODO: remove magic numbers
        }
        /**
         * Set the camera to orthographic projection. The origin is in the top left corner of the canvas.
         * @param _left The positionvalue of the projectionspace's left border. (Default = 0)
         * @param _right The positionvalue of the projectionspace's right border. (Default = canvas.clientWidth)
         * @param _bottom The positionvalue of the projectionspace's bottom border.(Default = canvas.clientHeight)
         * @param _top The positionvalue of the projectionspace's top border.(Default = 0)
         */
        projectOrthographic(_left = 0, _right = FudgeCore.Render.getCanvas().clientWidth, _bottom = FudgeCore.Render.getCanvas().clientHeight, _top = 0) {
            this.projection = PROJECTION.ORTHOGRAPHIC;
            this.mtxProjection = FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400); // TODO: examine magic numbers!
        }
        /**
         * Return the calculated dimension of a projection surface in the hypothetical distance of 1 to the camera
         */
        getProjectionRectangle() {
            let tanFov = Math.tan(Math.PI * this.fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
            let tanHorizontal = 0;
            let tanVertical = 0;
            if (this.direction == FIELD_OF_VIEW.DIAGONAL) {
                let aspect = Math.sqrt(this.aspectRatio);
                tanHorizontal = tanFov * aspect;
                tanVertical = tanFov / aspect;
            }
            else if (this.direction == FIELD_OF_VIEW.VERTICAL) {
                tanVertical = tanFov;
                tanHorizontal = tanVertical * this.aspectRatio;
            }
            else { //FOV_DIRECTION.HORIZONTAL
                tanHorizontal = tanFov;
                tanVertical = tanHorizontal / this.aspectRatio;
            }
            return FudgeCore.Rectangle.GET(0, 0, tanHorizontal * 2, tanVertical * 2);
        }
        pointWorldToClip(_pointInWorldSpace) {
            let result;
            let m = this.mtxWorldToView.get();
            let w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
            result = FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.mtxWorldToView);
            result.scale(1 / w);
            return result;
        }
        pointClipToWorld(_pointInClipSpace) {
            let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSION(this.mtxWorldToView);
            let m = mtxViewToWorld.get();
            let rayWorld = FudgeCore.Vector3.TRANSFORMATION(_pointInClipSpace, mtxViewToWorld, true);
            let w = m[3] * _pointInClipSpace.x + m[7] * _pointInClipSpace.y + m[11] * _pointInClipSpace.z + m[15];
            rayWorld.scale(1 / w);
            return rayWorld;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                backgroundColor: this.clrBackground,
                backgroundEnabled: this.backgroundEnabled,
                projection: this.projection,
                fieldOfView: this.fieldOfView,
                direction: this.direction,
                aspect: this.aspectRatio,
                pivot: this.mtxPivot.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.clrBackground = _serialization.backgroundColor;
            this.backgroundEnabled = _serialization.backgroundEnabled;
            this.projection = _serialization.projection;
            this.fieldOfView = _serialization.fieldOfView;
            this.aspectRatio = _serialization.aspect;
            this.direction = _serialization.direction;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            switch (this.projection) {
                case PROJECTION.ORTHOGRAPHIC:
                    this.projectOrthographic(); // TODO: serialize and deserialize parameters
                    break;
                case PROJECTION.CENTRAL:
                    this.projectCentral();
                    break;
            }
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.direction)
                types.direction = FIELD_OF_VIEW;
            if (types.projection)
                types.projection = PROJECTION;
            return types;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            switch (this.projection) {
                case PROJECTION.CENTRAL:
                    this.projectCentral(this.aspectRatio, this.fieldOfView, this.direction);
                    break;
            }
        }
        reduceMutator(_mutator) {
            delete _mutator.transform;
            super.reduceMutator(_mutator);
        }
    }
    ComponentCamera.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera);
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Filters synchronization between a graph instance and the graph it is connected to. If active, no synchronization occurs.
     * Maybe more finegrained in the future...
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentGraphFilter extends FudgeCore.Component {
        constructor() {
            super();
            this.singleton = true;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    ComponentGraphFilter.iSubclass = FudgeCore.Component.registerSubclass(ComponentGraphFilter);
    FudgeCore.ComponentGraphFilter = ComponentGraphFilter;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of lights.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Light extends FudgeCore.Mutable {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super();
            this.color = _color;
        }
        getType() {
            return this.constructor;
        }
        serialize() {
            let serialization = {
                color: this.color.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await this.color.deserialize(_serialization.color);
            return this;
        }
        reduceMutator() { }
    }
    FudgeCore.Light = Light;
    /**
     * Ambient light, coming from all directions, illuminating everything with its color independent of position and orientation (like a foggy day or in the shades)
     * ```plaintext
     * ~ ~ ~
     *  ~ ~ ~
     * ```
     */
    class LightAmbient extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightAmbient = LightAmbient;
    /**
     * Directional light, illuminating everything from a specified direction with its color (like standing in bright sunlight)
     * ```plaintext
     * --->
     * --->
     * --->
     * ```
     */
    class LightDirectional extends Light {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1)) {
            super(_color);
        }
    }
    FudgeCore.LightDirectional = LightDirectional;
    /**
     * Omnidirectional light emitting from its position, illuminating objects depending on their position and distance with its color (like a colored light bulb)
     * ```plaintext
     *         .\|/.
     *        -- o --
     *         ¬¥/|\`
     * ```
     */
    class LightPoint extends Light {
        constructor() {
            super(...arguments);
            this.range = 10;
        }
    }
    FudgeCore.LightPoint = LightPoint;
    /**
     * Spot light emitting within a specified angle from its position, illuminating objects depending on their position and distance with its color
     * ```plaintext
     *          o
     *         /|\
     *        / | \
     * ```
     */
    class LightSpot extends Light {
    }
    FudgeCore.LightSpot = LightSpot;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Light/Light.ts"/>
var FudgeCore;
///<reference path="../Light/Light.ts"/>
(function (FudgeCore) {
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export let LIGHT_TYPE: { [type: string]: string } = {
    let LIGHT_TYPE;
    (function (LIGHT_TYPE) {
        LIGHT_TYPE["AMBIENT"] = "LightAmbient";
        LIGHT_TYPE["DIRECTIONAL"] = "LightDirectional";
        LIGHT_TYPE["POINT"] = "LightPoint";
        LIGHT_TYPE["SPOT"] = "LightSpot";
    })(LIGHT_TYPE = FudgeCore.LIGHT_TYPE || (FudgeCore.LIGHT_TYPE = {}));
    /**
      * Attaches a {@link Light} to the node
      * @authors Jirka Dell'Oro-Friedl, HFU, 2019
      */
    class ComponentLight extends FudgeCore.Component {
        constructor(_light = new FudgeCore.LightAmbient()) {
            super();
            // private static constructors: { [type: string]: General } = { [LIGHT_TYPE.AMBIENT]: LightAmbient, [LIGHT_TYPE.DIRECTIONAL]: LightDirectional, [LIGHT_TYPE.POINT]: LightPoint, [LIGHT_TYPE.SPOT]: LightSpot };
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.light = null;
            this.singleton = false;
            this.light = _light;
        }
        setType(_class) {
            let mtrOld = {};
            if (this.light)
                mtrOld = this.light.getMutator();
            this.light = new _class();
            this.light.mutate(mtrOld);
        }
        serialize() {
            let serialization = {
                pivot: this.mtxPivot.serialize(),
                light: FudgeCore.Serializer.serialize(this.light)
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxPivot.deserialize(_serialization.pivot);
            this.light = await FudgeCore.Serializer.deserialize(_serialization.light);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.type = this.light.getType().name;
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.type)
                types.type = LIGHT_TYPE;
            return types;
        }
        async mutate(_mutator) {
            let type = _mutator.type;
            if (typeof (type) !== "undefined" && type != this.light.constructor.name)
                this.setType(FudgeCore.Serializer.getConstructor(type));
            delete (_mutator.type); // exclude light type from further mutation
            super.mutate(_mutator);
            _mutator.type = type; // reconstruct mutator
        }
    }
    ComponentLight.iSubclass = FudgeCore.Component.registerSubclass(ComponentLight);
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Material} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019 - 2021
     */
    class ComponentMaterial extends FudgeCore.Component {
        // public mutatorCoat: MutatorForComponent;
        constructor(_material = null) {
            super();
            this.clrPrimary = FudgeCore.Color.CSS("white");
            this.clrSecondary = FudgeCore.Color.CSS("white");
            this.mtxPivot = FudgeCore.Matrix3x3.IDENTITY();
            //** support sorting of objects with transparency when rendering, render objects in the back first */
            this.sortForAlpha = false;
            this.material = _material;
            // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
        }
        //#region Transfer
        serialize() {
            let serialization = {
                sortForAlpha: this.sortForAlpha,
                clrPrimary: this.clrPrimary.serialize(),
                clrSecondary: this.clrSecondary.serialize(),
                pivot: this.mtxPivot.serialize(),
                [super.constructor.name]: super.serialize(),
                idMaterial: this.material.idResource
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.material = await FudgeCore.Project.getResource(_serialization.idMaterial);
            await this.clrPrimary.deserialize(_serialization.clrPrimary);
            await this.clrSecondary.deserialize(_serialization.clrSecondary);
            this.sortForAlpha = _serialization.sortForAlpha;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    ComponentMaterial.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial);
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Mesh} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentMesh extends FudgeCore.Component {
        constructor(_mesh, _skeleton) {
            super();
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.mesh = _mesh;
            if (_skeleton)
                this.bindSkeleton(_skeleton);
        }
        #skeleton;
        get radius() {
            let scaling = this.mtxWorld.scaling;
            let scale = Math.max(Math.abs(scaling.x), Math.abs(scaling.y), Math.abs(scaling.z));
            return this.mesh.radius * scale;
        }
        get skeleton() {
            return this.#skeleton;
        }
        bindSkeleton(_skeleton) {
            this.#skeleton = _skeleton;
            if (!this.skeleton && !this.node)
                this.addEventListener("componentAdd" /* COMPONENT_ADD */, (_event) => {
                    if (_event.target != this)
                        return;
                    this.node.addChild(this.skeleton);
                });
            else if (this.node)
                this.node.addChild(this.skeleton);
        }
        // /**
        //  * Calculates the position of a vertex transformed by the skeleton
        //  * @param _index index of the vertex
        //  */
        // public getVertexPosition(_index: number): Vector3 {
        //   // extract the vertex data (vertices: 3D vectors, bone indices & weights: 4D vectors)
        //   const iVertex: number = _index * 3;
        //   const iBoneInfluence: number = _index * 4;
        //   const vertex: Vector3 = new Vector3(...Reflect.get(this.mesh, "renderMesh").vertices.slice(iVertex, iVertex + 3));
        //   if (!(this.mesh instanceof MeshSkin)) return vertex;
        //   const iBones: Uint8Array = this.mesh.iBones.slice(iBoneInfluence, iBoneInfluence + 4);
        //   const weights: Float32Array = this.mesh.weights.slice(iBoneInfluence, iBoneInfluence + 4);
        //   // get bone matrices
        //   const mtxBones: Array<Matrix4x4> = this.skeleton.mtxBones;
        //   // skin matrix S = sum_i=1^m{w_i * B_i}
        //   const skinMatrix: Matrix4x4 = new Matrix4x4();
        //   skinMatrix.set(Array
        //     .from(iBones)
        //     .map((iBone, iWeight) => mtxBones[iBone].get().map(value => value * weights[iWeight])) // apply weight on each matrix
        //     .reduce((mtxSum, mtxBone) => mtxSum.map((value, index) => value + mtxBone[index])) // sum up the matrices
        //   );
        //   // transform vertex
        //   vertex.transform(skinMatrix);
        //   return vertex;
        // }
        // TODO: remove or think if the transformed bounding box is of value or can be made to be
        // public get boundingBox(): Box {
        //   let box: Box = Recycler.get(Box);
        //   box.set(
        //     Vector3.TRANSFORMATION(this.mesh.boundingBox.min, this.mtxWorld, true),
        //     Vector3.TRANSFORMATION(this.mesh.boundingBox.max, this.mtxWorld, true)
        //   );
        //   return box;
        // }
        //#region Transfer
        serialize() {
            let serialization;
            /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
            let idMesh = this.mesh.idResource;
            if (idMesh)
                serialization = { idMesh: idMesh };
            else
                serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
            if (this.skeleton)
                serialization.skeleton = this.skeleton.name;
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            let mesh;
            if (_serialization.idMesh)
                mesh = await FudgeCore.Project.getResource(_serialization.idMesh);
            else
                mesh = await FudgeCore.Serializer.deserialize(_serialization.mesh);
            this.mesh = mesh;
            if (_serialization.skeleton)
                this.addEventListener("componentAdd" /* COMPONENT_ADD */, (_event) => {
                    if (_event.target != this)
                        return;
                    this.node.addEventListener("childAppend" /* CHILD_APPEND */, (_event) => {
                        if (_event.target instanceof FudgeCore.SkeletonInstance && _event.target.name == _serialization.skeleton)
                            this.#skeleton = _event.target;
                    });
                });
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutatorForUserInterface() {
            let mutator = this.getMutator();
            // if (!this.mesh)
            //   mutator.mesh = Mesh;
            return mutator;
        }
    }
    ComponentMesh.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh);
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let PICK;
    (function (PICK) {
        PICK["RADIUS"] = "radius";
        PICK["CAMERA"] = "camera";
        PICK["PHYSICS"] = "physics";
    })(PICK = FudgeCore.PICK || (FudgeCore.PICK = {}));
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentPick extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pick = PICK.RADIUS;
        }
        pickAndDispatch(_ray, _event) {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let position = cmpMesh ? cmpMesh.mtxWorld.translation : this.node.mtxWorld.translation;
            switch (this.pick) {
                case PICK.RADIUS:
                    // TODO: should only be node.radius. Adjustment needed, if mesh was transformed...
                    if (_ray.getDistance(position).magnitude < this.node.radius) {
                        this.node.dispatchEvent(_event);
                    }
                    break;
                case PICK.PHYSICS:
                    let hitInfo = FudgeCore.Physics.raycast(_ray.origin, _ray.direction, FudgeCore.Vector3.DIFFERENCE(position, _ray.origin).magnitudeSquared);
                    if (hitInfo.hit)
                        this.node.dispatchEvent(_event);
                    break;
            }
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.pick)
                types.pick = PICK;
            return types;
        }
    }
    ComponentPick.iSubclass = FudgeCore.Component.registerSubclass(ComponentPick);
    FudgeCore.ComponentPick = ComponentPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Component
     */
    class ComponentScript extends FudgeCore.Component {
        constructor() {
            super();
            this.singleton = false;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
    // TODO: rethink & refactor
    ComponentScript.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript);
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let BASE;
    (function (BASE) {
        BASE[BASE["SELF"] = 0] = "SELF";
        BASE[BASE["PARENT"] = 1] = "PARENT";
        BASE[BASE["WORLD"] = 2] = "WORLD";
        BASE[BASE["NODE"] = 3] = "NODE";
    })(BASE = FudgeCore.BASE || (FudgeCore.BASE = {}));
    /**
     * Attaches a transform-[[Matrix4x4} to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentTransform extends FudgeCore.Component {
        constructor(_mtxInit = FudgeCore.Matrix4x4.IDENTITY()) {
            super();
            this.mtxLocal = _mtxInit;
        }
        //#region Transformations respecting the hierarchy
        /**
         * Adjusts the rotation to point the z-axis directly at the given target point in world space and tilts it to accord with the given up vector,
         * respectively calculating yaw and pitch. If no up vector is given, the previous up-vector is used.
         */
        lookAt(_targetWorld, _up) {
            let container = this.node;
            if (!container && !container.getParent())
                return this.mtxLocal.lookAt(_targetWorld, _up);
            // component is attached to a child node -> transform respecting the hierarchy
            let mtxWorld = container.mtxWorld.clone;
            mtxWorld.lookAt(_targetWorld, _up, true);
            let mtxLocal = FudgeCore.Matrix4x4.RELATIVE(mtxWorld, null, container.getParent().mtxWorldInverse);
            this.mtxLocal = mtxLocal;
        }
        /**
         * Adjusts the rotation to match its y-axis with the given up-vector and facing its z-axis toward the given target at minimal angle,
         * respectively calculating yaw only. If no up vector is given, the previous up-vector is used.
         */
        showTo(_targetWorld, _up) {
            let container = this.node;
            if (!container && !container.getParent())
                return this.mtxLocal.showTo(_targetWorld, _up);
            // component is attached to a child node -> transform respecting the hierarchy
            let mtxWorld = container.mtxWorld.clone;
            mtxWorld.showTo(_targetWorld, _up, true);
            let mtxLocal = FudgeCore.Matrix4x4.RELATIVE(mtxWorld, null, container.getParent().mtxWorldInverse);
            this.mtxLocal = mtxLocal;
        }
        /**
         * recalculates this local matrix to yield the identical world matrix based on the given node.
         * Use rebase before appending the container of this component to another node while preserving its transformation in the world.
         */
        rebase(_node = null) {
            let mtxResult = this.mtxLocal;
            let container = this.node;
            if (container)
                mtxResult = container.mtxWorld;
            if (_node)
                mtxResult = FudgeCore.Matrix4x4.RELATIVE(mtxResult, null, _node.mtxWorldInverse);
            this.mtxLocal = mtxResult;
        }
        /**
         * Applies the given transformation relative to the selected base (SELF, PARENT, WORLD) or a particular other node (NODE)
         */
        transform(_mtxTransform, _base = BASE.SELF, _node = null) {
            switch (_base) {
                case BASE.SELF:
                    this.mtxLocal.multiply(_mtxTransform);
                    break;
                case BASE.PARENT:
                    this.mtxLocal.multiply(_mtxTransform, true);
                    break;
                case BASE.NODE:
                    if (!_node)
                        throw new Error("BASE.NODE requires a node given as base");
                case BASE.WORLD:
                    this.rebase(_node);
                    this.mtxLocal.multiply(_mtxTransform, true);
                    let node = this.node;
                    if (node) {
                        let mtxTemp;
                        if (_base == BASE.NODE) {
                            // fix mtxWorld of container for subsequent rebasing 
                            mtxTemp = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, node.mtxLocal);
                            node.mtxWorld.set(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                        let parent = node.getParent();
                        if (parent) {
                            // fix mtxLocal for current parent
                            this.rebase(node.getParent());
                            mtxTemp = FudgeCore.Matrix4x4.MULTIPLICATION(node.getParent().mtxWorld, node.mtxLocal);
                            node.mtxWorld.set(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                    }
                    break;
            }
        }
        //#endregion
        //#region Transfer
        serialize() {
            let serialization = {
                local: this.mtxLocal.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxLocal.deserialize(_serialization.local);
            return this;
        }
        // public mutate(_mutator: Mutator): void {
        //     this.local.mutate(_mutator);
        // }
        // public getMutator(): Mutator { 
        //     return this.local.getMutator();
        // }
        // public getMutatorAttributeTypes(_mutator: Mutator): MutatorAttributeTypes {
        //     let types: MutatorAttributeTypes = this.local.getMutatorAttributeTypes(_mutator);
        //     return types;
        // }
        reduceMutator(_mutator) {
            delete _mutator.world;
            super.reduceMutator(_mutator);
        }
    }
    ComponentTransform.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform);
    FudgeCore.ComponentTransform = ComponentTransform;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Processes input signals of type number and generates an output signal of the same type using
     * proportional, integral or differential mapping, an amplification factor and a linear dampening/delay
     * ```plaintext
     *          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *          ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      pass through (Proportional)      ‚îÇ
     *  Input ‚Üí ‚îÇ ‚Üí ‚îÇamplify‚îÇ ‚Üí ‚îÇdelay‚îÇ ‚Üí ‚öü sum up over time (Integral) ‚öû ‚Üí ‚îÇ ‚Üí Output
     *          ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      pass change  (Differential)      ‚îÇ
     *          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Control extends EventTarget {
        constructor(_name, _factor = 1, _type = 0 /* PROPORTIONAL */, _active = true) {
            super();
            this.rateDispatchOutput = 0;
            this.valuePrevious = 0;
            this.outputBase = 0;
            this.outputTarget = 0;
            this.outputPrevious = 0;
            this.outputTargetPrevious = 0;
            this.factor = 0;
            this.time = FudgeCore.Time.game;
            this.timeValueDelay = 0;
            this.timeOutputTargetSet = 0;
            this.idTimer = undefined;
            this.dispatchOutput = (_eventOrValue) => {
                if (!this.active)
                    return;
                let timer = this.time.getTimer(this.idTimer);
                let output;
                if (typeof (_eventOrValue) == "number")
                    output = _eventOrValue;
                else
                    output = this.calculateOutput();
                let outputChanged = (output != this.outputPrevious);
                if (timer) {
                    timer.active = outputChanged;
                    if (!outputChanged)
                        return;
                }
                this.outputPrevious = output;
                let event = new CustomEvent("output" /* OUTPUT */, {
                    detail: {
                        output: output
                    }
                });
                this.dispatchEvent(event);
            };
            this.factor = _factor;
            this.type = _type;
            this.active = _active;
            this.name = _name;
        }
        /**
         * Set the time-object to be used when calculating the output in {@link CONTROL_TYPE.INTEGRAL}
         */
        setTimebase(_time) {
            this.time = _time;
            this.calculateOutput();
        }
        /**
         * Feed an input value into this control and fire the events {@link EVENT_CONTROL.INPUT} and {@link EVENT_CONTROL.OUTPUT}
         */
        setInput(_input) {
            if (!this.active)
                return;
            this.outputBase = this.calculateOutput();
            this.valuePrevious = this.getValueDelayed();
            this.outputTarget = this.factor * _input;
            this.timeOutputTargetSet = this.time.get();
            if (this.type == 2 /* DIFFERENTIAL */) {
                this.valuePrevious = this.outputTarget - this.outputTargetPrevious;
                this.outputTargetPrevious = this.outputTarget;
                this.outputTarget = 0;
            }
            this.dispatchEvent(new Event("input" /* INPUT */));
            if (this.type == 2 /* DIFFERENTIAL */)
                this.dispatchOutput(this.valuePrevious);
            else
                this.dispatchOutput(null);
        }
        pulse(_input) {
            this.setInput(_input);
            this.setInput(0);
        }
        /**
         * Set the time to take for the internal linear dampening until the final ouput value is reached
         */
        setDelay(_time) {
            this.timeValueDelay = Math.max(0, _time);
        }
        /**
         * Set the number of output-events to dispatch per second.
         * At the default of 0, the control output must be polled and will only actively dispatched once each time input occurs and the output changes.
         */
        setRateDispatchOutput(_rateDispatchOutput = 0) {
            this.rateDispatchOutput = _rateDispatchOutput;
            this.time.deleteTimer(this.idTimer);
            this.idTimer = undefined;
            if (this.rateDispatchOutput)
                this.idTimer = this.time.setTimer(1000 / this.rateDispatchOutput, 0, this.dispatchOutput);
        }
        /**
         * Set the factor to multiply the input value given with {@link setInput} with
         */
        setFactor(_factor) {
            this.factor = _factor;
        }
        /**
         * Get the value from the output of this control
         */
        getOutput() {
            return this.calculateOutput();
        }
        /**
         * Calculates the output of this control
         */
        calculateOutput() {
            let output = 0;
            let value = this.getValueDelayed();
            switch (this.type) {
                case 1 /* INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeOutputTargetSet;
                    output = this.outputBase;
                    if (this.timeValueDelay > 0) {
                        if (timeElapsedSinceInput < this.timeValueDelay) {
                            output += 0.5 * (this.valuePrevious + value) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            output += 0.5 * (this.valuePrevious + value) * this.timeValueDelay;
                            timeElapsedSinceInput -= this.timeValueDelay;
                        }
                    }
                    output += value * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* DIFFERENTIAL */:
                case 0 /* PROPORTIONAL */:
                default:
                    output = value;
                    break;
            }
            return output;
        }
        /**
         * calculates the output considering the time of the delay
         */
        getValueDelayed() {
            if (this.timeValueDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeOutputTargetSet;
                if (timeElapsedSinceInput < this.timeValueDelay)
                    return this.valuePrevious + (this.outputTarget - this.valuePrevious) * timeElapsedSinceInput / this.timeValueDelay;
            }
            return this.outputTarget;
        }
    }
    FudgeCore.Control = Control;
})(FudgeCore || (FudgeCore = {}));
///<reference path="Control.ts"/>
var FudgeCore;
///<reference path="Control.ts"/>
(function (FudgeCore) {
    /**
     * Handles multiple controls as inputs and creates an output from that.
     * As a subclass of {@link Control}, axis calculates the ouput summing up the inputs and processing the result using its own settings.
     * Dispatches {@link EVENT_CONTROL.OUTPUT} and {@link EVENT_CONTROL.INPUT} when one of the controls dispatches them.
     * ```plaintext
     *           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ\                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò \                               ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  \‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ---‚îÇsum‚îÇ ‚Üí ‚îÇinternal control ‚îÇ ‚Üí ‚îÇ ‚Üí Output
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  /‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê /                               ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ/                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
     *           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Axis extends FudgeCore.Control {
        constructor() {
            super(...arguments);
            this.controls = new Map();
            this.sumPrevious = 0;
            this.hndOutputEvent = (_event) => {
                if (!this.active)
                    return;
                let control = _event.target;
                let event = new CustomEvent("output" /* OUTPUT */, { detail: {
                        control: control,
                        input: _event.detail.output,
                        output: this.getOutput()
                    } });
                this.dispatchEvent(event);
            };
            this.hndInputEvent = (_event) => {
                if (!this.active)
                    return;
                let event = new Event("input" /* INPUT */, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Add the control given to the list of controls feeding into this axis
         */
        addControl(_control) {
            this.controls.set(_control.name, _control);
            _control.addEventListener("input" /* INPUT */, this.hndInputEvent);
            _control.addEventListener("output" /* OUTPUT */, this.hndOutputEvent);
        }
        /**
         * Returns the control with the given name
         */
        getControl(_name) {
            return this.controls.get(_name);
        }
        /**
         * Removes the control with the given name
         */
        removeControl(_name) {
            let control = this.getControl(_name);
            if (control) {
                control.removeEventListener("input" /* INPUT */, this.hndInputEvent);
                control.removeEventListener("output" /* OUTPUT */, this.hndOutputEvent);
                this.controls.delete(_name);
            }
        }
        /**
         * Returns the value of this axis after summing up all inputs and processing the sum according to the axis' settings
         */
        getOutput() {
            let sumInput = 0;
            for (let control of this.controls) {
                if (control[1].active)
                    sumInput += control[1].getOutput();
            }
            if (sumInput != this.sumPrevious)
                super.setInput(sumInput);
            this.sumPrevious = sumInput;
            return super.getOutput();
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Collects the keys pressed on the keyboard and stores their status.
     */
    class Keyboard {
        // private static code_en: Object;
        /**
         * Returns true if one of the given keys is is currently being pressed.
         */
        static isPressedOne(_keys) {
            for (let code of _keys) {
                if (Keyboard.keysPressed[code])
                    return true;
            }
            return false;
        }
        /**
         * Returns true if all of the given keys are currently being pressed
         */
        static isPressedCombo(_keys) {
            for (let code of _keys) {
                if (!Keyboard.keysPressed[code])
                    return false;
            }
            return true;
        }
        /**
         * Returns the value given as _active if one or, when _combo is true, all of the given keys are pressed.
         * Returns the value given as _inactive if not.
         */
        static mapToValue(_active, _inactive, _keys, _combo = false) {
            if (!_combo && Keyboard.isPressedOne(_keys))
                return _active;
            if (Keyboard.isPressedCombo(_keys))
                return _active;
            return _inactive;
        }
        /**
         * Returns a balanced ternary value (either -1, 0 or 1)
         * according to the match of the keys currently being pressed and the lists of keys given
         */
        static mapToTrit(_positive, _negative) {
            return Keyboard.mapToValue(-1, 0, _negative) + Keyboard.mapToValue(1, 0, _positive);
        }
        // public static locale(_keyboard: Object): void {
        //   if (!Keyboard.code_en) {
        //     // save original keyboard codes to be able to switch back later
        //     Keyboard.code_en = {};
        //     Object.assign(Keyboard.code_en, KEYBOARD_CODE);
        //   }
        //   for (let key in _keyboard) {
        //     let value: string = Reflect.get(_keyboard, key);
        //     for (let original in KEYBOARD_CODE)
        //       if (Reflect.get(KEYBOARD_CODE, original) == value)
        //         // remove original key the yields the value
        //         Reflect.deleteProperty(KEYBOARD_CODE, original);
        //     // add new key to yield that value
        //     Reflect.set(KEYBOARD_CODE, key, value);
        //   }
        // }
        static initialize() {
            let store = {};
            document.addEventListener("keydown", Keyboard.hndKeyInteraction);
            document.addEventListener("keyup", Keyboard.hndKeyInteraction);
            return store;
        }
        static hndKeyInteraction(_event) {
            Keyboard.keysPressed[_event.code] = (_event.type == "keydown");
        }
    }
    Keyboard.keysPressed = Keyboard.initialize();
    FudgeCore.Keyboard = Keyboard;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    class DebugAlert extends FudgeCore.DebugTarget {
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                let args = _args.map(_arg => _arg.toString());
                let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                alert(out);
            };
            return delegate;
        }
    }
    DebugAlert.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
        [FudgeCore.DEBUG_FILTER.SOURCE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
    };
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    class DebugTextArea extends FudgeCore.DebugTarget {
        static clear() {
            DebugTextArea.textArea.textContent = "";
            DebugTextArea.groups = [];
        }
        static group(_name) {
            DebugTextArea.print("‚ñº " + _name);
            DebugTextArea.groups.push(_name);
        }
        static groupEnd() {
            DebugTextArea.groups.pop();
        }
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
            };
            return delegate;
        }
        static getIndentation(_level) {
            let result = "";
            for (let i = 0; i < _level; i++)
                result += "| ";
            return result;
        }
        static print(_text) {
            DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
            if (DebugTextArea.autoScroll)
                DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
        }
    }
    DebugTextArea.textArea = document.createElement("textarea");
    DebugTextArea.autoScroll = true;
    DebugTextArea.delegates = {
        [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
        [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
        [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
        [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
        [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
        [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
        [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
        [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd,
        [FudgeCore.DEBUG_FILTER.SOURCE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
    };
    DebugTextArea.groups = [];
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * a subclass of DragEvent .A event that represents a drag and drop interaction
     */
    class EventDragDrop extends DragEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventDragDrop = EventDragDrop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * a subclass of KeyboardEvent. EventKeyboard objects describe a user interaction with the keyboard
     * each event describes a single interaction between the user and a key (or combination of a key with modifier keys) on the keyboard.
     */
    class EventKeyboard extends KeyboardEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventKeyboard = EventKeyboard;
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    let KEYBOARD_CODE_DE;
    (function (KEYBOARD_CODE_DE) {
        KEYBOARD_CODE_DE["Z"] = "KeyY";
        KEYBOARD_CODE_DE["Y"] = "KeyZ";
        KEYBOARD_CODE_DE["\u00D6"] = "Semicolon";
        KEYBOARD_CODE_DE["\u00C4"] = "Quote";
        KEYBOARD_CODE_DE["\u00DC"] = "BracketLeft";
        KEYBOARD_CODE_DE["HASH"] = "Backslash";
        KEYBOARD_CODE_DE["PLUS"] = "BracketRight";
        KEYBOARD_CODE_DE["\u00DF"] = "Minus";
        KEYBOARD_CODE_DE["ACUTE"] = "Equal";
        KEYBOARD_CODE_DE["LESS_THAN"] = "IntlBackSlash";
        KEYBOARD_CODE_DE["MINUS"] = "Slash";
    })(KEYBOARD_CODE_DE = FudgeCore.KEYBOARD_CODE_DE || (FudgeCore.KEYBOARD_CODE_DE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * a subclass of PointerEvent. The state of a DOM event produced by a pointer such as the geometry of the contact point
     * */
    class EventPointer extends PointerEvent {
        constructor(type, _event) {
            super(type, _event);
            let target = _event.target;
            this.clientRect = target.getClientRects()[0];
            this.pointerX = _event.clientX - this.clientRect.left;
            this.pointerY = _event.clientY - this.clientRect.top;
        }
    }
    FudgeCore.EventPointer = EventPointer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An event that represents a call from a Timer
     * */
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A supclass of WheelEvent. Events that occur due to the user moving a mouse wheel or similar input device.
     * */
    class EventWheel extends WheelEvent {
        constructor(type, _event) {
            super(type, _event);
        }
    }
    FudgeCore.EventWheel = EventWheel;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by {@link Project} that functions as a template for {@link GraphInstance}s
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class Graph extends FudgeCore.Node {
        constructor() {
            super(...arguments);
            this.idResource = undefined;
            this.type = "Graph";
        }
        serialize() {
            let serialization = super.serialize();
            serialization.idResource = this.idResource;
            serialization.type = this.type;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            FudgeCore.Project.register(this, _serialization.idResource);
            await FudgeCore.Project.resyncGraphInstances(this);
            return this;
        }
    }
    FudgeCore.Graph = Graph;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An instance of a {@link Graph}.
     * This node keeps a reference to its resource an can thus optimize serialization
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Resource
     */
    class GraphInstance extends FudgeCore.Node {
        /**
         * This constructor allone will not create a reconstruction, but only save the id.
         * To create an instance of the graph, call reset on this or set with a graph as parameter.
         * Prefer Project.createGraphInstance(_graph).
         */
        constructor(_graph) {
            super("GraphInstance");
            /** id of the resource that instance was created from */
            // TODO: examine, if this should be a direct reference to the Graph, instead of the id
            this.#idSource = undefined;
            this.#sync = true;
            this.#deserializeFromSource = true;
            /**
             * Source graph mutated, reflect mutation in this instance
             */
            this.hndMutationGraph = async (_event) => {
                if (!this.#sync) {
                    this.#sync = true;
                    return;
                }
                if (this.isFiltered())
                    return;
                this.#sync = false; // do not sync again, since mutation is already a synchronization
                await this.reflectMutation(_event, _event.currentTarget, this);
                this.#sync = true;
            };
            /**
             * This instance mutated, reflect mutation in source graph
             */
            this.hndMutationInstance = async (_event) => {
                if (!this.#sync)
                    return;
                if (this.isFiltered())
                    return;
                await this.reflectMutation(_event, this, this.get());
            };
            this.addEventListener("mutate" /* MUTATE */, this.hndMutationInstance, true);
            if (!_graph)
                return;
            this.#idSource = _graph.idResource;
        }
        /** id of the resource that instance was created from */
        // TODO: examine, if this should be a direct reference to the Graph, instead of the id
        #idSource;
        #sync;
        #deserializeFromSource;
        get idSource() {
            return this.#idSource;
        }
        /**
         * Recreate this node from the {@link Graph} referenced
         */
        async reset() {
            let resource = await FudgeCore.Project.getResource(this.#idSource);
            await this.set(resource);
        }
        //TODO: optimize using the referenced Graph, serialize/deserialize only the differences
        serialize() {
            let filter = this.getComponent(FudgeCore.ComponentGraphFilter);
            let serialization = {};
            if (filter && filter.isActive) // if graph synchronisation is unfiltered, knowing the source is sufficient for serialization
                serialization = super.serialize();
            else
                serialization.deserializeFromSource = true;
            serialization.name = this.name;
            serialization.idSource = this.#idSource;
            return serialization;
        }
        async deserialize(_serialization) {
            this.#idSource = _serialization.idSource;
            if (!_serialization.deserializeFromSource)
                await super.deserialize(_serialization); // instance is deserialized from individual data
            let graph = this.get();
            if (graph)
                if (_serialization.deserializeFromSource) // no components-> assume synchronized GraphInstance
                    await this.set(graph); // recreate complete instance from source graph
                else {
                    await this.connectToGraph(); // otherwise just connect
                }
            else {
                FudgeCore.Project.registerGraphInstanceForResync(this);
            }
            return this;
        }
        async connectToGraph() {
            let graph = this.get();
            if (this.#deserializeFromSource)
                await this.set(graph);
            // graph.addEventListener(EVENT.MUTATE, (_event: CustomEvent) => this.hndMutation, true);
            graph.addEventListener("mutate" /* MUTATE */, this.hndMutationGraph, true);
        }
        /**
         * Set this node to be a recreation of the {@link Graph} given
         */
        async set(_graph) {
            // TODO: examine, if the serialization should be stored in the Graph for optimization <- also useful for sync with instances
            let serialization = FudgeCore.Serializer.serialize(_graph);
            //Serializer.deserialize(serialization);
            for (let path in serialization) {
                await this.deserialize(serialization[path]);
                break;
            }
            this.#idSource = _graph.idResource;
            this.dispatchEvent(new Event("graphInstantiated" /* GRAPH_INSTANTIATED */));
        }
        /**
         * Retrieve the graph this instances refers to
         */
        get() {
            return FudgeCore.Project.resources[this.#idSource];
        }
        async reflectMutation(_event, _source, _destination) {
            // console.log("Reflect mutation", _source, _destination);
            let path = Reflect.get(_event, "path");
            let index = path.indexOf(_source);
            for (let i = index - 1; i >= 0; i--)
                _destination = _destination.getChildrenByName(path[i].name)[0]; // TODO: respect index for non-singleton components...
            let cmpMutate = _destination.getComponent(_event.detail.component.constructor);
            if (cmpMutate)
                await cmpMutate.mutate(_event.detail.mutator);
        }
        isFiltered() {
            let cmpFilter = this.getComponent(FudgeCore.ComponentGraphFilter);
            return (cmpFilter && cmpFilter.isActive);
        }
    }
    FudgeCore.GraphInstance = GraphInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a {@link Shader} to describe the surface of {@link Mesh}.
     * {@link Material}s reference {@link Coat} and {@link Shader}.
     * The method useRenderData will be injected by {@link RenderInjector} at runtime, extending the functionality of this class to deal with the renderer.
     */
    class Coat extends FudgeCore.Mutable {
        useRenderData(_shader, _cmpMaterial) { }
        //#region Transfer
        serialize() {
            return {};
        }
        async deserialize(_serialization) {
            return this;
        }
        reduceMutator(_mutator) {
            delete _mutator.renderData;
        }
    }
    FudgeCore.Coat = Coat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The simplest {@link Coat} providing just a color
     */
    let CoatColored = class CoatColored extends FudgeCore.Coat {
        constructor(_color = new FudgeCore.Color()) {
            super();
            this.color = _color;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.color = this.color.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.color.deserialize(_serialization.color);
            return this;
        }
    };
    CoatColored = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatColored);
    FudgeCore.CoatColored = CoatColored;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The simplest {@link Coat} providing just a color
     */
    let CoatRemissive = class CoatRemissive extends FudgeCore.CoatColored {
        constructor(_color = new FudgeCore.Color(), _diffuse = 1, _specular = 0) {
            super(_color);
            this.diffuse = _diffuse;
            this.specular = _specular;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.color.deserialize(_serialization.color);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            return this;
        }
    };
    CoatRemissive = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatRemissive);
    FudgeCore.CoatRemissive = CoatRemissive;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatTextured = class CoatTextured extends FudgeCore.CoatColored {
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.texture) {
            super(_color);
            this.texture = null;
            this.texture = _texture;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.idTexture = this.texture.idResource;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            if (_serialization.idTexture)
                this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
            return this;
        }
    };
    CoatTextured = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatTextured);
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
///<reference path="CoatTextured.ts"/>
var FudgeCore;
///<reference path="CoatTextured.ts"/>
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatRemissiveTextured = class CoatRemissiveTextured extends FudgeCore.CoatTextured {
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.texture, _diffuse = 1, _specular = 0) {
            super(_color, _texture);
            this.diffuse = _diffuse;
            this.specular = _specular;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            return this;
        }
    };
    CoatRemissiveTextured = __decorate([
        FudgeCore.RenderInjectorCoat.decorate
    ], CoatRemissiveTextured);
    FudgeCore.CoatRemissiveTextured = CoatRemissiveTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    class Color extends FudgeCore.Mutable {
        constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
            super();
            this.setNormRGBA(_r, _g, _b, _a);
        }
        static getHexFromCSSKeyword(_keyword) {
            Color.crc2.fillStyle = _keyword;
            return Color.crc2.fillStyle;
        }
        static CSS(_keyword, _alpha = 1) {
            let hex = Color.getHexFromCSSKeyword(_keyword);
            let color = new Color(parseInt(hex.substr(1, 2), 16) / 255, parseInt(hex.substr(3, 2), 16) / 255, parseInt(hex.substr(5, 2), 16) / 255, _alpha);
            return color;
        }
        static MULTIPLY(_color1, _color2) {
            return new Color(_color1.r * _color2.r, _color1.g * _color2.g, _color1.b * _color2.b, _color1.a * _color2.a);
        }
        setNormRGBA(_r, _g, _b, _a) {
            this.r = Math.min(1, Math.max(0, _r));
            this.g = Math.min(1, Math.max(0, _g));
            this.b = Math.min(1, Math.max(0, _b));
            this.a = Math.min(1, Math.max(0, _a));
        }
        setBytesRGBA(_r, _g, _b, _a) {
            this.setNormRGBA(_r / 255, _g / 255, _b / 255, _a / 255);
        }
        getArray() {
            return new Float32Array([this.r, this.g, this.b, this.a]);
        }
        setArrayNormRGBA(_color) {
            this.setNormRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        setArrayBytesRGBA(_color) {
            this.setBytesRGBA(_color[0], _color[1], _color[2], _color[3]);
        }
        getArrayBytesRGBA() {
            return new Uint8ClampedArray([this.r * 255, this.g * 255, this.b * 255, this.a * 255]);
        }
        add(_color) {
            this.r += _color.r;
            this.g += _color.g;
            this.b += _color.b;
            this.a += _color.a;
        }
        getCSS() {
            let bytes = this.getArrayBytesRGBA();
            return `RGBA(${bytes[0]}, ${bytes[1]}, ${bytes[2]}, ${bytes[3]})`;
        }
        getHex() {
            let bytes = this.getArrayBytesRGBA();
            let hex = "";
            for (let byte of bytes)
                hex += byte.toString(16).padStart(2, "0");
            return hex;
        }
        setHex(_hex) {
            let bytes = this.getArrayBytesRGBA();
            let channel = 0;
            for (let byte in bytes)
                bytes[byte] = parseInt(_hex.substr(channel++ * 2, 2), 16);
            this.setArrayBytesRGBA(bytes);
        }
        copy(_color) {
            this.r = _color.r;
            this.g = _color.g;
            this.b = _color.b;
            this.a = _color.a;
        }
        toString() {
            return `(r: ${this.r.toFixed(3)}, g: ${this.g.toFixed(3)}, b: ${this.b.toFixed(3)}, a: ${this.a.toFixed(3)})`;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator(true);
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.r}, ${this.g}, ${this.b}, ${this.a}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.r, this.g, this.b, this.a] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        reduceMutator(_mutator) { }
    }
    // crc2 only used for converting colors from strings predefined by CSS
    Color.crc2 = document.createElement("canvas").getContext("2d");
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a {@link Shader} with a compatible {@link Coat}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Material extends FudgeCore.Mutable {
        constructor(_name, _shader, _coat) {
            super();
            this.idResource = undefined;
            this.name = _name;
            this.shaderType = _shader;
            if (_shader) {
                if (_coat)
                    this.coat = _coat;
                else
                    this.coat = this.createCoatMatchingShader();
            }
            FudgeCore.Project.register(this);
        }
        /** The name to call the Material by. */
        #coat;
        /**
         * Returns the currently referenced {@link Coat} instance
         */
        get coat() {
            return this.#coat;
        }
        /**
         * Makes this material reference the given {@link Coat} if it is compatible with the referenced {@link Shader}
         */
        set coat(_coat) {
            if (_coat.constructor != this.shaderType.getCoat())
                if (_coat instanceof this.shaderType.getCoat())
                    FudgeCore.Debug.fudge("Coat is extension of Coat required by shader");
                else
                    throw (new Error("Shader and coat don't match"));
            this.#coat = _coat;
        }
        /**
         * Creates a new {@link Coat} instance that is valid for the {@link Shader} referenced by this material
         */
        createCoatMatchingShader() {
            let coat = new (this.shaderType.getCoat())();
            return coat;
        }
        /**
         * Changes the materials reference to the given {@link Shader}, creates and references a new {@link Coat} instance
         * and mutates the new coat to preserve matching properties.
         * @param _shaderType
         */
        setShader(_shaderType) {
            this.shaderType = _shaderType;
            let coat = this.createCoatMatchingShader();
            coat.mutate(this.#coat.getMutator());
            this.coat = coat;
        }
        /**
         * Returns the {@link Shader} referenced by this material
         */
        getShader() {
            return this.shaderType;
        }
        //#region Transfer
        // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
        serialize() {
            let serialization = {
                name: this.name,
                idResource: this.idResource,
                shader: this.shaderType.name,
                coat: FudgeCore.Serializer.serialize(this.#coat)
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.name = _serialization.name;
            FudgeCore.Project.register(this, _serialization.idResource);
            this.shaderType = FudgeCore[_serialization.shader];
            let coat = await FudgeCore.Serializer.deserialize(_serialization.coat);
            this.coat = coat;
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.coat = this.coat.getMutator();
            return mutator;
        }
        reduceMutator(_mutator) {
            // delete _mutator.idResource;
        }
    }
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle and vice versa
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Framing
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector2 as polar coordinates
     * ```plaintext
     *  ‚Üï- angle (Angle to the x-axis)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo2 {
        constructor(_angle = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.angle = 0;
            this.set(_angle, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_angle = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.angle = _angle;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `angle: ${this.angle.toPrecision(5)},  magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo2 = Geo2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector3 as geographic coordinates as seen on a globe
     * ```plaintext
     * ‚Üê|‚Üí Longitude (Angle to the z-axis)
     *  ‚Üï- Latitude (Angle to the equator)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo3 {
        constructor(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.latitude = 0;
            this.longitude = 0;
            this.set(_longitude, _latitude, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.latitude = _latitude;
            this.longitude = _longitude;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `longitude: ${this.longitude.toPrecision(5)}, latitude: ${this.latitude.toPrecision(5)}, magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo3 = Geo3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // From http://baagoe.com/en/RandomMusings/javascript/
    // Johannes Baag√∏e <baagoe@baagoe.com>, 2010
    function Mash() {
        let n = 0xefc8249d;
        let mash = function (data) {
            data = data.toString();
            for (let i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                let h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        // mash.version = 'Mash 0.9';
        return mash;
    }
    FudgeCore.Mash = Mash;
    // From http://baagoe.com/en/RandomMusings/javascript/
    function LFIB4() {
        // George Marsaglia's LFIB4,
        //http://groups.google.com/group/sci.crypt/msg/eb4ddde782b17051
        let args = Array.prototype.slice.call(arguments);
        let k0 = 0, k1 = 58, k2 = 119, k3 = 178;
        let s = [];
        let mash = Mash();
        if (args.length === 0) {
            args = [+new Date()];
        }
        for (let j = 0; j < 256; j++) {
            s[j] = mash(" ");
            s[j] -= mash(" ") * 4.76837158203125e-7; // 2^-21
            if (s[j] < 0) {
                s[j] += 1;
            }
        }
        for (let i = 0; i < args.length; i++) {
            for (let j = 0; j < 256; j++) {
                s[j] -= mash(args[i]);
                s[j] -= mash(args[i]) * 4.76837158203125e-7; // 2^-21
                if (s[j] < 0) {
                    s[j] += 1;
                }
            }
        }
        mash = null;
        let random = function () {
            let x;
            k0 = (k0 + 1) & 255;
            k1 = (k1 + 1) & 255;
            k2 = (k2 + 1) & 255;
            k3 = (k3 + 1) & 255;
            x = s[k0] - s[k1];
            if (x < 0) {
                x += 1;
            }
            x -= s[k2];
            if (x < 0) {
                x += 1;
            }
            x -= s[k3];
            if (x < 0) {
                x += 1;
            }
            return s[k0] = x;
        };
        // random.uint32 = function () {
        //   return random() * 0x100000000 >>> 0; // 2^32
        // };
        // random.fract53 = random;
        // random.version = "LFIB4 0.9";
        // random.args = args;
        return random;
    }
    FudgeCore.LFIB4 = LFIB4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(9); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.recycle();
            this.resetCache();
        }
        //TODO: figure out what this is used for
        static PROJECTION(_width, _height) {
            let mtxResult = new Matrix3x3;
            mtxResult.data.set([
                2 / _width, 0, 0,
                0, -2 / _height, 0,
                -1, 1, 1
            ]);
            return mtxResult;
        }
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            return mtxResult;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector2}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            mtxResult.data.set([
                1, 0, 0,
                0, 1, 0,
                _translate.x, _translate.y, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            let angleInRadians = _angleInDegrees * Matrix3x3.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, sin, 0,
                -sin, cos, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector2}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            mtxResult.data.set([
                _scalar.x, 0, 0,
                0, _scalar.y, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        //#endregion
        static MULTIPLICATION(_mtxLeft, _mtxRight) {
            let a00 = _mtxLeft.data[0 * 3 + 0];
            let a01 = _mtxLeft.data[0 * 3 + 1];
            let a02 = _mtxLeft.data[0 * 3 + 2];
            let a10 = _mtxLeft.data[1 * 3 + 0];
            let a11 = _mtxLeft.data[1 * 3 + 1];
            let a12 = _mtxLeft.data[1 * 3 + 2];
            let a20 = _mtxLeft.data[2 * 3 + 0];
            let a21 = _mtxLeft.data[2 * 3 + 1];
            let a22 = _mtxLeft.data[2 * 3 + 2];
            let b00 = _mtxRight.data[0 * 3 + 0];
            let b01 = _mtxRight.data[0 * 3 + 1];
            let b02 = _mtxRight.data[0 * 3 + 2];
            let b10 = _mtxRight.data[1 * 3 + 0];
            let b11 = _mtxRight.data[1 * 3 + 1];
            let b12 = _mtxRight.data[1 * 3 + 2];
            let b20 = _mtxRight.data[2 * 3 + 0];
            let b21 = _mtxRight.data[2 * 3 + 1];
            let b22 = _mtxRight.data[2 * 3 + 2];
            let mtxResult = new Matrix3x3;
            mtxResult.data.set([
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22
            ]);
            return mtxResult;
        }
        /**
         * - get: return a vector representation of the translation {@link Vector2}.
         * **Caution!** Use immediately, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector2(this.data[6], this.data[7]);
            return this.vectors.translation; // .clone;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 6);
            // no full cache reset required
            this.vectors.translation = _translation;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation {@link Vector2}
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngle();
            return this.vectors.rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: return a vector representation of the scale {@link Vector3}.
         * **Caution!** Do not manipulate result, instead create a clone!
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector2(Math.hypot(this.data[0], this.data[1]), Math.hypot(this.data[3], this.data[4]));
            return this.vectors.scaling; // .clone;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        /**
         * Return a copy of this
         */
        get clone() {
            let mtxClone = FudgeCore.Recycler.get(Matrix3x3);
            mtxClone.set(this);
            return mtxClone;
        }
        recycle() {
            this.data = new Float32Array([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
            this.resetCache();
        }
        //#region Translation
        /**
         * Add a translation by the given {@link Vector2} to this matrix
         */
        translate(_by) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a translation along the x-Axis by the given amount to this matrix
         */
        translateX(_x) {
            this.data[6] += _x;
            this.mutator = null;
            this.vectors.translation = null;
        }
        /**
         * Add a translation along the y-Axis by the given amount to this matrix
         */
        translateY(_y) {
            this.data[7] += _y;
            this.mutator = null;
            this.vectors.translation = null;
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given {@link Vector2} to this matrix
         */
        scale(_by) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.SCALING(_by));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a scaling along the x-Axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(_by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the y-Axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotate(_angleInDegrees) {
            const mtxResult = Matrix3x3.MULTIPLICATION(this, Matrix3x3.ROTATION(_angleInDegrees));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_mtxRight) {
            let mtxResult = Matrix3x3.MULTIPLICATION(this, _mtxRight);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
            this.mutator = null;
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngle() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s3 = this.data[3] / scaling.y;
            let s4 = this.data[4] / scaling.y;
            let xSkew = Math.atan2(-s3, s4);
            let ySkew = Math.atan2(s0, s1);
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let rotation;
            if (!(sy > 1e-6))
                rotation = ySkew;
            else
                rotation = xSkew;
            rotation *= 180 / Math.PI;
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_mtxTo) {
            // this.data = _to.get();
            this.data.set(_mtxTo.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation,
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: _serialization.rotation,
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector2(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y);
            }
            vectors.rotation = (newRotation == undefined) ? oldRotation : newRotation;
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector2(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let mtxResult = Matrix3x3.IDENTITY();
            if (vectors.translation)
                mtxResult.translate(vectors.translation);
            if (vectors.rotation) {
                mtxResult.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                mtxResult.scale(vectors.scaling);
            this.set(mtxResult);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation != undefined)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    Matrix3x3.deg2rad = Math.PI / 180;
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```plaintext
     * [ 0, 1, 2, 3 ] ‚Üê row vector x
     * [ 4, 5, 6, 7 ] ‚Üê row vector y
     * [ 8, 9,10,11 ] ‚Üê row vector z
     * [12,13,14,15 ] ‚Üê translation
     *            ‚Üë  homogeneous column
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.#eulerAngles = FudgeCore.Vector3.ZERO();
            this.#vectors = { translation: FudgeCore.Vector3.ZERO(), rotation: FudgeCore.Vector3.ZERO(), scaling: FudgeCore.Vector3.ZERO() };
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.recycle();
            this.resetCache();
        }
        #eulerAngles;
        #vectors;
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            return mtxResult;
        }
        /**
         * Constructs a new matrix according to the translation, rotation and scaling {@link Vector3}s given
         */
        static CONSTRUCTION(_vectors) {
            let result = Matrix4x4.IDENTITY();
            result.mutate(_vectors);
            return result;
        }
        /**
         * Computes and returns the product of two passed matrices.
         * @param _mtxLeft The matrix to multiply.
         * @param _mtxRight The matrix to multiply by.
         */
        static MULTIPLICATION(_mtxLeft, _mtxRight) {
            let a = _mtxLeft.data;
            let b = _mtxRight.data;
            // let matrix: Matrix4x4 = new Matrix4x4();
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let a00 = a[0 * 4 + 0];
            let a01 = a[0 * 4 + 1];
            let a02 = a[0 * 4 + 2];
            let a03 = a[0 * 4 + 3];
            let a10 = a[1 * 4 + 0];
            let a11 = a[1 * 4 + 1];
            let a12 = a[1 * 4 + 2];
            let a13 = a[1 * 4 + 3];
            let a20 = a[2 * 4 + 0];
            let a21 = a[2 * 4 + 1];
            let a22 = a[2 * 4 + 2];
            let a23 = a[2 * 4 + 3];
            let a30 = a[3 * 4 + 0];
            let a31 = a[3 * 4 + 1];
            let a32 = a[3 * 4 + 2];
            let a33 = a[3 * 4 + 3];
            let b00 = b[0 * 4 + 0];
            let b01 = b[0 * 4 + 1];
            let b02 = b[0 * 4 + 2];
            let b03 = b[0 * 4 + 3];
            let b10 = b[1 * 4 + 0];
            let b11 = b[1 * 4 + 1];
            let b12 = b[1 * 4 + 2];
            let b13 = b[1 * 4 + 3];
            let b20 = b[2 * 4 + 0];
            let b21 = b[2 * 4 + 1];
            let b22 = b[2 * 4 + 2];
            let b23 = b[2 * 4 + 3];
            let b30 = b[3 * 4 + 0];
            let b31 = b[3 * 4 + 1];
            let b32 = b[3 * 4 + 2];
            let b33 = b[3 * 4 + 3];
            mtxResult.data.set([
                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns the transpose of a passed matrix.
         */
        static TRANSPOSE(_mtx) {
            let m = _mtx.data;
            let result = FudgeCore.Recycler.get(Matrix4x4);
            result.data.set([
                m[0], m[4], m[8], m[12],
                m[1], m[5], m[9], m[13],
                m[2], m[6], m[10], m[14],
                m[3], m[7], m[11], m[15]
            ]);
            return result;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtx The matrix to compute the inverse of.
         */
        static INVERSION(_mtx) {
            let m = _mtx.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly at the given target,
         * and a minimal angle between its y-axis and the given up-{@link Vector3}, respetively calculating yaw and pitch.
         */
        static LOOK_AT(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            let yAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            mtxResult.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its y-axis matching the given up-{@link Vector3}
         * and its z-axis facing towards the given target at a minimal angle, respetively calculating yaw only.
         */
        static SHOW_TO(_translation, _target, _up = FudgeCore.Vector3.Y()) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            // let yAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(zAxis, xAxis));
            zAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(xAxis, _up));
            mtxResult.data.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                _up.x, _up.y, _up.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector3}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                _translate.x, _translate.y, _translate.z, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         */
        static ROTATION_X(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Matrix4x4.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         */
        static ROTATION_Y(_angleInDegrees) {
            let mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Matrix4x4.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         */
        static ROTATION_Z(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let angleInRadians = _angleInDegrees * Matrix4x4.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.data.set([
                cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates when multiplied by, using the angles given.
         * Rotation occurs around the axis in the order Z-Y-X .
         */
        static ROTATION(_eulerAnglesInDegrees) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            let anglesInRadians = FudgeCore.Vector3.SCALE(_eulerAnglesInDegrees, Matrix4x4.deg2rad);
            let sinX = Math.sin(anglesInRadians.x);
            let cosX = Math.cos(anglesInRadians.x);
            let sinY = Math.sin(anglesInRadians.y);
            let cosY = Math.cos(anglesInRadians.y);
            let sinZ = Math.sin(anglesInRadians.z);
            let cosZ = Math.cos(anglesInRadians.z);
            mtxResult.data.set([
                /**/ cosZ * cosY, /**/ sinZ * cosY, /**/ -sinY, 0,
                cosZ * sinY * sinX - sinZ * cosX, sinZ * sinY * sinX + cosZ * cosX, /**/ cosY * sinX, 0,
                cosZ * sinY * cosX + sinZ * sinX, sinZ * sinY * cosX - cosZ * sinX, /**/ cosY * cosX, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector3}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                _scalar.x, 0, 0, 0,
                0, _scalar.y, 0, 0,
                0, 0, _scalar.z, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a representation of the given matrix relative to the given base.
         * If known, pass the inverse of the base to avoid unneccesary calculation
         */
        static RELATIVE(_mtx, _mtxBase, _mtxInverse) {
            if (_mtxInverse)
                return Matrix4x4.MULTIPLICATION(_mtxInverse, _mtx);
            let mtxInverse = Matrix4x4.INVERSION(_mtxBase);
            let mtxResult = Matrix4x4.MULTIPLICATION(mtxInverse, _mtx);
            FudgeCore.Recycler.store(mtxInverse);
            return mtxResult;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * Matrix4x4.deg2rad;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                f, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (_near + _far) * rangeInv, -1,
                0, 0, _near * _far * rangeInv * 2, 0
            ]);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                mtxResult.data[0] = f / _aspect;
                mtxResult.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                mtxResult.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                mtxResult.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            mtxResult.rotateY(180);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            mtxResult.data.set([
                2 / (_right - _left), 0, 0, 0,
                0, 2 / (_top - _bottom), 0, 0,
                0, 0, 2 / (_near - _far), 0,
                (_left + _right) / (_left - _right),
                (_bottom + _top) / (_bottom - _top),
                (_near + _far) / (_near - _far),
                1
            ]);
            return mtxResult;
        }
        //#endregion
        //#region  Accessors
        /**
         * - get: return a vector representation of the translation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        set translation(_translation) {
            this.data.set(_translation.get(), 12);
            // no full cache reset required
            if (this.vectors.translation)
                this.vectors.translation.set(_translation.x, _translation.y, _translation.z);
            else
                this.vectors.translation = _translation.clone;
            this.mutator = null;
        }
        get translation() {
            if (!this.vectors.translation) {
                this.vectors.translation = this.#vectors.translation;
                this.vectors.translation.set(this.data[12], this.data[13], this.data[14]);
            }
            return this.vectors.translation; // .clone;
        }
        /**
         * - get: return a vector representation of the rotation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngles().clone;
            return this.vectors.rotation; //.clone;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: return a vector representation of the scaling {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling) {
                this.vectors.scaling = this.#vectors.scaling;
                this.vectors.scaling.set(Math.hypot(this.data[0], this.data[1], this.data[2]), Math.hypot(this.data[4], this.data[5], this.data[6]), Math.hypot(this.data[8], this.data[9], this.data[10]));
            }
            return this.vectors.scaling; // .clone;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        /**
         * Return a copy of this
         */
        get clone() {
            let mtxClone = FudgeCore.Recycler.get(Matrix4x4);
            mtxClone.set(this);
            return mtxClone;
        }
        //#endregion
        recycle() {
            this.data.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            this.resetCache();
        }
        //#region Rotation
        /**
         * Rotate this matrix by given {@link Vector3} in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * The rotation is appended to already applied transforms, thus multiplied from the right. Set _fromLeft to true to switch and put it in front.
         */
        rotate(_by, _fromLeft = false) {
            // this.rotateZ(_by.z, _fromLeft);
            // this.rotateY(_by.y, _fromLeft);
            // this.rotateX(_by.x, _fromLeft);
            let mtxRotation = Matrix4x4.ROTATION(_by);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        transpose() {
            let matrix = this.data;
            this.data.set([
                matrix[0], matrix[4], matrix[8], matrix[12],
                matrix[1], matrix[5], matrix[9], matrix[13],
                matrix[2], matrix[6], matrix[10], matrix[14],
                matrix[3], matrix[7], matrix[11], matrix[15]
            ]);
            return this;
        }
        inverse() {
            let m = this.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            // let matrix: Matrix4x4 = new Matrix4x4;
            const matrix = FudgeCore.Recycler.get(Matrix4x4);
            matrix.data.set([
                d * t0,
                d * t1,
                d * t2,
                d * t3,
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)),
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)),
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)),
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)),
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)),
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)),
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)),
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)),
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)),
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)),
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)),
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return matrix;
        }
        /**
         * Adds a rotation around the x-axis to this matrix
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adds a rotation around the y-axis to this matrix
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adds a rotation around the z-axis to this matrix
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
        }
        /**
         * Adjusts the rotation of this matrix to point the z-axis directly at the given target and tilts it to accord with the given up-{@link Vector3},
         * respectively calculating yaw and pitch. If no up-{@link Vector3} is given, the previous up-{@link Vector3} is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        lookAt(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const mtxResult = Matrix4x4.LOOK_AT(this.translation, _target, _up);
            if (_preserveScaling)
                mtxResult.scale(this.scaling);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Same as {@link Matrix4x4.lookAt}, but optimized and needs testing
         */
        // TODO: testing lookat that really just rotates the matrix rather than creating a new one
        lookAtRotate(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            let scaling = this.scaling;
            let difference = FudgeCore.Vector3.DIFFERENCE(_target, this.translation);
            difference.normalize();
            let cos = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getZ()), difference);
            let sin = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getX()), difference);
            // console.log(sin, cos);
            let mtxRotation = FudgeCore.Recycler.borrow(Matrix4x4);
            mtxRotation.data.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            this.multiply(mtxRotation, false);
            cos = FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getZ()), difference);
            sin = -FudgeCore.Vector3.DOT(FudgeCore.Vector3.NORMALIZATION(this.getY()), difference);
            // console.log(sin, cos);
            mtxRotation.data.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            this.multiply(mtxRotation, false);
            this.scaling = scaling;
        }
        /**
         * Adjusts the rotation of this matrix to match its y-axis with the given up-{@link Vector3} and facing its z-axis toward the given target at minimal angle,
         * respectively calculating yaw only. If no up-{@link Vector3} is given, the previous up-{@link Vector3} is used.
         * When _preserveScaling is false, a rotated identity matrix is the result.
         */
        showTo(_target, _up, _preserveScaling = true) {
            if (!_up)
                _up = this.getY();
            const mtxResult = Matrix4x4.SHOW_TO(this.translation, _target, _up);
            if (_preserveScaling)
                mtxResult.scale(this.scaling);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Translation
        /**
         * Add a translation by the given {@link Vector3} to this matrix.
         * If _local is true, translation occurs according to the current rotation and scaling of this matrix,
         * according to the parent otherwise.
         */
        translate(_by, _local = true) {
            if (_local) {
                let mtxTranslation = Matrix4x4.TRANSLATION(_by);
                this.multiply(mtxTranslation);
                FudgeCore.Recycler.store(mtxTranslation);
            }
            else {
                this.data[12] += _by.x;
                this.data[13] += _by.y;
                this.data[14] += _by.z;
                this.mutator = null;
                if (this.vectors.translation)
                    FudgeCore.Recycler.store(this.vectors.translation);
                this.vectors.translation = null;
            }
            // const matrix: Matrix4x4 = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // // TODO: possible optimization, translation may alter mutator instead of deleting it.
            // this.set(matrix);
            // Recycler.store(matrix);
        }
        /**
         * Add a translation along the x-axis by the given amount to this matrix
         */
        translateX(_x, _local = true) {
            let translation = FudgeCore.Vector3.X(_x);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the y-axis by the given amount to this matrix
         */
        translateY(_y, _local = true) {
            let translation = FudgeCore.Vector3.Y(_y);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Add a translation along the z-axis by the given amount to this matrix
         */
        translateZ(_z, _local = true) {
            let translation = FudgeCore.Vector3.Z(_z);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
        }
        //#endregion
        //#region Scaling
        /**
         * Add a scaling by the given {@link Vector3} to this matrix
         */
        scale(_by) {
            const mtxResult = Matrix4x4.MULTIPLICATION(this, Matrix4x4.SCALING(_by));
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        /**
         * Add a scaling along the x-axis by the given amount to this matrix
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(_by, 1, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the y-axis by the given amount to this matrix
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(1, _by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        /**
         * Add a scaling along the z-axis by the given amount to this matrix
         */
        scaleZ(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector3);
            vector.set(1, 1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_matrix, _fromLeft = false) {
            const mtxResult = _fromLeft ? Matrix4x4.MULTIPLICATION(_matrix, this) : Matrix4x4.MULTIPLICATION(this, _matrix);
            this.set(mtxResult);
            FudgeCore.Recycler.store(mtxResult);
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         */
        getEulerAngles() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s2 = this.data[2] / scaling.x;
            let s6 = this.data[6] / scaling.y;
            let s10 = this.data[10] / scaling.z;
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let singular = sy < 1e-6; // If
            let x1, y1, z1;
            let x2, y2, z2;
            if (!singular) {
                x1 = Math.atan2(s6, s10);
                y1 = Math.atan2(-s2, sy);
                z1 = Math.atan2(s1, s0);
                x2 = Math.atan2(-s6, -s10);
                y2 = Math.atan2(-s2, -sy);
                z2 = Math.atan2(-s1, -s0);
                if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                    x1 = x2;
                    y1 = y2;
                    z1 = z2;
                }
            }
            else {
                x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                z1 = 0;
            }
            // let rotation: Vector3 = Recycler.borrow(Vector3);
            this.#eulerAngles.set(x1, y1, z1);
            this.#eulerAngles.scale(180 / Math.PI);
            return this.#eulerAngles;
        }
        /**
         * Sets the elements of this matrix to the values of the given matrix
         */
        set(_mtxTo) {
            if (_mtxTo instanceof Float32Array)
                this.data.set(_mtxTo);
            else
                this.data.set(_mtxTo.data);
            this.resetCache();
        }
        toString() {
            return `∆í.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Return the elements of this matrix as a Float32Array
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Return cardinal x-axis
         */
        getX() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[0], this.data[1], this.data[2]);
            return result;
        }
        /**
         * Return cardinal y-axis
         */
        getY() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[4], this.data[5], this.data[6]);
            return result;
        }
        /**
         * Return cardinal z-axis
         */
        getZ() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[8], this.data[9], this.data[10]);
            return result;
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXY() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[4], this.data[5], this.data[6]], 0); // overwrite x-axis with y-axis
            this.data.set(temp, 4); // overwrite Y with temp
            this.data.set([-this.data[8], -this.data[9], -this.data[10]], 8); // reverse z-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXZ() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 0); // overwrite x-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[4], -this.data[5], -this.data[6]], 4); // reverse y-axis
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapYZ() {
            let temp = [this.data[4], this.data[5], this.data[6]]; // store y-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 4); // overwrite y-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[0], -this.data[1], -this.data[2]], 0); // reverse x-axis
        }
        /**
         * Returns the tranlation from this matrix to the target matrix
         */
        getTranslationTo(_mtxTarget) {
            let difference = FudgeCore.Recycler.get(FudgeCore.Vector3);
            difference.set(_mtxTarget.data[12] - this.data[12], _mtxTarget.data[13] - this.data[13], _mtxTarget.data[14] - this.data[14]);
            return difference;
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation.serialize(),
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: await this.rotation.deserialize(_serialization.rotation),
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = vectors.translation || this.#vectors.translation;
                vectors.translation.set(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y, newTranslation.z != undefined ? newTranslation.z : oldTranslation.z);
            }
            if (newRotation) {
                vectors.rotation = vectors.rotation || this.#vectors.rotation;
                vectors.rotation.set(newRotation.x != undefined ? newRotation.x : oldRotation.x, newRotation.y != undefined ? newRotation.y : oldRotation.y, newRotation.z != undefined ? newRotation.z : oldRotation.z);
            }
            if (newScaling) {
                vectors.scaling = vectors.scaling || this.#vectors.scaling;
                vectors.scaling.set(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y, newScaling.z != undefined ? newScaling.z : oldScaling.z);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let mtxResult = Matrix4x4.IDENTITY();
            if (vectors.translation)
                mtxResult.translate(vectors.translation);
            if (vectors.rotation) {
                // mtxResult.rotateZ(vectors.rotation.z);
                // mtxResult.rotateY(vectors.rotation.y);
                // mtxResult.rotateX(vectors.rotation.x);
                mtxResult.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                mtxResult.scale(vectors.scaling);
            this.set(mtxResult);
            this.vectors = vectors;
            FudgeCore.Recycler.store(mtxResult);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    Matrix4x4.deg2rad = Math.PI / 180;
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
/**
 * Baseclass for Noise2, Noise3 and Noise4
 * @authors Jirka Dell'Oro-Friedl, HFU, 2021
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 */
var FudgeCore;
/**
 * Baseclass for Noise2, Noise3 and Noise4
 * @authors Jirka Dell'Oro-Friedl, HFU, 2021
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 */
(function (FudgeCore) {
    class Noise {
        constructor(_random = Math.random) {
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            const p = new Uint8Array(256);
            for (let i = 0; i < 256; i++)
                p[i] = i;
            let n;
            let q;
            for (let i = 255; i > 0; i--) {
                n = Math.floor((i + 1) * _random());
                q = p[i];
                p[i] = p[n];
                p[n] = q;
            }
            for (let i = 0; i < 512; i++) {
                this.perm[i] = p[i & 255];
                this.permMod12[i] = this.perm[i] % 12;
            }
        }
    }
    FudgeCore.Noise = Noise;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./Noise.ts"/>
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
var FudgeCore;
///<reference path="./Noise.ts"/>
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
(function (FudgeCore) {
    class Noise2 extends FudgeCore.Noise {
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y) => {
                return this.#sample(_x, _y);
            };
            this.#sample = (_x, _y) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const t = (i + j) * Noise2.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y) space
                const Y0 = j - t;
                const x0 = _x - X0; // The x,y distances from the cell origin
                const y0 = _y - Y0;
                // Determine which simplex we are in.
                const i1 = x0 > y0 ? 1 : 0;
                const j1 = x0 > y0 ? 0 : 1;
                // Offset:numbers for corners
                const x1 = x0 - i1 + Noise2.offset;
                const y1 = y0 - j1 + Noise2.offset;
                const x2 = x0 - 1.0 + 2.0 * Noise2.offset;
                const y2 = y0 - 1.0 + 2.0 * Noise2.offset;
                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const g0 = Noise2.gradient[this.permMod12[ii + this.perm[jj]]];
                const g1 = Noise2.gradient[this.permMod12[ii + i1 + this.perm[jj + j1]]];
                const g2 = Noise2.gradient[this.permMod12[ii + 1 + this.perm[jj + 1]]];
                // Calculate the contribution from the three corners
                const t0 = 0.5 - x0 * x0 - y0 * y0;
                const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0);
                const t1 = 0.5 - x1 * x1 - y1 * y1;
                const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1);
                const t2 = 0.5 - x2 * x2 - y2 * y2;
                const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1, 1]
                return 70.14805770653952 * (n0 + n1 + n2);
            };
        }
        #sample;
    }
    Noise2.offset = (3.0 - Math.sqrt(3.0)) / 6.0;
    Noise2.gradient = [[1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [0, 1], [0, -1]];
    FudgeCore.Noise2 = Noise2;
})(FudgeCore || (FudgeCore = {}));
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
var FudgeCore;
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
(function (FudgeCore) {
    // TODO: Test
    class Noise3 extends FudgeCore.Noise {
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z) => {
                return this.#sample(_x, _y, _z);
            };
            this.#sample = (_x, _y, _z) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y + _z) / 3.0; // Very nice and simple skew factor for 3D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const t = (i + j + k) * Noise3.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = _x - X0; // The x,y,z distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                // Deterine which simplex we are in
                let i1, j1, k1 // Offsets for second corner of simplex in (i,j,k) coords
                ;
                let i2, j2, k2 // Offsets for third corner of simplex in (i,j,k) coords
                ;
                if (x0 >= y0) {
                    if (y0 >= z0) {
                        i1 = i2 = j2 = 1;
                        j1 = k1 = k2 = 0;
                    }
                    else if (x0 >= z0) {
                        i1 = i2 = k2 = 1;
                        j1 = k1 = j2 = 0;
                    }
                    else {
                        k1 = i2 = k2 = 1;
                        i1 = j1 = j2 = 0;
                    }
                }
                else {
                    if (y0 < z0) {
                        k1 = j2 = k2 = 1;
                        i1 = j1 = i2 = 0;
                    }
                    else if (x0 < z0) {
                        j1 = j2 = k2 = 1;
                        i1 = k1 = i2 = 0;
                    }
                    else {
                        j1 = i2 = j2 = 1;
                        i1 = k1 = k2 = 0;
                    }
                }
                const x1 = x0 - i1 + Noise3.offset; // Offsets for second corner in (x,y,z) coords
                const y1 = y0 - j1 + Noise3.offset;
                const z1 = z0 - k1 + Noise3.offset;
                const x2 = x0 - i2 + 2.0 * Noise3.offset; // Offsets for third corner in (x,y,z) coords
                const y2 = y0 - j2 + 2.0 * Noise3.offset;
                const z2 = z0 - k2 + 2.0 * Noise3.offset;
                const x3 = x0 - 1.0 + 3.0 * Noise3.offset; // Offsets for last corner in (x,y,z) coords
                const y3 = y0 - 1.0 + 3.0 * Noise3.offset;
                const z3 = z0 - 1.0 + 3.0 * Noise3.offset;
                // Work :numberut the hashed gradient indices of the four simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const g0 = Noise3.gradient[this.permMod12[ii + this.perm[jj + this.perm[kk]]]];
                const g1 = Noise3.gradient[this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]]];
                const g2 = Noise3.gradient[this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]]];
                const g3 = Noise3.gradient[this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]]];
                // Calcu:numberate the contribution from the four corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to stay just inside [-1,1]
                return 94.68493150681972 * (n0 + n1 + n2 + n3);
            };
        }
        #sample;
    }
    Noise3.offset = 1.0 / 6.0;
    Noise3.gradient = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]
    ];
    FudgeCore.Noise3 = Noise3;
})(FudgeCore || (FudgeCore = {}));
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
var FudgeCore;
/**
 * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
 * done by Jirka Dell'Oro-Friedl, HFU, 2021
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 */
(function (FudgeCore) {
    // TODO: Test
    class Noise4 extends FudgeCore.Noise {
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z, _w) => {
                return this.#sample(_x, _y, _z, _w);
            };
            this.#sample = (x, y, z, w) => {
                // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
                const s = (x + y + z + w) * (Math.sqrt(5.0) - 1.0) / 4.0; // Factor for 4D skewing
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const k = Math.floor(z + s);
                const l = Math.floor(w + s);
                const t = (i + j + k + l) * Noise4.offset; // Factor for 4D unskewing
                const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
                const Y0 = j - t;
                const Z0 = k - t;
                const W0 = l - t;
                const x0 = x - X0; // The x,y,z,w distances from the cell origin
                const y0 = y - Y0;
                const z0 = z - Z0;
                const w0 = w - W0;
                // To find out which of the 24 possible simplices we're in, we need to determine the
                // magnitude ordering of x0, y0, z0 and w0. Six pair-wise comparisons are performed between
                // each possible pair of the four coordinates, and the results are used to rank the numbers.
                let rankx = 0;
                let ranky = 0;
                let rankz = 0;
                let rankw = 0;
                if (x0 > y0)
                    rankx++;
                else
                    ranky++;
                if (x0 > z0)
                    rankx++;
                else
                    rankz++;
                if (x0 > w0)
                    rankx++;
                else
                    rankw++;
                if (y0 > z0)
                    ranky++;
                else
                    rankz++;
                if (y0 > w0)
                    ranky++;
                else
                    rankw++;
                if (z0 > w0)
                    rankz++;
                else
                    rankw++;
                // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
                // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
                // impossible. Only the 24 indices which have non-zero entries make any sense.
                // We use a thresholding to set the coordinates in turn from the largest magnitude.
                // Rank 3 denotes the largest coordinate.
                const i1 = rankx >= 3 ? 1 : 0;
                const j1 = ranky >= 3 ? 1 : 0;
                const k1 = rankz >= 3 ? 1 : 0;
                const l1 = rankw >= 3 ? 1 : 0;
                // Rank : 2 denotes the second largest coordinate.
                const i2 = rankx >= 2 ? 1 : 0;
                const j2 = ranky >= 2 ? 1 : 0;
                const k2 = rankz >= 2 ? 1 : 0;
                const l2 = rankw >= 2 ? 1 : 0;
                // Rank : 1 denotes the second smallest coordinate.
                const i3 = rankx >= 1 ? 1 : 0;
                const j3 = ranky >= 1 ? 1 : 0;
                const k3 = rankz >= 1 ? 1 : 0;
                const l3 = rankw >= 1 ? 1 : 0;
                // The fifth corner has all coordinate offsets = 1, so no need to compute that.
                const x1 = x0 - i1 + Noise4.offset; // Offsets for second corner in (x,y,z,w) coords
                const y1 = y0 - j1 + Noise4.offset;
                const z1 = z0 - k1 + Noise4.offset;
                const w1 = w0 - l1 + Noise4.offset;
                const x2 = x0 - i2 + 2.0 * Noise4.offset; // Offsets for third corner in (x,y,z,w) coords
                const y2 = y0 - j2 + 2.0 * Noise4.offset;
                const z2 = z0 - k2 + 2.0 * Noise4.offset;
                const w2 = w0 - l2 + 2.0 * Noise4.offset;
                const x3 = x0 - i3 + 3.0 * Noise4.offset; // Offsets for fourth corner in (x,y,z,w) coords
                const y3 = y0 - j3 + 3.0 * Noise4.offset;
                const z3 = z0 - k3 + 3.0 * Noise4.offset;
                const w3 = w0 - l3 + 3.0 * Noise4.offset;
                const x4 = x0 - 1.0 + 4.0 * Noise4.offset; // Offsets for last corner in (x,y,z,w) coords
                const y4 = y0 - 1.0 + 4.0 * Noise4.offset;
                const z4 = z0 - 1.0 + 4.0 * Noise4.offset;
                const w4 = w0 - 1.0 + 4.0 * Noise4.offset;
                // Work out the hashed gradient indices of the five simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const ll = l & 255;
                const g0 = Noise4.gradient[this.perm[ii + this.perm[jj + this.perm[kk + this.perm[ll]]]] %
                    32];
                const g1 = Noise4.gradient[this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1 + this.perm[ll + l1]]]] % 32];
                const g2 = Noise4.gradient[this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2 + this.perm[ll + l2]]]] % 32];
                const g3 = Noise4.gradient[this.perm[ii + i3 + this.perm[jj + j3 + this.perm[kk + k3 + this.perm[ll + l3]]]] % 32];
                const g4 = Noise4.gradient[this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1 + this.perm[ll + 1]]]] % 32];
                // Calculate the contribution from the five corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0 + g0[3] * w0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1 + g1[3] * w1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2 + g2[3] * w2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3 + g3[3] * w3);
                const t4 = 0.5 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
                const n4 = t4 < 0
                    ? 0.0
                    : Math.pow(t4, 4) * (g4[0] * x4 + g4[1] * y4 + g4[2] * z4 + g4[3] * w4);
                // Sum up and scale the result to cover the range [-1,1]
                return 72.37855765153665 * (n0 + n1 + n2 + n3 + n4);
            };
        }
        #sample;
    }
    Noise4.offset = (5.0 - Math.sqrt(5.0)) / 20.0;
    Noise4.gradient = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];
    FudgeCore.Noise4 = Noise4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Random {
        /**
         * Create an instance of {@link Random}.
         * If a seed is given, LFIB4 is used as generator, reproducing a series of numbers from that seed.
         * If a function producing values between 0 and 1 is given, it will be used as generator.
         */
        constructor(_seedOrFunction) {
            this.generate = Math.random;
            if (_seedOrFunction instanceof Function)
                this.generate = _seedOrFunction;
            else if (_seedOrFunction == undefined)
                this.generate = Math.random;
            else
                //@ts-ignore
                this.generate = new FudgeCore.LFIB4(_seedOrFunction);
        }
        /**
         * Returns a normed random number, thus in the range of [0, 1[
         */
        getNorm() {
            return this.generate();
        }
        /**
         * Returns a random number in the range of given [_min, _max[
         */
        getRange(_min, _max) {
            return _min + this.generate() * (_max - _min);
        }
        /**
         * Returns a random integer number in the range of given floored [_min, _max[
         */
        getRangeFloored(_min, _max) {
            return Math.floor(this.getRange(_min, _max));
        }
        /**
         * Returns true or false randomly
         */
        getBoolean() {
            return this.generate() < 0.5;
        }
        /**
         * Returns -1 or 1 randomly
         */
        getSign() {
            return this.getBoolean() ? 1 : -1;
        }
        /**
         * Returns a randomly selected index into the given array
         */
        getIndex(_array) {
            if (_array.length > 0)
                return this.getRangeFloored(0, _array.length);
            return -1;
        }
        /**
         * Returns a randomly selected element of the given array
         */
        getElement(_array) {
            if (_array.length > 0)
                return _array[this.getIndex(_array)];
            return null;
        }
        /**
         * Removes a randomly selected element from the given array and returns it
         */
        splice(_array) {
            return _array.splice(this.getIndex(_array), 1)[0];
        }
        /**
         * Returns a randomly selected key from the given Map-instance
         */
        getKey(_map) {
            let keys = Array.from(_map.keys());
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected property name from the given object
         */
        getPropertyName(_object) {
            let keys = Object.getOwnPropertyNames(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected symbol from the given object, if symbols are used as keys
         */
        getPropertySymbol(_object) {
            let keys = Object.getOwnPropertySymbols(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a random three-dimensional vector in the limits of the box defined by the vectors given as [_corner0, _corner1[
         */
        getVector3(_corner0, _corner1) {
            return new FudgeCore.Vector3(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y), this.getRange(_corner0.z, _corner1.z));
        }
        /**
         * Returns a random two-dimensional vector in the limits of the rectangle defined by the vectors given as [_corner0, _corner1[
         */
        getVector2(_corner0, _corner1) {
            return new FudgeCore.Vector2(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y));
        }
    }
    Random.default = new Random();
    FudgeCore.Random = Random;
    /**
     * Standard {@link Random}-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```plaintext
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022
     */
    class Vector3 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.data = new Float32Array([_x, _y, _z]);
        }
        //#region Static
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_scale, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(0, _scale, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.data.set([0, 0, _scale]);
            return vector;
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(0, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_scale, _scale, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         */
        static TRANSFORMATION(_vector, _mtxTransform, _includeTranslation = true) {
            let result = FudgeCore.Recycler.get(Vector3);
            let m = _mtxTransform.get();
            let [x, y, z] = _vector.get();
            result.x = m[0] * x + m[4] * y + m[8] * z;
            result.y = m[1] * x + m[5] * y + m[9] * z;
            result.z = m[2] * x + m[6] * y + m[10] * z;
            if (_includeTranslation) {
                result.add(_mtxTransform.translation);
            }
            return result;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let magnitudeSquared = _vector.magnitudeSquared;
            let vector = _vector.clone;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            vector.scale(_length / Math.sqrt(magnitudeSquared));
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector3);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y, result.z + vector.z);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z);
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scaling) {
            let scaled = FudgeCore.Recycler.get(Vector3);
            scaled.set(_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling);
            return scaled;
        }
        /**
         * Computes the crossproduct of 2 vectors.
         */
        static CROSS(_a, _b) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_a.y * _b.z - _a.z * _b.y, _a.z * _b.x - _a.x * _b.z, _a.x * _b.y - _a.y * _b.x);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            let scalarProduct = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            return scalarProduct;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         *     __________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         *
         */
        static REFLECTION(_incoming, _normal) {
            let dot = -Vector3.DOT(_incoming, _normal);
            let reflection = Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * dot));
            return reflection;
        }
        /**
         * Divides the dividend by the divisor component by component and returns the result
         */
        static RATIO(_dividend, _divisor) {
            let vector = FudgeCore.Recycler.get(Vector3);
            vector.set(_dividend.x / _divisor.x, _dividend.y / _divisor.y, _dividend.z / _divisor.z);
            return vector;
        }
        /**
         * Creates a cartesian vector from geographic coordinates
         */
        static GEO(_longitude = 0, _latitude = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.get(Vector3);
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.set(_longitude, _latitude, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        //#endregion
        //#region Accessors
        // TODO: implement equals-functions
        get x() {
            return this.data[0];
        }
        get y() {
            return this.data[1];
        }
        get z() {
            return this.data[2];
        }
        set x(_x) {
            this.data[0] = _x;
        }
        set y(_y) {
            this.data[1] = _y;
        }
        set z(_z) {
            this.data[2] = _z;
        }
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(...this.data);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector3.DOT(this, this);
        }
        /**
         * Returns a copy of this vector
         * TODO: rename this clone and create a new method copy, which copies the values from a vector given
         */
        get clone() {
            let clone = FudgeCore.Recycler.get(Vector3);
            clone.data.set(this.data);
            return clone;
        }
        /**
         * - get: returns a geographic representation of this vector
         * - set: adjust the cartesian values of this vector to represent the given as geographic coordinates
         */
        set geo(_geo) {
            this.set(0, 0, _geo.magnitude);
            this.transform(FudgeCore.Matrix4x4.ROTATION_X(-_geo.latitude));
            this.transform(FudgeCore.Matrix4x4.ROTATION_Y(_geo.longitude));
        }
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.longitude = 180 * Math.atan2(this.x / geo.magnitude, this.z / geo.magnitude) / Math.PI;
            geo.latitude = 180 * Math.asin(this.y / geo.magnitude) / Math.PI;
            return geo;
        }
        //#endregion
        recycle() {
            this.data.set([0, 0, 0]);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a cube with the opposite corners 1 and 2
         */
        isInsideCube(_corner1, _corner2) {
            let diagonal = Vector3.DIFFERENCE(_corner2, _corner1);
            let relative = Vector3.DIFFERENCE(this, _corner1);
            let ratio = Vector3.RATIO(relative, diagonal);
            if (ratio.x > 1 || ratio.x < 0)
                return false;
            if (ratio.y > 1 || ratio.y < 0)
                return false;
            if (ratio.z > 1 || ratio.z < 0)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a sphere with the given center and radius
         */
        isInsideSphere(_center, _radius) {
            let difference = Vector3.DIFFERENCE(this, _center);
            return difference.magnitudeSquared < (_radius * _radius);
        }
        /**
         * Adds the given vector to this
         */
        add(_addend) {
            this.data.set([_addend.x + this.x, _addend.y + this.y, _addend.z + this.z]);
        }
        /**
         * Subtracts the given vector from this
         */
        subtract(_subtrahend) {
            this.data.set([this.x - _subtrahend.x, this.y - _subtrahend.y, this.z - _subtrahend.z]);
        }
        /**
         * Scales this vector by the given scalar
         */
        scale(_scalar) {
            this.data.set([_scalar * this.x, _scalar * this.y, _scalar * this.z]);
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            this.data = Vector3.NORMALIZATION(this, _length).data;
        }
        /**
         * Defines the components of this vector with the given numbers
         */
        set(_x = 0, _y = 0, _z = 0) {
            this.data[0] = _x;
            this.data[1] = _y;
            this.data[2] = _z;
        }
        /**
         * Returns this vector as a new Float32Array (copy)
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Transforms this vector by the given matrix, including or exluding the translation.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_mtxTransform, _includeTranslation = true) {
            let transformed = Vector3.TRANSFORMATION(this, _mtxTransform, _includeTranslation);
            this.data.set(transformed.data);
            FudgeCore.Recycler.store(transformed);
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components
         */
        toVector2() {
            return new FudgeCore.Vector2(this.x, this.y);
        }
        /**
         * Reflects this vector at a given normal. See {@link Vector3.REFLECTION}
         */
        reflect(_normal) {
            const reflected = Vector3.REFLECTION(this, _normal);
            this.set(reflected.x, reflected.y, reflected.z);
            FudgeCore.Recycler.store(reflected);
        }
        /**
         * Shuffles the components of this vector
         */
        shuffle() {
            let a = Array.from(this.data);
            this.set(FudgeCore.Random.default.splice(a), FudgeCore.Random.default.splice(a), a[0]);
        }
        getDistance(_to) {
            let difference = Vector3.DIFFERENCE(this, _to);
            FudgeCore.Recycler.store(difference);
            return difference.magnitude;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            this.z = Math.min(this.z, _compare.z);
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            this.z = Math.max(this.z, _compare.z);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.data = this.data.map(_function);
            return copy;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            let mutator = {
                x: this.data[0], y: this.data[1], z: this.data[2]
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a face of a {@link Mesh} by referencing three {@link Vertices} with their indizes
     * and calculates face normals.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Face {
        constructor(_vertices, _index0, _index1, _index2) {
            this.indices = [];
            this.indices = [_index0, _index1, _index2];
            this.vertices = _vertices;
            this.calculateNormals();
        }
        calculateNormals() {
            let trigon = this.indices.map((_index) => this.vertices.position(_index));
            let v1 = FudgeCore.Vector3.DIFFERENCE(trigon[1], trigon[0]);
            let v2 = FudgeCore.Vector3.DIFFERENCE(trigon[2], trigon[0]);
            this.normalUnscaled = FudgeCore.Vector3.CROSS(v1, v2);
            this.normal = FudgeCore.Vector3.NORMALIZATION(this.normalUnscaled);
        }
        getPosition(_index) {
            return this.vertices.position(this.indices[_index]);
        }
        /**
         * must be coplanar
         */
        isInside(_point) {
            let diffs = [];
            for (let index of this.indices) {
                let diff = FudgeCore.Vector3.DIFFERENCE(this.vertices.position(index), _point);
                diffs.push(diff);
            }
            let n0 = FudgeCore.Vector3.CROSS(diffs[1], diffs[0]);
            let n1 = FudgeCore.Vector3.CROSS(diffs[2], diffs[1]);
            let n2 = FudgeCore.Vector3.CROSS(diffs[0], diffs[2]);
            let dot1 = FudgeCore.Vector3.DOT(n0, n1);
            let dot2 = FudgeCore.Vector3.DOT(n0, n2);
            return !(dot1 < 0 || dot2 < 0);
        }
    }
    FudgeCore.Face = Face;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var Mesh_1;
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019/22
     */
    let Mesh = Mesh_1 = class Mesh extends FudgeCore.Mutable {
        constructor(_name = "Mesh") {
            super();
            // TODO: at this time, creating the buffers for flat shading is a brute force algorithm and should be optimized in the different subclasses
            // TODO: rename vertices to verticesSmooth or just cloud, and cloud to vertices
            // 
            this.idResource = undefined;
            this.name = "Mesh";
            // base structure for meshes in FUDGE
            this.vertices = new FudgeCore.Vertices();
            this.faces = [];
            this.name = _name;
            this.clear();
            FudgeCore.Project.register(this);
        }
        static registerSubclass(_subClass) { return Mesh_1.subclasses.push(_subClass) - 1; }
        get type() {
            return this.constructor.name;
        }
        get boundingBox() {
            if (this.∆íbox == null)
                this.∆íbox = this.createBoundingBox();
            return this.∆íbox;
        }
        get radius() {
            if (this.∆íradius == null)
                this.∆íradius = this.createRadius();
            return this.∆íradius;
        }
        useRenderBuffers(_shader, _mtxWorld, _mtxProjection, _id) { return null; /* injected by RenderInjector*/ }
        getRenderBuffers(_shader) { return null; /* injected by RenderInjector*/ }
        deleteRenderBuffers(_shader) { }
        clear() {
            this.∆íbox = undefined;
            this.∆íradius = undefined;
            this.renderMesh?.clear();
        }
        //#region Transfer
        // Serialize/Deserialize for all meshes that calculate without parameters
        serialize() {
            let serialization = {
                idResource: this.idResource,
                name: this.name,
                type: this.type // store for editor view
            }; // no data needed ...
            return serialization;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            // type is an accessor and must not be deserialized
            return this;
        }
        reduceMutator(_mutator) {
            // TODO: so much to delete... rather just gather what to mutate
            delete _mutator.∆íbox;
            delete _mutator.∆íradius;
            delete _mutator.renderBuffers;
        }
        //#endregion
        createRadius() {
            //TODO: radius and bounding box could be created on construction of vertex-array
            let radius = 0;
            for (let i = 0; i < this.vertices.length; i++) {
                radius = Math.max(radius, this.vertices.position(i).magnitudeSquared);
            }
            return Math.sqrt(radius);
        }
        createBoundingBox() {
            let box = FudgeCore.Recycler.get(FudgeCore.Box);
            box.set();
            for (let i = 0; i < this.vertices.length; i++) {
                let point = this.vertices.position(i);
                box.expand(point);
            }
            return box;
        }
    };
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Mesh.baseClass = Mesh_1;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Mesh.subclasses = [];
    Mesh = Mesh_1 = __decorate([
        FudgeCore.RenderInjectorMesh.decorate
    ], Mesh);
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```plaintext
     *       (12) 4____7  (11)
     *       (8) 0/__3/| (10)
     *       (15) ||5_||6 (14)
     *       (9) 1|/_2|/ (13)
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshCube extends FudgeCore.Mesh {
        constructor(_name = "MeshCube") {
            super(_name);
            // this.create();
            this.vertices = new FudgeCore.Vertices(
            // front
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0.5), new FudgeCore.Vector2(0, 0)), // 0
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0.5), new FudgeCore.Vector2(0, 1)), // 1
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0.5), new FudgeCore.Vector2(1, 1)), // 2
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0.5), new FudgeCore.Vector2(1, 0)), // 3
            // back
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, -0.5), new FudgeCore.Vector2(3, 0)), // 4
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, -0.5), new FudgeCore.Vector2(3, 1)), // 5
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, -0.5), new FudgeCore.Vector2(2, 1)), // 6
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, -0.5), new FudgeCore.Vector2(2, 0)), // 7
            // references
            new FudgeCore.Vertex(0, new FudgeCore.Vector2(4, 0)), // 8
            new FudgeCore.Vertex(1, new FudgeCore.Vector2(4, 1)), // 9
            new FudgeCore.Vertex(3, new FudgeCore.Vector2(0, 1)), // 10
            new FudgeCore.Vertex(7, new FudgeCore.Vector2(1, 1)), // 11
            new FudgeCore.Vertex(4, new FudgeCore.Vector2(1, 0)), // 12
            new FudgeCore.Vertex(2, new FudgeCore.Vector2(0, 0)), // 13
            new FudgeCore.Vertex(6, new FudgeCore.Vector2(1, 0)), // 14
            new FudgeCore.Vertex(5, new FudgeCore.Vector2(1, 1)) // 15
            );
            this.faces = [
                ...new FudgeCore.Quad(this.vertices, 0, 1, 2, 3).faces,
                ...new FudgeCore.Quad(this.vertices, 7, 6, 5, 4).faces,
                ...new FudgeCore.Quad(this.vertices, 3, 2, 6, 7).faces,
                ...new FudgeCore.Quad(this.vertices, 4, 5, 9, 8).faces,
                ...new FudgeCore.Quad(this.vertices, 0, 10, 11, 12).faces,
                ...new FudgeCore.Quad(this.vertices, 13, 1, 15, 14).faces // bottom
            ];
        }
    }
    MeshCube.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube);
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a flat polygon. All trigons share vertex 0, so careful design is required to create concave polygons.
     * Vertex 0 is also associated with the face normal.
     * ```plaintext
     *             0
     *           1‚ï±|‚ï≤  4 ...
     *            ‚ï≤|_‚ï≤‚ï±
     *            2   3
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshPolygon extends FudgeCore.Mesh {
        constructor(_name = "MeshPolygon", _shape = MeshPolygon.shapeDefault, _fitTexture = true) {
            super(_name);
            this.shape = new FudgeCore.MutableArray();
            this.create(_shape, _fitTexture);
        }
        get minVertices() {
            return 3;
        }
        create(_shape = [], _fitTexture = true) {
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.clear();
            this.fitTexture = _fitTexture;
            if (_shape.length < this.minVertices) {
                FudgeCore.Debug.warn(`At least ${this.minVertices} vertices needed to construct MeshPolygon, default trigon used`);
                this.create(MeshPolygon.shapeDefault, true);
                return;
            }
            let shape = _shape;
            let min = FudgeCore.Vector2.ZERO();
            let max = FudgeCore.Vector2.ZERO();
            this.vertices = new FudgeCore.Vertices();
            for (let vertex of shape) {
                this.vertices.push(new FudgeCore.Vertex(vertex.toVector3()));
                min.x = Math.min(min.x, vertex.x);
                max.x = Math.max(max.x, vertex.x);
                min.y = Math.min(min.y, vertex.y);
                max.y = Math.max(max.y, vertex.y);
            }
            let size = new FudgeCore.Vector2(max.x - min.x, max.y - min.y);
            if (this.fitTexture) {
                for (let i = 0; i < shape.length; i++) {
                    let textureUV = FudgeCore.Vector2.SUM(shape[i], min);
                    this.vertices[i].uv = new FudgeCore.Vector2(textureUV.x / size.x, -textureUV.y / size.y);
                }
            }
            else {
                _shape.forEach((_vertex, i) => this.vertices[i].uv = new FudgeCore.Vector2(_vertex.x, -_vertex.y));
            }
            this.faces = [];
            for (let i = 2; i < this.vertices.length; i++)
                this.faces.push(new FudgeCore.Face(this.vertices, i - 1, i, 0));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.fitTexture = this.fitTexture;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let vectors = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.create(vectors, _serialization.fitTexture);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.create(this.shape, this.fitTexture);
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
    }
    MeshPolygon.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPolygon);
    MeshPolygon.shapeDefault = [
        new FudgeCore.Vector2(-1, -1),
        new FudgeCore.Vector2(1, -1),
        new FudgeCore.Vector2(0, 1)
    ];
    FudgeCore.MeshPolygon = MeshPolygon;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshPolygon.ts"/>
var FudgeCore;
///<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates an extrusion of a polygon by a series of transformations
     * ```plaintext
     *                      ____
     * Polygon         ____‚ï±‚ï≤   ‚ï≤                             y
     * Transform 0  ‚Üí ‚ï± ‚ï≤__‚ï≤_‚ï≤___‚ï≤ ‚Üê Transform 2          z __‚îÇ
     * (base)         ‚ï≤_‚ï±__‚ï± ‚ï±   ‚ï±   (lid)                     ‚ï≤
     *     Transform 1  ‚Üí  ‚ï≤‚ï±___‚ï±                               x
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshExtrusion extends FudgeCore.MeshPolygon {
        // private transforms: MutableArray<Matrix4x4> = new MutableArray(Matrix4x4);
        constructor(_name = "MeshExtrusion", _vertices = FudgeCore.MeshPolygon.shapeDefault, _mtxTransforms = MeshExtrusion.mtxDefaults, _fitTexture = true) {
            super(_name, _vertices, _fitTexture);
            this.mtxTransforms = new FudgeCore.MutableArray();
            this.extrude(_mtxTransforms);
            // console.log("Mutator", this.getMutator());
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.transforms = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxTransforms);
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let mtxTransforms;
            if (_serialization.transforms)
                mtxTransforms = await FudgeCore.Serializer.deserializeArray(_serialization.transforms);
            this.extrude(mtxTransforms);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.extrude(this.mtxTransforms);
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
        //#endregion
        extrude(_mtxTransforms = MeshExtrusion.mtxDefaults) {
            this.mtxTransforms = FudgeCore.MutableArray.from(_mtxTransforms);
            let nTransforms = _mtxTransforms.length;
            let nVerticesShape = this.vertices.length;
            // create new vertex cloud, current cloud holds MeshPolygon
            let vertices = new FudgeCore.Vertices();
            // create base by transformation of polygon with first transform
            let base = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[0], true), _v.uv));
            vertices.push(...base);
            // create lid by transformation of polygon with last transform
            let lid = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[nTransforms - 1], true), _v.uv));
            vertices.push(...lid);
            // recreate base faces to recalculate normals
            this.faces = this.faces.map((_face) => new FudgeCore.Face(vertices, _face.indices[0], _face.indices[1], _face.indices[2]));
            // create the lid faces using the indices of the base faces, but with an index offset and reverse order of indices
            this.faces.push(...this.faces.map(_face => new FudgeCore.Face(vertices, _face.indices[2] + nVerticesShape, _face.indices[1] + nVerticesShape, _face.indices[0] + nVerticesShape)));
            for (let t = 0; t < nTransforms; t++) {
                let mtxTransform = _mtxTransforms[t];
                let referToClose = vertices.length;
                let wrap = this.vertices.map((_v, _i) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, mtxTransform, true), new FudgeCore.Vector2(_i / nVerticesShape, t / nTransforms)));
                vertices.push(...wrap);
                vertices.push(new FudgeCore.Vertex(referToClose, new FudgeCore.Vector2(1, t / nTransforms)));
                // if (i > 0 && i < nTransforms - 1)
                //   vertices.push(...wrap.map((_vector: Vector3) => _vector.clone)); <- no slicing for flat shading yet...
            }
            // create indizes for wrapper
            for (let t = 0; t < nTransforms - 1; t++)
                for (let i = 0; i < nVerticesShape; i++) {
                    let index = +2 * nVerticesShape // base & lid are offsets 
                        + t * (nVerticesShape + 1) // offset for each transformation
                        + i;
                    let quad = new FudgeCore.Quad(vertices, index, index + nVerticesShape + 1, index + nVerticesShape + 2, index + 1, FudgeCore.QUADSPLIT.AT_0);
                    this.faces.push(...quad.faces);
                }
            this.vertices = vertices;
            return;
        }
    }
    MeshExtrusion.iSubclass = FudgeCore.Mesh.registerSubclass(MeshExtrusion);
    MeshExtrusion.mtxDefaults = [
        FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(0.5)),
        FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(-0.5))
    ];
    FudgeCore.MeshExtrusion = MeshExtrusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Allows to create custom meshes from given Data */
    class MeshFromData extends FudgeCore.Mesh {
        constructor(_vertices, _textureUVs, _indices, _faceNormals) {
            super();
            this.verticesToSet = _vertices;
            this.textureUVsToSet = _textureUVs;
            this.indicesToSet = _indices;
            this.faceNormalsToSet = _faceNormals;
        }
        createVertices() {
            return this.verticesToSet;
        }
        createTextureUVs() {
            return this.textureUVsToSet;
        }
        createIndices() {
            return this.indicesToSet;
        }
        createFlatNormals() {
            return this.faceNormalsToSet;
        }
    }
    FudgeCore.MeshFromData = MeshFromData;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Mesh loaded from a GLTF-file
     * @author Matthias Roming, HFU, 2022
     */
    class MeshGLTF extends FudgeCore.Mesh {
        serialize() {
            const serialization = super.serialize();
            serialization.uriGLTF = this.uriGLTF;
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization);
            const loader = await FudgeCore.GLTFLoader.LOAD(_serialization.uriGLTF);
            await this.load(loader, loader.gltf.meshes.findIndex(gltfMesh => gltfMesh.name == this.name));
            return this;
        }
        async load(_loader, _iMesh) {
            const gltfMesh = _loader.gltf.meshes[_iMesh];
            this.name = gltfMesh.name;
            this.renderMesh = new FudgeCore.RenderMesh(this);
            Reflect.set(this.renderMesh, "∆íindices", await _loader.getUint16Array(gltfMesh.primitives[0].indices));
            Reflect.set(this.renderMesh, "∆ívertices", await _loader.getFloat32Array(gltfMesh.primitives[0].attributes.POSITION));
            Reflect.set(this.renderMesh, "∆ínormals", await _loader.getFloat32Array(gltfMesh.primitives[0].attributes.NORMAL));
            Reflect.set(this.renderMesh, "∆ítextureUVs", await _loader.getFloat32Array(gltfMesh.primitives[0].attributes.TEXCOORD_0));
            // let renderBuffers: RenderBuffers =  this.getRenderBuffers(ShaderFlat); // hotfix to create renderMesh
            this.uriGLTF = _loader.uri;
            return this;
        }
    }
    FudgeCore.MeshGLTF = MeshGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**Simple Wavefront OBJ import. Takes a wavefront obj string. To Load from a file url, use the
     * static LOAD Method. Currently only works with triangulated Meshes
     * (activate 'Geomentry ‚Üí Triangulate Faces' in Blenders obj exporter)
     * @todo UVs, Load Materials, Support Quads
     * @authors Simon Storl-Schulke 2021 | Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021-2022 */
    class MeshObj extends FudgeCore.Mesh {
        // protected verts: number[] = [];
        // protected uvs: number[] = [];
        // protected inds: number[] = [];
        // protected facenormals: number[] = [];
        // protected facecrossproducts: number[] = [];
        constructor(_name, _url) {
            super(_name);
            {
                if (_url) {
                    this.load(_url);
                    if (!_name)
                        _name = _url.toString().split("/").pop();
                }
                if (!_name)
                    _name = "MeshObj";
                this.name = _name;
            }
        }
        /**
             * Asynchronously loads the image from the given url
             */
        async load(_url) {
            this.url = _url;
            let url = new URL(this.url.toString(), FudgeCore.Project.baseURL).toString();
            let data = await (await fetch(url)).text();
            this.parseObj(data);
        }
        /** Splits up the obj string into separate arrays for each datatype */
        parseObj(data) {
            this.clear();
            const lines = data.split("\n");
            let positions = [];
            let uvs = [];
            let faceInfo = [];
            for (let line of lines) {
                line = line.trim();
                if (!line || line.startsWith("#"))
                    continue;
                const parts = line.split(" ");
                parts.shift();
                //Vertex - example: v 0.70 -0.45 -0.52
                if (!line || line.startsWith("v "))
                    positions.push(new FudgeCore.Vector3(...parts.map(x => +x)));
                //Texcoord - example: vt 0.545454 0.472382
                else if (!line || line.startsWith("vt "))
                    uvs.push(new FudgeCore.Vector2(...parts.map(x => +x)));
                /*Face Indices - example: f 1/1/1 2/2/1 3/3/1 -->
                vertex1/texcoord1/normal1 vertex2/texcoord2/normal2 vertex3/texcoord3/normal3*/
                else if (!line || line.startsWith("f "))
                    for (let i = 0; i < 3; i++) {
                        faceInfo.push({
                            iPosition: +parts[i].split("/")[0] - 1,
                            iUV: +parts[i].split("/")[1] - 1,
                            iNormal: +parts[i].split("/")[2] - 1
                        });
                    }
            }
            this.vertices = new FudgeCore.Vertices(...positions.map((_p) => new FudgeCore.Vertex(_p)));
            for (let i = 0; i < faceInfo.length; i += 3) {
                let indices = [];
                for (let v = 0; v < 3; v++) {
                    let info = faceInfo[i + v];
                    let index = info.iPosition;
                    if (this.vertices[index].uv) {
                        index = this.vertices.length;
                        this.vertices.push(new FudgeCore.Vertex(info.iPosition));
                    }
                    this.vertices[index].uv = uvs[info.iUV];
                    indices.push(index);
                }
                this.faces.push(new FudgeCore.Face(this.vertices, indices[0], indices[1], indices[2]));
            }
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.url = this.url;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.load(_serialization.url);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            if (typeof (_mutator.url) !== "undefined")
                this.load(_mutator.url);
        }
    }
    MeshObj.iSubclass = FudgeCore.Mesh.registerSubclass(MeshObj);
    FudgeCore.MeshObj = MeshObj;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```plaintext
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshPyramid extends FudgeCore.Mesh {
        constructor(_name = "MeshPyramid") {
            super(_name);
            // this.create();
            this.vertices = new FudgeCore.Vertices(
            // ground vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, 0.5), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, 0.5), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, -0.5), new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, -0.5), new FudgeCore.Vector2(0, 0)), 
            // tip (vertex #4)
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.0, 1.0, 0.0), new FudgeCore.Vector2(0.5, 0.5)), 
            // floor again for downside texture
            new FudgeCore.Vertex(0, new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(1, new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(2, new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(3, new FudgeCore.Vector2(0, 1)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 4, 0, 1),
                new FudgeCore.Face(this.vertices, 4, 1, 2),
                new FudgeCore.Face(this.vertices, 4, 2, 3),
                new FudgeCore.Face(this.vertices, 4, 3, 0),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 2, 5 + 1),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 3, 5 + 2)
            ];
        }
    }
    MeshPyramid.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid);
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```plaintext
     *        0 __ 3
     *         |_\|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019-2022
     */
    class MeshQuad extends FudgeCore.MeshPolygon {
        constructor(_name = "MeshQuad") {
            super(_name, MeshQuad.shape);
        }
        // // flat equals smooth
        // public get verticesFlat(): Float32Array { return this.vertices; }
        // public get indicesFlat(): Uint16Array { return this.indices; }
        // public get normalsFlat(): Float32Array { return this.normalsVertex; }
        //#region Transger
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(MeshQuad.shape, true);
            return this;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
            delete _mutator.fitTexture;
        }
    }
    MeshQuad.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad);
    MeshQuad.shape = [
        new FudgeCore.Vector2(-0.5, 0.5), new FudgeCore.Vector2(-0.5, -0.5), new FudgeCore.Vector2(0.5, -0.5), new FudgeCore.Vector2(0.5, 0.5)
    ];
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Information about the vertical projection of a given position onto the terrain
     */
    class TerrainInfo {
    }
    FudgeCore.TerrainInfo = TerrainInfo;
    /**
     * A terrain spreads out in the x-z-plane, y is the height derived from the heightmap function.
     * The terrain is always 1 in size in all dimensions, fitting into the unit-cube.
     * Resolution determines the number of quads in x and z dimension, scale the factor applied to the x,z-coordinates passed to the heightmap function.
     * Standard function is the simplex noise implemented with FUDGE, but another function can be given.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Simon Storl-Schulke, HFU, 2020 | Moritz Beaugrand, HFU, 2021
     */
    class MeshTerrain extends FudgeCore.Mesh {
        constructor(_name = "MeshTerrain", _resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            super(_name);
            this.heightMapFunction = null;
            this.create(_resolution, _scaleInput, _functionOrSeed);
        }
        create(_resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            this.clear();
            this.seed = undefined;
            this.resolution = new FudgeCore.Vector2(Math.round(_resolution.x), Math.round(_resolution.y));
            this.scale = _scaleInput.clone;
            if (_functionOrSeed instanceof Function)
                this.heightMapFunction = _functionOrSeed;
            else if (typeof (_functionOrSeed) == "number") {
                this.seed = _functionOrSeed;
                let prng = new FudgeCore.Random(this.seed);
                this.heightMapFunction = new FudgeCore.Noise2(() => prng.getNorm()).sample; // TODO call PRNG
            }
            else
                this.heightMapFunction = new FudgeCore.Noise2().sample;
            this.vertices = new FudgeCore.Vertices();
            //Iterate over each cell to generate grid of vertices
            for (let z = 0; z <= this.resolution.y; z++) {
                for (let x = 0; x <= this.resolution.x; x++) {
                    let xNorm = x / this.resolution.x;
                    let zNorm = z / this.resolution.y;
                    this.vertices.push(new FudgeCore.Vertex(new FudgeCore.Vector3(xNorm - 0.5, this.heightMapFunction(xNorm * this.scale.x, zNorm * this.scale.y), zNorm - 0.5), new FudgeCore.Vector2(xNorm, zNorm)));
                }
            }
            let quads = [];
            let split = FudgeCore.QUADSPLIT.AT_0;
            for (let z = 0; z < this.resolution.y; z++) {
                for (let x = 0; x < this.resolution.x; x++) {
                    quads.push(new FudgeCore.Quad(this.vertices, (x + 0) + (z + 0) * (this.resolution.x + 1), (x + 0) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 0) * (this.resolution.x + 1), split));
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
                }
                if (this.resolution.x % 2 == 0) // reverse last split change if x-resolution is even
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
            }
            this.faces = quads.flatMap((quad) => quad.faces);
        }
        /**
         * Returns information about the vertical projection of the given position onto the terrain.
         * Pass the overall world transformation of the terrain if the position is given in world coordinates.
         * If at hand, pass the inverse too to avoid unnecessary calculation.
         */
        getTerrainInfo(_position, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _mtxInverse) {
            if (!_mtxInverse)
                _mtxInverse = FudgeCore.Matrix4x4.INVERSION(_mtxWorld);
            let terrainInfo = new TerrainInfo;
            let posLocal = FudgeCore.Vector3.TRANSFORMATION(_position, _mtxInverse, true);
            let z = Math.floor((posLocal.z + 0.5) * this.resolution.y);
            let x = Math.floor((posLocal.x + 0.5) * this.resolution.x);
            if (z < 0 || z > this.resolution.y - 1 || x < 0 || x > this.resolution.x - 1)
                return null;
            let index = (z * this.resolution.x + x) * 2;
            let face = this.faces[index];
            let ray = new FudgeCore.Ray(FudgeCore.Vector3.Y(), posLocal);
            let point = ray.intersectFacePlane(face);
            if (!face.isInside(point)) {
                index++;
                face = this.faces[index];
                point = ray.intersectFacePlane(face);
            }
            terrainInfo.index = index;
            terrainInfo.positionFace = point;
            terrainInfo.position = FudgeCore.Vector3.TRANSFORMATION(point, _mtxWorld, true);
            terrainInfo.normal = FudgeCore.Vector3.TRANSFORMATION(face.normal, FudgeCore.Matrix4x4.TRANSPOSE(_mtxInverse), false);
            terrainInfo.distance = _position.y - terrainInfo.position.y;
            return terrainInfo;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.seed = this.seed;
            serialization.scale = this.scale.serialize();
            serialization.resolution = this.resolution.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.resolution.deserialize(_serialization.resolution);
            await this.scale.deserialize(_serialization.scale);
            this.seed = _serialization.seed;
            this.create(this.resolution, this.scale, this.seed);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(this.resolution, this.scale, this.seed);
        }
    }
    MeshTerrain.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTerrain);
    FudgeCore.MeshTerrain = MeshTerrain;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshTerrain.ts"/>
var FudgeCore;
///<reference path="MeshTerrain.ts"/>
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021 | Moritz Beaugrand, HFU, 2020
     */
    class MeshRelief extends FudgeCore.MeshTerrain {
        constructor(_name = "MeshRelief", _texture = null) {
            super(_name, FudgeCore.Vector2.ONE(2), undefined, (_x, _z) => 0);
            this.texture = null;
            this.setTexture(_texture);
        }
        static createHeightMapFunction(_texture) {
            let array = MeshRelief.textureToClampedArray(_texture);
            let heightMapFunction = (_x, _z) => {
                let pixel = Math.round(_z * _texture.image.width + _x);
                return array[pixel * 4] / 255;
            };
            return heightMapFunction;
        }
        static textureToClampedArray(_texture) {
            let canvas = document.createElement("canvas");
            canvas.width = _texture.image.width;
            canvas.height = _texture.image.height;
            let crc = canvas.getContext("2d");
            crc.imageSmoothingEnabled = false;
            crc.drawImage(_texture.image, 0, 0);
            return crc.getImageData(0, 0, _texture.image.width, _texture.image.height).data;
        }
        setTexture(_texture = null) {
            if (!_texture)
                return;
            this.texture = _texture;
            let resolution = _texture ? new FudgeCore.Vector2(_texture.image.width - 1, _texture.image.height - 1) : undefined;
            super.create(resolution, resolution, MeshRelief.createHeightMapFunction(_texture));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            delete serialization.seed;
            delete serialization.scale;
            delete serialization.resolution;
            if (this.texture)
                serialization.idTexture = this.texture.idResource;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            if (_serialization.idTexture) {
                this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                this.setTexture(this.texture);
            }
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.texture) !== "undefined")
                this.setTexture(_mutator.texture);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.seed;
            delete _mutator.scale;
            delete _mutator.resolution;
        }
    }
    MeshRelief.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRelief);
    FudgeCore.MeshRelief = MeshRelief;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="MeshPolygon.ts"/>
var FudgeCore;
// /<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates a rotation of a polygon around the y-axis
     * ```plaintext
     *                     y
     *                  _  ‚Üë 0_1
     *                 ‚îÇ   ‚îÇ‚Üíx ‚îÇ2
     *                  ‚ï≤  ‚îÇ  ‚ï±3
     *                  ‚ï±  ‚îÇ  ‚ï≤
     *                 ‚ï±___‚îÇ___‚ï≤4
     *                      5
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshRotation extends FudgeCore.Mesh {
        constructor(_name = "MeshRotation", _shape = MeshRotation.verticesDefault, _longitudes = 3) {
            super(_name);
            this.shape = new FudgeCore.MutableArray();
            this.rotate(_shape, _longitudes);
            // console.log("Mutator", this.getMutator());
        }
        get minVertices() {
            return 2;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.longitudes = this.longitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let shape = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.longitudes = _serialization.longitudes;
            this.rotate(shape, this.longitudes);
            return this;
        }
        async mutate(_mutator) {
            await super.mutate(_mutator);
            this.rotate(this.shape, this.longitudes);
            this.dispatchEvent(new Event("mutate" /* MUTATE */));
        }
        //#endregion
        rotate(_shape, _longitudes) {
            this.clear();
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.longitudes = Math.round(_longitudes);
            let angle = 360 / this.longitudes;
            let mtxRotate = FudgeCore.Matrix4x4.ROTATION_Y(angle);
            // copy original polygon as Vector3 array
            let polygon = [];
            let distances = [0];
            let total = 0;
            for (let i = 0; i < this.shape.length; i++) {
                polygon.push(this.shape[i].toVector3());
                if (i > 0) {
                    let distance = FudgeCore.Vector2.DIFFERENCE(this.shape[i], this.shape[i - 1]).magnitude;
                    total += distance;
                    distances.push(total);
                }
            }
            distances.forEach((entry, index) => { distances[index] = entry / total; });
            let nVerticesPolygon = polygon.length;
            let cloud = new FudgeCore.Vertices();
            for (let longitude = 0; longitude <= this.longitudes; longitude++) {
                for (let i = 0; i < nVerticesPolygon; i++) {
                    let uv = new FudgeCore.Vector2(longitude / this.longitudes, distances[i]);
                    // TODO: last sector should only be references to the first meridian
                    if (longitude == this.longitudes)
                        cloud.push(new FudgeCore.Vertex(i, uv));
                    else {
                        if (longitude > 0 && this.shape[i].x == 0) // use a single vertex when it's on the rotation axis
                            cloud.push(new FudgeCore.Vertex(i, uv));
                        else
                            cloud.push(new FudgeCore.Vertex(polygon[i].clone, uv));
                    }
                }
                polygon.forEach((_vector) => _vector.transform(mtxRotate));
            }
            // copy indices to new index array
            let faces = [];
            for (let longitude = 0; longitude < this.longitudes; longitude++) {
                for (let latitude = 0; latitude < nVerticesPolygon - 1; latitude++) {
                    let start = longitude * nVerticesPolygon + latitude;
                    let quad = new FudgeCore.Quad(cloud, start + 1, start + 1 + nVerticesPolygon, start + nVerticesPolygon, start);
                    faces.push(...quad.faces);
                    // TODO: catch invalid faces right here...
                }
            }
            this.vertices = cloud;
            this.faces = faces;
        }
    }
    MeshRotation.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRotation);
    MeshRotation.verticesDefault = [
        new FudgeCore.Vector2(0.5, 0.5),
        new FudgeCore.Vector2(0.5, -0.5)
    ];
    FudgeCore.MeshRotation = MeshRotation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderInjectorMeshSkin extends FudgeCore.RenderInjectorMesh {
        static decorate(_constructor) {
            Object.defineProperty(_constructor.prototype, "useRenderBuffers", {
                value: RenderInjectorMeshSkin.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "getRenderBuffers", {
                value: RenderInjectorMeshSkin.getRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, "deleteRenderBuffers", {
                value: RenderInjectorMeshSkin.deleteRenderBuffers
            });
        }
        static getRenderBuffers(_shader) {
            let renderBuffers = super.getRenderBuffers.call(this, _shader);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let iBones = this.renderMesh.iBones;
            let weights = this.renderMesh.weights;
            if (_shader.define.includes("FLAT")) {
                iBones = this.renderMesh.iBonesFlat;
                weights = this.renderMesh.weightsFlat;
            }
            renderBuffers.iBones = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.iBones);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, iBones, WebGL2RenderingContext.STATIC_DRAW);
            renderBuffers.weights = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.weights);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, weights, WebGL2RenderingContext.STATIC_DRAW);
            return renderBuffers;
        }
        static useRenderBuffers(_shader, _mtxMeshToWorld, _mtxMeshToView, _id, _mtxBones) {
            let renderBuffers = super.useRenderBuffers.call(this, _shader, _mtxMeshToWorld, _mtxMeshToView, _id);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const aIBone = _shader.attributes["a_iBone"];
            if (aIBone) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.iBones);
                crc3.enableVertexAttribArray(aIBone);
                crc3.vertexAttribIPointer(aIBone, 4, WebGL2RenderingContext.UNSIGNED_BYTE, 0, 0);
            }
            const aWeight = _shader.attributes["a_fWeight"];
            if (aWeight) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.weights);
                crc3.enableVertexAttribArray(aWeight);
                crc3.vertexAttribPointer(aWeight, 4, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            _mtxBones.forEach((mtxBone, iBone) => {
                const uMtxBone = _shader.uniforms[`u_bones[${iBone}].matrix`];
                if (uMtxBone)
                    crc3.uniformMatrix4fv(uMtxBone, false, mtxBone.get());
            });
            return renderBuffers;
        }
        static deleteRenderBuffers(_renderBuffers) {
            super.deleteRenderBuffers(_renderBuffers);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_renderBuffers) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.deleteBuffer(_renderBuffers.iBones);
                crc3.deleteBuffer(_renderBuffers.weights);
            }
        }
    }
    FudgeCore.RenderInjectorMeshSkin = RenderInjectorMeshSkin;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./../Render/RenderInjectorMeshSkin.ts"/>
var FudgeCore;
///<reference path="./../Render/RenderInjectorMeshSkin.ts"/>
(function (FudgeCore) {
    /**
     * Mesh influenced by a skeleton
     * @author Matthias Roming, HFU, 2022
     */
    let MeshSkin = class MeshSkin extends FudgeCore.MeshGLTF {
        async load(_loader, _iMesh) {
            await super.load(_loader, _iMesh);
            const gltfMesh = _loader.gltf.meshes[_iMesh];
            this.renderMesh = new FudgeCore.RenderMesh(this);
            Reflect.set(this.renderMesh, "∆íiBones", await _loader.getUint8Array(gltfMesh.primitives[0].attributes.JOINTS_0));
            Reflect.set(this.renderMesh, "∆íweights", await _loader.getFloat32Array(gltfMesh.primitives[0].attributes.WEIGHTS_0));
            return this;
        }
        useRenderBuffers(_shader, _mtxWorld, _mtxProjection, _id, _mtxBones) { return null; /* injected by RenderInjector*/ }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
    };
    MeshSkin = __decorate([
        FudgeCore.RenderInjectorMeshSkin.decorate
    ], MeshSkin);
    FudgeCore.MeshSkin = MeshSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSphere extends FudgeCore.MeshRotation {
        constructor(_name = "MeshSphere", _longitudes = 8, _latitudes = 8) {
            super(_name);
            this.create(_longitudes, _latitudes);
        }
        create(_longitudes = 3, _latitudes = 2) {
            this.clear();
            //Clamp resolution to prevent performance issues
            this.longitudes = Math.min(Math.round(_longitudes), 128);
            this.latitudes = Math.min(Math.round(_latitudes), 128);
            if (_longitudes < 3 || _latitudes < 2) {
                FudgeCore.Debug.warn("UV Sphere must have at least 3 longitudes and 2 latitudes to form a 3-dimensional shape.");
                this.longitudes = Math.max(3, _longitudes);
                this.latitudes = Math.max(2, _latitudes);
            }
            let shape = [];
            let step = Math.PI / this.latitudes;
            for (let i = 0; i <= this.latitudes; ++i) {
                let angle = Math.PI / 2 - i * step;
                let x = Math.cos(angle);
                let y = Math.sin(angle);
                shape.push(new FudgeCore.Vector2(x / 2, y / 2));
            }
            // place first and last vertex exactly on rotation axis
            shape[0].x = 0;
            shape[shape.length - 1].x = 0;
            super.rotate(shape, _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.latitudes = this.latitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    MeshSphere.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere);
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```plaintext
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSprite extends FudgeCore.Mesh {
        constructor(_name = "MeshSprite") {
            super(_name);
            this.vertices = new FudgeCore.Vertices(new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0), new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0), new FudgeCore.Vector2(1, 0)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 1, 2, 0),
                new FudgeCore.Face(this.vertices, 2, 3, 0),
                new FudgeCore.Face(this.vertices, 0, 3, 1),
                new FudgeCore.Face(this.vertices, 3, 2, 1)
            ];
        }
        // flat is standard here
        get verticesFlat() { return this.renderMesh.vertices; }
        get indicesFlat() { return this.renderMesh.indices; }
    }
    MeshSprite.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite);
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a Torus with a given thickness and the number of major- and minor segments
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshTorus extends FudgeCore.MeshRotation {
        constructor(_name = "MeshTorus", _size = 0.25, _longitudes = 8, _latitudes = 6) {
            super(_name, MeshTorus.getShape(_size, Math.max(3, _latitudes)), _longitudes);
            this.size = 0.25;
            this.latitudes = 12;
            this.size = _size;
            this.longitudes = _longitudes;
            this.latitudes = Math.max(3, _latitudes);
        }
        static getShape(_size, _latitudes) {
            let shape = [];
            let radius = _size / 2;
            let center = new FudgeCore.Vector2(0.25 + radius, 0);
            for (let latitude = 0; latitude <= _latitudes; latitude++) {
                let angle = 2 * Math.PI * latitude / _latitudes;
                shape.push(FudgeCore.Vector2.SUM(center, new FudgeCore.Vector2(radius * -Math.cos(angle), radius * Math.sin(angle))));
            }
            return shape;
        }
        create(_size = 0.25, _longitudes = 8, _latitudes = 6) {
            this.size = _size;
            this.latitudes = Math.max(3, _latitudes);
            super.rotate(MeshTorus.getShape(_size, _latitudes), _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.latitudes = this.latitudes;
            serialization.size = this.size;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.size, _serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator) {
            super.mutate(_mutator);
            this.create(this.size, this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    MeshTorus.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTorus);
    FudgeCore.MeshTorus = MeshTorus;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let QUADSPLIT;
    (function (QUADSPLIT) {
        QUADSPLIT[QUADSPLIT["PLANAR"] = 0] = "PLANAR";
        QUADSPLIT[QUADSPLIT["AT_0"] = 1] = "AT_0";
        QUADSPLIT[QUADSPLIT["AT_1"] = 2] = "AT_1";
    })(QUADSPLIT = FudgeCore.QUADSPLIT || (FudgeCore.QUADSPLIT = {}));
    /**
     * A surface created with four vertices which immediately creates none, one or two {@link Face}s depending on vertices at identical positions.
     * ```plaintext
     * QUADSPLIT:  PLANAR                  AT_0                     AT_1
     *             0 _ 3                   0 _ 3                    0 _ 3
     *              |\|                     |\|                      |/|
     *             1 ‚Äæ 2                   1 ‚Äæ 2                    1 ‚Äæ 2
     *  shared last vertex 2      last vertices 2 + 3      last vertices 3 + 0
     *
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Quad {
        constructor(_vertices, _index0, _index1, _index2, _index3, _split = QUADSPLIT.PLANAR) {
            this.faces = [];
            this.#split = _split;
            try {
                if (_split != QUADSPLIT.AT_1)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index1, _index2));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index2, _index3));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
            try {
                if (_split == QUADSPLIT.PLANAR)
                    this.faces.push(new FudgeCore.Face(_vertices, _index3, _index0, _index2));
                else if (_split == QUADSPLIT.AT_0)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index2, _index3));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index3, _index0));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
        }
        #split;
        get split() {
            return this.#split;
        }
    }
    FudgeCore.Quad = Quad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class Vertex {
        /**
         * Represents a vertex of a mesh with extended information such as the uv coordinates and the vertex normal.
         * It may refer to another vertex via an index into some array, in which case the position and the normal are stored there.
         * This way, vertex position and normal is a 1:1 association, vertex to texture coordinates a 1:n association.
       * @authors Jirka Dell'Oro-Friedl, HFU, 2022
         */
        constructor(_positionOrIndex, _uv = null, _normal = FudgeCore.Vector3.ZERO()) {
            if (_positionOrIndex instanceof FudgeCore.Vector3)
                this.position = _positionOrIndex;
            else
                this.referTo = _positionOrIndex;
            this.uv = _uv;
            this.normal = _normal;
        }
    }
    FudgeCore.Vertex = Vertex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Array with extended functionality to serve as a {@link Vertex}-cloud.
     * Accessors yield position or normal also for vertices referencing other vertices
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertices extends Array {
        // TODO: this class may become more powerful by hiding the array and add more service methods like calculating bounding box, radius etc.
        // see if a proxy of the array interfacing [] would do a good job -> tested: proxy is about 20 times slower!
        /**
         * Returns the subset of vertices that do not refer to other vertices
         */
        get originals() {
            return this.filter(_vertex => _vertex.referTo == undefined);
        }
        /**
         * returns the position associated with the vertex addressed, resolving references between vertices
         */
        position(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.position : this[vertex.referTo].position;
        }
        /**
         * returns the normal associated with the vertex addressed, resolving references between vertices
         */
        normal(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.normal : this[vertex.referTo].normal;
        }
        /**
         * returns the uv-coordinates associated with the vertex addressed
         */
        uv(_index) {
            return this[_index].uv;
        }
        /**
         * returns the position associated with the vertex addressed, resolving references between vertices
         */
        bones(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.bones : this[vertex.referTo].bones;
        }
    }
    FudgeCore.Vertices = Vertices;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines automatic adjustment of the collider
     */
    let BODY_INIT;
    (function (BODY_INIT) {
        /** Collider uses the pivot of the mesh for initilialization */
        BODY_INIT[BODY_INIT["TO_MESH"] = 0] = "TO_MESH";
        /** Collider uses the transform of the node for initilialization */
        BODY_INIT[BODY_INIT["TO_NODE"] = 1] = "TO_NODE";
        /** Collider uses its own pivot for initilialization */
        BODY_INIT[BODY_INIT["TO_PIVOT"] = 2] = "TO_PIVOT";
    })(BODY_INIT = FudgeCore.BODY_INIT || (FudgeCore.BODY_INIT = {}));
    /**
       * Acts as the physical representation of the {@link Node} it's attached to.
       * It's the connection between the Fudge rendered world and the Physics world.
       * For the physics to correctly get the transformations rotations need to be applied with from left = true.
       * Or rotations need to happen before scaling.
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class ComponentRigidbody extends FudgeCore.Component {
        // #physics: Physics; //TODO: keep a pointer to the physics instance used by this component
        /** Creating a new rigidbody with a weight in kg, a physics type (default = dynamic), a collider type what physical form has the collider, to what group does it belong, is there a transform Matrix that should be used, and is the collider defined as a group of points that represent a convex mesh. */
        constructor(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            super();
            /** Transformation of the collider relative to the node's transform. Once set mostly remains constant.
             * If altered, {@link isInitialized} must be reset to false to recreate the collider in the next {@link Render.prepare}
             */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            /**
             * Vertices that build a convex mesh (form that is in itself closed). Needs to set in the construction of the rb if none of the standard colliders is used.
             * Untested and not yet fully supported by serialization and mutation.
             */
            this.convexMesh = null;
            /** Collisions with rigidbodies happening to this body, can be used to build a custom onCollisionStay functionality. */
            this.collisions = new Array();
            /** Triggers that are currently triggering this body */
            this.triggerings = new Array();
            /**
             * Automatic adjustment of the pivot when {@link Render.prepare} is called according to {@link BODY_INIT}
             */
            this.initialization = BODY_INIT.TO_PIVOT;
            /** Marks if collider was initialized. Reset to false to initialize again e.g. after manipulation of mtxPivot */
            this.isInitialized = false;
            /** ID to reference this specific ComponentRigidbody */
            this.#id = 0;
            this.#collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT;
            this.#typeCollider = FudgeCore.COLLIDER_TYPE.CUBE;
            this.#rigidbodyInfo = new OIMO.RigidBodyConfig();
            this.#typeBody = FudgeCore.BODY_TYPE.DYNAMIC;
            this.#massData = new OIMO.MassData();
            this.#dampingLinear = 0.1;
            this.#dampingAngular = 0.1;
            this.#effectRotation = FudgeCore.Vector3.ONE();
            this.#effectGravity = 1;
            this.#isTrigger = false;
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.IDENTITY();
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.IDENTITY();
            //#endregion
            // Activate the functions of this component as response to events
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* COMPONENT_ADD */:
                        // this.addEventListener(EVENT.COMPONENT_ACTIVATE, this.addRigidbodyToWorld);
                        this.addEventListener("componentDeactivate" /* COMPONENT_DEACTIVATE */, this.removeRigidbodyFromWorld);
                        // this.node.addEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.addEventListener("nodeDeactivate" /* NODE_DEACTIVATE */, this.removeRigidbodyFromWorld, true);
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.warn(`ComponentRigidbody attached to node missing ComponentTransform`, this.node);
                        break;
                    case "componentRemove" /* COMPONENT_REMOVE */:
                        // this.removeEventListener(EVENT.COMPONENT_ADD, this.addRigidbodyToWorld);
                        this.removeEventListener("componentRemove" /* COMPONENT_REMOVE */, this.removeRigidbodyFromWorld);
                        // this.node.removeEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.removeEventListener("nodeDeactivate" /* NODE_DEACTIVATE */, this.removeRigidbodyFromWorld, true);
                        this.removeRigidbodyFromWorld();
                        break;
                    case "nodeDeserialized" /* NODE_DESERIALIZED */:
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.error(`ComponentRigidbody attached to node missing ComponentTransform`, this.node);
                        break;
                }
            };
            /** Adding this ComponentRigidbody to the Physiscs.world giving the oimoPhysics system the information needed */
            this.addRigidbodyToWorld = () => {
                if (!this.#rigidbody._world)
                    FudgeCore.Physics.addRigidbody(this);
            };
            /** Removing this ComponentRigidbody from the Physiscs.world taking the informations from the oimoPhysics system */
            this.removeRigidbodyFromWorld = () => {
                FudgeCore.Physics.removeRigidbody(this);
                this.isInitialized = false;
            };
            this.create(_mass, _type, _colliderType, _group, _mtxTransform, _convexMesh);
            this.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndEvent);
            // this.addEventListener(EVENT.NODE_DESERIALIZED, this.hndEvent);
        }
        /** ID to reference this specific ComponentRigidbody */
        #id;
        //Private informations - Mostly OimoPhysics variables that should not be exposed to the Fudge User and manipulated by them
        #collider;
        #colliderInfo;
        #collisionGroup;
        #typeCollider;
        #rigidbody;
        #rigidbodyInfo;
        #typeBody;
        #massData;
        #restitution;
        #friction;
        #dampingLinear;
        #dampingAngular;
        #effectRotation;
        #effectGravity;
        #isTrigger;
        #mtxPivotUnscaled;
        #mtxPivotInverse;
        #callbacks; //Callback Methods when within the oimoSystem a event is happening
        //#region Accessors
        get id() {
            return this.#id;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotInverse() {
            return this.#mtxPivotInverse;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotUnscaled() {
            return this.#mtxPivotUnscaled;
        }
        /** Retrieve the body type. See {@link BODY_TYPE} */
        get typeBody() {
            return this.#typeBody;
        }
        /** Set the body type. See {@link BODY_TYPE} */
        set typeBody(_value) {
            this.#typeBody = _value;
            this.#rigidbody.setType(ComponentRigidbody.mapBodyType[this.#typeBody]);
            this.#rigidbody.setMassData(this.#massData); //have to reset mass after changing the type, since Oimo is handling mass internally wrong when switching types
        }
        /** The shape that represents the {@link Node} in the physical world. Default is a Cube. */
        get typeCollider() {
            return this.#typeCollider;
        }
        set typeCollider(_value) {
            if (_value != this.#typeCollider && this.#rigidbody != null) {
                this.#typeCollider = _value;
                this.initialize();
            }
        }
        /** The collision group this {@link Node} belongs to it's the default group normally which means it physically collides with every group besides trigger. */
        get collisionGroup() {
            return this.#collisionGroup;
        }
        set collisionGroup(_value) {
            this.#collisionGroup = _value;
            if (this.#rigidbody != null)
                this.#rigidbody.getShapeList().setCollisionGroup(this.#collisionGroup);
        }
        /** Marking the Body as a trigger therefore not influencing the collision system but only sending triggerEvents */
        get isTrigger() {
            return this.#isTrigger;
        }
        set isTrigger(_value) {
            this.#isTrigger = _value;
            if (this.getOimoRigidbody() != null) {
                this.getOimoRigidbody()._isTrigger = this.#isTrigger;
            }
        }
        /**
         * Returns the physical weight of the {@link Node}
         */
        get mass() {
            return this.#rigidbody.getMass();
        }
        /**
         * Setting the physical weight of the {@link Node} in kg
         */
        set mass(_value) {
            this.#massData.mass = _value;
            if (this.node != null)
                if (this.#rigidbody != null)
                    this.#rigidbody.setMassData(this.#massData);
        }
        /** Drag of linear movement. A Body does slow down even on a surface without friction. */
        get dampTranslation() {
            return this.#rigidbody.getLinearDamping();
        }
        set dampTranslation(_value) {
            this.#dampingLinear = _value;
            this.#rigidbody.setLinearDamping(_value);
        }
        /** Drag of rotation. */
        get dampRotation() {
            return this.#rigidbody.getAngularDamping();
        }
        set dampRotation(_value) {
            this.#dampingAngular = _value;
            this.#rigidbody.setAngularDamping(_value);
        }
        /** The factor this rigidbody reacts rotations that happen in the physical world. 0 to lock rotation this axis. */
        get effectRotation() {
            return this.#effectRotation;
        }
        set effectRotation(_effect) {
            this.#effectRotation = _effect;
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** The factor this rigidbody reacts to world gravity. Default = 1 e.g. 1*9.81 m/s. */
        get effectGravity() {
            return this.#effectGravity;
        }
        set effectGravity(_effect) {
            this.#effectGravity = _effect;
            if (this.#rigidbody != null)
                this.#rigidbody.setGravityScale(this.#effectGravity);
        }
        /**
         * Get the friction of the rigidbody, which is the factor of sliding resistance of this rigidbody on surfaces
         */
        get friction() {
            return this.#friction;
        }
        /**
         * Set the friction of the rigidbody, which is the factor of  sliding resistance of this rigidbody on surfaces
         */
        set friction(_friction) {
            this.#friction = _friction;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setFriction(this.#friction);
        }
        /**
         * Get the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        get restitution() {
            return this.#restitution;
        }
        /**
         * Set the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        set restitution(_restitution) {
            this.#restitution = _restitution;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setRestitution(this.#restitution);
        }
        //#region Transformation
        /**
         * Returns the rigidbody in the form the physics engine is using it, should not be used unless a functionality
         * is not provided through the FUDGE Integration.
         */
        getOimoRigidbody() {
            return this.#rigidbody;
        }
        /** Rotating the rigidbody therefore changing it's rotation over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incremental changing it instead of a direct rotation.  Although it's always prefered to use forces in physics.
         */
        rotateBody(_rotationChange) {
            this.#rigidbody.rotateXyz(new OIMO.Vec3(_rotationChange.x * Math.PI / 180, _rotationChange.y * Math.PI / 180, _rotationChange.z * Math.PI / 180));
        }
        /** Translating the rigidbody therefore changing it's place over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incrementally changing it instead of a direct position. Although it's always prefered to use forces in physics.
         */
        translateBody(_translationChange) {
            this.#rigidbody.translate(new OIMO.Vec3(_translationChange.x, _translationChange.y, _translationChange.z));
        }
        /**
         * Get the current POSITION of the {@link Node} in the physical space
         */
        getPosition() {
            let tmpPos = this.#rigidbody.getPosition();
            return new FudgeCore.Vector3(tmpPos.x, tmpPos.y, tmpPos.z);
        }
        /**
         * Sets the current POSITION of the {@link Node} in the physical space
         */
        setPosition(_value) {
            this.#rigidbody.setPosition(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Get the current ROTATION of the {@link Node} in the physical space. Note this range from -pi to pi, so -90 to 90.
         */
        getRotation() {
            let orientation = this.#rigidbody.getOrientation();
            let tmpQuat = new FudgeCore.Quaternion(orientation.x, orientation.y, orientation.z, orientation.w);
            return tmpQuat.toDegrees();
        }
        /**
         * Sets the current ROTATION of the {@link Node} in the physical space, in degree.
         */
        setRotation(_value) {
            let quat = new OIMO.Quat();
            let mtxRot = FudgeCore.Matrix4x4.IDENTITY();
            mtxRot.rotate(new FudgeCore.Vector3(_value.x, _value.y, _value.z));
            let array = mtxRot.get();
            let rot = new OIMO.Mat3(array[0], array[4], array[8], array[1], array[5], array[9], array[2], array[6], array[10]);
            quat.fromMat3(rot);
            // quat.normalize();
            this.#rigidbody.setOrientation(quat);
        }
        /** Get the current SCALING in the physical space. */
        getScaling() {
            let scaling = this.node.mtxWorld.scaling.clone;
            scaling.x *= this.mtxPivot.scaling.x;
            scaling.y *= this.mtxPivot.scaling.y;
            scaling.z *= this.mtxPivot.scaling.z;
            return scaling;
        }
        /** Scaling requires the collider to be completely recreated anew */
        setScaling(_value) {
            // let scaling: Vector3 = _value.clone;   
            this.createCollider(new OIMO.Vec3(_value.x / 2, _value.y / 2, _value.z / 2), this.#typeCollider); //recreate the collider
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            let oldCollider = this.#rigidbody.getShapeList();
            this.#rigidbody.addShape(this.#collider); //add new collider, before removing the old, so the rb is never active with 0 colliders
            this.#rigidbody.removeShape(oldCollider); //remove the old collider
            this.#collider.userData = this; //reset the extra information so that this collider knows to which Fudge Component it's connected
            this.#collider.setCollisionGroup(this.collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#collider.setRestitution(this.#restitution);
            this.#collider.setFriction(this.#friction);
            this.#collider.setContactCallback(this.#callbacks);
        }
        /**
         * Initializes the rigidbody according to its initialization setting to match the mesh, the node or its own pivot matrix
         */
        initialize() {
            if (!this.node) // delay initialization until this rigidbody is attached to a node
                return;
            switch (Number(this.initialization)) {
                case BODY_INIT.TO_NODE:
                    this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                    break;
                case BODY_INIT.TO_MESH:
                    let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
                    if (cmpMesh)
                        this.mtxPivot = cmpMesh.mtxPivot.clone;
                    break;
                case BODY_INIT.TO_PIVOT:
                    break;
            }
            let mtxWorld = FudgeCore.Matrix4x4.MULTIPLICATION(this.node.mtxWorld, this.mtxPivot);
            let position = mtxWorld.translation; //Adding the offsets from the pivot
            let rotation = mtxWorld.getEulerAngles();
            let scaling = mtxWorld.scaling;
            //scaling requires collider to be recreated
            this.setScaling(scaling);
            this.#rigidbody.setMassData(this.#massData);
            this.setPosition(position); //set the actual new rotation/position for this Rb again since it's now updated
            this.setRotation(rotation);
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.CONSTRUCTION({ translation: this.mtxPivot.translation, rotation: this.mtxPivot.rotation, scaling: FudgeCore.Vector3.ONE() });
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.INVERSION(this.#mtxPivotUnscaled);
            this.addRigidbodyToWorld();
            this.isInitialized = true;
        }
        //#endregion
        //#region Velocity and Forces
        /**
        * Get the current VELOCITY of the {@link Node}
        */
        getVelocity() {
            let velocity = this.#rigidbody.getLinearVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current VELOCITY of the {@link Node}
         */
        setVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setLinearVelocity(velocity);
        }
        /**
         * Get the current ANGULAR - VELOCITY of the {@link Node}
         */
        getAngularVelocity() {
            let velocity = this.#rigidbody.getAngularVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current ANGULAR - VELOCITY of the {@link Node}
         */
        setAngularVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setAngularVelocity(velocity);
        }
        /**
        * Applies a continous FORCE at the center of the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS.
        * The force is measured in newton, 1kg needs about 10 Newton to fight against gravity.
        */
        applyForce(_force) {
            this.#rigidbody.applyForceToCenter(new OIMO.Vec3(_force.x, _force.y, _force.z));
        }
        /**
        * Applies a continous FORCE at a specific point in the world to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyForceAtPoint(_force, _worldPoint) {
            this.#rigidbody.applyForce(new OIMO.Vec3(_force.x, _force.y, _force.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a continous ROTATIONAL FORCE (Torque) to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyTorque(_rotationalForce) {
            this.#rigidbody.applyTorque(new OIMO.Vec3(_rotationalForce.x, _rotationalForce.y, _rotationalForce.z));
        }
        /**
        * Applies a instant FORCE at a point/rigidbodycenter to the RIGIDBODY in the three dimensions. Considering the rigidbod's MASS
        * Influencing the angular speed and the linear speed.
        */
        applyImpulseAtPoint(_impulse, _worldPoint = null) {
            _worldPoint = _worldPoint != null ? _worldPoint : this.getPosition();
            this.#rigidbody.applyImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a instant FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        * Only influencing it's speed not rotation.
        */
        applyLinearImpulse(_impulse) {
            this.#rigidbody.applyLinearImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z));
        }
        /**
       * Applies a instant ROTATIONAL-FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
       * Only influencing it's rotation.
       */
        applyAngularImpulse(_rotationalImpulse) {
            this.#rigidbody.applyAngularImpulse(new OIMO.Vec3(_rotationalImpulse.x, _rotationalImpulse.y, _rotationalImpulse.z));
        }
        /**
       * Changing the VELOCITY of the RIGIDBODY. Only influencing the linear speed not angular
       */
        addVelocity(_value) {
            this.#rigidbody.addLinearVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
       * Changing the VELOCITY of the RIGIDBODY. Only influencing the angular speed not the linear
       */
        addAngularVelocity(_value) {
            this.#rigidbody.addAngularVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /** Stops the rigidbody from sleeping when movement is too minimal. Decreasing performance, for rarely more precise physics results */
        deactivateAutoSleep() {
            this.#rigidbody.setAutoSleep(false);
        }
        activateAutoSleep() {
            this.#rigidbody.setAutoSleep(true);
        }
        //#endregion
        //#region Collision
        /**
         * Checking for Collision with other Colliders and dispatches a custom event with information about the collider.
         * Automatically called in the RenderManager, no interaction needed.
         */
        checkCollisionEvents() {
            if (!this.isInitialized) // check collisions only if intialization completed
                return;
            let list = this.#rigidbody.getContactLinkList(); //all physical contacts between colliding bodies on this rb
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            let normalImpulse = 0;
            let binormalImpulse = 0;
            let tangentImpulse = 0;
            let colPoint;
            //ADD NEW Collision - That just happened
            for (let i = 0; i < this.#rigidbody.getNumContactLinks(); i++) {
                let collisionManifold = list.getContact().getManifold(); //Manifold = Additional informations about the contact
                objHit = list.getContact().getShape1().userData; //Userdata is used to transfer the ∆í.ComponentRigidbody, it's an empty OimoPhysics Variable
                //Only register the collision on the actual touch, not on "shadowCollide", to register in the moment of impulse calculation
                if (!objHit.isInitialized)
                    continue;
                if (objHit == null || list.getContact().isTouching() == false) // only act if the collision is actual touching, so right at the moment when a impulse is happening, not when shapes overlap
                    return;
                objHit2 = list.getContact().getShape2().userData;
                if (!objHit2.isInitialized)
                    continue;
                if (objHit2 == null || list.getContact().isTouching() == false)
                    return;
                let points = collisionManifold.getPoints(); //All points in the collision where the two bodies are touching, used to calculate the full impact
                let normal = collisionManifold.getNormal();
                if (objHit.getOimoRigidbody() != this.getOimoRigidbody() && this.collisions.indexOf(objHit) == -1) { //Fire, if the hit object is not the Body itself but another and it's not already fired.
                    let colPos = this.collisionCenterPoint(points, collisionManifold.getNumPoints()); //THE point of collision is the first touching point (EXTENSION: could be the center of all touching points combined)
                    colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                    points.forEach((value) => {
                        normalImpulse += value.getNormalImpulse();
                        binormalImpulse += value.getBinormalImpulse();
                        tangentImpulse += value.getTangentImpulse();
                    });
                    this.collisions.push(objHit); //Tell the object that the event for this object does not need to be fired again
                    event = new FudgeCore.EventPhysics("ColliderEnteredCollision" /* COLLISION_ENTER */, objHit, normalImpulse, tangentImpulse, binormalImpulse, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z)); //Building the actual event, with what object did collide and informations about it
                    this.dispatchEvent(event); //Sending the given event
                }
                if (objHit2 != this && this.collisions.indexOf(objHit2) == -1) { //Same as the above but for the case the SECOND hit object is not the body itself
                    let colPos = this.collisionCenterPoint(points, collisionManifold.getNumPoints());
                    colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                    points.forEach((value) => {
                        normalImpulse += value.getNormalImpulse();
                        binormalImpulse += value.getBinormalImpulse();
                        tangentImpulse += value.getTangentImpulse();
                    });
                    this.collisions.push(objHit2);
                    event = new FudgeCore.EventPhysics("ColliderEnteredCollision" /* COLLISION_ENTER */, objHit2, normalImpulse, tangentImpulse, binormalImpulse, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z));
                    this.dispatchEvent(event);
                }
                list = list.getNext(); //Start the same routine with the next collision in the list
            }
            //REMOVE OLD Collisions - That do not happen anymore
            this.collisions.forEach((value) => {
                let isColliding = false;
                list = this.#rigidbody.getContactLinkList();
                for (let i = 0; i < this.#rigidbody.getNumContactLinks(); i++) {
                    objHit = list.getContact().getShape1().userData;
                    objHit2 = list.getContact().getShape2().userData;
                    if (value == objHit || value == objHit2) { //If the given object in the collisions list is still one of the objHit the collision is not CollisionEXIT
                        isColliding = true;
                    }
                    list = list.getNext();
                }
                if (isColliding == false) { //The collision is exiting but was in the collision list, then EXIT Event needs to be fired
                    let index = this.collisions.indexOf(value); //Find object in the array
                    this.collisions.splice(index); //remove it from the array
                    event = new FudgeCore.EventPhysics("ColliderLeftCollision" /* COLLISION_EXIT */, value, 0, 0, 0);
                    this.dispatchEvent(event);
                }
            });
        }
        /**
         * Sends a ray through this specific body ignoring the rest of the world and checks if this body was hit by the ray,
         * returning info about the hit. Provides the same functionality and information a regular raycast does but the ray is only testing against this specific body.
         */
        raycastThisBody(_origin, _direction, _length, _debugDraw = false) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let geometry = this.#rigidbody.getShapeList().getGeometry();
            let transform = this.#rigidbody.getTransform();
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, _origin.clone);
            let oimoRay = new OIMO.RayCastHit();
            let hit = geometry.rayCast(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z), transform, oimoRay); //the actual OimoPhysics Raycast
            if (hit) { //If hit return a bunch of informations about the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(oimoRay.position.x, oimoRay.position.y, oimoRay.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(oimoRay.normal.x, oimoRay.normal.y, oimoRay.normal.z);
                let dx = _origin.x - hitInfo.hitPoint.x; //calculate hit distance
                let dy = _origin.y - hitInfo.hitPoint.y;
                let dz = _origin.z - hitInfo.hitPoint.z;
                hitInfo.hitDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                hitInfo.rigidbodyComponent = this;
                hitInfo.rayOrigin = _origin;
                hitInfo.rayEnd = endpoint;
            }
            else { //Only tell the origin, and the hit point is the end of the ray.
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(endpoint.x, endpoint.y, endpoint.z);
            }
            if (_debugDraw) {
                FudgeCore.Physics.debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        //#endregion
        //#region Saving/Loading - Some properties might be missing, e.g. convexMesh (Float32Array)
        serialize() {
            let serialization = this.getMutator();
            delete serialization.mtxPivot;
            delete serialization.active;
            serialization.typeBody = FudgeCore.BODY_TYPE[this.#typeBody];
            serialization.typeCollider = FudgeCore.COLLIDER_TYPE[this.#typeCollider];
            serialization.initialization = BODY_INIT[this.initialization];
            serialization.id = this.#id;
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            this.mtxPivot.deserialize(_serialization.pivot);
            this.#id = _serialization.id;
            this.mass = ifNumber(_serialization.mass, this.mass);
            this.dampTranslation = ifNumber(_serialization.dampTranslation, this.dampTranslation);
            this.dampRotation = ifNumber(_serialization.dampRotation, this.dampRotation);
            this.collisionGroup = ifNumber(_serialization.collisionGroup, this.collisionGroup);
            this.effectRotation = _serialization.effectRotation || this.effectRotation;
            this.effectGravity = ifNumber(_serialization.effectGravity, this.effectGravity);
            this.friction = ifNumber(_serialization.friction, this.friction);
            this.restitution = ifNumber(_serialization.restitution, this.restitution);
            this.isTrigger = _serialization.isTrigger || this.isTrigger;
            this.initialization = _serialization.initialization;
            this.initialization = BODY_INIT[_serialization.initialization];
            this.typeBody = FudgeCore.BODY_TYPE[_serialization.typeBody];
            this.typeCollider = FudgeCore.COLLIDER_TYPE[_serialization.typeCollider];
            // this.create(this.mass, this.#typeBody, this.#typeCollider, this.collisionGroup, null, this.convexMesh);
            return this;
        }
        /** Change properties by an associative array */
        async mutate(_mutator) {
            if (_mutator.typeBody != undefined)
                _mutator.typeBody = parseInt(_mutator.typeBody);
            if (_mutator.typeCollider != undefined)
                _mutator.typeCollider = parseInt(_mutator.typeCollider);
            if (_mutator.initialization != undefined)
                _mutator.initialization = parseInt(_mutator.initialization);
            await super.mutate(_mutator);
            if (_mutator.initialization != undefined && this.isActive)
                this.initialize();
            // TODO: see if this alternative should be, at least partially, done with mutateSelection
            // let callIfExist: Function = (_key: string, _setter: Function) => {
            //   if (_mutator[_key])
            //     _setter(_mutator[_key]);
            // };
            // callIfExist("friction", (_value: number) => this.friction = _value);
            // callIfExist("restitution", (_value: number) => this.restitution = _value);
            // callIfExist("mass", (_value: number) => this.mass = _value);
            // callIfExist("dampTranslation", (_value: number) => this.dampTranslation = _value);
            // callIfExist("dampRotation", (_value: number) => this.dampRotation = _value);
            // callIfExist("effectGravity", (_value: number) => this.effectGravity = _value);
            // callIfExist("collisionGroup", (_value: COLLISION_GROUP) => this.collisionGroup = _value);
            // callIfExist("typeBody", (_value: string) => this.typeBody = parseInt(_value));
            // callIfExist("typeCollider", (_value: string) => this.typeCollider = parseInt(_value));
            // this.dispatchEvent(new Event(EVENT.MUTATE));
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.friction = this.friction;
            mutator.restitution = this.restitution;
            mutator.mass = this.mass;
            mutator.dampTranslation = this.dampTranslation;
            mutator.dampRotation = this.dampRotation;
            mutator.effectGravity = this.effectGravity;
            mutator.typeBody = this.#typeBody;
            mutator.typeCollider = this.#typeCollider;
            mutator.isTrigger = this.#isTrigger;
            // Object.preventExtensions(mutator);
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.typeBody)
                types.typeBody = FudgeCore.BODY_TYPE;
            if (types.typeCollider)
                types.typeCollider = FudgeCore.COLLIDER_TYPE;
            if (types.initialization)
                types.initialization = BODY_INIT;
            return types;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.convexMesh; //Convex Mesh can't be shown in the editor because float32Array is not a viable mutator
            delete _mutator.collisionMask;
            delete _mutator.isInitialized;
        }
        //#endregion
        //#region Creation
        create(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            //Setting up all incoming values to be internal values
            this.convexMesh = _convexMesh;
            this.#typeBody = _type;
            this.#collisionGroup = _group;
            this.#typeCollider = _colliderType;
            this.mass = _mass;
            this.#restitution = FudgeCore.Physics.settings.defaultRestitution;
            this.#friction = FudgeCore.Physics.settings.defaultFriction;
            this.collisionMask = FudgeCore.Physics.settings.defaultCollisionMask;
            //Create the actual rigidbody in the OimoPhysics Space
            this.createRigidbody(_mass, _type, this.#typeCollider, _mtxTransform, this.#collisionGroup);
            this.#id = FudgeCore.Physics.distributeBodyID();
            // Event Callbacks directly from OIMO Physics
            this.#callbacks = new OIMO.ContactCallback(); //fehm
            this.#callbacks.beginTriggerContact = this.triggerEnter;
            this.#callbacks.endTriggerContact = this.triggerExit;
        }
        /** Creates the actual OimoPhysics Rigidbody out of informations the Fudge Component has. */
        createRigidbody(_mass, _type, _colliderType, _mtxTransform, _collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let oimoType; //Need the conversion from simple enum to number because if enum is defined as Oimo.RigidyBodyType you have to include Oimo to use FUDGE at all
            switch (_type) {
                case FudgeCore.BODY_TYPE.DYNAMIC:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
                case FudgeCore.BODY_TYPE.STATIC:
                    oimoType = OIMO.RigidBodyType.STATIC;
                    break;
                case FudgeCore.BODY_TYPE.KINEMATIC:
                    oimoType = OIMO.RigidBodyType.KINEMATIC;
                    break;
                default:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
            }
            // remove all previous shapes from world. Necessary?
            // while (this.#rigidbody && this.#rigidbody.getShapeList() != null)
            //   this.#rigidbody.removeShape(this.#rigidbody.getShapeList());
            let tmpTransform = _mtxTransform == null ? super.node != null ? super.node.mtxWorld : FudgeCore.Matrix4x4.IDENTITY() : _mtxTransform; //Get transform informations from the world, since physics does not care about hierarchy
            //Convert informations from Fudge to OimoPhysics and creating a collider with it, while also adding a pivot to derivate from the transform informations if needed
            let scale = new OIMO.Vec3((tmpTransform.scaling.x * this.mtxPivot.scaling.x) / 2, (tmpTransform.scaling.y * this.mtxPivot.scaling.y) / 2, (tmpTransform.scaling.z * this.mtxPivot.scaling.z) / 2);
            let position = new OIMO.Vec3(tmpTransform.translation.x + this.mtxPivot.translation.x, tmpTransform.translation.y + this.mtxPivot.translation.y, tmpTransform.translation.z + this.mtxPivot.translation.z);
            let rotation = new OIMO.Vec3(tmpTransform.rotation.x + this.mtxPivot.rotation.x, tmpTransform.rotation.y + this.mtxPivot.rotation.y, tmpTransform.rotation.z + this.mtxPivot.rotation.z);
            this.createCollider(scale, _colliderType);
            //Setting informations about mass, position/rotation and physical reaction type
            this.#massData.mass = _mass; //_type != PHYSICS_TYPE.STATIC ? _mass : 0; //If a object is static it acts as if it has no mass
            this.#rigidbodyInfo.type = oimoType;
            this.#rigidbodyInfo.position = position;
            this.#rigidbodyInfo.rotation.fromEulerXyz(new OIMO.Vec3(rotation.x, rotation.y, rotation.z)); //Convert eulerAngles in degree to the internally used quaternions
            //Creating the actual rigidbody and it's collider
            this.#rigidbody = new OIMO.RigidBody(this.#rigidbodyInfo);
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            //Filling the additional settings and informations the rigidbody needs. Who is colliding, how is the collision handled (damping, influence factors)
            this.#collider.userData = this;
            this.#collider.setCollisionGroup(_collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#rigidbody.addShape(this.#collider);
            this.#rigidbody.setMassData(this.#massData);
            this.#rigidbody.getShapeList().setRestitution(this.#restitution);
            this.#rigidbody.getShapeList().setFriction(this.#friction);
            this.#rigidbody.getShapeList().setContactCallback(this.#callbacks);
            this.#rigidbody.setLinearDamping(this.#dampingLinear);
            this.#rigidbody.setAngularDamping(this.#dampingAngular);
            this.#rigidbody.setGravityScale(this.#effectGravity);
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** Creates a collider a shape that represents the object in the physical world.  */
        createCollider(_scale, _colliderType) {
            let shapeConf = new OIMO.ShapeConfig(); //Collider with geometry and infos like friction/restitution and more
            let geometry;
            if (this.typeCollider != _colliderType) //If the collider type was changed set the internal one new, else don't so there is not infinite set calls
                this.typeCollider = _colliderType;
            switch (_colliderType) { //Create a different OimoPhysics geometry based on the given type. That is only the mathematical shape of the collider
                case FudgeCore.COLLIDER_TYPE.CUBE:
                    geometry = new OIMO.BoxGeometry(_scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.SPHERE:
                    geometry = new OIMO.SphereGeometry(_scale.x);
                    break;
                case FudgeCore.COLLIDER_TYPE.CAPSULE:
                    geometry = new OIMO.CapsuleGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CYLINDER:
                    geometry = new OIMO.CylinderGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONE:
                    geometry = new OIMO.ConeGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.PYRAMID:
                    geometry = this.createConvexGeometryCollider(this.createPyramidVertices(), _scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONVEX:
                    geometry = this.createConvexGeometryCollider(this.convexMesh, _scale);
                    break;
            }
            shapeConf.geometry = geometry;
            this.#colliderInfo = shapeConf; //the configuration informations that are used to add an actual collider to the rigidbody in createRigidbody
        }
        /** Creating a shape that represents a in itself closed form, out of the given vertices. */
        createConvexGeometryCollider(_vertices, _scale) {
            let verticesAsVec3 = new Array(); //Convert Fudge Vector3 to OimoVec3
            for (let i = 0; i < _vertices.length; i += 3) { //3 Values for one point
                verticesAsVec3.push(new OIMO.Vec3(_vertices[i] * _scale.x, _vertices[i + 1] * _scale.y, _vertices[i + 2] * _scale.z));
            }
            return new OIMO.ConvexHullGeometry(verticesAsVec3); //Tell OimoPhysics to create a hull that involves all points but close it of. A convex shape can not have a hole in it.
        }
        /** Internal implementation of vertices that construct a pyramid. The vertices of the implemented pyramid mesh can be used too. But they are halfed and double sided, so it's more performant to use this. */
        createPyramidVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                /*4*/ 0, 2, 0
            ]);
            return vertices;
        }
        //#region private EVENT functions
        //Calculating the center of a collision as a singular point - in case there is more than one point - by getting the geometrical center of all colliding points
        collisionCenterPoint(_colPoints, _numPoints) {
            let center;
            let totalPoints = 0;
            let totalX = 0;
            let totalY = 0;
            let totalZ = 0;
            _colPoints.forEach((value) => {
                if (totalPoints < _numPoints) {
                    totalPoints++;
                    totalX += value.getPosition2().x;
                    totalY += value.getPosition2().y;
                    totalZ += value.getPosition2().z;
                }
            });
            center = new OIMO.Vec3(totalX / _numPoints, totalY / _numPoints, totalZ / _numPoints);
            return center;
        }
        //#endregion
        /**
        * Trigger EnteringEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the Fudge OIMO Fork!)
        */
        triggerEnter(contact) {
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            let colPoint;
            //ADD NEW Triggering - That just happened
            let collisionManifold = contact.getManifold(); //Manifold = Additional informations about the contact
            objHit = contact.getShape1().userData; //Userdata is used to transfer the ∆í.ComponentRigidbody, it's an empty OimoPhysics Variable
            //Only register the collision on the actual touch, not on "shadowCollide", to register in the moment of impulse calculation
            if (objHit == null || contact.isTouching() == false) // only act if the collision is actual touching, so right at the moment when a impulse is happening, not when shapes overlap
                return;
            objHit2 = contact.getShape2().userData;
            if (objHit2 == null || contact.isTouching() == false)
                return;
            let points = collisionManifold.getPoints(); //All points in the collision where the two bodies are touching, used to calculate the full impact
            let normal = collisionManifold.getNormal();
            if (objHit2.triggerings.indexOf(objHit) == -1) { //Fire, if the hit object is not the Body itself but another and it's not already fired.
                let colPos = objHit2.collisionCenterPoint(points, collisionManifold.getNumPoints()); //THE point of collision is the first touching point (EXTENSION: could be the center of all touching points combined)
                colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                // Impulses are 0 since, there are no forces/impulses at work, else this would not be a trigger, but a collision
                objHit2.triggerings.push(objHit); //Tell the object that the event for this object does not need to be fired again
                event = new FudgeCore.EventPhysics("TriggerEnteredCollision" /* TRIGGER_ENTER */, objHit, 0, 0, 0, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z)); //Building the actual event, with what object did collide and informations about it
                objHit2.dispatchEvent(event); //Sending the given event
            }
            if (objHit.triggerings.indexOf(objHit2) == -1) { //Same as the above but for the case the SECOND hit object is not the body itself
                let colPos = objHit.collisionCenterPoint(points, collisionManifold.getNumPoints());
                colPoint = new FudgeCore.Vector3(colPos.x, colPos.y, colPos.z);
                // Impulses are 0 since, there are no forces/impulses at work, else this would not be a trigger, but a collision,
                // also the event is handled before the actual solving impulse step in OIMO
                objHit.triggerings.push(objHit2);
                event = new FudgeCore.EventPhysics("TriggerEnteredCollision" /* TRIGGER_ENTER */, objHit2, 0, 0, 0, colPoint, new FudgeCore.Vector3(normal.x, normal.y, normal.z));
                objHit.dispatchEvent(event);
            }
        }
        /**
        * Trigger LeavingEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the Fudge OIMO Fork!)
        */
        triggerExit(contact) {
            //REMOVE OLD Triggering Body
            let objHit; //collision consisting of 2 bodies, so Hit1/2
            let objHit2;
            let event; //The event that will be send and the informations added to it
            objHit = contact.getShape1().userData;
            objHit2 = contact.getShape2().userData;
            // Remove both bodies in both cases, of self and other
            let index = objHit.triggerings.indexOf(objHit2); //Find object in the array
            if (index != -1) {
                objHit.triggerings.splice(index); //remove it from the array
                event = new FudgeCore.EventPhysics("TriggerLeftCollision" /* TRIGGER_EXIT */, objHit2, 0, 0, 0);
                objHit.dispatchEvent(event);
            }
            index = objHit2.triggerings.indexOf(objHit); //Find object in the array
            if (index != -1) {
                objHit2.triggerings.splice(index); //remove it from the array
                event = new FudgeCore.EventPhysics("TriggerLeftCollision" /* TRIGGER_EXIT */, objHit, 0, 0, 0);
                objHit2.dispatchEvent(event);
            }
        }
    }
    ComponentRigidbody.iSubclass = FudgeCore.Component.registerSubclass(ComponentRigidbody);
    ComponentRigidbody.mapBodyType = (typeof OIMO == "undefined") ?
        {
            [FudgeCore.BODY_TYPE.DYNAMIC]: FudgeCore.BODY_TYPE.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: FudgeCore.BODY_TYPE.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: FudgeCore.BODY_TYPE.KINEMATIC
        } : {
        [FudgeCore.BODY_TYPE.DYNAMIC]: OIMO.RigidBodyType.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: OIMO.RigidBodyType.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: OIMO.RigidBodyType.KINEMATIC
    };
    FudgeCore.ComponentRigidbody = ComponentRigidbody;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Internal class for holding data about physics debug vertices.*/
    class PhysicsDebugVertexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.numVertices = 0;
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data. Used at buffer initialization */
        setData(array) {
            if (this.attribs == null)
                throw "set attributes first";
            this.numVertices = array.length / (this.stride / 4);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(array), this.gl.DYNAMIC_DRAW);
            //not necessary an in webgl2 anymore to rebind the same last buffer (which is achieved by giving a null buffer), after buffer is changed. Removed it on all other occasions
            // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); 
        }
        /** Set Shader Attributes informations by getting their position in the shader, setting the offset, stride and size. For later use in the binding process */
        setAttribs(attribs) {
            this.attribs = attribs;
            this.offsets = [];
            this.stride = 0;
            let n = attribs.length;
            for (let i = 0; i < n; i++) {
                this.offsets.push(this.stride);
                this.stride += attribs[i].float32Count * Float32Array.BYTES_PER_ELEMENT; // 32bit float Bytes are a constant of 4
            }
        }
        /** Get the position of the attribute in the shader */
        loadAttribIndices(_program) {
            this.indices = _program.getAttribIndices(this.attribs);
        }
        /** Enable a attribute in a shader for this context, */
        bindAttribs() {
            if (this.indices == null)
                throw "indices are not loaded";
            let n = this.attribs.length;
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer); //making the buffer of this class the current buffer
            for (let i = 0; i < n; i++) {
                this.gl.enableVertexAttribArray(this.indices[i]); //enable the Attribute
                this.gl.vertexAttribPointer(this.indices[i], this.attribs[i].float32Count, this.gl.FLOAT, false, this.stride, this.offsets[i]); //creates a pointer and structure for this attribute
            }
        }
    }
    FudgeCore.PhysicsDebugVertexBuffer = PhysicsDebugVertexBuffer;
    /** Internal class for holding data about PhysicsDebugVertexBuffers */
    class PhysicsDebugIndexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data amount. Used at buffer initialization */
        setData(array) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(array), this.gl.DYNAMIC_DRAW);
            this.count = array.length;
        }
        /** The actual DrawCall for physicsDebugDraw Buffers. This is where the information from the debug is actually drawn. */
        draw(_mode = this.gl.TRIANGLES, _count = -1) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.drawElements(_mode, _count >= 0 ? _count : this.count, this.gl.UNSIGNED_SHORT, 0);
        }
    }
    FudgeCore.PhysicsDebugIndexBuffer = PhysicsDebugIndexBuffer;
    /** Internal class for managing data about webGL Attributes */
    class PhysicsDebugVertexAttribute {
        constructor(_float32Count, _name) {
            this.name = _name;
            this.float32Count = _float32Count;
        }
    }
    FudgeCore.PhysicsDebugVertexAttribute = PhysicsDebugVertexAttribute;
    /** Internal class for Shaders used only by the physics debugDraw */
    class PhysicsDebugShader {
        /** Introduce the Fudge Rendering Context to this class, creating a program and vertex/fragment shader in this context */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.program = this.gl.createProgram();
            this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        }
        /** Take glsl shaders as strings and compile them, attaching the compiled shaders to a program thats used by this rendering context. */
        compile(vertexSource, fragmentSource) {
            this.uniformLocationMap = new Map();
            this.compileShader(this.vertexShader, vertexSource);
            this.compileShader(this.fragmentShader, fragmentSource);
            this.gl.attachShader(this.program, this.vertexShader);
            this.gl.attachShader(this.program, this.fragmentShader);
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) { //make sure the linking worked, so the program is valid, and shaders are working
                FudgeCore.Debug.log(this.gl.getProgramInfoLog(this.program));
            }
            this.gl.validateProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.VALIDATE_STATUS)) {
                console.error("ERROR validating program!", this.gl.getProgramInfoLog(this.program));
                return;
            }
        }
        /** Get index of a attribute in a shader in this program */
        getAttribIndex(_name) {
            return this.gl.getAttribLocation(this.program, _name);
        }
        /** Get the location of a uniform in a shader in this program */
        getUniformLocation(_name) {
            if (this.uniformLocationMap.has(_name))
                return this.uniformLocationMap.get(_name);
            let location = this.gl.getUniformLocation(this.program, _name);
            this.uniformLocationMap.set(_name, location);
            return location;
        }
        /** Get all indices for every attribute in the shaders of this program */
        getAttribIndices(_attribs) {
            let indices = [];
            _attribs.forEach(value => {
                indices.push(this.getAttribIndex(value.name));
            });
            return indices;
        }
        /** Tell the Fudge Rendering Context to use this program to draw. */
        use() {
            this.gl.useProgram(this.program);
        }
        /** Compile a shader out of a string and validate it. */
        compileShader(shader, source) {
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                FudgeCore.Debug.log(this.gl.getShaderInfoLog(shader));
            }
        }
    }
    FudgeCore.PhysicsDebugShader = PhysicsDebugShader;
    /** Internal Class used to draw debugInformations about the physics simulation onto the renderContext. No user interaction needed.
     * @author Marko Fehrenbach, HFU 2020 //Based on OimoPhysics Haxe DebugDrawDemo
     */
    class PhysicsDebugDraw extends FudgeCore.RenderWebGL {
        /** Creating the debug for physics in Fudge. Tell it to draw only wireframe objects, since Fudge is handling rendering of the objects besides physics.
         * Override OimoPhysics Functions with own rendering. Initialize buffers and connect them with the context for later use. */
        constructor() {
            super();
            this.style = new OIMO.DebugDrawStyle();
            this.oimoDebugDraw = new OIMO.DebugDraw();
            this.oimoDebugDraw.wireframe = true; //Triangle Rendering is handled by FUDGE so, only the physics lines/points need to be rendered, although triangle is still implemented
            this.gl = FudgeCore.RenderWebGL.crc3;
            this.initializeOverride();
            this.shader = new PhysicsDebugShader(this.gl);
            this.shader.compile(this.vertexShaderSource(), this.fragmentShaderSource());
            this.initializeBuffers();
        }
        /** Receive the current DebugMode from the physics settings and set the OimoPhysics.DebugDraw booleans to show only certain informations.
         * Needed since some debug informations exclude others, and can't be drawn at the same time, by OimoPhysics. And for users it provides more readability
         * to debug only what they need and is commonly debugged.
         */
        setDebugMode(_mode = FudgeCore.PHYSICS_DEBUGMODE.NONE) {
            // tslint:disable-next-line
            let draw = { drawAabbs: false, drawBases: false, drawBvh: false, drawContactBases: false, drawContacts: false, drawJointLimits: false, drawJoints: false, drawPairs: false, drawShapes: false };
            switch (_mode) {
                case FudgeCore.PHYSICS_DEBUGMODE.COLLIDERS: //Colliders and Bases
                    draw.drawBases = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.JOINTS_AND_COLLIDER: //Colliders and joints
                    draw.drawJoints = draw.drawJointLimits = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY: //Physics Objects only, shows same as Collider / Joints but also hiding every other fudge object
                    draw.drawBases = draw.drawJointLimits = draw.drawJoints = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.CONTACTS: //Contacts
                    draw.drawBases = draw.drawContactBases = draw.drawContacts = draw.drawPairs = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.BOUNDING_BOXES: //Bounding Box / Broadphase Bvh / Bases
                    draw.drawAabbs = draw.drawBases = draw.drawBvh = true;
                    break;
            }
            Object.assign(this.oimoDebugDraw, draw);
        }
        /** Creating the empty render buffers. Defining the attributes used in shaders.
         * Needs to create empty buffers to already have them ready to draw later on, linking is only possible with existing buffers. */
        initializeBuffers() {
            let attribs = [
                new PhysicsDebugVertexAttribute(3, "aPosition"),
                new PhysicsDebugVertexAttribute(3, "aNormal"),
                new PhysicsDebugVertexAttribute(3, "aColor")
            ];
            this.pointVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.pointIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.pointVBO.setAttribs(attribs);
            this.pointVBO.loadAttribIndices(this.shader);
            this.lineVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.lineIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.lineVBO.setAttribs(attribs);
            this.lineVBO.loadAttribIndices(this.shader);
            this.triVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.triIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.triVBO.setAttribs(attribs);
            this.triVBO.loadAttribIndices(this.shader);
            this.clearBuffers();
        }
        /** Before OimoPhysics.world is filling the debug. Make sure the buffers are reset. Also receiving the debugMode from settings and updating the current projection for the vertexShader. */
        clearBuffers() {
            this.gl.lineWidth(2.0); //Does not affect anything because lineWidth is currently only supported by Microsoft Edge and Fudge is optimized for Chrome
            this.pointData = []; //Resetting the data to be filled again
            this.lineData = [];
            this.triData = [];
            this.numPointData = 0; //Resetting the amount of data calls
            this.numLineData = 0;
            this.numTriData = 0;
        }
        /** After OimoPhysics.world filled the debug. Rendering calls. Setting this program to be used by the Fudge rendering context. And draw each updated buffer and resetting them. */
        drawBuffers() {
            this.shader.use();
            let projection = FudgeCore.Physics.mainCam.mtxWorldToView.get();
            this.gl.uniformMatrix4fv(this.shader.getUniformLocation("u_mtxMeshToView"), false, projection);
            if (this.numPointData > 0) {
                this.pointIboData = []; //Buffer size matching to whats needed
                for (let i = 0; i < this.numPointData; i++) {
                    this.pointIboData.push(i);
                }
                this.pointIBO.setData(this.pointIboData); //Set Index buffer to correct size
                this.pointVBO.setData(this.pointData); //Set Vertex Buffer to current Data
                this.pointVBO.bindAttribs();
                this.pointIBO.draw(this.gl.POINTS, this.numPointData); //The actual draw call for each index in ibo
                this.numPointData = 0;
            }
            if (this.numLineData > 0) {
                this.lineIboData = [];
                for (let i = 0; i < this.numLineData; i++) {
                    this.lineIboData.push(i * 2);
                    this.lineIboData.push(i * 2 + 1);
                }
                this.lineIBO.setData(this.lineIboData);
                this.lineVBO.setData(this.lineData);
                this.lineVBO.bindAttribs();
                this.lineIBO.draw(this.gl.LINES, this.numLineData * 2);
                this.numLineData = 0;
            }
            if (this.numTriData > 0) {
                this.triIboData = [];
                for (let i = 0; i < this.numTriData; i++) {
                    this.triIboData.push(i * 3);
                    this.triIboData.push(i * 3 + 1);
                    this.triIboData.push(i * 3 + 2);
                }
                this.triIBO.setData(this.triIboData);
                this.triVBO.setData(this.triData);
                this.triVBO.bindAttribs();
                this.triIBO.draw(this.gl.TRIANGLES, this.numTriData * 3);
                this.numTriData = 0;
            }
        }
        /** Drawing the ray into the debugDraw Call. By using the overwritten line rendering functions and drawing a point (pointSize defined in the shader) at the end of the ray. */
        debugRay(_origin, _end, _color) {
            this.oimoDebugDraw.line(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
            this.oimoDebugDraw.point(new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
        }
        /** Overriding the existing functions from OimoPhysics.DebugDraw without actually inherit from the class, to avoid compiler problems.
         * Overriding them to receive debugInformations in the format the physic engine provides them but handling the rendering in the fudge context. */
        initializeOverride() {
            //Override point/line/triangle functions of OimoPhysics which are used to draw wireframes of objects, lines of raycasts or triangles when the objects are rendered by the physics not FUDGE (unused)
            OIMO.DebugDraw.prototype.point = function (_v, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw; //Get the custom physics debug class to have access to the data.
                if (FudgeCore.Physics.mainCam != null) { //only act when there is a camera that is rendering
                    let data = debugWrapper.pointData; //get the already written buffer informations
                    data.push(_v.x, _v.y, _v.z); //Coordinates of the point
                    data.push(0, 0, 0); //Point Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //Color of the point
                    debugWrapper.numPointData++;
                }
            };
            OIMO.DebugDraw.prototype.line = function (_v1, _v2, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.lineData;
                    data.push(_v1.x, _v1.y, _v1.z); //Point 1 Coordinates
                    data.push(0, 0, 0); //P1 Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //P1 Color
                    data.push(_v2.x, _v2.y, _v2.z); //Point 2 Coordinates
                    data.push(0, 0, 0);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numLineData++;
                }
            };
            OIMO.DebugDraw.prototype.triangle = function (_v1, _v2, _v3, _n1, _n2, _n3, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.triData;
                    data.push(_v1.x, _v1.y, _v1.z);
                    data.push(_n1.x, _n1.y, _n1.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v2.x, _v2.y, _v2.z);
                    data.push(_n2.x, _n2.y, _n2.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v3.x, _v3.y, _v3.z);
                    data.push(_n3.x, _n3.y, _n3.z);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numTriData++;
                }
            };
        }
        /** The source code (string) of the in physicsDebug used very simple vertexShader.
         *  Handling the projection (which includes, view/world[is always identity in this case]/projection in Fudge). Increasing the size of single points drawn.
         *  And transfer position color to the fragmentShader. */
        vertexShaderSource() {
            return `
			precision mediump float;
			attribute vec3 aPosition;
			attribute vec3 aColor;
			attribute vec3 aNormal;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;
			uniform mat4 u_mtxMeshToView;

			void main() {
				vPosition = aPosition;
				vColor = aColor;
				vNormal = aNormal;
				gl_Position = u_mtxMeshToView * vec4(aPosition,1.0);
				gl_PointSize = 6.0;
			}`;
        }
        /** The source code (string) of the in physicsDebug used super simple fragmentShader. Unlit - only colorizing the drawn pixels, normals/position are given to make it expandable */
        fragmentShaderSource() {
            return `
      precision mediump float;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(vColor, 1.0);
			}`;
        }
    }
    FudgeCore.PhysicsDebugDraw = PhysicsDebugDraw;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A physical connection between two bodies with a defined axe of translation and rotation. Two Degrees of Freedom in the defined axis.
     * Two RigidBodies need to be defined to use it. A motor can be defined for rotation and translation, along with spring settings.
     *
     * ```plaintext
     *          JointHolder - bodyAnchor
     *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
     *                    ‚îÇ   ‚îÇ
     *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on axis = 1st degree of freedom
     *                    ‚îÇ   ‚îÇ        rotating around axis = 2nd degree of freedom
     *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointCylindrical extends FudgeCore.JointAxial {
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.#springDampingRotation = 0;
            this.#springFrequencyRotation = 0;
            this.#motorForce = 0;
            this.#maxRotor = 360;
            this.#minRotor = 0;
            this.#rotorTorque = 0;
            this.#rotorSpeed = 0;
            this.config = new OIMO.CylindricalJointConfig();
            this.#getMutator = () => {
                let mutator = {
                    motorForce: this.motorForce,
                    springDampingRotation: this.springDampingRotation,
                    springFrequencyRotation: this.springFrequencyRotation,
                    maxRotor: this.maxRotor,
                    minRotor: this.minRotor,
                    rotorTorque: this.rotorTorque,
                    rotorSpeed: this.rotorSpeed
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["motorForce", "rotorTorque", "rotorSpeed", "maxRotor", "minRotor", "springDampingRotation", "springFrequencyRotation", "springFrequency"]);
            };
        }
        #springDampingRotation;
        #springFrequencyRotation;
        #motorForce;
        #maxRotor;
        #minRotor;
        #rotorTorque;
        #rotorSpeed;
        #rotor;
        #rotorSpringDamper;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        set springDamping(_value) {
            super.springDamping = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        set springFrequency(_value) {
            super.springFrequency = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().frequency = _value;
        }
        /**
        * The damping of the spring. 1 equals completly damped. Influencing TORQUE / ROTATION
        */
        get springDampingRotation() {
            return this.#springDampingRotation;
        }
        set springDampingRotation(_value) {
            this.#springDampingRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. Influencing TORQUE / ROTATION
        */
        get springFrequencyRotation() {
            return this.#springFrequencyRotation;
        }
        set springFrequencyRotation(_value) {
            this.#springFrequencyRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotor() {
            return this.#maxRotor;
        }
        set maxRotor(_value) {
            this.#maxRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().upperLimit = _value * Math.PI / 180;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotor() {
            return this.#minRotor;
        }
        set minRotor(_value) {
            this.#minRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeed() {
            return this.#rotorSpeed;
        }
        set rotorSpeed(_value) {
            this.#rotorSpeed = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorque() {
            return this.#rotorTorque;
        }
        set rotorTorque(_value) {
            this.#rotorTorque = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorTorque = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().lowerLimit = _value;
        }
        set motorSpeed(_value) {
            super.motorSpeed = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.#rotorSpringDamper = new OIMO.SpringDamper().setSpring(this.springFrequencyRotation, this.springDampingRotation);
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(super.minMotor, super.maxMotor);
            this.motor.setMotor(super.motorSpeed, this.motorForce);
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(this.minRotor * Math.PI / 180, this.maxRotor * Math.PI / 180);
            this.#rotor.setMotor(this.rotorSpeed, this.rotorTorque);
            this.config = new OIMO.CylindricalJointConfig();
            super.constructJoint();
            this.config.translationalSpringDamper = this.springDamper;
            this.config.translationalLimitMotor = this.motor;
            this.config.rotationalLimitMotor = this.#rotor;
            this.config.rotationalSpringDamper = this.#rotorSpringDamper;
            this.joint = new OIMO.CylindricalJoint(this.config);
            this.configureJoint();
        }
    }
    JointCylindrical.iSubclass = FudgeCore.Joint.registerSubclass(JointCylindrical);
    FudgeCore.JointCylindrical = JointCylindrical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe movement.
       * Used to create a sliding joint along one axis. Two RigidBodies need to be defined to use it.
       * A motor can be defined to move the connected along the defined axis. Great to construct standard springs or physical sliders.
       *
       * ```plaintext
       *          JointHolder - bodyAnchor
       *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
       *                    ‚îÇ   ‚îÇ
       *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on one Axis, 1 Degree of Freedom
       *                    ‚îÇ   ‚îÇ
       *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointPrismatic extends FudgeCore.JointAxial {
        //Internally used variables - Joint Properties that are used even when no actual joint is currently existend
        /** Creating a prismatic joint between two ComponentRigidbodies only moving on one axis bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.#motorForce = 0;
            this.config = new OIMO.PrismaticJointConfig();
            this.maxMotor = 10;
            this.minMotor = -10;
        }
        #motorForce;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled. This is the force that the motor is using to hold the position, or reach it if a motorSpeed is defined.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorForce: this.motorForce,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorForce = _serialization.motorForce;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorForce = this.motorForce;
            return mutator;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.motorForce) !== "undefined")
                this.motorForce = _mutator.motorForce;
            delete _mutator.motorForce;
            super.mutate(_mutator);
        }
        //#endregion
        /** Actual creation of a joint in the OimoPhysics system */
        constructJoint() {
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(this.minMotor, this.maxMotor); //Create motor settings, to hold positions, set constraint min/max
            this.motor.setMotor(this.motorSpeed, this.motorForce);
            this.config = new OIMO.PrismaticJointConfig(); //Create a specific config for this joint type that is calculating the local axis for both bodies
            super.constructJoint();
            this.config.springDamper = this.springDamper; //Telling the config to use the motor/spring of the Fudge Component
            this.config.limitMotor = this.motor;
            this.joint = new OIMO.PrismaticJoint(this.config);
            this.configureJoint();
        }
    }
    JointPrismatic.iSubclass = FudgeCore.Joint.registerSubclass(JointPrismatic);
    FudgeCore.JointPrismatic = JointPrismatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * A physical connection between two bodies, designed to simulate behaviour within a real body. It has two axis, a swing and twist axis, and also the perpendicular axis,
      * similar to a Spherical joint, but more restrictive in it's angles and only two degrees of freedom. Two RigidBodies need to be defined to use it. Mostly used to create humanlike joints that behave like a
      * lifeless body.
      * ```plaintext
      *
      *                      anchor - it can twist on one axis and swing on another
      *                            ‚îÇ
      *         z            ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê
      *         ‚Üë            ‚îÇ   ‚îÇ ‚Üì ‚îÇ   ‚îÇ        e.g. z = TwistAxis, it can rotate in-itself around this axis
      *    -x ‚Üê‚îÄ‚îº‚îÄ‚Üí x        ‚îÇ   ‚îÇ x ‚îÇ   ‚îÇ        e.g. x = SwingAxis, it can rotate anchored around the base on this axis
      *         ‚Üì            ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
      *        -z            ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò         e.g. you can twist the leg in-itself to a certain degree,
      *                                                     but also rotate it forward/backward/left/right to a certain degree
      *                bodyAnchor          bodyTied
      *              (e.g. pelvis)         (e.g. upper-leg)
      *
      * ```
      * Twist equals a rotation around a point without moving on an axis.
      * Swing equals a rotation on a point with a moving local axis.
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
      */
    class JointRagdoll extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.#springDampingTwist = 0;
            this.#springFrequencyTwist = 0;
            this.#springDampingSwing = 0;
            this.#springFrequencySwing = 0;
            this.#maxMotorTwist = 360;
            this.#minMotorTwist = 0;
            this.#motorTorqueTwist = 0;
            this.#motorSpeedTwist = 0;
            this.#maxAngleFirst = 0;
            this.#maxAngleSecond = 0;
            this.config = new OIMO.RagdollJointConfig();
            this.#getMutator = () => {
                let mutator = {
                    maxAngleFirst: this.#maxAngleFirst,
                    maxAngleSecond: this.#maxAngleSecond,
                    springDampingTwist: this.springDampingTwist,
                    springFrequencyTwist: this.springFrequencyTwist,
                    springDampingSwing: this.springDampingSwing,
                    springFrequencySwing: this.springFrequencySwing,
                    maxMotorTwist: this.#maxMotorTwist,
                    minMotorTwist: this.#minMotorTwist,
                    motorSpeedTwist: this.motorSpeedTwist,
                    motorTorqueTwist: this.motorTorqueTwist
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                if (typeof (_mutator.maxAngleFirst) !== "undefined")
                    this.#maxAngleFirst = _mutator.maxAngleFirst;
                if (typeof (_mutator.maxAngleSecond) !== "undefined")
                    this.#maxAngleSecond = _mutator.maxAngleSecond;
                this.mutateBase(_mutator, [
                    "springDampingTwist", "springFrequencyTwist", "springDampingSwing", "springFrequencySwing", "maxMotorTwist", "minMotorTwist", "motorSpeedTwist", "motorTorqueTwist"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        #springDampingTwist;
        #springFrequencyTwist;
        #springDampingSwing;
        #springFrequencySwing;
        #maxMotorTwist;
        #minMotorTwist;
        #motorTorqueTwist;
        #motorSpeedTwist;
        #motorTwist;
        #springDamperTwist;
        #springDamperSwing;
        #axisFirst;
        #axisSecond;
        #maxAngleFirst;
        #maxAngleSecond;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the first axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleFirstAxis() {
            return this.#maxAngleFirst * 180 / Math.PI;
        }
        set maxAngleFirstAxis(_value) {
            this.#maxAngleFirst = _value * Math.PI / 180;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the second axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleSecondAxis() {
            return this.#maxAngleSecond * 180 / Math.PI;
        }
        set maxAngleSecondAxis(_value) {
            this.#maxAngleSecond = _value * Math.PI / 180;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingTwist() {
            return this.#springDampingTwist;
        }
        set springDampingTwist(_value) {
            this.#springDampingTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyTwist() {
            return this.#springFrequencyTwist;
        }
        set springFrequencyTwist(_value) {
            this.#springFrequencyTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSwing() {
            return this.#springDampingSwing;
        }
        set springDampingSwing(_value) {
            this.#springDampingSwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySwing() {
            return this.#springFrequencySwing;
        }
        set springFrequencySwing(_value) {
            this.#springFrequencySwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxMotorTwist() {
            return this.#maxMotorTwist * 180 / Math.PI;
        }
        set maxMotorTwist(_value) {
            _value *= Math.PI / 180;
            this.#maxMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().upperLimit = _value;
        }
        /**
         * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minMotorTwist() {
            return this.#minMotorTwist * 180 / Math.PI;
        }
        set minMotorTwist(_value) {
            _value *= Math.PI / 180;
            this.#minMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().lowerLimit = _value;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get motorSpeedTwist() {
            return this.#motorSpeedTwist;
        }
        set motorSpeedTwist(_value) {
            this.#motorSpeedTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get motorTorqueTwist() {
            return this.#motorTorqueTwist;
        }
        set motorTorqueTwist(_value) {
            this.#motorTorqueTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axisFirst = this.axisFirst.serialize();
            serialization.axisSecond = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await this.axisFirst.deserialize(_serialization.axisFirst);
            await this.axisSecond.deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.#springDamperTwist = new OIMO.SpringDamper().setSpring(this.springFrequencyTwist, this.springDampingTwist);
            this.#springDamperSwing = new OIMO.SpringDamper().setSpring(this.springFrequencySwing, this.springDampingSwing);
            this.#motorTwist = new OIMO.RotationalLimitMotor().setLimits(this.minMotorTwist, this.maxMotorTwist);
            this.#motorTwist.setMotor(this.motorSpeedTwist, this.motorTorqueTwist);
            this.config = new OIMO.RagdollJointConfig();
            super.constructJoint(this.axisFirst, this.axisSecond);
            this.config.swingSpringDamper = this.#springDamperSwing;
            this.config.twistSpringDamper = this.#springDamperTwist;
            this.config.twistLimitMotor = this.#motorTwist;
            this.config.maxSwingAngle1 = this.#maxAngleFirst;
            this.config.maxSwingAngle2 = this.#maxAngleSecond;
            this.joint = new OIMO.RagdollJoint(this.config);
            super.configureJoint();
        }
    }
    JointRagdoll.iSubclass = FudgeCore.Joint.registerSubclass(JointRagdoll);
    FudgeCore.JointRagdoll = JointRagdoll;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe of rotation. Also known as HINGE joint.
       * Two RigidBodies need to be defined to use it. A motor can be defined to rotate the connected along the defined axis.
       *
       * ```plaintext
       *                  rotation axis, 1st Degree of freedom
       *                    ‚Üë
       *               ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       *                    ‚îÇ
       *      bodyAnchor         bodyTied
       *   (e.g. Doorhinge)       (e.g. Door)
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointRevolute extends FudgeCore.JointAxial {
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.#motorTorque = 0;
            this.config = new OIMO.RevoluteJointConfig();
            this.maxMotor = 360;
            this.minMotor = 0;
        }
        #motorTorque;
        #rotor;
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            _value *= Math.PI / 180;
            if (this.joint)
                this.joint.getLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint)
                this.joint.getLimitMotor().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorTorque() {
            return this.#motorTorque;
        }
        set motorTorque(_value) {
            this.#motorTorque = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorTorque: this.motorTorque,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorTorque = _serialization.motorTorque;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorTorque = this.motorTorque;
            return mutator;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.motorTorque) !== "undefined")
                this.motorTorque = _mutator.motorTorque;
            delete _mutator.motorTorque;
            super.mutate(_mutator);
        }
        //#endregion
        constructJoint() {
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(super.minMotor * Math.PI / 180, super.maxMotor * Math.PI / 180);
            this.#rotor.setMotor(this.motorSpeed, this.motorTorque);
            this.config = new OIMO.RevoluteJointConfig();
            super.constructJoint();
            this.config.springDamper = this.springDamper;
            this.config.limitMotor = this.#rotor;
            this.joint = new OIMO.RevoluteJoint(this.config);
            this.configureJoint();
        }
    }
    JointRevolute.iSubclass = FudgeCore.Joint.registerSubclass(JointRevolute);
    FudgeCore.JointRevolute = JointRevolute;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with three Degrees of Freedom, also known as ball and socket joint. Two bodies connected at their anchor but free to rotate.
       * Used for things like the connection of bones in the human shoulder (if simplified, else better use JointRagdoll). Two RigidBodies need to be defined to use it. Only spring settings can be defined.
       * 3 Degrees are swing horizontal, swing vertical and twist.
       *
       * ```plaintext
       *              JointHolder
       *         z      bodyAnchor (e.g. Human-Shoulder)
       *      y  ‚Üë
       *        \|          ‚îÄ‚îÄ‚îÄ(‚óè‚îÄ‚îÄ‚îÄ
       *  -x <---|---> x           bodyTied
       *         |\                (e.g. Upper-Arm)
       *         ‚Üì -y
       *        -z
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointSpherical extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.#springDamping = 0;
            this.#springFrequency = 0;
            this.config = new OIMO.SphericalJointConfig();
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        #springDamping;
        #springFrequency;
        #springDamper;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().frequency = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                springDamping: this.springDamping,
                springFrequency: this.springFrequency,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.springDamping = _serialization.springDamping;
            this.springFrequency = _serialization.springFrequency;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.springDamping = this.springDamping;
            mutator.springFrequency = this.springFrequency;
            return mutator;
        }
        async mutate(_mutator) {
            this.mutateBase(_mutator, ["springDamping", "springFrequency"]);
            delete _mutator.springDamping;
            delete _mutator.springFrequency;
            super.mutate(_mutator);
        }
        //#endregion
        constructJoint() {
            this.#springDamper = new OIMO.SpringDamper().setSpring(this.springFrequency, this.springDamping);
            this.config = new OIMO.SphericalJointConfig();
            super.constructJoint();
            this.config.springDamper = this.#springDamper;
            this.joint = new OIMO.SphericalJoint(this.config);
            super.configureJoint();
        }
    }
    JointSpherical.iSubclass = FudgeCore.Joint.registerSubclass(JointSpherical);
    FudgeCore.JointSpherical = JointSpherical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with two defined axis (normally e.g. (0,0,1) and rotation(1,0,0)), they share the same anchor and have free rotation, but transfer the twist.
       * In reality used in cars to transfer the more stable stationary force on the velocity axis to the bumping, damped moving wheel. Two RigidBodies need to be defined to use it.
       * The two motors can be defined for the two rotation axis, along with springs.
       * ```plaintext
       *
       *                      anchor - twist is transfered between bodies
       *         z                   |
       *         ‚Üë            -----  |  ------------
       *         |           |     | ‚Üì |            |
       *  -x <---|---> x     |     | x |            |           e.g. wheel can still turn up/down,
       *         |           |     |   |            |           left right but transfering it's rotation on to the wheel-axis.
       *         ‚Üì            -----     ------------
       *        -z
       *                 attachedRB          connectedRB
       *                (e.g. wheel)       (e.g. wheel-axis)
       * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointUniversal extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.#springDampingFirst = 0;
            this.#springFrequencyFirst = 0;
            this.#springDampingSecond = 0;
            this.#springFrequencySecond = 0;
            this.#maxRotorFirst = 360;
            this.#minRotorFirst = 0;
            this.#rotorTorqueFirst = 0;
            this.#rotorSpeedFirst = 0;
            this.#maxRotorSecond = 360;
            this.#minRotorSecond = 0;
            this.#rotorTorqueSecond = 0;
            this.#rotorSpeedSecond = 0;
            this.config = new OIMO.UniversalJointConfig();
            this.#getMutator = () => {
                let mutator = {
                    springDampingFirst: this.#springDampingFirst,
                    springFrequencyFirst: this.#springFrequencyFirst,
                    springDampingSecond: this.#springDampingSecond,
                    springFrequencySecond: this.#springFrequencySecond,
                    maxRotorFirst: this.#maxRotorFirst,
                    minRotorFirst: this.#minRotorFirst,
                    rotorSpeedFirst: this.#rotorSpeedFirst,
                    rotorTorqueFirst: this.#rotorTorqueFirst,
                    maxRotorSecond: this.#maxRotorSecond,
                    minRotorSecond: this.#minRotorSecond,
                    rotorSpeedSecond: this.#rotorSpeedSecond,
                    rotorTorqueSecond: this.#rotorTorqueSecond
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, [
                    "springDampingFirst", "springFrequencyFirst", "springDampingSecond", "springFrequencySecond",
                    "maxRotorFirst", "minRotorFirst", "rotorSpeedFirst", "rotorTorqueFirst",
                    "maxRotorSecond", "minRotorSecond", "rotorSpeedSecond", ".rotorTorqueSecond"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        #springDampingFirst;
        #springFrequencyFirst;
        #springDampingSecond;
        #springFrequencySecond;
        #maxRotorFirst;
        #minRotorFirst;
        #rotorTorqueFirst;
        #rotorSpeedFirst;
        #maxRotorSecond;
        #minRotorSecond;
        #rotorTorqueSecond;
        #rotorSpeedSecond;
        #motorFirst;
        #motorSecond;
        #axisSpringDamperFirst;
        #axisSpringDamperSecond;
        #axisFirst;
        #axisSecond;
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingFirst() {
            return this.#springDampingFirst;
        }
        set springDampingFirst(_value) {
            this.#springDampingFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyFirst() {
            return this.#springFrequencyFirst;
        }
        set springFrequencyFirst(_value) {
            this.#springFrequencyFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSecond() {
            return this.#springDampingSecond;
        }
        set springDampingSecond(_value) {
            this.#springDampingSecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySecond() {
            return this.#springFrequencySecond;
        }
        set springFrequencySecond(_value) {
            this.#springFrequencySecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorFirst() {
            return this.#maxRotorFirst;
        }
        set maxRotorFirst(_value) {
            this.#maxRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().upperLimit = _value * Math.PI / 180;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorFirst() {
            return this.#minRotorFirst;
        }
        set minRotorFirst(_value) {
            this.#minRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedFirst() {
            return this.#rotorSpeedFirst;
        }
        set rotorSpeedFirst(_value) {
            this.#rotorSpeedFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueFirst() {
            return this.#rotorTorqueFirst;
        }
        set rotorTorqueFirst(_value) {
            this.#rotorTorqueFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorTorque = _value;
        }
        /**
        * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
       */
        get maxRotorSecond() {
            return this.#maxRotorSecond;
        }
        set maxRotorSecond(_value) {
            this.#maxRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().upperLimit = _value * Math.PI / 180;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorSecond() {
            return this.#minRotorSecond;
        }
        set minRotorSecond(_value) {
            this.#minRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().lowerLimit = _value * Math.PI / 180;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedSecond() {
            return this.#rotorSpeedSecond;
        }
        set rotorSpeedSecond(_value) {
            this.#rotorSpeedSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueSecond() {
            return this.#rotorTorqueSecond;
        }
        set rotorTorqueSecond(_value) {
            this.#rotorTorqueSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.firstAxis = this.axisFirst.serialize();
            serialization.secondAxis = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axisFirst = await new FudgeCore.Vector3().deserialize(_serialization.axisFirst);
            this.axisSecond = await new FudgeCore.Vector3().deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            super.mutate(_mutator);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        #getMutator;
        #mutate;
        //#endregion
        constructJoint() {
            this.#axisSpringDamperFirst = new OIMO.SpringDamper().setSpring(this.#springFrequencyFirst, this.#springDampingFirst);
            this.#axisSpringDamperSecond = new OIMO.SpringDamper().setSpring(this.#springFrequencySecond, this.#springDampingSecond);
            this.#motorFirst = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * Math.PI / 180, this.#maxRotorFirst * Math.PI / 180);
            this.#motorFirst.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.#motorSecond = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * Math.PI / 180, this.#maxRotorFirst * Math.PI / 180);
            this.#motorSecond.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.config = new OIMO.UniversalJointConfig();
            super.constructJoint(this.#axisFirst, this.#axisSecond);
            this.config.limitMotor1 = this.#motorFirst;
            this.config.limitMotor2 = this.#motorSecond;
            this.config.springDamper1 = this.#axisSpringDamperFirst;
            this.config.springDamper2 = this.#axisSpringDamperSecond;
            this.joint = new OIMO.UniversalJoint(this.config);
            super.configureJoint();
        }
    }
    JointUniversal.iSubclass = FudgeCore.Joint.registerSubclass(JointUniversal);
    FudgeCore.JointUniversal = JointUniversal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with no movement.
       * Best way to simulate convex objects like a chair seat connected to chair legs.
       * The actual anchor point does not matter that much, only in very specific edge cases.
       * Because welding means they simply do not disconnect. (unless you add Breakability)
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointWelding extends FudgeCore.Joint {
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.GenericJointConfig();
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        //#endregion
        constructJoint() {
            this.config = new OIMO.GenericJointConfig();
            super.constructJoint(new OIMO.Mat3(), new OIMO.Mat3());
            this.joint = new OIMO.GenericJoint(this.config);
            this.joint.setAllowCollision(this.internalCollision);
        }
    }
    JointWelding.iSubclass = FudgeCore.Joint.registerSubclass(JointWelding);
    FudgeCore.JointWelding = JointWelding;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../../../Physics/OIMOPhysics.d.ts"/>
var FudgeCore;
///<reference path="../../../Physics/OIMOPhysics.d.ts"/>
(function (FudgeCore) {
    /**
      * Manages the OIMO physics engine for FUDGE. Multiple instances may be created, one is active at a time.
      * All methods are static and use the currently active instance. At startup, a default instance is created and become the active instance
      * Attaching a {@link ComponentRigidbody} to a {@link Node} places a physics collider in the physics instance active at that time.
      * @author Marko Fehrenbach, HFU 2020
      */
    class Physics {
        constructor() {
            this.bodyList = new Array();
            this.jointList = new Array();
            if (typeof OIMO == "undefined") { // Check if OIMO Namespace was loaded, else do not use any physics. Check is needed to ensure FUDGE can be used without Physics
                FudgeCore.Debug.error("OIMO physics engine not connected!");
                return null;
            }
            this.oimoWorld = new OIMO.World();
            this.#debugDraw = new FudgeCore.PhysicsDebugDraw(); //Create a Fudge Physics debugging handling object
            this.oimoWorld.setDebugDraw(this.#debugDraw.oimoDebugDraw); //Tell OimoPhysics where to debug to and how it will be handled
        }
        /** The rendering of physical debug informations. Used internally no interaction needed.*/
        #debugDraw;
        /** The camera/viewport the physics are debugged to. Used internally no interaction needed. */
        #mainCam;
        /**
         * Define the currently active Physics instance
         */
        static set activeInstance(_physics) {
            Physics.∆íactive = _physics;
        }
        /** Get the currently active Physics instance */
        static get activeInstance() {
            return Physics.∆íactive;
        }
        static get debugDraw() {
            return Physics.∆íactive.#debugDraw;
        }
        static get mainCam() {
            return Physics.∆íactive.#mainCam;
        }
        /**
        * Cast a RAY into the physical world from a origin point in a certain direction. Receiving informations about the hit object and the
        * hit point. Do not specify a _group to raycast the whole world, else only bodies within the specific group can be hit.
        */
        static raycast(_origin, _direction, _length = 1, _debugDraw = false, _group = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let ray = new OIMO.RayCastClosest();
            let begin = new OIMO.Vec3(_origin.x, _origin.y, _origin.z);
            let end = this.getRayEndPoint(begin, new FudgeCore.Vector3(_direction.x, _direction.y, _direction.z), _length);
            ray.clear();
            if (_group == FudgeCore.COLLISION_GROUP.DEFAULT) { //Case 1: Raycasting the whole world, normal mode
                Physics.∆íactive.oimoWorld.rayCast(begin, end, ray);
            }
            else { //Case2: Raycasting on each body in a specific group
                let allHits = new Array();
                Physics.∆íactive.bodyList.forEach(function (value) {
                    if (value.collisionGroup == _group) {
                        hitInfo = value.raycastThisBody(_origin, _direction, _length);
                        if (hitInfo.hit == true) { //Every hit is could potentially be the closest
                            allHits.push(hitInfo);
                        }
                    }
                });
                allHits.forEach(function (value) {
                    if (value.hitDistance < hitInfo.hitDistance || hitInfo.hit == false) {
                        hitInfo = value;
                    }
                });
            }
            if (ray.hit) { //Fill in informations on the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(ray.position.x, ray.position.y, ray.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(ray.normal.x, ray.normal.y, ray.normal.z);
                hitInfo.hitDistance = this.getRayDistance(_origin, hitInfo.hitPoint);
                hitInfo.rigidbodyComponent = ray.shape.userData;
                hitInfo.rayEnd = new FudgeCore.Vector3(end.x, end.y, end.z);
                hitInfo.rayOrigin = _origin;
            }
            else {
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(end.x, end.y, end.z);
            }
            if (_debugDraw) { //Handle debugging
                Physics.∆íactive.#debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        /**
        * Simulates the physical world. _deltaTime is the amount of time between physical steps, default is 60 frames per second ~17ms.
        * A frame timing can't be smaller than 1/30 of a second, or else it will be set to 30 frames, to have more consistent frame calculations.
        */
        static simulate(_deltaTime = 1 / 60) {
            if (Physics.∆íactive.jointList.length > 0)
                Physics.connectJoints(); //Connect joints if anything has happened between the last call to any of the two paired rigidbodies
            if (FudgeCore.Time.game.getScale() != 0) { //If time is stopped do not simulate to avoid misbehaviour
                _deltaTime = _deltaTime > 1 / 30 ? 1 / 30 : _deltaTime; //If instead of a fixed rate the game framerate is used, make sure irregular timings are fixed to 30fps
                Physics.∆íactive.oimoWorld.step(_deltaTime * FudgeCore.Time.game.getScale()); //Update the simulation by the given deltaTime and the Fudge internal TimeScale
            }
        }
        /**
         * Draw information about the currently active instance using the {@link ComponentCamera} given
         */
        static draw(_cmpCamera, _mode) {
            Physics.∆íactive.#debugDraw.setDebugMode(_mode);
            Physics.∆íactive.#mainCam = _cmpCamera;
            Physics.∆íactive.oimoWorld.debugDraw(); //Filling the physics world debug informations into the debug rendering handler
            Physics.∆íactive.#debugDraw.drawBuffers();
            Physics.∆íactive.#debugDraw.clearBuffers(); //Updates info about the current projection, resetting the points/lines/triangles that need to be drawn from debug
        }
        /**
          * Adjusts the transforms of the {@link ComponentRigidbody}s in the given branch to match their nodes or meshes
          */
        static adjustTransforms(_branch, _toMesh = false) {
            FudgeCore.Render.prepare(_branch, { ignorePhysics: true });
            for (let node of FudgeCore.Render.nodesPhysics)
                node.getComponent(FudgeCore.ComponentRigidbody).initialize();
        }
        /**
        * Get the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static getGravity() {
            let tmpVec = Physics.∆íactive.oimoWorld.getGravity();
            return new FudgeCore.Vector3(tmpVec.x, tmpVec.y, tmpVec.z);
        }
        /**
        * Set the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static setGravity(_value) {
            let tmpVec = new OIMO.Vec3(_value.x, _value.y, _value.z);
            Physics.∆íactive.oimoWorld.setGravity(tmpVec);
        }
        /**
        * Add a new OIMO Rigidbody to the active instance, happens automatically when adding a FUDGE Rigidbody Component.
        */
        static addRigidbody(_cmpRB) {
            Physics.∆íactive.bodyList.push(_cmpRB);
            Physics.∆íactive.oimoWorld.addRigidBody(_cmpRB.getOimoRigidbody());
        }
        /**
        * Remove the OIMO Rigidbody to the active instance, happens automatically when removing a FUDGE Rigidbody Component
        */
        static removeRigidbody(_cmpRB) {
            // TODO: two lists are being managed, info might deviate. Cleanup!
            let oimoRigidBody = _cmpRB.getOimoRigidbody();
            if (oimoRigidBody._world)
                oimoRigidBody._world.removeRigidBody(oimoRigidBody);
            // what if the rigidbodys oimo-world does not belong to the active instance?
            let id = Physics.∆íactive.bodyList.indexOf(_cmpRB);
            Physics.∆íactive.bodyList.splice(id, 1);
        }
        /**
        * Add a new OIMO Joint/Constraint to the active instance, happens automatically when adding a FUDGE Joint Component
        */
        static addJoint(_cmpJoint) {
            Physics.∆íactive.oimoWorld.addJoint(_cmpJoint.getOimoJoint());
        }
        /**
        * Called internally to inform the physics system that a joint has a change of core properties and needs to be recreated.
        */
        static changeJointStatus(_cmpJoint) {
            if (Physics.∆íactive.jointList.indexOf(_cmpJoint) < 0)
                Physics.∆íactive.jointList.push(_cmpJoint);
        }
        /**
          * Remove the OIMO Joint/Constraint to the active instance, happens automatically when removing a FUDGE Joint Component
          */
        static removeJoint(_cmpJoint) {
            try {
                Physics.∆íactive.oimoWorld.removeJoint(_cmpJoint.getOimoJoint());
            }
            catch (_error) {
                FudgeCore.Debug.fudge(_error);
            }
        }
        /** Returns all the ComponentRigidbodies that are known to the active instance. */
        static getBodyList() {
            return Physics.∆íactive.bodyList;
        }
        /** Giving a ComponentRigidbody a specific identification number so it can be referenced in the loading process. And removed rb's can receive a new id. */
        static distributeBodyID() {
            let freeId = 0;
            let free = false;
            Physics.∆íactive.bodyList.forEach((_value) => {
                if (_value.id != freeId) {
                    free = true;
                }
                else {
                    free = false;
                }
                if (!free) {
                    freeId++;
                }
            });
            return freeId;
        }
        /**
         * Connect all joints that are not connected yet. Used internally no user interaction needed. This functionality is called and needed to make sure joints connect/disconnect
         * if any of the two paired ComponentRigidbodies change.
         */
        static connectJoints() {
            let jointsToConnect = Physics.∆íactive.jointList;
            Physics.∆íactive.jointList = [];
            jointsToConnect.forEach((_joint) => {
                if (_joint.isConnected() == false)
                    if (_joint.isActive)
                        _joint.connect();
                    else
                        Physics.∆íactive.jointList.push(_joint);
            });
        }
        /** Remove all oimo joints and rigidbodies, so that they can be reused in another world  */
        static cleanup() {
            let oimoWorld = Physics.∆íactive.oimoWorld;
            if (oimoWorld != null) {
                //Resetting the world so a new world can be created, fix for re-opening a project in editor, making sure there are no old things calculated
                let jointsWorld = oimoWorld.getNumJoints();
                let bodiesWorld = oimoWorld.getNumRigidBodies();
                for (let body of Physics.∆íactive.bodyList)
                    body.isInitialized = false;
                Physics.∆íactive.jointList = new Array(); // TODO: see if it would be smarter, do use these arrays. Definitely more intuitive...
                for (let i = 0; i < jointsWorld; i++) {
                    let oimoJoint = Physics.∆íactive.oimoWorld.getJointList();
                    oimoWorld.removeJoint(oimoJoint);
                }
                for (let i = 0; i < bodiesWorld; i++) {
                    let oimoBody = oimoWorld.getRigidBodyList();
                    oimoWorld.removeRigidBody(oimoBody);
                }
            }
        }
        // /** Returns the ComponentRigidbody with the given id. Used internally to reconnect joints on loading in the editor. */
        // private static getBodyByID(_id: number): ComponentRigidbody {
        //   let body: ComponentRigidbody = null;
        //   Physics.#activePhysics.bodyList.forEach((value: ComponentRigidbody): void => {
        //     if (value.id == _id) {
        //       body = value;
        //     }
        //   });
        //   return body;
        // }
        /** Internal function to calculate the endpoint of mathematical ray. By adding the multiplied direction to the origin.
           * Used because OimoPhysics defines ray by start/end. But GameEngines commonly use origin/direction.
           */
        static getRayEndPoint(start, direction, length) {
            let origin = FudgeCore.Recycler.get(FudgeCore.Vector3);
            origin.set(start.x, start.y, start.z);
            let scaledDirection = direction.clone;
            scaledDirection.scale(length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, origin);
            FudgeCore.Recycler.store(scaledDirection);
            FudgeCore.Recycler.store(endpoint);
            FudgeCore.Recycler.store(origin);
            return new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z);
        }
        /** Internal function to get the distance in which a ray hit by subtracting points from each other and get the square root of the squared product of each component. */
        static getRayDistance(origin, hitPoint) {
            let dx = origin.x - hitPoint.x;
            let dy = origin.y - hitPoint.y;
            let dz = origin.z - hitPoint.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        // /** Returns the actual used world of the OIMO physics engine. No user interaction needed - Only for advanced users that need to access it directly */
        getOimoWorld() {
            return Physics.∆íactive.oimoWorld;
        }
    }
    /** The SETTINGS that apply to the physical world. Ranging from things like sleeping, collisionShapeThickness and others */
    Physics.settings = new FudgeCore.PhysicsSettings(FudgeCore.COLLISION_GROUP.DEFAULT, (FudgeCore.COLLISION_GROUP.DEFAULT | FudgeCore.COLLISION_GROUP.GROUP_1 | FudgeCore.COLLISION_GROUP.GROUP_2 | FudgeCore.COLLISION_GROUP.GROUP_3 | FudgeCore.COLLISION_GROUP.GROUP_4));
    Physics.∆íactive = new Physics();
    FudgeCore.Physics = Physics;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * Storing and manipulating rotations in the form of quaternions.
      * Constructed out of the 4 components x,y,z,w. Commonly used to calculate rotations in physics engines.
      * Class mostly used internally to bridge the in FUDGE commonly used angles in degree to OimoPhysics quaternion system.
      * @authors Marko Fehrenbach, HFU, 2020
      */
    class Quaternion extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0, _w = 0) {
            super();
            this.x = _x;
            this.y = _y;
            this.z = _z;
            this.w = _w;
        }
        /** Get/Set the X component of the Quaternion. Real Part */
        get X() {
            return this.x;
        }
        set X(_x) {
            this.x = _x;
        }
        /** Get/Set the Y component of the Quaternion. Real Part */
        get Y() {
            return this.y;
        }
        set Y(_y) {
            this.y = _y;
        }
        /** Get/Set the Z component of the Quaternion. Real Part */
        get Z() {
            return this.z;
        }
        set Z(_z) {
            this.z = _z;
        }
        /** Get/Set the Y component of the Quaternion. Imaginary Part */
        get W() {
            return this.w;
        }
        set W(_w) {
            this.w = _w;
        }
        /**
         * Create quaternion from vector3 angles in degree
         */
        setFromVector3(rollX, pitchY, yawZ) {
            let cy = Math.cos(yawZ * 0.5);
            let sy = Math.sin(yawZ * 0.5);
            let cp = Math.cos(pitchY * 0.5);
            let sp = Math.sin(pitchY * 0.5);
            let cr = Math.cos(rollX * 0.5);
            let sr = Math.sin(rollX * 0.5);
            this.w = cr * cp * cy + sr * sp * sy;
            this.x = sr * cp * cy - cr * sp * sy;
            this.y = cr * sp * cy + sr * cp * sy;
            this.z = cr * cp * sy - sr * sp * cy;
        }
        /**
         * Returns the euler angles in radians as Vector3 from this quaternion.
         */
        toEulerangles() {
            let angles = new FudgeCore.Vector3();
            // roll (x-axis rotation)
            let sinrcosp = 2 * (this.w * this.x + this.y * this.z);
            let cosrcosp = 1 - 2 * (this.x * this.x + this.y * this.y);
            angles.x = Math.atan2(sinrcosp, cosrcosp);
            // pitch (y-axis rotation)
            let sinp = 2 * (this.w * this.y - this.z * this.x);
            if (Math.abs(sinp) >= 1)
                angles.y = this.copysign(Math.PI / 2, sinp); // use 90 degrees if out of range
            else
                angles.y = Math.asin(sinp);
            // yaw (z-axis rotation)
            let sinycosp = 2 * (this.w * this.z + this.x * this.y);
            let cosycosp = 1 - 2 * (this.y * this.y + this.z * this.z);
            angles.z = Math.atan2(sinycosp, cosycosp);
            return angles;
        }
        /**
         * Return angles in degrees as vector3 from this. quaterion
         */
        toDegrees() {
            let angles = this.toEulerangles();
            angles.x = angles.x * (180 / Math.PI);
            angles.y = angles.y * (180 / Math.PI);
            angles.z = angles.z * (180 / Math.PI);
            return angles;
        }
        getMutator() {
            let mutator = {
                x: this.x, y: this.y, z: this.z, w: this.w
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
        /** Copying the sign of a to b */
        copysign(a, b) {
            return b < 0 ? -Math.abs(a) : Math.abs(a);
        }
    }
    FudgeCore.Quaternion = Quaternion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a threedimensional box by two corner-points, one with minimal values and one with maximum values
     */
    class Box {
        constructor(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.set(_min, _max);
        }
        /**
         * Define the corners of this box, standard values are Infinity for min, and -Infinity for max,
         * creating an impossible inverted box that can not contain any points
         */
        set(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.min = _min;
            this.max = _max;
        }
        /**
         * Expand the box if necessary to include the given point
         */
        expand(_include) {
            this.min.min(_include);
            this.max.max(_include);
        }
        recycle() {
            this.min.set(Infinity, Infinity, Infinity);
            this.max.set(-Infinity, -Infinity, -Infinity);
        }
    }
    FudgeCore.Box = Box;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores information provided by {@link Render}-picking e.g. using {@link Picker} and provides methods for further calculation of positions and normals etc.
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Pick {
        constructor(_node) {
            this.node = _node;
        }
        #mtxViewToWorld;
        #posWorld;
        #posMesh;
        /**
         * Accessor to calculate and store world position of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posWorld() {
            if (this.#posWorld)
                return this.#posWorld;
            let pointInClipSpace = FudgeCore.Vector3.Z(this.zBuffer);
            let m = this.#mtxViewToWorld.get();
            let result = FudgeCore.Vector3.TRANSFORMATION(pointInClipSpace, this.#mtxViewToWorld, true);
            let w = m[3] * pointInClipSpace.x + m[7] * pointInClipSpace.y + m[11] * pointInClipSpace.z + m[15];
            result.scale(1 / w);
            this.#posWorld = result;
            return result;
        }
        /**
         * Accessor to calculate and store position in mesh-space of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posMesh() {
            if (this.#posMesh)
                return this.#posMesh;
            let mtxWorldToMesh = FudgeCore.Matrix4x4.INVERSION(this.node.getComponent(FudgeCore.ComponentMesh).mtxWorld);
            let posMesh = FudgeCore.Vector3.TRANSFORMATION(this.posWorld, mtxWorldToMesh);
            this.#posMesh = posMesh;
            return posMesh;
        }
        /**
         * Accessor to calculate and store the face normal in world-space at the point of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get normal() {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let result;
            for (let face of cmpMesh.mesh.faces) {
                if (face.isInside(this.posMesh)) {
                    result = face.normal.clone;
                    break;
                }
            }
            result.transform(cmpMesh.mtxWorld, false);
            result.normalize();
            return result;
        }
        /**
         * Called solely by the renderer to enable calculation of the world coordinates of this {@link Pick}
         */
        set mtxViewToWorld(_mtxViewToWorld) {
            this.#mtxViewToWorld = _mtxViewToWorld;
        }
    }
    FudgeCore.Pick = Pick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Provides static methods for picking using {@link Render}
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Picker {
        /**
         * Takes a ray plus min and max values for the near and far planes to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickRay(_nodes, _ray, _min, _max) {
            let cmpCameraPick = new FudgeCore.ComponentCamera();
            cmpCameraPick.mtxPivot.translation = _ray.origin;
            cmpCameraPick.mtxPivot.lookAt(_ray.direction);
            cmpCameraPick.projectCentral(1, 0.001, FudgeCore.FIELD_OF_VIEW.DIAGONAL, _min, _max);
            let picks = FudgeCore.Render.pickBranch(_nodes, cmpCameraPick);
            return picks;
        }
        /**
         * Takes a camera and a point on its virtual normed projection plane (distance 1) to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickCamera(_nodes, _cmpCamera, _posProjection) {
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-_posProjection.x, _posProjection.y, 1));
            let length = ray.direction.magnitude;
            if (_cmpCamera.node) {
                let mtxCamera = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.node.mtxWorld, _cmpCamera.mtxPivot);
                ray.transform(mtxCamera);
                FudgeCore.Recycler.store(mtxCamera);
            }
            else
                ray.transform(_cmpCamera.mtxPivot);
            let picks = Picker.pickRay(_nodes, ray, length * _cmpCamera.getNear(), length * _cmpCamera.getFar());
            return picks;
        }
        /**
         * Takes the camera of the given viewport and a point the client surface to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickViewport(_viewport, _posClient) {
            let posProjection = _viewport.pointClientToProjection(_posClient);
            let nodes = Array.from(_viewport.getBranch().getIterator(true));
            let picks = Picker.pickCamera(nodes, _viewport.camera, posProjection);
            return picks;
        }
    }
    FudgeCore.Picker = Picker;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defined by an origin and a direction of type {@link Pick}, rays are used to calculate picking and intersections
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by
         * the given point of origin and the planes normal. All values and calculations
         * must be relative to the same coordinate system, preferably the world
         */
        intersectPlane(_origin, _normal) {
            let difference = FudgeCore.Vector3.DIFFERENCE(_origin, this.origin);
            let factor = FudgeCore.Vector3.DOT(difference, _normal) / FudgeCore.Vector3.DOT(this.direction, _normal);
            let intersect = FudgeCore.Vector3.SUM(this.origin, FudgeCore.Vector3.SCALE(this.direction, factor));
            return intersect;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by the face.
         * All values and calculations must be relative to the same coordinate system, preferably the world
         */
        intersectFacePlane(_face) {
            return this.intersectPlane(_face.getPosition(0), _face.normal);
        }
        /**
         * Returns the shortest distance from the ray to the given target point.
         * All values and calculations must be relative to the same coordinate system, preferably the world.
         */
        getDistance(_target) {
            let originToTarget = FudgeCore.Vector3.DIFFERENCE(_target, this.origin);
            let raySection = FudgeCore.Vector3.NORMALIZATION(this.direction, 1);
            let projectedLength = FudgeCore.Vector3.DOT(originToTarget, raySection);
            raySection.scale(projectedLength);
            raySection.add(this.origin);
            let distance = FudgeCore.Vector3.DIFFERENCE(_target, raySection);
            return distance;
        }
        /**
         * Transform the ray by the given matrix
         */
        transform(_mtxTransform) {
            this.direction.transform(_mtxTransform);
            this.origin.transform(_mtxTransform);
        }
        /**
         * Returns a readable string representation of this ray
         */
        toString() {
            return `origin: ${this.origin.toString()}, direction: ${this.direction.toString()}, length: ${this.length.toPrecision(5)}`;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The main interface to the render engine, here WebGL (see superclass {@link RenderWebGL} and the RenderInjectors
     */
    class Render extends FudgeCore.RenderWebGL {
        // TODO: research if picking should be optimized using radius picking to filter
        //#region Prepare
        /**
         * Recursively iterates over the branch starting with the node given, recalculates all world transforms,
         * collects all lights and feeds all shaders used in the graph with these lights. Sorts nodes for different
         * render passes.
         */
        static prepare(_branch, _options = {}, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _lights = new Map(), _shadersUsed = null) {
            let firstLevel = (_shadersUsed == null);
            if (firstLevel) {
                _shadersUsed = [];
                Render.timestampUpdate = performance.now();
                Render.nodesSimple.reset();
                Render.nodesAlpha.reset();
                Render.nodesPhysics.reset();
                Render.componentsPick.reset();
                Render.dispatchEvent(new Event("renderPrepareStart" /* RENDER_PREPARE_START */));
            }
            if (!_branch.isActive)
                return; // don't add branch to render list if not active
            _branch.nNodesInBranch = 1;
            _branch.radius = 0;
            _branch.dispatchEventToTargetOnly(new Event("renderPrepare" /* RENDER_PREPARE */));
            _branch.timestampUpdate = Render.timestampUpdate;
            if (_branch.cmpTransform && _branch.cmpTransform.isActive) {
                let mtxWorldBranch = FudgeCore.Matrix4x4.MULTIPLICATION(_mtxWorld, _branch.cmpTransform.mtxLocal);
                _branch.mtxWorld.set(mtxWorldBranch);
                FudgeCore.Recycler.store(mtxWorldBranch);
            }
            else
                _branch.mtxWorld.set(_mtxWorld); // overwrite readonly mtxWorld of the current node
            let cmpRigidbody = _branch.getComponent(FudgeCore.ComponentRigidbody);
            if (cmpRigidbody && cmpRigidbody.isActive) { //TODO: support de-/activation throughout
                Render.nodesPhysics.push(_branch); // add this node to physics list
                if (!_options?.ignorePhysics)
                    this.transformByPhysics(_branch, cmpRigidbody);
            }
            let cmpPick = _branch.getComponent(FudgeCore.ComponentPick);
            if (cmpPick && cmpPick.isActive) {
                Render.componentsPick.push(cmpPick); // add this component to pick list
            }
            let cmpLights = _branch.getComponents(FudgeCore.ComponentLight);
            for (let cmpLight of cmpLights) {
                if (!cmpLight.isActive)
                    continue;
                let type = cmpLight.light.getType();
                let lightsOfType = _lights.get(type);
                if (!lightsOfType) {
                    lightsOfType = [];
                    _lights.set(type, lightsOfType);
                }
                lightsOfType.push(cmpLight);
            }
            let cmpMesh = _branch.getComponent(FudgeCore.ComponentMesh);
            let cmpMaterial = _branch.getComponent(FudgeCore.ComponentMaterial);
            if (cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive) {
                // TODO: careful when using particlesystem, pivot must not change node position
                let mtxWorldMesh = FudgeCore.Matrix4x4.MULTIPLICATION(_branch.mtxWorld, cmpMesh.mtxPivot);
                cmpMesh.mtxWorld.set(mtxWorldMesh);
                FudgeCore.Recycler.store(mtxWorldMesh); // TODO: examine, why recycling this causes meshes to be misplaced...
                let shader = cmpMaterial.material.getShader();
                if (_shadersUsed.indexOf(shader) < 0)
                    _shadersUsed.push(shader);
                _branch.radius = cmpMesh.radius;
                if (cmpMaterial.sortForAlpha)
                    Render.nodesAlpha.push(_branch); // add this node to render list
                else
                    Render.nodesSimple.push(_branch); // add this node to render list
            }
            for (let child of _branch.getChildren()) {
                Render.prepare(child, _options, _branch.mtxWorld, _lights, _shadersUsed);
                _branch.nNodesInBranch += child.nNodesInBranch;
                let cmpMeshChild = child.getComponent(FudgeCore.ComponentMesh);
                let position = cmpMeshChild ? cmpMeshChild.mtxWorld.translation : child.mtxWorld.translation;
                position = position.clone;
                _branch.radius = Math.max(_branch.radius, position.getDistance(_branch.mtxWorld.translation) + child.radius);
                FudgeCore.Recycler.store(position);
            }
            if (firstLevel) {
                Render.dispatchEvent(new Event("renderPrepareEnd" /* RENDER_PREPARE_END */));
                for (let shader of _shadersUsed)
                    Render.setLightsInShader(shader, _lights);
            }
            //Calculate Physics based on all previous calculations    
            // Render.setupPhysicalTransform(_branch);
        }
        //#endregion
        //#region Picking
        /**
         * Used with a {@link Picker}-camera, this method renders one pixel with picking information
         * for each node in the line of sight and return that as an unsorted {@link Pick}-array
         */
        static pickBranch(_nodes, _cmpCamera) {
            Render.∆ípicked = [];
            let size = Math.ceil(Math.sqrt(_nodes.length));
            Render.createPickTexture(size);
            Render.setBlendMode(FudgeCore.BLEND.OPAQUE);
            for (let node of _nodes) {
                let cmpMesh = node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = node.getComponent(FudgeCore.ComponentMaterial);
                if (cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive) {
                    let mtxMeshToView = FudgeCore.Matrix4x4.MULTIPLICATION(_cmpCamera.mtxWorldToView, cmpMesh.mtxWorld);
                    Render.pick(node, node.mtxWorld, mtxMeshToView);
                    // RenderParticles.drawParticles();
                    FudgeCore.Recycler.store(mtxMeshToView);
                }
            }
            Render.setBlendMode(FudgeCore.BLEND.TRANSPARENT);
            let picks = Render.getPicks(size, _cmpCamera);
            Render.resetFrameBuffer();
            return picks;
        }
        //#endregion
        //#region Drawing
        static draw(_cmpCamera) {
            _cmpCamera.resetWorldToView();
            Render.drawList(_cmpCamera, this.nodesSimple);
            Render.drawListAlpha(_cmpCamera);
        }
        static drawListAlpha(_cmpCamera) {
            function sort(_a, _b) {
                return (Reflect.get(_a, "zCamera") < Reflect.get(_b, "zCamera")) ? 1 : -1;
            }
            for (let node of Render.nodesAlpha)
                Reflect.set(node, "zCamera", _cmpCamera.pointWorldToClip(node.getComponent(FudgeCore.ComponentMesh).mtxWorld.translation).z);
            let sorted = Render.nodesAlpha.getSorted(sort);
            Render.drawList(_cmpCamera, sorted);
        }
        static drawList(_cmpCamera, _list) {
            for (let node of _list) {
                let cmpMesh = node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = node.getComponent(FudgeCore.ComponentMaterial);
                Render.drawMesh(cmpMesh, cmpMaterial, _cmpCamera);
            }
        }
        //#region Physics
        static transformByPhysics(_node, _cmpRigidbody) {
            if (!_cmpRigidbody.isInitialized) // || Project.mode == MODE.EDITOR)
                _cmpRigidbody.initialize();
            if (!FudgeCore.Physics.getBodyList().length)
                return;
            if (!_node.mtxLocal) {
                throw (new Error("ComponentRigidbody requires ComponentTransform at the same Node"));
            }
            _cmpRigidbody.checkCollisionEvents();
            if (_cmpRigidbody.typeBody == FudgeCore.BODY_TYPE.KINEMATIC || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR) { //Case of Kinematic Rigidbody
                let mtxPivotWorld = FudgeCore.Matrix4x4.MULTIPLICATION(_node.mtxWorld, _cmpRigidbody.mtxPivotUnscaled);
                _cmpRigidbody.setPosition(mtxPivotWorld.translation);
                _cmpRigidbody.setRotation(mtxPivotWorld.rotation);
                FudgeCore.Recycler.store(mtxPivotWorld);
                return;
            }
            let mtxWorld = FudgeCore.Matrix4x4.CONSTRUCTION({ translation: _cmpRigidbody.getPosition(), rotation: _cmpRigidbody.getRotation(), scaling: null });
            mtxWorld.multiply(_cmpRigidbody.mtxPivotInverse);
            _node.mtxWorld.translation = mtxWorld.translation;
            _node.mtxWorld.rotation = mtxWorld.rotation;
            let mtxLocal = _node.getParent() ? FudgeCore.Matrix4x4.RELATIVE(_node.mtxWorld, _node.getParent().mtxWorld) : _node.mtxWorld;
            _node.mtxLocal.set(mtxLocal);
            FudgeCore.Recycler.store(mtxWorld);
            FudgeCore.Recycler.store(mtxLocal);
        }
    }
    Render.rectClip = new FudgeCore.Rectangle(-1, 1, 2, -2);
    Render.nodesPhysics = new FudgeCore.RecycableArray();
    Render.componentsPick = new FudgeCore.RecycableArray();
    Render.nodesSimple = new FudgeCore.RecycableArray();
    Render.nodesAlpha = new FudgeCore.RecycableArray();
    FudgeCore.Render = Render;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderMesh {
        constructor(_mesh) {
            this.smooth = null;
            this.flat = null;
            this.mesh = _mesh;
        }
        get iBones() {
            return this.∆íiBones || ( // return cache or ...
            this.∆íiBones = new Uint8Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                return [...this.mesh.vertices.bones(_index).map(_bone => _bone.index)];
            })));
        }
        get weights() {
            return this.∆íweights || ( // return cache or ...
            this.∆íweights = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                return [...this.mesh.vertices.bones(_index).map(_bone => _bone.weight)];
            })));
        }
        get vertices() {
            return this.∆ívertices || ( // return cache or ...
            // ... flatten all vertex positions from cloud into a typed array
            this.∆ívertices = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                return [...this.mesh.vertices.position(_index).get()];
            })));
        }
        get indices() {
            return this.∆íindices || ( // return cache or ...
            // ... flatten all indices from the faces into a typed array
            this.∆íindices = new Uint16Array(this.mesh.faces.flatMap((_face) => [..._face.indices])));
        }
        get normalsVertex() {
            if (this.∆ínormalsVertex == null) {
                // sum up all unscaled normals of faces connected to one vertex...
                this.mesh.vertices.forEach(_vertex => _vertex.normal.set(0, 0, 0));
                for (let face of this.mesh.faces)
                    for (let index of face.indices) {
                        this.mesh.vertices.normal(index).add(face.normalUnscaled);
                    }
                // ... and normalize them
                this.mesh.vertices.forEach(_vertex => {
                    // some vertices might be unused and yield a zero-normal...
                    if (_vertex.normal.magnitudeSquared > 0)
                        _vertex.normal.normalize();
                });
                // this.∆ínormalsVertex = new Float32Array(normalsVertex.flatMap((_normal: Vector3) => [..._normal.get()]));
                this.∆ínormalsVertex = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    return [...this.mesh.vertices.normal(_index).get()];
                }));
            }
            return this.∆ínormalsVertex;
        }
        get textureUVs() {
            return this.∆ítextureUVs || ( // return cache or ...
            // ... flatten all uvs from the clous into a typed array
            this.∆ítextureUVs = new Float32Array(this.mesh.vertices.flatMap((_vertex) => [..._vertex.uv.get()])));
        }
        get verticesFlat() {
            return this.∆íverticesFlat || (this.∆íverticesFlat = this.createVerticesFlat());
        }
        get indicesFlat() {
            return this.∆íindicesFlat;
        }
        get normalsFlat() {
            return this.∆ínormalsFlat || (this.∆ínormalsFlat = this.createNormalsFlat());
        }
        get textureUVsFlat() {
            return this.∆ítextureUVsFlat || (this.∆ítextureUVsFlat = this.createTextureUVsFlat());
        }
        get iBonesFlat() {
            return this.∆íiBonesFlat;
        }
        get weightsFlat() {
            return this.∆íweightsFlat;
        }
        clear() {
            this.smooth = null;
            this.flat = null;
            // buffers for smooth shading
            this.∆ívertices = undefined;
            this.∆íindices = undefined;
            this.∆ítextureUVs = undefined;
            this.∆ínormalsVertex = undefined;
            // special buffers for flat shading
            this.∆ínormalsFlat = undefined;
            this.∆íverticesFlat = undefined;
            this.∆íindicesFlat = undefined;
            this.∆ítextureUVsFlat = undefined;
            this.∆íiBones = undefined;
            this.∆íweights = undefined;
        }
        createVerticesFlat() {
            let positions = [];
            let bones = [];
            let indices = [];
            let i = 0;
            for (let face of this.mesh.faces)
                for (let index of face.indices) {
                    indices.push(i++);
                    positions.push(this.mesh.vertices.position(index));
                    let bone = this.mesh.vertices.bones(index);
                    if (bone)
                        bones.push(bone);
                }
            this.∆íindicesFlat = new Uint16Array(indices);
            this.∆íiBonesFlat = new Uint8Array(bones.flatMap((_bones) => {
                return [..._bones.map(_bone => _bone.index)];
            }));
            this.∆íweightsFlat = new Float32Array(bones.flatMap((_bones) => {
                return [..._bones.map(_bone => _bone.weight)];
            }));
            return new Float32Array(positions.flatMap(_v => [..._v.get()]));
        }
        createNormalsFlat() {
            let normals = [];
            let zero = FudgeCore.Vector3.ZERO();
            for (let face of this.mesh.faces) {
                // store the face normal at the position of the third vertex
                normals.push(zero);
                normals.push(zero);
                normals.push(face.normal);
            }
            this.∆ínormalsFlat = new Float32Array(normals.flatMap(_n => [..._n.get()]));
            return this.∆ínormalsFlat;
        }
        createTextureUVsFlat() {
            let uv = [];
            // create unique vertices for each face, tripling the number
            for (let i = 0; i < this.indices.length; i++) {
                let index = this.indices[i] * 2;
                uv.push(this.textureUVs[index], this.textureUVs[index + 1]);
            }
            return new Float32Array(uv);
        }
    }
    FudgeCore.RenderMesh = RenderMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class RenderParticles extends FudgeCore.Render {
        static drawParticles() {
            // console.log(RenderParticles.crc3);
        }
    }
    FudgeCore.RenderParticles = RenderParticles;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Controls the rendering of a branch, using the given {@link ComponentCamera},
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of {@link Framing} objects. The stages involved are in order of rendering
     * {@link Render}.viewport -> {@link Viewport}.source -> {@link Viewport}.destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022
     * @link https://github.com/JirkaDellOro/FUDGE/wiki/Viewport
     */
    class Viewport extends FudgeCore.EventTarget∆í {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the branch.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true;
            this.adjustingCamera = true;
            this.physicsDebugMode = FudgeCore.PHYSICS_DEBUGMODE.NONE;
            this.componentsPick = new FudgeCore.RecycableArray();
            this.#branch = null; // The to render with all its descendants.
            this.#crc2 = null;
            this.#canvas = null;
            /**
             * Handle drag-drop events and dispatch to viewport as FUDGE-Event
             */
            this.hndDragDropEvent = (_event) => {
                let _dragevent = _event;
                switch (_dragevent.type) {
                    case "dragover":
                    case "drop":
                        _dragevent.preventDefault();
                        _dragevent.dataTransfer.effectAllowed = "none";
                        break;
                    case "dragstart":
                        // just dummy data,  valid data should be set in handler registered by the user
                        _dragevent.dataTransfer.setData("text", "Hallo");
                        // TODO: check if there is a better solution to hide the ghost image of the draggable object
                        _dragevent.dataTransfer.setDragImage(new Image(), 0, 0);
                        break;
                }
                let event = new FudgeCore.EventDragDrop("∆í" + _event.type, _dragevent);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle pointer events and dispatch to viewport as FUDGE-Event
             */
            this.hndPointerEvent = (_event) => {
                let event = new FudgeCore.EventPointer("∆í" + _event.type, _event);
                this.addCanvasPosition(event);
                this.dispatchEvent(event);
            };
            /**
             * Handle keyboard events and dispatch to viewport as FUDGE-Event, if the viewport has the focus
             */
            this.hndKeyboardEvent = (_event) => {
                if (!this.hasFocus)
                    return;
                let event = new FudgeCore.EventKeyboard("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
            /**
             * Handle wheel event and dispatch to viewport as FUDGE-Event
             */
            this.hndWheelEvent = (_event) => {
                let event = new FudgeCore.EventWheel("∆í" + _event.type, _event);
                this.dispatchEvent(event);
            };
            // #endregion
        }
        #branch; // The to render with all its descendants.
        #crc2;
        #canvas;
        //#endregion
        // #region Events (passing from canvas to viewport and from there into branch)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
         */
        initialize(_name, _branch, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.#canvas = _canvas;
            this.#crc2 = _canvas.getContext("2d");
            this.rectSource = FudgeCore.Render.getCanvasRect();
            this.rectDestination = this.getClientRectangle();
            this.setBranch(_branch);
        }
        /**
         * Retrieve the destination canvas
         */
        getCanvas() {
            return this.#canvas;
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        getContext() {
            return this.#crc2;
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.width, this.#canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
        }
        /**
         * Set the branch to be drawn in the viewport.
         */
        setBranch(_branch) {
            // TODO: figure out what the event handling was created for. Doesn't have another effect than information on the console (deactivated)
            if (this.#branch) {
                this.#branch.removeEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.#branch.removeEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
            this.#branch = _branch;
            if (this.#branch) {
                this.#branch.addEventListener("componentAdd" /* COMPONENT_ADD */, this.hndComponentEvent);
                this.#branch.addEventListener("componentRemove" /* COMPONENT_REMOVE */, this.hndComponentEvent);
            }
        }
        /**
         * Retrieve the branch this viewport renders
         */
        getBranch() {
            return this.#branch;
        }
        /**
         * Logs this viewports scenegraph to the console.
         * TODO: remove this method, since it's implemented in Debug
         */
        showSceneGraph() {
            FudgeCore.Debug.branch(this.#branch);
        }
        // #region Drawing
        /**
         * Draw this viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         */
        draw(_calculateTransforms = true) {
            if (!this.#branch)
                return;
            FudgeCore.Render.resetFrameBuffer();
            if (!this.camera.isActive)
                return;
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            if (_calculateTransforms)
                this.calculateTransforms();
            FudgeCore.Render.clear(this.camera.clrBackground);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY)
                FudgeCore.Render.draw(this.camera);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE) {
                FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
            }
            this.#crc2.imageSmoothingEnabled = false;
            this.#crc2.drawImage(FudgeCore.Render.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
         * Calculate the cascade of transforms in this branch and store the results as mtxWorld in the {@link Node}s and {@link ComponentMesh}es
         */
        calculateTransforms() {
            let mtxRoot = FudgeCore.Matrix4x4.IDENTITY();
            if (this.#branch.getParent())
                mtxRoot = this.#branch.getParent().mtxWorld;
            FudgeCore.Render.prepare(this.#branch, null, mtxRoot);
            this.componentsPick = FudgeCore.Render.componentsPick;
        }
        dispatchPointerEvent(_event) {
            let posClient = new FudgeCore.Vector2(_event.clientX, _event.clientY);
            let ray = this.getRayFromClient(posClient);
            // let cameraPicks: RecycableArray<Node> = Recycler.get(RecycableArray); //TODO: think about optimization later
            let cameraPicks = [];
            let otherPicks = [];
            for (let cmpPick of this.componentsPick)
                cmpPick.pick == FudgeCore.PICK.CAMERA ? cameraPicks.push(cmpPick.node) : otherPicks.push(cmpPick);
            if (cameraPicks.length) {
                let picks = FudgeCore.Picker.pickCamera(cameraPicks, this.camera, this.pointClientToProjection(posClient));
                for (let pick of picks)
                    pick.node.dispatchEvent(_event);
            }
            for (let cmpPick of otherPicks) {
                cmpPick.pickAndDispatch(ray, _event);
            }
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas
         */
        adjustFrames() {
            // get the rectangle of the canvas area as displayed (consider css)
            let rectClient = this.getClientRectangle();
            // adjust the canvas size according to the given framing applied to client
            let rectCanvas = this.frameClientToCanvas.getRect(rectClient);
            this.#canvas.width = rectCanvas.width;
            this.#canvas.height = rectCanvas.height;
            let rectTemp;
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            rectTemp = this.frameCanvasToDestination.getRect(rectCanvas);
            this.rectDestination.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            rectTemp = this.frameDestinationToSource.getRect(this.rectDestination);
            this.rectSource.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport. For now, it's always adjusted to the current viewport
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.Render.setRenderRectangle(rectRender);
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.Render.setCanvasSize(rectRender.width, rectRender.height);
            FudgeCore.Recycler.store(rectClient);
            FudgeCore.Recycler.store(rectCanvas);
            FudgeCore.Recycler.store(rectRender);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render vieport
         */
        adjustCamera() {
            let rect = FudgeCore.Render.getRenderRectangle();
            this.camera.projectCentral(rect.width / rect.height, this.camera.getFieldOfView(), this.camera.getDirection(), this.camera.getNear(), this.camera.getFar());
        }
        // #endregion
        //#region Points
        /**
         * Returns a {@link Ray} in world coordinates from this camera through the point given in client space
         */
        getRayFromClient(_point) {
            let posProjection = this.pointClientToProjection(_point);
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-posProjection.x, posProjection.y, 1));
            // ray.direction.scale(camera.distance);
            ray.origin.transform(this.camera.mtxPivot);
            ray.direction.transform(this.camera.mtxPivot, false);
            let cameraNode = this.camera.node;
            if (cameraNode) {
                ray.origin.transform(cameraNode.mtxWorld);
                ray.direction.transform(cameraNode.mtxWorld, false);
            }
            return ray;
        }
        /**
         * Returns a point on the client rectangle matching the projection of the given point in world space
         */
        pointWorldToClient(_position) {
            let projection = this.camera.pointWorldToClip(_position);
            let posClient = this.pointClipToClient(projection.toVector2());
            return posClient;
        }
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.getClientRectangle());
            result = this.frameCanvasToDestination.getPoint(result, this.getCanvasRectangle());
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            // console.log(projectionRectangle.toString());
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point on a projection surface in the hypothetical distance of 1 to the camera
         * matching the given point on the client rectangle
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.Render.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.Render.rectClip.pointToRect(_normed, this.getCanvasRectangle());
            return pointCanvas;
        }
        /**
         * Returns a point in the browser page matching the given point of the viewport
         */
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.#canvas.offsetLeft + _client.x, this.#canvas.offsetTop + _client.y);
            return screen;
        }
        /**
         * Switch the viewports focus on or off. Only one viewport in one FUDGE instance can have the focus, thus receiving keyboard events.
         * So a viewport currently having the focus will lose it, when another one receives it. The viewports fire {@link Event∆í}s accordingly.
         * // TODO: examine, if this can be achieved by regular DOM-Focus and tabindex=0
         */
        setFocus(_on) {
            if (_on) {
                if (Viewport.focus == this)
                    return;
                if (Viewport.focus)
                    Viewport.focus.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = this;
                this.dispatchEvent(new Event("focusin" /* FOCUS_IN */));
            }
            else {
                if (Viewport.focus != this)
                    return;
                this.dispatchEvent(new Event("focusout" /* FOCUS_OUT */));
                Viewport.focus = null;
            }
        }
        /**
         * De- / Activates the given pointer event to be propagated into the viewport as FUDGE-Event
         */
        activatePointerEvent(_type, _on) {
            this.activateEvent(this.#canvas, _type, this.hndPointerEvent, _on);
        }
        /**
         * De- / Activates the given keyboard event to be propagated into the viewport as FUDGE-Event
         */
        activateKeyboardEvent(_type, _on) {
            this.activateEvent(this.#canvas.ownerDocument, _type, this.hndKeyboardEvent, _on);
        }
        /**
         * De- / Activates the given drag-drop event to be propagated into the viewport as FUDGE-Event
         */
        activateDragDropEvent(_type, _on) {
            if (_type == "\u0192dragstart" /* START */)
                this.#canvas.draggable = _on;
            this.activateEvent(this.#canvas, _type, this.hndDragDropEvent, _on);
        }
        /**
         * De- / Activates the wheel event to be propagated into the viewport as FUDGE-Event
         */
        activateWheelEvent(_type, _on) {
            this.activateEvent(this.#canvas, _type, this.hndWheelEvent, _on);
        }
        /**
         * Add position of the pointer mapped to canvas-coordinates as canvasX, canvasY to the event
         */
        addCanvasPosition(event) {
            event.canvasX = this.#canvas.width * event.pointerX / event.clientRect.width;
            event.canvasY = this.#canvas.height * event.pointerY / event.clientRect.height;
        }
        activateEvent(_target, _type, _handler, _on) {
            _type = _type.slice(1); // chip the ∆ílorin
            if (_on)
                _target.addEventListener(_type, _handler);
            else
                _target.removeEventListener(_type, _handler);
        }
        hndComponentEvent(_event) {
            // TODO: find out what the idea was here...
            // Debug.fudge(_event);
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a Fudge-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static async load(_multiple = false) {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = _multiple;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            return new Promise(_resolve => {
                function hndLoaded(_event) {
                    FileIoBrowserLocal.removeEventListener("fileLoaded" /* FILE_LOADED */, hndLoaded);
                    _resolve(_event.detail.mapFilenameToContent);
                }
                FileIoBrowserLocal.addEventListener("fileLoaded" /* FILE_LOADED */, hndLoaded);
                FileIoBrowserLocal.selector.click();
            });
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        static save(_toSave, _type = "text/plain") {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: _type });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            return new Promise(_resolve => {
                _resolve(_toSave);
                // function hndSaved(_event: Event): void {
                //   FileIoBrowserLocal.removeEventListener(EVENT.FILE_SAVED, hndSaved);
                //   _resolve((<CustomEvent>_event).detail);
                // }
                // FileIoBrowserLocal.addEventListener(EVENT.FILE_SAVED, hndSaved);
                // let event: CustomEvent = new CustomEvent(EVENT.FILE_SAVED, { detail: { mapFilenameToContent: _toSave } });
                // FileIoBrowserLocal.targetStatic.dispatchEvent(event);
            });
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Mutable array of {@link Mutable}s. The {@link Mutator}s of the entries are included as array in the {@link Mutator}
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class MutableArray extends Array {
        rearrange(_sequence) {
            let length = this.length;
            for (let index of _sequence) {
                let original = this[index];
                // TODO: optimize, copy only double entries
                //@ts-ignore
                let copy = new original.constructor();
                copy.mutate(original.getMutator());
                this.push(copy);
            }
            this.splice(0, length);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let entry in this)
                types[entry] = this[entry].constructor.name;
            return types;
        }
        getMutator() {
            return this.map((_value) => _value.getMutator());
        }
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        async mutate(_mutator) {
            for (let entry in this)
                await this[entry].mutate(_mutator[entry]);
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         */
        updateMutator(_mutator) {
            for (let entry in this) {
                let mutatorValue = _mutator[entry];
                if (!mutatorValue)
                    continue;
                if (this[entry] instanceof FudgeCore.Mutable)
                    _mutator[entry] = this[entry].getMutator();
                else
                    _mutator[entry] = this[entry];
            }
        }
    }
    FudgeCore.MutableArray = MutableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MODE;
    (function (MODE) {
        MODE[MODE["EDITOR"] = 0] = "EDITOR";
        MODE[MODE["RUNTIME"] = 1] = "RUNTIME";
    })(MODE = FudgeCore.MODE || (FudgeCore.MODE = {}));
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    class Project {
        /**
         * Registers the resource and generates an id for it by default.
         * If the resource already has an id, thus having been registered, its deleted from the list and registered anew.
         * It's possible to pass an id, but should not be done except by the Serializer.
         */
        static register(_resource, _idResource) {
            if (_resource.idResource)
                if (_resource.idResource == _idResource)
                    return;
                else
                    this.deregister(_resource);
            _resource.idResource = _idResource || Project.generateId(_resource);
            Project.resources[_resource.idResource] = _resource;
        }
        static deregister(_resource) {
            delete (Project.resources[_resource.idResource]);
            delete (Project.serialization[_resource.idResource]);
        }
        static clear() {
            Project.resources = {};
            Project.serialization = {};
            Project.scriptNamespaces = {};
        }
        // <T extends Component>(_class: new () => T): T[] {
        //   return <T[]>(this.components[_class.name] || []).slice(0);
        // }
        static getResourcesOfType(_type) {
            let found = {};
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource instanceof _type)
                    found[resourceId] = resource;
            }
            return found;
        }
        /**
         * Generate a user readable and unique id using the type of the resource, the date and random numbers
         * @param _resource
         */
        static generateId(_resource) {
            // TODO: build id and integrate info from resource, not just date
            let idResource;
            do
                idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
            while (Project.resources[idResource]);
            return idResource;
        }
        /**
         * Tests, if an object is a {@link SerializableResource}
         * @param _object The object to examine
         */
        static isResource(_object) {
            return (Reflect.has(_object, "idResource"));
        }
        /**
         * Retrieves the resource stored with the given id
         */
        static async getResource(_idResource) {
            let resource = Project.resources[_idResource];
            if (!resource) {
                let serialization = Project.serialization[_idResource];
                if (!serialization) {
                    FudgeCore.Debug.error("Resource not found", _idResource);
                    return null;
                }
                resource = await Project.deserializeResource(serialization);
            }
            return resource;
        }
        /**
         * Creates and registers a resource from a {@link Node}, copying the complete graph starting with it
         * @param _node A node to create the resource from
         * @param _replaceWithInstance if true (default), the node used as origin is replaced by a {@link GraphInstance} of the {@link Graph} created
         */
        static async registerAsGraph(_node, _replaceWithInstance = true) {
            let serialization = _node.serialize();
            let graph = new FudgeCore.Graph(_node.name);
            await graph.deserialize(serialization);
            Project.register(graph);
            if (_replaceWithInstance && _node.getParent()) {
                let instance = await Project.createGraphInstance(graph);
                _node.getParent().replaceChild(_node, instance);
            }
            return graph;
        }
        static async createGraphInstance(_graph) {
            let instance = new FudgeCore.GraphInstance(); // TODO: cleanup since creation moved here
            await instance.set(_graph);
            return instance;
        }
        static registerGraphInstanceForResync(_instance) {
            let instances = Project.graphInstancesToResync[_instance.idSource] || [];
            instances.push(_instance);
            Project.graphInstancesToResync[_instance.idSource] = instances;
        }
        static async resyncGraphInstances(_graph) {
            let instances = Project.graphInstancesToResync[_graph.idResource];
            if (!instances)
                return;
            for (let instance of instances)
                await instance.connectToGraph();
            delete (Project.graphInstancesToResync[_graph.idResource]);
        }
        static registerScriptNamespace(_namespace) {
            let name = FudgeCore.Serializer.registerNamespace(_namespace);
            if (!Project.scriptNamespaces[name])
                Project.scriptNamespaces[name] = _namespace;
        }
        static getComponentScripts() {
            let compoments = {};
            for (let namespace in Project.scriptNamespaces) {
                compoments[namespace] = [];
                for (let name in Project.scriptNamespaces[namespace]) {
                    let script = Reflect.get(Project.scriptNamespaces[namespace], name);
                    // is script a subclass of ComponentScript? instanceof doesn't work, since no instance is created
                    // let superclass: Object = script;
                    // while (superclass) {
                    //   superclass = Reflect.getPrototypeOf(superclass);
                    //   if (superclass == ComponentScript) {
                    //     scripts.push(script);
                    //     break;
                    //   }
                    // }
                    // Using Object.create doesn't call the constructor, but instanceof can be used. More elegant than the loop above, though maybe not as performant. 
                    let o = Object.create(script);
                    if (o.prototype instanceof FudgeCore.ComponentScript)
                        compoments[namespace].push(script);
                }
            }
            return compoments;
        }
        static async loadScript(_url) {
            let script = document.createElement("script");
            script.type = "text/javascript";
            // script.type = "module";
            script.async = false;
            // script.addEventListener("load", handleLoadedScript)
            let head = document.head;
            head.appendChild(script);
            FudgeCore.Debug.log("Loading: ", _url);
            return new Promise((resolve, reject) => {
                script.addEventListener("load", () => resolve());
                script.addEventListener("error", () => {
                    FudgeCore.Debug.error("Loading script", _url);
                    reject();
                });
                script.src = _url.toString();
            });
        }
        static async loadResources(_url) {
            const response = await fetch(_url);
            const resourceFileContent = await response.text();
            let serialization = FudgeCore.Serializer.parse(resourceFileContent);
            let reconstruction = await Project.deserialize(serialization);
            return reconstruction;
        }
        static async loadResourcesFromHTML() {
            const head = document.head;
            let links = head.querySelectorAll("link[type=resources]");
            for (let link of links) {
                let url = link.getAttribute("src");
                await Project.loadResources(url);
            }
        }
        /**
         * Serialize all resources
         */
        static serialize() {
            let serialization = {};
            for (let idResource in Project.resources) {
                let resource = Project.resources[idResource];
                if (idResource != resource.idResource)
                    FudgeCore.Debug.error("Resource-id mismatch", resource);
                serialization[idResource] = FudgeCore.Serializer.serialize(resource);
            }
            return serialization;
        }
        /**
         * Create resources from a serialization, deleting all resources previously registered
         * @param _serialization
         */
        static async deserialize(_serialization) {
            Project.serialization = _serialization;
            Project.resources = {};
            for (let idResource in _serialization) {
                let serialization = _serialization[idResource];
                let resource = await Project.deserializeResource(serialization);
                if (resource)
                    Project.resources[idResource] = resource;
            }
            return Project.resources;
        }
        static async deserializeResource(_serialization) {
            return FudgeCore.Serializer.deserialize(_serialization);
        }
    }
    Project.resources = {};
    Project.serialization = {};
    Project.scriptNamespaces = {};
    Project.baseURL = new URL(location.toString());
    Project.mode = MODE.RUNTIME;
    Project.graphInstancesToResync = {};
    FudgeCore.Project = Project;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let ComponentType;
    (function (ComponentType) {
        ComponentType[ComponentType["BYTE"] = 5120] = "BYTE";
        ComponentType[ComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        ComponentType[ComponentType["SHORT"] = 5122] = "SHORT";
        ComponentType[ComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        ComponentType[ComponentType["INT"] = 5124] = "INT";
        ComponentType[ComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        ComponentType[ComponentType["FLOAT"] = 5126] = "FLOAT";
    })(ComponentType || (ComponentType = {}));
    class GLTFLoader {
        constructor(_gltf, _uri) {
            this.gltf = _gltf;
            this.uri = _uri;
        }
        #scenes;
        #nodes;
        #cameras;
        #animations;
        #meshes;
        #skeletons;
        #buffers;
        static async LOAD(_uri) {
            if (!this.loaders)
                this.loaders = {};
            if (!this.loaders[_uri]) {
                const response = await fetch(_uri);
                const gltf = await response.json();
                this.loaders[_uri] = new GLTFLoader(gltf, _uri);
            }
            return this.loaders[_uri];
        }
        async getScene(_name) {
            const iScene = _name ? this.gltf.scenes.findIndex(scene => scene.name == _name) : this.gltf.scene;
            if (iScene == -1)
                throw new Error(`Couldn't find name ${_name} in gltf scenes.`);
            return await this.getSceneByIndex(iScene);
        }
        async getSceneByIndex(_iScene = this.gltf.scene) {
            if (!this.#scenes)
                this.#scenes = [];
            if (!this.#scenes[_iScene]) {
                const gltfScene = this.gltf.scenes[_iScene];
                const scene = new FudgeCore.Graph(gltfScene.name);
                for (const iNode of gltfScene.nodes)
                    scene.addChild(await this.getNodeByIndex(iNode));
                FudgeCore.Project.register(scene);
                this.#scenes[_iScene] = scene;
            }
            return FudgeCore.Project.createGraphInstance(this.#scenes[_iScene]);
        }
        async getNode(_name) {
            const iNode = this.gltf.nodes.findIndex(node => node.name == _name);
            if (iNode == -1)
                throw new Error(`Couldn't find name ${_name} in gltf nodes.`);
            return await this.getNodeByIndex(iNode);
        }
        async getNodeByIndex(_iNode) {
            if (!this.#nodes)
                this.#nodes = [];
            if (!this.#nodes[_iNode]) {
                const gltfNode = this.gltf.nodes[_iNode];
                const node = new FudgeCore.Node(gltfNode.name);
                // check for children
                if (gltfNode.children)
                    for (const iNode of gltfNode.children)
                        node.addChild(await this.getNodeByIndex(iNode));
                // check for transformation
                if (gltfNode.matrix || gltfNode.rotation || gltfNode.scale || gltfNode.translation) {
                    if (!node.getComponent(FudgeCore.ComponentTransform))
                        node.addComponent(new FudgeCore.ComponentTransform());
                    if (gltfNode.matrix) {
                        node.mtxLocal.set(Float32Array.from(gltfNode.matrix));
                    }
                    else {
                        if (gltfNode.rotation)
                            node.mtxLocal.rotate(new FudgeCore.Vector3(...gltfNode.rotation.map(rotation => rotation * 180 / Math.PI)));
                        if (gltfNode.scale)
                            node.mtxLocal.scale(new FudgeCore.Vector3(...gltfNode.scale));
                        if (gltfNode.translation)
                            node.mtxLocal.translate(new FudgeCore.Vector3(...gltfNode.translation));
                    }
                }
                // check for camera
                if (gltfNode.camera != undefined) {
                    node.addComponent(await this.getCameraByIndex(gltfNode.camera));
                }
                // check for mesh
                if (gltfNode.mesh != undefined) {
                    node.addComponent(new FudgeCore.ComponentMesh(await this.getMeshByIndex(gltfNode.mesh)));
                    if (node.getComponent(FudgeCore.ComponentMesh).mesh instanceof FudgeCore.MeshSkin) {
                        if (!GLTFLoader.defaultSkinMaterial)
                            GLTFLoader.defaultSkinMaterial = new FudgeCore.Material("GLTFDefaultSkinMaterial", FudgeCore.ShaderGouraudSkin, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white")));
                        node.addComponent(new FudgeCore.ComponentMaterial(GLTFLoader.defaultSkinMaterial));
                    }
                    else {
                        if (!GLTFLoader.defaultMaterial)
                            GLTFLoader.defaultMaterial = new FudgeCore.Material("GLTFDefaultMaterial", FudgeCore.ShaderGouraud, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white")));
                        node.addComponent(new FudgeCore.ComponentMaterial(GLTFLoader.defaultMaterial));
                    }
                }
                // check for skeleton        
                if (gltfNode.skin != undefined) {
                    const skeleton = await this.getSkeletonByIndex(gltfNode.skin);
                    node.addChild(skeleton);
                    if (node.getComponent(FudgeCore.ComponentMesh))
                        node.getComponent(FudgeCore.ComponentMesh).bindSkeleton(skeleton);
                    for (const iAnimation of this.findSkeletalAnimationIndices(gltfNode.skin)) {
                        skeleton.addComponent(new FudgeCore.ComponentAnimator(await this.getAnimationByIndex(iAnimation)));
                    }
                }
                this.#nodes[_iNode] = node;
            }
            return this.#nodes[_iNode];
        }
        async getCamera(_name) {
            const iCamera = this.gltf.cameras.findIndex(camera => camera.name == _name);
            if (iCamera == -1)
                throw new Error(`Couldn't find name ${_name} in gltf cameras.`);
            return await this.getCameraByIndex(iCamera);
        }
        async getCameraByIndex(_iCamera) {
            if (!this.#cameras)
                this.#cameras = [];
            if (!this.#cameras[_iCamera]) {
                const gltfCamera = this.gltf.cameras[_iCamera];
                const camera = new FudgeCore.ComponentCamera();
                if (gltfCamera.perspective)
                    camera.projectCentral(gltfCamera.perspective.aspectRatio, gltfCamera.perspective.yfov * 180 / Math.PI, null, gltfCamera.perspective.znear, gltfCamera.perspective.zfar);
                else
                    camera.projectOrthographic(-gltfCamera.orthographic.xmag, gltfCamera.orthographic.xmag, -gltfCamera.orthographic.ymag, gltfCamera.orthographic.ymag);
                return camera;
            }
            return this.#cameras[_iCamera];
        }
        async getAnimation(_name) {
            const iAnimation = this.gltf.animations.findIndex(animation => animation.name == _name);
            if (iAnimation == -1)
                throw new Error(`Couldn't find name ${_name} in gltf animations.`);
            return await this.getAnimationByIndex(iAnimation);
        }
        async getAnimationByIndex(_iAnimation) {
            if (!this.#animations)
                this.#animations = [];
            if (!this.#animations[_iAnimation]) {
                const gltfAnimation = this.gltf.animations[_iAnimation];
                if (this.isSkeletalAnimation(gltfAnimation)) {
                    // map channels to an animation structure for animating the local bone matrices
                    const animationStructure = { mtxBoneLocals: {} };
                    for (const gltfChannel of gltfAnimation.channels) {
                        const boneName = this.#nodes[gltfChannel.target.node].name;
                        // create new 4 by 4 matrix animation structure if there is no entry for the bone name
                        if (!animationStructure.mtxBoneLocals[boneName])
                            animationStructure.mtxBoneLocals[boneName] = {};
                        // set the vector 3 animation structure of the entry refered by the channel target path
                        const transformationType = gltfChannel.target.path;
                        if (transformationType)
                            animationStructure.mtxBoneLocals[boneName][transformationType] =
                                await this.getAnimationSequenceVector3(gltfAnimation.samplers[gltfChannel.sampler], transformationType);
                    }
                    this.#animations[_iAnimation] = new FudgeCore.Animation(gltfAnimation.name, animationStructure);
                }
                else
                    throw new Error("Non-skeletal animations are not supported yet.");
            }
            return this.#animations[_iAnimation];
        }
        async getMesh(_name) {
            const iMesh = this.gltf.meshes.findIndex(mesh => mesh.name == _name);
            if (iMesh == -1)
                throw new Error(`Couldn't find name ${_name} in gltf meshes.`);
            return await this.getMeshByIndex(iMesh);
        }
        async getMeshByIndex(_iMesh) {
            if (!this.#meshes)
                this.#meshes = [];
            if (!this.#meshes[_iMesh]) {
                const gltfMesh = this.gltf.meshes[_iMesh];
                this.#meshes[_iMesh] = await (gltfMesh.primitives[0].attributes.JOINTS_0 != undefined ?
                    new FudgeCore.MeshSkin().load(this, _iMesh) :
                    new FudgeCore.MeshGLTF().load(this, _iMesh));
            }
            return this.#meshes[_iMesh];
        }
        async getSkeleton(_name) {
            const iSkeleton = this.gltf.skins.findIndex(skeleton => skeleton.name == _name);
            if (iSkeleton == -1)
                throw new Error(`Couldn't find name ${_name} in gltf skins.`);
            return await this.getSkeletonByIndex(iSkeleton);
        }
        async getSkeletonByIndex(_iSkeleton) {
            if (!this.#skeletons)
                this.#skeletons = [];
            if (!this.#skeletons[_iSkeleton]) {
                const gltfSkeleton = this.gltf.skins[_iSkeleton];
                const skeleton = new FudgeCore.Skeleton(gltfSkeleton.name);
                // add all bones as children/descendants by adding the root bone
                skeleton.addChild(await this.getNodeByIndex(gltfSkeleton.joints[0]));
                // convert float array to array of matrices and register bones
                const floatArray = await this.getFloat32Array(gltfSkeleton.inverseBindMatrices);
                const span = 16;
                for (let iFloat = 0, iBone = 0; iFloat < floatArray.length; iFloat += span, iBone++) {
                    const mtxBindInverse = new FudgeCore.Matrix4x4();
                    mtxBindInverse.set(floatArray.subarray(iFloat, iFloat + span));
                    skeleton.registerBone(this.#nodes[gltfSkeleton.joints[iBone]], mtxBindInverse);
                }
                FudgeCore.Project.register(skeleton);
                this.#skeletons[_iSkeleton] = skeleton;
            }
            return await FudgeCore.SkeletonInstance.CREATE(this.#skeletons[_iSkeleton]);
        }
        async getUint8Array(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            if (this.gltf.accessors[_iAccessor]?.componentType == ComponentType.UNSIGNED_BYTE)
                return array;
            else {
                console.warn(`Expected component type UNSIGNED_BYTE but was ${ComponentType[this.gltf.accessors[_iAccessor]?.componentType]}.`);
                return Uint8Array.from(array);
            }
        }
        async getUint16Array(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            if (this.gltf.accessors[_iAccessor]?.componentType == ComponentType.UNSIGNED_SHORT)
                return array;
            else {
                console.warn(`Expected component type UNSIGNED_SHORT but was ${ComponentType[this.gltf.accessors[_iAccessor]?.componentType]}.`);
                return Uint16Array.from(array);
            }
        }
        async getUint32Array(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            if (this.gltf.accessors[_iAccessor]?.componentType == ComponentType.UNSIGNED_INT)
                return array;
            else {
                console.warn(`Expected component type UNSIGNED_INT but was ${ComponentType[this.gltf.accessors[_iAccessor]?.componentType]}.`);
                return Uint32Array.from(array);
            }
        }
        async getFloat32Array(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            if (this.gltf.accessors[_iAccessor]?.componentType == ComponentType.FLOAT)
                return array;
            else {
                console.warn(`Expected component type FLOAT but was ${ComponentType[this.gltf.accessors[_iAccessor]?.componentType]}.`);
                return Float32Array.from(array);
            }
        }
        async getBufferData(_iAccessor) {
            const gltfAccessor = this.gltf.accessors[_iAccessor];
            if (!gltfAccessor)
                throw new Error("Couldn't find accessor");
            const gltfBufferView = this.gltf.bufferViews[gltfAccessor.bufferView];
            if (!gltfBufferView)
                throw new Error("Couldn't find buffer view");
            const gltfBuffer = this.gltf.buffers[gltfBufferView.buffer];
            if (!gltfBuffer)
                throw new Error("Couldn't find buffer");
            if (!this.#buffers)
                this.#buffers = [];
            if (!this.#buffers[gltfBufferView.buffer]) {
                const response = await fetch(gltfBuffer.uri);
                const blob = await response.blob();
                this.#buffers[gltfBufferView.buffer] = await blob.arrayBuffer();
            }
            const buffer = this.#buffers[gltfBufferView.buffer];
            const byteOffset = gltfBufferView.byteOffset || 0;
            const byteLength = gltfBufferView.byteLength || 0;
            switch (gltfAccessor.componentType) {
                case ComponentType.UNSIGNED_BYTE:
                    return new Uint8Array(buffer, byteOffset, byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case ComponentType.BYTE:
                    return new Int8Array(buffer, byteOffset, byteLength / Int8Array.BYTES_PER_ELEMENT);
                case ComponentType.UNSIGNED_SHORT:
                    return new Uint16Array(buffer, byteOffset, byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case ComponentType.SHORT:
                    return new Int16Array(buffer, byteOffset, byteLength / Int16Array.BYTES_PER_ELEMENT);
                case ComponentType.UNSIGNED_INT:
                    return new Uint32Array(buffer, byteOffset, byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case ComponentType.INT:
                    return new Int32Array(buffer, byteOffset, byteLength / Int32Array.BYTES_PER_ELEMENT);
                case ComponentType.FLOAT:
                    return new Float32Array(buffer, byteOffset, byteLength / Float32Array.BYTES_PER_ELEMENT);
                default:
                    throw new Error(`Unsupported component type: ${gltfAccessor.componentType}.`);
            }
        }
        isSkeletalAnimation(_animation) {
            return _animation.channels.every(channel => this.isBoneIndex(channel.target.node));
        }
        findSkeletalAnimationIndices(_iSkeleton) {
            return this.gltf.animations
                .filter(animation => animation.channels.every(channel => this.gltf.skins[_iSkeleton].joints.includes(channel.target.node)))
                .map((_, iAnimation) => iAnimation);
        }
        isBoneIndex(_iNode) {
            return this.gltf.skins?.flatMap(gltfSkin => gltfSkin.joints).includes(_iNode);
        }
        async getAnimationSequenceVector3(_sampler, _transformationType) {
            const input = await this.getFloat32Array(_sampler.input);
            const output = await this.getFloat32Array(_sampler.output);
            const millisPerSecond = 1000;
            const sequenceX = new FudgeCore.AnimationSequence();
            const sequenceY = new FudgeCore.AnimationSequence();
            const sequenceZ = new FudgeCore.AnimationSequence();
            for (let i = 0; i < input.length; ++i) {
                const vector = _transformationType == "rotation" ?
                    new FudgeCore.Quaternion(output[i * 4 + 0], output[i * 4 + 1], output[i * 4 + 2], output[i * 4 + 3]).toDegrees() :
                    { x: output[i * 3 + 0], y: output[i * 3 + 1], z: output[i * 3 + 2] };
                sequenceX.addKey(new FudgeCore.AnimationKey(millisPerSecond * input[i], vector.x));
                sequenceY.addKey(new FudgeCore.AnimationKey(millisPerSecond * input[i], vector.y));
                sequenceZ.addKey(new FudgeCore.AnimationKey(millisPerSecond * input[i], vector.z));
            }
            return {
                x: sequenceX,
                y: sequenceY,
                z: sequenceZ
            };
        }
    }
    FudgeCore.GLTFLoader = GLTFLoader;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    var Shader_1;
    // TODO: define attribute/uniforms as layout and use those consistently in shaders
    let Shader = Shader_1 = class Shader {
        /** The type of coat that can be used with this shader to create a material */
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() { return this.vertexShaderSource; }
        static getFragmentShaderSource() { return this.fragmentShaderSource; }
        static deleteProgram() { }
        static useProgram() { }
        static createProgram() { }
        static registerSubclass(_subclass) { return Shader_1.subclasses.push(_subclass) - 1; }
    };
    /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
    Shader.baseClass = Shader_1;
    /** list of all the subclasses derived from this class, if they registered properly*/
    Shader.subclasses = [];
    Shader = Shader_1 = __decorate([
        FudgeCore.RenderInjectorShader.decorate
    ], Shader);
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderFlat extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderFlat.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat);
    ShaderFlat.define = [
        "LIGHT",
        "FLAT",
        "CAMERA"
    ];
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderFlatSkin extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define SKIN

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define SKIN

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderFlatSkin.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatSkin);
    ShaderFlatSkin.define = [
        "LIGHT",
        "FLAT",
        "SKIN"
    ];
    FudgeCore.ShaderFlatSkin = ShaderFlatSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderFlatTextured extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define FLAT
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderFlatTextured.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTextured);
    ShaderFlatTextured.define = [
        "LIGHT",
        "FLAT",
        "TEXTURE",
        "CAMERA"
    ];
    FudgeCore.ShaderFlatTextured = ShaderFlatTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderGouraud extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderGouraud.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraud);
    ShaderGouraud.define = [
        "LIGHT",
        "CAMERA"
    ];
    FudgeCore.ShaderGouraud = ShaderGouraud;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderGouraudSkin extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatRemissive; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define SKIN

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define SKIN

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderGouraudSkin.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudSkin);
    ShaderGouraudSkin.define = [
        "LIGHT",
        "SKIN"
    ];
    FudgeCore.ShaderGouraudSkin = ShaderGouraudSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderGouraudTextured extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define LIGHT
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define LIGHT
#define TEXTURE
#define CAMERA

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderGouraudTextured.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTextured);
    ShaderGouraudTextured.define = [
        "LIGHT",
        "TEXTURE",
        "CAMERA"
    ];
    FudgeCore.ShaderGouraudTextured = ShaderGouraudTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderLit extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderLit.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLit);
    ShaderLit.define = [];
    FudgeCore.ShaderLit = ShaderLit;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderLitTextured extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define TEXTURE

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define TEXTURE

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderLitTextured.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTextured);
    ShaderLitTextured.define = [
        "TEXTURE"
    ];
    FudgeCore.ShaderLitTextured = ShaderLitTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderMatCap extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatTextured; }
        static getVertexShaderSource() {
            return `#version 300 es
#define CAMERA
#define MATCAP

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021
*/

  // MINIMAL (no define needed): buffers for transformation
uniform mat4 u_mtxMeshToView;
in vec3 a_vctPosition;

  // LIGHT: offer buffers for lighting vertices with different light types
  #if defined(LIGHT)
uniform mat4 u_mtxNormalMeshToWorld;
in vec3 a_vctNormal;
uniform float u_fDiffuse;

struct LightAmbient {
  vec4 vctColor;
};
struct LightDirectional {
  vec4 vctColor;
  vec3 vctDirection;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;

uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];
  #endif 

  // TEXTURE: offer buffers for UVs and pivot matrix
  #if defined(TEXTURE)
uniform mat3 u_mtxPivot;
in vec2 a_vctTexture;
out vec2 v_vctTexture;
  #endif

  #if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals
in vec3 a_vctNormal;
uniform mat4 u_mtxNormalMeshToWorld;
out vec2 v_vctTexture;
  #endif

  // CAMERA: offer buffer and functionality for specular reflection depending on the camera-position
  #if defined(CAMERA)
uniform float u_fSpecular;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxWorldToView;
uniform vec3 u_vctCamera;

float calculateReflection(vec3 _vctLight, vec3 _vctView, vec3 _vctNormal, float _fSpecular) {
  if(_fSpecular <= 0.0)
    return 0.0;
  vec3 vctReflection = normalize(reflect(-_vctLight, _vctNormal));
  float fHitCamera = dot(vctReflection, _vctView);
  return pow(max(fHitCamera, 0.0), _fSpecular * 10.0) * _fSpecular; // 10.0 = magic number, looks good... 
}
  #endif

  #if defined(SKIN)
uniform mat4 u_mtxMeshToWorld;
// Bones
struct Bone {
  mat4 matrix;
};

const uint MAX_BONES = 10u;

in uvec4 a_iBone;
in vec4 a_fWeight;

uniform Bone u_bones[MAX_BONES];
  #endif

  // FLAT: outbuffer is flat
  #if defined(FLAT)
flat out vec4 v_vctColor;
  #else
  // regular if not FLAT
out vec4 v_vctColor;
  #endif

void main() {
  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToView = u_mtxMeshToView;

    #if defined(LIGHT) || defined(MATCAP)
  vec3 vctNormal = a_vctNormal;
  mat4 mtxNormalMeshToWorld = u_mtxNormalMeshToWorld;
      #if defined(LIGHT)
  v_vctColor = u_fDiffuse * u_ambient.vctColor;
      #endif
    #endif

    #if defined(SKIN)
  mat4 mtxSkin = a_fWeight.x * u_bones[a_iBone.x].matrix +
    a_fWeight.y * u_bones[a_iBone.y].matrix +
    a_fWeight.z * u_bones[a_iBone.z].matrix +
    a_fWeight.w * u_bones[a_iBone.w].matrix;

  mtxMeshToView *= mtxSkin;
  mtxNormalMeshToWorld = transpose(inverse(u_mtxMeshToWorld * mtxSkin));
    #endif

    // calculate position and normal according to input and defines
  gl_Position = mtxMeshToView * vctPosition;

    #if defined(CAMERA)
  // view vector needed
  // vec4 posWorld4 = u_mtxMeshToWorld * vctPosition;
  // vec3 vctView = normalize(posWorld4.xyz/posWorld4.w - u_vctCamera);
  vec3 vctView = normalize(vec3(u_mtxMeshToWorld * vctPosition) - u_vctCamera);
    #endif

    #if defined(LIGHT)
  vctNormal = normalize(mat3(mtxNormalMeshToWorld) * vctNormal);
  // calculate the directional lighting effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    float fIllumination = -dot(vctNormal, u_directional[i].vctDirection);
    if(fIllumination > 0.0f) {
      v_vctColor += u_fDiffuse * fIllumination * u_directional[i].vctColor;
        #if defined(CAMERA)
      float fReflection = calculateReflection(u_directional[i].vctDirection, vctView, vctNormal, u_fSpecular);
      v_vctColor += fReflection * u_directional[i].vctColor;
        #endif
    }
  }
    #endif

    // TEXTURE: transform UVs
    #if defined(TEXTURE)
  v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
    #endif

    #if defined(MATCAP)
  vctNormal = normalize(mat3(u_mtxNormalMeshToWorld) * a_vctNormal);
  vctNormal = mat3(u_mtxWorldToView) * vctNormal;
  v_vctTexture = 0.5 * vctNormal.xy / length(vctNormal) + 0.5;
  v_vctTexture.y *= -1.0;
    #endif

    // always full opacity for now...
  v_vctColor.a = 1.0;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
#define CAMERA
#define MATCAP

/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021
*/

precision mediump float;

  // MINIMAL (no define needed): include base color
uniform vec4 u_vctColor;

  // FLAT: input vertex colors flat, so the third of a triangle determines the color
  #if defined(FLAT) 
flat in vec4 v_vctColor;
  // LIGHT: input vertex colors for each vertex for interpolation over the face
  #elif defined(LIGHT)
in vec4 v_vctColor;
  #endif

  // TEXTURE: input UVs and texture
  #if defined(TEXTURE) || defined(MATCAP)
in vec2 v_vctTexture;
uniform sampler2D u_texture;
  #endif

out vec4 vctFrag;

void main() {
    // MINIMAL: set the base color
  vctFrag = u_vctColor;

    // VERTEX: multiply with vertex color
    #if defined(FLAT) || defined(LIGHT)
  vctFrag *= v_vctColor;
    #endif

    // TEXTURE: multiply with texel color
    #if defined(TEXTURE) || defined(MATCAP)
  vec4 vctColorTexture = texture(u_texture, v_vctTexture);
  vctFrag *= vctColorTexture;
    #endif

    // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < 0.01)
    discard;
}
`;
        }
    }
    ShaderMatCap.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap);
    ShaderMatCap.define = [
        "CAMERA",
        "MATCAP"
    ];
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderPhong extends FudgeCore.Shader {
        static getCoat() { return FudgeCore.CoatColored; }
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Phong shading
* Implementation based on https://www.gsn-lib.org/docs/nodes/ShaderPluginNode.php
* @authors Luis Keck, HFU, 2021
*/
precision highp float;

in vec3 a_vctPosition;
in vec3 a_vctNormalVertex;
uniform mat4 u_mtxMeshToWorld;
uniform mat4 u_mtxMeshToView;
uniform mat4 u_mtxNormalMeshToWorld;

out vec3 f_normal;
out vec3 v_position;

void main() {
  f_normal = vec3(u_mtxNormalMeshToWorld * vec4(a_vctNormalVertex, 0.0));
  vec4 v_position4 = u_mtxMeshToWorld * vec4(a_vctPosition, 1.0);
  v_position = vec3(v_position4) / v_position4.w;
  gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
}
        
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Phong shading
* Implementation based on https://www.gsn-lib.org/docs/nodes/ShaderPluginNode.php
* @authors Luis Keck, HFU, 2021
*/
precision highp float;

struct LightAmbient {
    vec4 color;
};
struct LightDirectional {
    vec4 color;
    vec3 direction;
};

const uint MAX_LIGHTS_DIRECTIONAL = 100u;
uniform LightAmbient u_ambient;
uniform uint u_nLightsDirectional;
uniform LightDirectional u_directional[MAX_LIGHTS_DIRECTIONAL];

in vec3 f_normal;
in vec3 v_position;
uniform vec4 u_vctColor;
uniform float u_fSpecular;
out vec4 vctFrag;

vec3 calculateReflection(vec3 light_dir, vec3 view_dir, vec3 normal, float shininess) {
    vec3 color = vec3(1);
    vec3 R = reflect(-light_dir, normal);
    float spec_dot = max(dot(R, view_dir), 0.0);
    color += pow(spec_dot, shininess);
    return color;
}

void main() {
    vctFrag = u_ambient.color;
    for(uint i = 0u; i < u_nLightsDirectional; i++) {
        vec3 light_dir = normalize(-u_directional[i].direction);
        vec3 view_dir = normalize(v_position);
        vec3 N = normalize(f_normal);

        float illuminance = dot(light_dir, N);
        if(illuminance > 0.0) {
            vec3 reflection = calculateReflection(light_dir, view_dir, N, u_fSpecular);
            vctFrag += vec4(reflection, 1.0) * illuminance * u_directional[i].color;
        }
    }
    vctFrag *= u_vctColor;
    vctFrag.a = 1.0;
}       
`;
        }
    }
    ShaderPhong.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhong);
    ShaderPhong.define = [];
    FudgeCore.ShaderPhong = ShaderPhong;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderPick extends FudgeCore.Shader {
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
in vec3 a_vctPosition;       
uniform mat4 u_mtxMeshToView;

void main() {   
    gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform vec2 u_vctSize;
uniform vec4 u_vctColor;
out ivec4 vctFrag;

void main() {
    float id = float(u_id); 
    float pixel = trunc(gl_FragCoord.x) + u_vctSize.x * trunc(gl_FragCoord.y);

    if (pixel != id)
      discard;

    uint icolor = uint(u_vctColor.r * 255.0) << 24 | uint(u_vctColor.g * 255.0) << 16 | uint(u_vctColor.b * 255.0) << 8 | uint(u_vctColor.a * 255.0);
                
    vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, 0, 0);
}
`;
        }
    }
    ShaderPick.define = [];
    FudgeCore.ShaderPick = ShaderPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Code generated by CompileShaders.mjs using the information in CompileShaders.json */
    class ShaderPickTextured extends FudgeCore.Shader {
        static getVertexShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
in vec3 a_vctPosition;       
in vec2 a_vctTexture;
uniform mat4 u_mtxMeshToView;
uniform mat3 u_mtxPivot;

out vec2 v_vctTexture;

void main() {   
    gl_Position = u_mtxMeshToView * vec4(a_vctPosition, 1.0);
    v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;
}
`;
        }
        static getFragmentShaderSource() {
            return `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform vec2 u_vctSize;
in vec2 v_vctTexture;
uniform vec4 u_vctColor;
uniform sampler2D u_texture;

out ivec4 vctFrag;

void main() {
    float id = float(u_id); 
    float pixel = trunc(gl_FragCoord.x) + u_vctSize.x * trunc(gl_FragCoord.y);

    if (pixel != id)
      discard;
    
    vec4 vctColor = u_vctColor * texture(u_texture, v_vctTexture);
    uint icolor = uint(vctColor.r * 255.0) << 24 | uint(vctColor.g * 255.0) << 16 | uint(vctColor.b * 255.0) << 8 | uint(vctColor.a * 255.0);
  
  vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, floatBitsToInt(v_vctTexture.x), floatBitsToInt(v_vctTexture.y));
}
`;
        }
    }
    ShaderPickTextured.define = [];
    FudgeCore.ShaderPickTextured = ShaderPickTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class Skeleton extends FudgeCore.Graph {
        /**
         * Creates a new skeleton with a name
         */
        constructor(_name = "Skeleton") {
            super(_name);
            this.bones = {};
            this.mtxBindInverses = {};
            /**
             * Deregisters all bones of a removed node
             */
            this.hndChildRemove = (_event) => {
                if (_event.currentTarget != this)
                    return;
                for (const node of _event.target)
                    if (this.bones[node.name]) {
                        delete this.bones[node.name];
                        delete this.mtxBindInverses[node.name];
                    }
            };
            this.addEventListener("childRemove" /* CHILD_REMOVE */, this.hndChildRemove);
        }
        /**
         * Appends a node to this skeleton or the given parent and registers it as a bone
         * @param _mtxInit initial local matrix
         * @param _parentName name of the parent node, that must be registered as a bone
         */
        addBone(_bone, _mtxInit, _parentName) {
            if (_parentName)
                this.bones[_parentName].addChild(_bone);
            else
                this.addChild(_bone);
            if (!_bone.cmpTransform)
                _bone.addComponent(new FudgeCore.ComponentTransform());
            if (_mtxInit)
                _bone.mtxLocal.set(_mtxInit);
            this.calculateMtxWorld(_bone);
            this.registerBone(_bone);
        }
        /**
         * Registers a node as a bone with its bind inverse matrix
         * @param _bone the node to be registered, that should be a descendant of this skeleton
         * @param _mtxBindInverse a precalculated inverse matrix of the bind pose from the bone
         */
        registerBone(_bone, _mtxBindInverse = _bone.mtxWorldInverse) {
            this.bones[_bone.name] = _bone;
            this.mtxBindInverses[_bone.name] = _mtxBindInverse;
        }
        /**
         * Sets the current state of this skeleton as the default pose
         * by updating the inverse bind matrices
         */
        setDefaultPose() {
            for (const boneName in this.bones) {
                this.calculateMtxWorld(this.bones[boneName]);
                this.mtxBindInverses[boneName] = this.bones[boneName].mtxWorldInverse;
            }
        }
        indexOfBone(_boneName) {
            let index = 0;
            for (const boneName in this.bones) {
                if (_boneName == boneName)
                    return index;
                index++;
            }
            return -1;
        }
        serialize() {
            const serialization = super.serialize();
            serialization.mtxBindInverses = {};
            for (const boneName in this.mtxBindInverses)
                serialization.mtxBindInverses[boneName] = this.mtxBindInverses[boneName].serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            for (const node of this)
                if (_serialization.mtxBindInverses[node.name])
                    this.registerBone(node, await new FudgeCore.Matrix4x4().deserialize(_serialization.mtxBindInverses[node.name]));
            return this;
        }
        /**
         * Calculates and sets the world matrix of a bone relative to its parent
         */
        calculateMtxWorld(_node) {
            _node.mtxWorld.set(_node.cmpTransform ?
                FudgeCore.Matrix4x4.MULTIPLICATION(_node.getParent().mtxWorld, _node.mtxLocal) :
                _node.getParent().mtxWorld);
        }
    }
    FudgeCore.Skeleton = Skeleton;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class SkeletonInstance extends FudgeCore.GraphInstance {
        #bones;
        #mtxBoneLocals;
        #mtxBones;
        #mtxBonesUpdated;
        static async CREATE(_skeleton) {
            const skeleton = new SkeletonInstance();
            await skeleton.set(_skeleton);
            return skeleton;
        }
        get bones() {
            return this.#bones;
        }
        get mtxBoneLocals() {
            return this.#mtxBoneLocals;
        }
        /**
         * Gets the bone transformations for a vertex
         */
        get mtxBones() {
            if (this.#mtxBonesUpdated != this.timestampUpdate) {
                this.calculateMtxBones();
                this.#mtxBonesUpdated = this.timestampUpdate;
            }
            return this.#mtxBones;
        }
        /**
         * Set this skeleton instance to be a recreation of the {@link Skeleton} given
         */
        async set(_skeleton) {
            await super.set(_skeleton);
            this.skeletonSource = _skeleton;
            this.registerBones();
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.skeletonSource = FudgeCore.Project.resources[_serialization.idSource || _serialization.idResource];
            this.registerBones();
            return this;
        }
        /**
         * Resets this skeleton instance to its default pose
         */
        resetPose() {
            for (const boneName in this.bones)
                this.bones[boneName].mtxLocal.set(FudgeCore.Matrix4x4.INVERSION(this.skeletonSource.mtxBindInverses[boneName]));
        }
        applyAnimation(_mutator) {
            super.applyAnimation(_mutator);
            if (_mutator.mtxBoneLocals)
                for (const boneName in _mutator.mtxBoneLocals)
                    this.mtxBoneLocals[boneName]?.mutate(_mutator.mtxBoneLocals[boneName]);
            if (_mutator.bones)
                for (const boneName in _mutator.bones)
                    this.bones[boneName]?.applyAnimation(_mutator.bones[boneName]);
        }
        calculateMtxBones() {
            this.#mtxBones = [];
            for (const boneName in this.bones) {
                // bone matrix T = N^-1 * B_delta * B_0^-1 * S
                const mtxBone = this.getParent()?.mtxWorldInverse.clone || FudgeCore.Matrix4x4.IDENTITY();
                mtxBone.multiply(this.bones[boneName].mtxWorld);
                mtxBone.multiply(this.skeletonSource.mtxBindInverses[boneName]);
                if (this.cmpTransform)
                    mtxBone.multiply(FudgeCore.Matrix4x4.INVERSION(this.mtxLocal));
                this.#mtxBones.push(mtxBone);
            }
        }
        registerBones() {
            this.#bones = {};
            this.#mtxBoneLocals = {};
            for (const node of this)
                if (this.skeletonSource.mtxBindInverses[node.name]) {
                    this.bones[node.name] = node;
                    this.mtxBoneLocals[node.name] = node.mtxLocal;
                }
        }
    }
    FudgeCore.SkeletonInstance = SkeletonInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MIPMAP;
    (function (MIPMAP) {
        MIPMAP[MIPMAP["CRISP"] = 0] = "CRISP";
        MIPMAP[MIPMAP["MEDIUM"] = 1] = "MEDIUM";
        MIPMAP[MIPMAP["BLURRY"] = 2] = "BLURRY";
    })(MIPMAP = FudgeCore.MIPMAP || (FudgeCore.MIPMAP = {}));
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Texture = class Texture extends FudgeCore.Mutable {
        constructor(_name = "Texture") {
            super();
            this.idResource = undefined;
            this.mipmap = MIPMAP.CRISP;
            this.name = _name;
        }
        useRenderData() { }
        refresh() {
            this.renderData = null;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                idResource: this.idResource,
                name: this.name,
                mipmap: MIPMAP[this.mipmap]
            };
            return serialization;
        }
        async deserialize(_serialization) {
            FudgeCore.Project.register(this, _serialization.idResource);
            this.name = _serialization.name;
            this.mipmap = MIPMAP[_serialization.mipmap];
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.mipmap)
                types.mipmap = MIPMAP;
            return types;
        }
        reduceMutator(_mutator) {
            delete _mutator.idResource;
        }
    };
    Texture = __decorate([
        FudgeCore.RenderInjectorTexture.decorate
    ], Texture);
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor(_url) {
            super();
            this.image = null;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get texImageSource() {
            return this.image;
        }
        /**
         * Asynchronously loads the image from the given url
         */
        async load(_url) {
            this.url = _url;
            this.image = new Image();
            // const response: Response = await window.fetch(this.url);
            // const blob: Blob = await response.blob();
            // let objectURL: string = URL.createObjectURL(blob);
            // this.image.src = objectURL;
            return new Promise((resolve, reject) => {
                this.image.addEventListener("load", () => {
                    this.renderData = null; // refresh render data on next draw call
                    resolve();
                });
                this.image.addEventListener("error", () => reject());
                this.image.src = new URL(this.url.toString(), FudgeCore.Project.baseURL).toString();
            });
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                type: this.type,
                [super.constructor.name]: super.serialize()
            };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.load(_serialization.url);
            // this.type is an accessor of Mutable doesn't need to be deserialized
            return this;
        }
        async mutate(_mutator) {
            if (_mutator.url != this.url.toString())
                await this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            super.mutate(_mutator);
            // TODO: examine necessity to reconstruct, if mutator is kept by caller
            // _mutator.url = this.url; 
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureBase64 extends Texture {
        constructor(_name, _base64, _mipmap = MIPMAP.CRISP) {
            super(_name);
            this.image = new Image();
            this.image.src = _base64;
            this.mipmap = _mipmap;
        }
        get texImageSource() {
            return this.image;
        }
    }
    FudgeCore.TextureBase64 = TextureBase64;
    class TextureCanvas extends Texture {
        constructor(_name, _crc2) {
            super(_name);
            this.crc2 = _crc2;
        }
        get texImageSource() {
            return this.crc2.canvas;
        }
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class TextureDefault extends FudgeCore.TextureBase64 {
        static get() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADWLSURBVHhe7d0HnFTlvf/xH9uXZYGl9yrSRJpEUexYsJIba8Re498WNcZEb+41epOIsWs0Niyxm2g0duwaewO7oqJCAGnSt7H/8304B4dldpk5Z3b3zO7nzeu85pwzM8vMs7PPb35PO61qPBZjrVq18vfiKebFR/lFRPlFQ/lFE/fyy/FvAQBICwEEABAKAQQAEAp9IBHRhhoN5RcN5RdNSyg//YzCwkJr3bq1O169erXbMoEAEhF/wNFQftFQftE09/LLzc21Ll262E9+8hMbP368VVdX2+uvv27Tp093QSTq+yeARMQfcDSUXzSUXzTNtfxycnKspKTEBg0aZEceeaQdeuihtmLFCvvss89s3rx59vjjj9vDDz8cOROJHECqqqps9uzZtmzZMlu5cqVLldq1a2d9+/Z1+1HxAYyG8ouG8ouG8osmTPnl5+db9+7dbffdd7dTTz3V1cXvvvuuvfzyyy4DkVWrVtmNN95oS5YsccdhhQ4g5eXl9uyzz9qMGTNszZo1/tkfKQIq+u29995WWlrqn00fH8BoKL9oKL9oKL9o0ik/PbZNmza2xRZb2HHHHWeTJ0+2hQsX2pNPPmmLFy/2H7XOf/7zH7v11ltdPR5FqACyYMECu+eee1KKXmvXrrX99tvPRo8e7YJKuvgARkP5RROUnz67+iKUl5dnlZWVtnz58li8dj5/0TSn8lOT1b777msXXHCBde7c2V577TV78803k77Hb7/91u644w6rqKjwz4STdgBRtqHUJ4hoChCffPKJffXVV649rX379jZgwAC3BZQuTZo0ybbbbjuXXqWDD2A0lF80Qfl17NjRjjnmGOvUqZN988039sADD7gvUk39+vn8RdOcyq9r1642depU23rrre3RRx91X3JEdbSasIqLi23YsGHuXKYCSNopgXrvg+Ch/o/77rvPvVi9+J///Od29NFH29ChQ90LDGj4mNIlBZm4/8LQssycOdM1xb766qtJm2JF2UfPnj3t17/+tU2YMMF23XVXO/bYY11QQfM1f/58u+mmm1zfgfp44071sV6zPstB8FA9rC/8Tz31lOsXybS0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";
        }
    }
    TextureDefault.texture = new TextureDefault("TextureDefault", TextureDefault.get(), FudgeCore.MIPMAP.MEDIUM);
    FudgeCore.TextureDefault = TextureDefault;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles with the given framerate in {@link Time.game} */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of {@link Time.game} */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a Fudge application. Initializes automatically and must be started explicitly.
     * It then fires {@link EVENT.LOOP_FRAME} to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Loop extends FudgeCore.EventTargetStatic {
        /** The gametime the loop was started, overwritten at each start */
        static get timeStartGame() { return Loop.∆íTimeStartGame; }
        /** The realtime the loop was started, overwritten at each start */
        static get timeStartReal() { return Loop.∆íTimeStartReal; }
        /** The gametime elapsed since the last loop cycle */
        static get timeFrameGame() { return Loop.∆íTimeFrameGame; }
        /** The realtime elapsed since the last loop cycle */
        static get timeFrameReal() { return Loop.∆íTimeFrameReal; }
        /** The gametime the last loop cycle started*/
        static get timeFrameStartGame() { return Loop.∆íTimeFrameStartGame; }
        /** The realtime the last loop cycle started*/
        static get timeFrameStartReal() { return Loop.∆íTimeFrameStartReal; }
        /** The average number of frames per second in gametime */
        static get fpsGameAverage() { return 1000 / Loop.∆íTimeLastFrameGameAvg; }
        /** The average number of frames per second in realtime */
        static get fpsRealAverage() { return 1000 / Loop.∆íTimeLastFrameRealAvg; }
        /** The number of frames triggered so far */
        static get frames() { return Loop.∆íFrames; }
        /**
         * Starts the loop with the given mode and fps.
         * The default for _mode is FRAME_REQUEST, see {@link LOOP_MODE}, hooking the loop to the browser's animation frame.
         * Is only applicable in TIME-modes.
         * _syncWithAnimationFrame is experimental and only applicable in TIME-modes, deferring the loop-cycle until the next possible animation frame.
         */
        static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
            Loop.stop();
            Loop.∆íTimeStartGame = FudgeCore.Time.game.get();
            Loop.∆íTimeStartReal = performance.now();
            Loop.∆íTimeFrameStartGame = Loop.∆íTimeStartGame;
            Loop.∆íTimeFrameStartReal = Loop.∆íTimeStartReal;
            Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
            Loop.framesToAverage = Loop.fpsDesired;
            Loop.∆íTimeLastFrameGameAvg = Loop.∆íTimeLastFrameRealAvg = 1000 / Loop.fpsDesired;
            Loop.mode = _mode;
            Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
            let log = `Loop starting in mode ${Loop.mode}`;
            if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                log += ` with attempted ${_fps} fps`;
            FudgeCore.Debug.fudge(log);
            switch (_mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    Loop.loopFrame();
                    break;
                case LOOP_MODE.TIME_REAL:
                    Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                    Loop.loopTime();
                    break;
                case LOOP_MODE.TIME_GAME:
                    Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                    Loop.loopTime();
                    break;
                default:
                    break;
            }
            Loop.running = true;
        }
        /**
         * Stops the loop
         */
        static stop() {
            if (!Loop.running)
                return;
            switch (Loop.mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_REAL:
                    window.clearInterval(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_GAME:
                    FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                default:
                    break;
            }
            Loop.running = false;
            FudgeCore.Debug.fudge("Loop stopped!");
        }
        static continue() {
            if (Loop.running)
                return;
            Loop.start(Loop.mode, Loop.fpsDesired, Loop.syncWithAnimationFrame);
        }
        static loop() {
            let time;
            time = performance.now();
            Loop.∆íTimeFrameReal = time - Loop.∆íTimeFrameStartReal;
            Loop.∆íTimeFrameStartReal = time;
            time = FudgeCore.Time.game.get();
            Loop.∆íTimeFrameGame = time - Loop.∆íTimeFrameStartGame;
            Loop.∆íTimeFrameStartGame = time;
            Loop.∆íTimeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameGameAvg + Loop.∆íTimeFrameGame) / Loop.framesToAverage;
            Loop.∆íTimeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameRealAvg + Loop.∆íTimeFrameReal) / Loop.framesToAverage;
            // TODO: consider LoopEvent which conveys information such as timeElapsed etc...
            Loop.∆íFrames++;
            let event = new Event("loopFrame" /* LOOP_FRAME */);
            Loop.targetStatic.dispatchEvent(event);
        }
        static loopFrame() {
            Loop.loop();
            Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
        }
        static loopTime() {
            if (Loop.syncWithAnimationFrame)
                Loop.idRequest = window.requestAnimationFrame(Loop.loop);
            else
                Loop.loop();
        }
    }
    Loop.∆íTimeStartGame = 0;
    Loop.∆íTimeStartReal = 0;
    Loop.∆íTimeFrameGame = 0;
    Loop.∆íTimeFrameReal = 0;
    Loop.∆íTimeFrameStartGame = 0;
    Loop.∆íTimeFrameStartReal = 0;
    Loop.∆íTimeLastFrameGameAvg = 0;
    Loop.∆íTimeLastFrameRealAvg = 0;
    Loop.∆íFrames = 0;
    Loop.running = false;
    Loop.mode = LOOP_MODE.FRAME_REQUEST;
    Loop.idIntervall = 0;
    Loop.idRequest = 0;
    Loop.fpsDesired = 30;
    Loop.framesToAverage = 30;
    Loop.syncWithAnimationFrame = false;
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports {@link Timer}s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Time extends FudgeCore.EventTarget∆í {
        constructor() {
            super();
            this.timers = {};
            this.idTimerAddedLast = 0;
            this.start = performance.now();
            this.scale = 1.0;
            this.offset = 0.0;
            this.lastCallToElapsed = 0.0;
        }
        /**
         * Returns the game-time-object which starts automatically and serves as base for various internal operations.
         */
        // public static get game(): Time {
        //   return Time.gameTime;
        // }
        static getUnits(_milliseconds) {
            let units = {};
            units.asSeconds = _milliseconds / 1000;
            units.asMinutes = units.asSeconds / 60;
            units.asHours = units.asMinutes / 60;
            units.hours = Math.floor(units.asHours);
            units.minutes = Math.floor(units.asMinutes) % 60;
            units.seconds = Math.floor(units.asSeconds) % 60;
            units.fraction = _milliseconds % 1000;
            units.thousands = _milliseconds % 10;
            units.hundreds = _milliseconds % 100 - units.thousands;
            units.tenths = units.fraction - units.hundreds - units.thousands;
            return units;
        }
        //#region Get/Set time and scaling
        /**
         * Retrieves the current scaled timestamp of this instance in milliseconds
         */
        get() {
            return this.offset + this.scale * (performance.now() - this.start);
        }
        /**
         * Returns the remaining time to the given point of time
         */
        getRemainder(_to) {
            return _to - this.get();
        }
        /**
         * (Re-) Sets the timestamp of this instance
         * @param _time The timestamp to represent the current time (default 0.0)
         */
        set(_time = 0) {
            this.offset = _time;
            this.start = performance.now();
            this.getElapsedSincePreviousCall();
        }
        /**
         * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
         * @param _scale The desired scaling (default 1.0)
         */
        setScale(_scale = 1.0) {
            this.set(this.get());
            this.scale = _scale;
            //TODO: catch scale=0
            this.rescaleAllTimers();
            this.getElapsedSincePreviousCall();
            this.dispatchEvent(new Event("timeScaled" /* TIME_SCALED */));
        }
        /**
         * Retrieves the current scaling of this time
         */
        getScale() {
            return this.scale;
        }
        /**
         * Retrieves the offset of this time
         */
        getOffset() {
            return this.offset;
        }
        /**
         * Retrieves the scaled time in milliseconds passed since the last call to this method
         * Automatically reset at every call to set(...) and setScale(...)
         */
        getElapsedSincePreviousCall() {
            let current = this.get();
            let elapsed = current - this.lastCallToElapsed;
            this.lastCallToElapsed = current;
            return elapsed;
        }
        //#endregion
        //#region Timers
        /**
         * Returns a Promise<void> to be resolved after the time given. To be used with async/await
         */
        delay(_lapse) {
            return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
        }
        // TODO: examine if web-workers would enhance performance here!
        /**
         * Stops and deletes all {@link Timer}s attached. Should be called before this Time-object leaves scope
         */
        clearAllTimers() {
            for (let id in this.timers) {
                this.deleteTimer(Number(id));
            }
        }
        /**
         * Deletes {@link Timer} found using the internal id of the connected interval-object
         * @param _id
         */
        deleteTimerByItsInternalId(_id) {
            for (let id in this.timers) {
                let timer = this.timers[id];
                if (timer.id == _id) {
                    timer.clear();
                    delete this.timers[id];
                    // TODO: check if an early out is OK here... should be!
                }
            }
        }
        /**
         * Installs a timer at this time object
         * @param _lapse The object-time to elapse between the calls to _callback
         * @param _count The number of calls desired, 0 = Infinite
         * @param _handler The function to call each the given lapse has elapsed
         * @param _arguments Additional parameters to pass to callback function
         */
        setTimer(_lapse, _count, _handler, ..._arguments) {
            // tslint:disable-next-line: no-unused-expression
            new FudgeCore.Timer(this, _lapse, _count, _handler, _arguments);
            //this.addTimer(timer);
            return this.idTimerAddedLast;
        }
        /**
         * This method is called internally by {@link Time} and {@link Timer} and must not be called otherwise
         */
        addTimer(_timer) {
            this.timers[++this.idTimerAddedLast] = _timer;
            return this.idTimerAddedLast;
        }
        /**
         * Deletes the timer with the id given by this time object
         */
        deleteTimer(_id) {
            let timer = this.timers[_id];
            if (!timer)
                return;
            timer.clear();
            delete this.timers[_id];
        }
        /**
         * Returns a reference to the timer with the given id or null if not found.
         */
        getTimer(_id) {
            return this.timers[_id];
        }
        /**
         * Returns a copy of the list of timers currently installed on this time object
         */
        getTimers() {
            let result = {};
            return Object.assign(result, this.timers);
        }
        /**
         * Returns true if there are {@link Timers} installed to this
         */
        hasTimers() {
            return (Object.keys(this.timers).length > 0);
        }
        /**
         * Recreates {@link Timer}s when scaling changes
         */
        rescaleAllTimers() {
            for (let id in this.timers) {
                let timer = this.timers[id];
                timer.clear();
                delete this.timers[id];
                if (!this.scale)
                    // Time has stopped, no need to replace cleared timers
                    continue;
                /* this.timers[id] =  */
                timer = timer.installCopy(); // the timer is automatically added to this time instance
                delete this.timers[this.idTimerAddedLast]; // remove the copy again ...
                this.timers[id] = timer; // ... and place it at the id of the original
            }
        }
    }
    /** Standard game time starting automatically with the application */
    Time.game = new Time();
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Timer}-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an {@link EventTimer}-instance with additional information and given arguments.
     * The frequency scales with the {@link Time}-instance the {@link Timer}-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a {@link Timer} instance.
         * @param _time The {@link Time} instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The {@link TimerHandler} instance to call
         * @param _arguments Additional arguments to pass to _handler
         *
         * TODO: for proper handling and deletion, use Time.setTimer instead of instantiating timers yourself.
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, _arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                if (!this.active)
                    return;
                this.event.count = this.count;
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, _arguments);
            this.active = true;
            _time.addTimer(this);
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same {@link Time}-instance. Used internally when rescaling {@link Time}
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0RlYnVnL0RlYnVnVGFyZ2V0LnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnSW50ZXJmYWNlcy50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0NvbnNvbGUudHMiLCIuLi9Tb3VyY2UvRGVidWcvRGVidWcudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnQudHMiLCIuLi9Tb3VyY2UvU2VyaWFsaXphdGlvbi9NdXRhYmxlLnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vU2VyaWFsaXplci50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50LnRzIiwiLi4vU291cmNlL1JlY3ljbGUvUmVjeWNhYmxlQXJyYXkudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlckluamVjdG9yLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3RvclNoYWRlci50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JDb2F0LnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3Rvck1lc2gudHMiLCIuLi9Tb3VyY2UvUmVjeWNsZS9SZWN5Y2xlci50cyIsIi4uL1NvdXJjZS9NYXRoL1ZlY3RvcjIudHMiLCIuLi9Tb3VyY2UvTWF0aC9SZWN0YW5nbGUudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1JlbmRlcldlYkdMLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJJbmplY3RvclRleHR1cmUudHMiLCIuLi9Tb3VyY2UvR3JhcGgvTm9kZS50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0hlbHBlcnNQaHlzaWNzLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnQudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludEF4aWFsLnRzIiwiLi4vU291cmNlL1JlZmVyZW5jZXMudHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbi50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uRnVuY3Rpb24udHMiLCIuLi9Tb3VyY2UvQW5pbWF0aW9uL0FuaW1hdGlvbktleS50cyIsIi4uL1NvdXJjZS9BbmltYXRpb24vQW5pbWF0aW9uU2VxdWVuY2UudHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW8udHMiLCIuLi9Tb3VyY2UvQXVkaW8vQXVkaW9NYW5hZ2VyLnRzIiwiLi4vU291cmNlL0F1ZGlvL0F1ZGlvT3NjaWxsYXRvci50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50QW5pbWF0b3IudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudEF1ZGlvLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpb0xpc3RlbmVyLnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRDYW1lcmEudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudEdyYXBoRmlsdGVyLnRzIiwiLi4vU291cmNlL0xpZ2h0L0xpZ2h0LnRzIiwiLi4vU291cmNlL0NvbXBvbmVudC9Db21wb25lbnRMaWdodC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50TWF0ZXJpYWwudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudE1lc2gudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudFBpY2sudHMiLCIuLi9Tb3VyY2UvQ29tcG9uZW50L0NvbXBvbmVudFNjcmlwdC50cyIsIi4uL1NvdXJjZS9Db21wb25lbnQvQ29tcG9uZW50VHJhbnNmb3JtLnRzIiwiLi4vU291cmNlL0NvbnRyb2wvQ29udHJvbC50cyIsIi4uL1NvdXJjZS9Db250cm9sL0F4aXMudHMiLCIuLi9Tb3VyY2UvQ29udHJvbC9LZXlib2FyZC50cyIsIi4uL1NvdXJjZS9EZWJ1Zy9EZWJ1Z0FsZXJ0LnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnRGlhbG9nLnRzIiwiLi4vU291cmNlL0RlYnVnL0RlYnVnVGV4dEFyZWEudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRBdWRpby50cyIsIi4uL1NvdXJjZS9FdmVudC9FdmVudERyYWdEcm9wLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50S2V5Ym9hcmQudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRQb2ludGVyLnRzIiwiLi4vU291cmNlL0V2ZW50L0V2ZW50VGltZXIudHMiLCIuLi9Tb3VyY2UvRXZlbnQvRXZlbnRXaGVlbC50cyIsIi4uL1NvdXJjZS9HcmFwaC9HcmFwaC50cyIsIi4uL1NvdXJjZS9HcmFwaC9HcmFwaEluc3RhbmNlLnRzIiwiLi4vU291cmNlL01hdGVyaWFsL0NvYXQudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvQ29hdENvbG9yZWQudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvQ29hdFJlbWlzc2l2ZS50cyIsIi4uL1NvdXJjZS9NYXRlcmlhbC9Db2F0VGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvTWF0ZXJpYWwvQ29hdFJlbWlzc2l2ZVRleHR1cmVkLnRzIiwiLi4vU291cmNlL01hdGVyaWFsL0NvbG9yLnRzIiwiLi4vU291cmNlL01hdGVyaWFsL01hdGVyaWFsLnRzIiwiLi4vU291cmNlL01hdGgvRnJhbWluZy50cyIsIi4uL1NvdXJjZS9NYXRoL0dlbzIudHMiLCIuLi9Tb3VyY2UvTWF0aC9HZW8zLnRzIiwiLi4vU291cmNlL01hdGgvTEZJQjQudHMiLCIuLi9Tb3VyY2UvTWF0aC9NYXRyaXgzeDMudHMiLCIuLi9Tb3VyY2UvTWF0aC9NYXRyaXg0eDQudHMiLCIuLi9Tb3VyY2UvTWF0aC9Ob2lzZS50cyIsIi4uL1NvdXJjZS9NYXRoL05vaXNlMi50cyIsIi4uL1NvdXJjZS9NYXRoL05vaXNlMy50cyIsIi4uL1NvdXJjZS9NYXRoL05vaXNlNC50cyIsIi4uL1NvdXJjZS9NYXRoL1JhbmRvbS50cyIsIi4uL1NvdXJjZS9NYXRoL1ZlY3RvcjMudHMiLCIuLi9Tb3VyY2UvTWVzaC9GYWNlLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hDdWJlLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFBvbHlnb24udHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoRXh0cnVzaW9uLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaEZyb21EYXRhLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaEdMVEYudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoT2JqLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFB5cmFtaWQudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoUXVhZC50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hUZXJyYWluLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFJlbGllZi50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hSb3RhdGlvbi50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JNZXNoU2tpbi50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hTa2luLnRzIiwiLi4vU291cmNlL01lc2gvTWVzaFNwaGVyZS50cyIsIi4uL1NvdXJjZS9NZXNoL01lc2hTcHJpdGUudHMiLCIuLi9Tb3VyY2UvTWVzaC9NZXNoVG9ydXMudHMiLCIuLi9Tb3VyY2UvTWVzaC9RdWFkLnRzIiwiLi4vU291cmNlL01lc2gvVmVydGV4LnRzIiwiLi4vU291cmNlL01lc2gvVmVydGljZXMudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Db21wb25lbnRSaWdpZGJvZHkudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9EZWJ1Z1BoeXNpY3NEcmF3LnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnRDeWxpbmRyaWNhbC50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0pvaW50UHJpc21hdGljLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnRSYWdkb2xsLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnRSZXZvbHV0ZS50cyIsIi4uL1NvdXJjZS9QaHlzaWNzL0pvaW50U3BoZXJpY2FsLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvSm9pbnRVbml2ZXJzYWwudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9Kb2ludFdlbGRpbmcudHMiLCIuLi9Tb3VyY2UvUGh5c2ljcy9QaHlzaWNzLnRzIiwiLi4vU291cmNlL1BoeXNpY3MvUXVhdGVybmlvbi50cyIsIi4uL1NvdXJjZS9SYXkvQm94LnRzIiwiLi4vU291cmNlL1JheS9QaWNrLnRzIiwiLi4vU291cmNlL1JheS9QaWNrZXIudHMiLCIuLi9Tb3VyY2UvUmF5L1JheS50cyIsIi4uL1NvdXJjZS9SZW5kZXIvUmVuZGVyLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJNZXNoLnRzIiwiLi4vU291cmNlL1JlbmRlci9SZW5kZXJQYXJ0aWNsZXMudHMiLCIuLi9Tb3VyY2UvUmVuZGVyL1ZpZXdwb3J0LnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vRmlsZUlvQnJvd3NlckxvY2FsLnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vTXV0YWJsZUFycmF5LnRzIiwiLi4vU291cmNlL1NlcmlhbGl6YXRpb24vUHJvamVjdC50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL0dMVEYvR0xURi50cyIsIi4uL1NvdXJjZS9TZXJpYWxpemF0aW9uL0dMVEYvR0xURkxvYWRlci50cyIsIi4uL1NvdXJjZS9TaGFkZXIvU2hhZGVyLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJGbGF0LnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJGbGF0U2tpbi50cyIsIi4uL1NvdXJjZS9TaGFkZXIvQnVpbGQvU2hhZGVyRmxhdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJHb3VyYXVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJHb3VyYXVkU2tpbi50cyIsIi4uL1NvdXJjZS9TaGFkZXIvQnVpbGQvU2hhZGVyR291cmF1ZFRleHR1cmVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJMaXQudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL0J1aWxkL1NoYWRlckxpdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJNYXRDYXAudHMiLCIuLi9Tb3VyY2UvU2hhZGVyL0J1aWxkL1NoYWRlclBob25nLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJQaWNrLnRzIiwiLi4vU291cmNlL1NoYWRlci9CdWlsZC9TaGFkZXJQaWNrVGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvU2tlbGV0b24vQm9uZUxpc3QudHMiLCIuLi9Tb3VyY2UvU2tlbGV0b24vQm9uZU1hdHJpeExpc3QudHMiLCIuLi9Tb3VyY2UvU2tlbGV0b24vU2tlbGV0b24udHMiLCIuLi9Tb3VyY2UvU2tlbGV0b24vU2tlbGV0b25JbnN0YW5jZS50cyIsIi4uL1NvdXJjZS9UZXh0dXJlL1RleHR1cmUudHMiLCIuLi9Tb3VyY2UvVGV4dHVyZS9UZXh0dXJlRGVmYXVsdC50cyIsIi4uL1NvdXJjZS9UaW1lL0xvb3AudHMiLCIuLi9Tb3VyY2UvVGltZS9UaW1lLnRzIiwiLi4vU291cmNlL1RpbWUvVGltZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQVUsU0FBUyxDQWdCbEI7QUFoQkQsV0FBVSxTQUFTO0lBQ2pCOztPQUVHO0lBQ0gsTUFBc0IsV0FBVztRQUV4QixNQUFNLENBQUMsY0FBYyxDQUFDLFFBQWdCLEVBQUUsR0FBRyxLQUFlO1lBQy9ELElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLDJCQUEyQjtZQUNsRSxLQUFLLElBQUksR0FBRyxJQUFJLEtBQUs7Z0JBQ25CLElBQUksR0FBRyxZQUFZLE1BQU07b0JBQ3ZCLEdBQUcsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLCtCQUErQjs7b0JBRTVFLEdBQUcsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsK0JBQStCO1lBQ2pFLE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQztL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LENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUNoQjtnQkFDRSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdB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Q0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLEdBQUcsR0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUU5QixJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNyRCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFFekMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQztnQkFDckQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQ3pDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ3RELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztZQUMxQyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDO2dCQUN0RCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFFMUMsSUFBSSxDQUFDLEdBQVcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBRWxFLE1BQU0sU0FBUyxHQUFjLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNyRCxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDakIsQ0FBQyxHQUFHLEVBQUU7Z0JBQ04sQ0FBQyxHQUFHLEVBQUU7Z0JBQ04sQ0FBQyxHQUFHLEVBQUU7Z0JBQ04sQ0FBQyxHQUFHLEVBQUU7Z0JBQ04sQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDckYsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDckYsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDdkYsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDdkYsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FB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QUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBRTlCLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ3JELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztZQUV6QyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNyRCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDekMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDdEQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzFDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ3RELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztZQUUxQyxJQUFJLENBQUMsR0FBVyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFFbEUseUNBQXlDO1lBQ3pDLE1BQU0sTUFBTSxHQUFjLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNsRCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsRUFBRTtnQkFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNyRixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FB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LEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUVyRyx5REFBeUQ7Z0JBQ3pELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzdELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzdELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENB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TSxFQUFFLEdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RDLGtEQUFrRDtnQkFDbEQsTUFBTSxFQUFFLEdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RDLE1BQU0sRUFBRSxHQUFXLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxNQUFNLEVBQUUsR0FBVyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEMsTUFBTSxFQUFFLEdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RDLG1EQUFtRDtnQkFDbkQsTUFBTSxFQUFFLEdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RDLE1BQU0sRUFBRSxHQUFXLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxNQUFNLEVBQUUsR0FBVyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEMsTUFBTSxFQUFFLEdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRXRDLCtFQUErRTtnQkFDL0UsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsZ0RBQWdEO2dCQUM1RixNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQzNDLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztnQkFDM0MsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUMzQyxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsK0NBQStDO2dCQUNqRyxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNqRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNqRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNqRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsZ0RBQWdEO2dCQUNsRyxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNqRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNqRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNqRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsOENBQThDO2dCQUNqRyxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUNsRCxNQUFNLEVB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QUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDMUUsTUFBTSxFQUFFLEdBQVcsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQy9ELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxDQUFDO29CQUN2QixDQUFDLENBQUMsR0FBRztvQkFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzFFLE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUMvRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsQ0FBQztvQkFDdkIsQ0FBQyxDQUFDLEdBQUc7b0JBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxNQUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDMUUsTUFBTSxFQUFFLEdBQVcsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQy9ELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxDQUFDO29CQUN2QixDQUFDLENBQUMsR0FBRztvQkFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBRTFFLHdEQUF3RDtnQkFDeEQsT0FBTyxpQkFBaUIsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUN0RCxDQUFDLENBQUM7UUFDSixDQUFDO1FBdklELE9BQU8sQ0FBb0U7O0lBRjVELGFBQU0sR0FBVyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQy9DLGVBQVEsR0FBZSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFD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LEdBQUcsSUFBSSxVQUFBLFFBQVE7WUFDMUIsUUFBUTtZQUNSLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ2hFLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUk7WUFDakUsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUk7WUFDaEUsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQy9ELE9BQU87WUFDUCxJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ2pFLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUNsRSxJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ2pFLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ2hFLGFBQWE7WUFDYixJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUk7WUFDdEMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ3RDLElBQUksVUFBQSxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSztZQUN2QyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUs7WUFDdkMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLO1lBQ3ZDLElBQUksVUFBQSxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSztZQUN2QyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFD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QUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2xELEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDbEQsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsSUFBSSxDQUNqQixJQUFJLENBQUMsUUFBUSxFQUNiLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQzNDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQzNDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQzNDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQzNDLEtBQUssQ0FDTixDQUFDLENBQUM7b0JBQ0gsS0FBSyxHQUFHLENBQUMsS0FBSyxJQUFJLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQztpQkFDckU7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FB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QUssQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFdEQsQ0FBQyxDQUFDO1lBRUYsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQzNFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1lBQ25CLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBVyxFQUFFO1lBQ1gsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3ZCLENBQUM7UUFFRDs7V0FFRztRQUNILElBQVcsS0FBSztZQUNkLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxXQUFXO1lBQ2hCLE9BQU8sSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNGLENBQUM7UUFFRDs7V0FFRztRQUNJLEtBQUs7WUFDVix5Q0FBeUM7WUFDekMsdUJBQXVCO1lBQ3ZCLHVFQUF1RTtZQUN2RSwyR0FBMkc7WUFDM0csb0NBQW9DO1lBQ3BDLElBQUk7WUFDSixPQUFPO1lBQ1Asa0hBQWtIO1lBQ2xILE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3BDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLENBQUM7S0FDRjtJQTdGWSxlQUFLLFFBNkZqQixDQUFBO0FBQ0gsQ0FBQyxFQTNHUyxTQUFTLEtBQVQsU0FBUyxRQTJHbEIiLCJzb3VyY2VzQ29udGVudCI6WyJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciB0aGUgZGlmZmVyZW50IERlYnVnVGFyZ2V0cywgbWFpbmx5IGZvciB0ZWNobmljYWwgcHVycG9zZSBvZiBpbmhlcml0YW5jZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICBwdWJsaWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGU7XHJcbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlQXJndW1lbnRzKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBvdXQ6IHN0cmluZyA9IF9tZXNzYWdlLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoX21lc3NhZ2UpO1xyXG4gICAgICBmb3IgKGxldCBhcmcgb2YgX2FyZ3MpXHJcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIE51bWJlcilcclxuICAgICAgICAgIG91dCArPSBcIiwgXCIgKyBhcmcudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIG91dCArPSBcIiwgXCIgKyBhcmcudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShhcmcsIG51bGwsIDIpO1xyXG4gICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQWxlcnQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBmaWx0ZXJzIGNvcnJlc3BvbmRpbmcgdG8gZGVidWcgYWN0aXZpdGllcywgbW9yZSB0byBjb21lXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gREVCVUdfRklMVEVSIHtcclxuICAgIE5PTkUgPSAweDAwLFxyXG4gICAgSU5GTyA9IDB4MDEsXHJcbiAgICBMT0cgPSAweDAyLFxyXG4gICAgV0FSTiA9IDB4MDQsXHJcbiAgICBFUlJPUiA9IDB4MDgsXHJcbiAgICBGVURHRSA9IDB4MTAsXHJcbiAgICBDTEVBUiA9IDB4MTAwLFxyXG4gICAgR1JPVVAgPSAweDEwMSxcclxuICAgIEdST1VQQ09MTEFQU0VEID0gMHgxMDIsXHJcbiAgICBHUk9VUEVORCA9IDB4MTA0LFxyXG4gICAgU09VUkNFID0gMHgyMDAsXHJcbiAgICBNRVNTQUdFUyA9IElORk8gfCBMT0cgfCBXQVJOIHwgRVJST1IgfCBGVURHRSxcclxuICAgIEZPUk1BVCA9IENMRUFSIHwgR1JPVVAgfCBHUk9VUENPTExBUFNFRCB8IEdST1VQRU5ELFxyXG4gICAgQUxMID0gTUVTU0FHRVMgfCBGT1JNQVRcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjb25zdCBERUJVR19TWU1CT0w6IHsgW2ZpbHRlcjogbnVtYmVyXTogc3RyaW5nOyB9ID0ge1xyXG4gICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogXCLinJNcIixcclxuICAgIFtERUJVR19GSUxURVIuTE9HXTogXCLinI5cIixcclxuICAgIFtERUJVR19GSUxURVIuV0FSTl06IFwi4pqgXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogXCLinYxcIixcclxuICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBcIvCfjrJcIixcclxuICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogXCLwn5SXXCJcclxuICB9O1xyXG5cclxuICBleHBvcnQgdHlwZSBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBNYXA8RGVidWdUYXJnZXQsIEZ1bmN0aW9uPjtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSB7IFtmaWx0ZXI6IG51bWJlcl06IEZ1bmN0aW9uOyB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0aW5nIHRvIHRoZSBzdGFuZGFyZC1jb25zb2xlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnQ29uc29sZSBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IGNvbnNvbGUuaW5mbyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBjb25zb2xlLmxvZyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogY29uc29sZS53YXJuLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogY29uc29sZS5lcnJvcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQ29uc29sZS5mdWRnZSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5DTEVBUl06IGNvbnNvbGUuY2xlYXIsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBdOiBjb25zb2xlLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VEXTogY29uc29sZS5ncm91cENvbGxhcHNlZCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUEVORF06IGNvbnNvbGUuZ3JvdXBFbmQsXHJcbiAgICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogRGVidWdDb25zb2xlLnNvdXJjZVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3VsZCBiZSB1c2VkIHRvIGRpc3BsYXkgdW5jcml0aWNhbCBzdGF0ZSBpbmZvcm1hdGlvbiBvZiBGVURHRSwgb25seSB2aXNpYmxlIGluIGJyb3dzZXIncyB2ZXJib3NlIG1vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmdWRnZShfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgY29uc29sZS5kZWJ1ZyhERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkZVREdFXSwgX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGFuIGV4dHJhIGxpbmUgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc291cmNlIG9mIHRoZSBkZWJ1ZyBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc291cmNlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBjb25zb2xlLmxvZyhERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLlNPVVJDRV0sIF9tZXNzYWdlLCAuLi5fYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnSW50ZXJmYWNlcy50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQ29uc29sZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIERlYnVnLUNsYXNzIG9mZmVycyBmdW5jdGlvbnMga25vd24gZnJvbSB0aGUgY29uc29sZS1vYmplY3QgYW5kIGFkZGl0aW9ucywgXHJcbiAgICogcm91dGluZyB0aGUgaW5mb3JtYXRpb24gdG8gdmFyaW91cyB7QGxpbmsgRGVidWdUYXJnZXR9cyB0aGF0IGNhbiBiZSBlYXNpbHkgZGVmaW5lZCBieSB0aGUgZGV2ZWxvcGVycyBhbmQgcmVnaXN0ZXJkIGJ5IHVzZXJzXHJcbiAgICogT3ZlcnJpZGUgZnVuY3Rpb25zIGluIHN1YmNsYXNzZXMgb2Yge0BsaW5rIERlYnVnVGFyZ2V0fSBhbmQgcmVnaXN0ZXIgdGhlbSBhcyB0aGVpciBkZWxlZ2F0ZXNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBzZXQgZmlsdGVyLCB0aGlzIGFzc29jaWF0aXZlIGFycmF5IGtlZXBzIHJlZmVyZW5jZXMgdG8gdGhlIHJlZ2lzdGVyZWQgZGVsZWdhdGUgZnVuY3Rpb25zIG9mIHRoZSBjaG9zZW4ge0BsaW5rIERlYnVnVGFyZ2V0fXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGVzOiB7IFtmaWx0ZXI6IG51bWJlcl06IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSB9ID0gRGVidWcuc2V0dXBDb25zb2xlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZSBhIGZpbHRlciBmb3IgdGhlIGdpdmVuIERlYnVnVGFyZ2V0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRGaWx0ZXIoX3RhcmdldDogRGVidWdUYXJnZXQsIF9maWx0ZXI6IERFQlVHX0ZJTFRFUik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gRGVidWcuZGVsZWdhdGVzKVxyXG4gICAgICAgIERlYnVnLmRlbGVnYXRlc1tmaWx0ZXJdLmRlbGV0ZShfdGFyZ2V0KTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBERUJVR19GSUxURVIpIHtcclxuICAgICAgICBsZXQgcGFyc2VkOiBudW1iZXIgPSBwYXJzZUludChmaWx0ZXIpO1xyXG4gICAgICAgIGlmIChpc05hTihwYXJzZWQpKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKFtERUJVR19GSUxURVIuTUVTU0FHRVMsIERFQlVHX0ZJTFRFUi5GT1JNQVQsIERFQlVHX0ZJTFRFUi5BTExdLmluZGV4T2YocGFyc2VkKSAhPSAtMSlcclxuICAgICAgICAgIC8vIGRvbnQgZGVsZWdhdGUgY29tYm9zLi4uIFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKF9maWx0ZXIgJiBwYXJzZWQpXHJcbiAgICAgICAgICBEZWJ1Zy5kZWxlZ2F0ZXNbcGFyc2VkXS5zZXQoX3RhcmdldCwgX3RhcmdldC5kZWxlZ2F0ZXNbcGFyc2VkXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm8oLi4uKSBkaXNwbGF5cyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdpdGggbG93IHByaW9yaXR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5mbyhfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuSU5GTywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gd2l0aCBtZWRpdW0gcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsb2coX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkxPRywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gYWJvdXQgbm9uLWNvbmZvcm1pdGllcyBpbiB1c2FnZSwgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgd2FybihfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuV0FSTiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgZmFpbHVyZXMsIHdoaWNoIGlzIGVtcGhhc2l6ZWQgZS5nLiBieSBjb2xvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGVycm9yKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5FUlJPUiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgbWVzc2FnZXMgZnJvbSBGVURHRVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZ1ZGdlKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5GVURHRSwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBvdXRwdXQgYW5kIHJlbW92ZXMgcHJldmlvdXMgbWVzc2FnZXMgaWYgcG9zc2libGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkNMRUFSLCBudWxsLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXAoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVAsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzIHRoYXQgaXMgY29sbGFwc2VkIGF0IGZpcnN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBDb2xsYXBzZWQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRUQsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSB5b3VuZ2VzdCBncm91cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwRW5kKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBFTkQsIG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgYSBicmFuY2ggb2YgdGhlIG5vZGUgaGllcmFyY2h5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYnJhbmNoKF9icmFuY2g6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKF9icmFuY2gubkNoaWxkcmVuID4gMClcclxuICAgICAgICBEZWJ1Zy5ncm91cChfYnJhbmNoLm5hbWUpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgRGVidWcuZnVkZ2UoX2JyYW5jaC5uYW1lKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9icmFuY2guZ2V0Q2hpbGRyZW4oKSkgRGVidWcuYnJhbmNoKGNoaWxkKTtcclxuXHJcbiAgICAgIGlmIChfYnJhbmNoLm5DaGlsZHJlbiA+IDApXHJcbiAgICAgICAgRGVidWcuZ3JvdXBFbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIG1lc3NhZ2VzIGFib3V0IHRoZSBzb3VyY2Ugb2YgdGhlIGRlYnVnIGNhbGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzb3VyY2UoX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLlNPVVJDRSwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvb2t1cCBhbGwgZGVsZWdhdGVzIHJlZ2lzdGVyZWQgdG8gdGhlIGZpbHRlciBhbmQgY2FsbCB0aGVtIHVzaW5nIHRoZSBnaXZlbiBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGUoX2ZpbHRlcjogREVCVUdfRklMVEVSLCBfbWVzc2FnZTogdW5rbm93biwgX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBpZiAoX2ZpbHRlciA9PSBERUJVR19GSUxURVIuTE9HIHx8IF9maWx0ZXIgPT0gREVCVUdfRklMVEVSLldBUk4gfHwgX2ZpbHRlciA9PSBERUJVR19GSUxURVIuRVJST1IpIHtcclxuICAgICAgICBpZiAoRGVidWcuZGVsZWdhdGVzW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxyXG4gICAgICAgICAgZm9yIChsZXQgZGVsZWdhdGUgb2YgRGVidWcuZGVsZWdhdGVzW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdLnZhbHVlcygpKVxyXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuICAgICAgICAgICAgICBsZXQgdHJhY2U6IHN0cmluZ1tdID0gbmV3IEVycm9yKFwiVGVzdFwiKS5zdGFjay5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgICBkZWxlZ2F0ZSh0cmFjZVszXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsZXQgZGVsZWdhdGVzOiBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBEZWJ1Zy5kZWxlZ2F0ZXNbX2ZpbHRlcl07XHJcbiAgICAgIGZvciAobGV0IGRlbGVnYXRlIG9mIGRlbGVnYXRlcy52YWx1ZXMoKSlcclxuICAgICAgICBpZiAoZGVsZWdhdGUpXHJcbiAgICAgICAgICBpZiAoX2FyZ3MgJiYgX2FyZ3MubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UpO1xyXG5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0dXAgcm91dGluZyB0byBzdGFuZGFyZCBjb25zb2xlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHNldHVwQ29uc29sZSgpOiB7fSB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSB7fTtcclxuICAgICAgbGV0IGZpbHRlcnM6IERFQlVHX0ZJTFRFUltdID0gW1xyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5JTkZPLCBERUJVR19GSUxURVIuTE9HLCBERUJVR19GSUxURVIuV0FSTiwgREVCVUdfRklMVEVSLkVSUk9SLCBERUJVR19GSUxURVIuRlVER0UsXHJcbiAgICAgICAgREVCVUdfRklMVEVSLkNMRUFSLCBERUJVR19GSUxURVIuR1JPVVAsIERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgREVCVUdfRklMVEVSLkdST1VQRU5ELFxyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5TT1VSQ0VcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBvZiBmaWx0ZXJzKVxyXG4gICAgICAgIHJlc3VsdFtmaWx0ZXJdID0gbmV3IE1hcChbW0RlYnVnQ29uc29sZSwgRGVidWdDb25zb2xlLmRlbGVnYXRlc1tmaWx0ZXJdXV0pO1xyXG5cclxuICAgICAgcmVzdWx0W0RFQlVHX0ZJTFRFUi5TT1VSQ0VdLmRlbGV0ZShEZWJ1Z0NvbnNvbGUpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIge1xyXG4gICAgW2V2ZW50VHlwZTogc3RyaW5nXTogRXZlbnRMaXN0ZW5lcsaSW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUeXBlcyBvZiBldmVudHMgc3BlY2lmaWMgdG8gRnVkZ2UsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCBET00vQnJvd3Nlci1UeXBlcyBhbmQgY3VzdG9tIHN0cmluZ3NcclxuICAgKi9cclxuXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlQge1xyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gdGFyZ2V0cyByZWdpc3RlcmVkIGF0IHtAbGluayBMb29wfSwgd2hlbiByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIHN0YXJ0cyAqL1xyXG4gICAgTE9PUF9GUkFNRSA9IFwibG9vcEZyYW1lXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGFkZGVkIHRvIGEge0BsaW5rIE5vZGV9ICovXHJcbiAgICBDT01QT05FTlRfQUREID0gXCJjb21wb25lbnRBZGRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGEge0BsaW5rIE5vZGV9ICovXHJcbiAgICBDT01QT05FTlRfUkVNT1ZFID0gXCJjb21wb25lbnRSZW1vdmVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgYWN0aXZhdGVkICovXHJcbiAgICBDT01QT05FTlRfQUNUSVZBVEUgPSBcImNvbXBvbmVudEFjdGl2YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGRlYWN0aXZhdGVkICovXHJcbiAgICBDT01QT05FTlRfREVBQ1RJVkFURSA9IFwiY29tcG9uZW50RGVhY3RpdmF0ZVwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgTm9kZX0sIGl0J3Mgc3VjY2Vzc29ycyBhbmQgYW5jZXN0b3JzIHdoZW4gaXRzIGJlaW5nIGFjdGl2YXRlZCAqL1xyXG4gICAgTk9ERV9BQ1RJVkFURSA9IFwibm9kZUFjdGl2YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBOb2RlfSwgaXQncyBzdWNjZXNzb3JzIGFuZCBhbmNlc3RvcnMgd2hlbiBpdHMgYmVpbmcgZGVhY3RpdmF0ZWQgKi9cclxuICAgIE5PREVfREVBQ1RJVkFURSA9IFwibm9kZURlYWN0aXZhdGVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQge0BsaW5rIE5vZGV9IGFuZCBpdHMgYW5jZXN0b3JzIGFmdGVyIGl0IHdhcyBhcHBlbmRlZCB0byBhIHBhcmVudCAqL1xyXG4gICAgQ0hJTERfQVBQRU5EID0gXCJjaGlsZEFwcGVuZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBjaGlsZCB7QGxpbmsgTm9kZX0gYW5kIGl0cyBhbmNlc3RvcnMganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICBDSElMRF9SRU1PVkUgPSBcImNoaWxkUmVtb3ZlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBNdXRhYmxlfSB3aGVuIGl0cyBiZWluZyBtdXRhdGVkICovXHJcbiAgICBNVVRBVEUgPSBcIm11dGF0ZVwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIFZpZXdwb3J0fSB3aGVuIGl0IGdldHMgdGhlIGZvY3VzIHRvIHJlY2VpdmUga2V5Ym9hcmQgaW5wdXQgKi9cclxuICAgIEZPQ1VTX0lOID0gXCJmb2N1c2luXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVmlld3BvcnR9IHdoZW4gaXQgbG9zZXMgdGhlIGZvY3VzIHRvIHJlY2VpdmUga2V5Ym9hcmQgaW5wdXQgKi9cclxuICAgIEZPQ1VTX09VVCA9IFwiZm9jdXNvdXRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBOb2RlfSB3aGVuIGl0J3MgZG9uZSBzZXJpYWxpemluZyAqL1xyXG4gICAgTk9ERV9TRVJJQUxJWkVEID0gXCJub2RlU2VyaWFsaXplZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIE5vZGV9IHdoZW4gaXQncyBkb25lIGRlc2VyaWFsaXppbmcsIHNvIGFsbCBjb21wb25lbnRzLCBjaGlsZHJlbiBhbmQgYXR0cmlidXRlcyBhcmUgYXZhaWxhYmxlICovXHJcbiAgICBOT0RFX0RFU0VSSUFMSVpFRCA9IFwibm9kZURlc2VyaWFsaXplZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIEdyYXBoSW5zdGFuY2V9IHdoZW4gaXQncyBjb250ZW50IGlzIHNldCBhY2NvcmRpbmcgdG8gYSBzZXJpYWxpemF0aW9uIG9mIGEge0BsaW5rIEdyYXBofSAgKi9cclxuICAgIEdSQVBIX0lOU1RBTlRJQVRFRCA9IFwiZ3JhcGhJbnN0YW50aWF0ZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBUaW1lfSB3aGVuIGl0J3Mgc2NhbGluZyBjaGFuZ2VkICAqL1xyXG4gICAgVElNRV9TQ0FMRUQgPSBcInRpbWVTY2FsZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBGaWxlSW9Ccm93c2VyTG9jYWx9IHdoZW4gYSBsaXN0IG9mIGZpbGVzIGhhcyBiZWVuIGxvYWRlZCAgKi9cclxuICAgIEZJTEVfTE9BREVEID0gXCJmaWxlTG9hZGVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgRmlsZUlvQnJvd3NlckxvY2FsfSB3aGVuIGEgbGlzdCBvZiBmaWxlcyBoYXMgYmVlbiBzYXZlZCAqL1xyXG4gICAgRklMRV9TQVZFRCA9IFwiZmlsZVNhdmVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gd2hlbiByZWNhbGN1bGF0aW5nIHRyYW5zZm9ybXMgZm9yIHJlbmRlciAqL1xyXG4gICAgUkVOREVSX1BSRVBBUkUgPSBcInJlbmRlclByZXBhcmVcIixcclxuICAgIFJFTkRFUl9QUkVQQVJFX1NUQVJUID0gXCJyZW5kZXJQcmVwYXJlU3RhcnRcIixcclxuICAgIFJFTkRFUl9QUkVQQVJFX0VORCA9IFwicmVuZGVyUHJlcGFyZUVuZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gSm9pbnQtQ29tcG9uZW50cyBpbiBvcmRlciB0byBkaXNjb25uZWN0ICovXHJcbiAgICBESVNDT05ORUNUX0pPSU5UID0gXCJkaXNjb25uZWN0Sm9pbnRcIlxyXG4gIH1cclxuXHJcblxyXG4gIC8vIGV4cG9ydCB0eXBlIEV2ZW50xpIgPSBFdmVudFBvaW50ZXIgfCBFdmVudERyYWdEcm9wIHwgRXZlbnRXaGVlbCB8IEV2ZW50S2V5Ym9hcmQgfCBFdmVudCB8IEV2ZW50UGh5c2ljcztcclxuXHJcbiAgZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lcsaSID1cclxuICAgICgoX2V2ZW50OiBFdmVudFBvaW50ZXIpID0+IHZvaWQpIHxcclxuICAgICgoX2V2ZW50OiBFdmVudERyYWdEcm9wKSA9PiB2b2lkKSB8XHJcbiAgICAoKF9ldmVudDogRXZlbnRXaGVlbCkgPT4gdm9pZCkgfFxyXG4gICAgKChfZXZlbnQ6IEV2ZW50S2V5Ym9hcmQpID0+IHZvaWQpIHxcclxuICAgICgoX2V2ZW50OiBFdmVudMaSKSA9PiB2b2lkKSB8XHJcbiAgICAoKF9ldmVudDogRXZlbnRQaHlzaWNzKSA9PiB2b2lkKSB8XHJcbiAgICAoKF9ldmVudDogQ3VzdG9tRXZlbnQpID0+IHZvaWQpIHxcclxuICAgIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q7XHJcblxyXG4gIGV4cG9ydCB0eXBlIEV2ZW50xpIgPSBFdmVudFBvaW50ZXIgfCBFdmVudERyYWdEcm9wIHwgRXZlbnRXaGVlbCB8IEV2ZW50S2V5Ym9hcmQgfCBFdmVudCB8IEV2ZW50UGh5c2ljcyB8IEN1c3RvbUV2ZW50O1xyXG4gIC8vIGV4cG9ydCB0eXBlIEV2ZW50TGlzdGVuZXLGkiA9ICgoX2V2ZW50OiBFdmVudMaSKSA9PiB2b2lkKSB8IEV2ZW50TGlzdGVuZXIgfCBFdmVudExpc3RlbmVyT2JqZWN0O1xyXG5cclxuICBleHBvcnQgY2xhc3MgRXZlbnRUYXJnZXTGkiBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcclxuICAgIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXLGkiwgX29wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgPEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q+X2hhbmRsZXIsIF9vcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXLGkiwgX29wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZSwgPEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q+X2hhbmRsZXIsIF9vcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnTGkik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gc3VwZXIuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgRXZlbnRUYXJnZXQgc2luZ2xldG9ucywgd2hpY2ggYXJlIGZpeGVkIGVudGl0aWVzIGluIHRoZSBzdHJ1Y3R1cmUgb2YgRnVkZ2UsIHN1Y2ggYXMgdGhlIGNvcmUgbG9vcCBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRXZlbnRUYXJnZXRTdGF0aWMgZXh0ZW5kcyBFdmVudFRhcmdldMaSIHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdGFyZ2V0U3RhdGljOiBFdmVudFRhcmdldFN0YXRpYyA9IG5ldyBFdmVudFRhcmdldFN0YXRpYygpO1xyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLmFkZEV2ZW50TGlzdGVuZXIoX3R5cGUsIF9oYW5kbGVyKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lcik6IHZvaWQge1xyXG4gICAgICBFdmVudFRhcmdldFN0YXRpYy50YXJnZXRTdGF0aWMucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlIGRlc2NyaWJpbmcgdGhlIGRhdGF0eXBlcyBvZiB0aGUgYXR0cmlidXRlcyBhIG11dGF0b3IgYXMgc3RyaW5ncyBcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICBbYXR0cmlidXRlOiBzdHJpbmddOiBzdHJpbmcgfCBPYmplY3Q7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSBkZXNjcmliaW5nIGEgbXV0YXRvciwgd2hpY2ggaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2l0aCBuYW1lcyBvZiBhdHRyaWJ1dGVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHZhbHVlc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvciB7XHJcbiAgICBbYXR0cmlidXRlOiBzdHJpbmddOiBHZW5lcmFsO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBJbnRlcmZhY2VzIGRlZGljYXRlZCBmb3IgZWFjaCBwdXJwb3NlLiBFeHRyYSBhdHRyaWJ1dGUgbmVjZXNzYXJ5IGZvciBjb21waWxldGltZSB0eXBlIGNoZWNraW5nLCBub3QgZXhpc3RlbnQgYXQgcnVudGltZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckZvckFuaW1hdGlvbiBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JBbmltYXRpb246IG51bGw7IH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvclVzZXJJbnRlcmZhY2U6IG51bGw7IH1cclxuICAvLyBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JDb21wb25lbnQgZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yVXNlckNvbXBvbmVudDogbnVsbDsgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0IGFwcGxpY2FibGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcGllcyBvZiB0aGVpciB2YWx1ZXMgaW4gYSBNdXRhdG9yLW9iamVjdFxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkoX29iamVjdDogT2JqZWN0KTogTXV0YXRvciB7XHJcbiAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgbGV0IGF0dHJpYnV0ZXM6IChzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpW10gPSBSZWZsZWN0Lm93bktleXMoUmVmbGVjdC5nZXRQcm90b3R5cGVPZihfb2JqZWN0KSk7XHJcbiAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xyXG4gICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IFJlZmxlY3QuZ2V0KF9vYmplY3QsIGF0dHJpYnV0ZSk7XHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAvLyBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpKVxyXG4gICAgICAvLyAgIGNvbnRpbnVlO1xyXG4gICAgICBtdXRhdG9yW2F0dHJpYnV0ZS50b1N0cmluZygpXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgdHlwZXMgYmVpbmcgbXV0YWJsZSB1c2luZyB7QGxpbmsgTXV0YXRvcn0tb2JqZWN0cywgdGh1cyBwcm92aWRpbmcgYW5kIHVzaW5nIGludGVyZmFjZXMgY3JlYXRlZCBhdCBydW50aW1lLiAgXHJcbiAgICogTXV0YWJsZXMgcHJvdmlkZSBhIHtAbGluayBNdXRhdG9yfSB0aGF0IGlzIGJ1aWxkIGJ5IGNvbGxlY3RpbmcgYWxsIG9iamVjdC1wcm9wZXJ0aWVzIHRoYXQgYXJlIGVpdGhlciBvZiBhIHByaW1pdGl2ZSB0eXBlIG9yIGFnYWluIE11dGFibGUuXHJcbiAgICogU3ViY2xhc3NlcyBjYW4gZWl0aGVyIHJlZHVjZSB0aGUgc3RhbmRhcmQge0BsaW5rIE11dGF0b3J9IGJ1aWx0IGJ5IHRoaXMgYmFzZSBjbGFzcyBieSBkZWxldGluZyBwcm9wZXJ0aWVzIG9yIGltcGxlbWVudCBhbiBpbmRpdmlkdWFsIGdldE11dGF0b3ItbWV0aG9kLlxyXG4gICAqIFRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9mIHRoZSB7QGxpbmsgTXV0YXRvcn0gbXVzdCBtYXRjaCBwdWJsaWMgcHJvcGVydGllcyBvciBnZXR0ZXJzL3NldHRlcnMgb2YgdGhlIG9iamVjdC5cclxuICAgKiBPdGhlcndpc2UsIHRoZXkgd2lsbCBiZSBpZ25vcmVkIGlmIG5vdCBoYW5kbGVkIGJ5IGFuIG92ZXJyaWRlIG9mIHRoZSBtdXRhdGUtbWV0aG9kIGluIHRoZSBzdWJjbGFzcyBhbmQgdGhyb3cgZXJyb3JzIGluIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIHVzZXItaW50ZXJmYWNlIGZvciB0aGUgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNdXRhYmxlIGV4dGVuZHMgRXZlbnRUYXJnZXTGkiB7XHJcbiAgICAvKipcclxuICAgICAqIERlY29yYXRvciBhbGxvd3MgdG8gYXR0YWNoIHtAbGluayBNdXRhYmxlfSBmdW5jdGlvbmFsaXR5IHRvIGV4aXN0aW5nIGNsYXNzZXMuIFxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgIC8vICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwidXNlUmVuZGVyRGF0YVwiLCB7XHJcbiAgICAvLyAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE11dGF0b3IodGhpczogTXV0YWJsZUZvclVzZXJJbnRlcmZhY2UpOiBNdXRhdG9yIHtcclxuICAgIC8vICAgICAgIHJldHVybiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkodGhpcyk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICB9KTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldE11dGF0b3JGcm9tUGF0aChfbXV0YXRvcjogTXV0YXRvciwgX3BhdGg6IHN0cmluZ1tdKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9wYXRoWzBdO1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgICBpZiAoIV9tdXRhdG9yW2tleV0pIC8vIGlmIHRoZSBwYXRoIGRldmlhdGVzIGZyb20gbXV0YXRvciBzdHJ1Y3R1cmUsIHJldHVybiB0aGUgbXV0YXRvclxyXG4gICAgICAgIHJldHVybiBfbXV0YXRvcjtcclxuICAgICAgbXV0YXRvcltrZXldID0gX211dGF0b3Jba2V5XTtcclxuICAgICAgaWYgKF9wYXRoLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgbXV0YXRvcltrZXldID0gTXV0YWJsZS5nZXRNdXRhdG9yRnJvbVBhdGgobXV0YXRvcltrZXldLCBfcGF0aC5zbGljZSgxLCBfcGF0aC5sZW5ndGgpKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHR5cGUgb2YgdGhpcyBtdXRhYmxlIHN1YmNsYXNzIGFzIHRoZSBuYW1lIG9mIHRoZSBydW50aW1lIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgbXV0YWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3BpZXMgb2YgdGhlaXIgdmFsdWVzIGluIGEgTXV0YXRvci1vYmplY3QuXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBhIG11dGF0b3IgY2Fubm90IGJlIGV4dGVuZGVkLCBzaW5jZSBleHRlbnNpb25zIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSBvYmplY3QgdGhlIG11dGF0b3IgYmVsb25ncyB0by5cclxuICAgICAqIEEgbXV0YXRvciBtYXkgYmUgcmVkdWNlZCBieSB0aGUgZGVzY2VuZGFudHMgb2Yge0BsaW5rIE11dGFibGV9IHRvIGNvbnRhaW4gb25seSB0aGUgcHJvcGVydGllcyBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKF9leHRlbmRhYmxlOiBib29sZWFuID0gZmFsc2UpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7fTtcclxuXHJcbiAgICAgIC8vIGNvbGxlY3QgcHJpbWl0aXZlIGFuZCBtdXRhYmxlIGF0dHJpYnV0ZXNcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIHRoaXMpIHtcclxuICAgICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IHRoaXNbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGVBcnJheSkgJiYgISh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcImlkUmVzb3VyY2VcIikpKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gdGhpc1thdHRyaWJ1dGVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIV9leHRlbmRhYmxlKVxyXG4gICAgICAgIC8vIG11dGF0b3IgY2FuIGJlIHJlZHVjZWQgYnV0IG5vdCBleHRlbmRlZCFcclxuICAgICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMobXV0YXRvcik7XHJcbiAgICAgIC8vIGRlbGV0ZSB1bndhbnRlZCBhdHRyaWJ1dGVzXHJcbiAgICAgIHRoaXMucmVkdWNlTXV0YXRvcihtdXRhdG9yKTtcclxuXHJcbiAgICAgIC8vIHJlcGxhY2UgcmVmZXJlbmNlcyB0byBtdXRhYmxlIG9iamVjdHMgd2l0aCByZWZlcmVuY2VzIHRvIG11dGF0b3JzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBtdXRhdG9yKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSBtdXRhdG9yW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHZhbHVlLmdldE11dGF0b3IoKTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlQXJyYXkpXHJcbiAgICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZS5tYXAoKF92YWx1ZSkgPT4gX3ZhbHVlLmdldE11dGF0b3IoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciBhbmltYXRpb24uXHJcbiAgICAgKiBCYXNpYyBmdW5jdGlvbmFsaXR5IGlzIGlkZW50aWNhbCB0byB7QGxpbmsgZ2V0TXV0YXRvcn0sIHJldHVybmVkIG11dGF0b3Igc2hvdWxkIHRoZW4gYmUgcmVkdWNlZCBieSB0aGUgc3ViY2xhc3NlZCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvckFuaW1hdGlvbigpOiBNdXRhdG9yRm9yQW5pbWF0aW9uIHtcclxuICAgICAgcmV0dXJuIDxNdXRhdG9yRm9yQW5pbWF0aW9uPnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIHRoZSB1c2VyIGludGVyZmFjZS5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIHtAbGluayBnZXRNdXRhdG9yfSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSgpOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSB7XHJcbiAgICAgIHJldHVybiA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCB0aGVpciB2YWx1ZXMgYXBwbGljYWJsZSBmb3IgaW5kaXZpdWFsaXphdGlvbiBieSB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIGdldE11dGF0b3J9LCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JGb3JDb21wb25lbnQoKTogTXV0YXRvckZvckNvbXBvbmVudCB7XHJcbiAgICAvLyAgICAgcmV0dXJuIDxNdXRhdG9yRm9yQ29tcG9uZW50PnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggdGhlIHNhbWUgYXR0cmlidXRlcyBhcyB0aGUgZ2l2ZW4gbXV0YXRvciwgYnV0IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgdHlwZXMgYXMgc3RyaW5nLXZhbHVlc1xyXG4gICAgICogRG9lcyBub3QgcmVjdXJzZSBpbnRvIG9iamVjdHMhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBsZXQgdHlwZTogc3RyaW5nID0gbnVsbDtcclxuICAgICAgICBsZXQgdmFsdWU6IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfCBvYmplY3QgPSBfbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChfbXV0YXRvclthdHRyaWJ1dGVdICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICB0eXBlID0gKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV0uY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdHlwZSA9IHZhbHVlW1wibmFtZVwiXTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdHlwZSA9IF9tdXRhdG9yW2F0dHJpYnV0ZV0uY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICB0eXBlc1thdHRyaWJ1dGVdID0gdHlwZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbXV0YXRvciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gX211dGF0b3JbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgX211dGF0b3JbYXR0cmlidXRlXSA9IHZhbHVlLmdldE11dGF0b3IoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBfbXV0YXRvclthdHRyaWJ1dGVdID0gKDxHZW5lcmFsPnRoaXMpW2F0dHJpYnV0ZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHRoZSBzdGF0ZSBvZiB0aGUgbXV0YXRvci5cclxuICAgICAqIFRoZSBtdXRhdGlvbiBtYXkgYmUgcmVzdHJpY3RlZCB0byBhIHN1YnNldCBvZiB0aGUgbXV0YXRvciBhbmQgdGhlIGV2ZW50IGRpc3BhdGNoaW5nIHN1cHByZXNzZWQuXHJcbiAgICAgKiBVc2VzIG11dGF0ZUJhc2UsIGJ1dCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gc3ViY2xhc3Nlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBfc2VsZWN0aW9uKTtcclxuICAgICAgaWYgKF9kaXNwYXRjaE11dGF0ZSlcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULk1VVEFURSwge2J1YmJsZXM6IHRydWUsIGRldGFpbDoge211dGF0b3I6IF9tdXRhdG9yfX0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhc2UgbWV0aG9kIGZvciBtdXRhdGlvbiwgYWx3YXlzIGF2YWlsYWJsZSB0byBzdWJjbGFzc2VzLiBEbyBub3Qgb3ZlcndyaXRlIGluIHN1YmNsYXNzZXMhXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhc3luYyBtdXRhdGVCYXNlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uPzogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7fTtcclxuICAgICAgaWYgKCFfc2VsZWN0aW9uKVxyXG4gICAgICAgIG11dGF0b3IgPSBfbXV0YXRvcjtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBvZiBfc2VsZWN0aW9uKSAvLyByZWR1Y2UgdGhlIG11dGF0b3IgdG8gdGhlIHNlbGVjdGlvblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3JbYXR0cmlidXRlXSkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IF9tdXRhdG9yW2F0dHJpYnV0ZV07XHJcblxyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gbXV0YXRvcikge1xyXG4gICAgICAgIGlmICghUmVmbGVjdC5oYXModGhpcywgYXR0cmlidXRlKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGxldCBtdXRhbnQ6IE9iamVjdCA9IFJlZmxlY3QuZ2V0KHRoaXMsIGF0dHJpYnV0ZSk7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBNdXRhdG9yID0gPE11dGF0b3I+bXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChtdXRhbnQgaW5zdGFuY2VvZiBNdXRhYmxlQXJyYXkgfHwgbXV0YW50IGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIGF3YWl0IG11dGFudC5tdXRhdGUodmFsdWUsIG51bGwsIGZhbHNlKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBhdHRyaWJ1dGUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWR1Y2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBnZW5lcmFsIG11dGF0b3IgYWNjb3JkaW5nIHRvIGRlc2lyZWQgb3B0aW9ucyBmb3IgbXV0YXRpb24uIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkO1xyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueVxyXG4gIGV4cG9ydCB0eXBlIEdlbmVyYWwgPSBhbnk7XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphdGlvbiB7XHJcbiAgICBbdHlwZTogc3RyaW5nXTogR2VuZXJhbDtcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemFibGUge1xyXG4gICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb247XHJcbiAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPjtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBOYW1lc3BhY2VSZWdpc3RlciB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB0aGUgZXh0ZXJuYWwgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG9mIHtAbGluayBTZXJpYWxpemFibGV9IG9iamVjdHMuIFRoZSBpbnRlcm5hbCBwcm9jZXNzIGlzIGhhbmRsZWQgYnkgdGhlIG9iamVjdHMgdGhlbXNlbHZlcy4gIFxyXG4gICAqIEEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9iamVjdCBjYW4gYmUgY3JlYXRlZCBmcm9tIGEge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0IGFuZCBhIEpTT04tU3RyaW5nIG1heSBiZSBjcmVhdGVkIGZyb20gdGhhdC4gIFxyXG4gICAqIFZpY2UgdmVyc2EsIGEgSlNPTi1TdHJpbmcgY2FuIGJlIHBhcnNlZCB0byBhIHtAbGluayBTZXJpYWxpemF0aW9ufSB3aGljaCBjYW4gYmUgZGVzZXJpYWxpemVkIHRvIGEge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0LlxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICBbU2VyaWFsaXphYmxlXSDihpIgKHNlcmlhbGl6ZSkg4oaSIFtTZXJpYWxpemF0aW9uXSDihpIgKHN0cmluZ2lmeSkg4oaSIFtTdHJpbmddIOKGkiAoc2F2ZSBvciBzZW5kKVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkyAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpMgICAgICAgICAgICAgICAgICDihpMgICAgICAgICBcclxuICAgKiAgICAgICAgICAgICAgICBbU2VyaWFsaXphYmxlXSDihpAgKGRlc2VyaWFsaXplKSDihpAgW1NlcmlhbGl6YXRpb25dIOKGkCAocGFyc2UpIOKGkCAobG9hZCkg4oaQIFtNZWRpdW1dXHJcbiAgICogYGBgICAgICAgXHJcbiAgICogV2hpbGUgdGhlIGludGVybmFsIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBtZXRob2QxcyBvZiB0aGUgb2JqZWN0cyBjYXJlIG9mIHRoZSBzZWxlY3Rpb24gb2YgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHJlY3JlYXRlIHRoZSBvYmplY3QgYW5kIGl0cyBzdHJ1Y3R1cmUsICBcclxuICAgKiB0aGUge0BsaW5rIFNlcmlhbGl6ZXJ9IGtlZXBzIHRyYWNrIG9mIHRoZSBuYW1lc3BhY2VzIGFuZCBjbGFzc2VzIGluIG9yZGVyIHRvIHJlY3JlYXRlIHtAbGluayBTZXJpYWxpemFibGV9IG9iamVjdHMuIFRoZSBnZW5lcmFsIHN0cnVjdHVyZSBvZiBhIHtAbGluayBTZXJpYWxpemF0aW9ufSBpcyBhcyBmb2xsb3dzICBcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiB7XHJcbiAgICogICAgICBuYW1lc3BhY2VOYW1lLmNsYXNzTmFtZToge1xyXG4gICAqICAgICAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlWYWx1ZSxcclxuICAgKiAgICAgICAgICAuLi4sXHJcbiAgICogICAgICAgICAgcHJvcGVydHlOYW1lT2ZSZWZlcmVuY2U6IFNlcmlhbGl6YXRpb25PZlRoZVJlZmVyZW5jZWRPYmplY3QsXHJcbiAgICogICAgICAgICAgLi4uLFxyXG4gICAqICAgICAgICAgIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzczogU2VyaWFsaXphdGlvbk9mU3VwZXJDbGFzc1xyXG4gICAqICAgICAgfVxyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKiBTaW5jZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIHN1cGVyY2xhc3MgaXMgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYW4gb2JqZWN0IGlzIGNyZWF0ZWQsIFxyXG4gICAqIHRoZSBTZXJpYWxpemF0aW9uT2ZTdXBlckNsYXNzIG9taXRzIHRoZSB0aGUgbmFtZXNwYWNlTmFtZS5jbGFzc05hbWUga2V5IGFuZCBjb25zaXN0cyBvbmx5IG9mIGl0cyB2YWx1ZS4gXHJcbiAgICogVGhlIGNvbnN0cnVjdG9yTmFtZU9mU3VwZXJjbGFzcyBpcyBnaXZlbiBpbnN0ZWFkIGFzIGEgcHJvcGVydHkgbmFtZSBpbiB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgc3ViY2xhc3MuXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNlcmlhbGl6ZXIge1xyXG4gICAgLyoqIEluIG9yZGVyIGZvciB0aGUgU2VyaWFsaXplciB0byBjcmVhdGUgY2xhc3MgaW5zdGFuY2VzLCBpdCBuZWVkcyBhY2Nlc3MgdG8gdGhlIGFwcHJvcHJpYXRlIG5hbWVzcGFjZXMgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIG5hbWVzcGFjZXM6IE5hbWVzcGFjZVJlZ2lzdGVyID0geyBcIsaSXCI6IEZ1ZGdlQ29yZSB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbmFtZXNwYWNlIHRvIHRoZSB7QGxpbmsgU2VyaWFsaXplcn0sIHRvIGVuYWJsZSBhdXRvbWF0aWMgaW5zdGFudGlhdGlvbiBvZiBjbGFzc2VzIGRlZmluZWQgd2l0aGluXHJcbiAgICAgKiBAcGFyYW0gX25hbWVzcGFjZSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3Rlck5hbWVzcGFjZShfbmFtZXNwYWNlOiBPYmplY3QpOiBzdHJpbmcge1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcylcclxuICAgICAgICBpZiAoU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVdID09IF9uYW1lc3BhY2UpXHJcbiAgICAgICAgICByZXR1cm4gbmFtZTtcclxuXHJcbiAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCB3aW5kb3cpO1xyXG4gICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgZm9yIChsZXQgcGFyZW50TmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpIHtcclxuICAgICAgICAgIG5hbWUgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCBTZXJpYWxpemVyLm5hbWVzcGFjZXNbcGFyZW50TmFtZV0pO1xyXG4gICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgbmFtZSA9IHBhcmVudE5hbWUgKyBcIi5cIiArIG5hbWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbmFtZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lc3BhY2Ugbm90IGZvdW5kLiBNYXliZSBwYXJlbnQgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgYmVmb3JlP1wiKTtcclxuXHJcbiAgICAgIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lXSA9IF9uYW1lc3BhY2U7XHJcbiAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6YWJsZSBGVURHRS1vYmplY3QgZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0cyBhbGwgaW5mb3JtYXRpb24gbmVlZGVkIGZvciByZWNvbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIF9vYmplY3QgQW4gb2JqZWN0IHRvIHNlcmlhbGl6ZSwgaW1wbGVtZW50aW5nIHRoZSB7QGxpbmsgU2VyaWFsaXphYmxlfSBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemUoX29iamVjdDogU2VyaWFsaXphYmxlKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIC8vIFRPRE86IHNhdmUgdGhlIG5hbWVzcGFjZSB3aXRoIHRoZSBjb25zdHJ1Y3RvcnMgbmFtZVxyXG4gICAgICAvLyBzZXJpYWxpemF0aW9uW19vYmplY3QuY29uc3RydWN0b3IubmFtZV0gPSBfb2JqZWN0LnNlcmlhbGl6ZSgpO1xyXG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gdGhpcy5nZXRGdWxsUGF0aChfb2JqZWN0KTtcclxuICAgICAgaWYgKCFwYXRoKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZXNwYWNlIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke19vYmplY3QuY29uc3RydWN0b3IubmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgb3IgdGhlIGNsYXNzIG5vdCBleHBvcnRlZD9gKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltwYXRoXSA9IF9vYmplY3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgICAvLyByZXR1cm4gX29iamVjdC5zZXJpYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBGVURHRS1vYmplY3QgcmVjb25zdHJ1Y3RlZCBmcm9tIHRoZSBpbmZvcm1hdGlvbiBpbiB0aGUge0BsaW5rIFNlcmlhbGl6YXRpb259IGdpdmVuLFxyXG4gICAgICogaW5jbHVkaW5nIGF0dGFjaGVkIGNvbXBvbmVudHMsIGNoaWxkcmVuLCBzdXBlcmNsYXNzLW9iamVjdHNcclxuICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGxldCByZWNvbnN0cnVjdDogU2VyaWFsaXphYmxlO1xyXG4gICAgICBsZXQgcGF0aDogc3RyaW5nO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGxvb3AgY29uc3RydWN0ZWQgc29sZWx5IHRvIGFjY2VzcyB0eXBlLXByb3BlcnR5LiBPbmx5IG9uZSBleHBlY3RlZCFcclxuICAgICAgICBmb3IgKHBhdGggaW4gX3NlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICAgIC8vIHJlY29uc3RydWN0ID0gbmV3ICg8R2VuZXJhbD5GdWRnZSlbdHlwZU5hbWVdO1xyXG4gICAgICAgICAgcmVjb25zdHJ1Y3QgPSBTZXJpYWxpemVyLnJlY29uc3RydWN0KHBhdGgpO1xyXG4gICAgICAgICAgcmVjb25zdHJ1Y3QgPSBhd2FpdCByZWNvbnN0cnVjdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcbiAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlc2VyaWFsaXphdGlvbiBvZiAke3BhdGh9IGZhaWxlZDogYCArIF9lcnJvcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIEFycmF5IG9mIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VyaWFsaXphYmxlIEZVREdFLW9iamVjdHMgZ2l2ZW4gaW4gdGhlIGFycmF5LFxyXG4gICAgICogaW5jbHVkaW5nIGF0dGFjaGVkIGNvbXBvbmVudHMsIGNoaWxkcmVuLCBzdXBlcmNsYXNzLW9iamVjdHMgYWxsIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgcmVjb25zdHJ1Y3Rpb25cclxuICAgICAqIEBwYXJhbSBfb2JqZWN0IEFuIG9iamVjdCB0byBzZXJpYWxpemUsIGltcGxlbWVudGluZyB0aGUge0BsaW5rIFNlcmlhbGl6YWJsZX0gaW50ZXJmYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXplQXJyYXk8VCBleHRlbmRzIFNlcmlhbGl6YWJsZT4oX3R5cGU6IG5ldyAoKSA9PiBULCBfb2JqZWN0czogU2VyaWFsaXphYmxlW10pOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb25zOiBTZXJpYWxpemF0aW9uW10gPSBbXTtcclxuICAgICAgbGV0IHBhdGg6IHN0cmluZyA9IHRoaXMuZ2V0RnVsbFBhdGgobmV3IF90eXBlKCkpO1xyXG4gICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lc3BhY2Ugb2Ygc2VyaWFsaXphYmxlIG9iamVjdCBvZiB0eXBlICR7X3R5cGUubmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgb3IgdGhlIGNsYXNzIG5vdCBleHBvcnRlZD9gKTtcclxuICAgICAgXHJcbiAgICAgIGZvciAobGV0IG9iamVjdCBvZiBfb2JqZWN0cylcclxuICAgICAgICBzZXJpYWxpemF0aW9ucy5wdXNoKG9iamVjdC5zZXJpYWxpemUoKSk7XHJcblxyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3BhdGhdID0gc2VyaWFsaXphdGlvbnM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBvZiBGVURHRS1vYmplY3RzIHJlY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IG9mIHtAbGluayBTZXJpYWxpemF0aW9ufXMgZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0c1xyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9ucyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZUFycmF5KF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGVbXT4ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphYmxlczogU2VyaWFsaXphYmxlW10gPSBbXTtcclxuICAgICAgbGV0IGNvbnN0cnVjdDogbmV3ICgpID0+IFNlcmlhbGl6YWJsZTtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb25zOiBTZXJpYWxpemF0aW9uW10gPSBbXTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBsb29wIGNvbnN0cnVjdGVkIHNvbGVseSB0byBhY2Nlc3MgdHlwZS1wcm9wZXJ0eS4gT25seSBvbmUgZXhwZWN0ZWQhXHJcbiAgICAgICAgZm9yIChsZXQgcGF0aCBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgY29uc3RydWN0ID0gU2VyaWFsaXplci5nZXRDb25zdHJ1Y3RvcihwYXRoKTtcclxuICAgICAgICAgIHNlcmlhbGl6YXRpb25zID0gX3NlcmlhbGl6YXRpb25bcGF0aF07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlc2VyaWFsaXphdGlvbiBmYWlsZWQ6IFwiICsgX2Vycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgc2VyaWFsaXphdGlvbiBvZiBzZXJpYWxpemF0aW9ucykge1xyXG4gICAgICAgIGxldCBzZXJpYWxpemFibGU6IFNlcmlhbGl6YWJsZSA9IG5ldyBjb25zdHJ1Y3QoKTtcclxuICAgICAgICBhd2FpdCBzZXJpYWxpemFibGUuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgICAgc2VyaWFsaXphYmxlcy5wdXNoKHNlcmlhbGl6YWJsZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemFibGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETzogaW1wbGVtZW50IHByZXR0aWZpZXIgdG8gbWFrZSBKU09OLVN0cmluZ2lmaWNhdGlvbiBvZiBzZXJpYWxpemF0aW9ucyBtb3JlIHJlYWRhYmxlLCBlLmcuIHBsYWNpbmcgeCwgeSBhbmQgeiBpbiBvbmUgbGluZVxyXG4gICAgcHVibGljIHN0YXRpYyBwcmV0dGlmeShfanNvbjogc3RyaW5nKTogc3RyaW5nIHsgcmV0dXJuIF9qc29uOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkLCBodW1hbiByZWFkYWJsZSBKU09OLVN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB7QGxpbmsgU2VyaWFsaXphdGlvbn0gdGhhdCBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgYnkge0BsaW5rIFNlcmlhbGl6ZXJ9LnNlcmlhbGl6ZVxyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogc3RyaW5nIHtcclxuICAgICAgLy8gYWRqdXN0bWVudHMgdG8gc2VyaWFsaXphdGlvbiBjYW4gYmUgbWFkZSBoZXJlIGJlZm9yZSBzdHJpbmdpZmljYXRpb24sIGlmIGRlc2lyZWRcclxuICAgICAgbGV0IGpzb246IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uLCBudWxsLCAyKTtcclxuICAgICAgbGV0IHByZXR0eTogc3RyaW5nID0gU2VyaWFsaXplci5wcmV0dGlmeShqc29uKTtcclxuICAgICAgcmV0dXJuIHByZXR0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBKU09OLVN0cmluZy4gUmVzdWx0IG1heSBiZSBwYXNzZWQgdG8ge0BsaW5rIFNlcmlhbGl6ZXIuZGVzZXJpYWxpemV9XHJcbiAgICAgKiBAcGFyYW0gX2pzb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2UoX2pzb246IHN0cmluZyk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShfanNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBvZiB0aGUgY2xhc3MgZGVmaW5lZCB3aXRoIHRoZSBmdWxsIHBhdGggaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2VOYW1lKHMpIGFuZCB0aGUgY2xhc3NOYW1lIHNlcGVyYXRlZCBieSBkb3RzKC4pIFxyXG4gICAgICogQHBhcmFtIF9wYXRoIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlY29uc3RydWN0KF9wYXRoOiBzdHJpbmcpOiBTZXJpYWxpemFibGUge1xyXG4gICAgICBsZXQgY29uc3RydWN0b3I6IG5ldyAoKSA9PiBTZXJpYWxpemFibGUgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKF9wYXRoKTtcclxuICAgICAgbGV0IHJlY29uc3RydWN0aW9uOiBTZXJpYWxpemFibGUgPSBuZXcgY29uc3RydWN0b3IoKTtcclxuICAgICAgcmV0dXJuIHJlY29uc3RydWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZ2V0Q29uc3RydWN0b3I8VCBleHRlbmRzIFNlcmlhbGl6YWJsZT4oX3R5cGU6IHN0cmluZywgX25hbWVzcGFjZTogT2JqZWN0ID0gRnVkZ2VDb3JlKTogbmV3ICgpID0+IFQge1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgU2VyaWFsaXphYmxlPihfcGF0aDogc3RyaW5nKTogbmV3ICgpID0+IFQge1xyXG4gICAgICBsZXQgdHlwZU5hbWU6IHN0cmluZyA9IF9wYXRoLnN1YnN0cmluZyhfcGF0aC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcclxuICAgICAgbGV0IG5hbWVzcGFjZTogT2JqZWN0ID0gU2VyaWFsaXplci5nZXROYW1lc3BhY2UoX3BhdGgpO1xyXG4gICAgICBpZiAoIW5hbWVzcGFjZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cnVjdG9yIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke19wYXRofSBub3QgZm91bmQuIE1heWJlIHRoZSBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZD9gKTtcclxuICAgICAgcmV0dXJuICg8R2VuZXJhbD5uYW1lc3BhY2UpW3R5cGVOYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgY2xhc3Mgb2YgdGhlIG9iamVjdCwgaWYgZm91bmQgaW4gdGhlIHJlZ2lzdGVyZWQgbmFtZXNwYWNlc1xyXG4gICAgICogQHBhcmFtIF9vYmplY3QgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEZ1bGxQYXRoKF9vYmplY3Q6IFNlcmlhbGl6YWJsZSk6IHN0cmluZyB7XHJcbiAgICAgIGxldCB0eXBlTmFtZTogc3RyaW5nID0gX29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coXCJTZWFyY2hpbmcgbmFtZXNwYWNlIG9mOiBcIiArIHR5cGVOYW1lKTtcclxuICAgICAgZm9yIChsZXQgbmFtZXNwYWNlTmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpIHtcclxuICAgICAgICBsZXQgZm91bmQ6IEdlbmVyYWwgPSAoPEdlbmVyYWw+U2VyaWFsaXplci5uYW1lc3BhY2VzKVtuYW1lc3BhY2VOYW1lXVt0eXBlTmFtZV07XHJcbiAgICAgICAgaWYgKGZvdW5kICYmIF9vYmplY3QgaW5zdGFuY2VvZiBmb3VuZClcclxuICAgICAgICAgIHJldHVybiBuYW1lc3BhY2VOYW1lICsgXCIuXCIgKyB0eXBlTmFtZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzcGFjZS1vYmplY3QgZGVmaW5lZCB3aXRoaW4gdGhlIGZ1bGwgcGF0aCwgaWYgcmVnaXN0ZXJlZFxyXG4gICAgICogQHBhcmFtIF9wYXRoXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldE5hbWVzcGFjZShfcGF0aDogc3RyaW5nKTogT2JqZWN0IHtcclxuICAgICAgbGV0IG5hbWVzcGFjZU5hbWU6IHN0cmluZyA9IF9wYXRoLnN1YnN0cigwLCBfcGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xyXG4gICAgICByZXR1cm4gU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVzcGFjZU5hbWVdIHx8IEZ1ZGdlQ29yZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGluIHByb3BlcnRpZXMgb2YgdGhlIHBhcmVudC1vYmplY3QgKGUuZy4gd2luZG93KSwgaWYgcHJlc2VudFxyXG4gICAgICogQHBhcmFtIF9uYW1lc3BhY2UgXHJcbiAgICAgKiBAcGFyYW0gX3BhcmVudCBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluZE5hbWVzcGFjZUluKF9uYW1lc3BhY2U6IE9iamVjdCwgX3BhcmVudDogT2JqZWN0KTogc3RyaW5nIHtcclxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBfcGFyZW50KVxyXG4gICAgICAgIGlmICgoPEdlbmVyYWw+X3BhcmVudClbcHJvcF0gPT0gX25hbWVzcGFjZSlcclxuICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqIFxyXG4gICAqIFN1cGVyY2xhc3MgZm9yIGFsbCB7QGxpbmsgQ29tcG9uZW50fXMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8ge0BsaW5rIE5vZGV9cy5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMCB8IEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5ICBcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbXBvbmVudCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgLyoqIHN1YmNsYXNzZXMgZ2V0IGEgaVN1YmNsYXNzIG51bWJlciBmb3IgaWRlbnRpZmljYXRpb24gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXI7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBDb21wb25lbnQgPSBDb21wb25lbnQ7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBDb21wb25lbnRbXSA9IFtdO1xyXG5cclxuICAgICNub2RlOiBOb2RlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHByb3RlY3RlZCBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURSwgKF9ldmVudDogQ3VzdG9tRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAodGhpcy4jbm9kZSkge1xyXG4gICAgICAgICAgLy8gVE9ETzogZmluZCB0aGUgbnVtYmVyIG9mIHRoZSBjb21wb25lbnQgaW4gdGhlIGFycmF5IGlmIG5vdCBzaW5nbGV0b25cclxuICAgICAgICAgIF9ldmVudC5kZXRhaWwuY29tcG9uZW50ID0gdGhpcztcclxuICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgX2V2ZW50LmRldGFpbC5jb21wb25lbnRJbmRleCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnRzKHRoaXMuY29uc3RydWN0b3IpLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgICB0aGlzLiNub2RlLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBDb21wb25lbnQpOiBudW1iZXIgeyByZXR1cm4gQ29tcG9uZW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0cnVlLCB3aGVuIG9ubHkgb25lIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgY2xhc3MgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGlzU2luZ2xldG9uKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaW5nbGV0b247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5vZGUsIHRoaXMgY29tcG9uZW50IGlzIGN1cnJlbnRseSBhdHRhY2hlZCB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG5vZGUoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX29uO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KF9vbiA/IEVWRU5ULkNPTVBPTkVOVF9BQ1RJVkFURSA6IEVWRU5ULkNPTVBPTkVOVF9ERUFDVElWQVRFKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmllcyB0byBhdHRhY2ggdGhlIGNvbXBvbmVudCB0byB0aGUgZ2l2ZW4gbm9kZSwgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgbm9kZSBpdCB3YXMgYXR0YWNoZWQgdG8gaWYgYXBwbGljYWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXR0YWNoVG9Ob2RlKF9jb250YWluZXI6IE5vZGUgfCBudWxsKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLiNub2RlID09IF9jb250YWluZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgcHJldmlvdXNDb250YWluZXI6IE5vZGUgPSB0aGlzLiNub2RlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChwcmV2aW91c0NvbnRhaW5lcilcclxuICAgICAgICAgIHByZXZpb3VzQ29udGFpbmVyLnJlbW92ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICB0aGlzLiNub2RlID0gX2NvbnRhaW5lcjtcclxuICAgICAgICBpZiAodGhpcy4jbm9kZSlcclxuICAgICAgICAgIHRoaXMuI25vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICB0aGlzLiNub2RlID0gcHJldmlvdXNDb250YWluZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGFjdGl2ZTogdGhpcy5hY3RpdmVcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKF9zZXJpYWxpemF0aW9uLmFjdGl2ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYWN0aXZlKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLmFjdGl2YXRlKF9tdXRhdG9yLmFjdGl2ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNpbmdsZXRvbjtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLm10eFdvcmxkO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogV3JhcHMgYSByZWd1bGFyIEphdmFzY3JpcHQgQXJyYXkgYW5kIG9mZmVycyB2ZXJ5IGxpbWl0ZWQgZnVuY3Rpb25hbGl0eSBnZWFyZWQgc29sZWx5IHRvd2FyZHMgYXZvaWRpbmcgZ2FyYmFnZSBjb2xsZXRpb24uXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZWN5Y2xlclxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZWN5Y2FibGVBcnJheTxUPiB7XHJcbiAgICAjbGVuZ3RoOiBudW1iZXIgPSAwO1xyXG4gICAgI2FycmF5OiBBcnJheTxUPiA9IG5ldyBBcnJheTxUPigpO1xyXG4gICAgLy8gI3R5cGU6IG5ldyAoKSA9PiBUO1xyXG5cclxuICAgIC8vIC8vdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgLy8gY29uc3RydWN0b3IoX3R5cGU6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFQpIHtcclxuICAgIC8vICAgdGhpcy4jdHlwZSA9IF90eXBlO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2aXJ0dWFsIGxlbmd0aCBvZiB0aGUgYXJyYXkgdG8gemVybyBidXQga2VlcHMgdGhlIGVudHJpZXMgYmV5b25kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI2xlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcHVzaChfZW50cnk6IFQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLiNhcnJheVt0aGlzLiNsZW5ndGhdID0gX2VudHJ5O1xyXG4gICAgICB0aGlzLiNsZW5ndGgrKztcclxuICAgICAgcmV0dXJuIHRoaXMuI2xlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcG9wKCk6IFQge1xyXG4gICAgICB0aGlzLiNsZW5ndGgtLTtcclxuICAgICAgcmV0dXJuIHRoaXMuI2FycmF5W3RoaXMuI2xlbmd0aF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN5Y2xlcyB0aGUgb2JqZWN0IGZvbGxvd2luZyB0aGUgbGFzdCBpbiB0aGUgYXJyYXkgYW5kIGluY3JlYXNlcyB0aGUgYXJyYXkgbGVuZ3RoXHJcbiAgICAgKiBJdCBtdXN0IGJlIGFzc3VyZWQsIHRoYXQgbm9uZSBvZiB0aGUgb2JqZWN0cyBpbiB0aGUgYXJyYXkgaXMgc3RpbGwgaW4gYW55IHVzZSBvZiBhbnkga2luZCFcclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIHJlY3ljbGUoKTogVCB7XHJcbiAgICAvLyAgIGlmICh0aGlzLiNsZW5ndGggPCB0aGlzLiNhcnJheS5sZW5ndGgpIHtcclxuICAgIC8vICAgICB0aGlzLiNsZW5ndGgrKztcclxuICAgIC8vICAgICByZXR1cm4gdGhpcy4jYXJyYXlbdGhpcy4jbGVuZ3RoKytdO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyAgIHRoaXMuI2FycmF5LnB1c2goUmVjeWNsZXIuZ2V0KHRoaXMuI3R5cGUpKTtcclxuICAgIC8vICAgcmV0dXJuIHRoaXMuI2FycmF5W3RoaXMuI2xlbmd0aCsrXTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwdWJsaWMgKltTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8VD4ge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy4jbGVuZ3RoOyBpKyspXHJcbiAgICAgICAgeWllbGQgdGhpcy4jYXJyYXlbaV07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFNvcnRlZChfc29ydDogKGE6IFQsIGI6IFQpID0+IG51bWJlcik6IFRbXSB7XHJcbiAgICAgIGxldCBzb3J0ZWQ6IFRbXSA9IHRoaXMuI2FycmF5LnNsaWNlKDAsIHRoaXMuI2xlbmd0aCk7XHJcbiAgICAgIHNvcnRlZC5zb3J0KF9zb3J0KTtcclxuICAgICAgcmV0dXJuIHNvcnRlZDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvL0Jhc2VjbGFzcyBmb3Ige0BsaW5rIFJlbmRlckluamVjdG9yQ29hdH0gYW5kIHtAbGluayBSZW5kZXJJbmplY3RvclRleHR1cmVdXVxyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvciB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBpbmplY3QoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbiwgX2luamVjdG9yOiB0eXBlb2YgUmVuZGVySW5qZWN0b3IpOiB2b2lkIHtcclxuICAgICAgbGV0IGluamVjdGlvbjogRnVuY3Rpb24gPSBSZWZsZWN0LmdldChfaW5qZWN0b3IsIFwiaW5qZWN0XCIgKyBfY29uc3RydWN0b3IubmFtZSk7XHJcbiAgICAgIGlmICghaW5qZWN0aW9uKSB7XHJcbiAgICAgICAgRGVidWcuZXJyb3IoXCJObyBpbmplY3Rpb24gZGVjb3JhdG9yIGRlZmluZWQgZm9yIFwiICsgX2NvbnN0cnVjdG9yLm5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcInVzZVJlbmRlckRhdGFcIiwge1xyXG4gICAgICAgIHZhbHVlOiBpbmplY3Rpb25cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLy9naXZlcyBXZWJHTCBCdWZmZXIgdGhlIGRhdGEgZnJvbSB0aGUge0BsaW5rIFNoYWRlcn1cclxuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIFwidXNlUHJvZ3JhbVwiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyLnVzZVByb2dyYW1cclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIFwiZGVsZXRlUHJvZ3JhbVwiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyLmRlbGV0ZVByb2dyYW1cclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIFwiY3JlYXRlUHJvZ3JhbVwiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyLmNyZWF0ZVByb2dyYW1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyB1c2VQcm9ncmFtKHRoaXM6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLnByb2dyYW0pXHJcbiAgICAgICAgdGhpcy5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKHRoaXMucHJvZ3JhbSkge1xyXG4gICAgICAgIGNyYzMuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMudW5pZm9ybXM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkNyZWF0ZSBzaGFkZXIgcHJvZ3JhbVwiLCB0aGlzLm5hbWUpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgbGV0IHByb2dyYW06IFdlYkdMUHJvZ3JhbSA9IGNyYzMuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCBzaGRWZXJ0ZXg6IFdlYkdMU2hhZGVyID0gY29tcGlsZVNoYWRlcih0aGlzLmdldFZlcnRleFNoYWRlclNvdXJjZSgpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIGxldCBzaGRGcmFnbWVudDogV2ViR0xTaGFkZXIgPSBjb21waWxlU2hhZGVyKHRoaXMuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIGNyYzMuYXR0YWNoU2hhZGVyKHByb2dyYW0sIFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFNoYWRlcj4oc2hkVmVydGV4KSk7XHJcbiAgICAgICAgY3JjMy5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMU2hhZGVyPihzaGRGcmFnbWVudCkpO1xyXG4gICAgICAgIGNyYzMubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgbGV0IGVycm9yOiBzdHJpbmcgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8c3RyaW5nPihjcmMzLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcclxuICAgICAgICBpZiAoZXJyb3IgIT09IFwiXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGxpbmtpbmcgU2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gZGV0ZWN0QXR0cmlidXRlcygpO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBkZXRlY3RVbmlmb3JtcygpO1xyXG5cclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoX3NoYWRlckNvZGU6IHN0cmluZywgX3NoYWRlclR5cGU6IEdMZW51bSk6IFdlYkdMU2hhZGVyIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IHdlYkdMU2hhZGVyOiBXZWJHTFNoYWRlciA9IGNyYzMuY3JlYXRlU2hhZGVyKF9zaGFkZXJUeXBlKTtcclxuICAgICAgICBjcmMzLnNoYWRlclNvdXJjZSh3ZWJHTFNoYWRlciwgX3NoYWRlckNvZGUpO1xyXG4gICAgICAgIGNyYzMuY29tcGlsZVNoYWRlcih3ZWJHTFNoYWRlcik7XHJcbiAgICAgICAgbGV0IGVycm9yOiBzdHJpbmcgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8c3RyaW5nPihjcmMzLmdldFNoYWRlckluZm9Mb2cod2ViR0xTaGFkZXIpKTtcclxuICAgICAgICBpZiAoZXJyb3IgIT09IFwiXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGNvbXBpbGluZyBzaGFkZXI6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGNvbXBpbGF0aW9uIGVycm9ycy5cclxuICAgICAgICBpZiAoIWNyYzMuZ2V0U2hhZGVyUGFyYW1ldGVyKHdlYkdMU2hhZGVyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgYWxlcnQoY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdlYkdMU2hhZGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGRldGVjdEF0dHJpYnV0ZXMoKTogeyBbbmFtZTogc3RyaW5nXTogbnVtYmVyIH0ge1xyXG4gICAgICAgIGxldCBkZXRlY3RlZEF0dHJpYnV0ZXM6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9ID0ge307XHJcbiAgICAgICAgbGV0IGF0dHJpYnV0ZUNvdW50OiBudW1iZXIgPSBjcmMzLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BQ1RJVkVfQVRUUklCVVRFUyk7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGF0dHJpYnV0ZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgIGxldCBhdHRyaWJ1dGVJbmZvOiBXZWJHTEFjdGl2ZUluZm8gPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xBY3RpdmVJbmZvPihjcmMzLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKSk7XHJcbiAgICAgICAgICBpZiAoIWF0dHJpYnV0ZUluZm8pIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZXRlY3RlZEF0dHJpYnV0ZXNbYXR0cmlidXRlSW5mby5uYW1lXSA9IGNyYzMuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlSW5mby5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRldGVjdGVkQXR0cmlidXRlcztcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBkZXRlY3RVbmlmb3JtcygpOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9IHtcclxuICAgICAgICBsZXQgZGV0ZWN0ZWRVbmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSA9IHt9O1xyXG4gICAgICAgIGxldCB1bmlmb3JtQ291bnQ6IG51bWJlciA9IGNyYzMuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFDVElWRV9VTklGT1JNUyk7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgaW5mbzogV2ViR0xBY3RpdmVJbmZvID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMQWN0aXZlSW5mbz4oY3JjMy5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpKTtcclxuICAgICAgICAgIGlmICghaW5mbykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRldGVjdGVkVW5pZm9ybXNbaW5mby5uYW1lXSA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFVuaWZvcm1Mb2NhdGlvbj4oY3JjMy5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgaW5mby5uYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXRlY3RlZFVuaWZvcm1zO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8vZ2l2ZXMgV2ViR0wgQnVmZmVyIHRoZSBkYXRhIGZyb20gdGhlIHtAbGluayBDb2F0fVxyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvYXQgZXh0ZW5kcyBSZW5kZXJJbmplY3RvciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgUmVuZGVySW5qZWN0b3IuaW5qZWN0KF9jb25zdHJ1Y3RvciwgUmVuZGVySW5qZWN0b3JDb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRDb2xvcmVkKHRoaXM6IENvYXRDb2xvcmVkLCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7XHJcbiAgICAgIGxldCB1bmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X3ZjdENvbG9yXCJdO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuTVVMVElQTFkodGhpcy5jb2xvciwgX2NtcE1hdGVyaWFsLmNsclByaW1hcnkpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTRmdih1bmlmb3JtLCBjb2xvci5nZXRBcnJheSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluamVjdENvYXRSZW1pc3NpdmUodGhpczogQ29hdFJlbWlzc2l2ZSwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJJbmplY3RvckNvYXQuaW5qZWN0Q29hdENvbG9yZWQuY2FsbCh0aGlzLCBfc2hhZGVyLCBfY21wTWF0ZXJpYWwpO1xyXG4gICAgICBsZXQgdW5pZm9ybTogV2ViR0xVbmlmb3JtTG9jYXRpb247XHJcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9mU3BlY3VsYXJcIl07XHJcbiAgICAgIFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKS51bmlmb3JtMWYodW5pZm9ybSwgdGhpcy5zcGVjdWxhcik7XHJcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9mRGlmZnVzZVwiXTtcclxuICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm0xZih1bmlmb3JtLCB0aGlzLmRpZmZ1c2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5qZWN0Q29hdFRleHR1cmVkKHRoaXM6IENvYXRUZXh0dXJlZCwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJJbmplY3RvckNvYXQuaW5qZWN0Q29hdENvbG9yZWQuY2FsbCh0aGlzLCBfc2hhZGVyLCBfY21wTWF0ZXJpYWwpO1xyXG5cclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIHRoaXMudGV4dHVyZS51c2VSZW5kZXJEYXRhKCk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFpKF9zaGFkZXIudW5pZm9ybXNbXCJ1X3RleHR1cmVcIl0sIDApO1xyXG4gICAgICBjcmMzLnVuaWZvcm1NYXRyaXgzZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4UGl2b3RcIl0sIGZhbHNlLCBfY21wTWF0ZXJpYWwubXR4UGl2b3QuZ2V0KCkpO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbmplY3RDb2F0UmVtaXNzaXZlVGV4dHVyZWQodGhpczogQ29hdFJlbWlzc2l2ZVRleHR1cmVkLCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlckluamVjdG9yQ29hdC5pbmplY3RDb2F0UmVtaXNzaXZlLmNhbGwodGhpcywgX3NoYWRlciwgX2NtcE1hdGVyaWFsKTtcclxuXHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICB0aGlzLnRleHR1cmUudXNlUmVuZGVyRGF0YSgpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xaShfc2hhZGVyLnVuaWZvcm1zW1widV90ZXh0dXJlXCJdLCAwKTtcclxuICAgICAgY3JjMy51bmlmb3JtTWF0cml4M2Z2KF9zaGFkZXIudW5pZm9ybXNbXCJ1X210eFBpdm90XCJdLCBmYWxzZSwgX2NtcE1hdGVyaWFsLm10eFBpdm90LmdldCgpKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvL0ZlZWRzIFdlYkdMIEJ1ZmZlcnMgd2l0aCBkYXRhIGNhbGN1bGF0ZWQgZnJvbSB0aGUge0BsaW5rIE1lc2hdXVxyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3Rvck1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcInVzZVJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2gudXNlUmVuZGVyQnVmZmVyc1xyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiZ2V0UmVuZGVyQnVmZmVyc1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC5nZXRSZW5kZXJCdWZmZXJzXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJkZWxldGVSZW5kZXJCdWZmZXJzXCIsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLmRlbGV0ZVJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBnZXRSZW5kZXJCdWZmZXJzKHRoaXM6IE1lc2gsIF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIpOiBSZW5kZXJCdWZmZXJzIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICB0aGlzLnJlbmRlck1lc2ggPSB0aGlzLnJlbmRlck1lc2ggfHwgbmV3IFJlbmRlck1lc2godGhpcyk7XHJcbiAgICAgIGlmIChfc2hhZGVyLmRlZmluZS5pbmNsdWRlcyhcIkZMQVRcIikpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJNZXNoLmZsYXQgPT0gbnVsbClcclxuICAgICAgICAgIHRoaXMucmVuZGVyTWVzaC5mbGF0ID0ge1xyXG4gICAgICAgICAgICB2ZXJ0aWNlczogY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2gudmVydGljZXNGbGF0KSxcclxuICAgICAgICAgICAgaW5kaWNlczogY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC5pbmRpY2VzRmxhdCksXHJcbiAgICAgICAgICAgIG5vcm1hbHM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLm5vcm1hbHNGbGF0KSxcclxuICAgICAgICAgICAgdGV4dHVyZVVWczogY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2gudGV4dHVyZVVWc0ZsYXQpLFxyXG4gICAgICAgICAgICBuSW5kaWNlczogdGhpcy5yZW5kZXJNZXNoLmluZGljZXNGbGF0Lmxlbmd0aFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLmZsYXQ7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyTWVzaC5zbW9vdGggPT0gbnVsbClcclxuICAgICAgICAgIHRoaXMucmVuZGVyTWVzaC5zbW9vdGggPSB7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC52ZXJ0aWNlcyksXHJcbiAgICAgICAgICAgIGluZGljZXM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2guaW5kaWNlcyksXHJcbiAgICAgICAgICAgIG5vcm1hbHM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLm5vcm1hbHNWZXJ0ZXgpLFxyXG4gICAgICAgICAgICB0ZXh0dXJlVVZzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC50ZXh0dXJlVVZzKSxcclxuICAgICAgICAgICAgbkluZGljZXM6IHRoaXMucmVuZGVyTWVzaC5pbmRpY2VzLmxlbmd0aFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLnNtb290aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKF90eXBlOiBHTGVudW0sIF9hcnJheTogRmxvYXQzMkFycmF5IHwgVWludDE2QXJyYXkpOiBXZWJHTEJ1ZmZlciB7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjogV2ViR0xCdWZmZXIgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xCdWZmZXI+KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihfdHlwZSwgYnVmZmVyKTtcclxuICAgICAgICBjcmMzLmJ1ZmZlckRhdGEoX3R5cGUsIF9hcnJheSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoLCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyLCBfbXR4TWVzaFRvV29ybGQ6IE1hdHJpeDR4NCwgX210eE1lc2hUb1ZpZXc6IE1hdHJpeDR4NCwgX2lkPzogbnVtYmVyKTogUmVuZGVyQnVmZmVycyB7XHJcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gdGhpcy5nZXRSZW5kZXJCdWZmZXJzKF9zaGFkZXIpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNldEJ1ZmZlcihfbmFtZTogc3RyaW5nLCBfYnVmZmVyOiBXZWJHTEJ1ZmZlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBhdHRyaWJ1dGU6IG51bWJlciA9IF9zaGFkZXIuYXR0cmlidXRlc1tfbmFtZV07XHJcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCBfYnVmZmVyKTtcclxuICAgICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZSk7XHJcbiAgICAgICAgUmVuZGVyV2ViR0wuc2V0QXR0cmlidXRlU3RydWN0dXJlKFxyXG4gICAgICAgICAgYXR0cmlidXRlLFxyXG4gICAgICAgICAgeyBzaXplOiAzLCBkYXRhVHlwZTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgbm9ybWFsaXplOiBmYWxzZSwgc3RyaWRlOiAwLCBvZmZzZXQ6IDAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB1bmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcclxuXHJcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhNZXNoVG9WaWV3XCJdO1xyXG4gICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybSwgZmFsc2UsIF9tdHhNZXNoVG9WaWV3LmdldCgpKTtcclxuXHJcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhNZXNoVG9Xb3JsZFwiXTtcclxuICAgICAgaWYgKHVuaWZvcm0pXHJcbiAgICAgICAgY3JjMy51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm0sIGZhbHNlLCBfbXR4TWVzaFRvV29ybGQuZ2V0KCkpO1xyXG5cclxuICAgICAgdW5pZm9ybSA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X210eE5vcm1hbE1lc2hUb1dvcmxkXCJdO1xyXG4gICAgICBpZiAodW5pZm9ybSkge1xyXG4gICAgICAgIGxldCBub3JtYWxNYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5UUkFOU1BPU0UoTWF0cml4NHg0LklOVkVSU0lPTihfbXR4TWVzaFRvV29ybGQpKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybSwgZmFsc2UsIG5vcm1hbE1hdHJpeC5nZXQoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldEJ1ZmZlcihcImFfdmN0UG9zaXRpb25cIiwgcmVuZGVyQnVmZmVycy52ZXJ0aWNlcyk7XHJcbiAgICAgIHNldEJ1ZmZlcihcImFfdmN0Tm9ybWFsXCIsIHJlbmRlckJ1ZmZlcnMubm9ybWFscyk7XHJcblxyXG5cclxuICAgICAgLy8gZmVlZCBpbiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGlmIHNoYWRlciBhY2NlcHRzIGFfdmN0VGV4dHVyZVxyXG4gICAgICBsZXQgYXR0cmlidXRlOiBudW1iZXIgPSBfc2hhZGVyLmF0dHJpYnV0ZXNbXCJhX3ZjdFRleHR1cmVcIl07XHJcbiAgICAgIGlmIChhdHRyaWJ1dGUpIHtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHJlbmRlckJ1ZmZlcnMudGV4dHVyZVVWcyk7XHJcbiAgICAgICAgY3JjMy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGUpOyAvLyBlbmFibGUgdGhlIGJ1ZmZlclxyXG4gICAgICAgIGNyYzMudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGUsIDIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmVlZCBpbiBhbiBpZCBvZiB0aGUgbm9kZSBpZiBzaGFkZXIgYWNjZXB0cyB1X2lkLiBVc2VkIGZvciBwaWNraW5nXHJcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9pZFwiXTtcclxuICAgICAgaWYgKHVuaWZvcm0pXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm0xaSh1bmlmb3JtLCBfaWQpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHJlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XHJcbiAgICAgIHJldHVybiByZW5kZXJCdWZmZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVsZXRlUmVuZGVyQnVmZmVycyhfcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyk6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKF9yZW5kZXJCdWZmZXJzKSB7XHJcbiAgICAgICAgLy8gVE9ETzogY2xlYW51cCBhbGwgYnVmZmVycywgZmxhdC9ub3JtYWxzIGlzIG1pc3NpbmcuLi5cclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIGNyYzMuZGVsZXRlQnVmZmVyKF9yZW5kZXJCdWZmZXJzLnZlcnRpY2VzKTtcclxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcihfcmVuZGVyQnVmZmVycy50ZXh0dXJlVVZzKTtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMuaW5kaWNlcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFJlY3ljYWJsZSB7XHJcbiAgICByZWN5Y2xlKCk6IHZvaWQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEtlZXBzIGEgZGVwb3Qgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgZm9yIHJldXNlLCBzb3J0ZWQgYnkgdHlwZS4gIFxyXG4gICAqIFVzaW5nIHtAbGluayBSZWN5Y2xlcn0gcmVkdWNlcyBsb2FkIG9uIHRoZSBjYXJiYWdlIGNvbGxlY3RvciBhbmQgdGh1cyBzdXBwb3J0cyBzbW9vdGggcGVyZm9ybWFuY2UuXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZWN5Y2xlclxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWN5Y2xlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZXBvdDogeyBbdHlwZTogc3RyaW5nXTogT2JqZWN0W10gfSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBhbiBvYmplY3Qgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIGZyb20gdGhlIGRlcG90LCBjYWxscyBpdHMgcmVjeWNsZS1tZXRob2QgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBJZiB0aGUgZGVwb3QgZm9yIHRoYXQgdHlwZSBpcyBlbXB0eSBpdCByZXR1cm5zIGEgbmV3IG9iamVjdCBvZiB0aGUgcmVxdWVzdGVkIHR5cGVcclxuICAgICAqIEBwYXJhbSBfVCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQ8VCBleHRlbmRzIFJlY3ljYWJsZSB8IFJlY3ljYWJsZUFycmF5PFQ+PihfVDogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgbGV0IGtleTogc3RyaW5nID0gX1QubmFtZTtcclxuICAgICAgbGV0IGluc3RhbmNlczogT2JqZWN0W10gPSBSZWN5Y2xlci5kZXBvdFtrZXldO1xyXG4gICAgICBpZiAoaW5zdGFuY2VzICYmIGluc3RhbmNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlOiBUID0gPFQ+aW5zdGFuY2VzLnBvcCgpO1xyXG4gICAgICAgIGluc3RhbmNlLnJlY3ljbGUoKTtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBuZXcgX1QoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSBpbiB0aGUgZGVwb3QsIGJ1dCBkb2VzIG5vdCByZW1vdmUgaXQgdGhlcmUuIFxyXG4gICAgICogSWYgbm8gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSB3YXMgaW4gdGhlIGRlcG90LCBvbmUgaXMgY3JlYXRlZCwgc3RvcmVkIGFuZCBib3Jyb3dlZC5cclxuICAgICAqIEZvciBzaG9ydCB0ZXJtIHVzYWdlIG9mIG9iamVjdHMgaW4gYSBsb2NhbCBzY29wZSwgd2hlbiB0aGVyZSB3aWxsIGJlIG5vIG90aGVyIGNhbGwgdG8gUmVjeWNsZXIuZ2V0IG9yIC5ib3Jyb3chXHJcbiAgICAgKiBAcGFyYW0gX1QgVGhlIGNsYXNzIGlkZW50aWZpZXIgb2YgdGhlIGRlc2lyZWQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYm9ycm93PFQgZXh0ZW5kcyBSZWN5Y2FibGU+KF9UOiBuZXcgKCkgPT4gVCk6IFQge1xyXG4gICAgICBsZXQgdDogVDtcclxuICAgICAgbGV0IGtleTogc3RyaW5nID0gX1QubmFtZTtcclxuICAgICAgbGV0IGluc3RhbmNlczogT2JqZWN0W10gPSBSZWN5Y2xlci5kZXBvdFtrZXldO1xyXG4gICAgICBpZiAoIWluc3RhbmNlcyB8fCBpbnN0YW5jZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICB0ID0gbmV3IF9UKCk7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUodCk7XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGluc3RhbmNlOiBUID0gPFQ+aW5zdGFuY2VzWzBdO1xyXG4gICAgICBpbnN0YW5jZS5yZWN5Y2xlKCk7XHJcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyB0aGUgb2JqZWN0IGluIHRoZSBkZXBvdCBmb3IgbGF0ZXIgcmVjeWNsaW5nLiBVc2VycyBhcmUgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIGluIG9iamVjdHMgdGhhdCBhcmUgYWJvdXQgdG8gbG9vc2Ugc2NvcGUgYW5kIGFyZSBub3QgcmVmZXJlbmNlZCBieSBhbnkgb3RoZXJcclxuICAgICAqIEBwYXJhbSBfaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdG9yZShfaW5zdGFuY2U6IE9iamVjdCk6IHZvaWQge1xyXG4gICAgICBsZXQga2V5OiBzdHJpbmcgPSBfaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgLy9EZWJ1Zy5sb2coa2V5KTtcclxuICAgICAgbGV0IGluc3RhbmNlczogT2JqZWN0W10gPSBSZWN5Y2xlci5kZXBvdFtrZXldIHx8IFtdO1xyXG4gICAgICBpbnN0YW5jZXMucHVzaChfaW5zdGFuY2UpO1xyXG4gICAgICBSZWN5Y2xlci5kZXBvdFtrZXldID0gaW5zdGFuY2VzO1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coYE9iamVjdE1hbmFnZXIuZGVwb3RbJHtrZXl9XTogJHtPYmplY3RNYW5hZ2VyLmRlcG90W2tleV0ubGVuZ3RofWApO1xyXG4gICAgICAvL0RlYnVnLmxvZyh0aGlzLmRlcG90KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtcHR5cyB0aGUgZGVwb3Qgb2YgYSBnaXZlbiB0eXBlLCBsZWF2aW5nIHRoZSBvYmplY3RzIGZvciB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXHJcbiAgICAgKiBAcGFyYW0gX1RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkdW1wPFQ+KF9UOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xyXG4gICAgICBsZXQga2V5OiBzdHJpbmcgPSBfVC5uYW1lO1xyXG4gICAgICBSZWN5Y2xlci5kZXBvdFtrZXldID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbXB0eXMgYWxsIGRlcG90cywgbGVhdmluZyBhbGwgb2JqZWN0cyB0byB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHVtcEFsbCgpOiB2b2lkIHtcclxuICAgICAgUmVjeWNsZXIuZGVwb3QgPSB7fTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgdHdvZGltZW5zaW9uYWwgdmVjdG9yIGNvbXByaXNlZCBvZiB0aGUgY29tcG9uZW50cyB4IGFuZCB5XHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgICAreVxyXG4gICAqICAgICAgICAgICAgIHxfXyAreFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVjdG9yMiBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KFtfeCwgX3ldKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gU3RhdGljXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoMCwgMClgLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoMCwgMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaRVJPKCk6IFZlY3RvcjIge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoMCwgMCk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKF9zY2FsZSwgX3NjYWxlKWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIHRoZSBzY2FsZSBvZiB0aGUgdmVjdG9yLiBEZWZhdWx0OiAxXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT05FKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoX3NjYWxlLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMigwLCB5KWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBudW1iZXIgdG8gd3JpdGUgaW4gdGhlIHkgY29vcmRpbmF0ZS4gRGVmYXVsdDogMVxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoMCwgX3NjYWxlKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFkoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgdmVjdG9yLnNldCgwLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMih4LCAwKWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBudW1iZXIgdG8gd3JpdGUgaW4gdGhlIHggY29vcmRpbmF0ZS4gRGVmYXVsdDogMVxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoX3NjYWxlLCAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFgoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgdmVjdG9yLnNldChfc2NhbGUsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNGT1JNQVRJT04oX3ZlY3RvcjogVmVjdG9yMiwgX210eFRyYW5zZm9ybTogTWF0cml4M3gzLCBfaW5jbHVkZVRyYW5zbGF0aW9uOiBib29sZWFuID0gdHJ1ZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gX210eFRyYW5zZm9ybS5nZXQoKTtcclxuICAgICAgbGV0IFt4LCB5XSA9IF92ZWN0b3IuZ2V0KCk7XHJcbiAgICAgIHJlc3VsdC54ID0gbVswXSAqIHggKyBtWzNdICogeTtcclxuICAgICAgcmVzdWx0LnkgPSBtWzFdICogeCArIG1bNF0gKiB5O1xyXG5cclxuICAgICAgaWYgKF9pbmNsdWRlVHJhbnNsYXRpb24pIHtcclxuICAgICAgICByZXN1bHQuYWRkKF9tdHhUcmFuc2Zvcm0udHJhbnNsYXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyBhIGdpdmVuIHZlY3RvciB0byB0aGUgZ2l2ZW4gbGVuZ3RoIHdpdGhvdXQgZWRpdGluZyB0aGUgb3JpZ2luYWwgdmVjdG9yLlxyXG4gICAgICogQHBhcmFtIF92ZWN0b3IgdGhlIHZlY3RvciB0byBub3JtYWxpemVcclxuICAgICAqIEBwYXJhbSBfbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIGRlZmF1bHRzIHRvIDFcclxuICAgICAqIEByZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gbGVuZ3RoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfdmVjdG9yOiBWZWN0b3IyLCBfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgW3gsIHldID0gX3ZlY3Rvci5kYXRhO1xyXG4gICAgICAgIGxldCBmYWN0b3I6IG51bWJlciA9IF9sZW5ndGggLyBNYXRoLmh5cG90KHgsIHkpO1xyXG4gICAgICAgIHZlY3Rvci5zZXQoX3ZlY3Rvci54ICogZmFjdG9yLCBfdmVjdG9yLnkgKiBmYWN0b3IpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKF9lcnJvcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gc2NhbGluZyBmYWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMRShfdmVjdG9yOiBWZWN0b3IyLCBfc2NhbGU6IG51bWJlcik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF92ZWN0b3IueCAqIF9zY2FsZSwgX3ZlY3Rvci55ICogX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdGluZyB2ZWN0b3IgYXR0YWluZWQgYnkgYWRkaXRpb24gb2YgYWxsIGdpdmVuIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU1VNKC4uLl92ZWN0b3JzOiBWZWN0b3IyW10pOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgZm9yIChsZXQgdmVjdG9yIG9mIF92ZWN0b3JzKVxyXG4gICAgICAgIHJlc3VsdC5zZXQocmVzdWx0LnggKyB2ZWN0b3IueCwgcmVzdWx0LnkgKyB2ZWN0b3IueSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHR3byB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERJRkZFUkVOQ0UoX21pbnVlbmQ6IFZlY3RvcjIsIF9zdWJ0cmFoZW5kOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoX21pbnVlbmQueCAtIF9zdWJ0cmFoZW5kLngsIF9taW51ZW5kLnkgLSBfc3VidHJhaGVuZC55KTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBkb3Rwcm9kdWN0IG9mIDIgdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBET1QoX2E6IFZlY3RvcjIsIF9iOiBWZWN0b3IyKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHNjYWxhclByb2R1Y3Q6IG51bWJlciA9IF9hLnggKiBfYi54ICsgX2EueSAqIF9iLnk7XHJcbiAgICAgIHJldHVybiBzY2FsYXJQcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gVmVjdG9ycy4gRHVlIHRvIHRoZW0gYmVpbmcgb25seSAyIERpbWVuc2lvbmFsLCB0aGUgcmVzdWx0IGlzIGEgc2luZ2xlIG51bWJlcixcclxuICAgICAqIHdoaWNoIGltcGxpY2l0bHkgaXMgb24gdGhlIFogYXhpcy4gSXQgaXMgYWxzbyB0aGUgc2lnbmVkIG1hZ25pdHVkZSBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICogQHBhcmFtIF9hIFZlY3RvciB0byBjb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IG9uXHJcbiAgICAgKiBAcGFyYW0gX2IgVmVjdG9yIHRvIGNvbXB1dGUgdGhlIGNyb3NzIHByb2R1Y3Qgd2l0aFxyXG4gICAgICogQHJldHVybnMgQSBudW1iZXIgcmVwcmVzZW50aW5nIHJlc3VsdCBvZiB0aGUgY3Jvc3MgcHJvZHVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBDUk9TUyhfYTogVmVjdG9yMiwgX2I6IFZlY3RvcjIpOiBudW1iZXIge1xyXG4gICAgICBsZXQgY3Jvc3NQcm9kdWN0OiBudW1iZXIgPSBfYS54ICogX2IueSAtIF9hLnkgKiBfYi54O1xyXG4gICAgICByZXR1cm4gY3Jvc3NQcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgb3J0aG9nb25hbCB2ZWN0b3IgdG8gdGhlIGdpdmVuIHZlY3Rvci4gUm90YXRlcyBjb3VudGVyY2xvY2t3aXNlIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqIOKGkSA9PiDihpAgPT4g4oaTID0+IOKGkiA9PiDihpFcclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIF92ZWN0b3IgVmVjdG9yIHRvIGdldCB0aGUgb3J0aG9nb25hbCBlcXVpdmFsZW50IG9mXHJcbiAgICAgKiBAcGFyYW0gX2Nsb2Nrd2lzZSBTaG91bGQgdGhlIHJvdGF0aW9uIGJlIGNsb2Nrd2lzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGNvdW50ZXJjbG9ja3dpc2U/IGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlY3RvciB0aGF0IGlzIG9ydGhvZ29uYWwgdG8gYW5kIGhhcyB0aGUgc2FtZSBtYWduaXR1ZGUgYXMgdGhlIGdpdmVuIFZlY3Rvci4gIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9SVEhPR09OQUwoX3ZlY3RvcjogVmVjdG9yMiwgX2Nsb2Nrd2lzZTogYm9vbGVhbiA9IGZhbHNlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIGlmIChfY2xvY2t3aXNlKVxyXG4gICAgICAgIHJlc3VsdC5zZXQoX3ZlY3Rvci55LCAtX3ZlY3Rvci54KTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJlc3VsdC5zZXQoLV92ZWN0b3IueSwgX3ZlY3Rvci54KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjYXJ0ZXNpYW4gdmVjdG9yIGZyb20gcG9sYXIgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHRU8oX2FuZ2xlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIGxldCBnZW86IEdlbzIgPSBSZWN5Y2xlci5nZXQoR2VvMik7XHJcbiAgICAgIGdlby5zZXQoX2FuZ2xlLCBfbWFnbml0dWRlKTtcclxuICAgICAgdmVjdG9yLmdlbyA9IGdlbztcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZ2VvKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBBY2Nlc3NvcnNcclxuICAgIGdldCB4KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB4KF94OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzBdID0gX3g7XHJcbiAgICB9XHJcbiAgICBzZXQgeShfeTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVsxXSA9IF95O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5oeXBvdCguLi50aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciB3aXRob3V0IGNhbGN1bGF0aW5nIGEgc3F1YXJlIHJvb3QuIEZhc3RlciBmb3Igc2ltcGxlIHByb3hpbWl0eSBldmFsdWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gVmVjdG9yMi5ET1QodGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBBIGRlZXAgY29weSBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICogVE9ETzogcmVuYW1lIHRoaXMgY2xvbmUgYW5kIGNyZWF0ZSBhIG5ldyBtZXRob2QgY29weSwgd2hpY2ggY29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIHZlY3RvciBnaXZlbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjbG9uZSgpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IGNsb25lOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICBjbG9uZS5kYXRhLnNldCh0aGlzLmRhdGEpO1xyXG4gICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9sYXIgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBnZW8oKTogR2VvMiB7XHJcbiAgICAgIGxldCBnZW86IEdlbzIgPSBSZWN5Y2xlci5nZXQoR2VvMik7XHJcbiAgICAgIGdlby5tYWduaXR1ZGUgPSB0aGlzLm1hZ25pdHVkZTtcclxuXHJcbiAgICAgIGlmIChnZW8ubWFnbml0dWRlID09PSAwKVxyXG4gICAgICAgIHJldHVybiBnZW87XHJcblxyXG4gICAgICBnZW8uYW5nbGUgPSAxODAgKiBNYXRoLmF0YW4yKHRoaXMueSAvIGdlby5tYWduaXR1ZGUsIHRoaXMueCAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgcmV0dXJuIGdlbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdCB0aGUgY2FydGVzaWFuIHZhbHVlcyBvZiB0aGlzIHZlY3RvciB0byByZXByZXNlbnQgdGhlIGdpdmVuIGFzIHBvbGFyIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgZ2VvKF9nZW86IEdlbzIpIHtcclxuICAgICAgdGhpcy5zZXQoX2dlby5tYWduaXR1ZGUsIDApO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybShNYXRyaXgzeDMuUk9UQVRJT04oX2dlby5hbmdsZSkpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBcclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFswLCAwXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IgYXJlIHRvIGJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsIHdpdGhpbiB0aGUgZ2l2ZW4gdG9sZXJhbmNlXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0b2xlcmFuY2UgYXMgY3JpdGVyaXVtIGZvciB0aGUgZGlmZmVyZW5jZSBpcyBhcHByb3ByaWF0ZSB3aXRoIHZlcnkgbGFyZ2UgY29vcmRpbmF0ZSB2YWx1ZXMgb3IgaWYgX3RvbGVyYW5jZSBzaG91bGQgYmUgbXVsdGlwbGllZCBieSBjb29yZGluYXRlIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlcXVhbHMoX2NvbXBhcmU6IFZlY3RvcjIsIF90b2xlcmFuY2U6IG51bWJlciA9IE51bWJlci5FUFNJTE9OKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSBfY29tcGFyZS54KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueSAtIF9jb21wYXJlLnkpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciB0byB0aGUgZXhlY3V0aW5nIHZlY3RvciwgY2hhbmdpbmcgdGhlIGV4ZWN1dG9yLlxyXG4gICAgICogQHBhcmFtIF9hZGRlbmQgVGhlIHZlY3RvciB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGQoX2FkZGVuZDogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFtfYWRkZW5kLnggKyB0aGlzLngsIF9hZGRlbmQueSArIHRoaXMueV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGUgZXhlY3V0aW5nIHZlY3RvciwgY2hhbmdpbmcgdGhlIGV4ZWN1dG9yLlxyXG4gICAgICogQHBhcmFtIF9zdWJ0cmFoZW5kIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJ0cmFjdChfc3VidHJhaGVuZDogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLnggLSBfc3VidHJhaGVuZC54LCB0aGlzLnkgLSBfc3VidHJhaGVuZC55XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhlIFZlY3RvciBieSB0aGUgZ2l2ZW4gX3NjYWxhci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9zY2FsYXI6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFtfc2NhbGFyICogdGhpcy54LCBfc2NhbGFyICogdGhpcy55XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoaXMgdG8gdGhlIGdpdmVuIGxlbmd0aCwgMSBieSBkZWZhdWx0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWxpemUoX2xlbmd0aDogbnVtYmVyID0gMSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBWZWN0b3IyLk5PUk1BTElaQVRJT04odGhpcywgX2xlbmd0aCkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGFbMF0gPSBfeDtcclxuICAgICAgdGhpcy5kYXRhWzFdID0gX3k7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgZGF0YSBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm06IE1hdHJpeDN4MywgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gVmVjdG9yMi5UUkFOU0ZPUk1BVElPTih0aGlzLCBfbXR4VHJhbnNmb3JtLCBfaW5jbHVkZVRyYW5zbGF0aW9uKS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtaW5pbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBkaW1lbnNpb24sIG1vdmVzIHRoZSBjb21wb25lbnQgdG8gdGhlIG1heGltdW0gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWF4KF9jb21wYXJlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgX2NvbXBhcmUueCk7XHJcbiAgICAgIHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgX2NvbXBhcmUueSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHotY29tcG9uZW50IG9mIHRoZSBnaXZlbiBtYWduaXR1ZGUgKGRlZmF1bHQ9MCkgdG8gdGhlIHZlY3RvciBhbmQgcmV0dXJucyBhIG5ldyBWZWN0b3IzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjMoX3o6IG51bWJlciA9IDApOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCwgdGhpcy55LCBfeik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IGAoJHt0aGlzLngudG9QcmVjaXNpb24oNSl9LCAke3RoaXMueS50b1ByZWNpc2lvbig1KX0pYDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYHsgXCJyXCI6ICR7dGhpcy5yfSwgXCJnXCI6ICR7dGhpcy5nfSwgXCJiXCI6ICR7dGhpcy5ifSwgXCJhXCI6ICR7dGhpcy5hfX1gOyB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnh9LCAke3RoaXMueX1dYDsgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxWZWN0b3IyPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9zZXJpYWxpemF0aW9uKSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgW3RoaXMueCwgdGhpcy55XSA9IEpTT04ucGFyc2UoPHN0cmluZz48dW5rbm93bj5fc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHg6IHRoaXMuZGF0YVswXSwgeTogdGhpcy5kYXRhWzFdXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vUmVjeWNsZS9SZWN5Y2xlci50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiVmVjdG9yMi50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgdGhlIG9yaWdpbiBvZiBhIHJlY3RhbmdsZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIE9SSUdJTjJEIHtcclxuICAgIFRPUExFRlQgPSAweDAwLFxyXG4gICAgVE9QQ0VOVEVSID0gMHgwMSxcclxuICAgIFRPUFJJR0hUID0gMHgwMixcclxuICAgIENFTlRFUkxFRlQgPSAweDEwLFxyXG4gICAgQ0VOVEVSID0gMHgxMSxcclxuICAgIENFTlRFUlJJR0hUID0gMHgxMixcclxuICAgIEJPVFRPTUxFRlQgPSAweDIwLFxyXG4gICAgQk9UVE9NQ0VOVEVSID0gMHgyMSxcclxuICAgIEJPVFRPTVJJR0hUID0gMHgyMlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIHJlY3RhbmdsZSB3aXRoIHBvc2l0aW9uIGFuZCBzaXplIGFuZCBhZGQgY29tZm9ydGFibGUgbWV0aG9kcyB0byBpdFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFJlY3ljYWJsZSB7XHJcbiAgICBwdWJsaWMgcG9zaXRpb246IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICBwdWJsaWMgc2l6ZTogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25BbmRTaXplKF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0LCBfb3JpZ2luKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIGNyZWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdFVChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKTogUmVjdGFuZ2xlIHtcclxuICAgICAgbGV0IHJlY3Q6IFJlY3RhbmdsZSA9IFJlY3ljbGVyLmdldChSZWN0YW5nbGUpO1xyXG4gICAgICByZWN0LnNldFBvc2l0aW9uQW5kU2l6ZShfeCwgX3ksIF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB4KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpemUueDtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2l6ZS55O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBsZWZ0bW9zdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2Ygd2lkdGhcclxuICAgICAqL1xyXG4gICAgZ2V0IGxlZnQoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS54ID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB0b3Btb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZ2V0IHRvcCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi55ICsgdGhpcy5zaXplLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHJpZ2h0bW9zdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2Ygd2lkdGhcclxuICAgICAqL1xyXG4gICAgZ2V0IHJpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnNpemUueCA+IDApXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBvc2l0aW9uLnggKyB0aGlzLnNpemUueCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbG93ZXN0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi55ICsgdGhpcy5zaXplLnkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB4KF94OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi54ID0gX3g7XHJcbiAgICB9XHJcbiAgICBzZXQgeShfeTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IF95O1xyXG4gICAgfVxyXG4gICAgc2V0IHdpZHRoKF93aWR0aDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS54ID0gX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGhlaWdodChfaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnkgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0IGxlZnQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnggPSB0aGlzLnJpZ2h0IC0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnggPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdG9wKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5ib3R0b20gLSBfdmFsdWU7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCByaWdodChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueCA9IHRoaXMucG9zaXRpb24ueCArIF92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBib3R0b20oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnkgPSB0aGlzLnBvc2l0aW9uLnkgKyBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkFuZFNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29weShfcmVjdDogUmVjdGFuZ2xlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25BbmRTaXplKF9yZWN0LngsIF9yZWN0LnksIF9yZWN0LndpZHRoLCBfcmVjdC5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHJlY3RhbmdsZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBvc2l0aW9uQW5kU2l6ZShfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2l6ZS5zZXQoX3dpZHRoLCBfaGVpZ2h0KTtcclxuICAgICAgc3dpdGNoIChfb3JpZ2luICYgMHgwMykge1xyXG4gICAgICAgIGNhc2UgMHgwMDogdGhpcy5wb3NpdGlvbi54ID0gX3g7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgwMTogdGhpcy5wb3NpdGlvbi54ID0gX3ggLSBfd2lkdGggLyAyOyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MDI6IHRoaXMucG9zaXRpb24ueCA9IF94IC0gX3dpZHRoOyBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKF9vcmlnaW4gJiAweDMwKSB7XHJcbiAgICAgICAgY2FzZSAweDAwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDEwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeSAtIF9oZWlnaHQgLyAyOyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MjA6IHRoaXMucG9zaXRpb24ueSA9IF95IC0gX2hlaWdodDsgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcG9pbnRUb1JlY3QoX3BvaW50OiBWZWN0b3IyLCBfdGFyZ2V0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IF9wb2ludC5jbG9uZTtcclxuICAgICAgcmVzdWx0LnN1YnRyYWN0KHRoaXMucG9zaXRpb24pO1xyXG4gICAgICByZXN1bHQueCAqPSBfdGFyZ2V0LndpZHRoIC8gdGhpcy53aWR0aDtcclxuICAgICAgcmVzdWx0LnkgKj0gX3RhcmdldC5oZWlnaHQgLyB0aGlzLmhlaWdodDtcclxuICAgICAgcmVzdWx0LmFkZChfdGFyZ2V0LnBvc2l0aW9uKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIG9mIHRoaXMgcmVjdGFuZ2xlIG9yIG9uIHRoZSBib3JkZXJcclxuICAgICAqIEBwYXJhbSBfcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlKF9wb2ludDogVmVjdG9yMik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKF9wb2ludC54ID49IHRoaXMubGVmdCAmJiBfcG9pbnQueCA8PSB0aGlzLnJpZ2h0ICYmIF9wb2ludC55ID49IHRoaXMudG9wICYmIF9wb2ludC55IDw9IHRoaXMuYm90dG9tKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlY3RhbmdsZSBjb2xsaWRlcyB3aXRoIHRoZSByZWN0YW5nbGUgZ2l2ZW5cclxuICAgICAqIEBwYXJhbSBfcmVjdCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbGxpZGVzKF9yZWN0OiBSZWN0YW5nbGUpOiBib29sZWFuIHtcclxuICAgICAgaWYgKHRoaXMubGVmdCA+IF9yZWN0LnJpZ2h0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnJpZ2h0IDwgX3JlY3QubGVmdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy50b3AgPiBfcmVjdC5ib3R0b20pIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMuYm90dG9tIDwgX3JlY3QudG9wKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVjdGFuZ2xlIGNyZWF0ZWQgYnkgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcmVjdGFuZ2xlIG9yIG51bGwsIGlmIHRoZXkgZG9uJ3QgY29sbGlkZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SW50ZXJzZWN0aW9uKF9yZWN0OiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xyXG4gICAgICBpZiAoIXRoaXMuY29sbGlkZXMoX3JlY3QpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgbGV0IGludGVyc2VjdGlvbjogUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgpO1xyXG4gICAgICBpbnRlcnNlY3Rpb24ueCA9IE1hdGgubWF4KHRoaXMubGVmdCwgX3JlY3QubGVmdCk7XHJcbiAgICAgIGludGVyc2VjdGlvbi55ID0gTWF0aC5tYXgodGhpcy50b3AsIF9yZWN0LnRvcCk7XHJcbiAgICAgIGludGVyc2VjdGlvbi53aWR0aCA9IE1hdGgubWluKHRoaXMucmlnaHQsIF9yZWN0LnJpZ2h0KSAtIGludGVyc2VjdGlvbi54O1xyXG4gICAgICBpbnRlcnNlY3Rpb24uaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5ib3R0b20sIF9yZWN0LmJvdHRvbSkgLSBpbnRlcnNlY3Rpb24ueTtcclxuXHJcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAqIFJldHVybnMgdGhlIHJlY3RhbmdsZSBjcmVhdGVkIGJ5IHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHJlY3RhbmdsZSBvciBudWxsLCBpZiB0aGV5IGRvbid0IGNvbGxpZGVcclxuICovXHJcbiAgICBwdWJsaWMgY292ZXJzKF9yZWN0OiBSZWN0YW5nbGUpOiBib29sZWFuIHtcclxuICAgICAgaWYgKHRoaXMubGVmdCA+IF9yZWN0LmxlZnQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMucmlnaHQgPCBfcmVjdC5yaWdodCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy50b3AgPiBfcmVjdC50b3ApIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMuYm90dG9tIDwgX3JlY3QuYm90dG9tKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYMaSLlJlY3RhbmdsZShwb3NpdGlvbjoke3RoaXMucG9zaXRpb24udG9TdHJpbmcoKX0sIHNpemU6JHt0aGlzLnNpemUudG9TdHJpbmcoKX1gO1xyXG4gICAgICByZXN1bHQgKz0gYCwgbGVmdDoke3RoaXMubGVmdC50b1ByZWNpc2lvbig1KX0sIHRvcDoke3RoaXMudG9wLnRvUHJlY2lzaW9uKDUpfSwgcmlnaHQ6JHt0aGlzLnJpZ2h0LnRvUHJlY2lzaW9uKDUpfSwgYm90dG9tOiR7dGhpcy5ib3R0b20udG9QcmVjaXNpb24oNSl9YDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qICovIH1cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJJbmplY3Rvci50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JTaGFkZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yQ29hdC50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JNZXNoLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9NYXRoL1JlY3RhbmdsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBkZWNsYXJlIGxldCBmdWRnZUNvbmZpZzogR2VuZXJhbDtcclxuXHJcbiAgZXhwb3J0IHR5cGUgUmVuZGVyVGV4dHVyZSA9IFdlYkdMVGV4dHVyZTtcclxuXHJcbiAgZXhwb3J0IGVudW0gQkxFTkQge1xyXG4gICAgT1BBUVVFLCBUUkFOU1BBUkVOVCwgUEFSVElDTEVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQnVmZmVyU3BlY2lmaWNhdGlvbiB7XHJcbiAgICBzaXplOiBudW1iZXI7ICAgLy8gVGhlIHNpemUgb2YgdGhlIGRhdGFzYW1wbGUuXHJcbiAgICBkYXRhVHlwZTogbnVtYmVyOyAvLyBUaGUgZGF0YXR5cGUgb2YgdGhlIHNhbXBsZSAoZS5nLiBnbC5GTE9BVCwgZ2wuQllURSwgZXRjLilcclxuICAgIG5vcm1hbGl6ZTogYm9vbGVhbjsgLy8gRmxhZyB0byBub3JtYWxpemUgdGhlIGRhdGEuXHJcbiAgICBzdHJpZGU6IG51bWJlcjsgLy8gTnVtYmVyIG9mIGluZGljZXMgdGhhdCB3aWxsIGJlIHNraXBwZWQgZWFjaCBpdGVyYXRpb24uXHJcbiAgICBvZmZzZXQ6IG51bWJlcjsgLy8gSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmVnaW4gd2l0aC5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIFJlbmRlck1hbmFnZXIsIGhhbmRsaW5nIHRoZSBjb25uZWN0aW9uIHRvIHRoZSByZW5kZXJpbmcgc3lzdGVtLCBpbiB0aGlzIGNhc2UgV2ViR0wuXHJcbiAgICogTWV0aG9kcyBhbmQgYXR0cmlidXRlcyBvZiB0aGlzIGNsYXNzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LCBvbmx5IHRocm91Z2gge0BsaW5rIFJlbmRlcn1cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyV2ViR0wgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5pbml0aWFsaXplKCk7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIMaScGlja2VkOiBQaWNrW107XHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWN0UmVuZGVyOiBSZWN0YW5nbGUgPSBSZW5kZXJXZWJHTC5nZXRDYW52YXNSZWN0KCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBzaXplUGljazogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgb2Zmc2NyZWVuLWNhbnZhcywgcmVuZGVyaW5nY29udGV4dCBhbmQgaGFyZHdhcmUgdmlld3BvcnQuIENhbGwgb25jZSBiZWZvcmUgY3JlYXRpbmcgYW55IHJlc291cmNlcyBsaWtlIG1lc2hlcyBvciBzaGFkZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5pdGlhbGl6ZShfYW50aWFsaWFzPzogYm9vbGVhbiwgX2FscGhhPzogYm9vbGVhbik6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQge1xyXG4gICAgICBmdWRnZUNvbmZpZyA9IGZ1ZGdlQ29uZmlnIHx8IHt9O1xyXG4gICAgICBsZXQgY29udGV4dEF0dHJpYnV0ZXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgYWxwaGE6IChfYWxwaGEgIT0gdW5kZWZpbmVkKSA/IF9hbHBoYSA6IGZ1ZGdlQ29uZmlnLmFscGhhIHx8IGZhbHNlLFxyXG4gICAgICAgIGFudGlhbGlhczogKF9hbnRpYWxpYXMgIT0gdW5kZWZpbmVkKSA/IF9hbnRpYWxpYXMgOiBmdWRnZUNvbmZpZy5hbnRpYWxpYXMgfHwgZmFsc2UsXHJcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZVxyXG4gICAgICB9O1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkluaXRpYWxpemUgUmVuZGVyV2ViR0xcIiwgY29udGV4dEF0dHJpYnV0ZXMpO1xyXG4gICAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICBjcmMzID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ+KFxyXG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIGNvbnRleHRBdHRyaWJ1dGVzKSxcclxuICAgICAgICBcIldlYkdMLWNvbnRleHQgY291bGRuJ3QgYmUgY3JlYXRlZFwiXHJcbiAgICAgICk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMgPSBjcmMzO1xyXG4gICAgICAvLyBFbmFibGUgYmFja2ZhY2UtIGFuZCB6QnVmZmVyLWN1bGxpbmcuXHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ1VMTF9GQUNFKTtcclxuICAgICAgY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9URVNUKTtcclxuICAgICAgY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CTEVORCk7XHJcbiAgICAgIGNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcclxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELlRSQU5TUEFSRU5UKTtcclxuICAgICAgLy8gUmVuZGVyT3BlcmF0b3IuY3JjMy5waXhlbFN0b3JlaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5yZWN0UmVuZGVyID0gUmVuZGVyV2ViR0wuZ2V0Q2FudmFzUmVjdCgpO1xyXG4gICAgICByZXR1cm4gY3JjMztcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBXcmFwcGVyIGZ1bmN0aW9uIHRvIHV0aWxpemUgdGhlIGJ1ZmZlclNwZWNpZmljYXRpb24gaW50ZXJmYWNlIHdoZW4gcGFzc2luZyBkYXRhIHRvIHRoZSBzaGFkZXIgdmlhIGEgYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIF9hdHRyaWJ1dGVMb2NhdGlvbiAgVGhlIGxvY2F0aW9uIG9mIHRoZSBhdHRyaWJ1dGUgb24gdGhlIHNoYWRlciwgdG8gd2hpY2ggdGhleSBkYXRhIHdpbGwgYmUgcGFzc2VkLlxyXG4gICAgICogQHBhcmFtIF9idWZmZXJTcGVjaWZpY2F0aW9uICBJbnRlcmZhY2UgcGFzc2luZyBkYXRhcHVsbHNwZWNpZmljYXRpb25zIHRvIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0QXR0cmlidXRlU3RydWN0dXJlKF9hdHRyaWJ1dGVMb2NhdGlvbjogbnVtYmVyLCBfYnVmZmVyU3BlY2lmaWNhdGlvbjogQnVmZmVyU3BlY2lmaWNhdGlvbik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLnZlcnRleEF0dHJpYlBvaW50ZXIoX2F0dHJpYnV0ZUxvY2F0aW9uLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5zaXplLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5kYXRhVHlwZSwgX2J1ZmZlclNwZWNpZmljYXRpb24ubm9ybWFsaXplLCBfYnVmZmVyU3BlY2lmaWNhdGlvbi5zdHJpZGUsIF9idWZmZXJTcGVjaWZpY2F0aW9uLm9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENoZWNrcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdpdGggdGhlIFdlYkdMLWVycm9yY29kZSBpZiB0aGUgdmFsdWUgaXMgbnVsbFxyXG4gICAgKiBAcGFyYW0gX3ZhbHVlICB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IG51bGxcclxuICAgICogQHBhcmFtIF9tZXNzYWdlICBvcHRpb25hbCwgYWRkaXRpb25hbCBtZXNzYWdlIGZvciB0aGUgZXhjZXB0aW9uXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3NlcnQ8VD4oX3ZhbHVlOiBUIHwgbnVsbCwgX21lc3NhZ2U6IHN0cmluZyA9IFwiXCIpOiBUIHtcclxuICAgICAgaWYgKF92YWx1ZSA9PT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2VydGlvbiBmYWlsZWQuICR7X21lc3NhZ2V9LCBXZWJHTC1FcnJvcjogJHtSZW5kZXJXZWJHTC5jcmMzID8gUmVuZGVyV2ViR0wuY3JjMy5nZXRFcnJvcigpIDogXCJcIn1gKTtcclxuICAgICAgcmV0dXJuIF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgb2Zmc2NyZWVuLWNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICAgIHJldHVybiA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyV2ViR0wuY3JjMy5jYW52YXM7IC8vIFRPRE86IGVuYWJsZSBPZmZzY3JlZW5DYW52YXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZW5kZXJpbmdDb250ZXh0KCk6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQge1xyXG4gICAgICByZXR1cm4gUmVuZGVyV2ViR0wuY3JjMztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRoZSBvZmZzY3JlZW4tY2FudmFzLiB4LHkgYXJlIDAgYXQgYWxsIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhc1JlY3QoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyV2ViR0wuY3JjMy5jYW52YXM7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNpemUgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0Q2FudmFzU2l6ZShfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuY2FudmFzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmNhbnZhcy5oZWlnaHQgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBhcmVhIG9uIHRoZSBvZmZzY3JlZW4tY2FudmFzIHRvIHJlbmRlciB0aGUgY2FtZXJhIGltYWdlIHRvLlxyXG4gICAgICogQHBhcmFtIF9yZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0UmVuZGVyUmVjdGFuZ2xlKF9yZWN0OiBSZWN0YW5nbGUpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wucmVjdFJlbmRlci5zZXRQb3NpdGlvbkFuZFNpemUoX3JlY3QueCwgX3JlY3QueSwgX3JlY3Qud2lkdGgsIF9yZWN0LmhlaWdodCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMudmlld3BvcnQoX3JlY3QueCwgX3JlY3QueSwgX3JlY3Qud2lkdGgsIF9yZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgQ29sb3J9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoX2NvbG9yOiBDb2xvciA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jbGVhckNvbG9yKF9jb2xvci5yLCBfY29sb3IuZywgX2NvbG9yLmIsIF9jb2xvci5hKTtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jbGVhcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQgfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX0JVRkZFUl9CSVQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIG9mZnNjcmVlbiBmcmFtZWJ1ZmZlciB0byB0aGUgb3JpZ2luYWwgUmVuZGVyaW5nQ29udGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlc2V0RnJhbWVCdWZmZXIoX2NvbG9yOiBDb2xvciA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgYXJlYSBvbiB0aGUgb2Zmc2NyZWVuLWNhbnZhcyB0aGUgY2FtZXJhIGltYWdlIGdldHMgcmVuZGVyZWQgdG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UmVuZGVyUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZW5kZXJXZWJHTC5yZWN0UmVuZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0RGVwdGhUZXN0KF90ZXN0OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfdGVzdClcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1RFU1QpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kaXNhYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzZXRCbGVuZE1vZGUoX21vZGU6IEJMRU5EKTogdm9pZCB7XHJcbiAgICAgIHN3aXRjaCAoX21vZGUpIHtcclxuICAgICAgICBjYXNlIEJMRU5ELk9QQVFVRTpcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlpFUk8pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5UUkFOU1BBUkVOVDpcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JDX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgICAgLy8gUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EU1RfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FX01JTlVTX0RTVF9BTFBIQSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJMRU5ELlBBUlRJQ0xFOlxyXG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TUkNfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0FMUEhBKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBQaWNraW5nXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB0ZXh0dXJlIGJ1ZmZlciB0byBiZSB1c2VkIGFzIHBpY2stYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlUGlja1RleHR1cmUoX3NpemU6IG51bWJlcik6IFJlbmRlclRleHR1cmUge1xyXG4gICAgICAvLyBjcmVhdGUgdG8gcmVuZGVyIHRvXHJcbiAgICAgIGNvbnN0IHRhcmdldFRleHR1cmU6IFJlbmRlclRleHR1cmUgPSBSZW5kZXIuY3JjMy5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICAgIFJlbmRlci5jcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGFyZ2V0VGV4dHVyZSk7XHJcblxyXG4gICAgICB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQ6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQTMySTtcclxuICAgICAgICBjb25zdCBmb3JtYXQ6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQV9JTlRFR0VSO1xyXG4gICAgICAgIGNvbnN0IHR5cGU6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuSU5UO1xyXG4gICAgICAgIFJlbmRlci5waWNrQnVmZmVyID0gbmV3IEludDMyQXJyYXkoX3NpemUgKiBfc2l6ZSAqIDQpO1xyXG4gICAgICAgIFJlbmRlci5jcmMzLnRleEltYWdlMkQoXHJcbiAgICAgICAgICBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBfc2l6ZSwgX3NpemUsIDAsIGZvcm1hdCwgdHlwZSwgUmVuZGVyLnBpY2tCdWZmZXJcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIGZpbHRlcmluZyBzbyB3ZSBkb24ndCBuZWVkIG1pcHNcclxuICAgICAgICBSZW5kZXIuY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSKTtcclxuICAgICAgICBSZW5kZXIuY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfUywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBSZW5kZXIuY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXIgPSBSZW5kZXIuY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICBSZW5kZXIuY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xyXG4gICAgICBjb25zdCBhdHRhY2htZW50UG9pbnQ6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDA7XHJcbiAgICAgIFJlbmRlci5jcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnRQb2ludCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCB0YXJnZXRUZXh0dXJlLCAwKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLnNpemVQaWNrID0gX3NpemU7XHJcbiAgICAgIHJldHVybiB0YXJnZXRUZXh0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZ2V0UGlja3MoX3NpemU6IG51bWJlciwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja1tdIHtcclxuICAgICAgLy8gZXZhbHVhdGUgdGV4dHVyZSBieSByZWFkaW5nIHBpeGVscyBhbmQgZXh0cmFjdCwgY29udmVydCBhbmQgc3RvcmUgdGhlIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggbWVzaCBoaXRcclxuICAgICAgbGV0IGRhdGE6IEludDMyQXJyYXkgPSBuZXcgSW50MzJBcnJheShfc2l6ZSAqIF9zaXplICogNCk7XHJcbiAgICAgIFJlbmRlci5jcmMzLnJlYWRQaXhlbHMoMCwgMCwgX3NpemUsIF9zaXplLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkFfSU5URUdFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5JTlQsIGRhdGEpO1xyXG5cclxuICAgICAgbGV0IG10eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKF9jbXBDYW1lcmEubXR4V29ybGRUb1ZpZXcpO1xyXG4gICAgICBsZXQgcGlja2VkOiBQaWNrW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IFJlbmRlci7GknBpY2tlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCB6QnVmZmVyOiBudW1iZXIgPSBkYXRhWzQgKiBpICsgMF0gKyBkYXRhWzQgKiBpICsgMV0gLyAyNTY7XHJcbiAgICAgICAgaWYgKHpCdWZmZXIgPT0gMCkgLy8gZGlzY2FyZCBtaXNzZXMgXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBsZXQgcGljazogUGljayA9IFJlbmRlci7GknBpY2tlZFtpXTtcclxuICAgICAgICBwaWNrLnpCdWZmZXIgPSBjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoZGF0YSwgNCAqIGkgKyAwKSAqIDIgLSAxO1xyXG4gICAgICAgIHBpY2suY29sb3IgPSBjb252ZXJ0SW50MzJ0b0NvbG9yKGRhdGEsIDQgKiBpICsgMSk7XHJcbiAgICAgICAgcGljay50ZXh0dXJlVVYgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgICAgcGljay50ZXh0dXJlVVYuc2V0KGNvbnZlcnRJbnQzMnRvRmxvYXQzMihkYXRhLCA0ICogaSArIDIpLCBjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoZGF0YSwgNCAqIGkgKyAzKSk7XHJcbiAgICAgICAgcGljay5tdHhWaWV3VG9Xb3JsZCA9IG10eFZpZXdUb1dvcmxkO1xyXG5cclxuICAgICAgICBwaWNrZWQucHVzaChwaWNrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHBpY2tlZDtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRJbnQzMnRvRmxvYXQzMihfaW50MzJBcnJheTogSW50MzJBcnJheSwgX2luZGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xyXG4gICAgICAgIGxldCB2aWV3OiBEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xyXG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgX2ludDMyQXJyYXlbX2luZGV4XSk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQzMigwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29udmVydEludDMydG9Db2xvcihfaW50MzJBcnJheTogSW50MzJBcnJheSwgX2luZGV4OiBudW1iZXIpOiBDb2xvciB7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XHJcbiAgICAgICAgbGV0IHZpZXc6IERhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XHJcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCBfaW50MzJBcnJheVtfaW5kZXhdKTtcclxuICAgICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuQ1NTKGByZ2IoJHt2aWV3LmdldFVpbnQ4KDApfSwgJHt2aWV3LmdldFVpbnQ4KDEpfSwgJHt2aWV3LmdldFVpbnQ4KDIpfSlgLCB2aWV3LmdldFVpbnQ4KDMpIC8gMjU1KTtcclxuICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIHJlbmRlciBmdW5jdGlvbiBmb3IgcGlja2luZyBhIHNpbmdsZSBub2RlLiBcclxuICAgICogQSBjYW1lcmFwcm9qZWN0aW9uIHdpdGggZXh0cmVtZWx5IG5hcnJvdyBmb2N1cyBpcyB1c2VkLCBzbyBlYWNoIHBpeGVsIG9mIHRoZSBidWZmZXIgd291bGQgaG9sZCB0aGUgc2FtZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub2RlLCAgXHJcbiAgICAqIGJ1dCB0aGUgZnJhZ21lbnQgc2hhZGVyIHJlbmRlcnMgb25seSAxIHBpeGVsIGZvciBlYWNoIG5vZGUgaW50byB0aGUgcmVuZGVyIGJ1ZmZlciwgMXN0IG5vZGUgdG8gMXN0IHBpeGVsLCAybmQgbm9kZSB0byBzZWNvbmQgcGl4ZWwgZXRjLlxyXG4gICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcGljayhfbm9kZTogTm9kZSwgX210eE1lc2hUb1dvcmxkOiBNYXRyaXg0eDQsIF9tdHhXb3JsZFRvVmlldzogTWF0cml4NHg0KTogdm9pZCB7IC8vIGNyZWF0ZSBUZXh0dXJlIHRvIHJlbmRlciB0bywgaW50LXJnYmFcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuXHJcbiAgICAgICAgbGV0IGNvYXQ6IENvYXQgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5jb2F0O1xyXG4gICAgICAgIGxldCBzaGFkZXI6IHR5cGVvZiBTaGFkZXIgPSBjb2F0IGluc3RhbmNlb2YgQ29hdFRleHR1cmVkID8gU2hhZGVyUGlja1RleHR1cmVkIDogU2hhZGVyUGljaztcclxuXHJcbiAgICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuICAgICAgICBjb2F0LnVzZVJlbmRlckRhdGEoc2hhZGVyLCBjbXBNYXRlcmlhbCk7XHJcblxyXG4gICAgICAgIGxldCBzaXplVW5pZm9ybUxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IHNoYWRlci51bmlmb3Jtc1tcInVfdmN0U2l6ZVwiXTtcclxuICAgICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTJmdihzaXplVW5pZm9ybUxvY2F0aW9uLCBbUmVuZGVyV2ViR0wuc2l6ZVBpY2ssIFJlbmRlcldlYkdMLnNpemVQaWNrXSk7XHJcblxyXG4gICAgICAgIGxldCBtZXNoOiBNZXNoID0gY21wTWVzaC5tZXNoO1xyXG4gICAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gbWVzaC51c2VSZW5kZXJCdWZmZXJzKHNoYWRlciwgX210eE1lc2hUb1dvcmxkLCBfbXR4V29ybGRUb1ZpZXcsIFJlbmRlci7GknBpY2tlZC5sZW5ndGgpO1xyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuZHJhd0VsZW1lbnRzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCByZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuXHJcbiAgICAgICAgbGV0IHBpY2s6IFBpY2sgPSBuZXcgUGljayhfbm9kZSk7XHJcbiAgICAgICAgUmVuZGVyLsaScGlja2VkLnB1c2gocGljayk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIC8vXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBMaWdodHNcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxpZ2h0IGRhdGEgaW4gc2hhZGVyc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHNldExpZ2h0c0luU2hhZGVyKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9saWdodHM6IE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0KTogdm9pZCB7XHJcbiAgICAgIF9zaGFkZXIudXNlUHJvZ3JhbSgpO1xyXG4gICAgICBsZXQgdW5pOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9ID0gX3NoYWRlci51bmlmb3JtcztcclxuXHJcbiAgICAgIC8vIEFtYmllbnRcclxuICAgICAgbGV0IGFtYmllbnQ6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gdW5pW1widV9hbWJpZW50LnZjdENvbG9yXCJdO1xyXG4gICAgICBpZiAoYW1iaWVudCkge1xyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTRmdihhbWJpZW50LCBbMCwgMCwgMCwgMF0pO1xyXG4gICAgICAgIGxldCBjbXBMaWdodHM6IENvbXBvbmVudExpZ2h0W10gPSBfbGlnaHRzLmdldChMaWdodEFtYmllbnQpO1xyXG4gICAgICAgIGlmIChjbXBMaWdodHMpIHtcclxuICAgICAgICAgIC8vIFRPRE86IGFkZCB1cCBhbWJpZW50IGxpZ2h0cyB0byBhIHNpbmdsZSBjb2xvclxyXG4gICAgICAgICAgbGV0IHJlc3VsdDogQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgICBmb3IgKGxldCBjbXBMaWdodCBvZiBjbXBMaWdodHMpXHJcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoY21wTGlnaHQubGlnaHQuY29sb3IpO1xyXG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtNGZ2KGFtYmllbnQsIHJlc3VsdC5nZXRBcnJheSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERpcmVjdGlvbmFsXHJcbiAgICAgIGxldCBuRGlyZWN0aW9uYWw6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gdW5pW1widV9uTGlnaHRzRGlyZWN0aW9uYWxcIl07XHJcbiAgICAgIGlmIChuRGlyZWN0aW9uYWwpIHtcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLnVuaWZvcm0xdWkobkRpcmVjdGlvbmFsLCAwKTtcclxuICAgICAgICBsZXQgY21wTGlnaHRzOiBDb21wb25lbnRMaWdodFtdID0gX2xpZ2h0cy5nZXQoTGlnaHREaXJlY3Rpb25hbCk7XHJcbiAgICAgICAgaWYgKGNtcExpZ2h0cykge1xyXG4gICAgICAgICAgbGV0IG46IG51bWJlciA9IGNtcExpZ2h0cy5sZW5ndGg7XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLnVuaWZvcm0xdWkobkRpcmVjdGlvbmFsLCBuKTtcclxuICAgICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNtcExpZ2h0OiBDb21wb25lbnRMaWdodCA9IGNtcExpZ2h0c1tpXTtcclxuICAgICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy51bmlmb3JtNGZ2KHVuaVtgdV9kaXJlY3Rpb25hbFske2l9XS52Y3RDb2xvcmBdLCBjbXBMaWdodC5saWdodC5jb2xvci5nZXRBcnJheSgpKTtcclxuICAgICAgICAgICAgbGV0IGRpcmVjdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWigpO1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24udHJhbnNmb3JtKGNtcExpZ2h0Lm10eFBpdm90LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbi50cmFuc2Zvcm0oY21wTGlnaHQubm9kZS5tdHhXb3JsZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTNmdih1bmlbYHVfZGlyZWN0aW9uYWxbJHtpfV0udmN0RGlyZWN0aW9uYF0sIGRpcmVjdGlvbi5nZXQoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBtZXNoIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gaW5mb3MgYW5kIHRoZSBjb21wbGV0ZSBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRyYXdNZXNoKF9jbXBNZXNoOiBDb21wb25lbnRNZXNoLCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICBsZXQgc2hhZGVyOiB0eXBlb2YgU2hhZGVyID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuZ2V0U2hhZGVyKCk7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gY21wTWF0ZXJpYWwubWF0ZXJpYWwuY29hdDtcclxuICAgICAgbGV0IG10eE1lc2hUb1ZpZXc6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3LCBfY21wTWVzaC5tdHhXb3JsZCk7XHJcbiAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzO1xyXG4gICAgICBpZiAoX2NtcE1lc2gubWVzaCBpbnN0YW5jZW9mIE1lc2hTa2luKVxyXG4gICAgICAgIHJlbmRlckJ1ZmZlcnMgPSBfY21wTWVzaC5tZXNoLnVzZVJlbmRlckJ1ZmZlcnMoc2hhZGVyLCBfY21wTWVzaC5tdHhXb3JsZCwgbXR4TWVzaFRvVmlldywgbnVsbCwgX2NtcE1lc2guc2tlbGV0b24ubXR4Qm9uZXMpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmVuZGVyQnVmZmVycyA9IF9jbXBNZXNoLm1lc2gudXNlUmVuZGVyQnVmZmVycyhzaGFkZXIsIF9jbXBNZXNoLm10eFdvcmxkLCBtdHhNZXNoVG9WaWV3KTtcclxuXHJcbiAgICAgIGNvYXQudXNlUmVuZGVyRGF0YShzaGFkZXIsIGNtcE1hdGVyaWFsKTtcclxuICAgICAgbGV0IHVDYW1lcmE6IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gc2hhZGVyLnVuaWZvcm1zW1widV92Y3RDYW1lcmFcIl07XHJcbiAgICAgIGlmICh1Q2FtZXJhKVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTNmdih1Q2FtZXJhLCBfY21wQ2FtZXJhLm10eFdvcmxkLnRyYW5zbGF0aW9uLmdldCgpKTtcclxuICAgICAgbGV0IHVXb3JsZFRvVmlldzogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBzaGFkZXIudW5pZm9ybXNbXCJ1X210eFdvcmxkVG9WaWV3XCJdO1xyXG4gICAgICBpZiAodVdvcmxkVG9WaWV3KVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybU1hdHJpeDRmdih1V29ybGRUb1ZpZXcsIGZhbHNlLCBfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3LmdldCgpKTtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIHJlbmRlckJ1ZmZlcnMubkluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAvL2dpdmVzIFdlYkdMIEJ1ZmZlciB0aGUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgVGV4dHVyZV1dXHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yVGV4dHVyZSBleHRlbmRzIFJlbmRlckluamVjdG9yIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJJbmplY3Rvci5pbmplY3QoX2NvbnN0cnVjdG9yLCBSZW5kZXJJbmplY3RvclRleHR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5qZWN0VGV4dHVyZSh0aGlzOiBUZXh0dXJlKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBpZiAodGhpcy5yZW5kZXJEYXRhKSB7XHJcbiAgICAgICAgLy8gYnVmZmVycyBleGlzdFxyXG4gICAgICAgIGNyYzMuYWN0aXZlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwKTtcclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5yZW5kZXJEYXRhW1widGV4dHVyZTBcIl0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0YSA9IHt9O1xyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIGFsbCBXZWJHTC1DcmVhdGlvbnMgYXJlIGFzc2VydGVkXHJcbiAgICAgICAgY29uc3QgdGV4dHVyZTogV2ViR0xUZXh0dXJlID0gUmVuZGVyLmFzc2VydDxXZWJHTFRleHR1cmU+KGNyYzMuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoY3JjMy5URVhUVVJFXzJELCAwLCBjcmMzLlJHQkEsIGNyYzMuUkdCQSwgY3JjMy5VTlNJR05FRF9CWVRFLCB0aGlzLnRleEltYWdlU291cmNlKTtcclxuICAgICAgICAgIGNyYzMudGV4SW1hZ2UyRChcclxuICAgICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgICAgICB0aGlzLnRleEltYWdlU291cmNlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLm1pcG1hcCkge1xyXG4gICAgICAgICAgY2FzZSBNSVBNQVAuQ1JJU1A6XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIE1JUE1BUC5NRURJVU06XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUX01JUE1BUF9MSU5FQVIpO1xyXG4gICAgICAgICAgICBjcmMzLmdlbmVyYXRlTWlwbWFwKGNyYzMuVEVYVFVSRV8yRCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBNSVBNQVAuQkxVUlJZOlxyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIpO1xyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XHJcbiAgICAgICAgICAgIGNyYzMuZ2VuZXJhdGVNaXBtYXAoY3JjMy5URVhUVVJFXzJEKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0YVtcInRleHR1cmUwXCJdID0gdGV4dHVyZTtcclxuXHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xyXG5cclxuICAgICAgICB0aGlzLnVzZVJlbmRlckRhdGEoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWFwQ2xhc3NUb0NvbXBvbmVudHMge1xyXG4gICAgW2NsYXNzTmFtZTogc3RyaW5nXTogQ29tcG9uZW50W107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgc2NlbmV0cmVlLlxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvR3JhcGhcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTm9kZSBleHRlbmRzIEV2ZW50VGFyZ2V0xpIgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZzsgLy8gVGhlIG5hbWUgdG8gY2FsbCB0aGlzIG5vZGUgYnkuXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgcHVibGljIHRpbWVzdGFtcFVwZGF0ZTogbnVtYmVyID0gMDtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIG5vZGVzIG9mIHRoZSB3aG9sZSBicmFuY2ggaW5jbHVkaW5nIHRoaXMgbm9kZSBhbmQgYWxsIHN1Y2Nlc3NvcnMgKi9cclxuICAgIHB1YmxpYyBuTm9kZXNJbkJyYW5jaDogbnVtYmVyID0gMDtcclxuICAgIC8qKiBUaGUgcmFkaXVzIG9mIHRoZSBib3VuZGluZyBzcGhlcmUgaW4gd29ybGQgZGltZW5zaW9ucyBlbmNsb3NpbmcgdGhlIGdlb21ldHJ5IG9mIHRoaXMgbm9kZSBhbmQgYWxsIHN1Y2Nlc3NvcnMgaW4gdGhlIGJyYW5jaCAqL1xyXG4gICAgcHVibGljIHJhZGl1czogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjbXR4V29ybGRJbnZlcnNlVXBkYXRlZDogbnVtYmVyO1xyXG4gICAgI210eFdvcmxkSW52ZXJzZTogTWF0cml4NHg0O1xyXG5cclxuICAgIHByaXZhdGUgcGFyZW50OiBOb2RlIHwgbnVsbCA9IG51bGw7IC8vIFRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLlxyXG4gICAgcHJpdmF0ZSBjaGlsZHJlbjogTm9kZVtdID0gW107IC8vIGFycmF5IG9mIGNoaWxkIG5vZGVzIGFwcGVuZGVkIHRvIHRoaXMgbm9kZS5cclxuICAgIHByaXZhdGUgY29tcG9uZW50czogTWFwQ2xhc3NUb0NvbXBvbmVudHMgPSB7fTtcclxuICAgIC8vIHByaXZhdGUgdGFnczogc3RyaW5nW10gPSBbXTsgLy8gTmFtZXMgb2YgdGFncyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIG5vZGUuIChUT0RPOiBBcyBvZiB5ZXQgbm8gZnVuY3Rpb25hbGl0eSlcclxuICAgIC8vIHByaXZhdGUgbGF5ZXJzOiBzdHJpbmdbXSA9IFtdOyAvLyBOYW1lcyBvZiB0aGUgbGF5ZXJzIHRoaXMgbm9kZSBpcyBvbi4gKFRPRE86IEFzIG9mIHlldCBubyBmdW5jdGlvbmFsaXR5KVxyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSB7fTtcclxuICAgIHByaXZhdGUgY2FwdHVyZXM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSB7fTtcclxuICAgIHByaXZhdGUgYWN0aXZlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBhIG5hbWUgYW5kIGluaXRpYWxpemVzIGFsbCBhdHRyaWJ1dGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IHRvIHJldHJpZXZlIHRoaXMgbm9kZXMge0BsaW5rIENvbXBvbmVudFRyYW5zZm9ybX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjbXBUcmFuc2Zvcm0oKTogQ29tcG9uZW50VHJhbnNmb3JtIHtcclxuICAgICAgcmV0dXJuIDxDb21wb25lbnRUcmFuc2Zvcm0+dGhpcy5nZXRDb21wb25lbnRzKENvbXBvbmVudFRyYW5zZm9ybSlbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGUgbG9jYWwge0BsaW5rIE1hdHJpeDR4NH0gYXR0YWNoZWQgdG8gdGhpcyBub2RlcyB7QGxpbmsgQ29tcG9uZW50VHJhbnNmb3JtfSAgXHJcbiAgICAgKiBGYWlscyBpZiBubyB7QGxpbmsgQ29tcG9uZW50VHJhbnNmb3JtfSBpcyBhdHRhY2hlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eExvY2FsKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNtcFRyYW5zZm9ybS5tdHhMb2NhbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG10eFdvcmxkSW52ZXJzZSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICBpZiAodGhpcy4jbXR4V29ybGRJbnZlcnNlVXBkYXRlZCAhPSB0aGlzLnRpbWVzdGFtcFVwZGF0ZSlcclxuICAgICAgICB0aGlzLiNtdHhXb3JsZEludmVyc2UgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKHRoaXMubXR4V29ybGQpO1xyXG5cclxuICAgICAgdGhpcy4jbXR4V29ybGRJbnZlcnNlVXBkYXRlZCA9IHRoaXMudGltZXN0YW1wVXBkYXRlO1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4V29ybGRJbnZlcnNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGF0dGFjaGVkIHRvIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBuQ2hpbGRyZW4oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBub2RlIGFuZCBhbGwgZGVjZW5kYW50cyBpbiB0aGUgZ3JhcGggYmVsb3cgZm9yIGl0ZXJhdGlvblxyXG4gICAgICogSW5hY3RpdmUgbm9kZXMgYW5kIHRoZWlyIGRlc2NlbmRhbnRzIGNhbiBiZSBmaWx0ZXJlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgKiBnZXRJdGVyYXRvcihfYWN0aXZlOiBib29sZWFuID0gZmFsc2UpOiBJdGVyYWJsZUl0ZXJhdG9yPE5vZGU+IHtcclxuICAgICAgaWYgKCFfYWN0aXZlIHx8IHRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgICB5aWVsZCB0aGlzO1xyXG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXHJcbiAgICAgICAgICB5aWVsZCogY2hpbGQuZ2V0SXRlcmF0b3IoX2FjdGl2ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxOb2RlPiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEl0ZXJhdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IF9vbjtcclxuICAgICAgLy8gVE9ETzogY2hlY2sgaWYgQ09NUE9ORU5UX0FDVElWQVRFL0RFQUNUSVZBVEUgaXMgdGhlIGNvcnJlY3QgZXZlbnQgdG8gZGlzcGF0Y2guIFNob3VsZG4ndCBpdCBiZSBzb21ldGhpbmcgbGlrZSBOT0RFX0FDVElWQVRFL0RFQUNUSVZBVEU/XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuTk9ERV9BQ1RJVkFURSA6IEVWRU5ULk5PREVfREVBQ1RJVkFURSwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgdGhpcy5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuTk9ERV9BQ1RJVkFURSA6IEVWRU5ULk5PREVfREVBQ1RJVkFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNyZWdpb24gU2NlbmV0cmVlXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBub2RlcyBwYXJlbnQgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGFyZW50KCk6IE5vZGUgfCBudWxsIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2VzIGJhY2sgdGhlIGFuY2VzdG9ycyBvZiB0aGlzIG5vZGUgYW5kIHJldHVybnMgdGhlIGZpcnN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBbmNlc3RvcigpOiBOb2RlIHwgbnVsbCB7XHJcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvci5nZXRQYXJlbnQoKSlcclxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLmdldFBhcmVudCgpO1xyXG4gICAgICByZXR1cm4gYW5jZXN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFjZXMgdGhlIGhpZXJhcmNoeSB1cHdhcmRzIHRvIHRoZSBmaXJzdCBhbmNlc3RvciBhbmQgcmV0dXJucyB0aGUgcGF0aCB0aHJvdWdoIHRoZSBncmFwaCB0byB0aGlzIG5vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBhdGgoKTogTm9kZVtdIHtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gdGhpcztcclxuICAgICAgbGV0IHBhdGg6IE5vZGVbXSA9IFt0aGlzXTtcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yLmdldFBhcmVudCgpKVxyXG4gICAgICAgIHBhdGgudW5zaGlmdChhbmNlc3RvciA9IGFuY2VzdG9yLmdldFBhcmVudCgpKTtcclxuICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENoaWxkKF9pbmRleDogbnVtYmVyKTogTm9kZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW19pbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENoaWxkcmVuKCk6IE5vZGVbXSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnNsaWNlKDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiByZWZlcmVuY2VzIHRvIGNoaWxkbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbkJ5TmFtZShfbmFtZTogc3RyaW5nKTogTm9kZVtdIHtcclxuICAgICAgbGV0IGZvdW5kOiBOb2RlW10gPSBbXTtcclxuICAgICAgZm91bmQgPSB0aGlzLmNoaWxkcmVuLmZpbHRlcigoX25vZGU6IE5vZGUpID0+IF9ub2RlLm5hbWUgPT0gX25hbWUpO1xyXG4gICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbHkgY2FsbHMge0BsaW5rIGFkZENoaWxkfS4gVGhpcyByZWZlcmVuY2UgaXMgaGVyZSBzb2xlbHkgYmVjYXVzZSBhcHBlbmRDaGlsZCBpcyB0aGUgZXF1aXZhbGVudCBtZXRob2QgaW4gRE9NLlxyXG4gICAgICogU2VlIGFuZCBwcmVmZXJhYmx5IHVzZSB7QGxpbmsgYWRkQ2hpbGR9XHJcbiAgICAgKi9cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWVtYmVyLW9yZGVyaW5nXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgYXBwZW5kQ2hpbGQ6IChfY2hpbGQ6IE5vZGUpID0+IHZvaWQgPSB0aGlzLmFkZENoaWxkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gcmVmZXJlbmNlIHRvIGEgbm9kZSB0byB0aGUgbGlzdCBvZiBjaGlsZHJlbiwgaWYgbm90IGFscmVhZHkgaW5cclxuICAgICAqIEB0aHJvd3MgRXJyb3Igd2hlbiB0cnlpbmcgdG8gYWRkIGFuIGFuY2VzdG9yIG9mIHRoaXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDaGlsZChfY2hpbGQ6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaW5jbHVkZXMoX2NoaWxkKSlcclxuICAgICAgICAvLyBfbm9kZSBpcyBhbHJlYWR5IGEgY2hpbGQgb2YgdGhpc1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBpbkF1ZGlvR3JhcGg6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgbGV0IGdyYXBoTGlzdGVuZWQ6IE5vZGUgPSBBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCk7XHJcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgIGFuY2VzdG9yLnRpbWVzdGFtcFVwZGF0ZSA9IDA7XHJcbiAgICAgICAgaW5BdWRpb0dyYXBoID0gaW5BdWRpb0dyYXBoIHx8IChhbmNlc3RvciA9PSBncmFwaExpc3RlbmVkKTtcclxuICAgICAgICBpZiAoYW5jZXN0b3IgPT0gX2NoaWxkKVxyXG4gICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIkN5Y2xpYyByZWZlcmVuY2UgcHJvaGliaXRlZCBpbiBub2RlIGhpZXJhcmNoeSwgYW5jZXN0b3JzIG11c3Qgbm90IGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHByZXZpb3VzUGFyZW50OiBOb2RlID0gX2NoaWxkLnBhcmVudDtcclxuICAgICAgaWYgKHByZXZpb3VzUGFyZW50KVxyXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF9jaGlsZCk7XHJcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChfY2hpbGQpO1xyXG4gICAgICBfY2hpbGQucGFyZW50ID0gdGhpcztcclxuICAgICAgX2NoaWxkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX0FQUEVORCwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgaWYgKGluQXVkaW9HcmFwaClcclxuICAgICAgICBfY2hpbGQuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcmVmZXJlbmNlIHRvIHRoZSBnaXZlIG5vZGUgZnJvbSB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ2hpbGQoX2NoaWxkOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGxldCBmb3VuZDogbnVtYmVyID0gdGhpcy5maW5kQ2hpbGQoX2NoaWxkKTtcclxuICAgICAgaWYgKGZvdW5kIDwgMClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBfY2hpbGQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ0hJTERfUkVNT1ZFLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICBpZiAodGhpcy5pc0Rlc2NlbmRhbnRPZihBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCkpKVxyXG4gICAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfUkVNT1ZFKSk7XHJcbiAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGZvdW5kLCAxKTtcclxuICAgICAgX2NoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCByZWZlcmVuY2VzIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVBbGxDaGlsZHJlbigpOiB2b2lkIHtcclxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxyXG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlbiBvciAtMSBpZiBub3QgZm91bmRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpbmRDaGlsZChfc2VhcmNoOiBOb2RlKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uaW5kZXhPZihfc2VhcmNoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIGEgY2hpbGQgbm9kZSB3aXRoIGFub3RoZXIsIHByZXNlcnZpbmcgdGhlIHBvc2l0aW9uIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXBsYWNlQ2hpbGQoX3JlcGxhY2U6IE5vZGUsIF93aXRoOiBOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBmb3VuZDogbnVtYmVyID0gdGhpcy5maW5kQ2hpbGQoX3JlcGxhY2UpO1xyXG4gICAgICBpZiAoZm91bmQgPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIGxldCBwcmV2aW91c1BhcmVudDogTm9kZSA9IF93aXRoLmdldFBhcmVudCgpO1xyXG4gICAgICBpZiAocHJldmlvdXNQYXJlbnQpXHJcbiAgICAgICAgcHJldmlvdXNQYXJlbnQucmVtb3ZlQ2hpbGQoX3dpdGgpO1xyXG5cclxuICAgICAgX3JlcGxhY2UucGFyZW50ID0gbnVsbDtcclxuICAgICAgdGhpcy5jaGlsZHJlbltmb3VuZF0gPSBfd2l0aDtcclxuICAgICAgX3dpdGgucGFyZW50ID0gdGhpcztcclxuXHJcbiAgICAgIF93aXRoLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX0FQUEVORCwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgaWYgKHRoaXMuaXNEZXNjZW5kYW50T2YoQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0R3JhcGhMaXN0ZW5pbmdUbygpKSlcclxuICAgICAgICBfd2l0aC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGlzVXBkYXRlZChfdGltZXN0YW1wVXBkYXRlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuICh0aGlzLnRpbWVzdGFtcFVwZGF0ZSA9PSBfdGltZXN0YW1wVXBkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNEZXNjZW5kYW50T2YoX2FuY2VzdG9yOiBOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBub2RlOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPSBfYW5jZXN0b3IpXHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgTXV0YXRvciBmcm9tIHtAbGluayBBbmltYXRpb259IHRvIGFsbCBpdHMgY29tcG9uZW50cyBhbmQgdHJhbnNmZXJzIGl0IHRvIGl0cyBjaGlsZHJlbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5QW5pbWF0aW9uKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXV0YXRvci5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgY29tcG9uZW50TmFtZSBpbiBfbXV0YXRvci5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgIGxldCBtdXRhdG9yT2ZDb21wb25lbnQ6IE11dGF0b3IgPSA8TXV0YXRvcj5fbXV0YXRvci5jb21wb25lbnRzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIG11dGF0b3JPZkNvbXBvbmVudFtjb21wb25lbnROYW1lXSkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV1bK2ldKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50VG9NdXRhdGU6IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVsraV07XHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRvckFycmF5OiBNdXRhdG9yW10gPSAoPEFycmF5PE11dGF0b3I+Pm11dGF0b3JPZkNvbXBvbmVudFtjb21wb25lbnROYW1lXSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRvcldpdGhDb21wb25lbnROYW1lOiBNdXRhdG9yID0gPE11dGF0b3I+bXV0YXRvckFycmF5WytpXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNuYW1lIGluIG11dGF0b3JXaXRoQ29tcG9uZW50TmFtZSkgeyAgIC8vIHRyaWNrIHVzZWQgdG8gZ2V0IHRoZSBvbmx5IGVudHJ5IGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgIGxldCBtdXRhdG9yVG9HaXZlOiBNdXRhdG9yID0gPE11dGF0b3I+bXV0YXRvcldpdGhDb21wb25lbnROYW1lW2NuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50VG9NdXRhdGUubXV0YXRlKG11dGF0b3JUb0dpdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoX211dGF0b3IuY2hpbGRyZW4pIHtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgKDxBcnJheTxPYmplY3Q+Pl9tdXRhdG9yLmNoaWxkcmVuKS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IG5hbWU6IHN0cmluZyA9ICg8Tm9kZT4oPEFycmF5PE11dGF0b3I+Pl9tdXRhdG9yLmNoaWxkcmVuKVtpXVtcIsaSLk5vZGVcIl0pLm5hbWU7XHJcbiAgICAgICAgICBsZXQgY2hpbGROb2RlczogTm9kZVtdID0gdGhpcy5nZXRDaGlsZHJlbkJ5TmFtZShuYW1lKTtcclxuICAgICAgICAgIGZvciAobGV0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNoaWxkTm9kZS5hcHBseUFuaW1hdGlvbig8TXV0YXRvcj4oPEFycmF5PE11dGF0b3I+Pl9tdXRhdG9yLmNoaWxkcmVuKVtpXVtcIsaSLk5vZGVcIl0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gQ29tcG9uZW50c1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgY29tcG9uZW50cyBhdHRhY2hlZCB0byB0aGlzIG5vZGUsIGluZGVwZW5kZW50IG9mIHR5cGUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QWxsQ29tcG9uZW50cygpOiBDb21wb25lbnRbXSB7XHJcbiAgICAgIGxldCBhbGw6IENvbXBvbmVudFtdID0gW107XHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgYWxsID0gYWxsLmNvbmNhdCh0aGlzLmNvbXBvbmVudHNbdHlwZV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhbGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGxpc3Qgb2YgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gY2xhc3MgYXR0YWNoZWQgdG8gdGhpcyBub2RlLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudHM8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IFRbXSB7XHJcbiAgICAgIHJldHVybiA8VFtdPih0aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdIHx8IFtdKS5zbGljZSgwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgY29tcG9udGVudCBmb3VuZCBvZiB0aGUgZ2l2ZW4gY2xhc3MgYXR0YWNoZWQgdGhpcyBub2RlIG9yIG51bGwsIGlmIGxpc3QgaXMgZW1wdHkgb3IgZG9lc24ndCBleGlzdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgbGV0IGxpc3Q6IFRbXSA9IDxUW10+dGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXTtcclxuICAgICAgaWYgKGxpc3QpXHJcbiAgICAgICAgcmV0dXJuIGxpc3RbMF07XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBjb21wb25lbnQgdG8gdGhpcyBub2RlLiBJZGVudGljYWwgdG8ge0BsaW5rIGFkZENvbXBvbmVudH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGF0dGFjaChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5hZGRDb21wb25lbnQoX2NvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaCB0aGUgZ2l2ZW4gY29tcG9uZW50IHRvIHRoaXMgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ29tcG9uZW50KF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2NvbXBvbmVudC5ub2RlID09IHRoaXMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgY21wTGlzdDogQ29tcG9uZW50W10gPSB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXTtcclxuICAgICAgaWYgKGNtcExpc3QgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXSA9IFtfY29tcG9uZW50XTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGlmIChjbXBMaXN0Lmxlbmd0aCAmJiBfY29tcG9uZW50LmlzU2luZ2xldG9uKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IGlzIG1hcmtlZCBzaW5nbGV0b24gYW5kIGNhbid0IGJlIGF0dGFjaGVkLCBubyBtb3JlIHRoYW4gb25lIGFsbG93ZWRcIik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgY21wTGlzdC5wdXNoKF9jb21wb25lbnQpO1xyXG5cclxuICAgICAgX2NvbXBvbmVudC5hdHRhY2hUb05vZGUodGhpcyk7XHJcbiAgICAgIF9jb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ09NUE9ORU5UX0FERCkpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnRUb1RhcmdldE9ubHkobmV3IEN1c3RvbUV2ZW50KEVWRU5ULkNPTVBPTkVOVF9BREQsIHsgZGV0YWlsOiBfY29tcG9uZW50IH0pKTsgLy8gVE9ETzogc2VlIGlmIHRoaXMgaXMgYmUgZmVhc2FibGVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGFjaCB0aGUgZ2l2ZW4gY29tcG9uZW50IGZyb20gdGhpcyBub2RlLiBJZGVudGljYWwgdG8ge0BsaW5rIHJlbW92ZUNvbXBvbmVudH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRldGFjaChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKiogXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjb21wb25lbnQgZnJvbSB0aGUgbm9kZSwgaWYgaXQgd2FzIGF0dGFjaGVkLCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ29tcG9uZW50KF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCBjb21wb25lbnRzT2ZUeXBlOiBDb21wb25lbnRbXSA9IHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdO1xyXG4gICAgICAgIGxldCBmb3VuZEF0OiBudW1iZXIgPSBjb21wb25lbnRzT2ZUeXBlLmluZGV4T2YoX2NvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGZvdW5kQXQgPCAwKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIF9jb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSkpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgeyBkZXRhaWw6IF9jb21wb25lbnQgfSkpOyAvLyBUT0RPOiBzZWUgaWYgdGhpcyB3b3VsZCBiZSBmZWFzYWJsZVxyXG4gICAgICAgIGNvbXBvbmVudHNPZlR5cGUuc3BsaWNlKGZvdW5kQXQsIDEpO1xyXG4gICAgICAgIF9jb21wb25lbnQuYXR0YWNoVG9Ob2RlKG51bGwpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZW1vdmUgY29tcG9uZW50ICcke19jb21wb25lbnR9J2luIG5vZGUgbmFtZWQgJyR7dGhpcy5uYW1lfSdgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gU2VyaWFsaXphdGlvblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGFjdGl2ZTogdGhpcy5hY3RpdmVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGxldCBjb21wb25lbnRzOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgY29tcG9uZW50c1t0eXBlXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudHNbdHlwZV0pIHtcclxuICAgICAgICAgIC8vIGNvbXBvbmVudHNbdHlwZV0ucHVzaChjb21wb25lbnQuc2VyaWFsaXplKCkpO1xyXG4gICAgICAgICAgY29tcG9uZW50c1t0eXBlXS5wdXNoKFNlcmlhbGl6ZXIuc2VyaWFsaXplKGNvbXBvbmVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzZXJpYWxpemF0aW9uW1wiY29tcG9uZW50c1wiXSA9IGNvbXBvbmVudHM7XHJcblxyXG4gICAgICBsZXQgY2hpbGRyZW46IFNlcmlhbGl6YXRpb25bXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgY2hpbGRyZW4ucHVzaChTZXJpYWxpemVyLnNlcmlhbGl6ZShjaGlsZCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bXCJjaGlsZHJlblwiXSA9IGNoaWxkcmVuO1xyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5OT0RFX1NFUklBTElaRUQpKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgLy8gdGhpcy5wYXJlbnQgPSBpcyBzZXQgd2hlbiB0aGUgbm9kZXMgYXJlIGFkZGVkXHJcblxyXG4gICAgICAvLyBkZXNlcmlhbGl6ZSBjb21wb25lbnRzIGZpcnN0IHNvIHNjcmlwdHMgY2FuIHJlYWN0IHRvIGNoaWxkcmVuIGJlaW5nIGFwcGVuZGVkXHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gX3NlcmlhbGl6YXRpb24uY29tcG9uZW50cykge1xyXG4gICAgICAgIGZvciAobGV0IHNlcmlhbGl6ZWRDb21wb25lbnQgb2YgX3NlcmlhbGl6YXRpb24uY29tcG9uZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgbGV0IGRlc2VyaWFsaXplZENvbXBvbmVudDogQ29tcG9uZW50ID0gPENvbXBvbmVudD5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRDb21wb25lbnQpO1xyXG4gICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoZGVzZXJpYWxpemVkQ29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IHNlcmlhbGl6ZWRDaGlsZCBvZiBfc2VyaWFsaXphdGlvbi5jaGlsZHJlbikge1xyXG4gICAgICAgIGxldCBkZXNlcmlhbGl6ZWRDaGlsZDogTm9kZSA9IDxOb2RlPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENoaWxkKTtcclxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGRlc2VyaWFsaXplZENoaWxkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRCkpO1xyXG4gICAgICBmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5nZXRBbGxDb21wb25lbnRzKCkpXHJcbiAgICAgICAgY29tcG9uZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfREVTRVJJQUxJWkVEKSk7XHJcblxyXG4gICAgICB0aGlzLmFjdGl2YXRlKF9zZXJpYWxpemF0aW9uLmFjdGl2ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyBhcyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9IaWVyYXJjaHlTdHJpbmcoX25vZGU6IE5vZGUgPSBudWxsLCBfbGV2ZWw6IG51bWJlciA9IDApOiBzdHJpbmcge1xyXG4gICAgICAvLyBUT0RPOiByZWZhY3RvciBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5XHJcbiAgICAgIGlmICghX25vZGUpXHJcbiAgICAgICAgX25vZGUgPSB0aGlzO1xyXG5cclxuICAgICAgbGV0IHByZWZpeDogc3RyaW5nID0gXCIrXCIucmVwZWF0KF9sZXZlbCk7XHJcblxyXG4gICAgICBsZXQgb3V0cHV0OiBzdHJpbmcgPSBwcmVmaXggKyBcIiBcIiArIF9ub2RlLm5hbWUgKyBcIiB8IFwiO1xyXG4gICAgICBmb3IgKGxldCB0eXBlIGluIF9ub2RlLmNvbXBvbmVudHMpXHJcbiAgICAgICAgb3V0cHV0ICs9IF9ub2RlLmNvbXBvbmVudHNbdHlwZV0ubGVuZ3RoICsgXCIgXCIgKyB0eXBlLnNwbGl0KFwiQ29tcG9uZW50XCIpLnBvcCgpICsgXCIsIFwiO1xyXG4gICAgICBvdXRwdXQgPSBvdXRwdXQuc2xpY2UoMCwgLTIpICsgXCI8L2JyPlwiO1xyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBfbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIG91dHB1dCArPSB0aGlzLnRvSGllcmFyY2h5U3RyaW5nKGNoaWxkLCBfbGV2ZWwgKyAxKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNyZWdpb24gRXZlbnRzXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG5vZGUuIFRoZSBnaXZlbiBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBtYXRjaGluZyBldmVudCBpcyBwYXNzZWQgdG8gdGhlIG5vZGUuXHJcbiAgICAgKiBEZXZpYXRpbmcgZnJvbSB0aGUgc3RhbmRhcmQgRXZlbnRUYXJnZXQsIGhlcmUgdGhlIF9oYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiBhbmQgX2NhcHR1cmUgaXMgdGhlIG9ubHkgb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZTogRVZFTlQgfCBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyxpIsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IGxpc3RMaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSBfY2FwdHVyZSA/IHRoaXMuY2FwdHVyZXMgOiB0aGlzLmxpc3RlbmVycztcclxuICAgICAgaWYgKCFsaXN0TGlzdGVuZXJzW190eXBlXSlcclxuICAgICAgICBsaXN0TGlzdGVuZXJzW190eXBlXSA9IFtdO1xyXG4gICAgICBsaXN0TGlzdGVuZXJzW190eXBlXS5wdXNoKF9oYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBub2RlLiBUaGUgc2lnbmF0dXJlIG11c3QgbWF0Y2ggdGhlIG9uZSB1c2VkIHdpdGggYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZTogRVZFTlQgfCBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyxpIsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IGxpc3RlbmVyc0ZvclR5cGU6IEV2ZW50TGlzdGVuZXLGkltdID0gX2NhcHR1cmUgPyB0aGlzLmNhcHR1cmVzW190eXBlXSA6IHRoaXMubGlzdGVuZXJzW190eXBlXTtcclxuICAgICAgaWYgKGxpc3RlbmVyc0ZvclR5cGUpXHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gbGlzdGVuZXJzRm9yVHlwZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgIGlmIChsaXN0ZW5lcnNGb3JUeXBlW2ldID09IF9oYW5kbGVyKVxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNGb3JUeXBlLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlcyBhIHN5bnRoZXRpYyBldmVudCB0byB0YXJnZXQuIFRoaXMgaW1wbGVtZW50YXRpb24gYWx3YXlzIHJldHVybnMgdHJ1ZSAoc3RhbmRhcmQ6IHJldHVybiB0cnVlIG9ubHkgaWYgZWl0aGVyIGV2ZW50J3MgY2FuY2VsYWJsZSBhdHRyaWJ1dGUgdmFsdWUgaXMgZmFsc2Ugb3IgaXRzIHByZXZlbnREZWZhdWx0KCkgbWV0aG9kIHdhcyBub3QgaW52b2tlZClcclxuICAgICAqIFRoZSBldmVudCB0cmF2ZWxzIGludG8gdGhlIGhpZXJhcmNoeSB0byB0aGlzIG5vZGUgZGlzcGF0Y2hpbmcgdGhlIGV2ZW50LCBpbnZva2luZyBtYXRjaGluZyBoYW5kbGVycyBvZiB0aGUgbm9kZXMgYW5jZXN0b3JzIGxpc3RlbmluZyB0byB0aGUgY2FwdHVyZSBwaGFzZSwgXHJcbiAgICAgKiB0aGFuIHRoZSBtYXRjaGluZyBoYW5kbGVyIG9mIHRoZSB0YXJnZXQgbm9kZSBpbiB0aGUgdGFyZ2V0IHBoYXNlLCBhbmQgYmFjayBvdXQgb2YgdGhlIGhpZXJhcmNoeSBpbiB0aGUgYnViYmxpbmcgcGhhc2UsIGludm9raW5nIGFwcHJvcHJpYXRlIGhhbmRsZXJzIG9mIHRoZSBhbnZlc3RvcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc3BhdGNoRXZlbnQoX2V2ZW50OiBFdmVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgYW5jZXN0b3JzOiBOb2RlW10gPSBbXTtcclxuICAgICAgbGV0IHVwY29taW5nOiBOb2RlID0gdGhpcztcclxuICAgICAgLy8gb3ZlcndyaXRlIGV2ZW50IHRhcmdldFxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcInRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgUmVmbGVjdCBpbnN0ZWFkIG9mIE9iamVjdCB0aHJvdWdob3V0LiBTZWUgYWxzbyBSZW5kZXIgYW5kIE11dGFibGUuLi5cclxuICAgICAgd2hpbGUgKHVwY29taW5nLnBhcmVudClcclxuICAgICAgICBhbmNlc3RvcnMucHVzaCh1cGNvbWluZyA9IHVwY29taW5nLnBhcmVudCk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwicGF0aFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbmV3IEFycmF5PE5vZGU+KHRoaXMsIC4uLmFuY2VzdG9ycykgfSk7XHJcblxyXG4gICAgICAvLyBjYXB0dXJlIHBoYXNlXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQ0FQVFVSSU5HX1BIQVNFIH0pO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSBhbmNlc3RvcnNbaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBhbmNlc3RvciB9KTtcclxuICAgICAgICB0aGlzLmNhbGxMaXN0ZW5lcnMoYW5jZXN0b3IuY2FwdHVyZXNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0YXJnZXQgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5BVF9UQVJHRVQgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgdGhpcy5jYWxsTGlzdGVuZXJzKHRoaXMuY2FwdHVyZXNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG4gICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG5cclxuICAgICAgaWYgKCFfZXZlbnQuYnViYmxlcylcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIC8vIGJ1YmJsZSBwaGFzZVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkJVQkJMSU5HX1BIQVNFIH0pO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gYW5jZXN0b3JzW2ldO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogYW5jZXN0b3IgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsTGlzdGVuZXJzKGFuY2VzdG9yLmxpc3RlbmVyc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7IC8vVE9ETzogcmV0dXJuIGEgbWVhbmluZ2Z1bCB2YWx1ZSwgc2VlIGRvY3VtZW50YXRpb24gb2YgZGlzcGF0Y2ggZXZlbnRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2hlcyBhIHN5bnRoZXRpYyBldmVudCB0byB0YXJnZXQgd2l0aG91dCB0cmF2ZWxsaW5nIHRocm91Z2ggdGhlIGdyYXBoIGhpZXJhcmNoeSBuZWl0aGVyIGR1cmluZyBjYXB0dXJlIG5vciBidWJibGluZyBwaGFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQVRfVEFSR0VUIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIHRoaXMuY2FsbExpc3RlbmVycyh0aGlzLmxpc3RlbmVyc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7IC8vIFRPRE86IGV4YW1pbmUgaWYgdGhpcyBzaG91bGQgZ28gdG8gdGhlIGNhcHR1cmVzIGluc3RlYWQgb2YgdGhlIGxpc3RlbmVyc1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0cyBhIHN5bnRoZXRpYyBldmVudCB0byB0aGlzIG5vZGUgYW5kIGZyb20gdGhlcmUgdG8gYWxsIG5vZGVzIGRlZXBlciBpbiB0aGUgaGllcmFyY2h5LFxyXG4gICAgICogaW52b2tpbmcgbWF0Y2hpbmcgaGFuZGxlcnMgb2YgdGhlIG5vZGVzIGxpc3RlbmluZyB0byB0aGUgY2FwdHVyZSBwaGFzZS4gV2F0Y2ggcGVyZm9ybWFuY2Ugd2hlbiB0aGVyZSBhcmUgbWFueSBub2RlcyBpbnZvbHZlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYnJvYWRjYXN0RXZlbnQoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0IGFuZCBwaGFzZVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkNBUFRVUklOR19QSEFTRSB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJ0YXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgLy8gY2FwdHVyZSBwaGFzZSBvbmx5XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgbGV0IGNhcHR1cmVzOiBFdmVudExpc3RlbmVyxpJbXSA9IHRoaXMuY2FwdHVyZXNbX2V2ZW50LnR5cGVdIHx8IFtdO1xyXG4gICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGNhcHR1cmVzKVxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBoYW5kbGVyKF9ldmVudCk7XHJcbiAgICAgIC8vIGFwcGVhcnMgdG8gYmUgc2xvd2VyLCBhc3RvbmlzaGluZ2x5Li4uXHJcbiAgICAgIC8vIGNhcHR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXI6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgIC8vICAgICBoYW5kbGVyKF9ldmVudCk7XHJcbiAgICAgIC8vIH0pO1xyXG5cclxuICAgICAgLy8gc2FtZSBmb3IgY2hpbGRyZW5cclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgIGNoaWxkLmJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNhbGxMaXN0ZW5lcnMoX2xpc3RlbmVyczogRXZlbnRMaXN0ZW5lcsaSW10sIF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgaWYgKF9saXN0ZW5lcnM/Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBfbGlzdGVuZXJzKVxyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgaGFuZGxlcihfZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfUEhZU0lDUyB7XHJcbiAgICAgICAgVFJJR0dFUl9FTlRFUiA9IFwiVHJpZ2dlckVudGVyZWRDb2xsaXNpb25cIixcclxuICAgICAgICBUUklHR0VSX0VYSVQgPSBcIlRyaWdnZXJMZWZ0Q29sbGlzaW9uXCIsXHJcbiAgICAgICAgQ09MTElTSU9OX0VOVEVSID0gXCJDb2xsaWRlckVudGVyZWRDb2xsaXNpb25cIixcclxuICAgICAgICBDT0xMSVNJT05fRVhJVCA9IFwiQ29sbGlkZXJMZWZ0Q29sbGlzaW9uXCJcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRQaHlzaWNzIGV4dGVuZHMgRXZlbnQge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBvbmVudFJpZ2lkYm9keSB0aGF0IGNvbGxpZGVkIHdpdGggdGhpcyBDb21wb25lbnRSaWdpZGJvZHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgY21wUmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG5vcm1hbCBpbXB1bHNlIGJldHdlZW4gdGhlIHR3byBjb2xsaWRpbmcgb2JqZWN0cy4gTm9ybWFsIHJlcHJlc2VudHMgdGhlIGRlZmF1bHQgaW1wdWxzZS5cclxuICAgICAgICAgKiBJbXB1bHNlIGlzIG9ubHkgaGFwcGVuaW5nIG9uIENPTExJU0lPTl9FTlRFUiwgc28gdGhlcmUgaXMgbm8gaW1wdWxzZSBvbiBleGl0IG5vciBvbiB0cmlnZ2Vycy5cclxuICAgICAgICAgKiBVc2UgdGhlIHZlbG9jaXR5IG9mIHRoZSBjbXBSaWdpZGJvZHkgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlbnNpdHkgb2YgdGhlIEVWRU5UIGluc3RlYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHVibGljIG5vcm1hbEltcHVsc2U6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgdGFuZ2VudEltcHVsc2U6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgYmlub21hbEltcHVsc2U6IG51bWJlcjtcclxuICAgICAgICAvKiogVGhlIHBvaW50IHdoZXJlIHRoZSBjb2xsaXNpb24vdHJpZ2dlcmluZyBpbml0aWFsbHkgaGFwcGVuZWQuIFRoZSBjb2xsaXNpb24gcG9pbnQgZXhpc3RzIG9ubHkgb24gQ09MTElTSU9OX0VOVEVSIC8gVFJJR0dFUl9FTlRFUi4gKi9cclxuICAgICAgICBwdWJsaWMgY29sbGlzaW9uUG9pbnQ6IFZlY3RvcjM7XHJcbiAgICAgICAgLyoqIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBjb2xsaXNpb24uIE9ubHkgZXhpc3Rpbmcgb24gQ09MTElTSU9OX0VOVEVSICovXHJcbiAgICAgICAgcHVibGljIGNvbGxpc2lvbk5vcm1hbDogVmVjdG9yMztcclxuXHJcbiAgICAgICAgLyoqIENyZWF0ZXMgYSBuZXcgZXZlbnQgY3VzdG9taXplZCBmb3IgcGh5c2ljcy4gSG9sZGluZyBpbmZvcm1hdGlvbnMgYWJvdXQgaW1wdWxzZXMuIENvbGxpc2lvbiBwb2ludCBhbmQgdGhlIGJvZHkgdGhhdCBpcyBjb2xsaWRpbmcgKi9cclxuICAgICAgICBjb25zdHJ1Y3RvcihfdHlwZTogRVZFTlRfUEhZU0lDUywgX2hpdFJpZ2lkYm9keTogQ29tcG9uZW50UmlnaWRib2R5LCBfbm9ybWFsSW1wdWxzZTogbnVtYmVyLCBfdGFuZ2VudEltcHVsc2U6IG51bWJlciwgX2Jpbm9ybWFsSW1wdWxzZTogbnVtYmVyLCBfY29sbGlzaW9uUG9pbnQ6IFZlY3RvcjMgPSBudWxsLCBfY29sbGlzaW9uTm9ybWFsOiBWZWN0b3IzID0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdXBlcihfdHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY21wUmlnaWRib2R5ID0gX2hpdFJpZ2lkYm9keTtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gX25vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSBfdGFuZ2VudEltcHVsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYmlub21hbEltcHVsc2UgPSBfYmlub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblBvaW50ID0gX2NvbGxpc2lvblBvaW50O1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk5vcm1hbCA9IF9jb2xsaXNpb25Ob3JtYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHcm91cHMgdG8gcGxhY2UgYSBub2RlIGluLCBub3QgZXZlcnkgZ3JvdXAgc2hvdWxkIGNvbGxpZGUgd2l0aCBldmVyeSBncm91cC4gVXNlIGEgTWFzayBpbiB0byBleGNsdWRlIGNvbGxpc2lvbnNcclxuICAgICovXHJcbiAgICBleHBvcnQgZW51bSBDT0xMSVNJT05fR1JPVVAgeyAvL1RPRE8gR2l2ZSBhIHBvc3NpYmxpdGh5IHRvIHNldCB3aGljaCBsYXllciBjb2xsaWRlcyB3aXRoIHdoaWNoLCBDb2xsaXNpb25NYXRyaXg/XHJcbiAgICAgICAgREVGQVVMVCA9IDEsXHJcbiAgICAgICAgR1JPVVBfMSA9IDIsXHJcbiAgICAgICAgR1JPVVBfMiA9IDQsXHJcbiAgICAgICAgR1JPVVBfMyA9IDgsXHJcbiAgICAgICAgR1JPVVBfNCA9IDE2LFxyXG4gICAgICAgIEdST1VQXzUgPSAzMlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEZWZpbmVzIHRoZSB0eXBlIG9mIHRoZSByaWdpZGJvZHkgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgd2F5IGl0IGludGVyYWN0cyB3aXRoIHRoZSBwaHlzaWNhbCBhbmQgdGhlIHZpc3VhbCB3b3JsZFxyXG4gICAgKi9cclxuICAgIGV4cG9ydCBlbnVtIEJPRFlfVFlQRSB7XHJcbiAgICAgICAgLyoqIFRoZSBib2R5IGlnbm9yZXMgdGhlIGhpZXJhcmNoeSBvZiB0aGUgcmVuZGVyIGdyYXBoLCBpcyBjb21wbGV0ZWx5IGNvbnRyb2xsZWQgIGJ5IHBoeXNpY3MgYW5kIHRha2VzIGl0cyBub2RlIHdpdGggaXQgICovXHJcbiAgICAgICAgRFlOQU1JQywgLy8gPSBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQyxcclxuICAgICAgICAvKiogVGhlIGJvZHkgaWdub3JlcyB0aGUgaGllcmFyY2h5IG9mIHRoZSByZW5kZXIgZ3JhcGgsIGlzIGNvbXBsZXRlbHkgaW1tb3ZlYmxlIGFuZCBrZWVwcyBpdHMgbm9kZSBmcm9tIG1vdmluZyAgKi9cclxuICAgICAgICBTVEFUSUMsIC8vID0gT0lNTy5SaWdpZEJvZHlUeXBlLlNUQVRJQyxcclxuICAgICAgICAvKiogVGhlIGJvZHkgaXMgY29udHJvbGxlZCBieSBpdHMgbm9kZSBhbmQgbW92ZXMgd2l0aCBpdCwgd2hpbGUgaXQgaW1wYWN0cyB0aGUgcGh5c2ljYWwgd29ybGQgZS5nLiBieSBjb2xsaXNpb25zICovXHJcbiAgICAgICAgS0lORU1BVElDIC8vID0gT0lNTy5SaWdpZEJvZHlUeXBlLktJTkVNQVRJQ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEaWZmZXJlbnQgdHlwZXMgb2YgY29sbGlkZXIgc2hhcGVzLCB3aXRoIGRpZmZlcmVudCBvcHRpb25zIGluIHNjYWxpbmcgQk9YID0gVmVjdG9yMyhsZW5ndGgsIGhlaWdodCwgZGVwdGgpLFxyXG4gICAgKiBTUEhFUkUgPSBWZWN0b3IzKGRpYW1ldGVyLCB4LCB4KSwgQ0FQU1VMRSA9IFZlY3RvcjMoZGlhbWV0ZXIsIGhlaWdodCwgeCksIENZTElOREVSID0gVmVjdG9yMyhkaWFtZXRlciwgaGVpZ2h0LCB4KSxcclxuICAgICogQ09ORSA9IFZlY3RvcihkaWFtZXRlciwgaGVpZ2h0LCB4KSwgUFlSQU1JRCA9IFZlY3RvcjMobGVuZ3RoLCBoZWlnaHQsIGRlcHRoKTsgeCA9PSB1bnVzZWQuXHJcbiAgICAqIENPTlZFWCA9IENvbXBvbmVudE1lc2ggbmVlZHMgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSBSQiBQcm9wZXJ0eSBjb252ZXhNZXNoLCB0aGUgcG9pbnRzIG9mIHRoYXQgY29tcG9uZW50IGFyZSB1c2VkIHRvIGNyZWF0ZSBhIGNvbGxpZGVyIHRoYXQgbWF0Y2hlcyxcclxuICAgICogdGhlIGNsb3Nlc3QgcG9zc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhhdCBmb3JtLCBpbiBmb3JtIG9mIGEgaHVsbC4gQ29udmV4IGlzIGV4cGVyaW1lbnRhbCBhbmQgY2FuIHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgd2hlbiB2ZXJ0aWNlc1xyXG4gICAgKiBhcmUgdG9vIGNsb3NlIHRvIG9uZSBhbm90aGVyIGFuZCB0aGUgZ2l2ZW4gdmVydGljZXMgZG8gbm90IGZvcm0gYSBpbiBpdHNlbGYgY2xvc2VkIHNoYXBlIGFuZCBoYXZpbmcgYSBnZW51cyBvZiAwIChubyBob2xlcykuIFZlcnRpY2VzIGluIHRoZSBDb21wb25lbnRNZXNoIGNhbiBiZSBzY2FsZWQgZGlmZmVyZW50bHkgXHJcbiAgICAqIGZvciB0ZXh0dXJpbmcvbm9ybWFsIG9yIG90aGVyIHJlYXNvbnMsIHNvIHRoZSBjb2xsaWRlciBtaWdodCBiZSBvZmYgY29tcGFyZWQgdG8gdGhlIHZpc3VhbCBzaGFwZSwgdGhpcyBjYW4gYmUgY29ycmVjdGVkIGJ5IGNoYW5naW5nIHRoZSBwaXZvdCBzY2FsZSBvZiB0aGUgQ29tcG9uZW50UmlnaWRib2R5LiAgXHJcbiAgICAqL1xyXG4gICAgZXhwb3J0IGVudW0gQ09MTElERVJfVFlQRSB7XHJcbiAgICAgICAgQ1VCRSxcclxuICAgICAgICBTUEhFUkUsXHJcbiAgICAgICAgQ0FQU1VMRSxcclxuICAgICAgICBDWUxJTkRFUixcclxuICAgICAgICBDT05FLFxyXG4gICAgICAgIFBZUkFNSUQsXHJcbiAgICAgICAgQ09OVkVYXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERpc3BsYXlpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IGRpZmZlcmVudCBwaHlzaWMgZmVhdHVyZXMuIERlZmF1bHQgPSBKT0lOVFNfQU5EX0NPTExJREVSLiAqL1xyXG4gICAgZXhwb3J0IGVudW0gUEhZU0lDU19ERUJVR01PREUge1xyXG4gICAgICAgIE5PTkUsXHJcbiAgICAgICAgQ09MTElERVJTLFxyXG4gICAgICAgIEpPSU5UU19BTkRfQ09MTElERVIsXHJcbiAgICAgICAgQk9VTkRJTkdfQk9YRVMsXHJcbiAgICAgICAgQ09OVEFDVFMsXHJcbiAgICAgICAgUEhZU0lDX09CSkVDVFNfT05MWVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbmZvIGFib3V0IFJheWNhc3RzIHNob3QgZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0uICovXHJcbiAgICBleHBvcnQgY2xhc3MgUmF5SGl0SW5mbyB7XHJcbiAgICAgICAgcHVibGljIGhpdDogYm9vbGVhbjtcclxuICAgICAgICBwdWJsaWMgaGl0RGlzdGFuY2U6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgaGl0UG9pbnQ6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgICBwdWJsaWMgcmlnaWRib2R5Q29tcG9uZW50OiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAgICAgcHVibGljIGhpdE5vcm1hbDogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICAgIHB1YmxpYyByYXlFbmQ6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgICBwdWJsaWMgcmF5T3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICAgICAgICB0aGlzLmhpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmhpdERpc3RhbmNlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5oaXRQb2ludC5yZWN5Y2xlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaWRib2R5Q29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oaXROb3JtYWwucmVjeWNsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJheU9yaWdpbi5yZWN5Y2xlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmF5RW5kLnJlY3ljbGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdlbmVyYWwgc2V0dGluZ3MgZm9yIHRoZSBwaHlzaWMgc2ltdWxhdGlvbiBhbmQgdGhlIGRlYnVnIG9mIGl0LiAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIFBoeXNpY3NTZXR0aW5ncyB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKF9kZWZhdWx0Q29sbGlzaW9uR3JvdXA6IG51bWJlciwgX2RlZmF1bHRDb2xsaXNpb25NYXNrOiBudW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPSU1PID09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdENvbGxpc2lvbkdyb3VwID0gX2RlZmF1bHRDb2xsaXNpb25Hcm91cDtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0Q29sbGlzaW9uTWFzayA9IF9kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBDaGFuZ2UgaWYgcmlnaWRib2RpZXMgYXJlIGFibGUgdG8gc2xlZXAgKGRvbid0IGJlIGNvbnNpZGVyZWQgaW4gcGh5c2ljYWwgY2FsY3VsYXRpb25zKSB3aGVuIHRoZWlyIG1vdmVtZW50IGlzIGJlbG93IGEgdGhyZXNob2xkLiBEZWFjdGl2YXRpb24gaXMgZGVjcmVhc2luZyBwZXJmb3JtYW5jZSBmb3IgbWlub3IgYWR2YW50YWdlIGluIHByZWNpc2lvbi4gKi9cclxuICAgICAgICBnZXQgZGlzYWJsZVNsZWVwaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRpc2FibGVTbGVlcGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGRpc2FibGVTbGVlcGluZyhfdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICAgICAgT0lNTy5TZXR0aW5nLmRpc2FibGVTbGVlcGluZyA9IF92YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqIFNsZWVwaW5nIFRocmVzaG9sZCBmb3IgTW92ZW1lbnQgVmVsb2N0aXkuICovXHJcbiAgICAgICAgZ2V0IHNsZWVwaW5nVmVsb2NpdHlUaHJlc2hvbGQoKTogbnVtYmVyIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5zbGVlcGluZ1ZlbG9jaXR5VGhyZXNob2xkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgICAgICBPSU1PLlNldHRpbmcuc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZCA9IF92YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBTbGVlcGluZyBUaHJlc2hvbGQgZm9yIFJvdGF0aW9uIFZlbG9jaXR5LiAqL1xyXG4gICAgICAgIGdldCBzbGVlcGluZ0FuZ3VsYXJWZWxvY2l0eVRocmVzaG9sZCgpOiBudW1iZXIge1xyXG4gICAgICAgICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLnNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgc2xlZXBpbmdBbmd1bGFyVmVsb2NpdHlUaHJlc2hvbGQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICAgICAgT0lNTy5TZXR0aW5nLnNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkID0gX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIFRocmVzaG9sZCBob3cgbG9uZyB0aGUgUmlnaWRib2R5IG11c3QgYmUgYmVsb3cvYWJvdmUgdGhlIHRocmVzaG9sZCB0byBjb3VudCBhcyBzbGVlcGluZy4gKi9cclxuICAgICAgICBnZXQgc2xlZXBpbmdUaW1lVGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICAgICAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuc2xlZXBpbmdUaW1lVGhyZXNob2xkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgc2xlZXBpbmdUaW1lVGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIE9JTU8uU2V0dGluZy5zbGVlcGluZ1RpbWVUaHJlc2hvbGQgPSBfdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiogRXJyb3IgdGhyZXNob2xkLiBEZWZhdWx0IGlzIDAuMDUuIFRoZSBoaWdoZXIgdGhlIG1vcmUgbGlrZWx5IGNvbGxpc2lvbnMgZ2V0IGRldGVjdGVkIGJlZm9yZSBhY3R1YWwgaW1wYWN0IGF0IGhpZ2ggc3BlZWRzIGJ1dCBpdCdzIHZpc3VhbGx5IGxlc3MgYWNjdXJhdGUuICovXHJcbiAgICAgICAgZ2V0IGRlZmF1bHRDb2xsaXNpb25NYXJnaW4oKTogbnVtYmVyIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0R0pLTWFyZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgZGVmYXVsdENvbGxpc2lvbk1hcmdpbihfdGhpY2tuZXNzOiBudW1iZXIpIHtcclxuICAgICAgICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRHSktNYXJnaW4gPSBfdGhpY2tuZXNzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIFRoZSBkZWZhdWx0IGFwcGxpZWQgZnJpY3Rpb24gYmV0d2VlbiB0d28gcmlnaWRib2RpZXMgd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZS4gSG93IG11Y2ggdmVsb2NpdHkgaXMgc2xvd2VkIGRvd24gd2hlbiBtb3ZpbmcgYWNjcm9zcyB0aGlzIHN1cmZhY2UuICovXHJcbiAgICAgICAgZ2V0IGRlZmF1bHRGcmljdGlvbigpOiBudW1iZXIge1xyXG4gICAgICAgICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRGcmljdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGRlZmF1bHRGcmljdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEZyaWN0aW9uID0gX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIEJvdW5jaW5lc3Mgb2YgcmlnaWRib2RpZXMuIEhvdyBtdWNoIG9mIHRoZSBpbXBhY3QgaXMgcmVzdGl0dXRlZC4gKi9cclxuICAgICAgICBnZXQgZGVmYXVsdFJlc3RpdHV0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgICAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdFJlc3RpdHV0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgZGVmYXVsdFJlc3RpdHV0aW9uKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0UmVzdGl0dXRpb24gPSBfdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiogR3JvdXBzIHRoZSBkZWZhdWx0IHJpZ2lkYm9keSB3aWxsIGNvbGxpZGUgd2l0aC4gU2V0IGl0IGxpa2U6IChQSFlTSUNTX0dST1VQLkRFRkFVTFQgfCBQSFlTSUNTX0dST1VQLkdST1VQXzEgfCBQSFlTSUNTX0dST1VQLkdST1VQXzIgfCBQSFlTSUNTX0dST1VQLkdST1VQXzMpIFxyXG4gICAgICAgICAqIHRvIGNvbGxpZGUgd2l0aCBtdWx0aXBsZSBncm91cHMuIERlZmF1bHQgaXMgY29sbGlzaW9uIHdpdGggZXZlcnl0aGluZyBidXQgdHJpZ2dlcnMuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBnZXQgZGVmYXVsdENvbGxpc2lvbk1hc2soKTogbnVtYmVyIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGRlZmF1bHRDb2xsaXNpb25NYXNrKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Q29sbGlzaW9uTWFzayA9IF92YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBUaGUgZ3JvdXAgdGhhdCB0aGlzIHJpZ2lkYm9keSBiZWxvbmdzIHRvLiBEZWZhdWx0IGlzIHRoZSBERUZBVUxUIEdyb3VwIHdoaWNoIG1lYW5zIGl0cyBqdXN0IGEgbm9ybWFsIFJpZ2lkYm9keSBub3QgYSB0cmlnZ2VyIG5vciBhbnl0aGluZyBzcGVjaWFsLiAqL1xyXG4gICAgICAgIGdldCBkZWZhdWx0Q29sbGlzaW9uR3JvdXAoKTogQ09MTElTSU9OX0dST1VQIHtcclxuICAgICAgICAgICAgcmV0dXJuIDxDT0xMSVNJT05fR1JPVVA+T0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25Hcm91cDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGRlZmF1bHRDb2xsaXNpb25Hcm91cChfdmFsdWU6IENPTExJU0lPTl9HUk9VUCkge1xyXG4gICAgICAgICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdENvbGxpc2lvbkdyb3VwID0gX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIENoYW5nZSB0aGUgdHlwZSBvZiBqb2ludCBzb2x2ZXIgYWxnb3JpdGhtLiBEZWZhdWx0IEl0ZXJhdGl2ZSA9PSAwLCBpcyBmYXN0ZXIgYnV0IGxlc3Mgc3RhYmxlLiBEaXJlY3QgPT0gMSwgc2xvdyBidXQgbW9yZSBzdGFibGUsIHJlY29tbWVuZGVkIGZvciBjb21wbGV4IGpvaW50IHdvcmsuIENoYW5nZSB0aGlzIHNldHRpbmcgb25seSBhdCB0aGUgc3RhcnQgb2YgeW91ciBnYW1lLiAqL1xyXG4gICAgICAgIGdldCBkZWZhdWx0Q29uc3RyYWludFNvbHZlclR5cGUoKTogbnVtYmVyIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0Sm9pbnRDb25zdHJhaW50U29sdmVyVHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0IGRlZmF1bHRDb25zdHJhaW50U29sdmVyVHlwZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50Q29uc3RyYWludFNvbHZlclR5cGUgPSBfdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiogVGhlIGNvcnJlY3Rpb24gYWxnb3JpdGhtIHVzZWQgdG8gY29ycmVjdCBwaHlzaWNzIGNhbGN1bGF0aW9ucy4gQ2hhbmdlIHRoaXMgb25seSBhdCB0aGUgYmVnaW5uaW5nIG9mIHlvdXIgZ2FtZS4gRWFjaCBoYXMgZGlmZmVyZW50IGFwcHJvYWNoZXMsIHNvIGlmIHlvdSBoYXZlIHByb2JsZW1zIHRlc3QgYW5vdGhlclxyXG4gICAgICAgICAqICBEZWZhdWx0IDAgPSBCYXVtZ2FydGUgKGZhc3QgYnV0IGxlc3MgY29ycmVjdCBpbmR1Y2VzIHNvbWUgZW5lcmd5IGVycm9ycyksIDEgPSBTcGxpdC1JbXB1bHNlIChmYXN0IGFuZCBubyBlbmdlcnkgZXJyb3JzLCBidXQgbW9yZSBpbmFjY3VyYXRlIGZvciBqb2ludHMpLCAyID0gTm9uLWxpbmVhciBHYXVzcyBTZWlkZWwgKHNsb3dlc3QgYnV0IG1vc3QgYWNjdXJhdGUpKi9cclxuICAgICAgICBnZXQgZGVmYXVsdENvcnJlY3Rpb25BbGdvcml0aG0oKTogbnVtYmVyIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0Sm9pbnRQb3NpdGlvbkNvcnJlY3Rpb25BbGdvcml0aG07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldCBkZWZhdWx0Q29ycmVjdGlvbkFsZ29yaXRobShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50UG9zaXRpb25Db3JyZWN0aW9uQWxnb3JpdGhtID0gX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIFRoZSBwcmVjaXNpb24gb2YgdGhlIHNpbXVsYXRpb24gaW4gZm9ybSBvZiBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGUgc2ltdWxhdGlvbnMgcnVucyB0aHJvdWdoIHVudGlsIGl0IGFjY2VwdHMgdGhlIHJlc3VsdC5cclxuICAgICAgICAgKiAgMTAgRGVmYXVsdCAtIEhpZ2hlciBtZWFucyBtb3JlIHByZWNpc2lvbiBidXQgcmVzdWx0cyBpbiBhIHBlcmZvcm1hbmNlIGRlY3JlYXNlLiBUaGlzIGhlbHBzIGVzcGVjaWFsbHkgd2l0aCBqb2ludHMsXHJcbiAgICAgICAgICogYnV0IGFsc28gdGhlIGdlbmVyYWwgc3RhYmlsaXR5IG9mIHRoZSBzaW11bGF0aW9uIGR1ZSB0byBzaW11bGF0aW9uIHN0ZXBzIGJlaW5nIHJlY2hlY2tlZCBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgYmVpbmcgc2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCBzb2x2ZXJJdGVyYXRpb25zKCk6IG51bWJlciB7XHJcbiAgICAgICAgICAgIHJldHVybiBQaHlzaWNzLmFjdGl2ZUluc3RhbmNlLmdldE9pbW9Xb3JsZCgpLmdldE51bVBvc2l0aW9uSXRlcmF0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXQgc29sdmVySXRlcmF0aW9ucyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgICAgICBQaHlzaWNzLmFjdGl2ZUluc3RhbmNlLmdldE9pbW9Xb3JsZCgpLnNldE51bVBvc2l0aW9uSXRlcmF0aW9ucyhfdmFsdWUpO1xyXG4gICAgICAgICAgICBQaHlzaWNzLmFjdGl2ZUluc3RhbmNlLmdldE9pbW9Xb3JsZCgpLnNldE51bVZlbG9jaXR5SXRlcmF0aW9ucyhfdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQWN0cyBhcyB0aGUgcGh5c2ljYWwgcmVwcmVzZW50YXRpb24gb2YgYSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIHtAbGluayBOb2RlfSdzLlxyXG4gICAgICogVGhlIHR5cGUgb2YgY29ubmNldGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBzdWJjbGFzc2VzIGxpa2UgcHJpc21hdGljIGpvaW50LCBjeWxpbmRlciBqb2ludCBldGMuXHJcbiAgICAgKiBBIFJpZ2lkYm9keSBvbiB0aGUge0BsaW5rIE5vZGV9IHRoYXQgdGhpcyBjb21wb25lbnQgaXMgYWRkZWQgdG8gaXMgbmVlZGVkLiBTZXR0aW5nIHRoZSBjb25uZWN0ZWRSaWdpZGJvZHkgYW5kXHJcbiAgICAgKiBpbml0aWFsaXppbmcgdGhlIGNvbm5lY3Rpb24gY3JlYXRlcyBhIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0aGVtLiBUaGlzIGRpZmZlcnMgZnJvbSBhIGNvbm5lY3Rpb24gdGhyb3VnaCBoaWVyYXJjaHlcclxuICAgICAqIGluIHRoZSBub2RlIHN0cnVjdHVyZSBvZiBmdWRnZS4gSm9pbnRzIGNhbiBoYXZlIGRpZmZlcmVudCBET0YncyAoRGVncmVlcyBPZiBGcmVlZG9tKSwgMSBBeGlzIHRoYXQgY2FuIGVpdGhlciB0d2lzdCBvciBzd2luZyBpcyBhIGRlZ3JlZSBvZiBmcmVlZG9tLlxyXG4gICAgICogQSBqb2ludCB0eXBpY2FsbHkgY29uc2lzdHMgb2YgYSBtb3RvciB0aGF0IGxpbWl0cyBtb3ZlbWVudC9yb3RhdGlvbiBvciBpcyBhY3Rpdmx5IHRyeWluZyB0byBtb3ZlIHRvIGEgbGltaXQuIEFuZCBhIHNwcmluZyB3aGljaCBkZWZpbmVzIHRoZSByaWdpZGl0eS5cclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjBcclxuICAgICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBKb2ludCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBKb2ludCA9IEpvaW50O1xyXG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgSm9pbnRbXSA9IFtdO1xyXG5cclxuICAgICNpZEJvZHlBbmNob3I6IG51bWJlciA9IDA7XHJcbiAgICAjaWRCb2R5VGllZDogbnVtYmVyID0gMDtcclxuICAgICNib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAjYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuXHJcbiAgICAjY29ubmVjdGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAjYW5jaG9yOiBPSU1PLlZlYzM7XHJcbiAgICAjaW50ZXJuYWxDb2xsaXNpb246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAjYnJlYWtGb3JjZTogbnVtYmVyID0gMDtcclxuICAgICNicmVha1RvcnF1ZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjbmFtZUNoaWxkVG9Db25uZWN0OiBzdHJpbmc7XHJcblxyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRKb2ludCk7XHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gZmFsc2U7IC8vTXVsdGlwbGUgam9pbnRzIGNhbiBiZSBhdHRhY2hlZCB0byBvbmUgTm9kZVxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGpvaW50OiBPSU1PLkpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGNvbmZpZzogT0lNTy5Kb2ludENvbmZpZztcclxuXHJcblxyXG4gICAgLyoqIENyZWF0ZSBhIGpvaW50IGNvbm5lY3Rpb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIFJpZ2lkYm9keUNvbXBvbmVudHMuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmJvZHlBbmNob3IgPSBfYm9keUFuY2hvcjtcclxuICAgICAgdGhpcy5ib2R5VGllZCA9IF9ib2R5VGllZDtcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAgVGVsbCB0aGUgcGh5c2ljcyB0aGF0IHRoZXJlIGlzIGEgbmV3IGpvaW50IGFuZCBvbiB0aGUgcGh5c2ljcyBzdGFydCB0aGUgYWN0dWFsIGpvaW50IGlzIGZpcnN0IGNyZWF0ZWQuIFZhbHVlcyBjYW4gYmUgc2V0IGJ1dCB0aGVcclxuICAgICAgICBhY3R1YWwgY29uc3RyYWludCBhaW4ndCBleGlzdGVudCB1bnRpbCB0aGUgZ2FtZSBzdGFydHNcclxuICAgICAgKi9cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5obmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWdpc3RlclN1YmNsYXNzKF9zdWJjbGFzczogdHlwZW9mIEpvaW50KTogbnVtYmVyIHsgcmV0dXJuIEpvaW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIC8qKiBHZXQvU2V0IHRoZSBmaXJzdCBDb21wb25lbnRSaWdpZGJvZHkgb2YgdGhpcyBjb25uZWN0aW9uLiBJdCBzaG91bGQgYWx3YXlzIGJlIHRoZSBvbmUgdGhhdCB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0b28gaW4gdGhlIHNjZW5lVHJlZS4gKi9cclxuICAgIHB1YmxpYyBnZXQgYm9keUFuY2hvcigpOiBDb21wb25lbnRSaWdpZGJvZHkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jYm9keUFuY2hvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGJvZHlBbmNob3IoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpIHtcclxuICAgICAgdGhpcy4jaWRCb2R5QW5jaG9yID0gX2NtcFJCICE9IG51bGwgPyBfY21wUkIuaWQgOiAtMTtcclxuICAgICAgdGhpcy4jYm9keUFuY2hvciA9IF9jbXBSQjtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0L1NldCB0aGUgc2Vjb25kIENvbXBvbmVudFJpZ2lkYm9keSBvZiB0aGlzIGNvbm5lY3Rpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGJvZHlUaWVkKCk6IENvbXBvbmVudFJpZ2lkYm9keSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNib2R5VGllZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYm9keVRpZWQoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpIHtcclxuICAgICAgdGhpcy4jaWRCb2R5VGllZCA9IF9jbXBSQiAhPSBudWxsID8gX2NtcFJCLmlkIDogLTE7XHJcbiAgICAgIHRoaXMuI2JvZHlUaWVkID0gX2NtcFJCO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGV4YWN0IHBvc2l0aW9uIHdoZXJlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBhcmUgY29ubmVjdGVkLiBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGFuY2hvcigpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2FuY2hvci54LCB0aGlzLiNhbmNob3IueSwgdGhpcy4jYW5jaG9yLnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBhbmNob3IoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2FuY2hvciA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW1vdW50IG9mIGZvcmNlIG5lZWRlZCB0byBicmVhayB0aGUgSk9JTlQsIHdoaWxlIHJvdGF0aW5nLCBpbiBOZXd0b24uIDAgZXF1YWxzIHVuYnJlYWthYmxlIChkZWZhdWx0KSBcclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJyZWFrVG9ycXVlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNicmVha1RvcnF1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYnJlYWtUb3JxdWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jYnJlYWtUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QnJlYWtUb3JxdWUodGhpcy4jYnJlYWtUb3JxdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFtb3VudCBvZiBmb3JjZSBuZWVkZWQgdG8gYnJlYWsgdGhlIEpPSU5ULCBpbiBOZXd0b24uIDAgZXF1YWxzIHVuYnJlYWthYmxlIChkZWZhdWx0KSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBicmVha0ZvcmNlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNicmVha0ZvcmNlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBicmVha0ZvcmNlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2JyZWFrRm9yY2UgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QnJlYWtGb3JjZSh0aGlzLiNicmVha0ZvcmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBJZiB0aGUgdHdvIGNvbm5lY3RlZCBSaWdpZEJvZGllcyBjb2xsaWRlIHdpdGggZWF0aCBvdGhlci4gKERlZmF1bHQgPSBmYWxzZSlcclxuICAgICAgKiBPbiBhIHdlbGRpbmcgam9pbnQgdGhlIGNvbm5lY3RlZCBib2RpZXMgc2hvdWxkIG5vdCBiZSBjb2xsaWRpbmcgd2l0aCBlYWNoIG90aGVyLFxyXG4gICAgICAqIGZvciBiZXN0IHJlc3VsdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpbnRlcm5hbENvbGxpc2lvbigpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29sbGlzaW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBpbnRlcm5hbENvbGxpc2lvbihfdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy4jaW50ZXJuYWxDb2xsaXNpb24gPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy4jaW50ZXJuYWxDb2xsaXNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb25uZWN0Q2hpbGQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNuYW1lQ2hpbGRUb0Nvbm5lY3QgPSBfbmFtZTtcclxuICAgICAgaWYgKCF0aGlzLm5vZGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGNoaWxkcmVuOiBOb2RlW10gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRyZW5CeU5hbWUoX25hbWUpO1xyXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09IDEpXHJcbiAgICAgICAgdGhpcy5jb25uZWN0Tm9kZShjaGlsZHJlbi5wb3AoKSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gYXQgJHt0aGlzLm5vZGUubmFtZX0gZmFpbHMgdG8gY29ubmVjdCBjaGlsZCB3aXRoIG5vbiBleGlzdGVudCBvciBhbWJpZ291cyBuYW1lICR7X25hbWV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvbm5lY3ROb2RlKF9ub2RlOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGlmICghX25vZGUgfHwgIXRoaXMubm9kZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBEZWJ1Zy5mdWRnZShgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNvbm5lY3RlZCAke3RoaXMubm9kZS5uYW1lfSBhbmQgJHtfbm9kZS5uYW1lfWApO1xyXG5cclxuICAgICAgbGV0IGNvbm5lY3RCb2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KTtcclxuICAgICAgbGV0IHRoaXNCb2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSk7XHJcblxyXG4gICAgICBpZiAoIWNvbm5lY3RCb2R5IHx8ICF0aGlzQm9keSkge1xyXG4gICAgICAgIERlYnVnLndhcm4oYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBhdCAke3RoaXMubm9kZS5uYW1lfSBmYWlscyBkdWUgdG8gbWlzc2luZyByaWdpZGJvZGllcyBvbiAke3RoaXMubm9kZS5uYW1lfSBvciAke19ub2RlLm5hbWV9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJvZHlBbmNob3IgPSB0aGlzQm9keTtcclxuICAgICAgdGhpcy5ib2R5VGllZCA9IGNvbm5lY3RCb2R5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVjayBpZiBjb25uZWN0aW9uIGlzIGRpcnR5LCBzbyB3aGVuIGVpdGhlciByYiBpcyBjaGFuZ2VkIGRpc2Nvbm5lY3QgYW5kIHJlY29ubmVjdC4gSW50ZXJuYWxseSB1c2VkIG5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiAqL1xyXG4gICAgcHVibGljIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29ubmVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6aW5nIGFuZCBjb25uZWN0aW5nIHRoZSB0d28gcmlnaWRib2RpZXMgd2l0aCB0aGUgY29uZmlndXJlZCBqb2ludCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29ubmVjdCgpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuI2Nvbm5lY3RlZCA9PSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLiNpZEJvZHlBbmNob3IgPT0gLTEgfHwgdGhpcy4jaWRCb2R5VGllZCA9PSAtMSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuI25hbWVDaGlsZFRvQ29ubmVjdClcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0Q2hpbGQodGhpcy4jbmFtZUNoaWxkVG9Db25uZWN0KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29uc3RydWN0Sm9pbnQoKTtcclxuICAgICAgICB0aGlzLiNjb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWRkSm9pbnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdGluZyB0aGUgdHdvIHJpZ2lkYm9kaWVzIGFuZCByZW1vdmluZyB0aGVtIGZyb20gdGhlIHBoeXNpY3Mgc3lzdGVtLFxyXG4gICAgICogaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgdGhlIHBoeXNpY3Mgc3lzdGVtLiBObyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc2Nvbm5lY3QoKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLiNjb25uZWN0ZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSm9pbnQoKTtcclxuICAgICAgICB0aGlzLiNjb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgSm9pbnQgdXNlZCBieSB0aGUgcGh5c2ljcyBlbmdpbmUuIFVzZWQgaW50ZXJuYWxseSBubyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqIE9ubHkgdG8gYmUgdXNlZCB3aGVuIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBub3QgYWRkZWQgd2l0aGluIEZ1ZGdlIGlzIG5lZWRlZC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2ltb0pvaW50KCk6IE9JTU8uSm9pbnQge1xyXG4gICAgICByZXR1cm4gdGhpcy5qb2ludDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5hbmNob3IgPSB0aGlzLmFuY2hvci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmFuY2hvciA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYW5jaG9yKTtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLmNvbm5lY3RDaGlsZChfc2VyaWFsaXphdGlvbi5uYW1lQ2hpbGRUb0Nvbm5lY3QpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYW5jaG9yID0gdGhpcy5hbmNob3IuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLmFuY2hvcikgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYW5jaG9yKSkpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuYW5jaG9yO1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5uYW1lQ2hpbGRUb0Nvbm5lY3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuY29ubmVjdENoaWxkKF9tdXRhdG9yLm5hbWVDaGlsZFRvQ29ubmVjdCk7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIG5hbWVDaGlsZFRvQ29ubmVjdDogdGhpcy4jbmFtZUNoaWxkVG9Db25uZWN0LFxyXG4gICAgICAgIGludGVybmFsQ29sbGlzaW9uOiB0aGlzLiNpbnRlcm5hbENvbGxpc2lvbixcclxuICAgICAgICBicmVha0ZvcmNlOiB0aGlzLiNicmVha0ZvcmNlLFxyXG4gICAgICAgIGJyZWFrVG9ycXVlOiB0aGlzLiNicmVha1RvcnF1ZVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XHJcbiAgICAgIHRoaXMubXV0YXRlQmFzZShfbXV0YXRvciwgW1wiaW50ZXJuYWxDb2xsaXNpb25cIiwgXCJicmVha0ZvcmNlXCIsIFwiYnJlYWtUb3JxdWVcIl0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zcHJpbmdEYW1wZXI7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5qb2ludDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLm1vdG9yO1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGVsbCB0aGUgRnVkZ2VQaHlzaWNzIHN5c3RlbSB0aGF0IHRoaXMgam9pbnQgbmVlZHMgdG8gYmUgaGFuZGxlZCBpbiB0aGUgbmV4dCBmcmFtZS4gKi9cclxuICAgIHByb3RlY3RlZCBkaXJ0eVN0YXR1cygpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy5jaGFuZ2VKb2ludFN0YXR1cyh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWRkSm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuYWRkSm9pbnQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlbW92ZUpvaW50KCk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLnJlbW92ZUpvaW50KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCguLi5fY29uZmlnUGFyYW1zOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBsZXQgcG9zQm9keUFuY2hvcjogVmVjdG9yMyA9IHRoaXMuYm9keUFuY2hvci5ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uOyAvL1NldHRpbmcgdGhlIGFuY2hvciBwb3NpdGlvbiBsb2NhbGx5IGZyb20gdGhlIGZpcnN0IHJpZ2lkYm9keVxyXG4gICAgICBsZXQgd29ybGRBbmNob3I6IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMocG9zQm9keUFuY2hvci54ICsgdGhpcy4jYW5jaG9yLngsIHBvc0JvZHlBbmNob3IueSArIHRoaXMuI2FuY2hvci55LCBwb3NCb2R5QW5jaG9yLnogKyB0aGlzLiNhbmNob3Iueik7XHJcblxyXG4gICAgICAvLyBAdHMtaWdub3JlICAgIC8vIHVuZm9ydHVuYXRlbHksIG1ldGhvZCBpbml0IGlzIG5vdCBhIG1lbWJlciBvZiB0aGUgYmFzZSBjbGFzcyBPSU1PLkpvaW50Q29uZmlnXHJcbiAgICAgIHRoaXMuY29uZmlnLmluaXQodGhpcy4jYm9keUFuY2hvci5nZXRPaW1vUmlnaWRib2R5KCksIHRoaXMuI2JvZHlUaWVkLmdldE9pbW9SaWdpZGJvZHkoKSwgd29ybGRBbmNob3IsIC4uLl9jb25maWdQYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjb25maWd1cmVKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5qb2ludC5zZXRCcmVha0ZvcmNlKHRoaXMuYnJlYWtGb3JjZSk7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QnJlYWtUb3JxdWUodGhpcy5icmVha1RvcnF1ZSk7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy4jaW50ZXJuYWxDb2xsaXNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBkZWxldGVGcm9tTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvciwgX2RlbGV0ZTogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBrZXkgaW4gX2RlbGV0ZSlcclxuICAgICAgICBkZWxldGUgX211dGF0b3Jba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhuZEV2ZW50ID0gKF9ldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRVZFTlQuQ09NUE9ORU5UX0FERDpcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkRJU0NPTk5FQ1RfSk9JTlQsICgpID0+IHsgdGhpcy5kaXNjb25uZWN0KCk7IHRoaXMuZGlydHlTdGF0dXMoKTsgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9SRU1PVkU6XHJcbiAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5ESVNDT05ORUNUX0pPSU5ULCAoKSA9PiB7IHRoaXMuZGlzY29ubmVjdCgpOyB0aGlzLmRpcnR5U3RhdHVzKCk7IH0sIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVKb2ludCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGpvaW50cyBvcGVyYXRpbmcgd2l0aCBleGFjdGx5IG9uZSBheGlzXHJcbiAgICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEpvaW50QXhpYWwgZXh0ZW5kcyBKb2ludCB7XHJcblxyXG4gICAgLy9JbnRlcm5hbCBWYXJpYWJsZXNcclxuXHJcbiAgICAjbWF4TW90b3I6IG51bWJlciA9IDEwO1xyXG4gICAgI21pbk1vdG9yOiBudW1iZXIgPSAtMTA7XHJcbiAgICAjbW90b3JTcGVlZDogbnVtYmVyID0gMDtcclxuICAgICNheGlzOiBPSU1PLlZlYzM7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5OiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0RhbXBpbmc6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIHNwcmluZ0RhbXBlcjogT0lNTy5TcHJpbmdEYW1wZXI7XHJcblxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIGN5bGluZHJpY2FsIGpvaW50IGJldHdlZW4gdHdvIENvbXBvbmVudFJpZ2lkYm9kaWVzIG1vdmluZyBvbiBvbmUgYXhpcyBhbmQgcm90YXRpbmcgYXJvdW5kIGFub3RoZXIgYm91bmQgb24gYSBsb2NhbCBhbmNob3Jwb2ludC4gKi9cclxuICAgIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xyXG4gICAgICB0aGlzLmF4aXMgPSBfYXhpcztcclxuICAgICAgdGhpcy5hbmNob3IgPSBfbG9jYWxBbmNob3I7XHJcbiAgICAgIHRoaXMubWluTW90b3IgPSAtMTA7XHJcbiAgICAgIHRoaXMubWF4TW90b3IgPSAxMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXHJcbiAgICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBheGlzKCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy4jYXhpcy54LCB0aGlzLiNheGlzLnksIHRoaXMuI2F4aXMueik7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGF4aXMoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtYXhNb3RvcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4TW90b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBtYXhNb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhNb3RvciA9IF92YWx1ZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAoPE9JTU8uUHJpc21hdGljSm9pbnQ+PHVua25vd24+dGhpcy5qb2ludCkuZ2V0TGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWU7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtaW5Nb3RvcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluTW90b3I7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1pbk1vdG9yKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21pbk1vdG9yID0gX3ZhbHVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD48dW5rbm93bj50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmcgPSBfdmFsdWU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgKDxPSU1PLlByaXNtYXRpY0pvaW50Pjx1bmtub3duPnRoaXMuam9pbnQpLmdldFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSB0YXJnZXQgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtb3RvclNwZWVkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclNwZWVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbW90b3JTcGVlZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3k7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgKDxPSU1PLlByaXNtYXRpY0pvaW50PnRoaXMuam9pbnQpLmdldFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5heGlzID0gdGhpcy5heGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuYXhpcyA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpcyk7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5heGlzKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLmF4aXMgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYXhpcykpKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmF4aXM7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLmF4aXMgPSB0aGlzLmF4aXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgICNnZXRNdXRhdG9yID0gKCk6IE11dGF0b3IgPT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICBzcHJpbmdEYW1waW5nOiB0aGlzLiNzcHJpbmdEYW1waW5nLFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeTogdGhpcy4jc3ByaW5nRnJlcXVlbmN5LFxyXG4gICAgICAgIG1heE1vdG9yOiB0aGlzLiNtYXhNb3RvcixcclxuICAgICAgICBtaW5Nb3RvcjogdGhpcy4jbWluTW90b3IsXHJcbiAgICAgICAgbW90b3JTcGVlZDogdGhpcy4jbW90b3JTcGVlZFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJzcHJpbmdEYW1waW5nXCIsIFwic3ByaW5nRnJlcXVlbmN5XCIsIFwibWF4TW90b3JcIiwgXCJtaW5Nb3RvclwiLCBcIm1vdG9yU3BlZWRcIl0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zcHJpbmdEYW1wZXIgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy4jc3ByaW5nRnJlcXVlbmN5LCB0aGlzLiNzcHJpbmdEYW1waW5nKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy4jYXhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnL0RlYnVnVGFyZ2V0LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWcvRGVidWcudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudC9FdmVudC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNlcmlhbGl6YXRpb24vTXV0YWJsZS50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNlcmlhbGl6YXRpb24vU2VyaWFsaXplci50c1wiLz4gXHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb21wb25lbnQvQ29tcG9uZW50LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUmVjeWNsZS9SZWN5Y2FibGVBcnJheS50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJXZWJHTC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJJbmplY3RvclRleHR1cmUudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJHcmFwaC9Ob2RlLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGh5c2ljcy9IZWxwZXJzUGh5c2ljcy50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBoeXNpY3MvSm9pbnQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQaHlzaWNzL0pvaW50QXhpYWwudHNcIi8+XHJcblxyXG4vL2dsb2JhbCBmdW5jdGlvbnNcclxuZnVuY3Rpb24gaWZOdW1iZXIoX2NoZWNrOiBudW1iZXIsIF9kZWZhdWx0OiBudW1iZXIpOiBudW1iZXIge1xyXG4gIHJldHVybiB0eXBlb2YgX2NoZWNrID09IFwidW5kZWZpbmVkXCIgPyBfZGVmYXVsdCA6IF9jaGVjaztcclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBBbmltYXRpb25TdHJ1Y3R1cmUgdGhhdCB0aGUgQW5pbWF0aW9uIHVzZXMgdG8gbWFwIHRoZSBTZXF1ZW5jZXMgdG8gdGhlIEF0dHJpYnV0ZXMuXHJcbiAgICogQnVpbHQgb3V0IG9mIGEge0BsaW5rIE5vZGV9J3Mgc2VyaWFsc2F0aW9uLCBpdCBzd2FwcyB0aGUgdmFsdWVzIHdpdGgge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlfXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogU2VyaWFsaXphdGlvbiB8IEFuaW1hdGlvblNlcXVlbmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBBbiBhc3NvY2lhdGl2ZSBhcnJheSBtYXBwaW5nIG5hbWVzIG9mIGxhYmxlcyB0byB0aW1lc3RhbXBzLlxyXG4gICogTGFiZWxzIG5lZWQgdG8gYmUgdW5pcXVlIHBlciBBbmltYXRpb24uXHJcbiAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkxhYmVsIHtcclxuICAgIFtuYW1lOiBzdHJpbmddOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IEFuaW1hdGlvbiBFdmVudCBUcmlnZ2Vyc1xyXG4gICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25FdmVudFRyaWdnZXIge1xyXG4gICAgW25hbWU6IHN0cmluZ106IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVybmFsbHkgdXNlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIHZhcmlvdXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgYW5kIGV2ZW50cy5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZW51bSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUge1xyXG4gICAgLyoqRGVmYXVsdDogZm9yd2FyZCwgY29udGlub3VzICovXHJcbiAgICBOT1JNQUwsXHJcbiAgICAvKipiYWNrd2FyZCwgY29udGlub3VzICovXHJcbiAgICBSRVZFUlNFLFxyXG4gICAgLyoqZm9yd2FyZCwgcmFzdGVyZWQgKi9cclxuICAgIFJBU1RFUkVELFxyXG4gICAgLyoqYmFja3dhcmQsIHJhc3RlcmVkICovXHJcbiAgICBSQVNURVJFRFJFVkVSU0VcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGRpZmZlcmVudCBwbGF5bW9kZXMgdGhlIGFuaW1hdGlvbiB1c2VzIHRvIHBsYXkgYmFjayBpdHMgYW5pbWF0aW9uLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBBTklNQVRJT05fUExBWU1PREUge1xyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIGluIGEgbG9vcDogaXQgcmVzdGFydHMgb25jZSBpdCBoaXQgdGhlIGVuZC4qL1xyXG4gICAgTE9PUCxcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBvbmNlIGFuZCBzdG9wcyBhdCB0aGUgbGFzdCBrZXkvZnJhbWUqL1xyXG4gICAgUExBWU9OQ0UsXHJcbiAgICAvKipQbGF5cyBhbmltYXRpb24gb25jZSBhbmQgc3RvcHMgb24gdGhlIGZpcnN0IGtleS9mcmFtZSAqL1xyXG4gICAgUExBWU9OQ0VTVE9QQUZURVIsXHJcbiAgICAvKipQbGF5cyBhbmltYXRpb24gbGlrZSBMT09QLCBidXQgYmFja3dhcmRzLiovXHJcbiAgICBSRVZFUlNFTE9PUCxcclxuICAgIC8qKkNhdXNlcyB0aGUgYW5pbWF0aW9uIG5vdCB0byBwbGF5IGF0IGFsbC4gVXNlZnVsIGZvciBqdW1waW5nIHRvIHZhcmlvdXMgcG9zaXRpb25zIGluIHRoZSBhbmltYXRpb24gd2l0aG91dCBwcm9jZWVkaW5nIGluIHRoZSBhbmltYXRpb24uKi9cclxuICAgIFNUT1BcclxuICAgIC8vVE9ETzogYWRkIGFuIElOSEVSSVQgYW5kIGEgUElOR1BPTkcgbW9kZVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX1BMQVlCQUNLIHtcclxuICAgIC8vVE9ETzogYWRkIGFuIGluLWRlcHRoIGRlc2NyaXB0aW9uIG9mIHdoYXQgaGFwcGVucyB0byB0aGUgYW5pbWF0aW9uIChhbmQgZXZlbnRzKSBkZXBlbmRpbmcgb24gdGhlIFBsYXliYWNrLiBVc2UgR3JhcGhzIHRvIGV4cGxhaW4uXHJcbiAgICAvKipDYWxjdWxhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIGF0IHRoZSBleGFjdCBwb3NpdGlvbiBvZiB0aW1lLiBJZ25vcmVzIEZQUyB2YWx1ZSBvZiBhbmltYXRpb24uKi9cclxuICAgIFRJTUVCQVNFRF9DT05USU5PVVMsXHJcbiAgICAvKipMaW1pdHMgdGhlIGNhbGN1bGF0aW9uIG9mIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHRoZSBGUFMgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbi4gU2tpcHMgZnJhbWVzIGlmIG5lZWRlZC4qL1xyXG4gICAgVElNRUJBU0VEX1JBU1RFUkVEX1RPX0ZQUyxcclxuICAgIC8qKiBBZHZhbmNlcyB0aGUgdGltZSBlYWNoIGZyYW1lIGFjY29yZGluZyB0byB0aGUgRlBTIHZhbHVlIG9mIHRoZSBhbmltYXRpb24sIGlnbm9yaW5nIHRoZSBhY3R1YWwgZHVyYXRpb24gb2YgdGhlIGZyYW1lcy4gRG9lc24ndCBza2lwIGFueSBmcmFtZXMuKi9cclxuICAgIEZSQU1FQkFTRURcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuaW1hdGlvbiBDbGFzcyB0byBob2xkIGFsbCByZXF1aXJlZCBPYmplY3RzIHRoYXQgYXJlIHBhcnQgb2YgYW4gQW5pbWF0aW9uLlxyXG4gICAqIEFsc28gaG9sZHMgZnVuY3Rpb25zIHRvIHBsYXkgc2FpZCBBbmltYXRpb24uXHJcbiAgICogQ2FuIGJlIGFkZGVkIHRvIGEgTm9kZSBhbmQgcGxheWVkIHRocm91Z2gge0BsaW5rIENvbXBvbmVudEFuaW1hdG9yfS5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIGlkUmVzb3VyY2U6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHRvdGFsVGltZTogbnVtYmVyID0gMDtcclxuICAgIGxhYmVsczogQW5pbWF0aW9uTGFiZWwgPSB7fTtcclxuICAgIC8vIHN0ZXBzUGVyU2Vjb25kOiBudW1iZXIgPSAxMDtcclxuICAgIGFuaW1hdGlvblN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlO1xyXG4gICAgZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgIHByaXZhdGUgZnJhbWVzUGVyU2Vjb25kOiBudW1iZXIgPSA2MDtcclxuXHJcbiAgICAvLyBwcm9jZXNzZWQgZXZlbnRsaXN0IGFuZCBhbmltYXRpb24gc3RydWN1dHJlcyBmb3IgcGxheWJhY2suXHJcbiAgICBwcml2YXRlIGV2ZW50c1Byb2Nlc3NlZDogTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPiA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+KCk7XHJcbiAgICBwcml2YXRlIGFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQ6IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvblN0cnVjdHVyZT4gPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9hbmltU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fSwgX2ZwczogbnVtYmVyID0gNjApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlID0gX2FuaW1TdHJ1Y3R1cmU7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5zZXQoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTCwgX2FuaW1TdHJ1Y3R1cmUpO1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcHM7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGdldExhYmVscygpOiBFbnVtZXJhdG9yIHtcclxuICAgICAgLy9UT0RPOiB0aGlzIGFjdHVhbGx5IG5lZWRzIHRlc3RpbmdcclxuICAgICAgbGV0IGVuOiBFbnVtZXJhdG9yID0gbmV3IEVudW1lcmF0b3IodGhpcy5sYWJlbHMpO1xyXG4gICAgICByZXR1cm4gZW47XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGZwcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGZwcyhfZnBzOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfZnBzO1xyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBcIk11dGF0b3JcIiB3aXRoIHRoZSBpbmZvcm1hdGlvbiB0byBhcHBseSB0byB0aGUge0BsaW5rIE5vZGV9IHRoZSB7QGxpbmsgQ29tcG9uZW50QW5pbWF0b3J9IGlzIGF0dGFjaGVkIHRvIHdpdGgge0BsaW5rIE5vZGUuYXBwbHlBbmltYXRpb259LlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBhbmltYXRpb24gY3VycmVudGx5IGlzIGF0XHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSBhbmltYXRpb24gaXMgc3VwcG9zZWQgdG8gYmUgcGxheWluZyBiYWNrLiA+MCA9PSBmb3J3YXJkLCAwID09IHN0b3AsIDwwID09IGJhY2t3YXJkc1xyXG4gICAgICogQHBhcmFtIF9wbGF5YmFjayBUaGUgcGxheWJhY2ttb2RlIHRoZSBhbmltYXRpb24gaXMgc3VwcG9zZWQgdG8gYmUgY2FsY3VsYXRlZCB3aXRoLlxyXG4gICAgICogQHJldHVybnMgYSBcIk11dGF0b3JcIiB0byBhcHBseS5cclxuICAgICAqL1xyXG4gICAgZ2V0TXV0YXRlZChfdGltZTogbnVtYmVyLCBfZGlyZWN0aW9uOiBudW1iZXIsIF9wbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLKTogTXV0YXRvciB7ICAgICAvL1RPRE86IGZpbmQgYSBiZXR0ZXIgbmFtZSBmb3IgdGhpc1xyXG4gICAgICBsZXQgbTogTXV0YXRvciA9IHt9O1xyXG4gICAgICBsZXQgYW5pbWF0aW9uU3RydWN0dXJlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEU7XHJcblxyXG4gICAgICBpZiAoX3BsYXliYWNrID09IEFOSU1BVElPTl9QTEFZQkFDSy5USU1FQkFTRURfQ09OVElOT1VTKVxyXG4gICAgICAgIGFuaW1hdGlvblN0cnVjdHVyZSA9IF9kaXJlY3Rpb24gPCAwID8gQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UgOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgYW5pbWF0aW9uU3RydWN0dXJlID0gX2RpcmVjdGlvbiA8IDAgPyBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFIDogQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEO1xyXG5cclxuICAgICAgbSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKHRoaXMuZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKGFuaW1hdGlvblN0cnVjdHVyZSksIF90aW1lKTtcclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgbmFtZXMgb2YgdGhlIGV2ZW50cyB0aGUge0BsaW5rIENvbXBvbmVudEFuaW1hdG9yfSBuZWVkcyB0byBmaXJlIGJldHdlZW4gX21pbiBhbmQgX21heC4gXHJcbiAgICAgKiBAcGFyYW0gX21pbiBUaGUgbWluaW11bSB0aW1lIChpbmNsdXNpdmUpIHRvIGNoZWNrIGJldHdlZW5cclxuICAgICAqIEBwYXJhbSBfbWF4IFRoZSBtYXhpbXVtIHRpbWUgKGV4Y2x1c2l2ZSkgdG8gY2hlY2sgYmV0d2VlblxyXG4gICAgICogQHBhcmFtIF9wbGF5YmFjayBUaGUgcGxheWJhY2sgbW9kZSB0byBjaGVjayBpbi4gSGFzIGFuIGVmZmVjdCBvbiB3aGVuIHRoZSBFdmVudHMgYXJlIGZpcmVkLiBcclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBpcyBzdXBwb3NlZCB0byBydW4gaW4uID4wID09IGZvcndhcmQsIDAgPT0gc3RvcCwgPDAgPT0gYmFja3dhcmRzXHJcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB3aXRoIHRoZSBuYW1lcyBvZiB0aGUgY3VzdG9tIGV2ZW50cyB0byBmaXJlLlxyXG4gICAgICovXHJcbiAgICBnZXRFdmVudHNUb0ZpcmUoX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIsIF9wbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLLCBfZGlyZWN0aW9uOiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICAgIGxldCBldmVudExpc3Q6IHN0cmluZ1tdID0gW107XHJcbiAgICAgIGxldCBtaW5TZWN0aW9uOiBudW1iZXIgPSBNYXRoLmZsb29yKF9taW4gLyB0aGlzLnRvdGFsVGltZSk7XHJcbiAgICAgIGxldCBtYXhTZWN0aW9uOiBudW1iZXIgPSBNYXRoLmZsb29yKF9tYXggLyB0aGlzLnRvdGFsVGltZSk7XHJcbiAgICAgIF9taW4gPSBfbWluICUgdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgIF9tYXggPSBfbWF4ICUgdGhpcy50b3RhbFRpbWU7XHJcblxyXG4gICAgICB3aGlsZSAobWluU2VjdGlvbiA8PSBtYXhTZWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VHJpZ2dlcnM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHRoaXMuZ2V0Q29ycmVjdEV2ZW50TGlzdChfZGlyZWN0aW9uLCBfcGxheWJhY2spO1xyXG4gICAgICAgIGlmIChtaW5TZWN0aW9uID09IG1heFNlY3Rpb24pIHtcclxuICAgICAgICAgIGV2ZW50TGlzdCA9IGV2ZW50TGlzdC5jb25jYXQodGhpcy5jaGVja0V2ZW50c0JldHdlZW4oZXZlbnRUcmlnZ2VycywgX21pbiwgX21heCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBldmVudExpc3QgPSBldmVudExpc3QuY29uY2F0KHRoaXMuY2hlY2tFdmVudHNCZXR3ZWVuKGV2ZW50VHJpZ2dlcnMsIF9taW4sIHRoaXMudG90YWxUaW1lKSk7XHJcbiAgICAgICAgICBfbWluID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluU2VjdGlvbisrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZXZlbnRMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBFdmVudCB0byB0aGUgTGlzdCBvZiBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChuZWVkcyB0byBiZSB1bmlxdWUgcGVyIEFuaW1hdGlvbikuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZXZlbnQgKGluIG1pbGxpc2Vjb25kcykuXHJcbiAgICAgKi9cclxuICAgIHNldEV2ZW50KF9uYW1lOiBzdHJpbmcsIF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5ldmVudHNbX25hbWVdID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBldmVudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIF9uYW1lIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRXZlbnQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbX25hbWVdO1xyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIChSZS0pQ2FsY3VsYXRlIHRoZSB0b3RhbCB0aW1lIG9mIHRoZSBBbmltYXRpb24uIENhbGN1bGF0aW9uLWhlYXZ5LCB1c2Ugb25seSBpZiBhY3R1YWxseSBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVRvdGFsVGltZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xyXG4gICAgICB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yVGltZSh0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lIHRvIHVzZSBmb3IgYW5pbWF0aW9uIHNhbXBsaW5nIHdoZW4gYXBwbHlpbmcgYSBwbGF5bW9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TW9kYWxUaW1lKF90aW1lOiBudW1iZXIsIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFLCBfdGltZVN0b3A6IG51bWJlciA9IF90aW1lKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgLy8gcmV0dXJuIHRoaXMubG9jYWxUaW1lLmdldE9mZnNldCgpO1xyXG4gICAgICAgICAgcmV0dXJuIF90aW1lU3RvcDtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZT05DRTpcclxuICAgICAgICAgIGlmIChfdGltZSA+PSB0aGlzLnRvdGFsVGltZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lIC0gMC4wMTsgICAgIC8vVE9ETzogdGhpcyBtaWdodCBjYXVzZSBzb21lIGlzc3Vlc1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFU1RPUEFGVEVSOlxyXG4gICAgICAgICAgaWYgKF90aW1lID49IHRoaXMudG90YWxUaW1lKVxyXG4gICAgICAgICAgICAvLyBUT0RPOiByZXR1cm4gX3RpbWVTdG9wIGluc3RlYWQ/XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZSArIDAuMDE7ICAgICAvL1RPRE86IHRoaXMgbWlnaHQgY2F1c2Ugc29tZSBpc3N1ZXNcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX3RpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBzaG91bGQgY3VycmVudGx5IGJlIHBsYXlpbmcgaW4uXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlIHRpbWUgYXQgd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25cclxuICAgICAqIEByZXR1cm5zIDEgaWYgZm9yd2FyZCwgMCBpZiBzdG9wLCAtMSBpZiBiYWNrd2FyZHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbGN1bGF0ZURpcmVjdGlvbihfdGltZTogbnVtYmVyLCBfcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERSk6IG51bWJlciB7XHJcbiAgICAgIHN3aXRjaCAoX3BsYXltb2RlKSB7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuU1RPUDpcclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIC8vIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBJTkdQT05HOlxyXG4gICAgICAgIC8vICAgaWYgKE1hdGguZmxvb3IoX3RpbWUgLyB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUpICUgMiA9PSAwKVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gMTtcclxuICAgICAgICAvLyAgIGVsc2VcclxuICAgICAgICAvLyAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlJFVkVSU0VMT09QOlxyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFOlxyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlPTkNFU1RPUEFGVEVSOlxyXG4gICAgICAgICAgaWYgKF90aW1lID49IHRoaXMudG90YWxUaW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBsYWJlbHM6IHt9LFxyXG4gICAgICAgIGV2ZW50czoge30sXHJcbiAgICAgICAgZnBzOiB0aGlzLmZyYW1lc1BlclNlY29uZCxcclxuICAgICAgICAvLyBzcHM6IHRoaXMuc3RlcHNQZXJTZWNvbmRcclxuICAgICAgfTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmxhYmVscykge1xyXG4gICAgICAgIHMubGFiZWxzW25hbWVdID0gdGhpcy5sYWJlbHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmV2ZW50cykge1xyXG4gICAgICAgIHMuZXZlbnRzW25hbWVdID0gdGhpcy5ldmVudHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXNhdGlvbih0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSk7XHJcbiAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuaWRSZXNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gX3NlcmlhbGl6YXRpb24uZnBzO1xyXG4gICAgICAvLyB0aGlzLnN0ZXBzUGVyU2Vjb25kID0gX3NlcmlhbGl6YXRpb24uc3BzO1xyXG4gICAgICB0aGlzLmxhYmVscyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9zZXJpYWxpemF0aW9uLmxhYmVscykge1xyXG4gICAgICAgIHRoaXMubGFiZWxzW25hbWVdID0gX3NlcmlhbGl6YXRpb24ubGFiZWxzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZXZlbnRzID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX3NlcmlhbGl6YXRpb24uZXZlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudHNbbmFtZV0gPSBfc2VyaWFsaXphdGlvbi5ldmVudHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQgPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPigpO1xyXG5cclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSBhd2FpdCB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpc2F0aW9uKF9zZXJpYWxpemF0aW9uLmFuaW1hdGlvblN0cnVjdHVyZSk7XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQgPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPigpO1xyXG5cclxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IudG90YWxUaW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYW4gQW5pbWF0aW9uU3RydWN0dXJlIGFuZCByZXR1cm5zIHRoZSBTZXJpYWxpemF0aW9uIG9mIHNhaWQgU3RydWN0dXJlLlxyXG4gICAgICogQHBhcmFtIF9zdHJ1Y3R1cmUgVGhlIEFuaW1hdGlvbiBTdHJ1Y3R1cmUgYXQgdGhlIGN1cnJlbnQgbGV2ZWwgdG8gdHJhbnNmb3JtIGludG8gdGhlIFNlcmlhbGl6YXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgZmlsbGVkIFNlcmlhbGl6YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpc2F0aW9uKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgbmV3U2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBuZXdTZXJpYWxpemF0aW9uW25dID0gX3N0cnVjdHVyZVtuXS5zZXJpYWxpemUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3U2VyaWFsaXphdGlvbltuXSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpc2F0aW9uKDxBbmltYXRpb25TdHJ1Y3R1cmU+X3N0cnVjdHVyZVtuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdTZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYSBTZXJpYWxpemF0aW9uIHRvIGNyZWF0ZSBhIG5ldyBBbmltYXRpb25TdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb24gVGhlIHNlcmlhbGl6YXRpb24gdG8gdHJhbnNmZXIgaW50byBhbiBBbmltYXRpb25TdHJ1Y3R1cmVcclxuICAgICAqIEByZXR1cm5zIHRoZSBuZXdseSBjcmVhdGVkIEFuaW1hdGlvblN0cnVjdHVyZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyB0cmF2ZXJzZVN0cnVjdHVyZUZvckRlc2VyaWFsaXNhdGlvbihfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8QW5pbWF0aW9uU3RydWN0dXJlPiB7XHJcbiAgICAgIGxldCBuZXdTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgaWYgKF9zZXJpYWxpemF0aW9uW25dLmFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBsZXQgYW5pbVNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IGF3YWl0IGFuaW1TZXEuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bbl0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSBhd2FpdCB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpc2F0aW9uKF9zZXJpYWxpemF0aW9uW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ld1N0cnVjdHVyZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIGxpc3Qgb2YgZXZlbnRzIHRvIGJlIHVzZWQgd2l0aCB0aGVzZSBzZXR0aW5ncy5cclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBpcyBwbGF5aW5nIGluLlxyXG4gICAgICogQHBhcmFtIF9wbGF5YmFjayBUaGUgcGxheWJhY2ttb2RlIHRoZSBhbmltYXRpb24gaXMgcGxheWluZyBpbi5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjb3JyZWN0IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciBPYmplY3QgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Q29ycmVjdEV2ZW50TGlzdChfZGlyZWN0aW9uOiBudW1iZXIsIF9wbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgaWYgKF9wbGF5YmFjayAhPSBBTklNQVRJT05fUExBWUJBQ0suRlJBTUVCQVNFRCkge1xyXG4gICAgICAgIGlmIChfZGlyZWN0aW9uID49IDApIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBBbmltYXRpb25TdHJ1Y3R1cmUgdG8gdHVybiBpdCBpbnRvIHRoZSBcIk11dGF0b3JcIiB0byByZXR1cm4gdG8gdGhlIENvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBfc3RydWN0dXJlIFRoZSBzdHJjdXR1cmUgdG8gdHJhdmVyc2VcclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSB0byB3cml0ZSB0aGUgYW5pbWF0aW9uIG51bWJlcnMgaW50by5cclxuICAgICAqIEByZXR1cm5zIFRoZSBcIk11dGF0b3JcIiBmaWxsZWQgd2l0aCB0aGUgY29ycmVjdCB2YWx1ZXMgYXQgdGhlIGdpdmVuIHRpbWUuIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcihfc3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUsIF90aW1lOiBudW1iZXIpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG5ld011dGF0b3I6IE11dGF0b3IgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfc3RydWN0dXJlKSB7XHJcbiAgICAgICAgaWYgKF9zdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbmV3TXV0YXRvcltuXSA9ICg8QW5pbWF0aW9uU2VxdWVuY2U+X3N0cnVjdHVyZVtuXSkuZXZhbHVhdGUoX3RpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdNdXRhdG9yW25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dLCBfdGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdNdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBjdXJyZW50IEFuaW1hdGlvblN0cmN1dHVyZSB0byBmaW5kIHRoZSB0b3RhbFRpbWUgb2YgdGhpcyBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgc3RydWN0dXJlIHRvIHRyYXZlcnNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBsZXQgc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlID0gPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl07XHJcbiAgICAgICAgICBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgc2VxdWVuY2VUaW1lOiBudW1iZXIgPSBzZXF1ZW5jZS5nZXRLZXkoc2VxdWVuY2UubGVuZ3RoIC0gMSkuVGltZTtcclxuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSBzZXF1ZW5jZVRpbWUgPiB0aGlzLnRvdGFsVGltZSA/IHNlcXVlbmNlVGltZSA6IHRoaXMudG90YWxUaW1lO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yVGltZSg8QW5pbWF0aW9uU3RydWN0dXJlPl9zdHJ1Y3R1cmVbbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGUgZXhpc3RhbmNlIG9mIHRoZSByZXF1ZXN0ZWQge0BsaW5rIEFuaW1hdGlvblN0cmN1dHVyZX0gYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBAcGFyYW0gX3R5cGUgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdHVyZSB0byBnZXRcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0ZWQge0BsaW5rIEFuaW1hdGlvblN0cnVjdHVyZV1dXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0UHJvY2Vzc2VkQW5pbWF0aW9uU3RydWN0dXJlKF90eXBlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUpOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5oYXMoX3R5cGUpKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgICBsZXQgYWU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTDpcclxuICAgICAgICAgICAgYWUgPSB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUsIHRoaXMuY2FsY3VsYXRlUmV2ZXJzZVNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUsIHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0U6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSksIHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5zZXQoX3R5cGUsIGFlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLmdldChfdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBleGlzdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZCB7QGxpbmsgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyfSBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqIEBwYXJhbSBfdHlwZSBUaGUgdHlwZSBvZiBBbmltYXRpb25FdmVudFRyaWdnZXIgdG8gZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25FdmVudFRyaWdnZXJdXVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldFByb2Nlc3NlZEV2ZW50VHJpZ2dlcihfdHlwZTogQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgaWYgKCF0aGlzLmV2ZW50c1Byb2Nlc3NlZC5oYXMoX3R5cGUpKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgICBsZXQgZXY6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTDpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmV2ZW50cztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuY2FsY3VsYXRlUmV2ZXJzZUV2ZW50VHJpZ2dlcnModGhpcy5ldmVudHMpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKHRoaXMuZXZlbnRzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0U6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnModGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLnNldChfdHlwZSwgZXYpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5nZXQoX3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIGV4aXN0aW5nIHN0cnVjdHVyZSB0byBhcHBseSBhIHJlY2FsY3VsYXRpb24gZnVuY3Rpb24gdG8gdGhlIEFuaW1hdGlvblN0cnVjdHVyZSB0byBzdG9yZSBpbiBhIG5ldyBTdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX29sZFN0cnVjdHVyZSBUaGUgb2xkIHN0cnVjdHVyZSB0byB0cmF2ZXJzZVxyXG4gICAgICogQHBhcmFtIF9mdW5jdGlvblRvVXNlIFRoZSBmdW5jdGlvbiB0byB1c2UgdG8gcmVjYWxjdWxhdGVkIHRoZSBzdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBBbmltYXRpb24gU3RydWN0dXJlIHdpdGggdGhlIHJlY2FsdWxhdGVkIEFuaW1hdGlvbiBTZXF1ZW5jZXMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUoX29sZFN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlLCBfZnVuY3Rpb25Ub1VzZTogRnVuY3Rpb24pOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgICBsZXQgbmV3U3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfb2xkU3RydWN0dXJlKSB7XHJcbiAgICAgICAgaWYgKF9vbGRTdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbmV3U3RydWN0dXJlW25dID0gX2Z1bmN0aW9uVG9Vc2UoX29sZFN0cnVjdHVyZVtuXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUoPEFuaW1hdGlvblN0cnVjdHVyZT5fb2xkU3RydWN0dXJlW25dLCBfZnVuY3Rpb25Ub1VzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdTdHJ1Y3R1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmV2ZXJzZWQgQW5pbWF0aW9uIFNlcXVlbmNlIG91dCBvZiBhIGdpdmVuIFNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9zZXF1ZW5jZSBUaGUgc2VxdWVuY2UgdG8gY2FsY3VsYXRlIHRoZSBuZXcgc2VxdWVuY2Ugb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmV2ZXJzZWQgU2VxdWVuY2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSZXZlcnNlU2VxdWVuY2UoX3NlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSk6IEFuaW1hdGlvblNlcXVlbmNlIHtcclxuICAgICAgbGV0IHNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBvbGRLZXk6IEFuaW1hdGlvbktleSA9IF9zZXF1ZW5jZS5nZXRLZXkoaSk7XHJcbiAgICAgICAgbGV0IGtleTogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleSh0aGlzLnRvdGFsVGltZSAtIG9sZEtleS5UaW1lLCBvbGRLZXkuVmFsdWUsIG9sZEtleS5TbG9wZU91dCwgb2xkS2V5LlNsb3BlSW4sIG9sZEtleS5Db25zdGFudCk7XHJcbiAgICAgICAgc2VxLmFkZEtleShrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmFzdGVyZWQge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlfSBvdXQgb2YgYSBnaXZlbiBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfc2VxdWVuY2UgVGhlIHNlcXVlbmNlIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IHNlcXVlbmNlIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJhc3RlcmVkIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJhc3RlcmVkU2VxdWVuY2UoX3NlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSk6IEFuaW1hdGlvblNlcXVlbmNlIHtcclxuICAgICAgbGV0IHNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgbGV0IGZyYW1lVGltZTogbnVtYmVyID0gMTAwMCAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy50b3RhbFRpbWU7IGkgKz0gZnJhbWVUaW1lKSB7XHJcbiAgICAgICAgbGV0IGtleTogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleShpLCBfc2VxdWVuY2UuZXZhbHVhdGUoaSksIDAsIDAsIHRydWUpO1xyXG4gICAgICAgIHNlcS5hZGRLZXkoa2V5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZXZlcnNlZCB7QGxpbmsgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyfSBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIG9uZS4gIFxyXG4gICAgICogQHBhcmFtIF9ldmVudHMgdGhlIGV2ZW50IG9iamVjdCB0byBjYWxjdWxhdGUgdGhlIG5ldyBvbmUgb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmV2ZXJzZWQgZXZlbnQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmV2ZXJzZUV2ZW50VHJpZ2dlcnMoX2V2ZW50czogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgbGV0IGFlOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRzKSB7XHJcbiAgICAgICAgYWVbbmFtZV0gPSB0aGlzLnRvdGFsVGltZSAtIF9ldmVudHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJhc3RlcmVkIHtAbGluayBBbmltYXRpb25FdmVudFRyaWdnZXJ9IG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW4gb25lLiAgXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50cyB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgbmV3IG9uZSBvdXQgb2ZcclxuICAgICAqIEByZXR1cm5zIHRoZSByYXN0ZXJlZCBldmVudCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVSYXN0ZXJlZEV2ZW50VHJpZ2dlcnMoX2V2ZW50czogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyKTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgICAgbGV0IGFlOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgICAgbGV0IGZyYW1lVGltZTogbnVtYmVyID0gMTAwMCAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9ldmVudHMpIHtcclxuICAgICAgICBhZVtuYW1lXSA9IF9ldmVudHNbbmFtZV0gLSAoX2V2ZW50c1tuYW1lXSAlIGZyYW1lVGltZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoaWNoIGV2ZW50cyBsYXkgYmV0d2VlbiB0d28gZ2l2ZW4gdGltZXMgYW5kIHJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBvbmVzIHRoYXQgZG8uXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50VHJpZ2dlcnMgVGhlIGV2ZW50IG9iamVjdCB0byBjaGVjayB0aGUgZXZlbnRzIGluc2lkZSBvZlxyXG4gICAgICogQHBhcmFtIF9taW4gdGhlIG1pbmltdW0gb2YgdGhlIHJhbmdlIHRvIGNoZWNrIGJldHdlZW4gKGluY2x1c2l2ZSlcclxuICAgICAqIEBwYXJhbSBfbWF4IHRoZSBtYXhpbXVtIG9mIHRoZSByYW5nZSB0byBjaGVjayBiZXR3ZWVuIChleGNsdXNpdmUpXHJcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgdGhlIGV2ZW50cyBpbiB0aGUgZ2l2ZW4gcmFuZ2UuIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNoZWNrRXZlbnRzQmV0d2VlbihfZXZlbnRUcmlnZ2VyczogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyLCBfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IHN0cmluZ1tdIHtcclxuICAgICAgbGV0IGV2ZW50c1RvVHJpZ2dlcjogc3RyaW5nW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRUcmlnZ2Vycykge1xyXG4gICAgICAgIGlmIChfbWluIDw9IF9ldmVudFRyaWdnZXJzW25hbWVdICYmIF9ldmVudFRyaWdnZXJzW25hbWVdIDwgX21heCkge1xyXG4gICAgICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2gobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBldmVudHNUb1RyaWdnZXI7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9TZXJpYWxpemVyLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZXMgYmV0d2VlbiB7QGxpbmsgQW5pbWF0aW9uS2V5fXMuXHJcbiAgICogUmVwcmVzZW50ZWQgaW50ZXJuYWxseSBieSBhIGN1YmljIGZ1bmN0aW9uIChgZih4KSA9IGF4wrMgKyBieMKyICsgY3ggKyBkYCkuIFxyXG4gICAqIE9ubHkgbmVlZHMgdG8gYmUgcmVjYWxjdWxhdGVkIHdoZW4gdGhlIGtleXMgY2hhbmdlLCBzbyBhdCBydW50aW1lIGl0IHNob3VsZCBvbmx5IGJlIGNhbGN1bGF0ZWQgb25jZS5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkZ1bmN0aW9uIHtcclxuICAgIHByaXZhdGUgYTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgYjogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgYzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgZDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUga2V5SW46IEFuaW1hdGlvbktleTtcclxuICAgIHByaXZhdGUga2V5T3V0OiBBbmltYXRpb25LZXk7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9rZXlJbjogQW5pbWF0aW9uS2V5LCBfa2V5T3V0OiBBbmltYXRpb25LZXkgPSBudWxsKSB7XHJcbiAgICAgIHRoaXMua2V5SW4gPSBfa2V5SW47XHJcbiAgICAgIHRoaXMua2V5T3V0ID0gX2tleU91dDtcclxuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBhdCB0aGUgZ2l2ZW4gdGltZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgZnVuY3Rpb24gaW4gbWlsbGlzZWNvbmRzLiBXaWxsIGJlIGNvcnJlY3RlZCBmb3Igb2Zmc2V0IGludGVybmFsbHkuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWVcclxuICAgICAqL1xyXG4gICAgZXZhbHVhdGUoX3RpbWU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIF90aW1lIC09IHRoaXMua2V5SW4uVGltZTtcclxuICAgICAgbGV0IHRpbWUyOiBudW1iZXIgPSBfdGltZSAqIF90aW1lO1xyXG4gICAgICBsZXQgdGltZTM6IG51bWJlciA9IHRpbWUyICogX3RpbWU7XHJcbiAgICAgIHJldHVybiB0aGlzLmEgKiB0aW1lMyArIHRoaXMuYiAqIHRpbWUyICsgdGhpcy5jICogX3RpbWUgKyB0aGlzLmQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHNldEtleUluKF9rZXlJbjogQW5pbWF0aW9uS2V5KSB7XHJcbiAgICAgIHRoaXMua2V5SW4gPSBfa2V5SW47XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHNldEtleU91dChfa2V5T3V0OiBBbmltYXRpb25LZXkpIHtcclxuICAgICAgdGhpcy5rZXlPdXQgPSBfa2V5T3V0O1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSlDYWxjdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjdWJpYyBmdW5jdGlvbi5cclxuICAgICAqIFNlZSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMxNzM0NjkvY2FsY3VsYXRlLWN1YmljLWVxdWF0aW9uLWZyb20tdHdvLXBvaW50cy1hbmQtdHdvLXNsb3Blcy12YXJpYWJseVxyXG4gICAgICogYW5kIGh0dHBzOi8vamlya2FkZWxsb3JvLmdpdGh1Yi5pby9GVURHRS9Eb2N1bWVudGF0aW9uL0xvZ3MvMTkwNDEwX05vdGl6ZW5fTFNcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMua2V5SW4pIHtcclxuICAgICAgICB0aGlzLmQgPSB0aGlzLmMgPSB0aGlzLmIgPSB0aGlzLmEgPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMua2V5T3V0IHx8IHRoaXMua2V5SW4uQ29uc3RhbnQpIHtcclxuICAgICAgICB0aGlzLmQgPSB0aGlzLmtleUluLlZhbHVlO1xyXG4gICAgICAgIHRoaXMuYyA9IHRoaXMuYiA9IHRoaXMuYSA9IDA7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgeDE6IG51bWJlciA9IHRoaXMua2V5T3V0LlRpbWUgLSB0aGlzLmtleUluLlRpbWU7XHJcblxyXG4gICAgICB0aGlzLmQgPSB0aGlzLmtleUluLlZhbHVlO1xyXG4gICAgICB0aGlzLmMgPSB0aGlzLmtleUluLlNsb3BlT3V0O1xyXG5cclxuICAgICAgdGhpcy5hID0gKC14MSAqICh0aGlzLmtleUluLlNsb3BlT3V0ICsgdGhpcy5rZXlPdXQuU2xvcGVJbikgLSAyICogdGhpcy5rZXlJbi5WYWx1ZSArIDIgKiB0aGlzLmtleU91dC5WYWx1ZSkgLyAtTWF0aC5wb3coeDEsIDMpO1xyXG4gICAgICB0aGlzLmIgPSAodGhpcy5rZXlPdXQuU2xvcGVJbiAtIHRoaXMua2V5SW4uU2xvcGVPdXQgLSAzICogdGhpcy5hICogTWF0aC5wb3coeDEsIDIpKSAvICgyICogeDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL1NlcmlhbGl6ZXIudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvTXV0YWJsZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHNldCBwb2ludHMgaW4gdGltZSwgdGhlaXIgYWNjb21wYW55aW5nIHZhbHVlcyBhcyB3ZWxsIGFzIHRoZWlyIHNsb3Blcy4gXHJcbiAgICogQWxzbyBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGUge0BsaW5rIEFuaW1hdGlvbkZ1bmN0aW9ufXMgdGhhdCBjb21lIGluIGFuZCBvdXQgb2YgdGhlIHNpZGVzLiBUaGUge0BsaW5rIEFuaW1hdGlvbkZ1bmN0aW9ufXMgYXJlIGhhbmRsZWQgYnkgdGhlIHtAbGluayBBbmltYXRpb25TZXF1ZW5jZX1zLlxyXG4gICAqIFNhdmVkIGluc2lkZSBhbiB7QGxpbmsgQW5pbWF0aW9uU2VxdWVuY2V9LlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uS2V5IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvLyBUT0RPOiBjaGVjayBpZiBmdW5jdGlvbkluIGNhbiBiZSByZW1vdmVkXHJcbiAgICAvKipEb24ndCBtb2RpZnkgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuKi9cclxuICAgIGZ1bmN0aW9uSW46IEFuaW1hdGlvbkZ1bmN0aW9uO1xyXG4gICAgLyoqRG9uJ3QgbW9kaWZ5IHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLiovXHJcbiAgICBmdW5jdGlvbk91dDogQW5pbWF0aW9uRnVuY3Rpb247XHJcbiAgICBcclxuICAgIGJyb2tlbjogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIHRpbWU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgdmFsdWU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgY29uc3RhbnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwcml2YXRlIHNsb3BlSW46IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHNsb3BlT3V0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF90aW1lOiBudW1iZXIgPSAwLCBfdmFsdWU6IG51bWJlciA9IDAsIF9zbG9wZUluOiBudW1iZXIgPSAwLCBfc2xvcGVPdXQ6IG51bWJlciA9IDAsIF9jb25zdGFudDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLnNsb3BlSW4gPSBfc2xvcGVJbjtcclxuICAgICAgdGhpcy5zbG9wZU91dCA9IF9zbG9wZU91dDtcclxuICAgICAgdGhpcy5jb25zdGFudCA9IF9jb25zdGFudDtcclxuXHJcbiAgICAgIHRoaXMuYnJva2VuID0gdGhpcy5zbG9wZUluICE9IC10aGlzLnNsb3BlT3V0O1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0ID0gbmV3IEFuaW1hdGlvbkZ1bmN0aW9uKHRoaXMsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIGNvbXBhcmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSBpbiBhbiBhcnJheSBzb3J0IGZ1bmN0aW9uIHRvIHNvcnQgdGhlIGtleXMgYnkgdGhlaXIgdGltZS5cclxuICAgICAqIEBwYXJhbSBfYSB0aGUgYW5pbWF0aW9uIGtleSB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIF9iIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrIGFnYWluc3RcclxuICAgICAqIEByZXR1cm5zID4wIGlmIGE+YiwgMCBpZiBhPWIsIDwwIGlmIGE8YlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZShfYTogQW5pbWF0aW9uS2V5LCBfYjogQW5pbWF0aW9uS2V5KTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9hLnRpbWUgLSBfYi50aW1lO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBnZXQgVGltZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBUaW1lKF90aW1lOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgVmFsdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IFZhbHVlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0IENvbnN0YW50KCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25zdGFudDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgQ29uc3RhbnQoX2NvbnN0YW50OiBib29sZWFuKSB7XHJcbiAgICAgIHRoaXMuY29uc3RhbnQgPSBfY29uc3RhbnQ7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgU2xvcGVJbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zbG9wZUluO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzZXQgU2xvcGVJbihfc2xvcGU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNsb3BlSW4gPSBfc2xvcGU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgU2xvcGVPdXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2xvcGVPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IFNsb3BlT3V0KF9zbG9wZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2xvcGVPdXQgPSBfc2xvcGU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBzLnRpbWUgPSB0aGlzLnRpbWU7XHJcbiAgICAgIHMudmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICBzLnNsb3BlSW4gPSB0aGlzLnNsb3BlSW47XHJcbiAgICAgIHMuc2xvcGVPdXQgPSB0aGlzLnNsb3BlT3V0O1xyXG4gICAgICBzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudDtcclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy50aW1lID0gX3NlcmlhbGl6YXRpb24udGltZTtcclxuICAgICAgdGhpcy52YWx1ZSA9IF9zZXJpYWxpemF0aW9uLnZhbHVlO1xyXG4gICAgICB0aGlzLnNsb3BlSW4gPSBfc2VyaWFsaXphdGlvbi5zbG9wZUluO1xyXG4gICAgICB0aGlzLnNsb3BlT3V0ID0gX3NlcmlhbGl6YXRpb24uc2xvcGVPdXQ7XHJcbiAgICAgIHRoaXMuY29uc3RhbnQgPSBfc2VyaWFsaXphdGlvbi5jb25zdGFudDtcclxuXHJcbiAgICAgIHRoaXMuYnJva2VuID0gdGhpcy5zbG9wZUluICE9IC10aGlzLnNsb3BlT3V0O1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICB9XHJcblxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBzZXF1ZW5jZSBvZiB7QGxpbmsgQW5pbWF0aW9uS2V5fXMgdGhhdCBpcyBtYXBwZWQgdG8gYW4gYXR0cmlidXRlIG9mIGEge0BsaW5rIE5vZGV9IG9yIGl0cyB7QGxpbmsgQ29tcG9uZW50fXMgaW5zaWRlIHRoZSB7QGxpbmsgQW5pbWF0aW9ufS5cclxuICAgKiBQcm92aWRlcyBmdW5jdGlvbnMgdG8gbW9kaWZ5IHNhaWQga2V5c1xyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uU2VxdWVuY2UgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIHByaXZhdGUga2V5czogQW5pbWF0aW9uS2V5W10gPSBbXTtcclxuXHJcbiAgICBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmtleXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlcyB0aGUgc2VxdWVuY2UgYXQgdGhlIGdpdmVuIHBvaW50IGluIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgdGhlIHBvaW50IGluIHRpbWUgYXQgd2hpY2ggdG8gZXZhbHVhdGUgdGhlIHNlcXVlbmNlIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc2VxdWVuY2UgYXQgdGhlIGdpdmVuIHRpbWUuIDAgaWYgdGhlcmUgYXJlIG5vIGtleXMuXHJcbiAgICAgKi9cclxuICAgIGV2YWx1YXRlKF90aW1lOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5rZXlzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybiAwOyAvL1RPRE86IHNob3VsZG4ndCByZXR1cm4gMCBidXQgc29tZXRoaW5nIGluZGljYXRpbmcgbm8gY2hhbmdlLCBsaWtlIG51bGwuIHByb2JhYmx5IG5lZWRzIHRvIGJlIGNoYW5nZWQgaW4gTm9kZSBhcyB3ZWxsIHRvIGlnbm9yZSBub24tbnVtZXJpYyB2YWx1ZXMgaW4gdGhlIGFwcGx5QW5pbWF0aW9uIGZ1bmN0aW9uXHJcbiAgICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDEgfHwgdGhpcy5rZXlzWzBdLlRpbWUgPj0gX3RpbWUpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1swXS5WYWx1ZTtcclxuXHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLmtleXNbaV0uVGltZSA8PSBfdGltZSAmJiB0aGlzLmtleXNbaSArIDFdLlRpbWUgPiBfdGltZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dC5ldmFsdWF0ZShfdGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmtleXNbdGhpcy5rZXlzLmxlbmd0aCAtIDFdLlZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBrZXkgdG8gdGhlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9rZXkgdGhlIGtleSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgYWRkS2V5KF9rZXk6IEFuaW1hdGlvbktleSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmtleXMucHVzaChfa2V5KTtcclxuICAgICAgdGhpcy5rZXlzLnNvcnQoQW5pbWF0aW9uS2V5LmNvbXBhcmUpO1xyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBnaXZlbiBrZXkgZnJvbSB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVLZXkoX2tleTogQW5pbWF0aW9uS2V5KTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5rZXlzW2ldID09IF9rZXkpIHtcclxuICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIEFuaW1hdGlvbiBLZXkgYXQgdGhlIGdpdmVuIGluZGV4IGZyb20gdGhlIGtleXMuXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IHRoZSB6ZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIHJlbW92ZSB0aGUga2V5XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVtb3ZlZCBBbmltYXRpb25LZXkgaWYgc3VjY2Vzc2Z1bCwgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUtleUF0SW5kZXgoX2luZGV4OiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xyXG4gICAgICBpZiAoX2luZGV4IDwgMCB8fCBfaW5kZXggPj0gdGhpcy5rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBhazogQW5pbWF0aW9uS2V5ID0gdGhpcy5rZXlzW19pbmRleF07XHJcbiAgICAgIHRoaXMua2V5cy5zcGxpY2UoX2luZGV4LCAxKTtcclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICAgIHJldHVybiBhaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBrZXkgZnJvbSB0aGUgc2VxdWVuY2UgYXQgdGhlIGRlc2lyZWQgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IHRoZSB6ZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGdldCB0aGUga2V5XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgQW5pbWF0aW9uS2V5IGF0IHRoZSBpbmRleCBpZiBpdCBleGlzdHMsIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBnZXRLZXkoX2luZGV4OiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xyXG4gICAgICBpZiAoX2luZGV4IDwgMCB8fCBfaW5kZXggPj0gdGhpcy5rZXlzLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5c1tfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAga2V5czogW10sXHJcbiAgICAgICAgYW5pbWF0aW9uU2VxdWVuY2U6IHRydWVcclxuICAgICAgfTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHMua2V5c1tpXSA9IHRoaXMua2V5c1tpXS5zZXJpYWxpemUoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcztcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfc2VyaWFsaXphdGlvbi5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gdGhpcy5rZXlzLnB1c2goPEFuaW1hdGlvbktleT5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmtleXNbaV0pKTtcclxuICAgICAgICBsZXQgazogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleSgpO1xyXG4gICAgICAgIGF3YWl0IGsuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ua2V5c1tpXSk7XHJcbiAgICAgICAgdGhpcy5rZXlzW2ldID0gaztcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy9cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IChyZS0pZ2VuZXJhdGVzIGFsbCBmdW5jdGlvbnMgaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlZ2VuZXJhdGVGdW5jdGlvbnMoKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgZjogQW5pbWF0aW9uRnVuY3Rpb24gPSBuZXcgQW5pbWF0aW9uRnVuY3Rpb24odGhpcy5rZXlzW2ldKTtcclxuICAgICAgICB0aGlzLmtleXNbaV0uZnVuY3Rpb25PdXQgPSBmO1xyXG4gICAgICAgIGlmIChpID09IHRoaXMua2V5cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAvL1RPRE86IGNoZWNrIGlmIHRoaXMgaXMgZXZlbiB1c2VmdWwuIE1heWJlIHVwZGF0ZSB0aGUgcnVuY29uZGl0aW9uIHRvIGxlbmd0aCAtIDEgaW5zdGVhZC4gTWlnaHQgYmUgcmVkdW5kYW50IGlmIGZ1bmN0aW9uSW4gaXMgcmVtb3ZlZCwgc2VlIFRPRE8gaW4gQW5pbWF0aW9uS2V5LlxyXG4gICAgICAgICAgZi5zZXRLZXlPdXQgPSB0aGlzLmtleXNbMF07XHJcbiAgICAgICAgICB0aGlzLmtleXNbMF0uZnVuY3Rpb25JbiA9IGY7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZi5zZXRLZXlPdXQgPSB0aGlzLmtleXNbaSArIDFdO1xyXG4gICAgICAgIHRoaXMua2V5c1tpICsgMV0uZnVuY3Rpb25JbiA9IGY7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBFeHRlbnNpb24gb2YgQXVkaW9CdWZmZXIgd2l0aCBhIGxvYWQgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIGJ1ZmZlciBpbiB0aGUge0BsaW5rIEF1ZGlvTWFuYWdlcn0uZGVmYXVsdCB0byBiZSB1c2VkIHdpdGgge0BsaW5rIENvbXBvbmVudEF1ZGlvfVxyXG4gICAqIEBhdXRob3JzIFRob21hcyBEb3JuZXIsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEF1ZGlvIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBcIkF1ZGlvXCI7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIGJ1ZmZlcjogQXVkaW9CdWZmZXIgPSB1bmRlZmluZWQ7XHJcbiAgICBwdWJsaWMgcGF0aDogVVJMID0gdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSB1cmw6IFJlcXVlc3RJbmZvID0gdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSByZWFkeTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF91cmw/OiBSZXF1ZXN0SW5mbykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICBpZiAoX3VybCkge1xyXG4gICAgICAgIHRoaXMubG9hZChfdXJsKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBfdXJsLnRvU3RyaW5nKCkuc3BsaXQoXCIvXCIpLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGlzUmVhZHkoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlYWR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgdGhlIGF1ZGlvIChtcDMpIGZyb20gdGhlIGdpdmVuIHVybFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkF1ZGlvTG9hZFwiLCBfdXJsKTtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMucGF0aCA9IG5ldyBVUkwodGhpcy51cmwudG9TdHJpbmcoKSwgUHJvamVjdC5iYXNlVVJMKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgd2luZG93LmZldGNoKHRoaXMucGF0aC50b1N0cmluZygpKTtcclxuICAgICAgY29uc3QgYXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgbGV0IGJ1ZmZlcjogQXVkaW9CdWZmZXIgPSBhd2FpdCBBdWRpb01hbmFnZXIuZGVmYXVsdC5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIpO1xyXG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uUkVBRFkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdXJsOiB0aGlzLnVybCxcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkKF9zZXJpYWxpemF0aW9uLnVybCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IHVybDogc3RyaW5nID0gX211dGF0b3IudXJsOyAvLyBzYXZlIHVybCBmb3IgcmVjb25zdHJ1Y3Rpb24gYWZ0ZXIgZXhjbHVzaW9uXHJcbiAgICAgIGlmIChfbXV0YXRvci51cmwgIT0gdGhpcy51cmwudG9TdHJpbmcoKSlcclxuICAgICAgICB0aGlzLmxvYWQoX211dGF0b3IudXJsKTtcclxuICAgICAgLy8gZXhjZXB0IHVybCBmcm9tIG11dGF0b3IgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZ1xyXG4gICAgICBkZWxldGUgKF9tdXRhdG9yLnVybCk7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIC8vIHJlY29uc3RydWN0LCBmb3IgbXV0YXRvciBtYXkgYmUga2VwdCBieSBjYWxsZXJcclxuICAgICAgUmVmbGVjdC5zZXQoX211dGF0b3IsIFwidXJsXCIsIHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy8gZGVsZXRlIF9tdXRhdG9yLmlkUmVzb3VyY2U7IFxyXG4gICAgICBkZWxldGUgX211dGF0b3IucmVhZHk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBFeHRlbmRzIHRoZSBzdGFuZGFyZCBBdWRpb0NvbnRleHQgZm9yIGludGVncmF0aW9uIHdpdGggRlVER0UtZ3JhcGhzLlxyXG4gICAqIENyZWF0ZXMgYSBkZWZhdWx0IG9iamVjdCBhdCBzdGFydHVwIHRvIGJlIGFkZHJlc3NlZCBhcyBBdWRpb01hbmFnZXIgZGVmYXVsdC5cclxuICAgKiBPdGhlciBvYmplY3RzIG9mIHRoaXMgY2xhc3MgbWF5IGJlIGNyZWF0ZSBmb3Igc3BlY2lhbCBwdXJwb3Nlcy5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQXVkaW9NYW5hZ2VyIGV4dGVuZHMgQXVkaW9Db250ZXh0IHtcclxuICAgIC8qKiBUaGUgZGVmYXVsdCBjb250ZXh0IHRoYXQgbWF5IGJlIHVzZWQgdGhyb3VnaG91dCB0aGUgcHJvamVjdCB3aXRob3V0IHRoZSBuZWVkIHRvIGNyZWF0ZSBvdGhlcnMgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZGVmYXVsdDogQXVkaW9NYW5hZ2VyID0gbmV3IEF1ZGlvTWFuYWdlcih7IGxhdGVuY3lIaW50OiBcImludGVyYWN0aXZlXCIsIHNhbXBsZVJhdGU6IDQ0MTAwIH0pO1xyXG4gICAgLyoqIFRoZSBtYXN0ZXIgdm9sdW1lIGFsbCBBdWRpb05vZGVzIGluIHRoZSBjb250ZXh0IHNob3VsZCBhdHRhY2ggdG8gKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBnYWluOiBHYWluTm9kZTtcclxuICAgIHByaXZhdGUgZ3JhcGg6IE5vZGUgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBjbXBMaXN0ZW5lcjogQ29tcG9uZW50QXVkaW9MaXN0ZW5lciA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY29udGV4dE9wdGlvbnM/OiBBdWRpb0NvbnRleHRPcHRpb25zKSB7XHJcbiAgICAgIHN1cGVyKGNvbnRleHRPcHRpb25zKTtcclxuICAgICAgdGhpcy5nYWluID0gdGhpcy5jcmVhdGVHYWluKCk7XHJcbiAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuZGVzdGluYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXN0ZXIgdm9sdW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgdm9sdW1lKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXN0ZXIgdm9sdW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdm9sdW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgRlVER0UtZ3JhcGggdG8gbGlzdGVuIHRvLiBFYWNoIHtAbGluayBDb21wb25lbnRBdWRpb30gaW4gdGhlIGdyYXBoIHdpbGwgY29ubmVjdCB0byB0aGlzIGNvbnRleHRzIG1hc3RlciBnYWluLCBhbGwgb3RoZXJzIGRpc2Nvbm5lY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsaXN0ZW5UbyA9IChfZ3JhcGg6IE5vZGUgfCBudWxsKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmdyYXBoKVxyXG4gICAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xyXG4gICAgICBpZiAoIV9ncmFwaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRoaXMuZ3JhcGggPSBfZ3JhcGg7XHJcbiAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIEZVREdFLWdyYXBoIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEdyYXBoTGlzdGVuaW5nVG8gPSAoKTogTm9kZSA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB7QGxpbmsgQ29tcG9uZW50QXVkaW9MaXN0ZW5lcn0gdGhhdCBzZXJ2ZXMgdGhlIHNwYXRpYWwgbG9jYXRpb24gYW5kIG9yaWVudGF0aW9uIGZvciB0aGlzIGNvbnRleHRzIGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsaXN0ZW5XaXRoID0gKF9jbXBMaXN0ZW5lcjogQ29tcG9uZW50QXVkaW9MaXN0ZW5lciB8IG51bGwpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5jbXBMaXN0ZW5lciA9IF9jbXBMaXN0ZW5lcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHNwYXRpYWwgc2V0dGluZ3Mgb2YgdGhlIEF1ZGlvTm9kZXMgZWZmZWN0ZWQgaW4gdGhlIGN1cnJlbnQgRlVER0UtZ3JhcGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uVVBEQVRFKSk7XHJcbiAgICAgIGlmICh0aGlzLmNtcExpc3RlbmVyKVxyXG4gICAgICAgIHRoaXMuY21wTGlzdGVuZXIudXBkYXRlKHRoaXMubGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIG5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgXHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEVudW1lcmF0b3IgZm9yIGFsbCBwb3NzaWJsZSBPc2NpbGxhdG9yIFR5cGVzXHJcbi8vICAgICAgKi9cclxuLy8gICAgIHR5cGUgT1NDSUxMQVRPUl9UWVBFID0gXCJzaW5lXCIgfCBcInNxdWFyZVwiIHwgXCJzYXd0b290aFwiIHwgXCJ0cmlhbmdsZVwiIHwgXCJjdXN0b21cIjtcclxuXHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEludGVyZmFjZSB0byBjcmVhdGUgQ3VzdG9tIE9zY2lsbGF0b3IgVHlwZXMuXHJcbi8vICAgICAgKiBTdGFydC0vRW5kcG9pbnQgb2YgYSBjdXN0dW0gY3VydmUgZS5nLiBzaW5lIGN1cnZlLlxyXG4vLyAgICAgICogQm90aCBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgaW5iZXR3ZWVuIC0xIGFuZCAxLlxyXG4vLyAgICAgICogQHBhcmFtIHN0YXJ0cG9pbnQgc3RhcnRwb2ludCBvZiBhIGN1cnZlIFxyXG4vLyAgICAgICogQHBhcmFtIGVuZHBvaW50IEVuZHBvaW50IG9mIGEgY3VydmUgXHJcbi8vICAgICAgKi9cclxuLy8gICAgIGludGVyZmFjZSBPc2NpbGxhdG9yV2F2ZSB7XHJcbi8vICAgICAgICAgc3RhcnRwb2ludDogbnVtYmVyO1xyXG4vLyAgICAgICAgIGVuZHBvaW50OiBudW1iZXI7XHJcbi8vICAgICB9XHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEFkZCBhbiB7QGxpbmsgQXVkaW9GaWx0ZXJ9IHRvIGFuIHtAbGluayBBdWRpb11dXHJcbi8vICAgICAgKiBAYXV0aG9ycyBUaG9tYXMgRG9ybmVyLCBIRlUsIDIwMTlcclxuLy8gICAgICAqL1xyXG4vLyAgICAgZXhwb3J0IGNsYXNzIEF1ZGlvT3NjaWxsYXRvciB7XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBhdWRpb09zY2lsbGF0b3I6IE9zY2lsbGF0b3JOb2RlOyBcclxuXHJcbi8vICAgICAgICAgcHJpdmF0ZSBmcmVxdWVuY3k6IG51bWJlcjtcclxuLy8gICAgICAgICBwcml2YXRlIG9zY2lsbGF0b3JUeXBlOiBPU0NJTExBVE9SX1RZUEU7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBvc2NpbGxhdG9yV2F2ZTogUGVyaW9kaWNXYXZlO1xyXG5cclxuLy8gICAgICAgICBwcml2YXRlIGxvY2FsR2FpbjogR2Fpbk5vZGU7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBsb2NhbEdhaW5WYWx1ZTogbnVtYmVyO1xyXG5cclxuLy8gICAgICAgICBjb25zdHJ1Y3RvcihfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX29zY2lsbGF0b3JUeXBlPzogT1NDSUxMQVRPUl9UWVBFKSB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yID0gX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlT3NjaWxsYXRvcigpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpbiA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5vc2NpbGxhdG9yVHlwZSA9IF9vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgaWYgKHRoaXMub3NjaWxsYXRvclR5cGUgIT0gXCJjdXN0b21cIikge1xyXG4vLyAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IudHlwZSA9IHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3NjaWxsYXRvcldhdmUpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5vc2NpbGxhdG9yV2F2ZSk7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0ZSBhIEN1c3RvbSBQZXJpb2RpYyBXYXZlIGZpcnN0IHRvIHVzZSBDdXN0b20gVHlwZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldE9zY2lsbGF0b3JUeXBlKF9vc2NpbGxhdG9yVHlwZTogT1NDSUxMQVRPUl9UWVBFKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIGlmICh0aGlzLm9zY2lsbGF0b3JUeXBlICE9IFwiY3VzdG9tXCIpIHtcclxuLy8gICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnR5cGUgPSB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9zY2lsbGF0b3JXYXZlKSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMub3NjaWxsYXRvcldhdmUpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0T3NjaWxsYXRvclR5cGUoKTogT1NDSUxMQVRPUl9UWVBFIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgY3JlYXRlUGVyaW9kaWNXYXZlKF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzLCBfcmVhbDogT3NjaWxsYXRvcldhdmUsIF9pbWFnOiBPc2NpbGxhdG9yV2F2ZSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICBsZXQgd2F2ZVJlYWw6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbi8vICAgICAgICAgICAgIHdhdmVSZWFsWzBdID0gX3JlYWwuc3RhcnRwb2ludDtcclxuLy8gICAgICAgICAgICAgd2F2ZVJlYWxbMV0gPSBfcmVhbC5lbmRwb2ludDtcclxuXHJcbi8vICAgICAgICAgICAgIGxldCB3YXZlSW1hZzogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuLy8gICAgICAgICAgICAgd2F2ZUltYWdbMF0gPSBfaW1hZy5zdGFydHBvaW50O1xyXG4vLyAgICAgICAgICAgICB3YXZlSW1hZ1sxXSA9IF9pbWFnLmVuZHBvaW50O1xyXG5cclxuLy8gICAgICAgICAgICAgdGhpcy5vc2NpbGxhdG9yV2F2ZSA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZVBlcmlvZGljV2F2ZSh3YXZlUmVhbCwgd2F2ZUltYWcpO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldExvY2FsR2FpbihfbG9jYWxHYWluOiBHYWluTm9kZSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpbiA9IF9sb2NhbEdhaW47XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0TG9jYWxHYWluKCk6IEdhaW5Ob2RlIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxHYWluO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldExvY2FsR2FpblZhbHVlKF9sb2NhbEdhaW5WYWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluVmFsdWUgPSBfbG9jYWxHYWluVmFsdWU7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4udmFsdWUgPSB0aGlzLmxvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldExvY2FsR2FpblZhbHVlKCk6IG51bWJlciB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldEZyZXF1ZW5jeShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX2ZyZXF1ZW5jeTogbnVtYmVyKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gX2ZyZXF1ZW5jeTtcclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKHRoaXMuZnJlcXVlbmN5LCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSk7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0RnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyZXF1ZW5jeTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBjcmVhdGVTbmFyZShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncyk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldE9zY2lsbGF0b3JUeXBlKFwidHJpYW5nbGVcIik7XHJcbi8vICAgICAgICAgICAgIHRoaXMuc2V0RnJlcXVlbmN5KF9hdWRpb1NldHRpbmdzLCAxMDApO1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldExvY2FsR2FpblZhbHVlKDApO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKDAuMDEsIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lICsgLjEpO1xyXG5cclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IuY29ubmVjdCh0aGlzLmxvY2FsR2Fpbik7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyB9IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UaW1lL0xvb3AudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQW5pbWF0aW9uL0FuaW1hdGlvbi50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBIb2xkcyBhIHJlZmVyZW5jZSB0byBhbiB7QGxpbmsgQW5pbWF0aW9ufSBhbmQgY29udHJvbHMgaXQuIENvbnRyb2xzIHBsYXliYWNrIGFuZCBwbGF5bW9kZSBhcyB3ZWxsIGFzIHNwZWVkLlxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QW5pbWF0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEFuaW1hdG9yKTtcclxuICAgIC8vVE9ETzogYWRkIGZ1bmN0aW9uYWxpdHkgdG8gYmxlbmQgZnJvbSBvbmUgYW5pbWF0aW9uIHRvIGFub3RoZXIuXHJcbiAgICBhbmltYXRpb246IEFuaW1hdGlvbjtcclxuICAgIHBsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREU7XHJcbiAgICBwbGF5YmFjazogQU5JTUFUSU9OX1BMQVlCQUNLO1xyXG4gICAgc2NhbGVXaXRoR2FtZVRpbWU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgICNzY2FsZTogbnVtYmVyID0gMTtcclxuICAgICN0aW1lTG9jYWw6IFRpbWU7XHJcbiAgICAjcHJldmlvdXM6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2FuaW1hdGlvbjogQW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihcIlwiKSwgX3BsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREUgPSBBTklNQVRJT05fUExBWU1PREUuTE9PUCwgX3BsYXliYWNrOiBBTklNQVRJT05fUExBWUJBQ0sgPSBBTklNQVRJT05fUExBWUJBQ0suVElNRUJBU0VEX0NPTlRJTk9VUykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IF9hbmltYXRpb247XHJcbiAgICAgIHRoaXMucGxheW1vZGUgPSBfcGxheW1vZGU7XHJcbiAgICAgIHRoaXMucGxheWJhY2sgPSBfcGxheWJhY2s7XHJcblxyXG4gICAgICB0aGlzLiN0aW1lTG9jYWwgPSBuZXcgVGltZSgpO1xyXG5cclxuICAgICAgLy9UT0RPOiB1cGRhdGUgYW5pbWF0aW9uIHRvdGFsIHRpbWUgd2hlbiBsb2FkaW5nIGEgZGlmZmVyZW50IGFuaW1hdGlvbj9cclxuICAgICAgdGhpcy5hbmltYXRpb24uY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgKCkgPT4gdGhpcy5hY3RpdmF0ZShmYWxzZSkpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNISUxEX1JFTU9WRSwgKCkgPT4gdGhpcy5hY3RpdmF0ZShmYWxzZSkpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgc2NhbGUoX3NjYWxlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc2NhbGUgPSBfc2NhbGU7XHJcbiAgICAgIHRoaXMudXBkYXRlU2NhbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2FtcGxlIHRpbWUgb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICAgcHVibGljIGdldCB0aW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN0aW1lTG9jYWwuZ2V0KCkgJSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBzdXBlci5hY3RpdmF0ZShfb24pO1xyXG4gICAgICBpZiAoIXRoaXMubm9kZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoX29uKSB7XHJcbiAgICAgICAgVGltZS5nYW1lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuVElNRV9TQ0FMRUQsIHRoaXMudXBkYXRlU2NhbGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3ApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIFRpbWUuZ2FtZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlRJTUVfU0NBTEVELCB0aGlzLnVwZGF0ZVNjYWxlKTtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5SRU5ERVJfUFJFUEFSRSwgdGhpcy51cGRhdGVBbmltYXRpb25Mb29wKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSnVtcHMgdG8gYSBjZXJ0YWluIHRpbWUgaW4gdGhlIGFuaW1hdGlvbiB0byBwbGF5IGZyb20gdGhlcmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBqdW1wVG8oX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLiN0aW1lTG9jYWwuc2V0KF90aW1lKTtcclxuICAgICAgdGhpcy4jcHJldmlvdXMgPSBfdGltZTtcclxuICAgICAgX3RpbWUgPSBfdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB0aGlzLmFuaW1hdGlvbi5nZXRNdXRhdGVkKF90aW1lLCB0aGlzLmFuaW1hdGlvbi5jYWxjdWxhdGVEaXJlY3Rpb24oX3RpbWUsIHRoaXMucGxheW1vZGUpLCB0aGlzLnBsYXliYWNrKTtcclxuICAgICAgdGhpcy5ub2RlLmFwcGx5QW5pbWF0aW9uKG11dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSnVtcHMgdG8gYSBjZXJ0YWluIGxhYmVsIGluIHRoZSBhbmltYXRpb24gaWYgZGVmaW5lZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMganVtcFRvTGFiZWwoX2xhYmVsOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgbGV0IHRpbWU6IG51bWJlciA9IHRoaXMuYW5pbWF0aW9uLmxhYmVsc1tfbGFiZWxdO1xyXG4gICAgICBpZiAodGltZSlcclxuICAgICAgICB0aGlzLmp1bXBUbyh0aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlcyBhbiB1cGRhdGUgb2YgdGhlIGFuaW1hdGlvbiBmcm9tIG91dHNpZGUuIFVzZWQgaW4gdGhlIFZpZXdBbmltYXRpb24uIFNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyB0aGUgZ2FtZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgKHVuc2NhbGVkKSB0aW1lIHRvIHVwZGF0ZSB0aGUgYW5pbWF0aW9uIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyBhIFR1cGVsIGNvbnRhaW5pbmcgdGhlIE11dGF0b3IgZm9yIEFuaW1hdGlvbiBhbmQgdGhlIHBsYXltb2RlIGNvcnJlY3RlZCB0aW1lLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbihfdGltZTogbnVtYmVyKTogW011dGF0b3IsIG51bWJlcl0ge1xyXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVBbmltYXRpb25Mb29wKG51bGwsIF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRBbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbi5pZFJlc291cmNlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnBsYXltb2RlID0gdGhpcy5wbGF5bW9kZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5wbGF5YmFjayA9IHRoaXMucGxheWJhY2s7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNjYWxlV2l0aEdhbWVUaW1lID0gdGhpcy5zY2FsZVdpdGhHYW1lVGltZTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IDxBbmltYXRpb24+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZEFuaW1hdGlvbik7XHJcbiAgICAgIHRoaXMucGxheWJhY2sgPSBfc2VyaWFsaXphdGlvbi5wbGF5YmFjaztcclxuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9zZXJpYWxpemF0aW9uLnBsYXltb2RlO1xyXG4gICAgICB0aGlzLnNjYWxlID0gX3NlcmlhbGl6YXRpb24uc2NhbGU7XHJcbiAgICAgIHRoaXMuc2NhbGVXaXRoR2FtZVRpbWUgPSBfc2VyaWFsaXphdGlvbi5zY2FsZVdpdGhHYW1lVGltZTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIHVwZGF0ZUFuaW1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBBbmltYXRpb24uXHJcbiAgICAgKiBHZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBMb29wIGZpcmVzIHRoZSBMT09QX0ZSQU1FIEV2ZW50LlxyXG4gICAgICogVXNlcyB0aGUgYnVpbHQtaW4gdGltZSB1bmxlc3MgYSBkaWZmZXJlbnQgdGltZSBpcyBzcGVjaWZpZWQuXHJcbiAgICAgKiBNYXkgYWxzbyBiZSBjYWxsZWQgZnJvbSB1cGRhdGVBbmltYXRpb24oKS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVBbmltYXRpb25Mb29wID0gKF9lOiBFdmVudCwgX3RpbWU/OiBudW1iZXIpOiBbTXV0YXRvciwgbnVtYmVyXSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUgPT0gMClcclxuICAgICAgICByZXR1cm4gW251bGwsIDBdO1xyXG4gICAgICBsZXQgdGltZTogbnVtYmVyID0gX3RpbWUgfHwgdGhpcy4jdGltZUxvY2FsLmdldCgpO1xyXG4gICAgICBpZiAodGhpcy5wbGF5YmFjayA9PSBBTklNQVRJT05fUExBWUJBQ0suRlJBTUVCQVNFRCkge1xyXG4gICAgICAgIHRpbWUgPSB0aGlzLiNwcmV2aW91cyArICgxMDAwIC8gdGhpcy5hbmltYXRpb24uZnBzKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgZGlyZWN0aW9uOiBudW1iZXIgPSB0aGlzLmFuaW1hdGlvbi5jYWxjdWxhdGVEaXJlY3Rpb24odGltZSwgdGhpcy5wbGF5bW9kZSk7XHJcbiAgICAgIHRpbWUgPSB0aGlzLmFuaW1hdGlvbi5nZXRNb2RhbFRpbWUodGltZSwgdGhpcy5wbGF5bW9kZSwgdGhpcy4jdGltZUxvY2FsLmdldE9mZnNldCgpKTtcclxuICAgICAgdGhpcy5leGVjdXRlRXZlbnRzKHRoaXMuYW5pbWF0aW9uLmdldEV2ZW50c1RvRmlyZSh0aGlzLiNwcmV2aW91cywgdGltZSwgdGhpcy5wbGF5YmFjaywgZGlyZWN0aW9uKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy4jcHJldmlvdXMgIT0gdGltZSkge1xyXG4gICAgICAgIHRoaXMuI3ByZXZpb3VzID0gdGltZTtcclxuICAgICAgICB0aW1lID0gdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHRoaXMuYW5pbWF0aW9uLmdldE11dGF0ZWQodGltZSwgZGlyZWN0aW9uLCB0aGlzLnBsYXliYWNrKTtcclxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XHJcbiAgICAgICAgICB0aGlzLm5vZGUuYXBwbHlBbmltYXRpb24obXV0YXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbXV0YXRvciwgdGltZV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFtudWxsLCB0aW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIGFsbCBjdXN0b20gZXZlbnRzIHRoZSBBbmltYXRpb24gc2hvdWxkIGhhdmUgZmlyZWQgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRzIGEgbGlzdCBvZiBuYW1lcyBvZiBjdXN0b20gZXZlbnRzIHRvIGZpcmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBleGVjdXRlRXZlbnRzKGV2ZW50czogc3RyaW5nW10pOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoZXZlbnRzW2ldKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHNjYWxlIG9mIHRoZSBhbmltYXRpb24gaWYgdGhlIHVzZXIgY2hhbmdlcyBpdCBvciBpZiB0aGUgZ2xvYmFsIGdhbWUgdGltZXIgY2hhbmdlZCBpdHMgc2NhbGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlU2NhbGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgIGxldCBuZXdTY2FsZTogbnVtYmVyID0gdGhpcy4jc2NhbGU7XHJcbiAgICAgIGlmICh0aGlzLnNjYWxlV2l0aEdhbWVUaW1lKVxyXG4gICAgICAgIG5ld1NjYWxlICo9IFRpbWUuZ2FtZS5nZXRTY2FsZSgpO1xyXG4gICAgICB0aGlzLiN0aW1lTG9jYWwuc2V0U2NhbGUobmV3U2NhbGUpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gQVVESU9fUEFOTkVSIHtcclxuICAgIENPTkVfSU5ORVJfQU5HTEUgPSBcImNvbmVJbm5lckFuZ2xlXCIsXHJcbiAgICBDT05FX09VVEVSX0FOR0xFID0gXCJjb25lT3V0ZXJBbmdsZVwiLFxyXG4gICAgQ09ORV9PVVRFUl9HQUlOID0gXCJjb25lT3V0ZXJHYWluXCIsXHJcbiAgICBESVNUQU5DRV9NT0RFTCA9IFwiZGlzdGFuY2VNb2RlbFwiLFxyXG4gICAgTUFYX0RJU1RBTkNFID0gXCJtYXhEaXN0YW5jZVwiLFxyXG4gICAgUEFOTklOR19NT0RFTCA9IFwicGFubmluZ01vZGVsXCIsXHJcbiAgICBSRUZfRElTVEFOQ0UgPSBcInJlZkRpc3RhbmNlXCIsXHJcbiAgICBST0xMT0ZGX0ZBQ1RPUiA9IFwicm9sbG9mZkZhY3RvclwiXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBBVURJT19OT0RFX1RZUEUge1xyXG4gICAgU09VUkNFLCBQQU5ORVIsIEdBSU5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhIG1pbmltYWwgYXVkaW8gZ3JhcGggKGJ5IGRlZmF1bHQgaW4ge0BsaW5rIEF1ZGlvTWFuYWdlcn0uZGVmYXVsdCkgYW5kIHN5bmNocm9uaXplcyBpdCB3aXRoIHRoZSBjb250YWluaW5nIHtAbGluayBOb2RlfVxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqIOKUjCBBdWRpb01hbmFnZXIoLmRlZmF1bHQpIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAqIOKUgiDilIwgQ29tcG9uZW50QXVkaW8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUglxyXG4gICAqIOKUgiDilIIgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCICBcclxuICAgKiDilIIg4pSCICAgIOKUgnNvdXJjZeKUgiDihpIg4pSCcGFubmVy4pSCIOKGkiDilIIgZ2FpbiDilIIg4oaSIOKUgiBnYWluIOKUgiDilIJcclxuICAgKiDilIIg4pSCICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiAgXHJcbiAgICog4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilIJcclxuICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBUaG9tYXMgRG9ybmVyLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBdWRpbyBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QXVkaW8pO1xyXG4gICAgLyoqIHBsYWNlcyBhbmQgZGlyZWN0cyB0aGUgcGFubmVyIHJlbGF0aXZlIHRvIHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHtAbGluayBOb2RlfSAgKi9cclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgcHJvdGVjdGVkIHNpbmdsZXRvbjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgYXVkaW86IEF1ZGlvO1xyXG4gICAgcHJpdmF0ZSBnYWluOiBHYWluTm9kZTtcclxuICAgIHByaXZhdGUgcGFubmVyOiBQYW5uZXJOb2RlO1xyXG4gICAgcHJpdmF0ZSBzb3VyY2U6IEF1ZGlvQnVmZmVyU291cmNlTm9kZTtcclxuICAgIHByaXZhdGUgYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXI7XHJcbiAgICBwcml2YXRlIHBsYXlpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgbGlzdGVuZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYXVkaW86IEF1ZGlvID0gbnVsbCwgX2xvb3A6IGJvb2xlYW4gPSBmYWxzZSwgX3N0YXJ0OiBib29sZWFuID0gZmFsc2UsIF9hdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlciA9IEF1ZGlvTWFuYWdlci5kZWZhdWx0KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuaW5zdGFsbChfYXVkaW9NYW5hZ2VyKTtcclxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoX2F1ZGlvLCBfbG9vcCk7XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5oYW5kbGVBdHRhY2gpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5oYW5kbGVBdHRhY2gpO1xyXG5cclxuICAgICAgaWYgKF9zdGFydClcclxuICAgICAgICB0aGlzLnBsYXkoX3N0YXJ0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHNldCB2b2x1bWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbG9vcChfb246IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy5zb3VyY2UubG9vcCA9IF9vbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGxvb3AoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5sb29wO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNQbGF5aW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5wbGF5aW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCBpc0F0dGFjaGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5ub2RlICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGlzTGlzdGVuZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRBdWRpbyhfYXVkaW86IEF1ZGlvKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKF9hdWRpbywgdGhpcy5zb3VyY2UubG9vcCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0QXVkaW8oKTogQXVkaW8ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdWRpbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcHJvcGVydHkgb2YgdGhlIHBhbm5lciB0byB0aGUgZ2l2ZW4gdmFsdWUuIFVzZSB0byBtYW5pcHVsYXRlIHJhbmdlIGFuZCByb2xsb2ZmIGV0Yy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBhbm5lcihfcHJvcGVydHk6IEFVRElPX1BBTk5FUiwgX3ZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgUmVmbGVjdC5zZXQodGhpcy5wYW5uZXIsIF9wcm9wZXJ0eSwgX3ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBtYXkgYmUgdXNlZCBmb3Igc2VyaWFsaXphdGlvbiBvZiBBdWRpb05vZGVzXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvck9mTm9kZShfdHlwZTogQVVESU9fTk9ERV9UWVBFKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBub2RlOiBBdWRpb05vZGUgPSB0aGlzLmdldEF1ZGlvTm9kZShfdHlwZSk7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gZ2V0TXV0YXRvck9mQXJiaXRyYXJ5KG5vZGUpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBBdWRpb05vZGUgb2YgdGhlIHN0YW5kYXJkIGdyYXBoIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW9Ob2RlKF90eXBlOiBBVURJT19OT0RFX1RZUEUpOiBBdWRpb05vZGUge1xyXG4gICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuU09VUkNFOiByZXR1cm4gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuUEFOTkVSOiByZXR1cm4gdGhpcy5wYW5uZXI7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuR0FJTjogcmV0dXJuIHRoaXMuZ2FpbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgb3Igc3RvcCBwbGF5aW5nIHRoZSBhdWRpb1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGxheShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbikge1xyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvLmlzUmVhZHkpIHtcclxuICAgICAgICAgIHRoaXMuY3JlYXRlU291cmNlKHRoaXMuYXVkaW8sIHRoaXMuc291cmNlLmxvb3ApO1xyXG4gICAgICAgICAgdGhpcy5zb3VyY2Uuc3RhcnQoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5hdWRpby5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlJFQURZLCB0aGlzLmhuZEF1ZGlvUmVhZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkVOREVELCB0aGlzLmhuZEF1ZGlvRW5kZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcjogdW5rbm93bikgeyAvKiBjYXRjaCBleGNlcHRpb24gd2hlbiBzb3VyY2UgaGFzbid0IGJlZW4gc3RhcnRlZC4uLiAqLyB9XHJcbiAgICAgIHRoaXMucGxheWluZyA9IF9vbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgQXVkaW9Ob2RlcyBiZXR3ZWVuIHRoZSBwYW5uZXIgYW5kIHRoZSBsb2NhbCBnYWluIG9mIHRoaXMge0BsaW5rIENvbXBvbmVudEF1ZGlvfVxyXG4gICAgICogX2lucHV0IGFuZCBfb3V0cHV0IG1heSBiZSB0aGUgc2FtZSBBdWRpb05vZGUsIGlmIHRoZXJlIGlzIG9ubHkgb25lIHRvIGluc2VydCxcclxuICAgICAqIG9yIG1heSBoYXZlIG11bHRpcGxlIEF1ZGlvTm9kZSBiZXR3ZWVuIHRoZW0gdG8gY3JlYXRlIGFuIGVmZmVjdC1ncmFwaC5cXFxyXG4gICAgICogTm90ZSB0aGF0IHtAbGluayBDb21wb25lbnRBdWRpb30gZG9lcyBub3Qga2VlcCB0cmFjayBvZiBpbnNlcnRlZCBBdWRpb05vZGVzIVxyXG4gICAgICogYGBgcGxhaW50ZXh0XHJcbiAgICAgKiDilIwgQXVkaW9NYW5hZ2VyKC5kZWZhdWx0KSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgICAqIOKUgiDilIwgQ29tcG9uZW50QXVkaW8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUglxyXG4gICAgICog4pSCIOKUgiAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCICBcclxuICAgICAqIOKUgiDilIIgICAg4pSCc291cmNl4pSCIOKGkiDilIJwYW5uZXLilIIg4oaSIOKUgl9pbnB1dOKUgiDihpIgLi4uICDihpIg4pSCX291dHB1dOKUgiDihpIg4pSCIGdhaW4g4pSCIOKGkiDilIIgZ2FpbiDilIIg4pSCXHJcbiAgICAgKiDilIIg4pSCICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIgIFxyXG4gICAgICog4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilIJcclxuICAgICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnNlcnRBdWRpb05vZGVzKF9pbnB1dDogQXVkaW9Ob2RlLCBfb3V0cHV0OiBBdWRpb05vZGUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5wYW5uZXIuZGlzY29ubmVjdCgwKTtcclxuICAgICAgaWYgKCFfaW5wdXQgJiYgIV9vdXRwdXQpIHtcclxuICAgICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QoX2lucHV0KTtcclxuICAgICAgX291dHB1dC5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZSBvdmVycmlkZS4gQ29ubmVjdHMgb3IgZGlzY29ubmVjdHMgQXVkaW9Ob2Rlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLmFjdGl2YXRlKF9vbik7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhpcyBjb21wb25lbnRzIGdhaW4tbm9kZSB0byB0aGUgZ2FpbiBub2RlIG9mIHRoZSBBdWRpb01hbmFnZXIgdGhpcyBjb21wb25lbnQgcnVucyBvbi5cclxuICAgICAqIE9ubHkgY2FsbCB0aGlzIG1ldGhvZCBpZiB0aGUgY29tcG9uZW50IGlzIG5vdCBhdHRhY2hlZCB0byBhIHtAbGluayBOb2RlfSBidXQgbmVlZHMgdG8gYmUgaGVhcmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25uZWN0KF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKVxyXG4gICAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5hdWRpb01hbmFnZXIuZ2Fpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UgPSB0aGlzLmF1ZGlvLmlkUmVzb3VyY2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucGxheWluZyA9IHRoaXMucGxheWluZztcclxuICAgICAgc2VyaWFsaXphdGlvbi5sb29wID0gdGhpcy5sb29wO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnZvbHVtZSA9IHRoaXMudm9sdW1lO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmdldE11dGF0b3JPZk5vZGUoQVVESU9fTk9ERV9UWVBFLlBBTk5FUikpO1xyXG4gICAgICAvLyBUT0RPOiBzZXJpYWxpemUgcGFubmVyIHBhcmFtZXRlcnNcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGxldCBhdWRpbzogQXVkaW8gPSA8QXVkaW8+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcclxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoYXVkaW8sIF9zZXJpYWxpemF0aW9uLmxvb3ApO1xyXG4gICAgICB0aGlzLnZvbHVtZSA9IF9zZXJpYWxpemF0aW9uLnZvbHVtZTtcclxuICAgICAgdGhpcy5wbGF5KF9zZXJpYWxpemF0aW9uLnBsYXlpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBsZXQgYXVkaW86IE11dGF0b3IgPSBtdXRhdG9yLmF1ZGlvO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5hdWRpbzsgLy8ganVzdCB0byByZWFycmFuZ2UgaW4gaW50ZXJmYWNlcy4uLlxyXG4gICAgICBtdXRhdG9yLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgIG11dGF0b3Iudm9sdW1lID0gdGhpcy52b2x1bWU7XHJcbiAgICAgIG11dGF0b3IuYXVkaW8gPSBhdWRpbzsgLy8uLi4gc28gYXVkaW8gY29tZXMgbGFzdFxyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAvLyAgIC8vIHRoaXMudm9sdW1lID0gX211dGF0b3Iudm9sdW1lO1xyXG4gICAgLy8gICAvLyB0aGlzLmxvb3AgPSBfbXV0YXRvci5sb29wO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubGlzdGVuZWQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBobmRBdWRpb1JlYWR5OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJBdWRpbyBzdGFydFwiLCBSZWZsZWN0LmdldChfZXZlbnQudGFyZ2V0LCBcInVybFwiKSk7XHJcbiAgICAgIGlmICh0aGlzLnBsYXlpbmcpXHJcbiAgICAgICAgdGhpcy5wbGF5KHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kQXVkaW9FbmRlZDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIC8vIERlYnVnLmZ1ZGdlKFwiQXVkaW8gZW5kZWRcIiwgUmVmbGVjdC5nZXQoX2V2ZW50LnRhcmdldCwgXCJ1cmxcIikpO1xyXG4gICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGluc3RhbGwoX2F1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQpOiB2b2lkIHtcclxuICAgICAgbGV0IGFjdGl2ZTogYm9vbGVhbiA9IHRoaXMuaXNBY3RpdmU7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoZmFsc2UpO1xyXG4gICAgICB0aGlzLmF1ZGlvTWFuYWdlciA9IF9hdWRpb01hbmFnZXI7XHJcbiAgICAgIHRoaXMucGFubmVyID0gX2F1ZGlvTWFuYWdlci5jcmVhdGVQYW5uZXIoKTtcclxuICAgICAgdGhpcy5nYWluID0gX2F1ZGlvTWFuYWdlci5jcmVhdGVHYWluKCk7XHJcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QodGhpcy5nYWluKTtcclxuICAgICAgdGhpcy5nYWluLmNvbm5lY3QoX2F1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgICAgdGhpcy5hY3RpdmF0ZShhY3RpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlU291cmNlKF9hdWRpbzogQXVkaW8sIF9sb29wOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLnNvdXJjZS5idWZmZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc291cmNlID0gdGhpcy5hdWRpb01hbmFnZXIuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5wYW5uZXIpO1xyXG5cclxuICAgICAgaWYgKF9hdWRpbykge1xyXG4gICAgICAgIHRoaXMuYXVkaW8gPSBfYXVkaW87XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuYnVmZmVyID0gX2F1ZGlvLmJ1ZmZlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zb3VyY2UubG9vcCA9IF9sb29wO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlQ29ubmVjdGlvbigpOiB2b2lkIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLmlzQXR0YWNoZWQgJiYgdGhpcy5saXN0ZW5lZCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIC8vIG5vcFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljYWxseSBjb25uZWN0cy9kaXNjb25uZWN0cyBBdWRpb05vZGVzIHdoZW4gYWRkaW5nL3JlbW92aW5nIHRoaXMgY29tcG9uZW50IHRvL2Zyb20gYSBub2RlLiBcclxuICAgICAqIFRoZXJlZm9yZSB1bnVzZWQgQXVkaW9Ob2RlcyBtYXkgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgd2hlbiBhbiB1bnVzZWQgY29tcG9uZW50IGlzIGNvbGxlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUF0dGFjaCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIC8vIERlYnVnLmxvZyhfZXZlbnQpO1xyXG4gICAgICBpZiAoX2V2ZW50LnR5cGUgPT0gRVZFTlQuQ09NUE9ORU5UX0FERCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfUkVNT1ZFLCB0aGlzLmhhbmRsZUdyYXBoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5VUERBVEUsIHRoaXMudXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVkID0gdGhpcy5ub2RlLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5ELCB0aGlzLmhhbmRsZUdyYXBoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlVQREFURSwgdGhpcy51cGRhdGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNvbm5lY3RzL2Rpc2Nvbm5lY3RzIEF1ZGlvTm9kZXMgd2hlbiBhcHBlbmRpbmcvcmVtb3ZpbmcgdGhlIEZVREdFLWdyYXBoIHRoZSBjb21wb25lbnQgaXMgaW4uIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUdyYXBoID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgLy8gRGVidWcubG9nKF9ldmVudCk7XHJcbiAgICAgIHRoaXMubGlzdGVuZWQgPSAoX2V2ZW50LnR5cGUgPT0gRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKTtcclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVXBkYXRlcyB0aGUgcGFubmVyIG5vZGUsIGl0cyBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uLCB1c2luZyB0aGUgd29ybGRtYXRyaXggb2YgdGhlIGNvbnRhaW5lciBhbmQgdGhlIHBpdm90IG9mIHRoaXMgY29tcG9uZW50LiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGUgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLm10eFBpdm90O1xyXG4gICAgICBpZiAodGhpcy5ub2RlKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50b1N0cmluZygpKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4UmVzdWx0LnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgZm9yd2FyZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5aKDEpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWi52YWx1ZSA9IHBvc2l0aW9uLno7XHJcblxyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblgudmFsdWUgPSBmb3J3YXJkLng7XHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWS52YWx1ZSA9IGZvcndhcmQueTtcclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25aLnZhbHVlID0gZm9yd2FyZC56O1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZm9yd2FyZCk7XHJcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUgd2h5IHRoZSBmb2xsb3dpbmcgcHJvZHVjZXMgZXJyb25lb3VzIHJlc3VsdHMsIHNlZSB0ZXN0IFwiU3BhdGlhbCBBdWRpb1wiXHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTZXJ2ZXMgdG8gc2V0IHRoZSBzcGF0aWFsIGxvY2F0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiBBdWRpb0xpc3RlbmVycyByZWxhdGl2ZSB0byB0aGVcclxuICAgKiB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHtAbGluayBOb2RlfSBpdCBpcyBhdHRhY2hlZCB0by5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBdWRpb0xpc3RlbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBdWRpb0xpc3RlbmVyKTtcclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIGdpdmVuIEF1ZGlvTGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZShfbGlzdGVuZXI6IEF1ZGlvTGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5tdHhQaXZvdDtcclxuICAgICAgaWYgKHRoaXMubm9kZSlcclxuICAgICAgICBtdHhSZXN1bHQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuXHJcbiAgICAgIC8vIERlYnVnLmxvZyhtdHhSZXN1bHQudG9TdHJpbmcoKSk7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IG10eFJlc3VsdC50cmFuc2xhdGlvbjtcclxuICAgICAgbGV0IGZvcndhcmQ6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKFZlY3RvcjMuWigxKSwgbXR4UmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgIGxldCB1cDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5ZKCksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG5cclxuICAgICAgaWYgKF9saXN0ZW5lci5wb3NpdGlvblggIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWi52YWx1ZSA9IHBvc2l0aW9uLno7XHJcblxyXG4gICAgICAgIF9saXN0ZW5lci5mb3J3YXJkWC52YWx1ZSA9IGZvcndhcmQueDtcclxuICAgICAgICBfbGlzdGVuZXIuZm9yd2FyZFkudmFsdWUgPSBmb3J3YXJkLnk7XHJcbiAgICAgICAgX2xpc3RlbmVyLmZvcndhcmRaLnZhbHVlID0gZm9yd2FyZC56O1xyXG5cclxuICAgICAgICBfbGlzdGVuZXIudXBYLnZhbHVlID0gdXAueDtcclxuICAgICAgICBfbGlzdGVuZXIudXBZLnZhbHVlID0gdXAueTtcclxuICAgICAgICBfbGlzdGVuZXIudXBaLnZhbHVlID0gdXAuejtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBGaXJlZm94IHN0aWxsIHVzZXMgZGVwcmVjYXRlZCBtZXRob2RzLiBUT0RPOiBkZWxldGUgYXMgc29vbiBhcyBwb3NzaWJsZSFcclxuICAgICAgICBfbGlzdGVuZXIuc2V0UG9zaXRpb24ocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XHJcbiAgICAgICAgX2xpc3RlbmVyLnNldE9yaWVudGF0aW9uKGZvcndhcmQueCwgZm9yd2FyZC55LCBmb3J3YXJkLnosIHVwLngsIHVwLnksIHVwLnopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShmb3J3YXJkKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodXApO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50cmFuc2xhdGlvbi50b1N0cmluZygpLCBmb3J3YXJkLnRvU3RyaW5nKCksIHVwLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkNvbXBvbmVudC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gRklFTERfT0ZfVklFVyB7XHJcbiAgICBIT1JJWk9OVEFMLCBWRVJUSUNBTCwgRElBR09OQUxcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBpZGVudGlmaWVycyBmb3IgdGhlIHZhcmlvdXMgcHJvamVjdGlvbnMgYSBjYW1lcmEgY2FuIHByb3ZpZGUuICBcclxuICAgKiBUT0RPOiBjaGFuZ2UgYmFjayB0byBudW1iZXIgZW51bSBpZiBzdHJpbmdzIG5vdCBuZWVkZWRcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBQUk9KRUNUSU9OIHtcclxuICAgIENFTlRSQUwgPSBcImNlbnRyYWxcIixcclxuICAgIE9SVEhPR1JBUEhJQyA9IFwib3J0aG9ncmFwaGljXCIsXHJcbiAgICBESU1FVFJJQyA9IFwiZGltZXRyaWNcIixcclxuICAgIFNURVJFTyA9IFwic3RlcmVvXCJcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhlIGNhbWVyYSBjb21wb25lbnQgaG9sZHMgdGhlIHByb2plY3Rpb24tbWF0cml4IGFuZCBvdGhlciBkYXRhIG5lZWRlZCB0byByZW5kZXIgYSBzY2VuZSBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiB0aGUgbm9kZSBpdCBpcyBhdHRhY2hlZCB0by5cclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudENhbWVyYSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50Q2FtZXJhKTtcclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgY2xyQmFja2dyb3VuZDogQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7IC8vIFRoZSBjb2xvciBvZiB0aGUgYmFja2dyb3VuZCB0aGUgY2FtZXJhIHdpbGwgcmVuZGVyLlxyXG4gICAgLy9wcml2YXRlIG9ydGhvZ3JhcGhpYzogYm9vbGVhbiA9IGZhbHNlOyAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGltYWdlIHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBwZXJzcGVjdGl2ZSBvciBvcnRob2dyYXBoaWMgcHJvamVjdGlvbi5cclxuICAgICNtdHhXb3JsZFRvVmlldzogTWF0cml4NHg0O1xyXG4gICAgcHJpdmF0ZSBwcm9qZWN0aW9uOiBQUk9KRUNUSU9OID0gUFJPSkVDVElPTi5DRU5UUkFMO1xyXG4gICAgcHJpdmF0ZSBtdHhQcm9qZWN0aW9uOiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0OyAvLyBUaGUgbWF0cml4IHRvIG11bHRpcGx5IGVhY2ggc2NlbmUgb2JqZWN0cyB0cmFuc2Zvcm1hdGlvbiBieSwgdG8gZGV0ZXJtaW5lIHdoZXJlIGl0IHdpbGwgYmUgZHJhd24uXHJcbiAgICBwcml2YXRlIGZpZWxkT2ZWaWV3OiBudW1iZXIgPSA0NTsgLy8gVGhlIGNhbWVyYSdzIHNlbnNvcmFuZ2xlLlxyXG4gICAgcHJpdmF0ZSBhc3BlY3RSYXRpbzogbnVtYmVyID0gMS4wO1xyXG4gICAgcHJpdmF0ZSBkaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcgPSBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMO1xyXG4gICAgcHJpdmF0ZSBuZWFyOiBudW1iZXIgPSAxO1xyXG4gICAgcHJpdmF0ZSBmYXI6IG51bWJlciA9IDIwMDA7XHJcbiAgICBwcml2YXRlIGJhY2tncm91bmRFbmFibGVkOiBib29sZWFuID0gdHJ1ZTsgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgYmFja2dyb3VuZCBvZiB0aGlzIGNhbWVyYSB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgLy8gVE9ETzogZXhhbWluZSwgaWYgYmFja2dyb3VuZCBzaG91bGQgYmUgYW4gYXR0cmlidXRlIG9mIENhbWVyYSBvciBWaWV3cG9ydFxyXG5cclxuICAgIHB1YmxpYyBnZXQgbXR4V29ybGQoKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG10eENhbWVyYTogTWF0cml4NHg0ID0gdGhpcy5tdHhQaXZvdC5jbG9uZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtdHhDYW1lcmEgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7ICAgXHJcbiAgICAgICAgLy8gbm8gY29udGFpbmVyIG5vZGUgb3Igbm8gd29ybGQgdHJhbnNmb3JtYXRpb24gZm91bmQgLT4gY29udGludWUgd2l0aCBwaXZvdCBvbmx5XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG10eENhbWVyYTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbXVsdGlwbGljYXRpb24gb2YgdGhlIHdvcmxkdHJhbnNmb3JtYXRpb24gb2YgdGhlIGNhbWVyYSBjb250YWluZXIsIHRoZSBwaXZvdCBvZiB0aGlzIGNhbWVyYSBhbmQgdGhlIGludmVyc2lvbiBvZiB0aGUgcHJvamVjdGlvbiBtYXRyaXhcclxuICAgICAqIHlpZWxkaW5nIHRoZSB3b3JsZHNwYWNlIHRvIHZpZXdzcGFjZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtdHhXb3JsZFRvVmlldygpOiBNYXRyaXg0eDQge1xyXG4gICAgICBpZiAodGhpcy4jbXR4V29ybGRUb1ZpZXcgKVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNtdHhXb3JsZFRvVmlldztcclxuICAgICAgICBcclxuICAgICAgLy9UT0RPOiBvcHRpbWl6ZSwgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBpZiBuZWl0aGVyIG10eFdvcmxkIG5vciBwaXZvdCBoYXZlIGNoYW5nZWRcclxuICAgICAgbGV0IG10eENhbWVyYTogTWF0cml4NHg0ID0gdGhpcy5tdHhXb3JsZDtcclxuICAgICAgbGV0IG10eEludmVyc2lvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0lPTihtdHhDYW1lcmEpO1xyXG4gICAgICB0aGlzLiNtdHhXb3JsZFRvVmlldyA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLm10eFByb2plY3Rpb24sIG10eEludmVyc2lvbik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eENhbWVyYSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eEludmVyc2lvbik7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4V29ybGRUb1ZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlc2V0V29ybGRUb1ZpZXcoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI210eFdvcmxkVG9WaWV3ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UHJvamVjdGlvbigpOiBQUk9KRUNUSU9OIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QmFja2dyb3VuZEVuYWJsZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRFbmFibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBc3BlY3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXNwZWN0UmF0aW87XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZpZWxkT2ZWaWV3KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkT2ZWaWV3O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXREaXJlY3Rpb24oKTogRklFTERfT0ZfVklFVyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TmVhcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5uZWFyO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldEZhcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5mYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSB0byBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uLiBUaGUgd29ybGQgb3JpZ2luIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc2VsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gX2FzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIGJldHdlZW4gd2lkdGggYW5kIGhlaWdodCBvZiBwcm9qZWN0aW9uc3BhY2UuKERlZmF1bHQgPSBjYW52YXMuY2xpZW50V2lkdGggLyBjYW52YXMuQ2xpZW50SGVpZ2h0KVxyXG4gICAgICogQHBhcmFtIF9maWVsZE9mVmlldyBUaGUgZmllbGQgb2YgdmlldyBpbiBEZWdyZWVzLiAoRGVmYXVsdCA9IDQ1KVxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHByb2plY3RDZW50cmFsKF9hc3BlY3Q6IG51bWJlciA9IHRoaXMuYXNwZWN0UmF0aW8sIF9maWVsZE9mVmlldzogbnVtYmVyID0gdGhpcy5maWVsZE9mVmlldywgX2RpcmVjdGlvbjogRklFTERfT0ZfVklFVyA9IHRoaXMuZGlyZWN0aW9uLCBfbmVhcjogbnVtYmVyID0gMSwgX2ZhcjogbnVtYmVyID0gMjAwMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gX2FzcGVjdDtcclxuICAgICAgdGhpcy5maWVsZE9mVmlldyA9IF9maWVsZE9mVmlldztcclxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSBfZGlyZWN0aW9uO1xyXG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XHJcbiAgICAgIHRoaXMubmVhciA9IF9uZWFyO1xyXG4gICAgICB0aGlzLmZhciA9IF9mYXI7XHJcbiAgICAgIHRoaXMubXR4UHJvamVjdGlvbiA9IE1hdHJpeDR4NC5QUk9KRUNUSU9OX0NFTlRSQUwoX2FzcGVjdCwgdGhpcy5maWVsZE9mVmlldywgX25lYXIsIF9mYXIsIHRoaXMuZGlyZWN0aW9uKTsgLy8gVE9ETzogcmVtb3ZlIG1hZ2ljIG51bWJlcnNcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjYW1lcmEgdG8gb3J0aG9ncmFwaGljIHByb2plY3Rpb24uIFRoZSBvcmlnaW4gaXMgaW4gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBsZWZ0IGJvcmRlci4gKERlZmF1bHQgPSAwKVxyXG4gICAgICogQHBhcmFtIF9yaWdodCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgcmlnaHQgYm9yZGVyLiAoRGVmYXVsdCA9IGNhbnZhcy5jbGllbnRXaWR0aClcclxuICAgICAqIEBwYXJhbSBfYm90dG9tIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBib3R0b20gYm9yZGVyLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfdG9wIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyB0b3AgYm9yZGVyLihEZWZhdWx0ID0gMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHByb2plY3RPcnRob2dyYXBoaWMoX2xlZnQ6IG51bWJlciA9IDAsIF9yaWdodDogbnVtYmVyID0gUmVuZGVyLmdldENhbnZhcygpLmNsaWVudFdpZHRoLCBfYm90dG9tOiBudW1iZXIgPSBSZW5kZXIuZ2V0Q2FudmFzKCkuY2xpZW50SGVpZ2h0LCBfdG9wOiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucHJvamVjdGlvbiA9IFBST0pFQ1RJT04uT1JUSE9HUkFQSElDO1xyXG4gICAgICB0aGlzLm10eFByb2plY3Rpb24gPSBNYXRyaXg0eDQuUFJPSkVDVElPTl9PUlRIT0dSQVBISUMoX2xlZnQsIF9yaWdodCwgX2JvdHRvbSwgX3RvcCwgNDAwLCAtNDAwKTsgLy8gVE9ETzogZXhhbWluZSBtYWdpYyBudW1iZXJzIVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjYWxjdWxhdGVkIGRpbWVuc2lvbiBvZiBhIHByb2plY3Rpb24gc3VyZmFjZSBpbiB0aGUgaHlwb3RoZXRpY2FsIGRpc3RhbmNlIG9mIDEgdG8gdGhlIGNhbWVyYVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvamVjdGlvblJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICBsZXQgdGFuRm92OiBudW1iZXIgPSBNYXRoLnRhbihNYXRoLlBJICogdGhpcy5maWVsZE9mVmlldyAvIDM2MCk7IC8vIEhhbGYgb2YgdGhlIGFuZ2xlLCB0byBjYWxjdWxhdGUgZGltZW5zaW9uIGZyb20gdGhlIGNlbnRlciAtPiByaWdodCBhbmdsZVxyXG4gICAgICBsZXQgdGFuSG9yaXpvbnRhbDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRhblZlcnRpY2FsOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IEZJRUxEX09GX1ZJRVcuRElBR09OQUwpIHtcclxuICAgICAgICBsZXQgYXNwZWN0OiBudW1iZXIgPSBNYXRoLnNxcnQodGhpcy5hc3BlY3RSYXRpbyk7XHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdiAqIGFzcGVjdDtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdiAvIGFzcGVjdDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMKSB7XHJcbiAgICAgICAgdGFuVmVydGljYWwgPSB0YW5Gb3Y7XHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhblZlcnRpY2FsICogdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHsvL0ZPVl9ESVJFQ1RJT04uSE9SSVpPTlRBTFxyXG4gICAgICAgIHRhbkhvcml6b250YWwgPSB0YW5Gb3Y7XHJcbiAgICAgICAgdGFuVmVydGljYWwgPSB0YW5Ib3Jpem9udGFsIC8gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGFuSG9yaXpvbnRhbCAqIDIsIHRhblZlcnRpY2FsICogMik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBvaW50V29ybGRUb0NsaXAoX3BvaW50SW5Xb3JsZFNwYWNlOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjM7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLm10eFdvcmxkVG9WaWV3LmdldCgpO1xyXG4gICAgICBsZXQgdzogbnVtYmVyID0gbVszXSAqIF9wb2ludEluV29ybGRTcGFjZS54ICsgbVs3XSAqIF9wb2ludEluV29ybGRTcGFjZS55ICsgbVsxMV0gKiBfcG9pbnRJbldvcmxkU3BhY2UueiArIG1bMTVdO1xyXG5cclxuICAgICAgcmVzdWx0ID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnRJbldvcmxkU3BhY2UsIHRoaXMubXR4V29ybGRUb1ZpZXcpO1xyXG4gICAgICByZXN1bHQuc2NhbGUoMSAvIHcpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwb2ludENsaXBUb1dvcmxkKF9wb2ludEluQ2xpcFNwYWNlOiBWZWN0b3IzKTogVmVjdG9yMyB7ICAgICAgXHJcbiAgICAgIGxldCBtdHhWaWV3VG9Xb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLm10eFdvcmxkVG9WaWV3KTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IG10eFZpZXdUb1dvcmxkLmdldCgpO1xyXG4gICAgICBsZXQgcmF5V29ybGQ6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF9wb2ludEluQ2xpcFNwYWNlLCBtdHhWaWV3VG9Xb3JsZCwgdHJ1ZSk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogX3BvaW50SW5DbGlwU3BhY2UueCArIG1bN10gKiBfcG9pbnRJbkNsaXBTcGFjZS55ICsgbVsxMV0gKiBfcG9pbnRJbkNsaXBTcGFjZS56ICsgbVsxNV07XHJcbiAgICAgIHJheVdvcmxkLnNjYWxlKDEgLyB3KTtcclxuXHJcbiAgICAgIHJldHVybiByYXlXb3JsZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5jbHJCYWNrZ3JvdW5kLFxyXG4gICAgICAgIGJhY2tncm91bmRFbmFibGVkOiB0aGlzLmJhY2tncm91bmRFbmFibGVkLFxyXG4gICAgICAgIHByb2plY3Rpb246IHRoaXMucHJvamVjdGlvbixcclxuICAgICAgICBmaWVsZE9mVmlldzogdGhpcy5maWVsZE9mVmlldyxcclxuICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxyXG4gICAgICAgIGFzcGVjdDogdGhpcy5hc3BlY3RSYXRpbyxcclxuICAgICAgICBwaXZvdDogdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuY2xyQmFja2dyb3VuZCA9IF9zZXJpYWxpemF0aW9uLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgdGhpcy5iYWNrZ3JvdW5kRW5hYmxlZCA9IF9zZXJpYWxpemF0aW9uLmJhY2tncm91bmRFbmFibGVkO1xyXG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBfc2VyaWFsaXphdGlvbi5wcm9qZWN0aW9uO1xyXG4gICAgICB0aGlzLmZpZWxkT2ZWaWV3ID0gX3NlcmlhbGl6YXRpb24uZmllbGRPZlZpZXc7XHJcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBfc2VyaWFsaXphdGlvbi5hc3BlY3Q7XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gX3NlcmlhbGl6YXRpb24uZGlyZWN0aW9uO1xyXG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICBzd2l0Y2ggKHRoaXMucHJvamVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5PUlRIT0dSQVBISUM6XHJcbiAgICAgICAgICB0aGlzLnByb2plY3RPcnRob2dyYXBoaWMoKTsgLy8gVE9ETzogc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBST0pFQ1RJT04uQ0VOVFJBTDpcclxuICAgICAgICAgIHRoaXMucHJvamVjdENlbnRyYWwoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAgIGlmICh0eXBlcy5kaXJlY3Rpb24pXHJcbiAgICAgICAgdHlwZXMuZGlyZWN0aW9uID0gRklFTERfT0ZfVklFVztcclxuICAgICAgaWYgKHR5cGVzLnByb2plY3Rpb24pXHJcbiAgICAgICAgdHlwZXMucHJvamVjdGlvbiA9IFBST0pFQ1RJT047XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMucHJvamVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5DRU5UUkFMOlxyXG4gICAgICAgICAgdGhpcy5wcm9qZWN0Q2VudHJhbCh0aGlzLmFzcGVjdFJhdGlvLCB0aGlzLmZpZWxkT2ZWaWV3LCB0aGlzLmRpcmVjdGlvbik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci50cmFuc2Zvcm07XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRmlsdGVycyBzeW5jaHJvbml6YXRpb24gYmV0d2VlbiBhIGdyYXBoIGluc3RhbmNlIGFuZCB0aGUgZ3JhcGggaXQgaXMgY29ubmVjdGVkIHRvLiBJZiBhY3RpdmUsIG5vIHN5bmNocm9uaXphdGlvbiBvY2N1cnMuXHJcbiAgICogTWF5YmUgbW9yZSBmaW5lZ3JhaW5lZCBpbiB0aGUgZnV0dXJlLi4uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEdyYXBoRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRHcmFwaEZpbHRlcik7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCB0eXBlIFR5cGVPZkxpZ2h0ID0gbmV3ICgpID0+IExpZ2h0O1xyXG4gIC8qKlxyXG4gICAqIEJhc2VjbGFzcyBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGxpZ2h0cy4gXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTGlnaHQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIHB1YmxpYyBjb2xvcjogQ29sb3I7XHJcbiAgICBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEsIDEpKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFR5cGUoKTogVHlwZU9mTGlnaHQge1xyXG4gICAgICByZXR1cm4gPFR5cGVPZkxpZ2h0PnRoaXMuY29uc3RydWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3Iuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgdGhpcy5jb2xvci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2xvcik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKCk6IHZvaWQgey8qKi8gfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW1iaWVudCBsaWdodCwgY29taW5nIGZyb20gYWxsIGRpcmVjdGlvbnMsIGlsbHVtaW5hdGluZyBldmVyeXRoaW5nIHdpdGggaXRzIGNvbG9yIGluZGVwZW5kZW50IG9mIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiAobGlrZSBhIGZvZ2d5IGRheSBvciBpbiB0aGUgc2hhZGVzKSAgXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogfiB+IH4gIFxyXG4gICAqICB+IH4gfiAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIExpZ2h0QW1iaWVudCBleHRlbmRzIExpZ2h0IHtcclxuICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSkpIHtcclxuICAgICAgc3VwZXIoX2NvbG9yKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogRGlyZWN0aW9uYWwgbGlnaHQsIGlsbHVtaW5hdGluZyBldmVyeXRoaW5nIGZyb20gYSBzcGVjaWZpZWQgZGlyZWN0aW9uIHdpdGggaXRzIGNvbG9yIChsaWtlIHN0YW5kaW5nIGluIGJyaWdodCBzdW5saWdodCkgIFxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqIC0tLT4gIFxyXG4gICAqIC0tLT4gIFxyXG4gICAqIC0tLT4gIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBMaWdodERpcmVjdGlvbmFsIGV4dGVuZHMgTGlnaHQge1xyXG4gICAgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSkge1xyXG4gICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBPbW5pZGlyZWN0aW9uYWwgbGlnaHQgZW1pdHRpbmcgZnJvbSBpdHMgcG9zaXRpb24sIGlsbHVtaW5hdGluZyBvYmplY3RzIGRlcGVuZGluZyBvbiB0aGVpciBwb3NpdGlvbiBhbmQgZGlzdGFuY2Ugd2l0aCBpdHMgY29sb3IgKGxpa2UgYSBjb2xvcmVkIGxpZ2h0IGJ1bGIpICBcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgIC5cXHwvLlxyXG4gICAqICAgICAgICAtLSBvIC0tXHJcbiAgICogICAgICAgICDCtC98XFxgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIExpZ2h0UG9pbnQgZXh0ZW5kcyBMaWdodCB7XHJcbiAgICBwdWJsaWMgcmFuZ2U6IG51bWJlciA9IDEwO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTcG90IGxpZ2h0IGVtaXR0aW5nIHdpdGhpbiBhIHNwZWNpZmllZCBhbmdsZSBmcm9tIGl0cyBwb3NpdGlvbiwgaWxsdW1pbmF0aW5nIG9iamVjdHMgZGVwZW5kaW5nIG9uIHRoZWlyIHBvc2l0aW9uIGFuZCBkaXN0YW5jZSB3aXRoIGl0cyBjb2xvciAgXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgbyAgXHJcbiAgICogICAgICAgICAvfFxcICBcclxuICAgKiAgICAgICAgLyB8IFxcIFxyXG4gICAqIGBgYCAgIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBMaWdodFNwb3QgZXh0ZW5kcyBMaWdodCB7XHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vTGlnaHQvTGlnaHQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyB0eXBlcyBvZiBsaWdodCB0aGlzIGNvbXBvbmVudCBjYW4gcHJvdmlkZS4gIFxyXG4gICAqL1xyXG4gIC8vIGV4cG9ydCBsZXQgTElHSFRfVFlQRTogeyBbdHlwZTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgZXhwb3J0IGVudW0gTElHSFRfVFlQRSB7XHJcbiAgICBBTUJJRU5UID0gXCJMaWdodEFtYmllbnRcIixcclxuICAgIERJUkVDVElPTkFMID0gXCJMaWdodERpcmVjdGlvbmFsXCIsXHJcbiAgICBQT0lOVCA9IFwiTGlnaHRQb2ludFwiLFxyXG4gICAgU1BPVCA9IFwiTGlnaHRTcG90XCJcclxuICB9XHJcbiAgLyoqXHJcbiAgICAqIEF0dGFjaGVzIGEge0BsaW5rIExpZ2h0fSB0byB0aGUgbm9kZVxyXG4gICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50TGlnaHQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudExpZ2h0KTtcclxuICAgIC8vIHByaXZhdGUgc3RhdGljIGNvbnN0cnVjdG9yczogeyBbdHlwZTogc3RyaW5nXTogR2VuZXJhbCB9ID0geyBbTElHSFRfVFlQRS5BTUJJRU5UXTogTGlnaHRBbWJpZW50LCBbTElHSFRfVFlQRS5ESVJFQ1RJT05BTF06IExpZ2h0RGlyZWN0aW9uYWwsIFtMSUdIVF9UWVBFLlBPSU5UXTogTGlnaHRQb2ludCwgW0xJR0hUX1RZUEUuU1BPVF06IExpZ2h0U3BvdCB9O1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyBsaWdodDogTGlnaHQgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9saWdodDogTGlnaHQgPSBuZXcgTGlnaHRBbWJpZW50KCkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5saWdodCA9IF9saWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0VHlwZTxUIGV4dGVuZHMgTGlnaHQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiB2b2lkIHtcclxuICAgICAgbGV0IG10ck9sZDogTXV0YXRvciA9IHt9O1xyXG4gICAgICBpZiAodGhpcy5saWdodClcclxuICAgICAgICBtdHJPbGQgPSB0aGlzLmxpZ2h0LmdldE11dGF0b3IoKTtcclxuXHJcbiAgICAgIHRoaXMubGlnaHQgPSBuZXcgX2NsYXNzKCk7XHJcbiAgICAgIHRoaXMubGlnaHQubXV0YXRlKG10ck9sZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgcGl2b3Q6IHRoaXMubXR4UGl2b3Quc2VyaWFsaXplKCksXHJcbiAgICAgICAgbGlnaHQ6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMubGlnaHQpXHJcbiAgICAgIH07XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgdGhpcy5saWdodCA9IGF3YWl0IDxQcm9taXNlPExpZ2h0Pj5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmxpZ2h0KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuICAgICAgbXV0YXRvci50eXBlID0gdGhpcy5saWdodC5nZXRUeXBlKCkubmFtZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLnR5cGUpXHJcbiAgICAgICAgdHlwZXMudHlwZSA9IExJR0hUX1RZUEU7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCB0eXBlOiBzdHJpbmcgPSBfbXV0YXRvci50eXBlO1xyXG4gICAgICBpZiAodHlwZW9mICh0eXBlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlICE9IHRoaXMubGlnaHQuY29uc3RydWN0b3IubmFtZSlcclxuICAgICAgICB0aGlzLnNldFR5cGUoU2VyaWFsaXplci5nZXRDb25zdHJ1Y3RvcjxMaWdodD4odHlwZSkpO1xyXG4gICAgICBkZWxldGUgKF9tdXRhdG9yLnR5cGUpOyAvLyBleGNsdWRlIGxpZ2h0IHR5cGUgZnJvbSBmdXJ0aGVyIG11dGF0aW9uXHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIF9tdXRhdG9yLnR5cGUgPSB0eXBlOyAvLyByZWNvbnN0cnVjdCBtdXRhdG9yXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGEge0BsaW5rIE1hdGVyaWFsfSB0byB0aGUgbm9kZVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5IC0gMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRNYXRlcmlhbCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50TWF0ZXJpYWwpO1xyXG4gICAgcHVibGljIGNsclByaW1hcnk6IENvbG9yID0gQ29sb3IuQ1NTKFwid2hpdGVcIik7XHJcbiAgICBwdWJsaWMgY2xyU2Vjb25kYXJ5OiBDb2xvciA9IENvbG9yLkNTUyhcIndoaXRlXCIpO1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyBtYXRlcmlhbDogTWF0ZXJpYWw7XHJcbiAgICAvLyoqIHN1cHBvcnQgc29ydGluZyBvZiBvYmplY3RzIHdpdGggdHJhbnNwYXJlbmN5IHdoZW4gcmVuZGVyaW5nLCByZW5kZXIgb2JqZWN0cyBpbiB0aGUgYmFjayBmaXJzdCAqL1xyXG4gICAgcHVibGljIHNvcnRGb3JBbHBoYTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLy8gcHVibGljIG11dGF0b3JDb2F0OiBNdXRhdG9yRm9yQ29tcG9uZW50O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWF0ZXJpYWw6IE1hdGVyaWFsID0gbnVsbCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm1hdGVyaWFsID0gX21hdGVyaWFsO1xyXG4gICAgICAvLyB0aGlzLm11dGF0b3JDb2F0ID0gX21hdGVyaWFsLmdldENvYXQoKS5nZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBzb3J0Rm9yQWxwaGE6IHRoaXMuc29ydEZvckFscGhhLFxyXG4gICAgICAgIGNsclByaW1hcnk6IHRoaXMuY2xyUHJpbWFyeS5zZXJpYWxpemUoKSxcclxuICAgICAgICBjbHJTZWNvbmRhcnk6IHRoaXMuY2xyU2Vjb25kYXJ5LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIHBpdm90OiB0aGlzLm10eFBpdm90LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKCksXHJcbiAgICAgICAgaWRNYXRlcmlhbDogdGhpcy5tYXRlcmlhbC5pZFJlc291cmNlXHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm1hdGVyaWFsID0gPE1hdGVyaWFsPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRNYXRlcmlhbCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuY2xyUHJpbWFyeS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jbHJQcmltYXJ5KTtcclxuICAgICAgYXdhaXQgdGhpcy5jbHJTZWNvbmRhcnkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY2xyU2Vjb25kYXJ5KTtcclxuICAgICAgdGhpcy5zb3J0Rm9yQWxwaGEgPSBfc2VyaWFsaXphdGlvbi5zb3J0Rm9yQWxwaGE7XHJcbiAgICAgIGF3YWl0IHRoaXMubXR4UGl2b3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucGl2b3QpO1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSgpOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSB7XHJcbiAgICAvLyAgIGxldCBtdXRhdG9yQ29hdDogTXV0YXRvckZvckNvbXBvbmVudCA9IHRoaXMubWF0ZXJpYWwuZ2V0Q29hdCgpLmdldE11dGF0b3JGb3JDb21wb25lbnQoKTtcclxuICAgIC8vICAgcmV0dXJuIDxNdXRhdG9yRm9yVXNlckludGVyZmFjZT48dW5rbm93bj5tdXRhdG9yQ29hdDtcclxuICAgIC8vIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGEge0BsaW5rIE1lc2h9IHRvIHRoZSBub2RlXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50TWVzaCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50TWVzaCk7XHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyBtZXNoOiBNZXNoO1xyXG5cclxuICAgICNza2VsZXRvbjogU2tlbGV0b25JbnN0YW5jZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21lc2g/OiBNZXNoLCBfc2tlbGV0b24/OiBTa2VsZXRvbkluc3RhbmNlKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IF9tZXNoO1xyXG4gICAgICBpZiAoX3NrZWxldG9uKVxyXG4gICAgICAgIHRoaXMuYmluZFNrZWxldG9uKF9za2VsZXRvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCByYWRpdXMoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLm10eFdvcmxkLnNjYWxpbmc7XHJcbiAgICAgIGxldCBzY2FsZTogbnVtYmVyID0gTWF0aC5tYXgoTWF0aC5hYnMoc2NhbGluZy54KSwgTWF0aC5hYnMoc2NhbGluZy55KSwgTWF0aC5hYnMoc2NhbGluZy56KSk7XHJcbiAgICAgIHJldHVybiB0aGlzLm1lc2gucmFkaXVzICogc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBza2VsZXRvbigpOiBTa2VsZXRvbkluc3RhbmNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NrZWxldG9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kU2tlbGV0b24oX3NrZWxldG9uOiBTa2VsZXRvbkluc3RhbmNlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3NrZWxldG9uID0gX3NrZWxldG9uO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLnNrZWxldG9uICYmICF0aGlzLm5vZGUpXHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICBpZiAoX2V2ZW50LnRhcmdldCAhPSB0aGlzKSByZXR1cm47XHJcbiAgICAgICAgICB0aGlzLm5vZGUuYWRkQ2hpbGQodGhpcy5za2VsZXRvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIGVsc2UgaWYgKHRoaXMubm9kZSlcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2hpbGQodGhpcy5za2VsZXRvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLyoqXHJcbiAgICAvLyAgKiBDYWxjdWxhdGVzIHRoZSBwb3NpdGlvbiBvZiBhIHZlcnRleCB0cmFuc2Zvcm1lZCBieSB0aGUgc2tlbGV0b25cclxuICAgIC8vICAqIEBwYXJhbSBfaW5kZXggaW5kZXggb2YgdGhlIHZlcnRleFxyXG4gICAgLy8gICovXHJcbiAgICAvLyBwdWJsaWMgZ2V0VmVydGV4UG9zaXRpb24oX2luZGV4OiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgIC8vICAgLy8gZXh0cmFjdCB0aGUgdmVydGV4IGRhdGEgKHZlcnRpY2VzOiAzRCB2ZWN0b3JzLCBib25lIGluZGljZXMgJiB3ZWlnaHRzOiA0RCB2ZWN0b3JzKVxyXG4gICAgLy8gICBjb25zdCBpVmVydGV4OiBudW1iZXIgPSBfaW5kZXggKiAzO1xyXG4gICAgLy8gICBjb25zdCBpQm9uZUluZmx1ZW5jZTogbnVtYmVyID0gX2luZGV4ICogNDtcclxuICAgICAgXHJcbiAgICAvLyAgIGNvbnN0IHZlcnRleDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKC4uLlJlZmxlY3QuZ2V0KHRoaXMubWVzaCwgXCJyZW5kZXJNZXNoXCIpLnZlcnRpY2VzLnNsaWNlKGlWZXJ0ZXgsIGlWZXJ0ZXggKyAzKSk7XHJcbiAgICAvLyAgIGlmICghKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2hTa2luKSkgcmV0dXJuIHZlcnRleDtcclxuXHJcbiAgICAvLyAgIGNvbnN0IGlCb25lczogVWludDhBcnJheSA9IHRoaXMubWVzaC5pQm9uZXMuc2xpY2UoaUJvbmVJbmZsdWVuY2UsIGlCb25lSW5mbHVlbmNlICsgNCk7XHJcbiAgICAvLyAgIGNvbnN0IHdlaWdodHM6IEZsb2F0MzJBcnJheSA9IHRoaXMubWVzaC53ZWlnaHRzLnNsaWNlKGlCb25lSW5mbHVlbmNlLCBpQm9uZUluZmx1ZW5jZSArIDQpO1xyXG5cclxuICAgIC8vICAgLy8gZ2V0IGJvbmUgbWF0cmljZXNcclxuICAgIC8vICAgY29uc3QgbXR4Qm9uZXM6IEFycmF5PE1hdHJpeDR4ND4gPSB0aGlzLnNrZWxldG9uLm10eEJvbmVzO1xyXG5cclxuICAgIC8vICAgLy8gc2tpbiBtYXRyaXggUyA9IHN1bV9pPTFebXt3X2kgKiBCX2l9XHJcbiAgICAvLyAgIGNvbnN0IHNraW5NYXRyaXg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcclxuICAgIC8vICAgc2tpbk1hdHJpeC5zZXQoQXJyYXlcclxuICAgIC8vICAgICAuZnJvbShpQm9uZXMpXHJcbiAgICAvLyAgICAgLm1hcCgoaUJvbmUsIGlXZWlnaHQpID0+IG10eEJvbmVzW2lCb25lXS5nZXQoKS5tYXAodmFsdWUgPT4gdmFsdWUgKiB3ZWlnaHRzW2lXZWlnaHRdKSkgLy8gYXBwbHkgd2VpZ2h0IG9uIGVhY2ggbWF0cml4XHJcbiAgICAvLyAgICAgLnJlZHVjZSgobXR4U3VtLCBtdHhCb25lKSA9PiBtdHhTdW0ubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICsgbXR4Qm9uZVtpbmRleF0pKSAvLyBzdW0gdXAgdGhlIG1hdHJpY2VzXHJcbiAgICAvLyAgICk7XHJcblxyXG4gICAgLy8gICAvLyB0cmFuc2Zvcm0gdmVydGV4XHJcbiAgICAvLyAgIHZlcnRleC50cmFuc2Zvcm0oc2tpbk1hdHJpeCk7XHJcblxyXG4gICAgLy8gICByZXR1cm4gdmVydGV4O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIFRPRE86IHJlbW92ZSBvciB0aGluayBpZiB0aGUgdHJhbnNmb3JtZWQgYm91bmRpbmcgYm94IGlzIG9mIHZhbHVlIG9yIGNhbiBiZSBtYWRlIHRvIGJlXHJcbiAgICAvLyBwdWJsaWMgZ2V0IGJvdW5kaW5nQm94KCk6IEJveCB7XHJcbiAgICAvLyAgIGxldCBib3g6IEJveCA9IFJlY3ljbGVyLmdldChCb3gpO1xyXG4gICAgLy8gICBib3guc2V0KFxyXG4gICAgLy8gICAgIFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5tZXNoLmJvdW5kaW5nQm94Lm1pbiwgdGhpcy5tdHhXb3JsZCwgdHJ1ZSksXHJcbiAgICAvLyAgICAgVmVjdG9yMy5UUkFOU0ZPUk1BVElPTih0aGlzLm1lc2guYm91bmRpbmdCb3gubWF4LCB0aGlzLm10eFdvcmxkLCB0cnVlKVxyXG4gICAgLy8gICApO1xyXG4gICAgLy8gICByZXR1cm4gYm94O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb247XHJcbiAgICAgIC8qIGF0IHRoaXMgcG9pbnQgb2YgdGltZSwgc2VyaWFsaXphdGlvbiBhcyByZXNvdXJjZSBhbmQgYXMgaW5saW5lIG9iamVjdCBpcyBwb3NzaWJsZS4gVE9ETzogY2hlY2sgaWYgaW5saW5lIGJlY29tZXMgb2Jzb2xldGUgKi9cclxuICAgICAgbGV0IGlkTWVzaDogc3RyaW5nID0gdGhpcy5tZXNoLmlkUmVzb3VyY2U7XHJcbiAgICAgIGlmIChpZE1lc2gpXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbiA9IHsgaWRNZXNoOiBpZE1lc2ggfTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24gPSB7IG1lc2g6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMubWVzaCkgfTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnNrZWxldG9uKVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24uc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uLm5hbWU7XHJcblxyXG4gICAgICBzZXJpYWxpemF0aW9uLnBpdm90ID0gdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbWVzaDogTWVzaDtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTWVzaClcclxuICAgICAgICBtZXNoID0gPE1lc2g+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZE1lc2gpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbWVzaCA9IDxNZXNoPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWVzaCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IG1lc2g7XHJcblxyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uc2tlbGV0b24pXHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICBpZiAoX2V2ZW50LnRhcmdldCAhPSB0aGlzKSByZXR1cm47XHJcbiAgICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DSElMRF9BUFBFTkQsIChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgU2tlbGV0b25JbnN0YW5jZSAmJiBfZXZlbnQudGFyZ2V0Lm5hbWUgPT0gX3NlcmlhbGl6YXRpb24uc2tlbGV0b24pXHJcbiAgICAgICAgICAgICAgdGhpcy4jc2tlbGV0b24gPSBfZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvckZvclVzZXJJbnRlcmZhY2UgPSA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIC8vIGlmICghdGhpcy5tZXNoKVxyXG4gICAgICAvLyAgIG11dGF0b3IubWVzaCA9IE1lc2g7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBlbnVtIFBJQ0sge1xyXG4gICAgUkFESVVTID0gXCJyYWRpdXNcIixcclxuICAgIENBTUVSQSA9IFwiY2FtZXJhXCIsXHJcbiAgICBQSFlTSUNTID0gXCJwaHlzaWNzXCJcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciBzY3JpcHRzIHRoZSB1c2VyIHdyaXRlc1xyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL0NvbXBvbmVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRQaWNrIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRQaWNrKTtcclxuICAgIHB1YmxpYyBwaWNrOiBQSUNLID0gUElDSy5SQURJVVM7XHJcblxyXG4gICAgcHVibGljIHBpY2tBbmREaXNwYXRjaChfcmF5OiBSYXksIF9ldmVudDogUG9pbnRlckV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gY21wTWVzaCA/IGNtcE1lc2gubXR4V29ybGQudHJhbnNsYXRpb24gOiB0aGlzLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb247XHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMucGljaykge1xyXG4gICAgICAgIGNhc2UgUElDSy5SQURJVVM6XHJcbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgb25seSBiZSBub2RlLnJhZGl1cy4gQWRqdXN0bWVudCBuZWVkZWQsIGlmIG1lc2ggd2FzIHRyYW5zZm9ybWVkLi4uXHJcbiAgICAgICAgICBpZiAoX3JheS5nZXREaXN0YW5jZShwb3NpdGlvbikubWFnbml0dWRlIDwgdGhpcy5ub2RlLnJhZGl1cykge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSUNLLlBIWVNJQ1M6XHJcbiAgICAgICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IFBoeXNpY3MucmF5Y2FzdChfcmF5Lm9yaWdpbiwgX3JheS5kaXJlY3Rpb24sIFZlY3RvcjMuRElGRkVSRU5DRShwb3NpdGlvbiwgX3JheS5vcmlnaW4pLm1hZ25pdHVkZVNxdWFyZWQpO1xyXG4gICAgICAgICAgaWYgKGhpdEluZm8uaGl0KVxyXG4gICAgICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMucGljaylcclxuICAgICAgICB0eXBlcy5waWNrID0gUElDSztcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIHNjcmlwdHMgdGhlIHVzZXIgd3JpdGVzXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFNjcmlwdCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAvLyByZWdpc3RlcmluZyB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSwgb25seSBpdHMgc3ViY2xhc3Nlcy4gT3IgdGhpcyBjb21wb25lbnQgbXVzdCByZWZlciB0byBzY3JpcHRzIHRvIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50XHJcbiAgICAvLyBUT0RPOiByZXRoaW5rICYgcmVmYWN0b3JcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRTY3JpcHQpO1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2luZ2xldG9uID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEJBU0Uge1xyXG4gICAgU0VMRiwgUEFSRU5ULCBXT1JMRCwgTk9ERVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB0cmFuc2Zvcm0tW1tNYXRyaXg0eDR9IHRvIHRoZSBub2RlLCBtb3ZpbmcsIHNjYWxpbmcgYW5kIHJvdGF0aW5nIGl0IGluIHNwYWNlIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50VHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRUcmFuc2Zvcm0pO1xyXG4gICAgcHVibGljIG10eExvY2FsOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9tdHhJbml0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm10eExvY2FsID0gX210eEluaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9ucyByZXNwZWN0aW5nIHRoZSBoaWVyYXJjaHlcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIHJvdGF0aW9uIHRvIHBvaW50IHRoZSB6LWF4aXMgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHRhcmdldCBwb2ludCBpbiB3b3JsZCBzcGFjZSBhbmQgdGlsdHMgaXQgdG8gYWNjb3JkIHdpdGggdGhlIGdpdmVuIHVwIHZlY3RvcixcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLiBJZiBubyB1cCB2ZWN0b3IgaXMgZ2l2ZW4sIHRoZSBwcmV2aW91cyB1cC12ZWN0b3IgaXMgdXNlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb29rQXQoX3RhcmdldFdvcmxkOiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCBjb250YWluZXI6IE5vZGUgPSB0aGlzLm5vZGU7XHJcbiAgICAgIGlmICghY29udGFpbmVyICYmICFjb250YWluZXIuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXR4TG9jYWwubG9va0F0KF90YXJnZXRXb3JsZCwgX3VwKTtcclxuXHJcbiAgICAgIC8vIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0byBhIGNoaWxkIG5vZGUgLT4gdHJhbnNmb3JtIHJlc3BlY3RpbmcgdGhlIGhpZXJhcmNoeVxyXG4gICAgICBsZXQgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IGNvbnRhaW5lci5tdHhXb3JsZC5jbG9uZTtcclxuICAgICAgbXR4V29ybGQubG9va0F0KF90YXJnZXRXb3JsZCwgX3VwLCB0cnVlKTtcclxuICAgICAgbGV0IG10eExvY2FsOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUkVMQVRJVkUobXR4V29ybGQsIG51bGwsIGNvbnRhaW5lci5nZXRQYXJlbnQoKS5tdHhXb3JsZEludmVyc2UpO1xyXG4gICAgICB0aGlzLm10eExvY2FsID0gbXR4TG9jYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSByb3RhdGlvbiB0byBtYXRjaCBpdHMgeS1heGlzIHdpdGggdGhlIGdpdmVuIHVwLXZlY3RvciBhbmQgZmFjaW5nIGl0cyB6LWF4aXMgdG93YXJkIHRoZSBnaXZlbiB0YXJnZXQgYXQgbWluaW1hbCBhbmdsZSxcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS4gSWYgbm8gdXAgdmVjdG9yIGlzIGdpdmVuLCB0aGUgcHJldmlvdXMgdXAtdmVjdG9yIGlzIHVzZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvd1RvKF90YXJnZXRXb3JsZDogVmVjdG9yMywgX3VwPzogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgY29udGFpbmVyOiBOb2RlID0gdGhpcy5ub2RlO1xyXG4gICAgICBpZiAoIWNvbnRhaW5lciAmJiAhY29udGFpbmVyLmdldFBhcmVudCgpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm10eExvY2FsLnNob3dUbyhfdGFyZ2V0V29ybGQsIF91cCk7XHJcblxyXG4gICAgICAvLyBjb21wb25lbnQgaXMgYXR0YWNoZWQgdG8gYSBjaGlsZCBub2RlIC0+IHRyYW5zZm9ybSByZXNwZWN0aW5nIHRoZSBoaWVyYXJjaHlcclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBjb250YWluZXIubXR4V29ybGQuY2xvbmU7XHJcbiAgICAgIG10eFdvcmxkLnNob3dUbyhfdGFyZ2V0V29ybGQsIF91cCwgdHJ1ZSk7XHJcbiAgICAgIGxldCBtdHhMb2NhbDogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJFTEFUSVZFKG10eFdvcmxkLCBudWxsLCBjb250YWluZXIuZ2V0UGFyZW50KCkubXR4V29ybGRJbnZlcnNlKTtcclxuICAgICAgdGhpcy5tdHhMb2NhbCA9IG10eExvY2FsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVjYWxjdWxhdGVzIHRoaXMgbG9jYWwgbWF0cml4IHRvIHlpZWxkIHRoZSBpZGVudGljYWwgd29ybGQgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBub2RlLlxyXG4gICAgICogVXNlIHJlYmFzZSBiZWZvcmUgYXBwZW5kaW5nIHRoZSBjb250YWluZXIgb2YgdGhpcyBjb21wb25lbnQgdG8gYW5vdGhlciBub2RlIHdoaWxlIHByZXNlcnZpbmcgaXRzIHRyYW5zZm9ybWF0aW9uIGluIHRoZSB3b3JsZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlYmFzZShfbm9kZTogTm9kZSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5tdHhMb2NhbDtcclxuICAgICAgbGV0IGNvbnRhaW5lcjogTm9kZSA9IHRoaXMubm9kZTtcclxuICAgICAgaWYgKGNvbnRhaW5lcilcclxuICAgICAgICBtdHhSZXN1bHQgPSBjb250YWluZXIubXR4V29ybGQ7XHJcblxyXG4gICAgICBpZiAoX25vZGUpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0LlJFTEFUSVZFKG10eFJlc3VsdCwgbnVsbCwgX25vZGUubXR4V29ybGRJbnZlcnNlKTtcclxuXHJcbiAgICAgIHRoaXMubXR4TG9jYWwgPSBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0ZWQgYmFzZSAoU0VMRiwgUEFSRU5ULCBXT1JMRCkgb3IgYSBwYXJ0aWN1bGFyIG90aGVyIG5vZGUgKE5PREUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX210eFRyYW5zZm9ybTogTWF0cml4NHg0LCBfYmFzZTogQkFTRSA9IEJBU0UuU0VMRiwgX25vZGU6IE5vZGUgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIHN3aXRjaCAoX2Jhc2UpIHtcclxuICAgICAgICBjYXNlIEJBU0UuU0VMRjpcclxuICAgICAgICAgIHRoaXMubXR4TG9jYWwubXVsdGlwbHkoX210eFRyYW5zZm9ybSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJBU0UuUEFSRU5UOlxyXG4gICAgICAgICAgdGhpcy5tdHhMb2NhbC5tdWx0aXBseShfbXR4VHJhbnNmb3JtLCB0cnVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkFTRS5OT0RFOlxyXG4gICAgICAgICAgaWYgKCFfbm9kZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQkFTRS5OT0RFIHJlcXVpcmVzIGEgbm9kZSBnaXZlbiBhcyBiYXNlXCIpO1xyXG4gICAgICAgIGNhc2UgQkFTRS5XT1JMRDpcclxuICAgICAgICAgIHRoaXMucmViYXNlKF9ub2RlKTtcclxuICAgICAgICAgIHRoaXMubXR4TG9jYWwubXVsdGlwbHkoX210eFRyYW5zZm9ybSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgbGV0IG5vZGU6IE5vZGUgPSB0aGlzLm5vZGU7XHJcbiAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBsZXQgbXR4VGVtcDogTWF0cml4NHg0O1xyXG4gICAgICAgICAgICBpZiAoX2Jhc2UgPT0gQkFTRS5OT0RFKSB7XHJcbiAgICAgICAgICAgICAgLy8gZml4IG10eFdvcmxkIG9mIGNvbnRhaW5lciBmb3Igc3Vic2VxdWVudCByZWJhc2luZyBcclxuICAgICAgICAgICAgICBtdHhUZW1wID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9ub2RlLm10eFdvcmxkLCBub2RlLm10eExvY2FsKTtcclxuICAgICAgICAgICAgICBub2RlLm10eFdvcmxkLnNldChtdHhUZW1wKTtcclxuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhUZW1wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmVudDogTm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAvLyBmaXggbXR4TG9jYWwgZm9yIGN1cnJlbnQgcGFyZW50XHJcbiAgICAgICAgICAgICAgdGhpcy5yZWJhc2Uobm9kZS5nZXRQYXJlbnQoKSk7XHJcbiAgICAgICAgICAgICAgbXR4VGVtcCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihub2RlLmdldFBhcmVudCgpLm10eFdvcmxkLCBub2RlLm10eExvY2FsKTtcclxuICAgICAgICAgICAgICBub2RlLm10eFdvcmxkLnNldChtdHhUZW1wKTtcclxuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhUZW1wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbG9jYWw6IHRoaXMubXR4TG9jYWwuc2VyaWFsaXplKCksXHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhMb2NhbC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5sb2NhbCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgIC8vICAgICB0aGlzLmxvY2FsLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAvLyB9XHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHsgXHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0TXV0YXRvcigpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgLy8gICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gdGhpcy5sb2NhbC5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgLy8gICAgIHJldHVybiB0eXBlcztcclxuICAgIC8vIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iud29ybGQ7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0NPTlRST0wge1xyXG4gICAgSU5QVVQgPSBcImlucHV0XCIsXHJcbiAgICBPVVRQVVQgPSBcIm91dHB1dFwiXHJcbiAgfVxyXG5cclxuICBleHBvcnQgY29uc3QgZW51bSBDT05UUk9MX1RZUEUge1xyXG4gICAgLyoqIFRoZSBvdXRwdXQgc2ltcGx5IGZvbGxvd3MgdGhlIHNjYWxlZCBhbmQgZGVsYXllZCBpbnB1dCAqL1xyXG4gICAgUFJPUE9SVElPTkFMLFxyXG4gICAgLyoqIFRoZSBvdXRwdXQgdmFsdWUgY2hhbmdlcyBvdmVyIHRpbWUgd2l0aCBhIHJhdGUgZ2l2ZW4gYnkgdGhlIHNjYWxlZCBhbmQgZGVsYXllZCBpbnB1dCAqL1xyXG4gICAgSU5URUdSQUwsXHJcbiAgICAvKiogVGhlIG91dHB1dCB2YWx1ZSByZWFjdHMgdG8gY2hhbmdlcyBvZiB0aGUgc2NhbGVkIGlucHV0IGFuZCBkcm9wcyB0byAwIHdpdGggZ2l2ZW4gZGVsYXksIGlmIGlucHV0IHJlbWFpbnMgY29uc3RhbnQgKi9cclxuICAgIERJRkZFUkVOVElBTFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2Vzc2VzIGlucHV0IHNpZ25hbHMgb2YgdHlwZSBudW1iZXIgYW5kIGdlbmVyYXRlcyBhbiBvdXRwdXQgc2lnbmFsIG9mIHRoZSBzYW1lIHR5cGUgdXNpbmcgXHJcbiAgICogcHJvcG9ydGlvbmFsLCBpbnRlZ3JhbCBvciBkaWZmZXJlbnRpYWwgbWFwcGluZywgYW4gYW1wbGlmaWNhdGlvbiBmYWN0b3IgYW5kIGEgbGluZWFyIGRhbXBlbmluZy9kZWxheVxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgIOKUgiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgIHBhc3MgdGhyb3VnaCAoUHJvcG9ydGlvbmFsKSAgICAgIOKUglxyXG4gICAqICBJbnB1dCDihpIg4pSCIOKGkiDilIJhbXBsaWZ54pSCIOKGkiDilIJkZWxheeKUgiDihpIg4pqfIHN1bSB1cCBvdmVyIHRpbWUgKEludGVncmFsKSDimp4g4oaSIOKUgiDihpIgT3V0cHV0XHJcbiAgICogICAgICAgICAg4pSCICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgcGFzcyBjaGFuZ2UgIChEaWZmZXJlbnRpYWwpICAgICAg4pSCXHJcbiAgICogICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb250cm9sIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IENPTlRST0xfVFlQRTtcclxuICAgIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCByYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRCYXNlOiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIG91dHB1dFRhcmdldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRUYXJnZXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBmYWN0b3I6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIHRpbWU6IFRpbWUgPSBUaW1lLmdhbWU7XHJcbiAgICBwcm90ZWN0ZWQgdGltZVZhbHVlRGVsYXk6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdGltZU91dHB1dFRhcmdldFNldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBpZFRpbWVyOiBudW1iZXIgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX2ZhY3RvcjogbnVtYmVyID0gMSwgX3R5cGU6IENPTlRST0xfVFlQRSA9IENPTlRST0xfVFlQRS5QUk9QT1JUSU9OQUwsIF9hY3RpdmU6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZmFjdG9yID0gX2ZhY3RvcjtcclxuICAgICAgdGhpcy50eXBlID0gX3R5cGU7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gX2FjdGl2ZTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpbWUtb2JqZWN0IHRvIGJlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgb3V0cHV0IGluIHtAbGluayBDT05UUk9MX1RZUEUuSU5URUdSQUx9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUaW1lYmFzZShfdGltZTogVGltZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy5jYWxjdWxhdGVPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZlZWQgYW4gaW5wdXQgdmFsdWUgaW50byB0aGlzIGNvbnRyb2wgYW5kIGZpcmUgdGhlIGV2ZW50cyB7QGxpbmsgRVZFTlRfQ09OVFJPTC5JTlBVVH0gYW5kIHtAbGluayBFVkVOVF9DT05UUk9MLk9VVFBVVH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldElucHV0KF9pbnB1dDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICB0aGlzLm91dHB1dEJhc2UgPSB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xyXG4gICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG4gICAgICB0aGlzLm91dHB1dFRhcmdldCA9IHRoaXMuZmFjdG9yICogX2lucHV0O1xyXG4gICAgICB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQgPSB0aGlzLnRpbWUuZ2V0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy50eXBlID09IENPTlRST0xfVFlQRS5ESUZGRVJFTlRJQUwpIHtcclxuICAgICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLm91dHB1dFRhcmdldCAtIHRoaXMub3V0cHV0VGFyZ2V0UHJldmlvdXM7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3V0cHV0VGFyZ2V0ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVF9DT05UUk9MLklOUFVUKSk7XHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OVFJPTF9UWVBFLkRJRkZFUkVOVElBTClcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KHRoaXMudmFsdWVQcmV2aW91cyk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwdWxzZShfaW5wdXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldElucHV0KF9pbnB1dCk7XHJcbiAgICAgIHRoaXMuc2V0SW5wdXQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpbWUgdG8gdGFrZSBmb3IgdGhlIGludGVybmFsIGxpbmVhciBkYW1wZW5pbmcgdW50aWwgdGhlIGZpbmFsIG91cHV0IHZhbHVlIGlzIHJlYWNoZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlbGF5KF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy50aW1lVmFsdWVEZWxheSA9IE1hdGgubWF4KDAsIF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIG91dHB1dC1ldmVudHMgdG8gZGlzcGF0Y2ggcGVyIHNlY29uZC4gXHJcbiAgICAgKiBBdCB0aGUgZGVmYXVsdCBvZiAwLCB0aGUgY29udHJvbCBvdXRwdXQgbXVzdCBiZSBwb2xsZWQgYW5kIHdpbGwgb25seSBhY3RpdmVseSBkaXNwYXRjaGVkIG9uY2UgZWFjaCB0aW1lIGlucHV0IG9jY3VycyBhbmQgdGhlIG91dHB1dCBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UmF0ZURpc3BhdGNoT3V0cHV0KF9yYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQgPSBfcmF0ZURpc3BhdGNoT3V0cHV0O1xyXG4gICAgICB0aGlzLnRpbWUuZGVsZXRlVGltZXIodGhpcy5pZFRpbWVyKTtcclxuICAgICAgdGhpcy5pZFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICBpZiAodGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQpXHJcbiAgICAgICAgdGhpcy5pZFRpbWVyID0gdGhpcy50aW1lLnNldFRpbWVyKDEwMDAgLyB0aGlzLnJhdGVEaXNwYXRjaE91dHB1dCwgMCwgdGhpcy5kaXNwYXRjaE91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGZhY3RvciB0byBtdWx0aXBseSB0aGUgaW5wdXQgdmFsdWUgZ2l2ZW4gd2l0aCB7QGxpbmsgc2V0SW5wdXR9IHdpdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEZhY3RvcihfZmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IG91dHB1dDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHZhbHVlOiBudW1iZXIgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5JTlRFR1JBTDpcclxuICAgICAgICAgIGxldCB0aW1lQ3VycmVudDogbnVtYmVyID0gdGhpcy50aW1lLmdldCgpO1xyXG4gICAgICAgICAgbGV0IHRpbWVFbGFwc2VkU2luY2VJbnB1dDogbnVtYmVyID0gdGltZUN1cnJlbnQgLSB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQ7XHJcbiAgICAgICAgICBvdXRwdXQgPSB0aGlzLm91dHB1dEJhc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMudGltZVZhbHVlRGVsYXkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVWYWx1ZURlbGF5KSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICAgIHRpbWVFbGFwc2VkU2luY2VJbnB1dCAtPSB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvdXRwdXQgKz0gdmFsdWUgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAvLyB2YWx1ZSArPSAwLjUgKiAodGhpcy5pbnB1dFByZXZpb3VzIC0gaW5wdXQpICogdGhpcy50aW1lSW5wdXREZWxheSArIGlucHV0ICogdGltZUVsYXBzZWRTaW5jZUlucHV0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMOlxyXG4gICAgICAgIGNhc2UgQ09OVFJPTF9UWVBFLlBST1BPUlRJT05BTDpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgb3V0cHV0ID0gdmFsdWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSBvdXRwdXQgY29uc2lkZXJpbmcgdGhlIHRpbWUgb2YgdGhlIGRlbGF5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0VmFsdWVEZWxheWVkKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnRpbWVWYWx1ZURlbGF5ID4gMCkge1xyXG4gICAgICAgIGxldCB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ6IG51bWJlciA9IHRoaXMudGltZS5nZXQoKSAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcclxuICAgICAgICBpZiAodGltZUVsYXBzZWRTaW5jZUlucHV0IDwgdGhpcy50aW1lVmFsdWVEZWxheSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlUHJldmlvdXMgKyAodGhpcy5vdXRwdXRUYXJnZXQgLSB0aGlzLnZhbHVlUHJldmlvdXMpICogdGltZUVsYXBzZWRTaW5jZUlucHV0IC8gdGhpcy50aW1lVmFsdWVEZWxheTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRUYXJnZXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByaXZhdGUgZGlzcGF0Y2hPdXRwdXQgPSAoX2V2ZW50T3JWYWx1ZTogRXZlbnRUaW1lciB8IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZS5nZXRUaW1lcih0aGlzLmlkVGltZXIpO1xyXG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXI7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9ldmVudE9yVmFsdWUpID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgb3V0cHV0ID0gX2V2ZW50T3JWYWx1ZTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91dHB1dCA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICAgIGxldCBvdXRwdXRDaGFuZ2VkOiBib29sZWFuID0gKG91dHB1dCAhPSB0aGlzLm91dHB1dFByZXZpb3VzKTtcclxuXHJcbiAgICAgIGlmICh0aW1lcikge1xyXG4gICAgICAgIHRpbWVyLmFjdGl2ZSA9IG91dHB1dENoYW5nZWQ7XHJcbiAgICAgICAgaWYgKCFvdXRwdXRDaGFuZ2VkKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm91dHB1dFByZXZpb3VzID0gb3V0cHV0O1xyXG5cclxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge1xyXG4gICAgICAgIGRldGFpbDoge1xyXG4gICAgICAgICAgb3V0cHV0OiBvdXRwdXRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJDb250cm9sLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIYW5kbGVzIG11bHRpcGxlIGNvbnRyb2xzIGFzIGlucHV0cyBhbmQgY3JlYXRlcyBhbiBvdXRwdXQgZnJvbSB0aGF0LlxyXG4gICAqIEFzIGEgc3ViY2xhc3Mgb2Yge0BsaW5rIENvbnRyb2x9LCBheGlzIGNhbGN1bGF0ZXMgdGhlIG91cHV0IHN1bW1pbmcgdXAgdGhlIGlucHV0cyBhbmQgcHJvY2Vzc2luZyB0aGUgcmVzdWx0IHVzaW5nIGl0cyBvd24gc2V0dGluZ3MuICBcclxuICAgKiBEaXNwYXRjaGVzIHtAbGluayBFVkVOVF9DT05UUk9MLk9VVFBVVH0gYW5kIHtAbGluayBFVkVOVF9DT05UUk9MLklOUFVUfSB3aGVuIG9uZSBvZiB0aGUgY29udHJvbHMgZGlzcGF0Y2hlcyB0aGVtLlxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiAgICAgICAgICAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgSW5wdXQg4oaSIOKUgiDilIJjb250cm9s4pSCXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICBcXOKUjOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUglxyXG4gICAqICAgSW5wdXQg4oaSIOKUgiDilIJjb250cm9s4pSCLS0t4pSCc3Vt4pSCIOKGkiDilIJpbnRlcm5hbCBjb250cm9sIOKUgiDihpIg4pSCIOKGkiBPdXRwdXRcclxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgL+KUlOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIC8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIIvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBeGlzIGV4dGVuZHMgQ29udHJvbCB7XHJcbiAgICBwcml2YXRlIGNvbnRyb2xzOiBNYXA8c3RyaW5nLCBDb250cm9sPiA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgc3VtUHJldmlvdXM6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIGNvbnRyb2wgZ2l2ZW4gdG8gdGhlIGxpc3Qgb2YgY29udHJvbHMgZmVlZGluZyBpbnRvIHRoaXMgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ29udHJvbChfY29udHJvbDogQ29udHJvbCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNvbnRyb2xzLnNldChfY29udHJvbC5uYW1lLCBfY29udHJvbCk7XHJcbiAgICAgIF9jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQ09OVFJPTC5JTlBVVCwgdGhpcy5obmRJbnB1dEV2ZW50KTtcclxuICAgICAgX2NvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLk9VVFBVVCwgdGhpcy5obmRPdXRwdXRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbnRyb2woX25hbWU6IHN0cmluZyk6IENvbnRyb2wge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb250cm9scy5nZXQoX25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBuYW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb250cm9sKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgbGV0IGNvbnRyb2w6IENvbnRyb2wgPSB0aGlzLmdldENvbnRyb2woX25hbWUpO1xyXG4gICAgICBpZiAoY29udHJvbCkge1xyXG4gICAgICAgIGNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLklOUFVULCB0aGlzLmhuZElucHV0RXZlbnQpO1xyXG4gICAgICAgIGNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLk9VVFBVVCwgdGhpcy5obmRPdXRwdXRFdmVudCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9scy5kZWxldGUoX25hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGF4aXMgYWZ0ZXIgc3VtbWluZyB1cCBhbGwgaW5wdXRzIGFuZCBwcm9jZXNzaW5nIHRoZSBzdW0gYWNjb3JkaW5nIHRvIHRoZSBheGlzJyBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T3V0cHV0KCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzdW1JbnB1dDogbnVtYmVyID0gMDtcclxuICAgICAgZm9yIChsZXQgY29udHJvbCBvZiB0aGlzLmNvbnRyb2xzKSB7XHJcblxyXG4gICAgICAgIGlmIChjb250cm9sWzFdLmFjdGl2ZSlcclxuICAgICAgICAgIHN1bUlucHV0ICs9IGNvbnRyb2xbMV0uZ2V0T3V0cHV0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdW1JbnB1dCAhPSB0aGlzLnN1bVByZXZpb3VzKVxyXG4gICAgICAgIHN1cGVyLnNldElucHV0KHN1bUlucHV0KTtcclxuXHJcbiAgICAgIHRoaXMuc3VtUHJldmlvdXMgPSBzdW1JbnB1dDtcclxuXHJcbiAgICAgIHJldHVybiBzdXBlci5nZXRPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhuZE91dHB1dEV2ZW50OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgY29udHJvbDogQ29udHJvbCA9ICg8Q29udHJvbD5fZXZlbnQudGFyZ2V0KTtcclxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge2RldGFpbDoge1xyXG4gICAgICAgIGNvbnRyb2w6IGNvbnRyb2wsIFxyXG4gICAgICAgIGlucHV0OiAoPEN1c3RvbUV2ZW50Pl9ldmVudCkuZGV0YWlsLm91dHB1dCxcclxuICAgICAgICBvdXRwdXQ6IHRoaXMuZ2V0T3V0cHV0KClcclxuICAgICAgfX0pO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kSW5wdXRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50ID0gbmV3IEV2ZW50KEVWRU5UX0NPTlRST0wuSU5QVVQsIF9ldmVudCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgaW50ZXJmYWNlIEtleVByZXNzZWQge1xyXG4gICAgW2NvZGU6IHN0cmluZ106IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0cyB0aGUga2V5cyBwcmVzc2VkIG9uIHRoZSBrZXlib2FyZCBhbmQgc3RvcmVzIHRoZWlyIHN0YXR1cy4gXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEtleWJvYXJkIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGtleXNQcmVzc2VkOiBLZXlQcmVzc2VkID0gS2V5Ym9hcmQuaW5pdGlhbGl6ZSgpO1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgY29kZV9lbjogT2JqZWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cyBpcyBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRPbmUoX2tleXM6IEtFWUJPQVJEX0NPREVbXSk6IGJvb2xlYW4ge1xyXG4gICAgICBmb3IgKGxldCBjb2RlIG9mIF9rZXlzKSB7XHJcbiAgICAgICAgaWYgKEtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgY3VycmVudGx5IGJlaW5nIHByZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRDb21ibyhfa2V5czogS0VZQk9BUkRfQ09ERVtdKTogYm9vbGVhbiB7XHJcbiAgICAgIGZvciAobGV0IGNvZGUgb2YgX2tleXMpIHtcclxuICAgICAgICBpZiAoIUtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZ2l2ZW4gYXMgX2FjdGl2ZSBpZiBvbmUgb3IsIHdoZW4gX2NvbWJvIGlzIHRydWUsIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgcHJlc3NlZC5cclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGdpdmVuIGFzIF9pbmFjdGl2ZSBpZiBub3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWFwVG9WYWx1ZTxUPihfYWN0aXZlOiBULCBfaW5hY3RpdmU6IFQsIF9rZXlzOiBLRVlCT0FSRF9DT0RFW10sIF9jb21ibzogYm9vbGVhbiA9IGZhbHNlKTogVCB7XHJcbiAgICAgIGlmICghX2NvbWJvICYmIEtleWJvYXJkLmlzUHJlc3NlZE9uZShfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIGlmIChLZXlib2FyZC5pc1ByZXNzZWRDb21ibyhfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIHJldHVybiBfaW5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYmFsYW5jZWQgdGVybmFyeSB2YWx1ZSAoZWl0aGVyIC0xLCAwIG9yIDEpIFxyXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBtYXRjaCBvZiB0aGUga2V5cyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgdGhlIGxpc3RzIG9mIGtleXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWFwVG9Ucml0KF9wb3NpdGl2ZTogS0VZQk9BUkRfQ09ERVtdLCBfbmVnYXRpdmU6IEtFWUJPQVJEX0NPREVbXSk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBLZXlib2FyZC5tYXBUb1ZhbHVlKC0xLCAwLCBfbmVnYXRpdmUpICsgS2V5Ym9hcmQubWFwVG9WYWx1ZSgxLCAwLCBfcG9zaXRpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgbG9jYWxlKF9rZXlib2FyZDogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAvLyAgIGlmICghS2V5Ym9hcmQuY29kZV9lbikge1xyXG4gICAgLy8gICAgIC8vIHNhdmUgb3JpZ2luYWwga2V5Ym9hcmQgY29kZXMgdG8gYmUgYWJsZSB0byBzd2l0Y2ggYmFjayBsYXRlclxyXG4gICAgLy8gICAgIEtleWJvYXJkLmNvZGVfZW4gPSB7fTtcclxuICAgIC8vICAgICBPYmplY3QuYXNzaWduKEtleWJvYXJkLmNvZGVfZW4sIEtFWUJPQVJEX0NPREUpO1xyXG4gICAgLy8gICB9XHJcblxyXG4gICAgLy8gICBmb3IgKGxldCBrZXkgaW4gX2tleWJvYXJkKSB7XHJcbiAgICAvLyAgICAgbGV0IHZhbHVlOiBzdHJpbmcgPSBSZWZsZWN0LmdldChfa2V5Ym9hcmQsIGtleSk7XHJcbiAgICAvLyAgICAgZm9yIChsZXQgb3JpZ2luYWwgaW4gS0VZQk9BUkRfQ09ERSlcclxuICAgIC8vICAgICAgIGlmIChSZWZsZWN0LmdldChLRVlCT0FSRF9DT0RFLCBvcmlnaW5hbCkgPT0gdmFsdWUpXHJcbiAgICAvLyAgICAgICAgIC8vIHJlbW92ZSBvcmlnaW5hbCBrZXkgdGhlIHlpZWxkcyB0aGUgdmFsdWVcclxuICAgIC8vICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShLRVlCT0FSRF9DT0RFLCBvcmlnaW5hbCk7XHJcbiAgICAvLyAgICAgLy8gYWRkIG5ldyBrZXkgdG8geWllbGQgdGhhdCB2YWx1ZVxyXG4gICAgLy8gICAgIFJlZmxlY3Quc2V0KEtFWUJPQVJEX0NPREUsIGtleSwgdmFsdWUpO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5pdGlhbGl6ZSgpOiBLZXlQcmVzc2VkIHtcclxuICAgICAgbGV0IHN0b3JlOiBLZXlQcmVzc2VkID0ge307XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgcmV0dXJuIHN0b3JlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGhuZEtleUludGVyYWN0aW9uKF9ldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICBLZXlib2FyZC5rZXlzUHJlc3NlZFtfZXZlbnQuY29kZV0gPSAoX2V2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRpbmcgdG8gdGhlIGFsZXJ0IGJveFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z0FsZXJ0IGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLklORk9dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5XQVJOXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRVJST1JdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLlNPVVJDRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxyXG4gICAgfTtcclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRGVsZWdhdGUoX2hlYWRsaW5lOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBkZWxlZ2F0ZTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGFyZ3M6IHN0cmluZ1tdID0gX2FyZ3MubWFwKF9hcmcgPT4gX2FyZy50b1N0cmluZygpKTtcclxuICAgICAgICBsZXQgb3V0OiBzdHJpbmcgPSBfaGVhZGxpbmUgKyBcIiBcIiArIERlYnVnVGFyZ2V0Lm1lcmdlQXJndW1lbnRzKF9tZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICBhbGVydChvdXQpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICAvKipcclxuICAgICAqIFJvdXRpbmcgdG8gYSBIVE1MRGlhbG9nRWxlbWVudFxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgRGVidWdEaWFsb2cgZXh0ZW5kcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2tvdXQgSFRNTERpYWxvZ0VsZW1lbnQ7ICEhIVxyXG4gICAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUm91dGUgdG8gYW4gSFRNTFRleHRBcmVhLCBtYXkgYmUgb2Jzb2xldGUgd2hlbiB1c2luZyBIVE1MRGlhbG9nRWxlbWVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z1RleHRBcmVhIGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXh0QXJlYTogSFRNTFRleHRBcmVhRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgYXV0b1Njcm9sbDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLklORk9dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5XQVJOXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRVJST1JdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkNMRUFSXTogRGVidWdUZXh0QXJlYS5jbGVhcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUF06IERlYnVnVGV4dEFyZWEuZ3JvdXAsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRURdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQRU5EXTogRGVidWdUZXh0QXJlYS5ncm91cEVuZCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuU09VUkNFXSlcclxuICAgIH07XHJcbiAgICBwcml2YXRlIHN0YXRpYyBncm91cHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBncm91cChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEucHJpbnQoXCLilrwgXCIgKyBfbmFtZSk7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzLnB1c2goX25hbWUpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHN0YXRpYyBncm91cEVuZCgpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVEZWxlZ2F0ZShfaGVhZGxpbmU6IHN0cmluZyk6IEZ1bmN0aW9uIHtcclxuICAgICAgbGV0IGRlbGVnYXRlOiBGdW5jdGlvbiA9IGZ1bmN0aW9uIChfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgICBEZWJ1Z1RleHRBcmVhLnByaW50KF9oZWFkbGluZSArIFwiIFwiICsgRGVidWdUYXJnZXQubWVyZ2VBcmd1bWVudHMoX21lc3NhZ2UsIF9hcmdzKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBkZWxlZ2F0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRJbmRlbnRhdGlvbihfbGV2ZWw6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfbGV2ZWw7IGkrKylcclxuICAgICAgICByZXN1bHQgKz0gXCJ8IFwiO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByaW50KF90ZXh0OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCArPSBEZWJ1Z1RleHRBcmVhLmdldEluZGVudGF0aW9uKERlYnVnVGV4dEFyZWEuZ3JvdXBzLmxlbmd0aCkgKyBfdGV4dCArIFwiXFxuXCI7XHJcbiAgICAgIGlmIChEZWJ1Z1RleHRBcmVhLmF1dG9TY3JvbGwpXHJcbiAgICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS5zY3JvbGxUb3AgPSBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnNjcm9sbEhlaWdodDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9BVURJTyB7XHJcbiAgICAvKiogYnJvYWRjYXN0IHRvIGEge0BsaW5rIE5vZGV9IGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzIGluIHRoZSBncmFwaCBhZnRlciBpdCB3YXMgYXBwZW5kZWQgdG8gYSBwYXJlbnQgKi9cclxuICAgIENISUxEX0FQUEVORCA9IFwiY2hpbGRBcHBlbmRUb0F1ZGlvR3JhcGhcIixcclxuICAgIC8qKiBicm9hZGNhc3QgdG8gYSB7QGxpbmsgTm9kZX0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIGp1c3QgYmVmb3JlIGl0cyBiZWluZyByZW1vdmVkIGZyb20gaXRzIHBhcmVudCAqL1xyXG4gICAgQ0hJTERfUkVNT1ZFID0gXCJjaGlsZFJlbW92ZUZyb21BdWRpb0dyYXBoXCIsXHJcbiAgICAvKiogYnJvYWRjYXN0IHRvIGEge0BsaW5rIE5vZGV9IGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzIGluIHRoZSBncmFwaCB0byB1cGRhdGUgdGhlIHBhbm5lcnMgaW4gQXVkaW9Db21wb25lbnRzICovXHJcbiAgICBVUERBVEUgPSBcInVwZGF0ZUF1ZGlvR3JhcGhcIixcclxuICAgIC8qKiBmaXJlZCB3aGVuIHRoZSBhdWRpbyBmaWxlIHdhcyBsb2FkZWQgYW5kIGlzIHJlYWR5IGZvciBwbGF5aW5nICovXHJcbiAgICBSRUFEWSA9IFwicmVhZHlcIixcclxuICAgIC8qKiBmaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGF1ZGlvIGlzIHJlYWNoZWQgd2hpbGUgcGxheWluZyAqL1xyXG4gICAgRU5ERUQgPSBcImVuZGVkXCJcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAgIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0RSQUdEUk9QIHtcclxuICAgICAgICBEUkFHID0gXCLGkmRyYWdcIixcclxuICAgICAgICBEUk9QID0gXCLGkmRyb3BcIixcclxuICAgICAgICBTVEFSVCA9IFwixpJkcmFnc3RhcnRcIixcclxuICAgICAgICBFTkQgPSBcIsaSZHJhZ2VuZFwiLFxyXG4gICAgICAgIE9WRVIgPSBcIsaSZHJhZ292ZXJcIlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBhIHN1YmNsYXNzIG9mIERyYWdFdmVudCAuQSBldmVudCB0aGF0IHJlcHJlc2VudHMgYSBkcmFnIGFuZCBkcm9wIGludGVyYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudERyYWdEcm9wIGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclg6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclk6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2FudmFzWDogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjYW52YXNZOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNsaWVudFJlY3Q6IENsaWVudFJlY3Q7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudERyYWdEcm9wKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50Pl9ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRhcmdldC5nZXRDbGllbnRSZWN0cygpWzBdO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJYID0gX2V2ZW50LmNsaWVudFggLSB0aGlzLmNsaWVudFJlY3QubGVmdDtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyWSA9IF9ldmVudC5jbGllbnRZIC0gdGhpcy5jbGllbnRSZWN0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBhIHN1YmNsYXNzIG9mIEtleWJvYXJkRXZlbnQuIEV2ZW50S2V5Ym9hcmQgb2JqZWN0cyBkZXNjcmliZSBhIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUga2V5Ym9hcmRcclxuICAgKiBlYWNoIGV2ZW50IGRlc2NyaWJlcyBhIHNpbmdsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIHRoZSB1c2VyIGFuZCBhIGtleSAob3IgY29tYmluYXRpb24gb2YgYSBrZXkgd2l0aCBtb2RpZmllciBrZXlzKSBvbiB0aGUga2V5Ym9hcmQuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEV2ZW50S2V5Ym9hcmQgZXh0ZW5kcyBLZXlib2FyZEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudEtleWJvYXJkKSB7XHJcbiAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYXBwaW5ncyBvZiBzdGFuZGFyZCBET00vQnJvd3Nlci1FdmVudHMgYXMgcGFzc2VkIGZyb20gYSBjYW52YXMgdG8gdGhlIHZpZXdwb3J0XHJcbiAgICovXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfS0VZQk9BUkQge1xyXG4gICAgVVAgPSBcIsaSa2V5dXBcIixcclxuICAgIERPV04gPSBcIsaSa2V5ZG93blwiLFxyXG4gICAgUFJFU1MgPSBcIsaSa2V5cHJlc3NcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNvZGVzIHNlbnQgZnJvbSBhIHN0YW5kYXJkIGVuZ2xpc2gga2V5Ym9hcmQgbGF5b3V0XHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERSB7XHJcbiAgICBBID0gXCJLZXlBXCIsXHJcbiAgICBCID0gXCJLZXlCXCIsXHJcbiAgICBDID0gXCJLZXlDXCIsXHJcbiAgICBEID0gXCJLZXlEXCIsXHJcbiAgICBFID0gXCJLZXlFXCIsXHJcbiAgICBGID0gXCJLZXlGXCIsXHJcbiAgICBHID0gXCJLZXlHXCIsXHJcbiAgICBIID0gXCJLZXlIXCIsXHJcbiAgICBJID0gXCJLZXlJXCIsXHJcbiAgICBKID0gXCJLZXlKXCIsXHJcbiAgICBLID0gXCJLZXlLXCIsXHJcbiAgICBMID0gXCJLZXlMXCIsXHJcbiAgICBNID0gXCJLZXlNXCIsXHJcbiAgICBOID0gXCJLZXlOXCIsXHJcbiAgICBPID0gXCJLZXlPXCIsXHJcbiAgICBQID0gXCJLZXlQXCIsXHJcbiAgICBRID0gXCJLZXlRXCIsXHJcbiAgICBSID0gXCJLZXlSXCIsXHJcbiAgICBTID0gXCJLZXlTXCIsXHJcbiAgICBUID0gXCJLZXlUXCIsXHJcbiAgICBVID0gXCJLZXlVXCIsXHJcbiAgICBWID0gXCJLZXlWXCIsXHJcbiAgICBXID0gXCJLZXlXXCIsXHJcbiAgICBYID0gXCJLZXlYXCIsXHJcbiAgICBZID0gXCJLZXlZXCIsXHJcbiAgICBaID0gXCJLZXlaXCIsXHJcbiAgICBFU0MgPSBcIkVzY2FwZVwiLFxyXG4gICAgWkVSTyA9IFwiRGlnaXQwXCIsXHJcbiAgICBPTkUgPSBcIkRpZ2l0MVwiLFxyXG4gICAgVFdPID0gXCJEaWdpdDJcIixcclxuICAgIFRIUkVFID0gXCJEaWdpdDNcIixcclxuICAgIEZPVVIgPSBcIkRpZ2l0NFwiLFxyXG4gICAgRklWRSA9IFwiRGlnaXQ1XCIsXHJcbiAgICBTSVggPSBcIkRpZ2l0NlwiLFxyXG4gICAgU0VWRU4gPSBcIkRpZ2l0N1wiLFxyXG4gICAgRUlHSFQgPSBcIkRpZ2l0OFwiLFxyXG4gICAgTklORSA9IFwiRGlnaXQ5XCIsXHJcbiAgICBNSU5VUyA9IFwiTWludXNcIixcclxuICAgIEVRVUFMID0gXCJFcXVhbFwiLFxyXG4gICAgQkFDS1NQQUNFID0gXCJCYWNrc3BhY2VcIixcclxuICAgIFRBQlVMQVRPUiA9IFwiVGFiXCIsXHJcbiAgICBCUkFDS0VUX0xFRlQgPSBcIkJyYWNrZXRMZWZ0XCIsXHJcbiAgICBCUkFDS0VUX1JJR0hUID0gXCJCcmFja2V0UmlnaHRcIixcclxuICAgIEVOVEVSID0gXCJFbnRlclwiLFxyXG4gICAgQ1RSTF9MRUZUID0gXCJDb250cm9sTGVmdFwiLFxyXG4gICAgU0VNSUNPTE9OID0gXCJTZW1pY29sb25cIixcclxuICAgIFFVT1RFID0gXCJRdW90ZVwiLFxyXG4gICAgQkFDS19RVU9URSA9IFwiQmFja3F1b3RlXCIsXHJcbiAgICBTSElGVF9MRUZUID0gXCJTaGlmdExlZnRcIixcclxuICAgIEJBQ0tTTEFTSCA9IFwiQmFja3NsYXNoXCIsXHJcbiAgICBDT01NQSA9IFwiQ29tbWFcIixcclxuICAgIFBFUklPRCA9IFwiUGVyaW9kXCIsXHJcbiAgICBTTEFTSCA9IFwiU2xhc2hcIixcclxuICAgIFNISUZUX1JJR0hUID0gXCJTaGlmdFJpZ2h0XCIsXHJcbiAgICBOVU1QQURfTVVMVElQTFkgPSBcIk51bXBhZE11bHRpcGx5XCIsXHJcbiAgICBBTFRfTEVGVCA9IFwiQWx0TGVmdFwiLFxyXG4gICAgU1BBQ0UgPSBcIlNwYWNlXCIsXHJcbiAgICBDQVBTX0xPQ0sgPSBcIkNhcHNMb2NrXCIsXHJcbiAgICBGMSA9IFwiRjFcIixcclxuICAgIEYyID0gXCJGMlwiLFxyXG4gICAgRjMgPSBcIkYzXCIsXHJcbiAgICBGNCA9IFwiRjRcIixcclxuICAgIEY1ID0gXCJGNVwiLFxyXG4gICAgRjYgPSBcIkY2XCIsXHJcbiAgICBGNyA9IFwiRjdcIixcclxuICAgIEY4ID0gXCJGOFwiLFxyXG4gICAgRjkgPSBcIkY5XCIsXHJcbiAgICBGMTAgPSBcIkYxMFwiLFxyXG4gICAgUEFVU0UgPSBcIlBhdXNlXCIsXHJcbiAgICBTQ1JPTExfTE9DSyA9IFwiU2Nyb2xsTG9ja1wiLFxyXG4gICAgTlVNUEFENyA9IFwiTnVtcGFkN1wiLFxyXG4gICAgTlVNUEFEOCA9IFwiTnVtcGFkOFwiLFxyXG4gICAgTlVNUEFEOSA9IFwiTnVtcGFkOVwiLFxyXG4gICAgTlVNUEFEX1NVQlRSQUNUID0gXCJOdW1wYWRTdWJ0cmFjdFwiLFxyXG4gICAgTlVNUEFENCA9IFwiTnVtcGFkNFwiLFxyXG4gICAgTlVNUEFENSA9IFwiTnVtcGFkNVwiLFxyXG4gICAgTlVNUEFENiA9IFwiTnVtcGFkNlwiLFxyXG4gICAgTlVNUEFEX0FERCA9IFwiTnVtcGFkQWRkXCIsXHJcbiAgICBOVU1QQUQxID0gXCJOdW1wYWQxXCIsXHJcbiAgICBOVU1QQUQyID0gXCJOdW1wYWQyXCIsXHJcbiAgICBOVU1QQUQzID0gXCJOdW1wYWQzXCIsXHJcbiAgICBOVU1QQUQwID0gXCJOdW1wYWQwXCIsXHJcbiAgICBOVU1QQURfREVDSU1BTCA9IFwiTnVtcGFkRGVjaW1hbFwiLFxyXG4gICAgUFJJTlRfU0NSRUVOID0gXCJQcmludFNjcmVlblwiLFxyXG4gICAgSU5UTF9CQUNLX1NMQVNIID0gXCJJbnRsQmFja1NsYXNoXCIsXHJcbiAgICBGMTEgPSBcIkYxMVwiLFxyXG4gICAgRjEyID0gXCJGMTJcIixcclxuICAgIE5VTVBBRF9FUVVBTCA9IFwiTnVtcGFkRXF1YWxcIixcclxuICAgIEYxMyA9IFwiRjEzXCIsXHJcbiAgICBGMTQgPSBcIkYxNFwiLFxyXG4gICAgRjE1ID0gXCJGMTVcIixcclxuICAgIEYxNiA9IFwiRjE2XCIsXHJcbiAgICBGMTcgPSBcIkYxN1wiLFxyXG4gICAgRjE4ID0gXCJGMThcIixcclxuICAgIEYxOSA9IFwiRjE5XCIsXHJcbiAgICBGMjAgPSBcIkYyMFwiLFxyXG4gICAgRjIxID0gXCJGMjFcIixcclxuICAgIEYyMiA9IFwiRjIyXCIsXHJcbiAgICBGMjMgPSBcIkYyM1wiLFxyXG4gICAgRjI0ID0gXCJGMjRcIixcclxuICAgIEtBTkFfTU9ERSA9IFwiS2FuYU1vZGVcIixcclxuICAgIExBTkcyID0gXCJMYW5nMlwiLFxyXG4gICAgTEFORzEgPSBcIkxhbmcxXCIsXHJcbiAgICBJTlRMX1JPID0gXCJJbnRsUm9cIixcclxuICAgIENPTlZFUlQgPSBcIkNvbnZlcnRcIixcclxuICAgIE5PTl9DT05WRVJUID0gXCJOb25Db252ZXJ0XCIsXHJcbiAgICBJTlRMX1lFTiA9IFwiSW50bFllblwiLFxyXG4gICAgTlVNUEFEX0NPTU1BID0gXCJOdW1wYWRDb21tYVwiLFxyXG4gICAgVU5ETyA9IFwiVW5kb1wiLFxyXG4gICAgUEFTVEUgPSBcIlBhc3RlXCIsXHJcbiAgICBNRURJQV9UUkFDS19QUkVWSU9VUyA9IFwiTWVkaWFUcmFja1ByZXZpb3VzXCIsXHJcbiAgICBDVVQgPSBcIkN1dFwiLFxyXG4gICAgQ09QWSA9IFwiQ29weVwiLFxyXG4gICAgTUVESUFfVFJBQ0tfTkVYVCA9IFwiTWVkaWFUcmFja05leHRcIixcclxuICAgIE5VTVBBRF9FTlRFUiA9IFwiTnVtcGFkRW50ZXJcIixcclxuICAgIENUUkxfUklHSFQgPSBcIkNvbnRyb2xSaWdodFwiLFxyXG4gICAgQVVESU9fVk9MVU1FX01VVEUgPSBcIkF1ZGlvVm9sdW1lTXV0ZVwiLFxyXG4gICAgTEFVTkNIX0FQUDIgPSBcIkxhdW5jaEFwcDJcIixcclxuICAgIE1FRElBX1BMQVlfUEFVU0UgPSBcIk1lZGlhUGxheVBhdXNlXCIsXHJcbiAgICBNRURJQV9TVE9QID0gXCJNZWRpYVN0b3BcIixcclxuICAgIEVKRUNUID0gXCJFamVjdFwiLFxyXG4gICAgQVVESU9fVk9MVU1FX0RPV04gPSBcIkF1ZGlvVm9sdW1lRG93blwiLFxyXG4gICAgVk9MVU1FX0RPV04gPSBcIlZvbHVtZURvd25cIixcclxuICAgIEFVRElPX1ZPTFVNRV9VUCA9IFwiQXVkaW9Wb2x1bWVVcFwiLFxyXG4gICAgVk9MVU1FX1VQID0gXCJWb2x1bWVVcFwiLFxyXG4gICAgQlJPV1NFUl9IT01FID0gXCJCcm93c2VySG9tZVwiLFxyXG4gICAgTlVNUEFEX0RJVklERSA9IFwiTnVtcGFkRGl2aWRlXCIsXHJcbiAgICBBTFRfUklHSFQgPSBcIkFsdFJpZ2h0XCIsXHJcbiAgICBIRUxQID0gXCJIZWxwXCIsXHJcbiAgICBOVU1fTE9DSyA9IFwiTnVtTG9ja1wiLFxyXG4gICAgSE9NRSA9IFwiSG9tZVwiLFxyXG4gICAgQVJST1dfVVAgPSBcIkFycm93VXBcIixcclxuICAgIEFSUk9XX1JJR0hUID0gXCJBcnJvd1JpZ2h0XCIsXHJcbiAgICBBUlJPV19ET1dOID0gXCJBcnJvd0Rvd25cIixcclxuICAgIEFSUk9XX0xFRlQgPSBcIkFycm93TGVmdFwiLFxyXG4gICAgRU5EID0gXCJFbmRcIixcclxuICAgIFBBR0VfVVAgPSBcIlBhZ2VVcFwiLFxyXG4gICAgUEFHRV9ET1dOID0gXCJQYWdlRG93blwiLFxyXG4gICAgSU5TRVJUID0gXCJJbnNlcnRcIixcclxuICAgIERFTEVURSA9IFwiRGVsZXRlXCIsXHJcbiAgICBNRVRBX0xFRlQgPSBcIk1ldGFfTGVmdFwiLFxyXG4gICAgT1NfTEVGVCA9IFwiT1NMZWZ0XCIsXHJcbiAgICBNRVRBX1JJR0hUID0gXCJNZXRhUmlnaHRcIixcclxuICAgIE9TX1JJR0hUID0gXCJPU1JpZ2h0XCIsXHJcbiAgICBDT05URVhUX01FTlUgPSBcIkNvbnRleHRNZW51XCIsXHJcbiAgICBQT1dFUiA9IFwiUG93ZXJcIixcclxuICAgIEJST1dTRVJfU0VBUkNIID0gXCJCcm93c2VyU2VhcmNoXCIsXHJcbiAgICBCUk9XU0VSX0ZBVk9SSVRFUyA9IFwiQnJvd3NlckZhdm9yaXRlc1wiLFxyXG4gICAgQlJPV1NFUl9SRUZSRVNIID0gXCJCcm93c2VyUmVmcmVzaFwiLFxyXG4gICAgQlJPV1NFUl9TVE9QID0gXCJCcm93c2VyU3RvcFwiLFxyXG4gICAgQlJPV1NFUl9GT1JXQVJEID0gXCJCcm93c2VyRm9yd2FyZFwiLFxyXG4gICAgQlJPV1NFUl9CQUNLID0gXCJCcm93c2VyQmFja1wiLFxyXG4gICAgTEFVTkNIX0FQUDEgPSBcIkxhdW5jaEFwcDFcIixcclxuICAgIExBVU5DSF9NQUlMID0gXCJMYXVuY2hNYWlsXCIsXHJcbiAgICBMQVVOQ0hfTUVESUFfUExBWUVSID0gXCJMYXVuY2hNZWRpYVBsYXllclwiLFxyXG5cclxuICAgIC8vbWFjIGJyaW5ncyB0aGlzIGJ1dHR0b25cclxuICAgIEZOID0gXCJGblwiLCAvL25vIGV2ZW50IGZpcmVkIGFjdHVhbGx5XHJcblxyXG4gICAgLy9MaW51eCBicmluZ3MgdGhlc2VcclxuICAgIEFHQUlOID0gXCJBZ2FpblwiLFxyXG4gICAgUFJPUFMgPSBcIlByb3BzXCIsXHJcbiAgICBTRUxFQ1QgPSBcIlNlbGVjdFwiLFxyXG4gICAgT1BFTiA9IFwiT3BlblwiLFxyXG4gICAgRklORCA9IFwiRmluZFwiLFxyXG4gICAgV0FLRV9VUCA9IFwiV2FrZVVwXCIsXHJcbiAgICBOVU1QQURfUEFSRU5UX0xFRlQgPSBcIk51bXBhZFBhcmVudExlZnRcIixcclxuICAgIE5VTVBBRF9QQVJFTlRfUklHSFQgPSBcIk51bXBhZFBhcmVudFJpZ2h0XCIsXHJcblxyXG4gICAgLy9hbmRyb2lkXHJcbiAgICBTTEVFUCA9IFwiU2xlZXBcIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERV9ERSB7XHJcbiAgICBaID0gS0VZQk9BUkRfQ09ERS5ZLFxyXG4gICAgWSA9IEtFWUJPQVJEX0NPREUuWixcclxuICAgIMOWID0gS0VZQk9BUkRfQ09ERS5TRU1JQ09MT04sXHJcbiAgICDDhCA9IEtFWUJPQVJEX0NPREUuUVVPVEUsXHJcbiAgICDDnCA9IEtFWUJPQVJEX0NPREUuQlJBQ0tFVF9MRUZULFxyXG4gICAgSEFTSCA9IEtFWUJPQVJEX0NPREUuQkFDS1NMQVNILFxyXG4gICAgUExVUyA9IEtFWUJPQVJEX0NPREUuQlJBQ0tFVF9SSUdIVCxcclxuICAgIMOfID0gS0VZQk9BUkRfQ09ERS5NSU5VUyxcclxuICAgIEFDVVRFID0gS0VZQk9BUkRfQ09ERS5FUVVBTCxcclxuICAgIExFU1NfVEhBTiA9IEtFWUJPQVJEX0NPREUuSU5UTF9CQUNLX1NMQVNILFxyXG4gICAgTUlOVVMgPSBLRVlCT0FSRF9DT0RFLlNMQVNIXHJcbiAgfVxyXG5cclxuICAvKiBcclxuICBGaXJlZm94IGNhbid0IG1ha2UgdXNlIG9mIHRob3NlIGJ1dHRvbnMgYW5kIENvbWJpbmF0aW9uczpcclxuICBTSU5HRUxFX0JVVFRPTlM6XHJcbiAgIERydWNrLFxyXG4gIENPTUJJTkFUSU9OUzpcclxuICAgU2hpZnQgKyBGMTAsIFNoaWZ0ICsgTnVtcGFkNSxcclxuICAgQ1RSTCArIHEsIENUUkwgKyBGNCxcclxuICAgQUxUICsgRjEsIEFMVCArIEYyLCBBTFQgKyBGMywgQUxUICsgRjcsIEFMVCArIEY4LCBBTFQgKyBGMTBcclxuICBPcGVyYSB3b24ndCBkbyBnb29kIHdpdGggdGhlc2UgQnV0dG9ucyBhbmQgY29tYmluYXRpb25zOlxyXG4gIFNJTkdMRV9CVVRUT05TOlxyXG4gICBGbG9hdDMyQXJyYXksIEYxMSwgQUxULFxyXG4gIENPTUJJTkFUSU9OUzpcclxuICAgQ1RSTCArIHEsIENUUkwgKyB0LCBDVFJMICsgaCwgQ1RSTCArIGcsIENUUkwgKyBuLCBDVFJMICsgZiBcclxuICAgQUxUICsgRjEsIEFMVCArIEYyLCBBTFQgKyBGNCwgQUxUICsgRjUsIEFMVCArIEY2LCBBTFQgKyBGNywgQUxUICsgRjgsIEFMVCArIEYxMFxyXG4gICAqL1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9QT0lOVEVSIHtcclxuICAgICAgICBVUCA9IFwixpJwb2ludGVydXBcIixcclxuICAgICAgICBET1dOID0gXCLGknBvaW50ZXJkb3duXCIsXHJcbiAgICAgICAgTU9WRSA9IFwixpJwb2ludGVybW92ZVwiLFxyXG4gICAgICAgIE9WRVIgPSBcIsaScG9pbnRlcm92ZXJcIixcclxuICAgICAgICBFTlRFUiA9IFwixpJwb2ludGVyZW50ZXJcIixcclxuICAgICAgICBDQU5DRUwgPSBcIsaScG9pbnRlcmNhbmNlbFwiLFxyXG4gICAgICAgIE9VVCA9IFwixpJwb2ludGVyb3V0XCIsXHJcbiAgICAgICAgTEVBVkUgPSBcIsaScG9pbnRlcmxlYXZlXCIsXHJcbiAgICAgICAgR09UQ0FQVFVSRSA9IFwixpJnb3Rwb2ludGVyY2FwdHVyZVwiLFxyXG4gICAgICAgIExPU1RDQVBUVVJFID0gXCLGkmxvc3Rwb2ludGVyY2FwdHVyZVwiXHJcbiAgICB9XHJcbiAgICAvKiogIFxyXG4gICAgICogYSBzdWJjbGFzcyBvZiBQb2ludGVyRXZlbnQuIFRoZSBzdGF0ZSBvZiBhIERPTSBldmVudCBwcm9kdWNlZCBieSBhIHBvaW50ZXIgc3VjaCBhcyB0aGUgZ2VvbWV0cnkgb2YgdGhlIGNvbnRhY3QgcG9pbnRcclxuICAgICAqICovXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRQb2ludGVyIGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclg6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgcG9pbnRlclk6IG51bWJlcjtcclxuICAgICAgICBwdWJsaWMgY2FudmFzWDogbnVtYmVyO1xyXG4gICAgICAgIHB1YmxpYyBjYW52YXNZOiBudW1iZXI7XHJcbiAgICAgICAgcHVibGljIGNsaWVudFJlY3Q6IENsaWVudFJlY3Q7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudFBvaW50ZXIpIHtcclxuICAgICAgICAgICAgc3VwZXIodHlwZSwgX2V2ZW50KTtcclxuICAgICAgICAgICAgbGV0IHRhcmdldDogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+X2V2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKClbMF07XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclggPSBfZXZlbnQuY2xpZW50WCAtIHRoaXMuY2xpZW50UmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJZID0gX2V2ZW50LmNsaWVudFkgLSB0aGlzLmNsaWVudFJlY3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfVElNRVIge1xyXG4gICAgICAgIENBTEwgPSBcIsaSbGFwc2VcIlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBldmVudCB0aGF0IHJlcHJlc2VudHMgYSBjYWxsIGZyb20gYSBUaW1lclxyXG4gICAgICogKi9cclxuICAgIGV4cG9ydCBjbGFzcyBFdmVudFRpbWVyIHtcclxuICAgICAgICBwdWJsaWMgdHlwZTogRVZFTlRfVElNRVIgPSBFVkVOVF9USU1FUi5DQUxMO1xyXG4gICAgICAgIHB1YmxpYyB0YXJnZXQ6IFRpbWVyO1xyXG4gICAgICAgIHB1YmxpYyBhcmd1bWVudHM6IE9iamVjdFtdO1xyXG4gICAgICAgIHB1YmxpYyBmaXJzdENhbGw6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpYyBsYXN0Q2FsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIHB1YmxpYyBjb3VudDogbnVtYmVyO1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcihfdGltZXI6IFRpbWVyLCAuLi5fYXJndW1lbnRzOiBPYmplY3RbXSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IF90aW1lcjtcclxuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBfYXJndW1lbnRzO1xyXG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9XSEVFTCB7XHJcbiAgICAgICAgV0hFRUwgPSBcIsaSd2hlZWxcIlxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN1cGNsYXNzIG9mIFdoZWVsRXZlbnQuIEV2ZW50cyB0aGF0IG9jY3VyIGR1ZSB0byB0aGUgdXNlciBtb3ZpbmcgYSBtb3VzZSB3aGVlbCBvciBzaW1pbGFyIGlucHV0IGRldmljZS5cclxuICAgICAqICovXHJcbiAgICBleHBvcnQgY2xhc3MgRXZlbnRXaGVlbCBleHRlbmRzIFdoZWVsRXZlbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgX2V2ZW50OiBFdmVudFdoZWVsKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHR5cGUsIF9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBub2RlIG1hbmFnZWQgYnkge0BsaW5rIFByb2plY3R9IHRoYXQgZnVuY3Rpb25zIGFzIGEgdGVtcGxhdGUgZm9yIHtAbGluayBHcmFwaEluc3RhbmNlfXMgXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9KaXJrYURlbGxPcm8vRlVER0Uvd2lraS9SZXNvdXJjZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBHcmFwaCBleHRlbmRzIE5vZGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIHR5cGU6IHN0cmluZyA9IFwiR3JhcGhcIjtcclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UgPSB0aGlzLmlkUmVzb3VyY2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICBhd2FpdCBQcm9qZWN0LnJlc3luY0dyYXBoSW5zdGFuY2VzKHRoaXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBbiBpbnN0YW5jZSBvZiBhIHtAbGluayBHcmFwaH0uICBcclxuICAgKiBUaGlzIG5vZGUga2VlcHMgYSByZWZlcmVuY2UgdG8gaXRzIHJlc291cmNlIGFuIGNhbiB0aHVzIG9wdGltaXplIHNlcmlhbGl6YXRpb25cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL1Jlc291cmNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdyYXBoSW5zdGFuY2UgZXh0ZW5kcyBOb2RlIHtcclxuICAgIC8qKiBpZCBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpbnN0YW5jZSB3YXMgY3JlYXRlZCBmcm9tICovXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIEdyYXBoLCBpbnN0ZWFkIG9mIHRoZSBpZFxyXG4gICAgI2lkU291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAjc3luYzogYm9vbGVhbiA9IHRydWU7XHJcbiAgICAjZGVzZXJpYWxpemVGcm9tU291cmNlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY29uc3RydWN0b3IgYWxsb25lIHdpbGwgbm90IGNyZWF0ZSBhIHJlY29uc3RydWN0aW9uLCBidXQgb25seSBzYXZlIHRoZSBpZC5cclxuICAgICAqIFRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgZ3JhcGgsIGNhbGwgcmVzZXQgb24gdGhpcyBvciBzZXQgd2l0aCBhIGdyYXBoIGFzIHBhcmFtZXRlci5cclxuICAgICAqIFByZWZlciBQcm9qZWN0LmNyZWF0ZUdyYXBoSW5zdGFuY2UoX2dyYXBoKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX2dyYXBoPzogR3JhcGgpIHtcclxuICAgICAgc3VwZXIoXCJHcmFwaEluc3RhbmNlXCIpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTVVUQVRFLCB0aGlzLmhuZE11dGF0aW9uSW5zdGFuY2UsIHRydWUpO1xyXG5cclxuICAgICAgaWYgKCFfZ3JhcGgpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aGlzLiNpZFNvdXJjZSA9IF9ncmFwaC5pZFJlc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaWRTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2lkU291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjcmVhdGUgdGhpcyBub2RlIGZyb20gdGhlIHtAbGluayBHcmFwaH0gcmVmZXJlbmNlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVzZXQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCByZXNvdXJjZTogR3JhcGggPSA8R3JhcGg+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZSh0aGlzLiNpZFNvdXJjZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2V0KHJlc291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IG9wdGltaXplIHVzaW5nIHRoZSByZWZlcmVuY2VkIEdyYXBoLCBzZXJpYWxpemUvZGVzZXJpYWxpemUgb25seSB0aGUgZGlmZmVyZW5jZXNcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBmaWx0ZXI6IENvbXBvbmVudEdyYXBoRmlsdGVyID0gdGhpcy5nZXRDb21wb25lbnQoQ29tcG9uZW50R3JhcGhGaWx0ZXIpO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG5cclxuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUpIC8vIGlmIGdyYXBoIHN5bmNocm9uaXNhdGlvbiBpcyB1bmZpbHRlcmVkLCBrbm93aW5nIHRoZSBzb3VyY2UgaXMgc3VmZmljaWVudCBmb3Igc2VyaWFsaXphdGlvblxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24uZGVzZXJpYWxpemVGcm9tU291cmNlID0gdHJ1ZTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24ubmFtZSA9IHRoaXMubmFtZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFNvdXJjZSA9IHRoaXMuI2lkU291cmNlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLiNpZFNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkU291cmNlO1xyXG4gICAgICBpZiAoIV9zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplRnJvbVNvdXJjZSkgXHJcbiAgICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pOyAvLyBpbnN0YW5jZSBpcyBkZXNlcmlhbGl6ZWQgZnJvbSBpbmRpdmlkdWFsIGRhdGFcclxuICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IHRoaXMuZ2V0KCk7XHJcblxyXG4gICAgICBpZiAoZ3JhcGgpXHJcbiAgICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplRnJvbVNvdXJjZSkgLy8gbm8gY29tcG9uZW50cy0+IGFzc3VtZSBzeW5jaHJvbml6ZWQgR3JhcGhJbnN0YW5jZVxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXQoZ3JhcGgpOyAvLyByZWNyZWF0ZSBjb21wbGV0ZSBpbnN0YW5jZSBmcm9tIHNvdXJjZSBncmFwaFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0VG9HcmFwaCgpOyAvLyBvdGhlcndpc2UganVzdCBjb25uZWN0XHJcbiAgICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBQcm9qZWN0LnJlZ2lzdGVyR3JhcGhJbnN0YW5jZUZvclJlc3luYyh0aGlzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY29ubmVjdFRvR3JhcGgoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCBncmFwaDogR3JhcGggPSB0aGlzLmdldCgpO1xyXG4gICAgICBpZiAodGhpcy4jZGVzZXJpYWxpemVGcm9tU291cmNlKVxyXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0KGdyYXBoKTtcclxuXHJcbiAgICAgIC8vIGdyYXBoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTVVUQVRFLCAoX2V2ZW50OiBDdXN0b21FdmVudCkgPT4gdGhpcy5obmRNdXRhdGlvbiwgdHJ1ZSk7XHJcbiAgICAgIGdyYXBoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTVVUQVRFLCB0aGlzLmhuZE11dGF0aW9uR3JhcGgsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoaXMgbm9kZSB0byBiZSBhIHJlY3JlYXRpb24gb2YgdGhlIHtAbGluayBHcmFwaH0gZ2l2ZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNldChfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUsIGlmIHRoZSBzZXJpYWxpemF0aW9uIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIEdyYXBoIGZvciBvcHRpbWl6YXRpb24gPC0gYWxzbyB1c2VmdWwgZm9yIHN5bmMgd2l0aCBpbnN0YW5jZXNcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBTZXJpYWxpemVyLnNlcmlhbGl6ZShfZ3JhcGgpO1xyXG4gICAgICAvL1NlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGZvciAobGV0IHBhdGggaW4gc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy4jaWRTb3VyY2UgPSBfZ3JhcGguaWRSZXNvdXJjZTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5HUkFQSF9JTlNUQU5USUFURUQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBncmFwaCB0aGlzIGluc3RhbmNlcyByZWZlcnMgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBHcmFwaCB7XHJcbiAgICAgIHJldHVybiA8R3JhcGg+UHJvamVjdC5yZXNvdXJjZXNbdGhpcy4jaWRTb3VyY2VdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU291cmNlIGdyYXBoIG11dGF0ZWQsIHJlZmxlY3QgbXV0YXRpb24gaW4gdGhpcyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZE11dGF0aW9uR3JhcGggPSBhc3luYyAoX2V2ZW50OiBDdXN0b21FdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuI3N5bmMpIHtcclxuICAgICAgICB0aGlzLiNzeW5jID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmlzRmlsdGVyZWQoKSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLiNzeW5jID0gZmFsc2U7IC8vIGRvIG5vdCBzeW5jIGFnYWluLCBzaW5jZSBtdXRhdGlvbiBpcyBhbHJlYWR5IGEgc3luY2hyb25pemF0aW9uXHJcbiAgICAgIGF3YWl0IHRoaXMucmVmbGVjdE11dGF0aW9uKF9ldmVudCwgPEdyYXBoPl9ldmVudC5jdXJyZW50VGFyZ2V0LCB0aGlzKTtcclxuICAgICAgdGhpcy4jc3luYyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGluc3RhbmNlIG11dGF0ZWQsIHJlZmxlY3QgbXV0YXRpb24gaW4gc291cmNlIGdyYXBoXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kTXV0YXRpb25JbnN0YW5jZSA9IGFzeW5jIChfZXZlbnQ6IEN1c3RvbUV2ZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIGlmICghdGhpcy4jc3luYylcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAodGhpcy5pc0ZpbHRlcmVkKCkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYXdhaXQgdGhpcy5yZWZsZWN0TXV0YXRpb24oX2V2ZW50LCB0aGlzLCB0aGlzLmdldCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIHJlZmxlY3RNdXRhdGlvbihfZXZlbnQ6IEN1c3RvbUV2ZW50LCBfc291cmNlOiBOb2RlLCBfZGVzdGluYXRpb246IE5vZGUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJSZWZsZWN0IG11dGF0aW9uXCIsIF9zb3VyY2UsIF9kZXN0aW5hdGlvbik7XHJcbiAgICAgIGxldCBwYXRoOiBOb2RlW10gPSBSZWZsZWN0LmdldChfZXZlbnQsIFwicGF0aFwiKTtcclxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSBwYXRoLmluZGV4T2YoX3NvdXJjZSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgX2Rlc3RpbmF0aW9uID0gX2Rlc3RpbmF0aW9uLmdldENoaWxkcmVuQnlOYW1lKHBhdGhbaV0ubmFtZSlbMF07IC8vIFRPRE86IHJlc3BlY3QgaW5kZXggZm9yIG5vbi1zaW5nbGV0b24gY29tcG9uZW50cy4uLlxyXG4gICAgICBsZXQgY21wTXV0YXRlOiBDb21wb25lbnQgPSBfZGVzdGluYXRpb24uZ2V0Q29tcG9uZW50KF9ldmVudC5kZXRhaWwuY29tcG9uZW50LmNvbnN0cnVjdG9yKTtcclxuICAgICAgaWYgKGNtcE11dGF0ZSlcclxuICAgICAgICBhd2FpdCBjbXBNdXRhdGUubXV0YXRlKF9ldmVudC5kZXRhaWwubXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpc0ZpbHRlcmVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgY21wRmlsdGVyOiBDb21wb25lbnRHcmFwaEZpbHRlciA9IHRoaXMuZ2V0Q29tcG9uZW50KENvbXBvbmVudEdyYXBoRmlsdGVyKTtcclxuICAgICAgcmV0dXJuIChjbXBGaWx0ZXIgJiYgY21wRmlsdGVyLmlzQWN0aXZlKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIb2xkcyBkYXRhIHRvIGZlZWQgaW50byBhIHtAbGluayBTaGFkZXJ9IHRvIGRlc2NyaWJlIHRoZSBzdXJmYWNlIG9mIHtAbGluayBNZXNofS4gIFxyXG4gICAqIHtAbGluayBNYXRlcmlhbH1zIHJlZmVyZW5jZSB7QGxpbmsgQ29hdH0gYW5kIHtAbGluayBTaGFkZXJ9LiAgIFxyXG4gICAqIFRoZSBtZXRob2QgdXNlUmVuZGVyRGF0YSB3aWxsIGJlIGluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3Rvcn0gYXQgcnVudGltZSwgZXh0ZW5kaW5nIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHRoaXMgY2xhc3MgdG8gZGVhbCB3aXRoIHRoZSByZW5kZXJlci5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29hdCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgLy8gcHVibGljIG5hbWU6IHN0cmluZyA9IFwiQ29hdFwiO1xyXG4gICAgcHJvdGVjdGVkIHJlbmRlckRhdGE6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xyXG5cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7IFxyXG4gICAgICBkZWxldGUgX211dGF0b3IucmVuZGVyRGF0YTtcclxuICAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUaGUgc2ltcGxlc3Qge0BsaW5rIENvYXR9IHByb3ZpZGluZyBqdXN0IGEgY29sb3JcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JDb2F0LmRlY29yYXRlXHJcbiAgZXhwb3J0IGNsYXNzIENvYXRDb2xvcmVkIGV4dGVuZHMgQ29hdCB7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigpKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmNvbG9yID0gdGhpcy5jb2xvci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29sb3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBzaW1wbGVzdCB7QGxpbmsgQ29hdH0gcHJvdmlkaW5nIGp1c3QgYSBjb2xvclxyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcclxuICBleHBvcnQgY2xhc3MgQ29hdFJlbWlzc2l2ZSBleHRlbmRzIENvYXRDb2xvcmVkIHtcclxuICAgIHB1YmxpYyBzcGVjdWxhcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGRpZmZ1c2U6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCksIF9kaWZmdXNlOiBudW1iZXIgPSAxLCBfc3BlY3VsYXI6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoX2NvbG9yKTtcclxuICAgICAgdGhpcy5kaWZmdXNlID0gX2RpZmZ1c2U7XHJcbiAgICAgIHRoaXMuc3BlY3VsYXIgPSBfc3BlY3VsYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmRpZmZ1c2UgPSB0aGlzLmRpZmZ1c2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgdGhpcy5jb2xvci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2xvcik7XHJcbiAgICAgIHRoaXMuZGlmZnVzZSA9IF9zZXJpYWxpemF0aW9uLmRpZmZ1c2U7XHJcbiAgICAgIHRoaXMuc3BlY3VsYXIgPSBfc2VyaWFsaXphdGlvbi5zcGVjdWxhcjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHtAbGluayBDb2F0fSBwcm92aWRpbmcgYSB0ZXh0dXJlIGFuZCBhZGRpdGlvbmFsIGRhdGEgZm9yIHRleHR1cmluZ1xyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3RvckNvYXQuZGVjb3JhdGVcclxuICBleHBvcnQgY2xhc3MgQ29hdFRleHR1cmVkIGV4dGVuZHMgQ29hdENvbG9yZWQge1xyXG4gICAgcHVibGljIHRleHR1cmU6IFRleHR1cmUgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoKSwgX3RleHR1cmU6IFRleHR1cmUgPSBUZXh0dXJlRGVmYXVsdC50ZXh0dXJlKSB7XHJcbiAgICAgIHN1cGVyKF9jb2xvcik7XHJcbiAgICAgIHRoaXMudGV4dHVyZSA9IF90ZXh0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFRleHR1cmUgPSB0aGlzLnRleHR1cmUuaWRSZXNvdXJjZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gPFRleHR1cmU+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIkNvYXRUZXh0dXJlZC50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEEge0BsaW5rIENvYXR9IHByb3ZpZGluZyBhIHRleHR1cmUgYW5kIGFkZGl0aW9uYWwgZGF0YSBmb3IgdGV4dHVyaW5nXHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yQ29hdC5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb2F0UmVtaXNzaXZlVGV4dHVyZWQgZXh0ZW5kcyBDb2F0VGV4dHVyZWQge1xyXG4gICAgcHVibGljIHNwZWN1bGFyOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgZGlmZnVzZTogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoKSwgX3RleHR1cmU6IFRleHR1cmUgPSBUZXh0dXJlRGVmYXVsdC50ZXh0dXJlLCBfZGlmZnVzZTogbnVtYmVyID0gMSwgX3NwZWN1bGFyOiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKF9jb2xvciwgX3RleHR1cmUpO1xyXG4gICAgICB0aGlzLmRpZmZ1c2UgPSBfZGlmZnVzZTtcclxuICAgICAgdGhpcy5zcGVjdWxhciA9IF9zcGVjdWxhcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uZGlmZnVzZSA9IHRoaXMuZGlmZnVzZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXI7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmRpZmZ1c2UgPSBfc2VyaWFsaXphdGlvbi5kaWZmdXNlO1xyXG4gICAgICB0aGlzLnNwZWN1bGFyID0gX3NlcmlhbGl6YXRpb24uc3BlY3VsYXI7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIGNvbG9yIGFzIHZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgMCB0byAxIGZvciB0aGUgZm91ciBjaGFubmVscyByZWQsIGdyZWVuLCBibHVlIGFuZCBhbHBoYSAoZm9yIG9wYWNpdHkpXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbG9yIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvLyBjcmMyIG9ubHkgdXNlZCBmb3IgY29udmVydGluZyBjb2xvcnMgZnJvbSBzdHJpbmdzIHByZWRlZmluZWQgYnkgQ1NTXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICBwdWJsaWMgcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGc6IG51bWJlcjtcclxuICAgIHB1YmxpYyBiOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYTogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9yOiBudW1iZXIgPSAxLCBfZzogbnVtYmVyID0gMSwgX2I6IG51bWJlciA9IDEsIF9hOiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0Tm9ybVJHQkEoX3IsIF9nLCBfYiwgX2EpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SGV4RnJvbUNTU0tleXdvcmQoX2tleXdvcmQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgIENvbG9yLmNyYzIuZmlsbFN0eWxlID0gX2tleXdvcmQ7XHJcbiAgICAgIHJldHVybiBDb2xvci5jcmMyLmZpbGxTdHlsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIENTUyhfa2V5d29yZDogc3RyaW5nLCBfYWxwaGE6IG51bWJlciA9IDEpOiBDb2xvciB7XHJcbiAgICAgIGxldCBoZXg6IHN0cmluZyA9IENvbG9yLmdldEhleEZyb21DU1NLZXl3b3JkKF9rZXl3b3JkKTtcclxuICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IG5ldyBDb2xvcihcclxuICAgICAgICBwYXJzZUludChoZXguc3Vic3RyKDEsIDIpLCAxNikgLyAyNTUsXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4LnN1YnN0cigzLCAyKSwgMTYpIC8gMjU1LFxyXG4gICAgICAgIHBhcnNlSW50KGhleC5zdWJzdHIoNSwgMiksIDE2KSAvIDI1NSxcclxuICAgICAgICBfYWxwaGEpO1xyXG4gICAgICByZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgTVVMVElQTFkoX2NvbG9yMTogQ29sb3IsIF9jb2xvcjI6IENvbG9yKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gbmV3IENvbG9yKF9jb2xvcjEuciAqIF9jb2xvcjIuciwgX2NvbG9yMS5nICogX2NvbG9yMi5nLCBfY29sb3IxLmIgKiBfY29sb3IyLmIsIF9jb2xvcjEuYSAqIF9jb2xvcjIuYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldE5vcm1SR0JBKF9yOiBudW1iZXIsIF9nOiBudW1iZXIsIF9iOiBudW1iZXIsIF9hOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX3IpKTtcclxuICAgICAgdGhpcy5nID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX2cpKTtcclxuICAgICAgdGhpcy5iID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX2IpKTtcclxuICAgICAgdGhpcy5hID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgX2EpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0Qnl0ZXNSR0JBKF9yOiBudW1iZXIsIF9nOiBudW1iZXIsIF9iOiBudW1iZXIsIF9hOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXROb3JtUkdCQShfciAvIDI1NSwgX2cgLyAyNTUsIF9iIC8gMjU1LCBfYSAvIDI1NSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFycmF5KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmFdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0QXJyYXlOb3JtUkdCQShfY29sb3I6IEZsb2F0MzJBcnJheSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldE5vcm1SR0JBKF9jb2xvclswXSwgX2NvbG9yWzFdLCBfY29sb3JbMl0sIF9jb2xvclszXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEFycmF5Qnl0ZXNSR0JBKF9jb2xvcjogVWludDhDbGFtcGVkQXJyYXkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXRCeXRlc1JHQkEoX2NvbG9yWzBdLCBfY29sb3JbMV0sIF9jb2xvclsyXSwgX2NvbG9yWzNdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXJyYXlCeXRlc1JHQkEoKTogVWludDhDbGFtcGVkQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFt0aGlzLnIgKiAyNTUsIHRoaXMuZyAqIDI1NSwgdGhpcy5iICogMjU1LCB0aGlzLmEgKiAyNTVdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkKF9jb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yICs9IF9jb2xvci5yO1xyXG4gICAgICB0aGlzLmcgKz0gX2NvbG9yLmc7XHJcbiAgICAgIHRoaXMuYiArPSBfY29sb3IuYjtcclxuICAgICAgdGhpcy5hICs9IF9jb2xvci5hO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDU1MoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcclxuICAgICAgcmV0dXJuIGBSR0JBKCR7Ynl0ZXNbMF19LCAke2J5dGVzWzFdfSwgJHtieXRlc1syXX0sICR7Ynl0ZXNbM119KWA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEhleCgpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgYnl0ZXM6IFVpbnQ4Q2xhbXBlZEFycmF5ID0gdGhpcy5nZXRBcnJheUJ5dGVzUkdCQSgpO1xyXG4gICAgICBsZXQgaGV4OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBmb3IgKGxldCBieXRlIG9mIGJ5dGVzKVxyXG4gICAgICAgIGhleCArPSBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XHJcbiAgICAgIHJldHVybiBoZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldEhleChfaGV4OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgbGV0IGJ5dGVzOiBVaW50OENsYW1wZWRBcnJheSA9IHRoaXMuZ2V0QXJyYXlCeXRlc1JHQkEoKTtcclxuICAgICAgbGV0IGNoYW5uZWw6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGJ5dGUgaW4gYnl0ZXMpXHJcbiAgICAgICAgYnl0ZXNbYnl0ZV0gPSBwYXJzZUludChfaGV4LnN1YnN0cihjaGFubmVsKysgKiAyLCAyKSwgMTYpO1xyXG4gICAgICB0aGlzLnNldEFycmF5Qnl0ZXNSR0JBKGJ5dGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29weShfY29sb3I6IENvbG9yKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuciA9IF9jb2xvci5yOyBcclxuICAgICAgdGhpcy5nID0gX2NvbG9yLmc7IFxyXG4gICAgICB0aGlzLmIgPSBfY29sb3IuYjsgXHJcbiAgICAgIHRoaXMuYSA9IF9jb2xvci5hOyBcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgKHI6ICR7dGhpcy5yLnRvRml4ZWQoMyl9LCBnOiAke3RoaXMuZy50b0ZpeGVkKDMpfSwgYjogJHt0aGlzLmIudG9GaXhlZCgzKX0sIGE6ICR7dGhpcy5hLnRvRml4ZWQoMyl9KWA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcih0cnVlKTtcclxuICAgICAgLy8gc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgeyBcInJcIjogJHt0aGlzLnJ9LCBcImdcIjogJHt0aGlzLmd9LCBcImJcIjogJHt0aGlzLmJ9LCBcImFcIjogJHt0aGlzLmF9fWA7IH07XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYFske3RoaXMucn0sICR7dGhpcy5nfSwgJHt0aGlzLmJ9LCAke3RoaXMuYX1dYDsgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgaWYgKHR5cGVvZiAoX3NlcmlhbGl6YXRpb24pID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXSA9IEpTT04ucGFyc2UoPHN0cmluZz48dW5rbm93bj5fc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEJhc2VjbGFzcyBmb3IgbWF0ZXJpYWxzLiBDb21iaW5lcyBhIHtAbGluayBTaGFkZXJ9IHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBDb2F0fVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIC8qKiBUaGUgbmFtZSB0byBjYWxsIHRoZSBNYXRlcmlhbCBieS4gKi9cclxuICAgICNjb2F0OiBDb2F0O1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHNoYWRlclR5cGU6IHR5cGVvZiBTaGFkZXI7IC8vIFRoZSBzaGFkZXIgcHJvZ3JhbSB1c2VkIGJ5IHRoaXMgQmFzZU1hdGVyaWFsXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9zaGFkZXI/OiB0eXBlb2YgU2hhZGVyLCBfY29hdD86IENvYXQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuc2hhZGVyVHlwZSA9IF9zaGFkZXI7XHJcbiAgICAgIGlmIChfc2hhZGVyKSB7XHJcbiAgICAgICAgaWYgKF9jb2F0KVxyXG4gICAgICAgICAgdGhpcy5jb2F0ID0gX2NvYXQ7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5jb2F0ID0gdGhpcy5jcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHJlZmVyZW5jZWQge0BsaW5rIENvYXR9IGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMgZ2V0IGNvYXQoKTogQ29hdCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjb2F0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGlzIG1hdGVyaWFsIHJlZmVyZW5jZSB0aGUgZ2l2ZW4ge0BsaW5rIENvYXR9IGlmIGl0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgcmVmZXJlbmNlZCB7QGxpbmsgU2hhZGVyfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGNvYXQoX2NvYXQ6IENvYXQpIHtcclxuICAgICAgaWYgKF9jb2F0LmNvbnN0cnVjdG9yICE9IHRoaXMuc2hhZGVyVHlwZS5nZXRDb2F0KCkpXHJcbiAgICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgdGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSlcclxuICAgICAgICAgIERlYnVnLmZ1ZGdlKFwiQ29hdCBpcyBleHRlbnNpb24gb2YgQ29hdCByZXF1aXJlZCBieSBzaGFkZXJcIik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIlNoYWRlciBhbmQgY29hdCBkb24ndCBtYXRjaFwiKSk7XHJcbiAgICAgIHRoaXMuI2NvYXQgPSBfY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIENvYXR9IGluc3RhbmNlIHRoYXQgaXMgdmFsaWQgZm9yIHRoZSB7QGxpbmsgU2hhZGVyfSByZWZlcmVuY2VkIGJ5IHRoaXMgbWF0ZXJpYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZUNvYXRNYXRjaGluZ1NoYWRlcigpOiBDb2F0IHtcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSBuZXcgKHRoaXMuc2hhZGVyVHlwZS5nZXRDb2F0KCkpKCk7XHJcbiAgICAgIHJldHVybiBjb2F0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgbWF0ZXJpYWxzIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4ge0BsaW5rIFNoYWRlcn0sIGNyZWF0ZXMgYW5kIHJlZmVyZW5jZXMgYSBuZXcge0BsaW5rIENvYXR9IGluc3RhbmNlICBcclxuICAgICAqIGFuZCBtdXRhdGVzIHRoZSBuZXcgY29hdCB0byBwcmVzZXJ2ZSBtYXRjaGluZyBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHBhcmFtIF9zaGFkZXJUeXBlIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2hhZGVyKF9zaGFkZXJUeXBlOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2hhZGVyVHlwZSA9IF9zaGFkZXJUeXBlO1xyXG4gICAgICBsZXQgY29hdDogQ29hdCA9IHRoaXMuY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCk7XHJcbiAgICAgIGNvYXQubXV0YXRlKHRoaXMuI2NvYXQuZ2V0TXV0YXRvcigpKTtcclxuICAgICAgdGhpcy5jb2F0ID0gY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBTaGFkZXJ9IHJlZmVyZW5jZWQgYnkgdGhpcyBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2hhZGVyKCk6IHR5cGVvZiBTaGFkZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaGFkZXJUeXBlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8vIFRPRE86IHRoaXMgdHlwZSBvZiBzZXJpYWxpemF0aW9uIHdhcyBpbXBsZW1lbnRlZCBmb3IgaW1wbGljaXQgTWF0ZXJpYWwgY3JlYXRlLiBDaGVjayBpZiBvYnNvbGV0ZSB3aGVuIG9ubHkgb25lIG1hdGVyaWFsIGNsYXNzIGV4aXN0cyBhbmQvb3IgbWF0ZXJpYWxzIGFyZSBzdG9yZWQgc2VwYXJhdGVseVxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcclxuICAgICAgICBzaGFkZXI6IHRoaXMuc2hhZGVyVHlwZS5uYW1lLFxyXG4gICAgICAgIGNvYXQ6IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMuI2NvYXQpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcclxuICAgICAgdGhpcy5zaGFkZXJUeXBlID0gKDxHZW5lcmFsPkZ1ZGdlQ29yZSlbX3NlcmlhbGl6YXRpb24uc2hhZGVyXTtcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSA8Q29hdD5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmNvYXQpO1xyXG4gICAgICB0aGlzLmNvYXQgPSBjb2F0O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBtdXRhdG9yLmNvYXQgPSB0aGlzLmNvYXQuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvLyBkZWxldGUgX211dGF0b3IuaWRSZXNvdXJjZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQm9yZGVyIHtcclxuICAgIGxlZnQ6IG51bWJlcjtcclxuICAgIHRvcDogbnVtYmVyO1xyXG4gICAgcmlnaHQ6IG51bWJlcjtcclxuICAgIGJvdHRvbTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRnJhbWluZyBkZXNjcmliZXMgaG93IHRvIG1hcCBhIHJlY3RhbmdsZSBpbnRvIGEgZ2l2ZW4gZnJhbWVcclxuICAgKiBhbmQgaG93IHBvaW50cyBpbiB0aGUgZnJhbWUgY29ycmVzcG9uZCB0byBwb2ludHMgaW4gdGhlIHJlc3VsdGluZyByZWN0YW5nbGUgYW5kIHZpY2UgdmVyc2FcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOSAgXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0ppcmthRGVsbE9yby9GVURHRS93aWtpL0ZyYW1pbmdcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgRnJhbWluZyBleHRlbmRzIE11dGFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGEgcG9pbnQgaW4gdGhlIGdpdmVuIGZyYW1lIGFjY29yZGluZyB0byB0aGlzIGZyYW1pbmdcclxuICAgICAqIEBwYXJhbSBfcG9pbnRJbkZyYW1lIFRoZSBwb2ludCBpbiB0aGUgZnJhbWUgZ2l2ZW5cclxuICAgICAqIEBwYXJhbSBfcmVjdEZyYW1lIFRoZSBmcmFtZSB0aGUgcG9pbnQgaXMgcmVsYXRpdmUgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGEgcG9pbnQgaW4gYSBnaXZlbiByZWN0YW5nbGUgYmFjayB0byBhIGNhbGN1bGF0ZWQgZnJhbWUgb2Ygb3JpZ2luXHJcbiAgICAgKiBAcGFyYW0gX3BvaW50IFRoZSBwb2ludCBpbiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gX3JlY3QgVGhlIHJlY3RhbmdsZSB0aGUgcG9pbnQgaXMgcmVsYXRpdmUgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldFBvaW50SW52ZXJzZShfcG9pbnQ6IFZlY3RvcjIsIF9yZWN0OiBSZWN0YW5nbGUpOiBWZWN0b3IyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSByZWN0YW5nbGUgYXMgdGhlIGZyYW1lIGFuZCBjcmVhdGVzIGEgbmV3IHJlY3RhbmdsZSBhY2NvcmRpbmcgdG8gdGhlIGZyYW1pbmdcclxuICAgICAqIEBwYXJhbSBfcmVjdEZyYW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRSZWN0KF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZTtcclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGhhcyBhIGZpeGVkIHdpZHRoIGFuZCBoZWlnaHQgYW5kIGRpc3BsYXkgc2hvdWxkIHNjYWxlIHRvIGZpdCB0aGUgZnJhbWVcclxuICAgKiBQb2ludHMgYXJlIHNjYWxlZCBpbiB0aGUgc2FtZSByYXRpb1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGcmFtaW5nRml4ZWQgZXh0ZW5kcyBGcmFtaW5nIHtcclxuICAgIHB1YmxpYyB3aWR0aDogbnVtYmVyID0gMzAwO1xyXG4gICAgcHVibGljIGhlaWdodDogbnVtYmVyID0gMTUwO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihfd2lkdGg6IG51bWJlciA9IDMwMCwgX2hlaWdodDogbnVtYmVyID0gMTUwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0U2l6ZShfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRTaXplKF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy53aWR0aCA9IF93aWR0aDtcclxuICAgICAgdGhpcy5oZWlnaHQgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHRoaXMud2lkdGggKiAoX3BvaW50SW5GcmFtZS54IC0gX3JlY3RGcmFtZS54KSAvIF9yZWN0RnJhbWUud2lkdGgsXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgKiAoX3BvaW50SW5GcmFtZS55IC0gX3JlY3RGcmFtZS55KSAvIF9yZWN0RnJhbWUuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50SW52ZXJzZShfcG9pbnQ6IFZlY3RvcjIsIF9yZWN0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIF9wb2ludC54ICogX3JlY3Qud2lkdGggLyB0aGlzLndpZHRoICsgX3JlY3QueCxcclxuICAgICAgICBfcG9pbnQueSAqIF9yZWN0LmhlaWdodCAvIHRoaXMuaGVpZ2h0ICsgX3JlY3QueVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRSZWN0KF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBhcmUgZnJhY3Rpb25zIG9mIHRob3NlIG9mIHRoZSBmcmFtZSwgc2NhbGVkIGJ5IG5vcm1lZCB2YWx1ZXMgbm9ybVdpZHRoIGFuZCBub3JtSGVpZ2h0LlxyXG4gICAqIERpc3BsYXkgc2hvdWxkIHNjYWxlIHRvIGZpdCB0aGUgZnJhbWUgYW5kIHBvaW50cyBhcmUgc2NhbGVkIGluIHRoZSBzYW1lIHJhdGlvXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdTY2FsZWQgZXh0ZW5kcyBGcmFtaW5nIHtcclxuICAgIHB1YmxpYyBub3JtV2lkdGg6IG51bWJlciA9IDEuMDtcclxuICAgIHB1YmxpYyBub3JtSGVpZ2h0OiBudW1iZXIgPSAxLjA7XHJcblxyXG4gICAgcHVibGljIHNldFNjYWxlKF9ub3JtV2lkdGg6IG51bWJlciwgX25vcm1IZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLm5vcm1XaWR0aCA9IF9ub3JtV2lkdGg7XHJcbiAgICAgIHRoaXMubm9ybUhlaWdodCA9IF9ub3JtSGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHRoaXMubm9ybVdpZHRoICogKF9wb2ludEluRnJhbWUueCAtIF9yZWN0RnJhbWUueCksXHJcbiAgICAgICAgdGhpcy5ub3JtSGVpZ2h0ICogKF9wb2ludEluRnJhbWUueSAtIF9yZWN0RnJhbWUueSlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggLyB0aGlzLm5vcm1XaWR0aCArIF9yZWN0LngsXHJcbiAgICAgICAgX3BvaW50LnkgLyB0aGlzLm5vcm1IZWlnaHQgKyBfcmVjdC55XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy5ub3JtV2lkdGggKiBfcmVjdEZyYW1lLndpZHRoLCB0aGlzLm5vcm1IZWlnaHQgKiBfcmVjdEZyYW1lLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBmaXRzIGludG8gYSBtYXJnaW4gZ2l2ZW4gYXMgZnJhY3Rpb25zIG9mIHRoZSBzaXplIG9mIHRoZSBmcmFtZSBnaXZlbiBieSBub3JtQW5jaG9yXHJcbiAgICogcGx1cyBhbiBhYnNvbHV0ZSBwYWRkaW5nIGdpdmVuIGJ5IHBpeGVsQm9yZGVyLiBEaXNwbGF5IHNob3VsZCBmaXQgaW50byB0aGlzLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGcmFtaW5nQ29tcGxleCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIG1hcmdpbjogQm9yZGVyID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfTtcclxuICAgIHB1YmxpYyBwYWRkaW5nOiBCb3JkZXIgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIF9wb2ludEluRnJhbWUueCAtIHRoaXMucGFkZGluZy5sZWZ0IC0gdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0RnJhbWUud2lkdGgsXHJcbiAgICAgICAgX3BvaW50SW5GcmFtZS55IC0gdGhpcy5wYWRkaW5nLnRvcCAtIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0RnJhbWUuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggKyB0aGlzLnBhZGRpbmcubGVmdCArIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdC53aWR0aCxcclxuICAgICAgICBfcG9pbnQueSArIHRoaXMucGFkZGluZy50b3AgKyB0aGlzLm1hcmdpbi50b3AgKiBfcmVjdC5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xyXG4gICAgICBpZiAoIV9yZWN0RnJhbWUpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBsZXQgbWluWDogbnVtYmVyID0gX3JlY3RGcmFtZS54ICsgdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0RnJhbWUud2lkdGggKyB0aGlzLnBhZGRpbmcubGVmdDtcclxuICAgICAgbGV0IG1pblk6IG51bWJlciA9IF9yZWN0RnJhbWUueSArIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0RnJhbWUuaGVpZ2h0ICsgdGhpcy5wYWRkaW5nLnRvcDtcclxuICAgICAgbGV0IG1heFg6IG51bWJlciA9IF9yZWN0RnJhbWUueCArICgxIC0gdGhpcy5tYXJnaW4ucmlnaHQpICogX3JlY3RGcmFtZS53aWR0aCAtIHRoaXMucGFkZGluZy5yaWdodDtcclxuICAgICAgbGV0IG1heFk6IG51bWJlciA9IF9yZWN0RnJhbWUueSArICgxIC0gdGhpcy5tYXJnaW4uYm90dG9tKSAqIF9yZWN0RnJhbWUuaGVpZ2h0IC0gdGhpcy5wYWRkaW5nLmJvdHRvbTtcclxuXHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB7IG1hcmdpbjogdGhpcy5tYXJnaW4sIHBhZGRpbmc6IHRoaXMucGFkZGluZyB9O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yMiBhcyBwb2xhciBjb29yZGluYXRlcyBcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAg4oaVLSBhbmdsZSAoQW5nbGUgdG8gdGhlIHgtYXhpcylcclxuICAgKiAgLeKGkiBNYWduaXR1ZGUgKERpc3RhbmNlIGZyb20gdGhlIGNlbnRlcikgIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBHZW8yIGltcGxlbWVudHMgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyBtYWduaXR1ZGU6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgYW5nbGU6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2FuZ2xlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9hbmdsZSwgX21hZ25pdHVkZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBpbnN0YW5jZSBhdCBvbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX2FuZ2xlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubWFnbml0dWRlID0gX21hZ25pdHVkZTtcclxuICAgICAgdGhpcy5hbmdsZSA9IF9hbmdsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcmV0dHkgc3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYGFuZ2xlOiAke3RoaXMuYW5nbGUudG9QcmVjaXNpb24oNSl9LCAgbWFnbml0dWRlOiAke3RoaXMubWFnbml0dWRlLnRvUHJlY2lzaW9uKDUpfWA7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3IzIGFzIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgYXMgc2VlbiBvbiBhIGdsb2JlXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICog4oaQfOKGkiBMb25naXR1ZGUgKEFuZ2xlIHRvIHRoZSB6LWF4aXMpIFxyXG4gICAqICDihpUtIExhdGl0dWRlIChBbmdsZSB0byB0aGUgZXF1YXRvcilcclxuICAgKiAgLeKGkiBNYWduaXR1ZGUgKERpc3RhbmNlIGZyb20gdGhlIGNlbnRlcikgIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBHZW8zIGltcGxlbWVudHMgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyBtYWduaXR1ZGU6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgbGF0aXR1ZGU6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgbG9uZ2l0dWRlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9sb25naXR1ZGU6IG51bWJlciA9IDAsIF9sYXRpdHVkZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSkge1xyXG4gICAgICB0aGlzLnNldChfbG9uZ2l0dWRlLCBfbGF0aXR1ZGUsIF9tYWduaXR1ZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgaW5zdGFuY2UgYXQgb25jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF9sb25naXR1ZGU6IG51bWJlciA9IDAsIF9sYXRpdHVkZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1hZ25pdHVkZSA9IF9tYWduaXR1ZGU7XHJcbiAgICAgIHRoaXMubGF0aXR1ZGUgPSBfbGF0aXR1ZGU7XHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlID0gX2xvbmdpdHVkZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcmV0dHkgc3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYGxvbmdpdHVkZTogJHt0aGlzLmxvbmdpdHVkZS50b1ByZWNpc2lvbig1KX0sIGxhdGl0dWRlOiAke3RoaXMubGF0aXR1ZGUudG9QcmVjaXNpb24oNSl9LCBtYWduaXR1ZGU6ICR7dGhpcy5tYWduaXR1ZGUudG9QcmVjaXNpb24oNSl9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvLyBGcm9tIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cclxuICAvLyBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcclxuICBleHBvcnQgZnVuY3Rpb24gTWFzaCgpOiBGdW5jdGlvbiB7XHJcbiAgICBsZXQgbjogbnVtYmVyID0gMHhlZmM4MjQ5ZDtcclxuXHJcbiAgICBsZXQgbWFzaDogRnVuY3Rpb24gPSBmdW5jdGlvbiAoZGF0YTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBsZXQgaDogbnVtYmVyID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XHJcbiAgICAgICAgbiA9IGggPj4+IDA7XHJcbiAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgIGggKj0gbjtcclxuICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICBoIC09IG47XHJcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcclxuICAgIH07XHJcblxyXG4gICAgLy8gbWFzaC52ZXJzaW9uID0gJ01hc2ggMC45JztcclxuICAgIHJldHVybiBtYXNoO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEZyb20gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBMRklCNCgpOiBGdW5jdGlvbiB7XHJcbiAgICAvLyBHZW9yZ2UgTWFyc2FnbGlhJ3MgTEZJQjQsXHJcbiAgICAvL2h0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC9zY2kuY3J5cHQvbXNnL2ViNGRkZGU3ODJiMTcwNTFcclxuICAgIGxldCBhcmdzOiBudW1iZXJbXSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICBsZXQgazA6IG51bWJlciA9IDAsXHJcbiAgICAgIGsxOiBudW1iZXIgPSA1OCxcclxuICAgICAgazI6IG51bWJlciA9IDExOSxcclxuICAgICAgazM6IG51bWJlciA9IDE3ODtcclxuXHJcbiAgICBsZXQgczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBsZXQgbWFzaDogRnVuY3Rpb24gPSBNYXNoKCk7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgYXJncyA9IFsrbmV3IERhdGUoKV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgMjU2OyBqKyspIHtcclxuICAgICAgc1tqXSA9IG1hc2goXCIgXCIpO1xyXG4gICAgICBzW2pdIC09IG1hc2goXCIgXCIpICogNC43NjgzNzE1ODIwMzEyNWUtNzsgLy8gMl4tMjFcclxuICAgICAgaWYgKHNbal0gPCAwKSB7XHJcbiAgICAgICAgc1tqXSArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgMjU2OyBqKyspIHtcclxuICAgICAgICBzW2pdIC09IG1hc2goYXJnc1tpXSk7XHJcbiAgICAgICAgc1tqXSAtPSBtYXNoKGFyZ3NbaV0pICogNC43NjgzNzE1ODIwMzEyNWUtNzsgLy8gMl4tMjFcclxuICAgICAgICBpZiAoc1tqXSA8IDApIHtcclxuICAgICAgICAgIHNbal0gKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG1hc2ggPSBudWxsO1xyXG5cclxuICAgIGxldCByYW5kb206IEZ1bmN0aW9uID0gZnVuY3Rpb24gKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCB4OiBudW1iZXI7XHJcblxyXG4gICAgICBrMCA9IChrMCArIDEpICYgMjU1O1xyXG4gICAgICBrMSA9IChrMSArIDEpICYgMjU1O1xyXG4gICAgICBrMiA9IChrMiArIDEpICYgMjU1O1xyXG4gICAgICBrMyA9IChrMyArIDEpICYgMjU1O1xyXG5cclxuICAgICAgeCA9IHNbazBdIC0gc1trMV07XHJcbiAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgIHggKz0gMTtcclxuICAgICAgfVxyXG4gICAgICB4IC09IHNbazJdO1xyXG4gICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICB4ICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgeCAtPSBzW2szXTtcclxuICAgICAgaWYgKHggPCAwKSB7XHJcbiAgICAgICAgeCArPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc1trMF0gPSB4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByYW5kb20udWludDMyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gICByZXR1cm4gcmFuZG9tKCkgKiAweDEwMDAwMDAwMCA+Pj4gMDsgLy8gMl4zMlxyXG4gICAgLy8gfTtcclxuICAgIC8vIHJhbmRvbS5mcmFjdDUzID0gcmFuZG9tO1xyXG4gICAgLy8gcmFuZG9tLnZlcnNpb24gPSBcIkxGSUI0IDAuOVwiO1xyXG4gICAgLy8gcmFuZG9tLmFyZ3MgPSBhcmdzO1xyXG5cclxuICAgIHJldHVybiByYW5kb207XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1hdHJpeCBhcyB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxpbmcge0BsaW5rIFZlY3RvcjJ9LCBiZWluZyBjYWxjdWxhdGVkIGZyb20gdGhlIG1hdHJpeFxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBWZWN0b3JSZXByZXNlbnRhdGlvbiB7XHJcbiAgICB0cmFuc2xhdGlvbjogVmVjdG9yMjtcclxuICAgIHJvdGF0aW9uOiBudW1iZXI7XHJcbiAgICBzY2FsaW5nOiBWZWN0b3IyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2ltcGxlIGNsYXNzIGZvciAzeDMgbWF0cml4IG9wZXJhdGlvbnNcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDN4MyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZWcycmFkOiBudW1iZXIgPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDkpOyAvLyBUaGUgZGF0YSBvZiB0aGUgbWF0cml4LlxyXG4gICAgcHJpdmF0ZSBtdXRhdG9yOiBNdXRhdG9yID0gbnVsbDsgLy8gcHJlcGFyZWQgZm9yIG9wdGltaXphdGlvbiwga2VlcCBtdXRhdG9yIHRvIHJlZHVjZSByZWR1bmRhbnQgY2FsY3VsYXRpb24gYW5kIGZvciBjb21wYXJpc29uLiBTZXQgdG8gbnVsbCB3aGVuIGRhdGEgY2hhbmdlcyFcclxuICAgIHByaXZhdGUgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb247IC8vIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5yZWN5Y2xlKCk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvL1RPRE86IGZpZ3VyZSBvdXQgd2hhdCB0aGlzIGlzIHVzZWQgZm9yXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT04oX3dpZHRoOiBudW1iZXIsIF9oZWlnaHQ6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IG5ldyBNYXRyaXgzeDM7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMiAvIF93aWR0aCwgMCwgMCxcclxuICAgICAgICAwLCAtMiAvIF9oZWlnaHQsIDAsXHJcbiAgICAgICAgLTEsIDEsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBJREVOVElUWSgpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLmdldChNYXRyaXgzeDMpO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHRyYW5zbGF0ZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TTEFUSU9OKF90cmFuc2xhdGU6IFZlY3RvcjIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLmdldChNYXRyaXgzeDMpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCxcclxuICAgICAgICBfdHJhbnNsYXRlLngsIF90cmFuc2xhdGUueSwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIG9uIHRoZSB6LWF4aXMgd2hlbiBtdWx0aXBsaWVkIGJ5LlxyXG4gICAgICogQHBhcmFtIF9hbmdsZUluRGVncmVlcyBUaGUgdmFsdWUgb2YgdGhlIHJvdGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5nZXQoTWF0cml4M3gzKTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBNYXRyaXgzeDMuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgY29zLCBzaW4sIDAsXHJcbiAgICAgICAgLXNpbiwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgc2NhbGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHtAbGluayBWZWN0b3IyfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxJTkcoX3NjYWxhcjogVmVjdG9yMik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgX3NjYWxhci54LCAwLCAwLFxyXG4gICAgICAgIDAsIF9zY2FsYXIueSwgMCxcclxuICAgICAgICAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgTVVMVElQTElDQVRJT04oX210eExlZnQ6IE1hdHJpeDN4MywgX210eFJpZ2h0OiBNYXRyaXgzeDMpOiBNYXRyaXgzeDMge1xyXG4gICAgICBsZXQgYTAwOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzAgKiAzICsgMF07XHJcbiAgICAgIGxldCBhMDE6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMCAqIDMgKyAxXTtcclxuICAgICAgbGV0IGEwMjogbnVtYmVyID0gX210eExlZnQuZGF0YVswICogMyArIDJdO1xyXG4gICAgICBsZXQgYTEwOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzEgKiAzICsgMF07XHJcbiAgICAgIGxldCBhMTE6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMSAqIDMgKyAxXTtcclxuICAgICAgbGV0IGExMjogbnVtYmVyID0gX210eExlZnQuZGF0YVsxICogMyArIDJdO1xyXG4gICAgICBsZXQgYTIwOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzIgKiAzICsgMF07XHJcbiAgICAgIGxldCBhMjE6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMiAqIDMgKyAxXTtcclxuICAgICAgbGV0IGEyMjogbnVtYmVyID0gX210eExlZnQuZGF0YVsyICogMyArIDJdO1xyXG4gICAgICBsZXQgYjAwOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVswICogMyArIDBdO1xyXG4gICAgICBsZXQgYjAxOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVswICogMyArIDFdO1xyXG4gICAgICBsZXQgYjAyOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVswICogMyArIDJdO1xyXG4gICAgICBsZXQgYjEwOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsxICogMyArIDBdO1xyXG4gICAgICBsZXQgYjExOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsxICogMyArIDFdO1xyXG4gICAgICBsZXQgYjEyOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsxICogMyArIDJdO1xyXG4gICAgICBsZXQgYjIwOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsyICogMyArIDBdO1xyXG4gICAgICBsZXQgYjIxOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsyICogMyArIDFdO1xyXG4gICAgICBsZXQgYjIyOiBudW1iZXIgPSBfbXR4UmlnaHQuZGF0YVsyICogMyArIDJdO1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMCxcclxuICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEsXHJcbiAgICAgICAgYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyLFxyXG4gICAgICAgIGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCxcclxuICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEsXHJcbiAgICAgICAgYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyLFxyXG4gICAgICAgIGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMCxcclxuICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEsXHJcbiAgICAgICAgYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiByZXR1cm4gYSB2ZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zbGF0aW9uIHtAbGluayBWZWN0b3IyfS4gIFxyXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgYnkgUmVjeWNsZXIuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0cmFuc2xhdGlvbigpOiBWZWN0b3IyIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbmV3IFZlY3RvcjIodGhpcy5kYXRhWzZdLCB0aGlzLmRhdGFbN10pO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uOyAvLyAuY2xvbmU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMikge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90cmFuc2xhdGlvbi5nZXQoKSwgNik7XHJcbiAgICAgIC8vIG5vIGZ1bGwgY2FjaGUgcmVzZXQgcmVxdWlyZWRcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gX3RyYW5zbGF0aW9uO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgcm90YXRpb24ge0BsaW5rIFZlY3RvcjJ9ICAgXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy5yb3RhdGlvbilcclxuICAgICAgICB0aGlzLnZlY3RvcnMucm90YXRpb24gPSB0aGlzLmdldEV1bGVyQW5nbGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2NhbGUge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogRG8gbm90IG1hbmlwdWxhdGUgcmVzdWx0LCBpbnN0ZWFkIGNyZWF0ZSBhIGNsb25lISAgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxpbmcoKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0pLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbM10sIHRoaXMuZGF0YVs0XSlcclxuICAgICAgICApO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnNjYWxpbmc7IC8vIC5jbG9uZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2NhbGluZyhfc2NhbGluZzogVmVjdG9yMikge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwic2NhbGluZ1wiOiBfc2NhbGluZyB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjbG9uZSgpOiBNYXRyaXgzeDMge1xyXG4gICAgICBsZXQgbXR4Q2xvbmU6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLmdldChNYXRyaXgzeDMpO1xyXG4gICAgICBtdHhDbG9uZS5zZXQodGhpcyk7XHJcbiAgICAgIHJldHVybiBtdHhDbG9uZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpOyBcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNsYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYnkgdGhlIGdpdmVuIHtAbGluayBWZWN0b3IyfSB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4M3gzLlRSQU5TTEFUSU9OKF9ieSkpO1xyXG4gICAgICAvLyBUT0RPOiBwb3NzaWJsZSBvcHRpbWl6YXRpb24sIHRyYW5zbGF0aW9uIG1heSBhbHRlciBtdXRhdG9yIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQuXHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVYKF94OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhWzZdICs9IF94O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVZKF95OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhWzddICs9IF95O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBieSB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX2J5OiBWZWN0b3IyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDN4My5TQ0FMSU5HKF9ieSkpO1xyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB4LUF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWChfYnk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9ieSwgMSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeS1BeGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgdmVjdG9yLnNldCgxLCBfYnkpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFJvdGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHotQXhpcyB0byB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gTWF0cml4M3gzLk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDN4My5ST1RBVElPTihfYW5nbGVJbkRlZ3JlZXMpKTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9tdHhSaWdodDogTWF0cml4M3gzKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5NVUxUSVBMSUNBVElPTih0aGlzLCBfbXR4UmlnaHQpO1xyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBldWxlci1hbmdsZXMgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRFdWxlckFuZ2xlKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IyID0gdGhpcy5zY2FsaW5nO1xyXG5cclxuICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczM6IG51bWJlciA9IHRoaXMuZGF0YVszXSAvIHNjYWxpbmcueTtcclxuICAgICAgbGV0IHM0OiBudW1iZXIgPSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnk7XHJcblxyXG4gICAgICBsZXQgeFNrZXc6IG51bWJlciA9IE1hdGguYXRhbjIoLXMzLCBzNCk7XHJcbiAgICAgIGxldCB5U2tldzogbnVtYmVyID0gTWF0aC5hdGFuMihzMCwgczEpO1xyXG5cclxuICAgICAgbGV0IHN5OiBudW1iZXIgPSBNYXRoLmh5cG90KHMwLCBzMSk7IC8vIHByb2JhYmx5IDIuIHBhcmFtIHNob3VsZCBiZSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnlcclxuICAgICAgbGV0IHJvdGF0aW9uOiBudW1iZXI7XHJcblxyXG4gICAgICBpZiAoIShzeSA+IDFlLTYpKVxyXG4gICAgICAgIHJvdGF0aW9uID0geVNrZXc7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByb3RhdGlvbiA9IHhTa2V3O1xyXG5cclxuICAgICAgcm90YXRpb24gKj0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgICAgIHJldHVybiByb3RhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF9tdHhUbzogTWF0cml4M3gzKTogdm9pZCB7XHJcbiAgICAgIC8vIHRoaXMuZGF0YSA9IF90by5nZXQoKTtcclxuICAgICAgdGhpcy5kYXRhLnNldChfbXR4VG8uZGF0YSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYMaSLk1hdHJpeDN4Myh0cmFuc2xhdGlvbjogJHt0aGlzLnRyYW5zbGF0aW9uLnRvU3RyaW5nKCl9LCByb3RhdGlvbjogJHt0aGlzLnJvdGF0aW9uLnRvU3RyaW5nKCl9LCBzY2FsaW5nOiAke3RoaXMuc2NhbGluZy50b1N0cmluZygpfWA7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggYXMgYSBGbG9hdDMyQXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5zZXJpYWxpemUoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogYXdhaXQgdGhpcy50cmFuc2xhdGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi50cmFuc2xhdGlvbiksXHJcbiAgICAgICAgcm90YXRpb246IF9zZXJpYWxpemF0aW9uLnJvdGF0aW9uLFxyXG4gICAgICAgIHNjYWxpbmc6IGF3YWl0IHRoaXMuc2NhbGluZy5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5zY2FsaW5nKVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLm11dGF0ZShtdXRhdG9yKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGlmICh0aGlzLm11dGF0b3IpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRvcjtcclxuXHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLmdldE11dGF0b3IoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuZ2V0TXV0YXRvcigpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBjYWNoZSBtdXRhdG9yXHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG11dGF0b3I7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IG9sZFRyYW5zbGF0aW9uOiBWZWN0b3IyID0gdGhpcy50cmFuc2xhdGlvbjtcclxuICAgICAgbGV0IG9sZFJvdGF0aW9uOiBudW1iZXIgPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICBsZXQgb2xkU2NhbGluZzogVmVjdG9yMiA9IHRoaXMuc2NhbGluZztcclxuICAgICAgbGV0IG5ld1RyYW5zbGF0aW9uOiBWZWN0b3IyID0gPFZlY3RvcjI+X211dGF0b3JbXCJ0cmFuc2xhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1JvdGF0aW9uOiBudW1iZXIgPSA8bnVtYmVyPl9tdXRhdG9yW1wicm90YXRpb25cIl07XHJcbiAgICAgIGxldCBuZXdTY2FsaW5nOiBWZWN0b3IyID0gPFZlY3RvcjI+X211dGF0b3JbXCJzY2FsaW5nXCJdO1xyXG4gICAgICBsZXQgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb24gPSB7IHRyYW5zbGF0aW9uOiBvbGRUcmFuc2xhdGlvbiwgcm90YXRpb246IG9sZFJvdGF0aW9uLCBzY2FsaW5nOiBvbGRTY2FsaW5nIH07XHJcbiAgICAgIGlmIChuZXdUcmFuc2xhdGlvbikge1xyXG4gICAgICAgIHZlY3RvcnMudHJhbnNsYXRpb24gPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueCA6IG9sZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnkgOiBvbGRUcmFuc2xhdGlvbi55XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmVjdG9ycy5yb3RhdGlvbiA9IChuZXdSb3RhdGlvbiA9PSB1bmRlZmluZWQpID8gb2xkUm90YXRpb24gOiBuZXdSb3RhdGlvbjtcclxuXHJcbiAgICAgIGlmIChuZXdTY2FsaW5nKSB7XHJcbiAgICAgICAgdmVjdG9ycy5zY2FsaW5nID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnggIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy54IDogb2xkU2NhbGluZy54LFxyXG4gICAgICAgICAgbmV3U2NhbGluZy55ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueSA6IG9sZFNjYWxpbmcueVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHBvc3NpYmxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB3aGVuIG9ubHkgb25lIG9yIHR3byBjb21wb25lbnRzIGNoYW5nZSwgdGhlbiB1c2Ugb2xkIG1hdHJpeCBpbnN0ZWFkIG9mIElERU5USVRZIGFuZCB0cmFuc2Zvcm0gYnkgZGlmZmVyZW5jZXMvcXVvdGllbnRzXHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5JREVOVElUWSgpO1xyXG4gICAgICBpZiAodmVjdG9ycy50cmFuc2xhdGlvbilcclxuICAgICAgICBtdHhSZXN1bHQudHJhbnNsYXRlKHZlY3RvcnMudHJhbnNsYXRpb24pO1xyXG4gICAgICBpZiAodmVjdG9ycy5yb3RhdGlvbikge1xyXG4gICAgICAgIG10eFJlc3VsdC5yb3RhdGUodmVjdG9ycy5yb3RhdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZlY3RvcnMuc2NhbGluZylcclxuICAgICAgICBtdHhSZXN1bHQuc2NhbGUodmVjdG9ycy5zY2FsaW5nKTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcclxuXHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikgdHlwZXMudHJhbnNsYXRpb24gPSBcIlZlY3RvcjJcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uICE9IHVuZGVmaW5lZCkgdHlwZXMucm90YXRpb24gPSBcIm51bWJlclwiO1xyXG4gICAgICBpZiAoX211dGF0b3Iuc2NhbGluZykgdHlwZXMuc2NhbGluZyA9IFwiVmVjdG9yMlwiO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNldENhY2hlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnZlY3RvcnMgPSB7IHRyYW5zbGF0aW9uOiBudWxsLCByb3RhdGlvbjogbnVsbCwgc2NhbGluZzogbnVsbCB9O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxuXHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1hdHJpeCBhcyB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxpbmcge0BsaW5rIFZlY3RvcjN9LCBiZWluZyBjYWxjdWxhdGVkIGZyb20gdGhlIG1hdHJpeFxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBWZWN0b3JSZXByZXNlbnRhdGlvbiB7XHJcbiAgICB0cmFuc2xhdGlvbjogVmVjdG9yMztcclxuICAgIHJvdGF0aW9uOiBWZWN0b3IzO1xyXG4gICAgc2NhbGluZzogVmVjdG9yMztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYW5kIHByb3ZpZGVzIG9wZXJhdGlvbnMgZm9yIGl0LlxyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqIFsgMCwgMSwgMiwgMyBdIOKGkCByb3cgdmVjdG9yIHhcclxuICAgKiBbIDQsIDUsIDYsIDcgXSDihpAgcm93IHZlY3RvciB5XHJcbiAgICogWyA4LCA5LDEwLDExIF0g4oaQIHJvdyB2ZWN0b3IgelxyXG4gICAqIFsxMiwxMywxNCwxNSBdIOKGkCB0cmFuc2xhdGlvblxyXG4gICAqICAgICAgICAgICAg4oaRICBob21vZ2VuZW91cyBjb2x1bW5cclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcblxyXG4gIGV4cG9ydCBjbGFzcyBNYXRyaXg0eDQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVnMnJhZDogbnVtYmVyID0gTWF0aC5QSSAvIDE4MDtcclxuICAgICNldWxlckFuZ2xlczogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgI3ZlY3RvcnM6IFZlY3RvclJlcHJlc2VudGF0aW9uID0geyB0cmFuc2xhdGlvbjogVmVjdG9yMy5aRVJPKCksIHJvdGF0aW9uOiBWZWN0b3IzLlpFUk8oKSwgc2NhbGluZzogVmVjdG9yMy5aRVJPKCkgfTtcclxuXHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpOyAvLyBUaGUgZGF0YSBvZiB0aGUgbWF0cml4LlxyXG4gICAgcHJpdmF0ZSBtdXRhdG9yOiBNdXRhdG9yID0gbnVsbDsgLy8gcHJlcGFyZWQgZm9yIG9wdGltaXphdGlvbiwga2VlcCBtdXRhdG9yIHRvIHJlZHVjZSByZWR1bmRhbnQgY2FsY3VsYXRpb24gYW5kIGZvciBjb21wYXJpc29uLiBTZXQgdG8gbnVsbCB3aGVuIGRhdGEgY2hhbmdlcyFcclxuICAgIHByaXZhdGUgdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb247IC8vIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5yZWN5Y2xlKCk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBTVEFUSUNTXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGEgbmV3IGlkZW50aXR5IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBtYXRyaXggYWNjb3JkaW5nIHRvIHRoZSB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxpbmcge0BsaW5rIFZlY3RvcjN9cyBnaXZlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENPTlNUUlVDVElPTihfdmVjdG9yczogVmVjdG9yUmVwcmVzZW50YXRpb24pOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgcmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgcmVzdWx0Lm11dGF0ZShfdmVjdG9ycyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0d28gcGFzc2VkIG1hdHJpY2VzLlxyXG4gICAgICogQHBhcmFtIF9tdHhMZWZ0IFRoZSBtYXRyaXggdG8gbXVsdGlwbHkuXHJcbiAgICAgKiBAcGFyYW0gX210eFJpZ2h0IFRoZSBtYXRyaXggdG8gbXVsdGlwbHkgYnkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTVVMVElQTElDQVRJT04oX210eExlZnQ6IE1hdHJpeDR4NCwgX210eFJpZ2h0OiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgYTogRmxvYXQzMkFycmF5ID0gX210eExlZnQuZGF0YTtcclxuICAgICAgbGV0IGI6IEZsb2F0MzJBcnJheSA9IF9tdHhSaWdodC5kYXRhO1xyXG4gICAgICAvLyBsZXQgbWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0KCk7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCBhMDA6IG51bWJlciA9IGFbMCAqIDQgKyAwXTtcclxuICAgICAgbGV0IGEwMTogbnVtYmVyID0gYVswICogNCArIDFdO1xyXG4gICAgICBsZXQgYTAyOiBudW1iZXIgPSBhWzAgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMDM6IG51bWJlciA9IGFbMCAqIDQgKyAzXTtcclxuICAgICAgbGV0IGExMDogbnVtYmVyID0gYVsxICogNCArIDBdO1xyXG4gICAgICBsZXQgYTExOiBudW1iZXIgPSBhWzEgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMTI6IG51bWJlciA9IGFbMSAqIDQgKyAyXTtcclxuICAgICAgbGV0IGExMzogbnVtYmVyID0gYVsxICogNCArIDNdO1xyXG4gICAgICBsZXQgYTIwOiBudW1iZXIgPSBhWzIgKiA0ICsgMF07XHJcbiAgICAgIGxldCBhMjE6IG51bWJlciA9IGFbMiAqIDQgKyAxXTtcclxuICAgICAgbGV0IGEyMjogbnVtYmVyID0gYVsyICogNCArIDJdO1xyXG4gICAgICBsZXQgYTIzOiBudW1iZXIgPSBhWzIgKiA0ICsgM107XHJcbiAgICAgIGxldCBhMzA6IG51bWJlciA9IGFbMyAqIDQgKyAwXTtcclxuICAgICAgbGV0IGEzMTogbnVtYmVyID0gYVszICogNCArIDFdO1xyXG4gICAgICBsZXQgYTMyOiBudW1iZXIgPSBhWzMgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMzM6IG51bWJlciA9IGFbMyAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIwMDogbnVtYmVyID0gYlswICogNCArIDBdO1xyXG4gICAgICBsZXQgYjAxOiBudW1iZXIgPSBiWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMDI6IG51bWJlciA9IGJbMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIwMzogbnVtYmVyID0gYlswICogNCArIDNdO1xyXG4gICAgICBsZXQgYjEwOiBudW1iZXIgPSBiWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMTE6IG51bWJlciA9IGJbMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIxMjogbnVtYmVyID0gYlsxICogNCArIDJdO1xyXG4gICAgICBsZXQgYjEzOiBudW1iZXIgPSBiWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBiMjA6IG51bWJlciA9IGJbMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IGIyMTogbnVtYmVyID0gYlsyICogNCArIDFdO1xyXG4gICAgICBsZXQgYjIyOiBudW1iZXIgPSBiWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBiMjM6IG51bWJlciA9IGJbMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIzMDogbnVtYmVyID0gYlszICogNCArIDBdO1xyXG4gICAgICBsZXQgYjMxOiBudW1iZXIgPSBiWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMzI6IG51bWJlciA9IGJbMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIzMzogbnVtYmVyID0gYlszICogNCArIDNdO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwICsgYjAzICogYTMwLFxyXG4gICAgICAgICAgYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxICsgYjAzICogYTMxLFxyXG4gICAgICAgICAgYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyICsgYjAzICogYTMyLFxyXG4gICAgICAgICAgYjAwICogYTAzICsgYjAxICogYTEzICsgYjAyICogYTIzICsgYjAzICogYTMzLFxyXG4gICAgICAgICAgYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwICsgYjEzICogYTMwLFxyXG4gICAgICAgICAgYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxICsgYjEzICogYTMxLFxyXG4gICAgICAgICAgYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyICsgYjEzICogYTMyLFxyXG4gICAgICAgICAgYjEwICogYTAzICsgYjExICogYTEzICsgYjEyICogYTIzICsgYjEzICogYTMzLFxyXG4gICAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwICsgYjIzICogYTMwLFxyXG4gICAgICAgICAgYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxICsgYjIzICogYTMxLFxyXG4gICAgICAgICAgYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyICsgYjIzICogYTMyLFxyXG4gICAgICAgICAgYjIwICogYTAzICsgYjIxICogYTEzICsgYjIyICogYTIzICsgYjIzICogYTMzLFxyXG4gICAgICAgICAgYjMwICogYTAwICsgYjMxICogYTEwICsgYjMyICogYTIwICsgYjMzICogYTMwLFxyXG4gICAgICAgICAgYjMwICogYTAxICsgYjMxICogYTExICsgYjMyICogYTIxICsgYjMzICogYTMxLFxyXG4gICAgICAgICAgYjMwICogYTAyICsgYjMxICogYTEyICsgYjMyICogYTIyICsgYjMzICogYTMyLFxyXG4gICAgICAgICAgYjMwICogYTAzICsgYjMxICogYTEzICsgYjMyICogYTIzICsgYjMzICogYTMzXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHRyYW5zcG9zZSBvZiBhIHBhc3NlZCBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNQT1NFKF9tdHg6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbXR4LmRhdGE7XHJcbiAgICAgIGxldCByZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICByZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIG1bMF0sIG1bNF0sIG1bOF0sIG1bMTJdLFxyXG4gICAgICAgIG1bMV0sIG1bNV0sIG1bOV0sIG1bMTNdLFxyXG4gICAgICAgIG1bMl0sIG1bNl0sIG1bMTBdLCBtWzE0XSxcclxuICAgICAgICBtWzNdLCBtWzddLCBtWzExXSwgbVsxNV1cclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaW52ZXJzZSBvZiBhIHBhc3NlZCBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0gX210eCBUaGUgbWF0cml4IHRvIGNvbXB1dGUgdGhlIGludmVyc2Ugb2YuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJTSU9OKF9tdHg6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbXR4LmRhdGE7XHJcbiAgICAgIGxldCBtMDA6IG51bWJlciA9IG1bMCAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0wMTogbnVtYmVyID0gbVswICogNCArIDFdO1xyXG4gICAgICBsZXQgbTAyOiBudW1iZXIgPSBtWzAgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMDM6IG51bWJlciA9IG1bMCAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0xMDogbnVtYmVyID0gbVsxICogNCArIDBdO1xyXG4gICAgICBsZXQgbTExOiBudW1iZXIgPSBtWzEgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMTI6IG51bWJlciA9IG1bMSAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0xMzogbnVtYmVyID0gbVsxICogNCArIDNdO1xyXG4gICAgICBsZXQgbTIwOiBudW1iZXIgPSBtWzIgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMjE6IG51bWJlciA9IG1bMiAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0yMjogbnVtYmVyID0gbVsyICogNCArIDJdO1xyXG4gICAgICBsZXQgbTIzOiBudW1iZXIgPSBtWzIgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMzA6IG51bWJlciA9IG1bMyAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0zMTogbnVtYmVyID0gbVszICogNCArIDFdO1xyXG4gICAgICBsZXQgbTMyOiBudW1iZXIgPSBtWzMgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMzM6IG51bWJlciA9IG1bMyAqIDQgKyAzXTtcclxuICAgICAgbGV0IHRtcDA6IG51bWJlciA9IG0yMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDE6IG51bWJlciA9IG0zMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDI6IG51bWJlciA9IG0xMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDM6IG51bWJlciA9IG0zMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDQ6IG51bWJlciA9IG0xMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDU6IG51bWJlciA9IG0yMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDY6IG51bWJlciA9IG0wMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDc6IG51bWJlciA9IG0zMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDg6IG51bWJlciA9IG0wMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDk6IG51bWJlciA9IG0yMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDEwOiBudW1iZXIgPSBtMDIgKiBtMTM7XHJcbiAgICAgIGxldCB0bXAxMTogbnVtYmVyID0gbTEyICogbTAzO1xyXG4gICAgICBsZXQgdG1wMTI6IG51bWJlciA9IG0yMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDEzOiBudW1iZXIgPSBtMzAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNDogbnVtYmVyID0gbTEwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTU6IG51bWJlciA9IG0zMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDE2OiBudW1iZXIgPSBtMTAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNzogbnVtYmVyID0gbTIwICogbTExO1xyXG4gICAgICBsZXQgdG1wMTg6IG51bWJlciA9IG0wMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDE5OiBudW1iZXIgPSBtMzAgKiBtMDE7XHJcbiAgICAgIGxldCB0bXAyMDogbnVtYmVyID0gbTAwICogbTIxO1xyXG4gICAgICBsZXQgdG1wMjE6IG51bWJlciA9IG0yMCAqIG0wMTtcclxuICAgICAgbGV0IHRtcDIyOiBudW1iZXIgPSBtMDAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAyMzogbnVtYmVyID0gbTEwICogbTAxO1xyXG5cclxuICAgICAgbGV0IHQwOiBudW1iZXIgPSAodG1wMCAqIG0xMSArIHRtcDMgKiBtMjEgKyB0bXA0ICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDEgKiBtMTEgKyB0bXAyICogbTIxICsgdG1wNSAqIG0zMSk7XHJcblxyXG4gICAgICBsZXQgdDE6IG51bWJlciA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cclxuICAgICAgICAodG1wMCAqIG0wMSArIHRtcDcgKiBtMjEgKyB0bXA4ICogbTMxKTtcclxuICAgICAgbGV0IHQyOiBudW1iZXIgPSAodG1wMiAqIG0wMSArIHRtcDcgKiBtMTEgKyB0bXAxMCAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcclxuICAgICAgbGV0IHQzOiBudW1iZXIgPSAodG1wNSAqIG0wMSArIHRtcDggKiBtMTEgKyB0bXAxMSAqIG0yMSkgLVxyXG4gICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcclxuXHJcbiAgICAgIGxldCBkOiBudW1iZXIgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xyXG5cclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICBkICogdDAsIC8vIFswXVxyXG4gICAgICAgIGQgKiB0MSwgLy8gWzFdXHJcbiAgICAgICAgZCAqIHQyLCAvLyBbMl1cclxuICAgICAgICBkICogdDMsIC8vIFszXVxyXG4gICAgICAgIGQgKiAoKHRtcDEgKiBtMTAgKyB0bXAyICogbTIwICsgdG1wNSAqIG0zMCkgLSAodG1wMCAqIG0xMCArIHRtcDMgKiBtMjAgKyB0bXA0ICogbTMwKSksICAgICAgICAvLyBbNF1cclxuICAgICAgICBkICogKCh0bXAwICogbTAwICsgdG1wNyAqIG0yMCArIHRtcDggKiBtMzApIC0gKHRtcDEgKiBtMDAgKyB0bXA2ICogbTIwICsgdG1wOSAqIG0zMCkpLCAgICAgICAgLy8gWzVdXHJcbiAgICAgICAgZCAqICgodG1wMyAqIG0wMCArIHRtcDYgKiBtMTAgKyB0bXAxMSAqIG0zMCkgLSAodG1wMiAqIG0wMCArIHRtcDcgKiBtMTAgKyB0bXAxMCAqIG0zMCkpLCAgICAgIC8vIFs2XVxyXG4gICAgICAgIGQgKiAoKHRtcDQgKiBtMDAgKyB0bXA5ICogbTEwICsgdG1wMTAgKiBtMjApIC0gKHRtcDUgKiBtMDAgKyB0bXA4ICogbTEwICsgdG1wMTEgKiBtMjApKSwgICAgICAvLyBbN11cclxuICAgICAgICBkICogKCh0bXAxMiAqIG0xMyArIHRtcDE1ICogbTIzICsgdG1wMTYgKiBtMzMpIC0gKHRtcDEzICogbTEzICsgdG1wMTQgKiBtMjMgKyB0bXAxNyAqIG0zMykpLCAgLy8gWzhdXHJcbiAgICAgICAgZCAqICgodG1wMTMgKiBtMDMgKyB0bXAxOCAqIG0yMyArIHRtcDIxICogbTMzKSAtICh0bXAxMiAqIG0wMyArIHRtcDE5ICogbTIzICsgdG1wMjAgKiBtMzMpKSwgIC8vIFs5XVxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTAzICsgdG1wMTkgKiBtMTMgKyB0bXAyMiAqIG0zMykgLSAodG1wMTUgKiBtMDMgKyB0bXAxOCAqIG0xMyArIHRtcDIzICogbTMzKSksICAvLyBbMTBdXHJcbiAgICAgICAgZCAqICgodG1wMTcgKiBtMDMgKyB0bXAyMCAqIG0xMyArIHRtcDIzICogbTIzKSAtICh0bXAxNiAqIG0wMyArIHRtcDIxICogbTEzICsgdG1wMjIgKiBtMjMpKSwgIC8vIFsxMV1cclxuICAgICAgICBkICogKCh0bXAxNCAqIG0yMiArIHRtcDE3ICogbTMyICsgdG1wMTMgKiBtMTIpIC0gKHRtcDE2ICogbTMyICsgdG1wMTIgKiBtMTIgKyB0bXAxNSAqIG0yMikpLCAgLy8gWzEyXVxyXG4gICAgICAgIGQgKiAoKHRtcDIwICogbTMyICsgdG1wMTIgKiBtMDIgKyB0bXAxOSAqIG0yMikgLSAodG1wMTggKiBtMjIgKyB0bXAyMSAqIG0zMiArIHRtcDEzICogbTAyKSksICAvLyBbMTNdXHJcbiAgICAgICAgZCAqICgodG1wMTggKiBtMTIgKyB0bXAyMyAqIG0zMiArIHRtcDE1ICogbTAyKSAtICh0bXAyMiAqIG0zMiArIHRtcDE0ICogbTAyICsgdG1wMTkgKiBtMTIpKSwgIC8vIFsxNF1cclxuICAgICAgICBkICogKCh0bXAyMiAqIG0yMiArIHRtcDE2ICogbTAyICsgdG1wMjEgKiBtMTIpIC0gKHRtcDIwICogbTEyICsgdG1wMjMgKiBtMjIgKyB0bXAxNyAqIG0wMikpICAvLyBbMTVdXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIGl0cyB6LWF4aXMgcG9pbnRpbmcgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHRhcmdldCxcclxuICAgICAqIGFuZCBhIG1pbmltYWwgYW5nbGUgYmV0d2VlbiBpdHMgeS1heGlzIGFuZCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LCByZXNwZXRpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExPT0tfQVQoX3RyYW5zbGF0aW9uOiBWZWN0b3IzLCBfdGFyZ2V0OiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoKSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCB6QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCBfdHJhbnNsYXRpb24pO1xyXG4gICAgICB6QXhpcy5ub3JtYWxpemUoKTtcclxuICAgICAgbGV0IHhBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoX3VwLCB6QXhpcykpO1xyXG4gICAgICBsZXQgeUF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oVmVjdG9yMy5DUk9TUyh6QXhpcywgeEF4aXMpKTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHhBeGlzLngsIHhBeGlzLnksIHhBeGlzLnosIDAsXHJcbiAgICAgICAgICB5QXhpcy54LCB5QXhpcy55LCB5QXhpcy56LCAwLFxyXG4gICAgICAgICAgekF4aXMueCwgekF4aXMueSwgekF4aXMueiwgMCxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi54LFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLnksXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueixcclxuICAgICAgICAgIDFcclxuICAgICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLCBpdHMgeS1heGlzIG1hdGNoaW5nIHRoZSBnaXZlbiB1cC17QGxpbmsgVmVjdG9yM31cclxuICAgICAqIGFuZCBpdHMgei1heGlzIGZhY2luZyB0b3dhcmRzIHRoZSBnaXZlbiB0YXJnZXQgYXQgYSBtaW5pbWFsIGFuZ2xlLCByZXNwZXRpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTSE9XX1RPKF90cmFuc2xhdGlvbjogVmVjdG9yMywgX3RhcmdldDogVmVjdG9yMywgX3VwOiBWZWN0b3IzID0gVmVjdG9yMy5ZKCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgekF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgX3RyYW5zbGF0aW9uKTtcclxuICAgICAgekF4aXMubm9ybWFsaXplKCk7XHJcbiAgICAgIGxldCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKF91cCwgekF4aXMpKTtcclxuICAgICAgLy8gbGV0IHlBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoekF4aXMsIHhBeGlzKSk7XHJcbiAgICAgIHpBeGlzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoeEF4aXMsIF91cCkpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgeEF4aXMueCwgeEF4aXMueSwgeEF4aXMueiwgMCxcclxuICAgICAgICAgIF91cC54LCBfdXAueSwgX3VwLnosIDAsXHJcbiAgICAgICAgICB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56LCAwLFxyXG4gICAgICAgICAgX3RyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBfdHJhbnNsYXRpb24ueSxcclxuICAgICAgICAgIF90cmFuc2xhdGlvbi56LFxyXG4gICAgICAgICAgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHRyYW5zbGF0ZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TTEFUSU9OKF90cmFuc2xhdGU6IFZlY3RvcjMpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIF90cmFuc2xhdGUueCwgX3RyYW5zbGF0ZS55LCBfdHJhbnNsYXRlLnosIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeC1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9YKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBNYXRyaXg0eDQuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCBjb3MsIHNpbiwgMCxcclxuICAgICAgICAwLCAtc2luLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIG9uIHRoZSB5LWF4aXMgd2hlbiBtdWx0aXBsaWVkIGJ5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1koX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBNYXRyaXg0eDQuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgY29zLCAwLCAtc2luLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgc2luLCAwLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIG9uIHRoZSB6LWF4aXMgd2hlbiBtdWx0aXBsaWVkIGJ5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIE1hdHJpeDR4NC5kZWcycmFkO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICBjb3MsIHNpbiwgMCwgMCxcclxuICAgICAgICAtc2luLCBjb3MsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgd2hlbiBtdWx0aXBsaWVkIGJ5LCB1c2luZyB0aGUgYW5nbGVzIGdpdmVuLlxyXG4gICAgICogUm90YXRpb24gb2NjdXJzIGFyb3VuZCB0aGUgYXhpcyBpbiB0aGUgb3JkZXIgWi1ZLVggLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OKF9ldWxlckFuZ2xlc0luRGVncmVlczogVmVjdG9yMyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIGxldCBhbmdsZXNJblJhZGlhbnM6IFZlY3RvcjMgPSBWZWN0b3IzLlNDQUxFKF9ldWxlckFuZ2xlc0luRGVncmVlcywgTWF0cml4NHg0LmRlZzJyYWQpO1xyXG4gICAgICBsZXQgc2luWDogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVzSW5SYWRpYW5zLngpO1xyXG4gICAgICBsZXQgY29zWDogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVzSW5SYWRpYW5zLngpO1xyXG4gICAgICBsZXQgc2luWTogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVzSW5SYWRpYW5zLnkpO1xyXG4gICAgICBsZXQgY29zWTogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVzSW5SYWRpYW5zLnkpO1xyXG4gICAgICBsZXQgc2luWjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVzSW5SYWRpYW5zLnopO1xyXG4gICAgICBsZXQgY29zWjogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVzSW5SYWRpYW5zLnopO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIC8qKi8gICAgICAgICAgICAgICAgIGNvc1ogKiBjb3NZLCAvKiovICAgICAgICAgICAgICAgICBzaW5aICogY29zWSwgLyoqLyAgICAgICAtc2luWSwgMCxcclxuICAgICAgICBjb3NaICogc2luWSAqIHNpblggLSBzaW5aICogY29zWCwgc2luWiAqIHNpblkgKiBzaW5YICsgY29zWiAqIGNvc1gsIC8qKi8gY29zWSAqIHNpblgsIDAsXHJcbiAgICAgICAgY29zWiAqIHNpblkgKiBjb3NYICsgc2luWiAqIHNpblgsIHNpblogKiBzaW5ZICogY29zWCAtIGNvc1ogKiBzaW5YLCAvKiovIGNvc1kgKiBjb3NYLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgc2NhbGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSwgeS0gYW5kIHotYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHtAbGluayBWZWN0b3IzfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxJTkcoX3NjYWxhcjogVmVjdG9yMyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eFJlc3VsdC5kYXRhLnNldChbXHJcbiAgICAgICAgX3NjYWxhci54LCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIF9zY2FsYXIueSwgMCwgMCxcclxuICAgICAgICAwLCAwLCBfc2NhbGFyLnosIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gbWF0cml4IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBiYXNlLlxyXG4gICAgICogSWYga25vd24sIHBhc3MgdGhlIGludmVyc2Ugb2YgdGhlIGJhc2UgdG8gYXZvaWQgdW5uZWNjZXNhcnkgY2FsY3VsYXRpb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUkVMQVRJVkUoX210eDogTWF0cml4NHg0LCBfbXR4QmFzZTogTWF0cml4NHg0LCBfbXR4SW52ZXJzZT86IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGlmIChfbXR4SW52ZXJzZSlcclxuICAgICAgIHJldHVybiBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX210eEludmVyc2UsIF9tdHgpO1xyXG5cclxuICAgICAgbGV0IG10eEludmVyc2U6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JTlZFUlNJT04oX210eEJhc2UpO1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04obXR4SW52ZXJzZSwgX210eCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eEludmVyc2UpO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFBST0pFQ1RJT05TXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIGEgbWF0cml4IHRoYXQgYXBwbGllcyBwZXJzcGVjdGl2ZSB0byBhbiBvYmplY3QsIGlmIGl0cyB0cmFuc2Zvcm0gaXMgbXVsdGlwbGllZCBieSBpdC5cclxuICAgICAqIEBwYXJhbSBfYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gYmV0d2VlbiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHByb2plY3Rpb25zcGFjZS4oRGVmYXVsdCA9IGNhbnZhcy5jbGllbnRXaWR0aCAvIGNhbnZhcy5DbGllbnRIZWlnaHQpXHJcbiAgICAgKiBAcGFyYW0gX2ZpZWxkT2ZWaWV3SW5EZWdyZWVzIFRoZSBmaWVsZCBvZiB2aWV3IGluIERlZ3JlZXMuIChEZWZhdWx0ID0gNDUpXHJcbiAgICAgKiBAcGFyYW0gX25lYXIgVGhlIG5lYXIgY2xpcHNwYWNlIGJvcmRlciBvbiB0aGUgei1heGlzLlxyXG4gICAgICogQHBhcmFtIF9mYXIgVGhlIGZhciBjbGlwc3BhY2UgYm9yZGVyIG9uIHRoZSB6LWF4aXMuXHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgcGxhbmUgb24gd2hpY2ggdGhlIGZpZWxkT2ZWaWV3LUFuZ2xlIGlzIGdpdmVuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT05fQ0VOVFJBTChfYXNwZWN0OiBudW1iZXIsIF9maWVsZE9mVmlld0luRGVncmVlczogbnVtYmVyLCBfbmVhcjogbnVtYmVyLCBfZmFyOiBudW1iZXIsIF9kaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvL1RPRE86IGNhbWVyYSBsb29rcyBkb3duIG5lZ2F0aXZlIHotZGlyZWN0aW9uLCBzaG91bGQgYmUgcG9zaXRpdmVcclxuICAgICAgbGV0IGZpZWxkT2ZWaWV3SW5SYWRpYW5zOiBudW1iZXIgPSBfZmllbGRPZlZpZXdJbkRlZ3JlZXMgKiBNYXRyaXg0eDQuZGVnMnJhZDtcclxuICAgICAgbGV0IGY6IG51bWJlciA9IE1hdGgudGFuKDAuNSAqIChNYXRoLlBJIC0gZmllbGRPZlZpZXdJblJhZGlhbnMpKTtcclxuICAgICAgbGV0IHJhbmdlSW52OiBudW1iZXIgPSAxLjAgLyAoX25lYXIgLSBfZmFyKTtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbXR4UmVzdWx0LmRhdGEuc2V0KFtcclxuICAgICAgICBmLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIGYsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgKF9uZWFyICsgX2ZhcikgKiByYW5nZUludiwgLTEsXHJcbiAgICAgICAgMCwgMCwgX25lYXIgKiBfZmFyICogcmFuZ2VJbnYgKiAyLCAwXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIF9hc3BlY3QgPSBNYXRoLnNxcnQoX2FzcGVjdCk7XHJcbiAgICAgICAgbXR4UmVzdWx0LmRhdGFbMF0gPSBmIC8gX2FzcGVjdDtcclxuICAgICAgICBtdHhSZXN1bHQuZGF0YVs1XSA9IGYgKiBfYXNwZWN0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5WRVJUSUNBTClcclxuICAgICAgICBtdHhSZXN1bHQuZGF0YVswXSA9IGYgLyBfYXNwZWN0O1xyXG4gICAgICBlbHNlIC8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgbXR4UmVzdWx0LmRhdGFbNV0gPSBmICogX2FzcGVjdDtcclxuXHJcbiAgICAgIC8vIEhBQ0s6IG1hdHJpeCBzaG91bGQgbG9vayBpbiBwb3NpdGl2ZSB6LWRpcmVjdGlvbiwgcHJlZmVyYWJseSB0aGUgbWF0cml4IHNob3VsZCBiZSBjYWxjdWxhdGVkIGxpa2UgdGhhdCByaWdodCBhd2F5XHJcbiAgICAgIG10eFJlc3VsdC5yb3RhdGVZKDE4MCk7XHJcblxyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBsZWZ0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfcmlnaHQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHJpZ2h0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfYm90dG9tIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBib3R0b20gYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF90b3AgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHRvcCBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX25lYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIG5lYXIgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9mYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGZhciBib3JkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdDogbnVtYmVyLCBfcmlnaHQ6IG51bWJlciwgX2JvdHRvbTogbnVtYmVyLCBfdG9wOiBudW1iZXIsIF9uZWFyOiBudW1iZXIgPSAtNDAwLCBfZmFyOiBudW1iZXIgPSA0MDApOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIDIgLyAoX3JpZ2h0IC0gX2xlZnQpLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIDIgLyAoX3RvcCAtIF9ib3R0b20pLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDIgLyAoX25lYXIgLSBfZmFyKSwgMCxcclxuICAgICAgICAoX2xlZnQgKyBfcmlnaHQpIC8gKF9sZWZ0IC0gX3JpZ2h0KSxcclxuICAgICAgICAoX2JvdHRvbSArIF90b3ApIC8gKF9ib3R0b20gLSBfdG9wKSxcclxuICAgICAgICAoX25lYXIgKyBfZmFyKSAvIChfbmVhciAtIF9mYXIpLFxyXG4gICAgICAgIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gIEFjY2Vzc29yc1xyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNsYXRpb24ge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgYnkgUmVjeWNsZXIuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCB0cmFuc2xhdGlvbihfdHJhbnNsYXRpb246IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChfdHJhbnNsYXRpb24uZ2V0KCksIDEyKTtcclxuICAgICAgLy8gbm8gZnVsbCBjYWNoZSByZXNldCByZXF1aXJlZFxyXG4gICAgICBpZiAodGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbi5zZXQoX3RyYW5zbGF0aW9uLngsIF90cmFuc2xhdGlvbi55LCBfdHJhbnNsYXRpb24ueik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBfdHJhbnNsYXRpb24uY2xvbmU7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IHRyYW5zbGF0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy50cmFuc2xhdGlvbikge1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy50cmFuc2xhdGlvbiA9IHRoaXMuI3ZlY3RvcnMudHJhbnNsYXRpb247XHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uLnNldCh0aGlzLmRhdGFbMTJdLCB0aGlzLmRhdGFbMTNdLCB0aGlzLmRhdGFbMTRdKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uOyAvLyAuY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm90YXRpb24ge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgYnkgUmVjeWNsZXIuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy5yb3RhdGlvbilcclxuICAgICAgICB0aGlzLnZlY3RvcnMucm90YXRpb24gPSB0aGlzLmdldEV1bGVyQW5nbGVzKCkuY2xvbmU7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMucm90YXRpb247IC8vLmNsb25lO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RhdGlvbihfcm90YXRpb246IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2NhbGluZyB7QGxpbmsgVmVjdG9yM30uICBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBieSBSZWN5Y2xlci4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc2NhbGluZygpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMuc2NhbGluZykge1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy5zY2FsaW5nID0gdGhpcy4jdmVjdG9ycy5zY2FsaW5nO1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy5zY2FsaW5nLnNldChcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXSksXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl0pLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXSlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvcnMuc2NhbGluZzsgLy8gLmNsb25lO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzY2FsaW5nKF9zY2FsaW5nOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJzY2FsaW5nXCI6IF9zY2FsaW5nIH0pO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtdHhDbG9uZTogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eENsb25lLnNldCh0aGlzKTtcclxuICAgICAgcmV0dXJuIG10eENsb25lO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpOyBcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gUm90YXRpb25cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIHRoaXMgbWF0cml4IGJ5IGdpdmVuIHtAbGluayBWZWN0b3IzfSBpbiB0aGUgb3JkZXIgWiwgWSwgWC4gUmlnaHQgaGFuZCByb3RhdGlvbiBpcyB1c2VkLCB0aHVtYiBwb2ludHMgaW4gYXhpcyBkaXJlY3Rpb24sIGZpbmdlcnMgY3VybGluZyBpbmRpY2F0ZSByb3RhdGlvblxyXG4gICAgICogVGhlIHJvdGF0aW9uIGlzIGFwcGVuZGVkIHRvIGFscmVhZHkgYXBwbGllZCB0cmFuc2Zvcm1zLCB0aHVzIG11bHRpcGxpZWQgZnJvbSB0aGUgcmlnaHQuIFNldCBfZnJvbUxlZnQgdG8gdHJ1ZSB0byBzd2l0Y2ggYW5kIHB1dCBpdCBpbiBmcm9udC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZShfYnk6IFZlY3RvcjMsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIC8vIHRoaXMucm90YXRlWihfYnkueiwgX2Zyb21MZWZ0KTtcclxuICAgICAgLy8gdGhpcy5yb3RhdGVZKF9ieS55LCBfZnJvbUxlZnQpO1xyXG4gICAgICAvLyB0aGlzLnJvdGF0ZVgoX2J5LngsIF9mcm9tTGVmdCk7XHJcbiAgICAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OKF9ieSk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdHJhbnNwb3NlKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtYXRyaXg6IEZsb2F0MzJBcnJheSA9IHRoaXMuZGF0YTtcclxuICAgICAgdGhpcy5kYXRhLnNldChbXHJcbiAgICAgICAgbWF0cml4WzBdLCBtYXRyaXhbNF0sIG1hdHJpeFs4XSwgIG1hdHJpeFsxMl0sXHJcbiAgICAgICAgbWF0cml4WzFdLCBtYXRyaXhbNV0sIG1hdHJpeFs5XSwgIG1hdHJpeFsxM10sXHJcbiAgICAgICAgbWF0cml4WzJdLCBtYXRyaXhbNl0sIG1hdHJpeFsxMF0sIG1hdHJpeFsxNF0sXHJcbiAgICAgICAgbWF0cml4WzNdLCBtYXRyaXhbN10sIG1hdHJpeFsxMV0sIG1hdHJpeFsxNV1cclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbnZlcnNlKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcbiAgICAgIGxldCBtMDA6IG51bWJlciA9IG1bMCAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0wMTogbnVtYmVyID0gbVswICogNCArIDFdO1xyXG4gICAgICBsZXQgbTAyOiBudW1iZXIgPSBtWzAgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMDM6IG51bWJlciA9IG1bMCAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0xMDogbnVtYmVyID0gbVsxICogNCArIDBdO1xyXG4gICAgICBsZXQgbTExOiBudW1iZXIgPSBtWzEgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMTI6IG51bWJlciA9IG1bMSAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0xMzogbnVtYmVyID0gbVsxICogNCArIDNdO1xyXG4gICAgICBsZXQgbTIwOiBudW1iZXIgPSBtWzIgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMjE6IG51bWJlciA9IG1bMiAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0yMjogbnVtYmVyID0gbVsyICogNCArIDJdO1xyXG4gICAgICBsZXQgbTIzOiBudW1iZXIgPSBtWzIgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMzA6IG51bWJlciA9IG1bMyAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0zMTogbnVtYmVyID0gbVszICogNCArIDFdO1xyXG4gICAgICBsZXQgbTMyOiBudW1iZXIgPSBtWzMgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMzM6IG51bWJlciA9IG1bMyAqIDQgKyAzXTtcclxuICAgICAgbGV0IHRtcDA6IG51bWJlciA9IG0yMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDE6IG51bWJlciA9IG0zMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDI6IG51bWJlciA9IG0xMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDM6IG51bWJlciA9IG0zMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDQ6IG51bWJlciA9IG0xMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDU6IG51bWJlciA9IG0yMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDY6IG51bWJlciA9IG0wMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDc6IG51bWJlciA9IG0zMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDg6IG51bWJlciA9IG0wMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDk6IG51bWJlciA9IG0yMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDEwOiBudW1iZXIgPSBtMDIgKiBtMTM7XHJcbiAgICAgIGxldCB0bXAxMTogbnVtYmVyID0gbTEyICogbTAzO1xyXG4gICAgICBsZXQgdG1wMTI6IG51bWJlciA9IG0yMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDEzOiBudW1iZXIgPSBtMzAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNDogbnVtYmVyID0gbTEwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTU6IG51bWJlciA9IG0zMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDE2OiBudW1iZXIgPSBtMTAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNzogbnVtYmVyID0gbTIwICogbTExO1xyXG4gICAgICBsZXQgdG1wMTg6IG51bWJlciA9IG0wMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDE5OiBudW1iZXIgPSBtMzAgKiBtMDE7XHJcbiAgICAgIGxldCB0bXAyMDogbnVtYmVyID0gbTAwICogbTIxO1xyXG4gICAgICBsZXQgdG1wMjE6IG51bWJlciA9IG0yMCAqIG0wMTtcclxuICAgICAgbGV0IHRtcDIyOiBudW1iZXIgPSBtMDAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAyMzogbnVtYmVyID0gbTEwICogbTAxO1xyXG5cclxuICAgICAgbGV0IHQwOiBudW1iZXIgPSAodG1wMCAqIG0xMSArIHRtcDMgKiBtMjEgKyB0bXA0ICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDEgKiBtMTEgKyB0bXAyICogbTIxICsgdG1wNSAqIG0zMSk7XHJcblxyXG4gICAgICBsZXQgdDE6IG51bWJlciA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cclxuICAgICAgICAodG1wMCAqIG0wMSArIHRtcDcgKiBtMjEgKyB0bXA4ICogbTMxKTtcclxuICAgICAgbGV0IHQyOiBudW1iZXIgPSAodG1wMiAqIG0wMSArIHRtcDcgKiBtMTEgKyB0bXAxMCAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcclxuICAgICAgbGV0IHQzOiBudW1iZXIgPSAodG1wNSAqIG0wMSArIHRtcDggKiBtMTEgKyB0bXAxMSAqIG0yMSkgLVxyXG4gICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcclxuXHJcbiAgICAgIGxldCBkOiBudW1iZXIgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xyXG5cclxuICAgICAgLy8gbGV0IG1hdHJpeDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NDtcclxuICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgICAgbWF0cml4LmRhdGEuc2V0KFtcclxuICAgICAgICBkICogdDAsIC8vIFswXVxyXG4gICAgICAgIGQgKiB0MSwgLy8gWzFdXHJcbiAgICAgICAgZCAqIHQyLCAvLyBbMl1cclxuICAgICAgICBkICogdDMsIC8vIFszXVxyXG4gICAgICAgIGQgKiAoKHRtcDEgKiBtMTAgKyB0bXAyICogbTIwICsgdG1wNSAqIG0zMCkgLSAodG1wMCAqIG0xMCArIHRtcDMgKiBtMjAgKyB0bXA0ICogbTMwKSksICAgICAgICAvLyBbNF1cclxuICAgICAgICBkICogKCh0bXAwICogbTAwICsgdG1wNyAqIG0yMCArIHRtcDggKiBtMzApIC0gKHRtcDEgKiBtMDAgKyB0bXA2ICogbTIwICsgdG1wOSAqIG0zMCkpLCAgICAgICAgLy8gWzVdXHJcbiAgICAgICAgZCAqICgodG1wMyAqIG0wMCArIHRtcDYgKiBtMTAgKyB0bXAxMSAqIG0zMCkgLSAodG1wMiAqIG0wMCArIHRtcDcgKiBtMTAgKyB0bXAxMCAqIG0zMCkpLCAgICAgIC8vIFs2XVxyXG4gICAgICAgIGQgKiAoKHRtcDQgKiBtMDAgKyB0bXA5ICogbTEwICsgdG1wMTAgKiBtMjApIC0gKHRtcDUgKiBtMDAgKyB0bXA4ICogbTEwICsgdG1wMTEgKiBtMjApKSwgICAgICAvLyBbN11cclxuICAgICAgICBkICogKCh0bXAxMiAqIG0xMyArIHRtcDE1ICogbTIzICsgdG1wMTYgKiBtMzMpIC0gKHRtcDEzICogbTEzICsgdG1wMTQgKiBtMjMgKyB0bXAxNyAqIG0zMykpLCAgLy8gWzhdXHJcbiAgICAgICAgZCAqICgodG1wMTMgKiBtMDMgKyB0bXAxOCAqIG0yMyArIHRtcDIxICogbTMzKSAtICh0bXAxMiAqIG0wMyArIHRtcDE5ICogbTIzICsgdG1wMjAgKiBtMzMpKSwgIC8vIFs5XVxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTAzICsgdG1wMTkgKiBtMTMgKyB0bXAyMiAqIG0zMykgLSAodG1wMTUgKiBtMDMgKyB0bXAxOCAqIG0xMyArIHRtcDIzICogbTMzKSksICAvLyBbMTBdXHJcbiAgICAgICAgZCAqICgodG1wMTcgKiBtMDMgKyB0bXAyMCAqIG0xMyArIHRtcDIzICogbTIzKSAtICh0bXAxNiAqIG0wMyArIHRtcDIxICogbTEzICsgdG1wMjIgKiBtMjMpKSwgIC8vIFsxMV1cclxuICAgICAgICBkICogKCh0bXAxNCAqIG0yMiArIHRtcDE3ICogbTMyICsgdG1wMTMgKiBtMTIpIC0gKHRtcDE2ICogbTMyICsgdG1wMTIgKiBtMTIgKyB0bXAxNSAqIG0yMikpLCAgLy8gWzEyXVxyXG4gICAgICAgIGQgKiAoKHRtcDIwICogbTMyICsgdG1wMTIgKiBtMDIgKyB0bXAxOSAqIG0yMikgLSAodG1wMTggKiBtMjIgKyB0bXAyMSAqIG0zMiArIHRtcDEzICogbTAyKSksICAvLyBbMTNdXHJcbiAgICAgICAgZCAqICgodG1wMTggKiBtMTIgKyB0bXAyMyAqIG0zMiArIHRtcDE1ICogbTAyKSAtICh0bXAyMiAqIG0zMiArIHRtcDE0ICogbTAyICsgdG1wMTkgKiBtMTIpKSwgIC8vIFsxNF1cclxuICAgICAgICBkICogKCh0bXAyMiAqIG0yMiArIHRtcDE2ICogbTAyICsgdG1wMjEgKiBtMTIpIC0gKHRtcDIwICogbTEyICsgdG1wMjMgKiBtMjIgKyB0bXAxNyAqIG0wMikpICAvLyBbMTVdXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgeC1heGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVYKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9YKF9hbmdsZUluRGVncmVlcyk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHktYXhpcyB0byB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlWShfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShfYW5nbGVJbkRlZ3JlZXMpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSb3RhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB6LWF4aXMgdG8gdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZVooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyB0aGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXggdG8gcG9pbnQgdGhlIHotYXhpcyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCB0aWx0cyBpdCB0byBhY2NvcmQgd2l0aCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LFxyXG4gICAgICogcmVzcGVjdGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBhbmQgcGl0Y2guIElmIG5vIHVwLXtAbGluayBWZWN0b3IzfSBpcyBnaXZlbiwgdGhlIHByZXZpb3VzIHVwLXtAbGluayBWZWN0b3IzfSBpcyB1c2VkLiBcclxuICAgICAqIFdoZW4gX3ByZXNlcnZlU2NhbGluZyBpcyBmYWxzZSwgYSByb3RhdGVkIGlkZW50aXR5IG1hdHJpeCBpcyB0aGUgcmVzdWx0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvb2tBdChfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcHJlc2VydmVTY2FsaW5nOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBpZiAoIV91cClcclxuICAgICAgICBfdXAgPSB0aGlzLmdldFkoKTtcclxuXHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkxPT0tfQVQodGhpcy50cmFuc2xhdGlvbiwgX3RhcmdldCwgX3VwKTtcclxuICAgICAgaWYgKF9wcmVzZXJ2ZVNjYWxpbmcpXHJcbiAgICAgICAgbXR4UmVzdWx0LnNjYWxlKHRoaXMuc2NhbGluZyk7XHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhbWUgYXMge0BsaW5rIE1hdHJpeDR4NC5sb29rQXR9LCBidXQgb3B0aW1pemVkIGFuZCBuZWVkcyB0ZXN0aW5nXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IHRlc3RpbmcgbG9va2F0IHRoYXQgcmVhbGx5IGp1c3Qgcm90YXRlcyB0aGUgbWF0cml4IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG9uZVxyXG4gICAgcHVibGljIGxvb2tBdFJvdGF0ZShfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcHJlc2VydmVTY2FsaW5nOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBpZiAoIV91cClcclxuICAgICAgICBfdXAgPSB0aGlzLmdldFkoKTtcclxuXHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCB0aGlzLnRyYW5zbGF0aW9uKTtcclxuICAgICAgZGlmZmVyZW5jZS5ub3JtYWxpemUoKTtcclxuICAgICAgbGV0IGNvczogbnVtYmVyID0gVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WigpKSwgZGlmZmVyZW5jZSk7XHJcbiAgICAgIGxldCBzaW46IG51bWJlciA9IFZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFgoKSksIGRpZmZlcmVuY2UpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhzaW4sIGNvcyk7XHJcbiAgICAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gUmVjeWNsZXIuYm9ycm93KE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eFJvdGF0aW9uLmRhdGEuc2V0KFtcclxuICAgICAgICBjb3MsIDAsIC1zaW4sIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICBzaW4sIDAsIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBmYWxzZSk7XHJcblxyXG4gICAgICBjb3MgPSBWZWN0b3IzLkRPVChWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5nZXRaKCkpLCBkaWZmZXJlbmNlKTtcclxuICAgICAgc2luID0gLVZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFkoKSksIGRpZmZlcmVuY2UpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhzaW4sIGNvcyk7XHJcbiAgICAgIG10eFJvdGF0aW9uLmRhdGEuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIGNvcywgc2luLCAwLFxyXG4gICAgICAgIDAsIC1zaW4sIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBmYWxzZSk7XHJcbiAgICAgIHRoaXMuc2NhbGluZyA9IHNjYWxpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeCB0byBtYXRjaCBpdHMgeS1heGlzIHdpdGggdGhlIGdpdmVuIHVwLXtAbGluayBWZWN0b3IzfSBhbmQgZmFjaW5nIGl0cyB6LWF4aXMgdG93YXJkIHRoZSBnaXZlbiB0YXJnZXQgYXQgbWluaW1hbCBhbmdsZSxcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS4gSWYgbm8gdXAte0BsaW5rIFZlY3RvcjN9IGlzIGdpdmVuLCB0aGUgcHJldmlvdXMgdXAte0BsaW5rIFZlY3RvcjN9IGlzIHVzZWQuIFxyXG4gICAgICogV2hlbiBfcHJlc2VydmVTY2FsaW5nIGlzIGZhbHNlLCBhIHJvdGF0ZWQgaWRlbnRpdHkgbWF0cml4IGlzIHRoZSByZXN1bHQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvd1RvKF90YXJnZXQ6IFZlY3RvcjMsIF91cD86IFZlY3RvcjMsIF9wcmVzZXJ2ZVNjYWxpbmc6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGlmICghX3VwKVxyXG4gICAgICAgIF91cCA9IHRoaXMuZ2V0WSgpO1xyXG5cclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuU0hPV19UTyh0aGlzLnRyYW5zbGF0aW9uLCBfdGFyZ2V0LCBfdXApO1xyXG4gICAgICBpZiAoX3ByZXNlcnZlU2NhbGluZylcclxuICAgICAgICBtdHhSZXN1bHQuc2NhbGUodGhpcy5zY2FsaW5nKTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2xhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBieSB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9IHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICogSWYgX2xvY2FsIGlzIHRydWUsIHRyYW5zbGF0aW9uIG9jY3VycyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcm90YXRpb24gYW5kIHNjYWxpbmcgb2YgdGhpcyBtYXRyaXgsXHJcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIHBhcmVudCBvdGhlcndpc2UuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlKF9ieTogVmVjdG9yMywgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBpZiAoX2xvY2FsKSB7XHJcbiAgICAgICAgbGV0IG10eFRyYW5zbGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuVFJBTlNMQVRJT04oX2J5KTtcclxuICAgICAgICB0aGlzLm11bHRpcGx5KG10eFRyYW5zbGF0aW9uKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhUcmFuc2xhdGlvbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEyXSArPSBfYnkueDtcclxuICAgICAgICB0aGlzLmRhdGFbMTNdICs9IF9ieS55O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxNF0gKz0gX2J5Lno7XHJcbiAgICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgICAgUmVjeWNsZXIuc3RvcmUodGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uKTtcclxuICAgICAgICB0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24gPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXg0eDQuVFJBTlNMQVRJT04oX2J5KSk7XHJcbiAgICAgIC8vIC8vIFRPRE86IHBvc3NpYmxlIG9wdGltaXphdGlvbiwgdHJhbnNsYXRpb24gbWF5IGFsdGVyIG11dGF0b3IgaW5zdGVhZCBvZiBkZWxldGluZyBpdC5cclxuICAgICAgLy8gdGhpcy5zZXQobWF0cml4KTtcclxuICAgICAgLy8gUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB4LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVgoX3g6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlgoX3gpO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVZKF95OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5ZKF95KTtcclxuICAgICAgdGhpcy50cmFuc2xhdGUodHJhbnNsYXRpb24sIF9sb2NhbCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWihfejogbnVtYmVyLCBfbG9jYWw6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWihfeik7XHJcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2NhbGluZ1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGJ5IHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yM30gdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfYnk6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcywgTWF0cml4NHg0LlNDQUxJTkcoX2J5KSk7XHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzY2FsaW5nIGFsb25nIHRoZSB4LWF4aXMgYnkgdGhlIGdpdmVuIGFtb3VudCB0byB0aGlzIG1hdHJpeCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWChfYnk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9ieSwgMSwgMSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NhbGluZyBhbG9uZyB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlbiBhbW91bnQgdG8gdGhpcyBtYXRyaXggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldCgxLCBfYnksIDEpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHNjYWxpbmcgYWxvbmcgdGhlIHotYXhpcyBieSB0aGUgZ2l2ZW4gYW1vdW50IHRvIHRoaXMgbWF0cml4IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVaKF9ieTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMSwgMSwgX2J5KTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZm9ybWF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGx5IHRoaXMgbWF0cml4IHdpdGggdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbXVsdGlwbHkoX21hdHJpeDogTWF0cml4NHg0LCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IF9mcm9tTGVmdCA/IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTihfbWF0cml4LCB0aGlzKSA6IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLCBfbWF0cml4KTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBldWxlci1hbmdsZXMgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgYnkgUmVjeWNsZXIuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEV1bGVyQW5nbGVzKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuXHJcbiAgICAgIGxldCBzMDogbnVtYmVyID0gdGhpcy5kYXRhWzBdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczE6IG51bWJlciA9IHRoaXMuZGF0YVsxXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHMyOiBudW1iZXIgPSB0aGlzLmRhdGFbMl0gLyBzY2FsaW5nLng7XHJcbiAgICAgIGxldCBzNjogbnVtYmVyID0gdGhpcy5kYXRhWzZdIC8gc2NhbGluZy55O1xyXG4gICAgICBsZXQgczEwOiBudW1iZXIgPSB0aGlzLmRhdGFbMTBdIC8gc2NhbGluZy56O1xyXG5cclxuICAgICAgbGV0IHN5OiBudW1iZXIgPSBNYXRoLmh5cG90KHMwLCBzMSk7IC8vIHByb2JhYmx5IDIuIHBhcmFtIHNob3VsZCBiZSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnlcclxuXHJcbiAgICAgIGxldCBzaW5ndWxhcjogYm9vbGVhbiA9IHN5IDwgMWUtNjsgLy8gSWZcclxuXHJcbiAgICAgIGxldCB4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB6MTogbnVtYmVyO1xyXG4gICAgICBsZXQgeDI6IG51bWJlciwgeTI6IG51bWJlciwgejI6IG51bWJlcjtcclxuXHJcbiAgICAgIGlmICghc2luZ3VsYXIpIHtcclxuICAgICAgICB4MSA9IE1hdGguYXRhbjIoczYsIHMxMCk7XHJcbiAgICAgICAgeTEgPSBNYXRoLmF0YW4yKC1zMiwgc3kpO1xyXG4gICAgICAgIHoxID0gTWF0aC5hdGFuMihzMSwgczApO1xyXG5cclxuICAgICAgICB4MiA9IE1hdGguYXRhbjIoLXM2LCAtczEwKTtcclxuICAgICAgICB5MiA9IE1hdGguYXRhbjIoLXMyLCAtc3kpO1xyXG4gICAgICAgIHoyID0gTWF0aC5hdGFuMigtczEsIC1zMCk7XHJcblxyXG4gICAgICAgIGlmIChNYXRoLmFicyh4MikgKyBNYXRoLmFicyh5MikgKyBNYXRoLmFicyh6MikgPCBNYXRoLmFicyh4MSkgKyBNYXRoLmFicyh5MSkgKyBNYXRoLmFicyh6MSkpIHtcclxuICAgICAgICAgIHgxID0geDI7XHJcbiAgICAgICAgICB5MSA9IHkyO1xyXG4gICAgICAgICAgejEgPSB6MjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgeDEgPSBNYXRoLmF0YW4yKC10aGlzLmRhdGFbOV0gLyBzY2FsaW5nLnosIHRoaXMuZGF0YVs1XSAvIHNjYWxpbmcueSk7XHJcbiAgICAgICAgeTEgPSBNYXRoLmF0YW4yKC10aGlzLmRhdGFbMl0gLyBzY2FsaW5nLngsIHN5KTtcclxuICAgICAgICB6MSA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGxldCByb3RhdGlvbjogVmVjdG9yMyA9IFJlY3ljbGVyLmJvcnJvdyhWZWN0b3IzKTtcclxuICAgICAgdGhpcy4jZXVsZXJBbmdsZXMuc2V0KHgxLCB5MSwgejEpO1xyXG4gICAgICB0aGlzLiNldWxlckFuZ2xlcy5zY2FsZSgxODAgLyBNYXRoLlBJKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNldWxlckFuZ2xlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF9tdHhUbzogTWF0cml4NHg0IHwgRmxvYXQzMkFycmF5KTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXR4VG8gaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpXHJcbiAgICAgICAgdGhpcy5kYXRhLnNldChfbXR4VG8pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5kYXRhLnNldChfbXR4VG8uZGF0YSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYMaSLk1hdHJpeDR4NCh0cmFuc2xhdGlvbjogJHt0aGlzLnRyYW5zbGF0aW9uLnRvU3RyaW5nKCl9LCByb3RhdGlvbjogJHt0aGlzLnJvdGF0aW9uLnRvU3RyaW5nKCl9LCBzY2FsaW5nOiAke3RoaXMuc2NhbGluZy50b1N0cmluZygpfWA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IGFzIGEgRmxvYXQzMkFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBjYXJkaW5hbCB4LWF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFgoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHJlc3VsdC5zZXQodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBjYXJkaW5hbCB5LWF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFkoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHJlc3VsdC5zZXQodGhpcy5kYXRhWzRdLCB0aGlzLmRhdGFbNV0sIHRoaXMuZGF0YVs2XSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBjYXJkaW5hbCB6LWF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFooKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHJlc3VsdC5zZXQodGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFhZKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGVtcDogbnVtYmVyW10gPSBbdGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXV07IC8vIHN0b3JlIHgtYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdXSwgMCk7IC8vIG92ZXJ3cml0ZSB4LWF4aXMgd2l0aCB5LWF4aXNcclxuICAgICAgdGhpcy5kYXRhLnNldCh0ZW1wLCA0KTsgLy8gb3ZlcndyaXRlIFkgd2l0aCB0ZW1wXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoWy10aGlzLmRhdGFbOF0sIC10aGlzLmRhdGFbOV0sIC10aGlzLmRhdGFbMTBdXSwgOCk7IC8vIHJldmVyc2Ugei1heGlzXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3YXBzIHRoZSB0d28gY2FyZGluYWwgYXhpcyBhbmQgcmV2ZXJzZXMgdGhlIHRoaXJkLCBlZmZlY3RpdmVseSByb3RhdGluZyB0aGUgdHJhbnNmb3JtIDE4MCBkZWdyZWVzIGFyb3VuZCBvbmUgYW5kIDkwIGRlZ3JlZXMgYXJvdW5kIGEgc2Vjb25kIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN3YXBYWigpOiB2b2lkIHtcclxuICAgICAgbGV0IHRlbXA6IG51bWJlcltdID0gW3RoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl1dOyAvLyBzdG9yZSB4LWF4aXNcclxuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF1dLCAwKTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHotYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDgpOyAvLyBvdmVyd3JpdGUgWiB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVs0XSwgLXRoaXMuZGF0YVs1XSwgLXRoaXMuZGF0YVs2XV0sIDQpOyAvLyByZXZlcnNlIHktYXhpc1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwcyB0aGUgdHdvIGNhcmRpbmFsIGF4aXMgYW5kIHJldmVyc2VzIHRoZSB0aGlyZCwgZWZmZWN0aXZlbHkgcm90YXRpbmcgdGhlIHRyYW5zZm9ybSAxODAgZGVncmVlcyBhcm91bmQgb25lIGFuZCA5MCBkZWdyZWVzIGFyb3VuZCBhIHNlY29uZCBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzd2FwWVooKTogdm9pZCB7XHJcbiAgICAgIGxldCB0ZW1wOiBudW1iZXJbXSA9IFt0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdXTsgLy8gc3RvcmUgeS1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMuZGF0YVs4XSwgdGhpcy5kYXRhWzldLCB0aGlzLmRhdGFbMTBdXSwgNCk7IC8vIG92ZXJ3cml0ZSB5LWF4aXMgd2l0aCB6LWF4aXNcclxuICAgICAgdGhpcy5kYXRhLnNldCh0ZW1wLCA4KTsgLy8gb3ZlcndyaXRlIFogd2l0aCB0ZW1wXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoWy10aGlzLmRhdGFbMF0sIC10aGlzLmRhdGFbMV0sIC10aGlzLmRhdGFbMl1dLCAwKTsgLy8gcmV2ZXJzZSB4LWF4aXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRyYW5sYXRpb24gZnJvbSB0aGlzIG1hdHJpeCB0byB0aGUgdGFyZ2V0IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VHJhbnNsYXRpb25UbyhfbXR4VGFyZ2V0OiBNYXRyaXg0eDQpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGRpZmZlcmVuY2Uuc2V0KF9tdHhUYXJnZXQuZGF0YVsxMl0gLSB0aGlzLmRhdGFbMTJdLCBfbXR4VGFyZ2V0LmRhdGFbMTNdIC0gdGhpcy5kYXRhWzEzXSwgX210eFRhcmdldC5kYXRhWzE0XSAtIHRoaXMuZGF0YVsxNF0pO1xyXG4gICAgICByZXR1cm4gZGlmZmVyZW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAvLyB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uc2VyaWFsaXplKCksXHJcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24uc2VyaWFsaXplKCksXHJcbiAgICAgICAgc2NhbGluZzogdGhpcy5zY2FsaW5nLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IGF3YWl0IHRoaXMudHJhbnNsYXRpb24uZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24udHJhbnNsYXRpb24pLFxyXG4gICAgICAgIHJvdGF0aW9uOiBhd2FpdCB0aGlzLnJvdGF0aW9uLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnJvdGF0aW9uKSxcclxuICAgICAgICBzY2FsaW5nOiBhd2FpdCB0aGlzLnNjYWxpbmcuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uc2NhbGluZylcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5tdXRhdGUobXV0YXRvcik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBpZiAodGhpcy5tdXRhdG9yKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0b3I7XHJcblxyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5nZXRNdXRhdG9yKCksXHJcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5nZXRNdXRhdG9yKClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNhY2hlIG11dGF0b3JcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbXV0YXRvcjtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgb2xkVHJhbnNsYXRpb246IFZlY3RvcjMgPSB0aGlzLnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgb2xkUm90YXRpb246IFZlY3RvcjMgPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICBsZXQgb2xkU2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuICAgICAgbGV0IG5ld1RyYW5zbGF0aW9uOiBWZWN0b3IzID0gPFZlY3RvcjM+X211dGF0b3JbXCJ0cmFuc2xhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1JvdGF0aW9uOiBWZWN0b3IzID0gPFZlY3RvcjM+X211dGF0b3JbXCJyb3RhdGlvblwiXTtcclxuICAgICAgbGV0IG5ld1NjYWxpbmc6IFZlY3RvcjMgPSA8VmVjdG9yMz5fbXV0YXRvcltcInNjYWxpbmdcIl07XHJcbiAgICAgIGxldCB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbiA9IHsgdHJhbnNsYXRpb246IG9sZFRyYW5zbGF0aW9uLCByb3RhdGlvbjogb2xkUm90YXRpb24sIHNjYWxpbmc6IG9sZFNjYWxpbmcgfTtcclxuICAgICAgaWYgKG5ld1RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy50cmFuc2xhdGlvbiA9IHZlY3RvcnMudHJhbnNsYXRpb24gfHwgdGhpcy4jdmVjdG9ycy50cmFuc2xhdGlvbjtcclxuICAgICAgICB2ZWN0b3JzLnRyYW5zbGF0aW9uLnNldChcclxuICAgICAgICAgIG5ld1RyYW5zbGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3VHJhbnNsYXRpb24ueCA6IG9sZFRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnkgOiBvbGRUcmFuc2xhdGlvbi55LFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueiAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi56IDogb2xkVHJhbnNsYXRpb24uelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1JvdGF0aW9uKSB7XHJcbiAgICAgICAgdmVjdG9ycy5yb3RhdGlvbiA9IHZlY3RvcnMucm90YXRpb24gfHwgdGhpcy4jdmVjdG9ycy5yb3RhdGlvbjtcclxuICAgICAgICB2ZWN0b3JzLnJvdGF0aW9uLnNldChcclxuICAgICAgICAgIG5ld1JvdGF0aW9uLnggIT0gdW5kZWZpbmVkID8gbmV3Um90YXRpb24ueCA6IG9sZFJvdGF0aW9uLngsXHJcbiAgICAgICAgICBuZXdSb3RhdGlvbi55ICE9IHVuZGVmaW5lZCA/IG5ld1JvdGF0aW9uLnkgOiBvbGRSb3RhdGlvbi55LFxyXG4gICAgICAgICAgbmV3Um90YXRpb24ueiAhPSB1bmRlZmluZWQgPyBuZXdSb3RhdGlvbi56IDogb2xkUm90YXRpb24uelxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1NjYWxpbmcpIHtcclxuICAgICAgICB2ZWN0b3JzLnNjYWxpbmcgPSB2ZWN0b3JzLnNjYWxpbmcgfHwgdGhpcy4jdmVjdG9ycy5zY2FsaW5nO1xyXG4gICAgICAgIHZlY3RvcnMuc2NhbGluZy5zZXQoXHJcbiAgICAgICAgICBuZXdTY2FsaW5nLnggIT0gdW5kZWZpbmVkID8gbmV3U2NhbGluZy54IDogb2xkU2NhbGluZy54LFxyXG4gICAgICAgICAgbmV3U2NhbGluZy55ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueSA6IG9sZFNjYWxpbmcueSxcclxuICAgICAgICAgIG5ld1NjYWxpbmcueiAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnogOiBvbGRTY2FsaW5nLnpcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUT0RPOiBwb3NzaWJsZSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gd2hlbiBvbmx5IG9uZSBvciB0d28gY29tcG9uZW50cyBjaGFuZ2UsIHRoZW4gdXNlIG9sZCBtYXRyaXggaW5zdGVhZCBvZiBJREVOVElUWSBhbmQgdHJhbnNmb3JtIGJ5IGRpZmZlcmVuY2VzL3F1b3RpZW50c1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgaWYgKHZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgbXR4UmVzdWx0LnRyYW5zbGF0ZSh2ZWN0b3JzLnRyYW5zbGF0aW9uKTtcclxuICAgICAgaWYgKHZlY3RvcnMucm90YXRpb24pIHtcclxuICAgICAgICAvLyBtdHhSZXN1bHQucm90YXRlWih2ZWN0b3JzLnJvdGF0aW9uLnopO1xyXG4gICAgICAgIC8vIG10eFJlc3VsdC5yb3RhdGVZKHZlY3RvcnMucm90YXRpb24ueSk7XHJcbiAgICAgICAgLy8gbXR4UmVzdWx0LnJvdGF0ZVgodmVjdG9ycy5yb3RhdGlvbi54KTtcclxuICAgICAgICBtdHhSZXN1bHQucm90YXRlKHZlY3RvcnMucm90YXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgbXR4UmVzdWx0LnNjYWxlKHZlY3RvcnMuc2NhbGluZyk7XHJcblxyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQpO1xyXG4gICAgICB0aGlzLnZlY3RvcnMgPSB2ZWN0b3JzO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnRyYW5zbGF0aW9uKSB0eXBlcy50cmFuc2xhdGlvbiA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24pIHR5cGVzLnJvdGF0aW9uID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHsgdHJhbnNsYXRpb246IG51bGwsIHJvdGF0aW9uOiBudWxsLCBzY2FsaW5nOiBudWxsIH07XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vI2VuZHJlZ2lvblxyXG59XHJcbiIsIi8qKlxyXG4gKiBCYXNlY2xhc3MgZm9yIE5vaXNlMiwgTm9pc2UzIGFuZCBOb2lzZTRcclxuICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICogVGhpcyBpcyBhbiBhZGFwdGlvbiBvZiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mYXN0LXNpbXBsZXgtbm9pc2VcclxuICovXHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY2xhc3MgTm9pc2Uge1xyXG4gICAgcHJvdGVjdGVkIHBlcm06IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg1MTIpO1xyXG4gICAgcHJvdGVjdGVkIHBlcm1Nb2QxMjogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDUxMik7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xyXG4gICAgICBjb25zdCBwOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IDI1NjsgaSsrKVxyXG4gICAgICAgIHBbaV0gPSBpO1xyXG5cclxuICAgICAgbGV0IG46IG51bWJlcjtcclxuICAgICAgbGV0IHE6IG51bWJlcjtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMjU1OyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgbiA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIF9yYW5kb20oKSk7XHJcbiAgICAgICAgcSA9IHBbaV07XHJcbiAgICAgICAgcFtpXSA9IHBbbl07XHJcbiAgICAgICAgcFtuXSA9IHE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCA1MTI7IGkrKykge1xyXG4gICAgICAgIHRoaXMucGVybVtpXSA9IHBbaSAmIDI1NV07XHJcbiAgICAgICAgdGhpcy5wZXJtTW9kMTJbaV0gPSB0aGlzLnBlcm1baV0gJSAxMjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4vTm9pc2UudHNcIi8+XHJcbi8qKlxyXG4gKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxyXG4gKiBkb25lIGJ5IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAqXHJcbiAqIEJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cclxuICogT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXHJcbiAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXHJcbiAqXHJcbiAqIFRoaXMgY29kZSB3YXMgcGxhY2VkIGluIHRoZSBwdWJsaWMgZG9tYWluIGJ5IGl0cyBvcmlnaW5hbCBhdXRob3IsXHJcbiAqIFN0ZWZhbiBHdXN0YXZzb24uIFlvdSBtYXkgdXNlIGl0IGFzIHlvdSBzZWUgZml0LCBidXRcclxuICogYXR0cmlidXRpb24gaXMgYXBwcmVjaWF0ZWQuXHJcbiAqL1xyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNsYXNzIE5vaXNlMiBleHRlbmRzIE5vaXNlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIG9mZnNldDogbnVtYmVyID0gKDMuMCAtIE1hdGguc3FydCgzLjApKSAvIDYuMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyYWRpZW50OiBudW1iZXJbXVtdID0gW1sxLCAxXSwgWy0xLCAxXSwgWzEsIC0xXSwgWy0xLCAtMV0sIFsxLCAwXSwgWy0xLCAwXSwgWzEsIDBdLCBbLTEsIDBdLCBbMCwgMV0sIFswLCAtMV0sIFswLCAxXSwgWzAsIC0xXV07XHJcbiAgICAjc2FtcGxlOiAoX3g6IG51bWJlciwgX3k6IG51bWJlcikgPT4gbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XHJcbiAgICAgIHN1cGVyKF9yYW5kb20pO1xyXG5cclxuICAgICAgdGhpcy4jc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIpID0+IHtcclxuICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXHJcbiAgICAgICAgY29uc3QgczogbnVtYmVyID0gKF94ICsgX3kpICogMC41ICogKE1hdGguc3FydCgzLjApIC0gMS4wKTsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxyXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoX3ggKyBzKTtcclxuICAgICAgICBjb25zdCBqOiBudW1iZXIgPSBNYXRoLmZsb29yKF95ICsgcyk7XHJcbiAgICAgICAgY29uc3QgdDogbnVtYmVyID0gKGkgKyBqKSAqIE5vaXNlMi5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgWDA6IG51bWJlciA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2VcclxuICAgICAgICBjb25zdCBZMDogbnVtYmVyID0gaiAtIHQ7XHJcbiAgICAgICAgY29uc3QgeDA6IG51bWJlciA9IF94IC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXHJcbiAgICAgICAgY29uc3QgeTA6IG51bWJlciA9IF95IC0gWTA7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cclxuICAgICAgICBjb25zdCBpMTogbnVtYmVyID0geDAgPiB5MCA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGoxOiBudW1iZXIgPSB4MCA+IHkwID8gMCA6IDE7XHJcblxyXG4gICAgICAgIC8vIE9mZnNldDpudW1iZXJzIGZvciBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgeDE6IG51bWJlciA9IHgwIC0gaTEgKyBOb2lzZTIub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2UyLm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MjogbnVtYmVyID0geDAgLSAxLjAgKyAyLjAgKiBOb2lzZTIub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHkyOiBudW1iZXIgPSB5MCAtIDEuMCArIDIuMCAqIE5vaXNlMi5vZmZzZXQ7XHJcblxyXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgaWk6IG51bWJlciA9IGkgJiAyNTU7XHJcbiAgICAgICAgY29uc3Qgamo6IG51bWJlciA9IGogJiAyNTU7XHJcbiAgICAgICAgY29uc3QgZzA6IG51bWJlcltdID0gTm9pc2UyLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgdGhpcy5wZXJtW2pqXV1dO1xyXG4gICAgICAgIGNvbnN0IGcxOiBudW1iZXJbXSA9IE5vaXNlMi5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIGkxICsgdGhpcy5wZXJtW2pqICsgajFdXV07XHJcbiAgICAgICAgY29uc3QgZzI6IG51bWJlcltdID0gTm9pc2UyLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgMSArIHRoaXMucGVybVtqaiArIDFdXV07XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcclxuICAgICAgICBjb25zdCB0MDogbnVtYmVyID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XHJcbiAgICAgICAgY29uc3QgbjA6IG51bWJlciA9IHQwIDwgMCA/IDAuMCA6IE1hdGgucG93KHQwLCA0KSAqIChnMFswXSAqIHgwICsgZzBbMV0gKiB5MCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MTtcclxuICAgICAgICBjb25zdCBuMTogbnVtYmVyID0gdDEgPCAwID8gMC4wIDogTWF0aC5wb3codDEsIDQpICogKGcxWzBdICogeDEgKyBnMVsxXSAqIHkxKTtcclxuXHJcbiAgICAgICAgY29uc3QgdDI6IG51bWJlciA9IDAuNSAtIHgyICogeDIgLSB5MiAqIHkyO1xyXG4gICAgICAgIGNvbnN0IG4yOiBudW1iZXIgPSB0MiA8IDAgPyAwLjAgOiBNYXRoLnBvdyh0MiwgNCkgKiAoZzJbMF0gKiB4MiArIGcyWzFdICogeTIpO1xyXG5cclxuICAgICAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXHJcbiAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLCAxXVxyXG4gICAgICAgIHJldHVybiA3MC4xNDgwNTc3MDY1Mzk1MiAqIChuMCArIG4xICsgbjIpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzYW1wbGUgPSAoX3g6IG51bWJlciwgX3k6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzYW1wbGUoX3gsIF95KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvKipcclxuICogVGhpcyBpcyBhbiBhZGFwdGlvbiBvZiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mYXN0LXNpbXBsZXgtbm9pc2VcclxuICogZG9uZSBieSBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gKlxyXG4gKiBCYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXHJcbiAqIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxyXG4gKiBCZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxyXG4gKlxyXG4gKiBUaGlzIGNvZGUgd2FzIHBsYWNlZCBpbiB0aGUgcHVibGljIGRvbWFpbiBieSBpdHMgb3JpZ2luYWwgYXV0aG9yLFxyXG4gKiBTdGVmYW4gR3VzdGF2c29uLiBZb3UgbWF5IHVzZSBpdCBhcyB5b3Ugc2VlIGZpdCwgYnV0XHJcbiAqIGF0dHJpYnV0aW9uIGlzIGFwcHJlY2lhdGVkLlxyXG4gKi9cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvLyBUT0RPOiBUZXN0XHJcbiAgZXhwb3J0IGNsYXNzIE5vaXNlMyBleHRlbmRzIE5vaXNlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIG9mZnNldDogbnVtYmVyID0gMS4wIC8gNi4wO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JhZGllbnQ6IG51bWJlcltdW10gPSBbWzEsIDEsIDBdLCBbLTEsIDEsIDBdLCBbMSwgLTEsIDBdLCBbLTEsIC0xLCAwXSwgWzEsIDAsIDFdLCBbLTEsIDAsIDFdLCBbMSwgMCwgLTFdLCBbLTEsIDAsIC0xXSwgWzAsIDEsIDFdLCBbMCwgLTEsIC0xXSwgWzAsIDEsIC0xXSwgWzAsIC0xLCAtMV1cclxuICAgIF07XHJcbiAgICAjc2FtcGxlOiAoX3g6IG51bWJlciwgX3k6IG51bWJlciwgX3o6IG51bWJlcikgPT4gbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XHJcbiAgICAgIHN1cGVyKF9yYW5kb20pO1xyXG5cclxuICAgICAgdGhpcy4jc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIpID0+IHtcclxuICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXHJcbiAgICAgICAgY29uc3QgczogbnVtYmVyID0gKF94ICsgX3kgKyBfeikgLyAzLjA7IC8vIFZlcnkgbmljZSBhbmQgc2ltcGxlIHNrZXcgZmFjdG9yIGZvciAzRFxyXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoX3ggKyBzKTtcclxuICAgICAgICBjb25zdCBqOiBudW1iZXIgPSBNYXRoLmZsb29yKF95ICsgcyk7XHJcbiAgICAgICAgY29uc3QgazogbnVtYmVyID0gTWF0aC5mbG9vcihfeiArIHMpO1xyXG4gICAgICAgIGNvbnN0IHQ6IG51bWJlciA9IChpICsgaiArIGspICogTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCBYMDogbnVtYmVyID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5LHopIHNwYWNlXHJcbiAgICAgICAgY29uc3QgWTA6IG51bWJlciA9IGogLSB0O1xyXG4gICAgICAgIGNvbnN0IFowOiBudW1iZXIgPSBrIC0gdDtcclxuICAgICAgICBjb25zdCB4MDogbnVtYmVyID0gX3ggLSBYMDsgLy8gVGhlIHgseSx6IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxyXG4gICAgICAgIGNvbnN0IHkwOiBudW1iZXIgPSBfeSAtIFkwO1xyXG4gICAgICAgIGNvbnN0IHowOiBudW1iZXIgPSBfeiAtIFowO1xyXG5cclxuICAgICAgICAvLyBEZXRlcmluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpblxyXG4gICAgICAgIGxldCBpMTogbnVtYmVyLCBqMTogbnVtYmVyLCBrMTogbnVtYmVyIC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xyXG4gICAgICAgICAgO1xyXG4gICAgICAgIGxldCBpMjogbnVtYmVyLCBqMjogbnVtYmVyLCBrMjogbnVtYmVyIC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXHJcbiAgICAgICAgICA7XHJcbiAgICAgICAgaWYgKHgwID49IHkwKSB7XHJcbiAgICAgICAgICBpZiAoeTAgPj0gejApIHtcclxuICAgICAgICAgICAgaTEgPSBpMiA9IGoyID0gMTtcclxuICAgICAgICAgICAgajEgPSBrMSA9IGsyID0gMDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoeDAgPj0gejApIHtcclxuICAgICAgICAgICAgaTEgPSBpMiA9IGsyID0gMTtcclxuICAgICAgICAgICAgajEgPSBrMSA9IGoyID0gMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGsxID0gaTIgPSBrMiA9IDE7XHJcbiAgICAgICAgICAgIGkxID0gajEgPSBqMiA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICh5MCA8IHowKSB7XHJcbiAgICAgICAgICAgIGsxID0gajIgPSBrMiA9IDE7XHJcbiAgICAgICAgICAgIGkxID0gajEgPSBpMiA9IDA7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHgwIDwgejApIHtcclxuICAgICAgICAgICAgajEgPSBqMiA9IGsyID0gMTtcclxuICAgICAgICAgICAgaTEgPSBrMSA9IGkyID0gMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGoxID0gaTIgPSBqMiA9IDE7XHJcbiAgICAgICAgICAgIGkxID0gazEgPSBrMiA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB4MTogbnVtYmVyID0geDAgLSBpMSArIE5vaXNlMy5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MTogbnVtYmVyID0geTAgLSBqMSArIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejE6IG51bWJlciA9IHowIC0gazEgKyBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHgyOiBudW1iZXIgPSB4MCAtIGkyICsgMi4wICogTm9pc2UzLm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTI6IG51bWJlciA9IHkwIC0gajIgKyAyLjAgKiBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHoyOiBudW1iZXIgPSB6MCAtIGsyICsgMi4wICogTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MzogbnVtYmVyID0geDAgLSAxLjAgKyAzLjAgKiBOb2lzZTMub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkzOiBudW1iZXIgPSB5MCAtIDEuMCArIDMuMCAqIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejM6IG51bWJlciA9IHowIC0gMS4wICsgMy4wICogTm9pc2UzLm9mZnNldDtcclxuXHJcbiAgICAgICAgLy8gV29yayA6bnVtYmVydXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IGlpOiBudW1iZXIgPSBpICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGpqOiBudW1iZXIgPSBqICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGtrOiBudW1iZXIgPSBrICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIHRoaXMucGVybVtqaiArIHRoaXMucGVybVtra11dXV07XHJcbiAgICAgICAgY29uc3QgZzE6IG51bWJlcltdID0gTm9pc2UzLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgaTEgKyB0aGlzLnBlcm1bamogKyBqMSArIHRoaXMucGVybVtrayArIGsxXV1dXTtcclxuICAgICAgICBjb25zdCBnMjogbnVtYmVyW10gPSBOb2lzZTMuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyBpMiArIHRoaXMucGVybVtqaiArIGoyICsgdGhpcy5wZXJtW2trICsgazJdXV1dO1xyXG4gICAgICAgIGNvbnN0IGczOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIDEgKyB0aGlzLnBlcm1bamogKyAxICsgdGhpcy5wZXJtW2trICsgMV1dXV07XHJcblxyXG4gICAgICAgIC8vIENhbGN1Om51bWJlcmF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIGZvdXIgY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IHQwOiBudW1iZXIgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XHJcbiAgICAgICAgY29uc3QgbjA6IG51bWJlciA9IHQwIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDAsIDQpICogKGcwWzBdICogeDAgKyBnMFsxXSAqIHkwICsgZzBbMl0gKiB6MCk7XHJcbiAgICAgICAgY29uc3QgdDE6IG51bWJlciA9IDAuNSAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcclxuICAgICAgICBjb25zdCBuMTogbnVtYmVyID0gdDEgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MSwgNCkgKiAoZzFbMF0gKiB4MSArIGcxWzFdICogeTEgKyBnMVsyXSAqIHoxKTtcclxuICAgICAgICBjb25zdCB0MjogbnVtYmVyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xyXG4gICAgICAgIGNvbnN0IG4yOiBudW1iZXIgPSB0MiA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQyLCA0KSAqIChnMlswXSAqIHgyICsgZzJbMV0gKiB5MiArIGcyWzJdICogejIpO1xyXG4gICAgICAgIGNvbnN0IHQzOiBudW1iZXIgPSAwLjUgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XHJcbiAgICAgICAgY29uc3QgbjM6IG51bWJlciA9IHQzIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDMsIDQpICogKGczWzBdICogeDMgKyBnM1sxXSAqIHkzICsgZzNbMl0gKiB6Myk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cclxuICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byBzdGF5IGp1c3QgaW5zaWRlIFstMSwxXVxyXG4gICAgICAgIHJldHVybiA5NC42ODQ5MzE1MDY4MTk3MiAqIChuMCArIG4xICsgbjIgKyBuMyk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NhbXBsZShfeCwgX3ksIF96KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvKipcclxuICogVGhpcyBpcyBhbiBhZGFwdGlvbiBvZiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mYXN0LXNpbXBsZXgtbm9pc2VcclxuICogZG9uZSBieSBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gKlxyXG4gKiBCYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXHJcbiAqIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxyXG4gKiBCZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxyXG4gKlxyXG4gKiBUaGlzIGNvZGUgd2FzIHBsYWNlZCBpbiB0aGUgcHVibGljIGRvbWFpbiBieSBpdHMgb3JpZ2luYWwgYXV0aG9yLFxyXG4gKiBTdGVmYW4gR3VzdGF2c29uLiBZb3UgbWF5IHVzZSBpdCBhcyB5b3Ugc2VlIGZpdCwgYnV0XHJcbiAqIGF0dHJpYnV0aW9uIGlzIGFwcHJlY2lhdGVkLlxyXG4gKi9cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8vIFRPRE86IFRlc3RcclxuICBleHBvcnQgY2xhc3MgTm9pc2U0IGV4dGVuZHMgTm9pc2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAoNS4wIC0gTWF0aC5zcXJ0KDUuMCkpIC8gMjAuMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyYWRpZW50OiBudW1iZXJbXVtdID0gW1swLCAxLCAxLCAxXSwgWzAsIDEsIDEsIC0xXSwgWzAsIDEsIC0xLCAxXSwgWzAsIDEsIC0xLCAtMV0sIFswLCAtMSwgMSwgMV0sIFswLCAtMSwgMSwgLTFdLCBbMCwgLTEsIC0xLCAxXSwgWzAsIC0xLCAtMSwgLTFdLCBbMSwgMCwgMSwgMV0sIFsxLCAwLCAxLCAtMV0sIFsxLCAwLCAtMSwgMV0sIFsxLCAwLCAtMSwgLTFdLCBbLTEsIDAsIDEsIDFdLCBbLTEsIDAsIDEsIC0xXSwgWy0xLCAwLCAtMSwgMV0sIFstMSwgMCwgLTEsIC0xXSwgWzEsIDEsIDAsIDFdLCBbMSwgMSwgMCwgLTFdLCBbMSwgLTEsIDAsIDFdLCBbMSwgLTEsIDAsIC0xXSwgWy0xLCAxLCAwLCAxXSwgWy0xLCAxLCAwLCAtMV0sIFstMSwgLTEsIDAsIDFdLCBbLTEsIC0xLCAwLCAtMV0sIFsxLCAxLCAxLCAwXSwgWzEsIDEsIC0xLCAwXSwgWzEsIC0xLCAxLCAwXSwgWzEsIC0xLCAtMSwgMF0sIFstMSwgMSwgMSwgMF0sIFstMSwgMSwgLTEsIDBdLCBbLTEsIC0xLCAxLCAwXSwgWy0xLCAtMSwgLTEsIDBdXTtcclxuICAgICNzYW1wbGU6IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKSA9PiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9yYW5kb206IEZ1bmN0aW9uID0gTWF0aC5yYW5kb20pIHtcclxuICAgICAgc3VwZXIoX3JhbmRvbSlcclxuXHJcbiAgICAgIHRoaXMuI3NhbXBsZSA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyLCB3OiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIC8vIFNrZXcgdGhlICh4LHkseix3KSBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggY2VsbCBvZiAyNCBzaW1wbGljZXMgd2UncmUgaW5cclxuICAgICAgICBjb25zdCBzOiBudW1iZXIgPSAoeCArIHkgKyB6ICsgdykgKiAoTWF0aC5zcXJ0KDUuMCkgLSAxLjApIC8gNC4wOyAvLyBGYWN0b3IgZm9yIDREIHNrZXdpbmdcclxuICAgICAgICBjb25zdCBpOiBudW1iZXIgPSBNYXRoLmZsb29yKHggKyBzKTtcclxuICAgICAgICBjb25zdCBqOiBudW1iZXIgPSBNYXRoLmZsb29yKHkgKyBzKTtcclxuICAgICAgICBjb25zdCBrOiBudW1iZXIgPSBNYXRoLmZsb29yKHogKyBzKTtcclxuICAgICAgICBjb25zdCBsOiBudW1iZXIgPSBNYXRoLmZsb29yKHcgKyBzKTtcclxuICAgICAgICBjb25zdCB0OiBudW1iZXIgPSAoaSArIGogKyBrICsgbCkgKiBOb2lzZTQub2Zmc2V0OyAvLyBGYWN0b3IgZm9yIDREIHVuc2tld2luZ1xyXG4gICAgICAgIGNvbnN0IFgwOiBudW1iZXIgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseix3KSBzcGFjZVxyXG4gICAgICAgIGNvbnN0IFkwOiBudW1iZXIgPSBqIC0gdDtcclxuICAgICAgICBjb25zdCBaMDogbnVtYmVyID0gayAtIHQ7XHJcbiAgICAgICAgY29uc3QgVzA6IG51bWJlciA9IGwgLSB0O1xyXG4gICAgICAgIGNvbnN0IHgwOiBudW1iZXIgPSB4IC0gWDA7IC8vIFRoZSB4LHkseix3IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxyXG4gICAgICAgIGNvbnN0IHkwOiBudW1iZXIgPSB5IC0gWTA7XHJcbiAgICAgICAgY29uc3QgejA6IG51bWJlciA9IHogLSBaMDtcclxuICAgICAgICBjb25zdCB3MDogbnVtYmVyID0gdyAtIFcwO1xyXG5cclxuICAgICAgICAvLyBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3JlIGluLCB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGVcclxuICAgICAgICAvLyBtYWduaXR1ZGUgb3JkZXJpbmcgb2YgeDAsIHkwLCB6MCBhbmQgdzAuIFNpeCBwYWlyLXdpc2UgY29tcGFyaXNvbnMgYXJlIHBlcmZvcm1lZCBiZXR3ZWVuXHJcbiAgICAgICAgLy8gZWFjaCBwb3NzaWJsZSBwYWlyIG9mIHRoZSBmb3VyIGNvb3JkaW5hdGVzLCBhbmQgdGhlIHJlc3VsdHMgYXJlIHVzZWQgdG8gcmFuayB0aGUgbnVtYmVycy5cclxuICAgICAgICBsZXQgcmFua3g6IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IHJhbmt5OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCByYW5rejogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgcmFua3c6IG51bWJlciA9IDA7XHJcbiAgICAgICAgaWYgKHgwID4geTApIHJhbmt4Kys7XHJcbiAgICAgICAgZWxzZSByYW5reSsrO1xyXG4gICAgICAgIGlmICh4MCA+IHowKSByYW5reCsrO1xyXG4gICAgICAgIGVsc2UgcmFua3orKztcclxuICAgICAgICBpZiAoeDAgPiB3MCkgcmFua3grKztcclxuICAgICAgICBlbHNlIHJhbmt3Kys7XHJcbiAgICAgICAgaWYgKHkwID4gejApIHJhbmt5Kys7XHJcbiAgICAgICAgZWxzZSByYW5reisrO1xyXG4gICAgICAgIGlmICh5MCA+IHcwKSByYW5reSsrO1xyXG4gICAgICAgIGVsc2UgcmFua3crKztcclxuICAgICAgICBpZiAoejAgPiB3MCkgcmFua3orKztcclxuICAgICAgICBlbHNlIHJhbmt3Kys7XHJcblxyXG4gICAgICAgIC8vIHNpbXBsZXhbY10gaXMgYSA0LXZlY3RvciB3aXRoIHRoZSBudW1iZXJzIDAsIDEsIDIgYW5kIDMgaW4gc29tZSBvcmRlci5cclxuICAgICAgICAvLyBNYW55IHZhbHVlcyBvZiBjIHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno+dyBtYWtlcyB4PHosIHk8dyBhbmQgeDx3XHJcbiAgICAgICAgLy8gaW1wb3NzaWJsZS4gT25seSB0aGUgMjQgaW5kaWNlcyB3aGljaCBoYXZlIG5vbi16ZXJvIGVudHJpZXMgbWFrZSBhbnkgc2Vuc2UuXHJcbiAgICAgICAgLy8gV2UgdXNlIGEgdGhyZXNob2xkaW5nIHRvIHNldCB0aGUgY29vcmRpbmF0ZXMgaW4gdHVybiBmcm9tIHRoZSBsYXJnZXN0IG1hZ25pdHVkZS5cclxuICAgICAgICAvLyBSYW5rIDMgZGVub3RlcyB0aGUgbGFyZ2VzdCBjb29yZGluYXRlLlxyXG4gICAgICAgIGNvbnN0IGkxOiBudW1iZXIgPSByYW5reCA+PSAzID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgajE6IG51bWJlciA9IHJhbmt5ID49IDMgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBrMTogbnVtYmVyID0gcmFua3ogPj0gMyA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGwxOiBudW1iZXIgPSByYW5rdyA+PSAzID8gMSA6IDA7XHJcbiAgICAgICAgLy8gUmFuayA6IDIgZGVub3RlcyB0aGUgc2Vjb25kIGxhcmdlc3QgY29vcmRpbmF0ZS5cclxuICAgICAgICBjb25zdCBpMjogbnVtYmVyID0gcmFua3ggPj0gMiA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGoyOiBudW1iZXIgPSByYW5reSA+PSAyID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgazI6IG51bWJlciA9IHJhbmt6ID49IDIgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBsMjogbnVtYmVyID0gcmFua3cgPj0gMiA/IDEgOiAwO1xyXG4gICAgICAgIC8vIFJhbmsgOiAxIGRlbm90ZXMgdGhlIHNlY29uZCBzbWFsbGVzdCBjb29yZGluYXRlLlxyXG4gICAgICAgIGNvbnN0IGkzOiBudW1iZXIgPSByYW5reCA+PSAxID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgajM6IG51bWJlciA9IHJhbmt5ID49IDEgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBrMzogbnVtYmVyID0gcmFua3ogPj0gMSA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGwzOiBudW1iZXIgPSByYW5rdyA+PSAxID8gMSA6IDA7XHJcblxyXG4gICAgICAgIC8vIFRoZSBmaWZ0aCBjb3JuZXIgaGFzIGFsbCBjb29yZGluYXRlIG9mZnNldHMgPSAxLCBzbyBubyBuZWVkIHRvIGNvbXB1dGUgdGhhdC5cclxuICAgICAgICBjb25zdCB4MTogbnVtYmVyID0geDAgLSBpMSArIE5vaXNlNC5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MTogbnVtYmVyID0gejAgLSBrMSArIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdzE6IG51bWJlciA9IHcwIC0gbDEgKyBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHgyOiBudW1iZXIgPSB4MCAtIGkyICsgMi4wICogTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MjogbnVtYmVyID0geTAgLSBqMiArIDIuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejI6IG51bWJlciA9IHowIC0gazIgKyAyLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHcyOiBudW1iZXIgPSB3MCAtIGwyICsgMi4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MzogbnVtYmVyID0geDAgLSBpMyArIDMuMCAqIE5vaXNlNC5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIGZvdXJ0aCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkzOiBudW1iZXIgPSB5MCAtIGozICsgMy4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MzogbnVtYmVyID0gejAgLSBrMyArIDMuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdzM6IG51bWJlciA9IHcwIC0gbDMgKyAzLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHg0OiBudW1iZXIgPSB4MCAtIDEuMCArIDQuMCAqIE5vaXNlNC5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5NDogbnVtYmVyID0geTAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHo0OiBudW1iZXIgPSB6MCAtIDEuMCArIDQuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdzQ6IG51bWJlciA9IHcwIC0gMS4wICsgNC4wICogTm9pc2U0Lm9mZnNldDtcclxuXHJcbiAgICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmaXZlIHNpbXBsZXggY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IGlpOiBudW1iZXIgPSBpICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGpqOiBudW1iZXIgPSBqICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGtrOiBudW1iZXIgPSBrICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGxsOiBudW1iZXIgPSBsICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtpaSArIHRoaXMucGVybVtqaiArIHRoaXMucGVybVtrayArIHRoaXMucGVybVtsbF1dXV0gJVxyXG4gICAgICAgICAgMzJcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGcxOiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtcclxuICAgICAgICAgIGlpICsgaTEgKyB0aGlzLnBlcm1bamogKyBqMSArIHRoaXMucGVybVtrayArIGsxICsgdGhpcy5wZXJtW2xsICsgbDFdXV1cclxuICAgICAgICAgIF0gJSAzMlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3QgZzI6IG51bWJlcltdID0gTm9pc2U0LmdyYWRpZW50W1xyXG4gICAgICAgICAgdGhpcy5wZXJtW1xyXG4gICAgICAgICAgaWkgKyBpMiArIHRoaXMucGVybVtqaiArIGoyICsgdGhpcy5wZXJtW2trICsgazIgKyB0aGlzLnBlcm1bbGwgKyBsMl1dXVxyXG4gICAgICAgICAgXSAlIDMyXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBnMzogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXHJcbiAgICAgICAgICB0aGlzLnBlcm1bXHJcbiAgICAgICAgICBpaSArIGkzICsgdGhpcy5wZXJtW2pqICsgajMgKyB0aGlzLnBlcm1ba2sgKyBrMyArIHRoaXMucGVybVtsbCArIGwzXV1dXHJcbiAgICAgICAgICBdICUgMzJcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGc0OiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtcclxuICAgICAgICAgIGlpICsgMSArIHRoaXMucGVybVtqaiArIDEgKyB0aGlzLnBlcm1ba2sgKyAxICsgdGhpcy5wZXJtW2xsICsgMV1dXVxyXG4gICAgICAgICAgXSAlIDMyXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZml2ZSBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgdDA6IG51bWJlciA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MCAtIHcwICogdzA7XHJcbiAgICAgICAgY29uc3QgbjA6IG51bWJlciA9IHQwIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDAsIDQpICogKGcwWzBdICogeDAgKyBnMFsxXSAqIHkwICsgZzBbMl0gKiB6MCArIGcwWzNdICogdzApO1xyXG4gICAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MSAtIHoxICogejEgLSB3MSAqIHcxO1xyXG4gICAgICAgIGNvbnN0IG4xOiBudW1iZXIgPSB0MSA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQxLCA0KSAqIChnMVswXSAqIHgxICsgZzFbMV0gKiB5MSArIGcxWzJdICogejEgKyBnMVszXSAqIHcxKTtcclxuICAgICAgICBjb25zdCB0MjogbnVtYmVyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyIC0gdzIgKiB3MjtcclxuICAgICAgICBjb25zdCBuMjogbnVtYmVyID0gdDIgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MiwgNCkgKiAoZzJbMF0gKiB4MiArIGcyWzFdICogeTIgKyBnMlsyXSAqIHoyICsgZzJbM10gKiB3Mik7XHJcbiAgICAgICAgY29uc3QgdDM6IG51bWJlciA9IDAuNSAtIHgzICogeDMgLSB5MyAqIHkzIC0gejMgKiB6MyAtIHczICogdzM7XHJcbiAgICAgICAgY29uc3QgbjM6IG51bWJlciA9IHQzIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDMsIDQpICogKGczWzBdICogeDMgKyBnM1sxXSAqIHkzICsgZzNbMl0gKiB6MyArIGczWzNdICogdzMpO1xyXG4gICAgICAgIGNvbnN0IHQ0OiBudW1iZXIgPSAwLjUgLSB4NCAqIHg0IC0geTQgKiB5NCAtIHo0ICogejQgLSB3NCAqIHc0O1xyXG4gICAgICAgIGNvbnN0IG40OiBudW1iZXIgPSB0NCA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQ0LCA0KSAqIChnNFswXSAqIHg0ICsgZzRbMV0gKiB5NCArIGc0WzJdICogejQgKyBnNFszXSAqIHc0KTtcclxuXHJcbiAgICAgICAgLy8gU3VtIHVwIGFuZCBzY2FsZSB0aGUgcmVzdWx0IHRvIGNvdmVyIHRoZSByYW5nZSBbLTEsMV1cclxuICAgICAgICByZXR1cm4gNzIuMzc4NTU3NjUxNTM2NjUgKiAobjAgKyBuMSArIG4yICsgbjMgKyBuNCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NhbXBsZShfeCwgX3ksIF96LCBfdyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZm9yIGNyZWF0aW5nIHJhbmRvbSB2YWx1ZXMsIHN1cHBvcnRpbmcgSmF2YXNjcmlwdCdzIE1hdGgucmFuZG9tIGFuZCBhIGRldGVybWluaXN0aWcgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIChQUk5HKSBcclxuICAgKiB0aGF0IGNhbiBiZSBmZWQgd2l0aCBhIHNlZWQgYW5kIHRoZW4gcmV0dXJucyBhIHJlcHJvZHVjYWJsZSBzZXQgb2YgcmFuZG9tIG51bWJlcnMgKGlmIHRoZSBwcmVjaXNpb24gb2YgSmF2YXNjcmlwdCBhbGxvd3MpIFxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmFuZG9tIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdDogUmFuZG9tID0gbmV3IFJhbmRvbSgpO1xyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUmFuZG9tfS4gXHJcbiAgICAgKiBJZiBhIHNlZWQgaXMgZ2l2ZW4sIExGSUI0IGlzIHVzZWQgYXMgZ2VuZXJhdG9yLCByZXByb2R1Y2luZyBhIHNlcmllcyBvZiBudW1iZXJzIGZyb20gdGhhdCBzZWVkLlxyXG4gICAgICogSWYgYSBmdW5jdGlvbiBwcm9kdWNpbmcgdmFsdWVzIGJldHdlZW4gMCBhbmQgMSBpcyBnaXZlbiwgaXQgd2lsbCBiZSB1c2VkIGFzIGdlbmVyYXRvci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX3NlZWRPckZ1bmN0aW9uPzogbnVtYmVyIHwgRnVuY3Rpb24pIHtcclxuICAgICAgaWYgKF9zZWVkT3JGdW5jdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIHRoaXMuZ2VuZXJhdGUgPSBfc2VlZE9yRnVuY3Rpb247XHJcbiAgICAgIGVsc2UgaWYgKF9zZWVkT3JGdW5jdGlvbiA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IE1hdGgucmFuZG9tO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IG5ldyBMRklCNChfc2VlZE9yRnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5vcm1lZCByYW5kb20gbnVtYmVyLCB0aHVzIGluIHRoZSByYW5nZSBvZiBbMCwgMVtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE5vcm0oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGluIHRoZSByYW5nZSBvZiBnaXZlbiBbX21pbiwgX21heFtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJhbmdlKF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9taW4gKyB0aGlzLmdlbmVyYXRlKCkgKiAoX21heCAtIF9taW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBpbiB0aGUgcmFuZ2Ugb2YgZ2l2ZW4gZmxvb3JlZCBbX21pbiwgX21heFtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJhbmdlRmxvb3JlZChfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZ2V0UmFuZ2UoX21pbiwgX21heCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIHJhbmRvbWx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRCb29sZWFuKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpIDwgMC41O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyAtMSBvciAxIHJhbmRvbWx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTaWduKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEJvb2xlYW4oKSA/IDEgOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBpbmRleCBpbnRvIHRoZSBnaXZlbiBhcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SW5kZXg8VD4oX2FycmF5OiBBcnJheTxUPik6IG51bWJlciB7XHJcbiAgICAgIGlmIChfYXJyYXkubGVuZ3RoID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZUZsb29yZWQoMCwgX2FycmF5Lmxlbmd0aCk7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBlbGVtZW50IG9mIHRoZSBnaXZlbiBhcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RWxlbWVudDxUPihfYXJyYXk6IEFycmF5PFQ+KTogVCB7XHJcbiAgICAgIGlmIChfYXJyYXkubGVuZ3RoID4gMClcclxuICAgICAgICByZXR1cm4gX2FycmF5W3RoaXMuZ2V0SW5kZXgoX2FycmF5KV07XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHJhbmRvbWx5IHNlbGVjdGVkIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNwbGljZTxUPihfYXJyYXk6IEFycmF5PFQ+KTogVCB7XHJcbiAgICAgIHJldHVybiBfYXJyYXkuc3BsaWNlKHRoaXMuZ2V0SW5kZXgoX2FycmF5KSwgMSlbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQga2V5IGZyb20gdGhlIGdpdmVuIE1hcC1pbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0S2V5PFQsIFU+KF9tYXA6IE1hcDxULCBVPik6IFQge1xyXG4gICAgICBsZXQga2V5czogR2VuZXJhbCA9IEFycmF5LmZyb20oX21hcC5rZXlzKCkpO1xyXG4gICAgICByZXR1cm4ga2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBwcm9wZXJ0eSBuYW1lIGZyb20gdGhlIGdpdmVuIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvcGVydHlOYW1lKF9vYmplY3Q6IE9iamVjdCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBrZXlzOiBzdHJpbmdbXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKF9vYmplY3QpO1xyXG4gICAgICByZXR1cm4ga2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBzeW1ib2wgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LCBpZiBzeW1ib2xzIGFyZSB1c2VkIGFzIGtleXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFByb3BlcnR5U3ltYm9sKF9vYmplY3Q6IE9iamVjdCk6IHN5bWJvbCB7XHJcbiAgICAgIGxldCBrZXlzOiBzeW1ib2xbXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoX29iamVjdCk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB0aHJlZS1kaW1lbnNpb25hbCB2ZWN0b3IgaW4gdGhlIGxpbWl0cyBvZiB0aGUgYm94IGRlZmluZWQgYnkgdGhlIHZlY3RvcnMgZ2l2ZW4gYXMgW19jb3JuZXIwLCBfY29ybmVyMVtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFZlY3RvcjMoX2Nvcm5lcjA6IFZlY3RvcjMsIF9jb3JuZXIxOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLmdldFJhbmdlKF9jb3JuZXIwLngsIF9jb3JuZXIxLngpLCB0aGlzLmdldFJhbmdlKF9jb3JuZXIwLnksIF9jb3JuZXIxLnkpLCB0aGlzLmdldFJhbmdlKF9jb3JuZXIwLnosIF9jb3JuZXIxLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb20gdHdvLWRpbWVuc2lvbmFsIHZlY3RvciBpbiB0aGUgbGltaXRzIG9mIHRoZSByZWN0YW5nbGUgZGVmaW5lZCBieSB0aGUgdmVjdG9ycyBnaXZlbiBhcyBbX2Nvcm5lcjAsIF9jb3JuZXIxW1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VmVjdG9yMihfY29ybmVyMDogVmVjdG9yMiwgX2Nvcm5lcjE6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueCwgX2Nvcm5lcjEueCksIHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueSwgX2Nvcm5lcjEueSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhbmRhcmQge0BsaW5rIFJhbmRvbX0taW5zdGFuY2UgdXNpbmcgTWF0aC5yYW5kb20oKS5cclxuICAgKi9cclxuICBleHBvcnQgY29uc3QgcmFuZG9tOiBSYW5kb20gPSBuZXcgUmFuZG9tKCk7XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgdGhyZWVkaW1lbnNpb25hbCB2ZWN0b3IgY29tcHJpc2VkIG9mIHRoZSBjb21wb25lbnRzIHgsIHkgYW5kIHpcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICAgICt5XHJcbiAgICogICAgICAgICAgICAgfF9fICt4XHJcbiAgICogICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgK3ogICBcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVjdG9yMyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXk7IC8vIFRPRE86IGNoZWNrIHdoeSB0aGlzIHNob3VsZG4ndCBiZSB4LHkseiBhcyBudW1iZXJzLi4uXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShbX3gsIF95LCBfel0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBTdGF0aWNcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geC1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBYKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoX3NjYWxlLCAwLCAwKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoIHBvaW50aW5nIGluIHktZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDAsIF9zY2FsZSwgMCk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGxlbmd0aCBwb2ludGluZyBpbiB6LWRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFooX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLmRhdGEuc2V0KFswLCAwLCBfc2NhbGVdKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgdmFsdWUgMCBvbiBlYWNoIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaRVJPKCk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMCwgMCwgMCk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIG9mIHRoZSBnaXZlbiBzaXplIG9uIGVhY2ggb2YgdGhlIHRocmVlIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBPTkUoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfc2NhbGUsIF9zY2FsZSwgX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3IgdGhyb3VnaCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0ZPUk1BVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfbXR4VHJhbnNmb3JtLmdldCgpO1xyXG4gICAgICBsZXQgW3gsIHksIHpdID0gX3ZlY3Rvci5nZXQoKTtcclxuXHJcbiAgICAgIHJlc3VsdC54ID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6O1xyXG4gICAgICByZXN1bHQueSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogejtcclxuICAgICAgcmVzdWx0LnogPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6O1xyXG5cclxuICAgICAgaWYgKF9pbmNsdWRlVHJhbnNsYXRpb24pIHtcclxuICAgICAgICByZXN1bHQuYWRkKF9tdHhUcmFuc2Zvcm0udHJhbnNsYXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aGljaCBpcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgdG8gdGhlIGdpdmVuIGxlbmd0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3ZlY3RvcjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgbWFnbml0dWRlU3F1YXJlZDogbnVtYmVyID0gX3ZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkO1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gX3ZlY3Rvci5jbG9uZTtcclxuICAgICAgaWYgKG1hZ25pdHVkZVNxdWFyZWQgPT0gMClcclxuICAgICAgICB0aHJvdyAobmV3IFJhbmdlRXJyb3IoXCJJbXBvc3NpYmxlIG5vcm1hbGl6YXRpb25cIikpO1xyXG4gICAgICB2ZWN0b3Iuc2NhbGUoX2xlbmd0aCAvIE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkKSlcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdGluZyB2ZWN0b3IgYXR0YWluZWQgYnkgYWRkaXRpb24gb2YgYWxsIGdpdmVuIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU1VNKC4uLl92ZWN0b3JzOiBWZWN0b3IzW10pOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgZm9yIChsZXQgdmVjdG9yIG9mIF92ZWN0b3JzKVxyXG4gICAgICAgIHJlc3VsdC5zZXQocmVzdWx0LnggKyB2ZWN0b3IueCwgcmVzdWx0LnkgKyB2ZWN0b3IueSwgcmVzdWx0LnogKyB2ZWN0b3Iueik7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHR3byB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERJRkZFUkVOQ0UoX21pbnVlbmQ6IFZlY3RvcjMsIF9zdWJ0cmFoZW5kOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoX21pbnVlbmQueCAtIF9zdWJ0cmFoZW5kLngsIF9taW51ZW5kLnkgLSBfc3VidHJhaGVuZC55LCBfbWludWVuZC56IC0gX3N1YnRyYWhlbmQueik7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTEUoX3ZlY3RvcjogVmVjdG9yMywgX3NjYWxpbmc6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgc2NhbGVkOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBzY2FsZWQuc2V0KF92ZWN0b3IueCAqIF9zY2FsaW5nLCBfdmVjdG9yLnkgKiBfc2NhbGluZywgX3ZlY3Rvci56ICogX3NjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gc2NhbGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGNyb3NzcHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1JPU1MoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoXHJcbiAgICAgICAgX2EueSAqIF9iLnogLSBfYS56ICogX2IueSxcclxuICAgICAgICBfYS56ICogX2IueCAtIF9hLnggKiBfYi56LFxyXG4gICAgICAgIF9hLnggKiBfYi55IC0gX2EueSAqIF9iLnhcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdHByb2R1Y3Qgb2YgMiB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfYTogVmVjdG9yMywgX2I6IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc2NhbGFyUHJvZHVjdDogbnVtYmVyID0gX2EueCAqIF9iLnggKyBfYS55ICogX2IueSArIF9hLnogKiBfYi56O1xyXG4gICAgICByZXR1cm4gc2NhbGFyUHJvZHVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIGluY29taW5nIHZlY3RvciBhdCB0aGUgZ2l2ZW4gbm9ybWFsIHZlY3Rvci4gVGhlIGxlbmd0aCBvZiBub3JtYWwgc2hvdWxkIGJlIDEuXHJcbiAgICAgKiAgICAgX19fX19fX19fX19fX19fX19fXHJcbiAgICAgKiAgICAgICAgICAgL3xcXFxyXG4gICAgICogaW5jb21pbmcgLyB8IFxcIHJlZmxlY3Rpb25cclxuICAgICAqICAgICAgICAgLyAgfCAgXFwgICBcclxuICAgICAqICAgICAgICAgIG5vcm1hbFxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUkVGTEVDVElPTihfaW5jb21pbmc6IFZlY3RvcjMsIF9ub3JtYWw6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGRvdDogbnVtYmVyID0gLVZlY3RvcjMuRE9UKF9pbmNvbWluZywgX25vcm1hbCk7XHJcbiAgICAgIGxldCByZWZsZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oX2luY29taW5nLCBWZWN0b3IzLlNDQUxFKF9ub3JtYWwsIDIgKiBkb3QpKTtcclxuICAgICAgcmV0dXJuIHJlZmxlY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXZpZGVzIHRoZSBkaXZpZGVuZCBieSB0aGUgZGl2aXNvciBjb21wb25lbnQgYnkgY29tcG9uZW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSQVRJTyhfZGl2aWRlbmQ6IFZlY3RvcjMsIF9kaXZpc29yOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoX2RpdmlkZW5kLnggLyBfZGl2aXNvci54LCBfZGl2aWRlbmQueSAvIF9kaXZpc29yLnksIF9kaXZpZGVuZC56IC8gX2Rpdmlzb3Iueik7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2FydGVzaWFuIHZlY3RvciBmcm9tIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHRU8oX2xvbmdpdHVkZTogbnVtYmVyID0gMCwgX2xhdGl0dWRlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIGxldCBnZW86IEdlbzMgPSBSZWN5Y2xlci5nZXQoR2VvMyk7XHJcbiAgICAgIGdlby5zZXQoX2xvbmdpdHVkZSwgX2xhdGl0dWRlLCBfbWFnbml0dWRlKTtcclxuICAgICAgdmVjdG9yLmdlbyA9IGdlbztcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZ2VvKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBBY2Nlc3NvcnNcclxuICAgIC8vIFRPRE86IGltcGxlbWVudCBlcXVhbHMtZnVuY3Rpb25zXHJcbiAgICBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhWzBdO1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVsxXTtcclxuICAgIH1cclxuICAgIGdldCB6KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMl07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHgoX3g6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRhdGFbMF0gPSBfeDtcclxuICAgIH1cclxuICAgIHNldCB5KF95OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5kYXRhWzFdID0gX3k7XHJcbiAgICB9XHJcbiAgICBzZXQgeihfejogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZGF0YVsyXSA9IF96O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5oeXBvdCguLi50aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciB3aXRob3V0IGNhbGN1bGF0aW5nIGEgc3F1YXJlIHJvb3QuIEZhc3RlciBmb3Igc2ltcGxlIHByb3hpbWl0eSBldmFsdWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gVmVjdG9yMy5ET1QodGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHZlY3RvclxyXG4gICAgICogVE9ETzogcmVuYW1lIHRoaXMgY2xvbmUgYW5kIGNyZWF0ZSBhIG5ldyBtZXRob2QgY29weSwgd2hpY2ggY29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIHZlY3RvciBnaXZlbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjbG9uZSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGNsb25lOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBjbG9uZS5kYXRhLnNldCh0aGlzLmRhdGEpO1xyXG4gICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAtIGdldDogcmV0dXJucyBhIGdlb2dyYXBoaWMgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3IgIFxyXG4gICAgICogLSBzZXQ6IGFkanVzdCB0aGUgY2FydGVzaWFuIHZhbHVlcyBvZiB0aGlzIHZlY3RvciB0byByZXByZXNlbnQgdGhlIGdpdmVuIGFzIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBnZW8oX2dlbzogR2VvMykge1xyXG4gICAgICB0aGlzLnNldCgwLCAwLCBfZ2VvLm1hZ25pdHVkZSk7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5ST1RBVElPTl9YKC1fZ2VvLmxhdGl0dWRlKSk7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5ST1RBVElPTl9ZKF9nZW8ubG9uZ2l0dWRlKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGdlbygpOiBHZW8zIHtcclxuICAgICAgbGV0IGdlbzogR2VvMyA9IFJlY3ljbGVyLmdldChHZW8zKTtcclxuICAgICAgZ2VvLm1hZ25pdHVkZSA9IHRoaXMubWFnbml0dWRlO1xyXG5cclxuICAgICAgaWYgKGdlby5tYWduaXR1ZGUgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGdlbztcclxuXHJcbiAgICAgIGdlby5sb25naXR1ZGUgPSAxODAgKiBNYXRoLmF0YW4yKHRoaXMueCAvIGdlby5tYWduaXR1ZGUsIHRoaXMueiAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgZ2VvLmxhdGl0dWRlID0gMTgwICogTWF0aC5hc2luKHRoaXMueSAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgcmV0dXJuIGdlbztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFswLCAwLCAwXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IgYXJlIHRvIGJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsIHdpdGhpbiB0aGUgZ2l2ZW4gdG9sZXJhbmNlXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0b2xlcmFuY2UgYXMgY3JpdGVyaXVtIGZvciB0aGUgZGlmZmVyZW5jZSBpcyBhcHByb3ByaWF0ZSB3aXRoIHZlcnkgbGFyZ2UgY29vcmRpbmF0ZSB2YWx1ZXMgb3IgaWYgX3RvbGVyYW5jZSBzaG91bGQgYmUgbXVsdGlwbGllZCBieSBjb29yZGluYXRlIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlcXVhbHMoX2NvbXBhcmU6IFZlY3RvcjMsIF90b2xlcmFuY2U6IG51bWJlciA9IE51bWJlci5FUFNJTE9OKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSBfY29tcGFyZS54KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueSAtIF9jb21wYXJlLnkpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy56IC0gX2NvbXBhcmUueikgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb3NpdGlvbiBkZXNjcmliZWQgYnkgdGhpcyBpcyB3aXRoaW4gYSBjdWJlIHdpdGggdGhlIG9wcG9zaXRlIGNvcm5lcnMgMSBhbmQgMlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGVDdWJlKF9jb3JuZXIxOiBWZWN0b3IzLCBfY29ybmVyMjogVmVjdG9yMyk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZGlhZ29uYWw6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX2Nvcm5lcjIsIF9jb3JuZXIxKTtcclxuICAgICAgbGV0IHJlbGF0aXZlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMsIF9jb3JuZXIxKTtcclxuICAgICAgbGV0IHJhdGlvOiBWZWN0b3IzID0gVmVjdG9yMy5SQVRJTyhyZWxhdGl2ZSwgZGlhZ29uYWwpO1xyXG4gICAgICBpZiAocmF0aW8ueCA+IDEgfHwgcmF0aW8ueCA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAocmF0aW8ueSA+IDEgfHwgcmF0aW8ueSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAocmF0aW8ueiA+IDEgfHwgcmF0aW8ueiA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZGVzY3JpYmVkIGJ5IHRoaXMgaXMgd2l0aGluIGEgc3BoZXJlIHdpdGggdGhlIGdpdmVuIGNlbnRlciBhbmQgcmFkaXVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0luc2lkZVNwaGVyZShfY2VudGVyOiBWZWN0b3IzLCBfcmFkaXVzOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX2NlbnRlcik7XHJcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlLm1hZ25pdHVkZVNxdWFyZWQgPCAoX3JhZGl1cyAqIF9yYWRpdXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW19hZGRlbmQueCArIHRoaXMueCwgX2FkZGVuZC55ICsgdGhpcy55LCBfYWRkZW5kLnogKyB0aGlzLnpdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gdmVjdG9yIGZyb20gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VidHJhY3QoX3N1YnRyYWhlbmQ6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy54IC0gX3N1YnRyYWhlbmQueCwgdGhpcy55IC0gX3N1YnRyYWhlbmQueSwgdGhpcy56IC0gX3N1YnRyYWhlbmQuel0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBzY2FsYXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9zY2FsYXI6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFtfc2NhbGFyICogdGhpcy54LCBfc2NhbGFyICogdGhpcy55LCBfc2NhbGFyICogdGhpcy56XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoaXMgdG8gdGhlIGdpdmVuIGxlbmd0aCwgMSBieSBkZWZhdWx0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWxpemUoX2xlbmd0aDogbnVtYmVyID0gMSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRhdGEgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcywgX2xlbmd0aCkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5kYXRhWzBdID0gX3g7XHJcbiAgICAgIHRoaXMuZGF0YVsxXSA9IF95O1xyXG4gICAgICB0aGlzLmRhdGFbMl0gPSBfejtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyB2ZWN0b3IgYXMgYSBuZXcgRmxvYXQzMkFycmF5IChjb3B5KVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBtYXRyaXgsIGluY2x1ZGluZyBvciBleGx1ZGluZyB0aGUgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBJbmNsdWRpbmcgaXMgdGhlIGRlZmF1bHQsIGV4Y2x1ZGluZyB3aWxsIG9ubHkgcm90YXRlIGFuZCBzY2FsZSB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIGxldCB0cmFuc2Zvcm1lZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcywgX210eFRyYW5zZm9ybSwgX2luY2x1ZGVUcmFuc2xhdGlvbik7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQodHJhbnNmb3JtZWQuZGF0YSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zZm9ybWVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyb3BzIHRoZSB6LWNvbXBvbmVudCBhbmQgcmV0dXJucyBhIFZlY3RvcjIgY29uc2lzdGluZyBvZiB0aGUgeC0gYW5kIHktY29tcG9uZW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9WZWN0b3IyKCk6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmbGVjdHMgdGhpcyB2ZWN0b3IgYXQgYSBnaXZlbiBub3JtYWwuIFNlZSB7QGxpbmsgVmVjdG9yMy5SRUZMRUNUSU9OfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVmbGVjdChfbm9ybWFsOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IHJlZmxlY3RlZDogVmVjdG9yMyA9IFZlY3RvcjMuUkVGTEVDVElPTih0aGlzLCBfbm9ybWFsKTtcclxuICAgICAgdGhpcy5zZXQocmVmbGVjdGVkLngsIHJlZmxlY3RlZC55LCByZWZsZWN0ZWQueik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlZmxlY3RlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaHVmZmxlcyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBzaHVmZmxlKCk6IHZvaWQge1xyXG4gICAgICBsZXQgYTogbnVtYmVyW10gPSBBcnJheS5mcm9tKHRoaXMuZGF0YSk7XHJcbiAgICAgIHRoaXMuc2V0KFJhbmRvbS5kZWZhdWx0LnNwbGljZShhKSwgUmFuZG9tLmRlZmF1bHQuc3BsaWNlKGEpLCBhWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RGlzdGFuY2UoX3RvOiBWZWN0b3IzKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX3RvKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZGlmZmVyZW5jZSk7XHJcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlLm1hZ25pdHVkZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtaW5pbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgICB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIF9jb21wYXJlLnopO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBkaW1lbnNpb24sIG1vdmVzIHRoZSBjb21wb25lbnQgdG8gdGhlIG1heGltdW0gb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWF4KF9jb21wYXJlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgX2NvbXBhcmUueCk7XHJcbiAgICAgIHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgX2NvbXBhcmUueSk7XHJcbiAgICAgIHRoaXMueiA9IE1hdGgubWF4KHRoaXMueiwgX2NvbXBhcmUueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYCgke3RoaXMueC50b1ByZWNpc2lvbig1KX0sICR7dGhpcy55LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnoudG9QcmVjaXNpb24oNSl9KWA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHRoZSBzdGFuZGFyZCBhcnJheS5tYXAgZnVuY3Rpb25hbGl0eSB0byBwZXJmb3JtIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBhbGwgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWFwKF9mdW5jdGlvbjogKHZhbHVlOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGFycmF5OiBGbG9hdDMyQXJyYXkpID0+IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgY29weTogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgY29weS5kYXRhID0gdGhpcy5kYXRhLm1hcChfZnVuY3Rpb24pO1xyXG4gICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYHsgXCJyXCI6ICR7dGhpcy5yfSwgXCJnXCI6ICR7dGhpcy5nfSwgXCJiXCI6ICR7dGhpcy5ifSwgXCJhXCI6ICR7dGhpcy5hfX1gOyB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnh9LCAke3RoaXMueX0sICR7dGhpcy56fV1gOyB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFZlY3RvcjM+IHtcclxuICAgICAgaWYgKHR5cGVvZiAoX3NlcmlhbGl6YXRpb24pID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMuel0gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLmRhdGFbMF0sIHk6IHRoaXMuZGF0YVsxXSwgejogdGhpcy5kYXRhWzJdXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gICAgLy8jZW5kcmVnaW9uIFRyYW5zZmVyXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVzY3JpYmVzIGEgZmFjZSBvZiBhIHtAbGluayBNZXNofSBieSByZWZlcmVuY2luZyB0aHJlZSB7QGxpbmsgVmVydGljZXN9IHdpdGggdGhlaXIgaW5kaXplc1xyXG4gICAqIGFuZCBjYWxjdWxhdGVzIGZhY2Ugbm9ybWFscy5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGYWNlIHtcclxuICAgIHB1YmxpYyBpbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgcHVibGljIG5vcm1hbFVuc2NhbGVkOiBWZWN0b3IzO1xyXG4gICAgcHVibGljIG5vcm1hbDogVmVjdG9yMztcclxuICAgIHByaXZhdGUgdmVydGljZXM6IFZlcnRpY2VzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF92ZXJ0aWNlczogVmVydGljZXMsIF9pbmRleDA6IG51bWJlciwgX2luZGV4MTogbnVtYmVyLCBfaW5kZXgyOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gW19pbmRleDAsIF9pbmRleDEsIF9pbmRleDJdO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gX3ZlcnRpY2VzO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZU5vcm1hbHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlTm9ybWFscygpOiB2b2lkIHtcclxuICAgICAgbGV0IHRyaWdvbjogVmVjdG9yM1tdID0gdGhpcy5pbmRpY2VzLm1hcCgoX2luZGV4OiBudW1iZXIpID0+IHRoaXMudmVydGljZXMucG9zaXRpb24oX2luZGV4KSk7XHJcbiAgICAgIGxldCB2MTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0cmlnb25bMV0sIHRyaWdvblswXSk7XHJcbiAgICAgIGxldCB2MjogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0cmlnb25bMl0sIHRyaWdvblswXSk7XHJcbiAgICAgIHRoaXMubm9ybWFsVW5zY2FsZWQgPSBWZWN0b3IzLkNST1NTKHYxLCB2Mik7XHJcbiAgICAgIHRoaXMubm9ybWFsID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMubm9ybWFsVW5zY2FsZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb3NpdGlvbihfaW5kZXg6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbih0aGlzLmluZGljZXNbX2luZGV4XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBtdXN0IGJlIGNvcGxhbmFyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0luc2lkZShfcG9pbnQ6IFZlY3RvcjMpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGRpZmZzOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgaW5kZXggb2YgdGhpcy5pbmRpY2VzKSB7XHJcbiAgICAgICAgbGV0IGRpZmY6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihpbmRleCksIF9wb2ludCk7XHJcbiAgICAgICAgZGlmZnMucHVzaChkaWZmKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgbjA6IFZlY3RvcjMgPSBWZWN0b3IzLkNST1NTKGRpZmZzWzFdLCBkaWZmc1swXSk7XHJcbiAgICAgIGxldCBuMTogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoZGlmZnNbMl0sIGRpZmZzWzFdKTtcclxuICAgICAgbGV0IG4yOiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhkaWZmc1swXSwgZGlmZnNbMl0pO1xyXG4gIFxyXG4gICAgICBsZXQgZG90MTogbnVtYmVyID0gVmVjdG9yMy5ET1QobjAsIG4xKTtcclxuICAgICAgbGV0IGRvdDI6IG51bWJlciA9IFZlY3RvcjMuRE9UKG4wLCBuMik7XHJcbiAgXHJcbiAgICAgIHJldHVybiAhKGRvdDEgPCAwIHx8IGRvdDIgPCAwKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgbWVzaGVzLiBcclxuICAgKiBNZXNoZXMgcHJvdmlkZSBpbmRleGVkIHZlcnRpY2VzLCB0aGUgb3JkZXIgb2YgaW5kaWNlcyB0byBjcmVhdGUgdHJpZ29ucyBhbmQgbm9ybWFscywgYW5kIHRleHR1cmUgY29vcmRpbmF0ZXNcclxuICAgKiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOS8yMlxyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3Rvck1lc2guZGVjb3JhdGVcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTWVzaCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBNZXNoID0gTWVzaDtcclxuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIE1lc2hbXSA9IFtdO1xyXG5cclxuICAgIC8vIFRPRE86IGF0IHRoaXMgdGltZSwgY3JlYXRpbmcgdGhlIGJ1ZmZlcnMgZm9yIGZsYXQgc2hhZGluZyBpcyBhIGJydXRlIGZvcmNlIGFsZ29yaXRobSBhbmQgc2hvdWxkIGJlIG9wdGltaXplZCBpbiB0aGUgZGlmZmVyZW50IHN1YmNsYXNzZXNcclxuICAgIC8vIFRPRE86IHJlbmFtZSB2ZXJ0aWNlcyB0byB2ZXJ0aWNlc1Ntb290aCBvciBqdXN0IGNsb3VkLCBhbmQgY2xvdWQgdG8gdmVydGljZXNcclxuICAgIC8vIFxyXG5cclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJNZXNoXCI7XHJcbiAgICAvLyBiYXNlIHN0cnVjdHVyZSBmb3IgbWVzaGVzIGluIEZVREdFXHJcbiAgICBwdWJsaWMgdmVydGljZXM6IFZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICBwdWJsaWMgZmFjZXM6IEZhY2VbXSA9IFtdO1xyXG5cclxuICAgIC8vIHB1YmxpYyByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzOyAvKiBkZWZpbmVkIGJ5IFJlbmRlckluamVjdG9yKi9cclxuICAgIHByb3RlY3RlZCByZW5kZXJNZXNoOiBSZW5kZXJNZXNoOyAvKiBkZWZpbmVkIGJ5IFJlbmRlckluamVjdG9yKi9cclxuXHJcblxyXG4gICAgLyoqIGJvdW5kaW5nIGJveCBBQUJCICovXHJcbiAgICBwcm90ZWN0ZWQgxpJib3g6IEJveDtcclxuICAgIC8vIFRPRE86IGV4cGxvcmUgbWF0aGVtYXRpY3MgZm9yIGVhc3kgdHJhbnNmb3JtYXRpb25zIG9mIHJhZGl1cyBcclxuICAgIC8qKiBib3VuZGluZyByYWRpdXMgKi9cclxuICAgIHByb3RlY3RlZCDGknJhZGl1czogbnVtYmVyO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFwiKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWdpc3RlclN1YmNsYXNzKF9zdWJDbGFzczogdHlwZW9mIE1lc2gpOiBudW1iZXIgeyByZXR1cm4gTWVzaC5zdWJjbGFzc2VzLnB1c2goX3N1YkNsYXNzKSAtIDE7IH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGJvdW5kaW5nQm94KCk6IEJveCB7XHJcbiAgICAgIGlmICh0aGlzLsaSYm94ID09IG51bGwpXHJcbiAgICAgICAgdGhpcy7GkmJveCA9IHRoaXMuY3JlYXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaSYm94O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCByYWRpdXMoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuxpJyYWRpdXMgPT0gbnVsbClcclxuICAgICAgICB0aGlzLsaScmFkaXVzID0gdGhpcy5jcmVhdGVSYWRpdXMoKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaScmFkaXVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXJzKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfbXR4UHJvamVjdGlvbjogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIpOiBSZW5kZXJCdWZmZXJzIHsgcmV0dXJuIG51bGw7IC8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG4gICAgcHVibGljIGdldFJlbmRlckJ1ZmZlcnMoX3NoYWRlcjogdHlwZW9mIFNoYWRlcik6IFJlbmRlckJ1ZmZlcnMgeyByZXR1cm4gbnVsbDsgLyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcbiAgICBwdWJsaWMgZGVsZXRlUmVuZGVyQnVmZmVycyhfc2hhZGVyOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcblxyXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLsaSYm94ID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLsaScmFkaXVzID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgdGhpcy5yZW5kZXJNZXNoPy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLy8gU2VyaWFsaXplL0Rlc2VyaWFsaXplIGZvciBhbGwgbWVzaGVzIHRoYXQgY2FsY3VsYXRlIHdpdGhvdXQgcGFyYW1ldGVyc1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUgLy8gc3RvcmUgZm9yIGVkaXRvciB2aWV3XHJcbiAgICAgIH07IC8vIG5vIGRhdGEgbmVlZGVkIC4uLlxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIC8vIHR5cGUgaXMgYW4gYWNjZXNzb3IgYW5kIG11c3Qgbm90IGJlIGRlc2VyaWFsaXplZFxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiBzbyBtdWNoIHRvIGRlbGV0ZS4uLiByYXRoZXIganVzdCBnYXRoZXIgd2hhdCB0byBtdXRhdGVcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLsaSYm94O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJyYWRpdXM7XHJcblxyXG4gICAgICBkZWxldGUgX211dGF0b3IucmVuZGVyQnVmZmVycztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlUmFkaXVzKCk6IG51bWJlciB7XHJcbiAgICAgIC8vVE9ETzogcmFkaXVzIGFuZCBib3VuZGluZyBib3ggY291bGQgYmUgY3JlYXRlZCBvbiBjb25zdHJ1Y3Rpb24gb2YgdmVydGV4LWFycmF5XHJcbiAgICAgIGxldCByYWRpdXM6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCB0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKGkpLm1hZ25pdHVkZVNxdWFyZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQocmFkaXVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlQm91bmRpbmdCb3goKTogQm94IHtcclxuICAgICAgbGV0IGJveDogQm94ID0gUmVjeWNsZXIuZ2V0KEJveCk7XHJcbiAgICAgIGJveC5zZXQoKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICsrKSB7XHJcbiAgICAgICAgbGV0IHBvaW50OiBWZWN0b3IzID0gdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihpKTtcclxuICAgICAgICBib3guZXhwYW5kKHBvaW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYm94O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIGN1YmUgd2l0aCBlZGdlcyBvZiBsZW5ndGggMSwgZWFjaCBmYWNlIGNvbnNpc3Rpbmcgb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAoMTIpIDRfX19fNyAgKDExKVxyXG4gICAqICAgICAgICg4KSAwL19fMy98ICgxMClcclxuICAgKiAgICAgICAoMTUpIHx8NV98fDYgKDE0KVxyXG4gICAqICAgICAgICg5KSAxfC9fMnwvICgxMylcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoQ3ViZSBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoQ3ViZSk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hDdWJlXCIpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICAvLyB0aGlzLmNyZWF0ZSgpO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKFxyXG4gICAgICAgIC8vIGZyb250XHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAwLjUsIDAuNSksIG5ldyBWZWN0b3IyKDAsIDApKSwgLy8gMFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgLTAuNSwgMC41KSwgbmV3IFZlY3RvcjIoMCwgMSkpLCAvLyAxXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKDEsIDEpKSwgLy8gMlxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAwLjUsIDAuNSksIG5ldyBWZWN0b3IyKDEsIDApKSwgLy8gM1xyXG4gICAgICAgIC8vIGJhY2tcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIDAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDMsIDApKSwgLy8gNFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgLTAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDMsIDEpKSwgLy8gNVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAtMC41LCAtMC41KSwgbmV3IFZlY3RvcjIoMiwgMSkpLCAvLyA2XHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDIsIDApKSwgLy8gN1xyXG4gICAgICAgIC8vIHJlZmVyZW5jZXNcclxuICAgICAgICBuZXcgVmVydGV4KDAsIG5ldyBWZWN0b3IyKDQsIDApKSwgLy8gOFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMSwgbmV3IFZlY3RvcjIoNCwgMSkpLCAvLyA5XHJcbiAgICAgICAgbmV3IFZlcnRleCgzLCBuZXcgVmVjdG9yMigwLCAxKSksIC8vIDEwXHJcbiAgICAgICAgbmV3IFZlcnRleCg3LCBuZXcgVmVjdG9yMigxLCAxKSksIC8vIDExXHJcbiAgICAgICAgbmV3IFZlcnRleCg0LCBuZXcgVmVjdG9yMigxLCAwKSksIC8vIDEyXHJcbiAgICAgICAgbmV3IFZlcnRleCgyLCBuZXcgVmVjdG9yMigwLCAwKSksIC8vIDEzXHJcbiAgICAgICAgbmV3IFZlcnRleCg2LCBuZXcgVmVjdG9yMigxLCAwKSksIC8vIDE0XHJcbiAgICAgICAgbmV3IFZlcnRleCg1LCBuZXcgVmVjdG9yMigxLCAxKSkgIC8vIDE1XHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLmZhY2VzID0gW1xyXG4gICAgICAgIC4uLm5ldyBRdWFkKHRoaXMudmVydGljZXMsIDAsIDEsIDIsIDMpLmZhY2VzLCAvLyBmcm9udFxyXG4gICAgICAgIC4uLm5ldyBRdWFkKHRoaXMudmVydGljZXMsIDcsIDYsIDUsIDQpLmZhY2VzLCAvLyBiYWNrXHJcbiAgICAgICAgLi4ubmV3IFF1YWQodGhpcy52ZXJ0aWNlcywgMywgMiwgNiwgNykuZmFjZXMsIC8vIHJpZ2h0XHJcbiAgICAgICAgLi4ubmV3IFF1YWQodGhpcy52ZXJ0aWNlcywgNCwgNSwgOSwgOCkuZmFjZXMsIC8vIGxlZnRcclxuICAgICAgICAuLi5uZXcgUXVhZCh0aGlzLnZlcnRpY2VzLCAwLCAxMCwgMTEsIDEyKS5mYWNlcywgLy8gdG9wXHJcbiAgICAgICAgLi4ubmV3IFF1YWQodGhpcy52ZXJ0aWNlcywgMTMsIDEsIDE1LCAxNCkuZmFjZXMgIC8vIGJvdHRvbVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgZmxhdCBwb2x5Z29uLiBBbGwgdHJpZ29ucyBzaGFyZSB2ZXJ0ZXggMCwgc28gY2FyZWZ1bCBkZXNpZ24gaXMgcmVxdWlyZWQgdG8gY3JlYXRlIGNvbmNhdmUgcG9seWdvbnMuIFxyXG4gICAqIFZlcnRleCAwIGlzIGFsc28gYXNzb2NpYXRlZCB3aXRoIHRoZSBmYWNlIG5vcm1hbC5cclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgICAgICAwIFxyXG4gICAqICAgICAgICAgICAx4pWxfOKVsiAgNCAuLi5cclxuICAgKiAgICAgICAgICAgIOKVsnxf4pWy4pWxIFxyXG4gICAqICAgICAgICAgICAgMiAgIDNcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hQb2x5Z29uIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQb2x5Z29uKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc2hhcGVEZWZhdWx0OiBWZWN0b3IyW10gPSBbIC8vIHRyaWdvbiBpcyB0aGUgbWluaW1hbCBzaGFwZVxyXG4gICAgICBuZXcgVmVjdG9yMigtMSwgLTEpLFxyXG4gICAgICBuZXcgVmVjdG9yMigxLCAtMSksXHJcbiAgICAgIG5ldyBWZWN0b3IyKDAsIDEpXHJcbiAgICBdO1xyXG4gICAgcHJvdGVjdGVkIHNoYXBlOiBNdXRhYmxlQXJyYXk8VmVjdG9yMj4gPSBuZXcgTXV0YWJsZUFycmF5PFZlY3RvcjI+KCk7XHJcbiAgICBwcm90ZWN0ZWQgZml0VGV4dHVyZTogYm9vbGVhbjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFBvbHlnb25cIiwgX3NoYXBlOiBWZWN0b3IyW10gPSBNZXNoUG9seWdvbi5zaGFwZURlZmF1bHQsIF9maXRUZXh0dXJlOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKF9zaGFwZSwgX2ZpdFRleHR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZXQgbWluVmVydGljZXMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZShfc2hhcGU6IFZlY3RvcjJbXSA9IFtdLCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaGFwZSA9IDxNdXRhYmxlQXJyYXk8VmVjdG9yMj4+TXV0YWJsZUFycmF5LmZyb20oX3NoYXBlLm1hcChfdmVydGV4ID0+IF92ZXJ0ZXguY2xvbmUpKTtcclxuICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICB0aGlzLmZpdFRleHR1cmUgPSBfZml0VGV4dHVyZTtcclxuXHJcbiAgICAgIGlmIChfc2hhcGUubGVuZ3RoIDwgdGhpcy5taW5WZXJ0aWNlcykge1xyXG4gICAgICAgIERlYnVnLndhcm4oYEF0IGxlYXN0ICR7dGhpcy5taW5WZXJ0aWNlc30gdmVydGljZXMgbmVlZGVkIHRvIGNvbnN0cnVjdCBNZXNoUG9seWdvbiwgZGVmYXVsdCB0cmlnb24gdXNlZGApO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlKE1lc2hQb2x5Z29uLnNoYXBlRGVmYXVsdCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IF9zaGFwZTtcclxuXHJcbiAgICAgIGxldCBtaW46IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcclxuICAgICAgbGV0IG1heDogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgIGZvciAobGV0IHZlcnRleCBvZiBzaGFwZSkge1xyXG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaChuZXcgVmVydGV4KHZlcnRleC50b1ZlY3RvcjMoKSkpO1xyXG5cclxuICAgICAgICBtaW4ueCA9IE1hdGgubWluKG1pbi54LCB2ZXJ0ZXgueCk7XHJcbiAgICAgICAgbWF4LnggPSBNYXRoLm1heChtYXgueCwgdmVydGV4LngpO1xyXG4gICAgICAgIG1pbi55ID0gTWF0aC5taW4obWluLnksIHZlcnRleC55KTtcclxuICAgICAgICBtYXgueSA9IE1hdGgubWF4KG1heC55LCB2ZXJ0ZXgueSk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHNpemU6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihtYXgueCAtIG1pbi54LCBtYXgueSAtIG1pbi55KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmZpdFRleHR1cmUpIHtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCB0ZXh0dXJlVVY6IFZlY3RvcjIgPSBWZWN0b3IyLlNVTShzaGFwZVtpXSwgbWluKTtcclxuICAgICAgICAgIHRoaXMudmVydGljZXNbaV0udXYgPSBuZXcgVmVjdG9yMih0ZXh0dXJlVVYueCAvIHNpemUueCwgLXRleHR1cmVVVi55IC8gc2l6ZS55KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX3NoYXBlLmZvckVhY2goKF92ZXJ0ZXgsIGkpID0+IHRoaXMudmVydGljZXNbaV0udXYgPSBuZXcgVmVjdG9yMihfdmVydGV4LngsIC1fdmVydGV4LnkpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5mYWNlcyA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAyOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgaSAtIDEsIGksIDApKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2hhcGUgPSBTZXJpYWxpemVyLnNlcmlhbGl6ZUFycmF5KFZlY3RvcjIsIHRoaXMuc2hhcGUpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmZpdFRleHR1cmUgPSB0aGlzLmZpdFRleHR1cmU7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBsZXQgdmVjdG9yczogVmVjdG9yMltdID0gPFZlY3RvcjJbXT5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb24uc2hhcGUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh2ZWN0b3JzLCBfc2VyaWFsaXphdGlvbi5maXRUZXh0dXJlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnNoYXBlLCB0aGlzLmZpdFRleHR1cmUpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiTWVzaFBvbHlnb24udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhbiBleHRydXNpb24gb2YgYSBwb2x5Z29uIGJ5IGEgc2VyaWVzIG9mIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAqIGBgYHBsYWludGV4dCAgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgX19fX1xyXG4gICAqIFBvbHlnb24gICAgICAgICBfX19f4pWx4pWyICAg4pWyICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICogVHJhbnNmb3JtIDAgIOKGkiDilbEg4pWyX1/ilbJf4pWyX19f4pWyIOKGkCBUcmFuc2Zvcm0gMiAgICAgICAgICB6IF9f4pSCXHJcbiAgICogKGJhc2UpICAgICAgICAg4pWyX+KVsV9f4pWxIOKVsSAgIOKVsSAgIChsaWQpICAgICAgICAgICAgICAgICAgICAg4pWyICAgICAgIFxyXG4gICAqICAgICBUcmFuc2Zvcm0gMSAg4oaSICDilbLilbFfX1/ilbEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxLTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEV4dHJ1c2lvbiBleHRlbmRzIE1lc2hQb2x5Z29uIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaEV4dHJ1c2lvbik7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG10eERlZmF1bHRzOiBNYXRyaXg0eDRbXSA9IFsgLy8gb2Zmc2V0IG9mICswLjV6IGFuZCAtMC41eiBhcyBkZWZhdWx0XHJcbiAgICAgIE1hdHJpeDR4NC5UUkFOU0xBVElPTihWZWN0b3IzLlooMC41KSksXHJcbiAgICAgIE1hdHJpeDR4NC5UUkFOU0xBVElPTihWZWN0b3IzLlooLTAuNSkpXHJcbiAgICBdO1xyXG4gICAgcHJpdmF0ZSBtdHhUcmFuc2Zvcm1zOiBNdXRhYmxlQXJyYXk8TWF0cml4NHg0PiA9IG5ldyBNdXRhYmxlQXJyYXk8TWF0cml4NHg0PigpO1xyXG4gICAgLy8gcHJpdmF0ZSB0cmFuc2Zvcm1zOiBNdXRhYmxlQXJyYXk8TWF0cml4NHg0PiA9IG5ldyBNdXRhYmxlQXJyYXkoTWF0cml4NHg0KTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaEV4dHJ1c2lvblwiLCBfdmVydGljZXM6IFZlY3RvcjJbXSA9IE1lc2hQb2x5Z29uLnNoYXBlRGVmYXVsdCwgX210eFRyYW5zZm9ybXM6IE1hdHJpeDR4NFtdID0gTWVzaEV4dHJ1c2lvbi5tdHhEZWZhdWx0cywgX2ZpdFRleHR1cmU6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lLCBfdmVydGljZXMsIF9maXRUZXh0dXJlKTtcclxuICAgICAgdGhpcy5leHRydWRlKF9tdHhUcmFuc2Zvcm1zKTtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJNdXRhdG9yXCIsIHRoaXMuZ2V0TXV0YXRvcigpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHJhbnNmb3JtcyA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQXJyYXkoTWF0cml4NHg0LCB0aGlzLm10eFRyYW5zZm9ybXMpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGxldCBtdHhUcmFuc2Zvcm1zOiBNYXRyaXg0eDRbXTtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLnRyYW5zZm9ybXMpXHJcbiAgICAgICAgbXR4VHJhbnNmb3JtcyA9IDxNYXRyaXg0eDRbXT5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb24udHJhbnNmb3Jtcyk7XHJcbiAgICAgIHRoaXMuZXh0cnVkZShtdHhUcmFuc2Zvcm1zKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmV4dHJ1ZGUodGhpcy5tdHhUcmFuc2Zvcm1zKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5NVVRBVEUpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICBwcml2YXRlIGV4dHJ1ZGUoX210eFRyYW5zZm9ybXM6IE1hdHJpeDR4NFtdID0gTWVzaEV4dHJ1c2lvbi5tdHhEZWZhdWx0cyk6IHZvaWQge1xyXG4gICAgICB0aGlzLm10eFRyYW5zZm9ybXMgPSA8TXV0YWJsZUFycmF5PE1hdHJpeDR4ND4+TXV0YWJsZUFycmF5LmZyb20oPE11dGFibGVBcnJheTxNYXRyaXg0eDQ+Pl9tdHhUcmFuc2Zvcm1zKTtcclxuICAgICAgbGV0IG5UcmFuc2Zvcm1zOiBudW1iZXIgPSBfbXR4VHJhbnNmb3Jtcy5sZW5ndGg7XHJcbiAgICAgIGxldCBuVmVydGljZXNTaGFwZTogbnVtYmVyID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgbmV3IHZlcnRleCBjbG91ZCwgY3VycmVudCBjbG91ZCBob2xkcyBNZXNoUG9seWdvblxyXG4gICAgICBsZXQgdmVydGljZXM6IFZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgYmFzZSBieSB0cmFuc2Zvcm1hdGlvbiBvZiBwb2x5Z29uIHdpdGggZmlyc3QgdHJhbnNmb3JtXHJcbiAgICAgIGxldCBiYXNlOiBWZXJ0ZXhbXSA9IHRoaXMudmVydGljZXMubWFwKChfdjogVmVydGV4KSA9PiBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIF9tdHhUcmFuc2Zvcm1zWzBdLCB0cnVlKSwgX3YudXYpKTtcclxuICAgICAgdmVydGljZXMucHVzaCguLi5iYXNlKTtcclxuICAgICAgLy8gY3JlYXRlIGxpZCBieSB0cmFuc2Zvcm1hdGlvbiBvZiBwb2x5Z29uIHdpdGggbGFzdCB0cmFuc2Zvcm1cclxuICAgICAgbGV0IGxpZDogVmVydGV4W10gPSB0aGlzLnZlcnRpY2VzLm1hcCgoX3Y6IFZlcnRleCkgPT4gbmV3IFZlcnRleChWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF92LnBvc2l0aW9uLCBfbXR4VHJhbnNmb3Jtc1tuVHJhbnNmb3JtcyAtIDFdLCB0cnVlKSwgX3YudXYpKTtcclxuICAgICAgdmVydGljZXMucHVzaCguLi5saWQpO1xyXG5cclxuICAgICAgLy8gcmVjcmVhdGUgYmFzZSBmYWNlcyB0byByZWNhbGN1bGF0ZSBub3JtYWxzXHJcbiAgICAgIHRoaXMuZmFjZXMgPSB0aGlzLmZhY2VzLm1hcCgoX2ZhY2U6IEZhY2UpID0+IG5ldyBGYWNlKHZlcnRpY2VzLCBfZmFjZS5pbmRpY2VzWzBdLCBfZmFjZS5pbmRpY2VzWzFdLCBfZmFjZS5pbmRpY2VzWzJdKSk7XHJcbiAgICAgIC8vIGNyZWF0ZSB0aGUgbGlkIGZhY2VzIHVzaW5nIHRoZSBpbmRpY2VzIG9mIHRoZSBiYXNlIGZhY2VzLCBidXQgd2l0aCBhbiBpbmRleCBvZmZzZXQgYW5kIHJldmVyc2Ugb3JkZXIgb2YgaW5kaWNlc1xyXG4gICAgICB0aGlzLmZhY2VzLnB1c2goLi4udGhpcy5mYWNlcy5tYXAoX2ZhY2UgPT5cclxuICAgICAgICBuZXcgRmFjZSh2ZXJ0aWNlcywgX2ZhY2UuaW5kaWNlc1syXSArIG5WZXJ0aWNlc1NoYXBlLCBfZmFjZS5pbmRpY2VzWzFdICsgblZlcnRpY2VzU2hhcGUsIF9mYWNlLmluZGljZXNbMF0gKyBuVmVydGljZXNTaGFwZSlcclxuICAgICAgKSk7XHJcblxyXG4gICAgICBmb3IgKGxldCB0OiBudW1iZXIgPSAwOyB0IDwgblRyYW5zZm9ybXM7IHQrKykge1xyXG4gICAgICAgIGxldCBtdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IF9tdHhUcmFuc2Zvcm1zW3RdO1xyXG4gICAgICAgIGxldCByZWZlclRvQ2xvc2U6IG51bWJlciA9IHZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgICBsZXQgd3JhcDogVmVydGV4W10gPSB0aGlzLnZlcnRpY2VzLm1hcCgoX3Y6IFZlcnRleCwgX2k6IG51bWJlcikgPT5cclxuICAgICAgICAgIG5ldyBWZXJ0ZXgoVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfdi5wb3NpdGlvbiwgbXR4VHJhbnNmb3JtLCB0cnVlKSwgbmV3IFZlY3RvcjIoX2kgLyBuVmVydGljZXNTaGFwZSwgdCAvIG5UcmFuc2Zvcm1zKSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHZlcnRpY2VzLnB1c2goLi4ud3JhcCk7XHJcbiAgICAgICAgdmVydGljZXMucHVzaChuZXcgVmVydGV4KHJlZmVyVG9DbG9zZSwgbmV3IFZlY3RvcjIoMSwgdCAvIG5UcmFuc2Zvcm1zKSkpO1xyXG4gICAgICAgIC8vIGlmIChpID4gMCAmJiBpIDwgblRyYW5zZm9ybXMgLSAxKVxyXG4gICAgICAgIC8vICAgdmVydGljZXMucHVzaCguLi53cmFwLm1hcCgoX3ZlY3RvcjogVmVjdG9yMykgPT4gX3ZlY3Rvci5jbG9uZSkpOyA8LSBubyBzbGljaW5nIGZvciBmbGF0IHNoYWRpbmcgeWV0Li4uXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNyZWF0ZSBpbmRpemVzIGZvciB3cmFwcGVyXHJcbiAgICAgIGZvciAobGV0IHQ6IG51bWJlciA9IDA7IHQgPCBuVHJhbnNmb3JtcyAtIDE7IHQrKylcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgblZlcnRpY2VzU2hhcGU7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPVxyXG4gICAgICAgICAgICArIDIgKiBuVmVydGljZXNTaGFwZSAvLyBiYXNlICYgbGlkIGFyZSBvZmZzZXRzIFxyXG4gICAgICAgICAgICArIHQgKiAoblZlcnRpY2VzU2hhcGUgKyAxKSAvLyBvZmZzZXQgZm9yIGVhY2ggdHJhbnNmb3JtYXRpb25cclxuICAgICAgICAgICAgKyBpO1xyXG4gICAgICAgICAgbGV0IHF1YWQ6IFF1YWQgPSBuZXcgUXVhZCh2ZXJ0aWNlcywgaW5kZXgsIGluZGV4ICsgblZlcnRpY2VzU2hhcGUgKyAxLCBpbmRleCArIG5WZXJ0aWNlc1NoYXBlICsgMiwgaW5kZXggKyAxLCBRVUFEU1BMSVQuQVRfMCk7XHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goLi4ucXVhZC5mYWNlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIHByaXZhdGUgY2FsY3VsYXRlUG9seWdvbkxlbmd0aHMoKTogbnVtYmVyW10ge1xyXG4gICAgLy8gICBsZXQgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xyXG4gICAgLy8gICBsZXQgZmlyc3Q6IFZlY3RvcjM7XHJcbiAgICAvLyAgIGxldCBwcmV2OiBWZWN0b3IzO1xyXG4gICAgLy8gICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgLy8gICAgIGxldCBjdXJyZW50OiBWZWN0b3IzID0gbmV3IFZlY3RvcjModGhpcy52ZXJ0aWNlc1tpXSwgdGhpcy52ZXJ0aWNlc1tpICsgMV0sIHRoaXMudmVydGljZXNbaSArIDJdKTtcclxuICAgIC8vICAgICBpZiAocHJldilcclxuICAgIC8vICAgICAgIHJlc3VsdC5wdXNoKFZlY3RvcjMuRElGRkVSRU5DRShjdXJyZW50LCBwcmV2KS5tYWduaXR1ZGUpO1xyXG4gICAgLy8gICAgIGVsc2VcclxuICAgIC8vICAgICAgIGZpcnN0ID0gY3VycmVudDtcclxuICAgIC8vICAgICBwcmV2ID0gY3VycmVudDtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gICByZXN1bHQucHVzaChWZWN0b3IzLkRJRkZFUkVOQ0UoZmlyc3QsIHByZXYpLm1hZ25pdHVkZSk7XHJcbiAgICAvLyAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAvLyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gICAgLyoqIEFsbG93cyB0byBjcmVhdGUgY3VzdG9tIG1lc2hlcyBmcm9tIGdpdmVuIERhdGEgKi9cclxuICAgIGV4cG9ydCBjbGFzcyBNZXNoRnJvbURhdGEgZXh0ZW5kcyBNZXNoIHtcclxuICAgICAgICAgICAgcHJvdGVjdGVkIHZlcnRpY2VzVG9TZXQ6IEZsb2F0MzJBcnJheTtcclxuICAgICAgICAgICAgcHJvdGVjdGVkIHRleHR1cmVVVnNUb1NldDogRmxvYXQzMkFycmF5O1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgaW5kaWNlc1RvU2V0OiBVaW50MTZBcnJheTtcclxuICAgICAgICAgICAgcHJvdGVjdGVkIGZhY2VOb3JtYWxzVG9TZXQ6IEZsb2F0MzJBcnJheTtcclxuICAgICAgICBcclxuICAgICAgICBwdWJsaWMgY29uc3RydWN0b3IoX3ZlcnRpY2VzOiBGbG9hdDMyQXJyYXksIF90ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXksIF9pbmRpY2VzOiBVaW50MTZBcnJheSwgX2ZhY2VOb3JtYWxzOiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1RvU2V0ID0gX3ZlcnRpY2VzO1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVVVnNUb1NldCA9IF90ZXh0dXJlVVZzO1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXNUb1NldCA9IF9pbmRpY2VzO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VOb3JtYWxzVG9TZXQgPSBfZmFjZU5vcm1hbHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXNUb1NldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBjcmVhdGVUZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVVVnNUb1NldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBjcmVhdGVJbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kaWNlc1RvU2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIGNyZWF0ZUZsYXROb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY2VOb3JtYWxzVG9TZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIE1lc2ggbG9hZGVkIGZyb20gYSBHTFRGLWZpbGVcclxuICAgKiBAYXV0aG9yIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hHTFRGIGV4dGVuZHMgTWVzaCB7XHJcblxyXG4gICAgcHJpdmF0ZSB1cmlHTFRGOiBzdHJpbmc7XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnVyaUdMVEYgPSB0aGlzLnVyaUdMVEY7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgY29uc3QgbG9hZGVyOiBHTFRGTG9hZGVyID0gYXdhaXQgR0xURkxvYWRlci5MT0FEKF9zZXJpYWxpemF0aW9uLnVyaUdMVEYpO1xyXG4gICAgICBhd2FpdCB0aGlzLmxvYWQobG9hZGVyLCBsb2FkZXIuZ2x0Zi5tZXNoZXMuZmluZEluZGV4KGdsdGZNZXNoID0+IGdsdGZNZXNoLm5hbWUgPT0gdGhpcy5uYW1lKSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF9sb2FkZXI6IEdMVEZMb2FkZXIsIF9pTWVzaDogbnVtYmVyKTogUHJvbWlzZTxNZXNoR0xURj4ge1xyXG4gICAgICBjb25zdCBnbHRmTWVzaDogR0xURi5NZXNoID0gX2xvYWRlci5nbHRmLm1lc2hlc1tfaU1lc2hdO1xyXG4gICAgICB0aGlzLm5hbWUgPSBnbHRmTWVzaC5uYW1lO1xyXG5cclxuICAgICAgdGhpcy5yZW5kZXJNZXNoID0gbmV3IFJlbmRlck1lc2godGhpcyk7XHJcbiAgICAgIFJlZmxlY3Quc2V0KHRoaXMucmVuZGVyTWVzaCwgXCLGkmluZGljZXNcIiwgYXdhaXQgX2xvYWRlci5nZXRVaW50MTZBcnJheShnbHRmTWVzaC5wcmltaXRpdmVzWzBdLmluZGljZXMpKTtcclxuICAgICAgUmVmbGVjdC5zZXQodGhpcy5yZW5kZXJNZXNoLCBcIsaSdmVydGljZXNcIiwgYXdhaXQgX2xvYWRlci5nZXRGbG9hdDMyQXJyYXkoZ2x0Zk1lc2gucHJpbWl0aXZlc1swXS5hdHRyaWJ1dGVzLlBPU0lUSU9OKSk7XHJcbiAgICAgIFJlZmxlY3Quc2V0KHRoaXMucmVuZGVyTWVzaCwgXCLGkm5vcm1hbHNcIiwgYXdhaXQgX2xvYWRlci5nZXRGbG9hdDMyQXJyYXkoZ2x0Zk1lc2gucHJpbWl0aXZlc1swXS5hdHRyaWJ1dGVzLk5PUk1BTCkpOyBcclxuICAgICAgUmVmbGVjdC5zZXQodGhpcy5yZW5kZXJNZXNoLCBcIsaSdGV4dHVyZVVWc1wiLCBhd2FpdCBfbG9hZGVyLmdldEZsb2F0MzJBcnJheShnbHRmTWVzaC5wcmltaXRpdmVzWzBdLmF0dHJpYnV0ZXMuVEVYQ09PUkRfMCkpO1xyXG4gICAgICAvLyBsZXQgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyA9ICB0aGlzLmdldFJlbmRlckJ1ZmZlcnMoU2hhZGVyRmxhdCk7IC8vIGhvdGZpeCB0byBjcmVhdGUgcmVuZGVyTWVzaFxyXG5cclxuICAgICAgdGhpcy51cmlHTFRGID0gX2xvYWRlci51cmk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGxhenktZ2V0dGVyIHRvIHJldHJpZXZlIHRoZSBmYWNlIG5vcm1hbHMuIEluaXRpYWxpemUgZmFjZXMgb24gY2FsbC5cclxuICAgIFxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipTaW1wbGUgV2F2ZWZyb250IE9CSiBpbXBvcnQuIFRha2VzIGEgd2F2ZWZyb250IG9iaiBzdHJpbmcuIFRvIExvYWQgZnJvbSBhIGZpbGUgdXJsLCB1c2UgdGhlXHJcbiAgICogc3RhdGljIExPQUQgTWV0aG9kLiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIHRyaWFuZ3VsYXRlZCBNZXNoZXNcclxuICAgKiAoYWN0aXZhdGUgJ0dlb21lbnRyeSDihpIgVHJpYW5ndWxhdGUgRmFjZXMnIGluIEJsZW5kZXJzIG9iaiBleHBvcnRlcilcclxuICAgKiBAdG9kbyBVVnMsIExvYWQgTWF0ZXJpYWxzLCBTdXBwb3J0IFF1YWRzXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSAyMDIxIHwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyICovXHJcblxyXG4gIGludGVyZmFjZSBGYWNlSW5mbyB7XHJcbiAgICBpUG9zaXRpb246IG51bWJlcjtcclxuICAgIGlVVjogbnVtYmVyO1xyXG4gICAgaU5vcm1hbDogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hPYmogZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaE9iaik7XHJcbiAgICBwdWJsaWMgdXJsOiBSZXF1ZXN0SW5mbztcclxuXHJcbiAgICAvLyBwcm90ZWN0ZWQgdmVydHM6IG51bWJlcltdID0gW107XHJcbiAgICAvLyBwcm90ZWN0ZWQgdXZzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgLy8gcHJvdGVjdGVkIGluZHM6IG51bWJlcltdID0gW107XHJcbiAgICAvLyBwcm90ZWN0ZWQgZmFjZW5vcm1hbHM6IG51bWJlcltdID0gW107XHJcbiAgICAvLyBwcm90ZWN0ZWQgZmFjZWNyb3NzcHJvZHVjdHM6IG51bWJlcltdID0gW107XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lPzogc3RyaW5nLCBfdXJsPzogUmVxdWVzdEluZm8pIHtcclxuICAgICAgc3VwZXIoX25hbWUpOyB7XHJcbiAgICAgICAgaWYgKF91cmwpIHtcclxuICAgICAgICAgIHRoaXMubG9hZChfdXJsKTtcclxuICAgICAgICAgIGlmICghX25hbWUpXHJcbiAgICAgICAgICAgIF9uYW1lID0gX3VybC50b1N0cmluZygpLnNwbGl0KFwiL1wiKS5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfbmFtZSlcclxuICAgICAgICAgIF9uYW1lID0gXCJNZXNoT2JqXCI7XHJcblxyXG4gICAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgdGhlIGltYWdlIGZyb20gdGhlIGdpdmVuIHVybFxyXG4gICAgICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG4gICAgICBsZXQgdXJsOiBzdHJpbmcgPSBuZXcgVVJMKHRoaXMudXJsLnRvU3RyaW5nKCksIFByb2plY3QuYmFzZVVSTCkudG9TdHJpbmcoKTtcclxuICAgICAgbGV0IGRhdGE6IHN0cmluZyA9IGF3YWl0IChhd2FpdCBmZXRjaCh1cmwpKS50ZXh0KCk7XHJcbiAgICAgIHRoaXMucGFyc2VPYmooZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNwbGl0cyB1cCB0aGUgb2JqIHN0cmluZyBpbnRvIHNlcGFyYXRlIGFycmF5cyBmb3IgZWFjaCBkYXRhdHlwZSAqL1xyXG4gICAgcHVibGljIHBhcnNlT2JqKGRhdGE6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IGRhdGEuc3BsaXQoXCJcXG5cIik7XHJcblxyXG4gICAgICBsZXQgcG9zaXRpb25zOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgbGV0IHV2czogVmVjdG9yMltdID0gW107XHJcbiAgICAgIGxldCBmYWNlSW5mbzogRmFjZUluZm9bXSA9IFtdO1xyXG5cclxuICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcclxuXHJcbiAgICAgICAgaWYgKCFsaW5lIHx8IGxpbmUuc3RhcnRzV2l0aChcIiNcIikpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gbGluZS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgcGFydHMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgLy9WZXJ0ZXggLSBleGFtcGxlOiB2IDAuNzAgLTAuNDUgLTAuNTJcclxuICAgICAgICBpZiAoIWxpbmUgfHwgbGluZS5zdGFydHNXaXRoKFwidiBcIikpXHJcbiAgICAgICAgICBwb3NpdGlvbnMucHVzaChuZXcgVmVjdG9yMyguLi5wYXJ0cy5tYXAoeCA9PiAreCkpKTtcclxuXHJcbiAgICAgICAgLy9UZXhjb29yZCAtIGV4YW1wbGU6IHZ0IDAuNTQ1NDU0IDAuNDcyMzgyXHJcbiAgICAgICAgZWxzZSBpZiAoIWxpbmUgfHwgbGluZS5zdGFydHNXaXRoKFwidnQgXCIpKSB1dnMucHVzaChuZXcgVmVjdG9yMiguLi5wYXJ0cy5tYXAoeCA9PiAreCkpKTtcclxuXHJcbiAgICAgICAgLypGYWNlIEluZGljZXMgLSBleGFtcGxlOiBmIDEvMS8xIDIvMi8xIDMvMy8xIC0tPlxyXG4gICAgICAgIHZlcnRleDEvdGV4Y29vcmQxL25vcm1hbDEgdmVydGV4Mi90ZXhjb29yZDIvbm9ybWFsMiB2ZXJ0ZXgzL3RleGNvb3JkMy9ub3JtYWwzKi9cclxuICAgICAgICBlbHNlIGlmICghbGluZSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJmIFwiKSlcclxuICAgICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICAgICAgZmFjZUluZm8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgaVBvc2l0aW9uOiArcGFydHNbaV0uc3BsaXQoXCIvXCIpWzBdIC0gMSxcclxuICAgICAgICAgICAgICBpVVY6ICtwYXJ0c1tpXS5zcGxpdChcIi9cIilbMV0gLSAxLFxyXG4gICAgICAgICAgICAgIGlOb3JtYWw6ICtwYXJ0c1tpXS5zcGxpdChcIi9cIilbMl0gLSAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKC4uLnBvc2l0aW9ucy5tYXAoKF9wOiBWZWN0b3IzKSA9PiBuZXcgVmVydGV4KF9wKSkpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgZmFjZUluZm8ubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICBsZXQgaW5kaWNlczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCB2OiBudW1iZXIgPSAwOyB2IDwgMzsgdisrKSB7XHJcbiAgICAgICAgICBsZXQgaW5mbzogRmFjZUluZm8gPSBmYWNlSW5mb1tpICsgdl07XHJcbiAgICAgICAgICBsZXQgaW5kZXg6IG51bWJlciA9IGluZm8uaVBvc2l0aW9uO1xyXG4gICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaW5kZXhdLnV2KSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaChuZXcgVmVydGV4KGluZm8uaVBvc2l0aW9uKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzW2luZGV4XS51diA9IHV2c1tpbmZvLmlVVl07XHJcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgaW5kaWNlc1swXSwgaW5kaWNlc1sxXSwgaW5kaWNlc1syXSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnVybCA9IHRoaXMudXJsO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgdGhpcy5sb2FkKF9zZXJpYWxpemF0aW9uLnVybCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IudXJsKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLmxvYWQoX211dGF0b3IudXJsKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHB5cmFtaWQgd2l0aCBlZGdlcyBhdCB0aGUgYmFzZSBvZiBsZW5ndGggMSBhbmQgYSBoZWlnaHQgb2YgMS4gVGhlIHNpZGVzIGNvbnNpc3Rpbmcgb2Ygb25lLCB0aGUgYmFzZSBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHBsYWludGV4dFxyXG4gICAqICAgICAgICAgICAgICAgNFxyXG4gICAqICAgICAgICAgICAgICAvXFxgLlxyXG4gICAqICAgICAgICAgICAgMy9fX1xcX1xcIDJcclxuICAgKiAgICAgICAgICAgMC9fX19fXFwvMVxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hQeXJhbWlkIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQeXJhbWlkKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFB5cmFtaWRcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIC8vIHRoaXMuY3JlYXRlKCk7XHJcblxyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKFxyXG4gICAgICAgIC8vIGdyb3VuZCB2ZXJ0aWNlc1xyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC4wLCAwLjUpLCBuZXcgVmVjdG9yMigwLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuMCwgMC41KSwgbmV3IFZlY3RvcjIoMSwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAwLjAsIC0wLjUpLCBuZXcgVmVjdG9yMigxLCAwKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAwLjAsIC0wLjUpLCBuZXcgVmVjdG9yMigwLCAwKSksXHJcbiAgICAgICAgLy8gdGlwICh2ZXJ0ZXggIzQpXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjAsIDEuMCwgMC4wKSwgbmV3IFZlY3RvcjIoMC41LCAwLjUpKSxcclxuICAgICAgICAvLyBmbG9vciBhZ2FpbiBmb3IgZG93bnNpZGUgdGV4dHVyZVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMCwgbmV3IFZlY3RvcjIoMCwgMCkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMSwgbmV3IFZlY3RvcjIoMSwgMCkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMiwgbmV3IFZlY3RvcjIoMSwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMywgbmV3IFZlY3RvcjIoMCwgMSkpXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuZmFjZXMgPSBbXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMCwgMSksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMSwgMiksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMiwgMyksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMywgMCksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNSArIDAsIDUgKyAyLCA1ICsgMSksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNSArIDAsIDUgKyAzLCA1ICsgMilcclxuICAgICAgXTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBxdWFkIHdpdGggZWRnZXMgb2YgbGVuZ3RoIDEsIHRoZSBmYWNlIGNvbnNpc3Rpbmcgb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgMCBfXyAzXHJcbiAgICogICAgICAgICB8X1xcfFxyXG4gICAqICAgICAgICAxICAgIDIgICAgICAgICAgICAgXHJcbiAgICogYGBgIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFF1YWQgZXh0ZW5kcyBNZXNoUG9seWdvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hRdWFkKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc2hhcGU6IFZlY3RvcjJbXSA9IFtcclxuICAgICAgbmV3IFZlY3RvcjIoLTAuNSwgMC41KSwgbmV3IFZlY3RvcjIoLTAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDAuNSwgMC41KVxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFF1YWRcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSwgTWVzaFF1YWQuc2hhcGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC8vIGZsYXQgZXF1YWxzIHNtb290aFxyXG4gICAgLy8gcHVibGljIGdldCB2ZXJ0aWNlc0ZsYXQoKTogRmxvYXQzMkFycmF5IHsgcmV0dXJuIHRoaXMudmVydGljZXM7IH1cclxuICAgIC8vIHB1YmxpYyBnZXQgaW5kaWNlc0ZsYXQoKTogVWludDE2QXJyYXkgeyByZXR1cm4gdGhpcy5pbmRpY2VzOyB9XHJcbiAgICAvLyBwdWJsaWMgZ2V0IG5vcm1hbHNGbGF0KCk6IEZsb2F0MzJBcnJheSB7IHJldHVybiB0aGlzLm5vcm1hbHNWZXJ0ZXg7IH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNnZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmNyZWF0ZShNZXNoUXVhZC5zaGFwZSwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaGFwZTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmZpdFRleHR1cmU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKiBcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHR5cGUgdGFrZXMgeCBhbmQgeiBhcyBQYXJhbWV0ZXJzIGFuZCByZXR1cm5zIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kIDEgdG8gYmUgdXNlZCBhcyBhIGhlaWdodG1hcC4gXHJcbiAgICogeCAqIHogKiAyIHJlcHJlc2VudCB0aGUgYW1vdXQgb2YgZmFjZXMgd2hpY2ggYXJlIGNyZWF0ZWQuIEFzIGEgcmVzdWx0IHlvdSBnZXQgMSB2ZXJ0ZXggbW9yZSBpbiBlYWNoIGRpcmVjdGlvbiAoeCBhbmQgeiBheGlzKVxyXG4gICAqIFRoZSB5LWNvbXBvbmVudCBvZiB0aGUgcmVzdWx0aW5nIG1lc2ggbWF5IGJlIG1vdmVkIHRvIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIGEgbWF4aW11bSBoZWlnaHQuXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIEhlaWdodE1hcEZ1bmN0aW9uID0gKHg6IG51bWJlciwgejogbnVtYmVyKSA9PiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZXJ0aWNhbCBwcm9qZWN0aW9uIG9mIGEgZ2l2ZW4gcG9zaXRpb24gb250byB0aGUgdGVycmFpblxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXJyYWluSW5mbyB7XHJcbiAgICAvKiogdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCB2ZXJ0aWNhbGx5IHByb2plY3RlZCBvbiB0aGUgdGVycmFpbiBpbiB3b3JsZCBjb29yZGluYXRlcyAqL1xyXG4gICAgcG9zaXRpb246IFZlY3RvcjM7XHJcbiAgICAvKiogdGhlIG5vcm1hbCBvZiB0aGUgZmFjZSBvZiB0aGUgdGVycmFpbiB1bmRlciB0aGUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMgKi9cclxuICAgIG5vcm1hbDogVmVjdG9yMztcclxuICAgIC8qKiB2ZXJ0aWNhbCBkaXN0YW5jZSBvZiB0aGUgcG9pbnQgdG8gdGhlIHRlcnJhaW4sIG5lZ2F0aXZlIGlmIGJlbG93ICovXHJcbiAgICBkaXN0YW5jZTogbnVtYmVyO1xyXG4gICAgLyoqIHRoZSBwb3NpdGlvbiBpbiBmYWNlIGNvb3JkaW5hdGVzICovXHJcbiAgICBwb3NpdGlvbkZhY2U6IFZlY3RvcjM7XHJcbiAgICAvKiogdGhlIGluZGV4IG9mIHRoZSBmYWNlIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgKi9cclxuICAgIGluZGV4OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHRlcnJhaW4gc3ByZWFkcyBvdXQgaW4gdGhlIHgtei1wbGFuZSwgeSBpcyB0aGUgaGVpZ2h0IGRlcml2ZWQgZnJvbSB0aGUgaGVpZ2h0bWFwIGZ1bmN0aW9uLiBcclxuICAgKiBUaGUgdGVycmFpbiBpcyBhbHdheXMgMSBpbiBzaXplIGluIGFsbCBkaW1lbnNpb25zLCBmaXR0aW5nIGludG8gdGhlIHVuaXQtY3ViZS4gXHJcbiAgICogUmVzb2x1dGlvbiBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgcXVhZHMgaW4geCBhbmQgeiBkaW1lbnNpb24sIHNjYWxlIHRoZSBmYWN0b3IgYXBwbGllZCB0byB0aGUgeCx6LWNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGUgaGVpZ2h0bWFwIGZ1bmN0aW9uLlxyXG4gICAqIFN0YW5kYXJkIGZ1bmN0aW9uIGlzIHRoZSBzaW1wbGV4IG5vaXNlIGltcGxlbWVudGVkIHdpdGggRlVER0UsIGJ1dCBhbm90aGVyIGZ1bmN0aW9uIGNhbiBiZSBnaXZlbi5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyIHwgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgTW9yaXR6IEJlYXVncmFuZCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hUZXJyYWluIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hUZXJyYWluKTtcclxuICAgIHByb3RlY3RlZCByZXNvbHV0aW9uOiBWZWN0b3IyO1xyXG4gICAgcHJvdGVjdGVkIHNjYWxlOiBWZWN0b3IyO1xyXG4gICAgcHJvdGVjdGVkIHNlZWQ6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBoZWlnaHRNYXBGdW5jdGlvbjogSGVpZ2h0TWFwRnVuY3Rpb24gPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoVGVycmFpblwiLCBfcmVzb2x1dGlvbjogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDIpLCBfc2NhbGVJbnB1dDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKCksIF9mdW5jdGlvbk9yU2VlZDogSGVpZ2h0TWFwRnVuY3Rpb24gfCBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX3Jlc29sdXRpb24sIF9zY2FsZUlucHV0LCBfZnVuY3Rpb25PclNlZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoX3Jlc29sdXRpb246IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgyKSwgX3NjYWxlSW5wdXQ6IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgpLCBfZnVuY3Rpb25PclNlZWQ6IEhlaWdodE1hcEZ1bmN0aW9uIHwgbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuc2VlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIoTWF0aC5yb3VuZChfcmVzb2x1dGlvbi54KSwgTWF0aC5yb3VuZChfcmVzb2x1dGlvbi55KSk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSBfc2NhbGVJbnB1dC5jbG9uZTtcclxuXHJcbiAgICAgIGlmIChfZnVuY3Rpb25PclNlZWQgaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuICAgICAgICB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uID0gX2Z1bmN0aW9uT3JTZWVkO1xyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgKF9mdW5jdGlvbk9yU2VlZCkgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIHRoaXMuc2VlZCA9IF9mdW5jdGlvbk9yU2VlZDtcclxuICAgICAgICBsZXQgcHJuZzogUmFuZG9tID0gbmV3IFJhbmRvbSh0aGlzLnNlZWQpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBuZXcgTm9pc2UyKCgpID0+IHBybmcuZ2V0Tm9ybSgpKS5zYW1wbGU7IC8vIFRPRE8gY2FsbCBQUk5HXHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBuZXcgTm9pc2UyKCkuc2FtcGxlO1xyXG5cclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAvL0l0ZXJhdGUgb3ZlciBlYWNoIGNlbGwgdG8gZ2VuZXJhdGUgZ3JpZCBvZiB2ZXJ0aWNlc1xyXG4gICAgICBmb3IgKGxldCB6OiBudW1iZXIgPSAwOyB6IDw9IHRoaXMucmVzb2x1dGlvbi55OyB6KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDw9IHRoaXMucmVzb2x1dGlvbi54OyB4KyspIHtcclxuICAgICAgICAgIGxldCB4Tm9ybTogbnVtYmVyID0geCAvIHRoaXMucmVzb2x1dGlvbi54O1xyXG4gICAgICAgICAgbGV0IHpOb3JtOiBudW1iZXIgPSB6IC8gdGhpcy5yZXNvbHV0aW9uLnk7XHJcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFZlcnRleChcclxuICAgICAgICAgICAgbmV3IFZlY3RvcjMoeE5vcm0gLSAwLjUsIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24oeE5vcm0gKiB0aGlzLnNjYWxlLngsIHpOb3JtICogdGhpcy5zY2FsZS55KSwgek5vcm0gLSAwLjUpLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yMih4Tm9ybSwgek5vcm0pXHJcbiAgICAgICAgICApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBxdWFkczogUXVhZFtdID0gW107XHJcbiAgICAgIGxldCBzcGxpdDogUVVBRFNQTElUID0gUVVBRFNQTElULkFUXzA7XHJcbiAgICAgIGZvciAobGV0IHo6IG51bWJlciA9IDA7IHogPCB0aGlzLnJlc29sdXRpb24ueTsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8IHRoaXMucmVzb2x1dGlvbi54OyB4KyspIHtcclxuICAgICAgICAgIHF1YWRzLnB1c2gobmV3IFF1YWQoXHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMsXHJcbiAgICAgICAgICAgICh4ICsgMCkgKyAoeiArIDApICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMCkgKyAoeiArIDEpICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMSkgKyAoeiArIDEpICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMSkgKyAoeiArIDApICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgIHNwbGl0XHJcbiAgICAgICAgICApKTtcclxuICAgICAgICAgIHNwbGl0ID0gKHNwbGl0ID09IFFVQURTUExJVC5BVF8wKSA/IFFVQURTUExJVC5BVF8xIDogUVVBRFNQTElULkFUXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJlc29sdXRpb24ueCAlIDIgPT0gMCkgLy8gcmV2ZXJzZSBsYXN0IHNwbGl0IGNoYW5nZSBpZiB4LXJlc29sdXRpb24gaXMgZXZlblxyXG4gICAgICAgICAgc3BsaXQgPSAoc3BsaXQgPT0gUVVBRFNQTElULkFUXzApID8gUVVBRFNQTElULkFUXzEgOiBRVUFEU1BMSVQuQVRfMDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZhY2VzID0gcXVhZHMuZmxhdE1hcCgocXVhZDogUXVhZCkgPT4gcXVhZC5mYWNlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZXJ0aWNhbCBwcm9qZWN0aW9uIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBvbnRvIHRoZSB0ZXJyYWluLlxyXG4gICAgICogUGFzcyB0aGUgb3ZlcmFsbCB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgdGVycmFpbiBpZiB0aGUgcG9zaXRpb24gaXMgZ2l2ZW4gaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBJZiBhdCBoYW5kLCBwYXNzIHRoZSBpbnZlcnNlIHRvbyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRlcnJhaW5JbmZvKF9wb3NpdGlvbjogVmVjdG9yMywgX210eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSwgX210eEludmVyc2U/OiBNYXRyaXg0eDQpOiBUZXJyYWluSW5mbyB7XHJcbiAgICAgIGlmICghX210eEludmVyc2UpXHJcbiAgICAgICAgX210eEludmVyc2UgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKF9tdHhXb3JsZCk7XHJcblxyXG4gICAgICBsZXQgdGVycmFpbkluZm86IFRlcnJhaW5JbmZvID0gbmV3IFRlcnJhaW5JbmZvO1xyXG5cclxuICAgICAgbGV0IHBvc0xvY2FsOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9zaXRpb24sIF9tdHhJbnZlcnNlLCB0cnVlKTtcclxuXHJcblxyXG4gICAgICBsZXQgejogbnVtYmVyID0gTWF0aC5mbG9vcigocG9zTG9jYWwueiArIDAuNSkgKiB0aGlzLnJlc29sdXRpb24ueSk7XHJcbiAgICAgIGxldCB4OiBudW1iZXIgPSBNYXRoLmZsb29yKChwb3NMb2NhbC54ICsgMC41KSAqIHRoaXMucmVzb2x1dGlvbi54KTtcclxuICAgICAgaWYgKHogPCAwIHx8IHogPiB0aGlzLnJlc29sdXRpb24ueSAtIDEgfHwgeCA8IDAgfHwgeCA+IHRoaXMucmVzb2x1dGlvbi54IC0gMSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gKHogKiB0aGlzLnJlc29sdXRpb24ueCArIHgpICogMjtcclxuICAgICAgbGV0IGZhY2U6IEZhY2UgPSB0aGlzLmZhY2VzW2luZGV4XTtcclxuXHJcbiAgICAgIGxldCByYXk6IFJheSA9IG5ldyBSYXkoVmVjdG9yMy5ZKCksIHBvc0xvY2FsKTtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IzID0gcmF5LmludGVyc2VjdEZhY2VQbGFuZShmYWNlKTtcclxuICAgICAgaWYgKCFmYWNlLmlzSW5zaWRlKHBvaW50KSkge1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbaW5kZXhdO1xyXG4gICAgICAgIHBvaW50ID0gcmF5LmludGVyc2VjdEZhY2VQbGFuZShmYWNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGVycmFpbkluZm8uaW5kZXggPSBpbmRleDtcclxuICAgICAgdGVycmFpbkluZm8ucG9zaXRpb25GYWNlID0gcG9pbnQ7XHJcbiAgICAgIHRlcnJhaW5JbmZvLnBvc2l0aW9uID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihwb2ludCwgX210eFdvcmxkLCB0cnVlKTtcclxuICAgICAgdGVycmFpbkluZm8ubm9ybWFsID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihmYWNlLm5vcm1hbCwgTWF0cml4NHg0LlRSQU5TUE9TRShfbXR4SW52ZXJzZSksIGZhbHNlKTtcclxuICAgICAgdGVycmFpbkluZm8uZGlzdGFuY2UgPSBfcG9zaXRpb24ueSAtIHRlcnJhaW5JbmZvLnBvc2l0aW9uLnk7XHJcblxyXG4gICAgICByZXR1cm4gdGVycmFpbkluZm87XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNlZWQgPSB0aGlzLnNlZWQ7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2NhbGUgPSB0aGlzLnNjYWxlLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb24uc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlc29sdXRpb24uZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucmVzb2x1dGlvbik7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2NhbGUuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uc2NhbGUpO1xyXG4gICAgICB0aGlzLnNlZWQgPSBfc2VyaWFsaXphdGlvbi5zZWVkO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnJlc29sdXRpb24sIHRoaXMuc2NhbGUsIHRoaXMuc2VlZCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy5yZXNvbHV0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnNlZWQpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiTWVzaFRlcnJhaW4udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHBsYW5hciBHcmlkIGFuZCBhcHBsaWVzIGEgSGVpZ2h0bWFwLUZ1bmN0aW9uIHRvIGl0LlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxIHwgTW9yaXR6IEJlYXVncmFuZCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hSZWxpZWYgZXh0ZW5kcyBNZXNoVGVycmFpbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hSZWxpZWYpO1xyXG4gICAgcHJpdmF0ZSB0ZXh0dXJlOiBUZXh0dXJlSW1hZ2UgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoUmVsaWVmXCIsIF90ZXh0dXJlOiBUZXh0dXJlSW1hZ2UgPSBudWxsKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lLCBWZWN0b3IyLk9ORSgyKSwgdW5kZWZpbmVkLCAoX3g6IG51bWJlciwgX3o6IG51bWJlcikgPT4gMCk7XHJcbiAgICAgIHRoaXMuc2V0VGV4dHVyZShfdGV4dHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlSGVpZ2h0TWFwRnVuY3Rpb24oX3RleHR1cmU6IFRleHR1cmVJbWFnZSk6IEhlaWdodE1hcEZ1bmN0aW9uIHtcclxuICAgICAgbGV0IGFycmF5OiBVaW50OENsYW1wZWRBcnJheSA9IE1lc2hSZWxpZWYudGV4dHVyZVRvQ2xhbXBlZEFycmF5KF90ZXh0dXJlKTtcclxuICAgICAgbGV0IGhlaWdodE1hcEZ1bmN0aW9uOiBIZWlnaHRNYXBGdW5jdGlvbiA9IChfeDogbnVtYmVyLCBfejogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgbGV0IHBpeGVsOiBudW1iZXIgPSBNYXRoLnJvdW5kKF96ICogX3RleHR1cmUuaW1hZ2Uud2lkdGggKyBfeCk7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W3BpeGVsICogNF0gLyAyNTU7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBoZWlnaHRNYXBGdW5jdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyB0ZXh0dXJlVG9DbGFtcGVkQXJyYXkoX3RleHR1cmU6IFRleHR1cmVJbWFnZSk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICBjYW52YXMud2lkdGggPSBfdGV4dHVyZS5pbWFnZS53aWR0aDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IF90ZXh0dXJlLmltYWdlLmhlaWdodDtcclxuXHJcbiAgICAgIGxldCBjcmM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGNyYy5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgY3JjLmRyYXdJbWFnZShfdGV4dHVyZS5pbWFnZSwgMCwgMCk7XHJcblxyXG4gICAgICByZXR1cm4gY3JjLmdldEltYWdlRGF0YSgwLCAwLCBfdGV4dHVyZS5pbWFnZS53aWR0aCwgX3RleHR1cmUuaW1hZ2UuaGVpZ2h0KS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRUZXh0dXJlKF90ZXh0dXJlOiBUZXh0dXJlSW1hZ2UgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIGlmICghX3RleHR1cmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aGlzLnRleHR1cmUgPSBfdGV4dHVyZTtcclxuICAgICAgbGV0IHJlc29sdXRpb246IFZlY3RvcjIgPSBfdGV4dHVyZSA/IG5ldyBWZWN0b3IyKF90ZXh0dXJlLmltYWdlLndpZHRoIC0gMSwgX3RleHR1cmUuaW1hZ2UuaGVpZ2h0IC0gMSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgIHN1cGVyLmNyZWF0ZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uLCBNZXNoUmVsaWVmLmNyZWF0ZUhlaWdodE1hcEZ1bmN0aW9uKF90ZXh0dXJlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5zZWVkO1xyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5zY2FsZTtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24ucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLnRleHR1cmUpXHJcbiAgICAgICAgc2VyaWFsaXphdGlvbi5pZFRleHR1cmUgPSB0aGlzLnRleHR1cmUuaWRSZXNvdXJjZTtcclxuXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uaWRUZXh0dXJlKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gPFRleHR1cmVJbWFnZT5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRoaXMudGV4dHVyZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci50ZXh0dXJlKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLnNldFRleHR1cmUoX211dGF0b3IudGV4dHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zZWVkO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2NhbGU7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8gLzxyZWZlcmVuY2UgcGF0aD1cIk1lc2hQb2x5Z29uLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYSByb3RhdGlvbiBvZiBhIHBvbHlnb24gYXJvdW5kIHRoZSB5LWF4aXNcclxuICAgKiBgYGBwbGFpbnRleHQgICAgICAgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICogICAgICAgICAgICAgICAgICBfICDihpEgMF8xXHJcbiAgICogICAgICAgICAgICAgICAgIOKUgiAgIOKUguKGkngg4pSCMiAgICAgICAgIFxyXG4gICAqICAgICAgICAgICAgICAgICAg4pWyICDilIIgIOKVsTMgICAgICAgICBcclxuICAgKiAgICAgICAgICAgICAgICAgIOKVsSAg4pSCICDilbIgICBcclxuICAgKiAgICAgICAgICAgICAgICAg4pWxX19f4pSCX19f4pWyNCBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICA1XHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUm90YXRpb24gZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFJvdGF0aW9uKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdmVydGljZXNEZWZhdWx0OiBWZWN0b3IyW10gPSBbIC8vIGxpbmUgaXMgdGhlIG1pbmltYWwgc2hhcGVcclxuICAgICAgbmV3IFZlY3RvcjIoMC41LCAwLjUpLFxyXG4gICAgICBuZXcgVmVjdG9yMigwLjUsIC0wLjUpXHJcbiAgICBdO1xyXG4gICAgcHJvdGVjdGVkIHNoYXBlOiBNdXRhYmxlQXJyYXk8VmVjdG9yMj4gPSBuZXcgTXV0YWJsZUFycmF5PFZlY3RvcjI+KCk7XHJcbiAgICBwcm90ZWN0ZWQgbG9uZ2l0dWRlczogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoUm90YXRpb25cIiwgX3NoYXBlOiBWZWN0b3IyW10gPSBNZXNoUm90YXRpb24udmVydGljZXNEZWZhdWx0LCBfbG9uZ2l0dWRlczogbnVtYmVyID0gMykge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMucm90YXRlKF9zaGFwZSwgX2xvbmdpdHVkZXMpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIk11dGF0b3JcIiwgdGhpcy5nZXRNdXRhdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZXQgbWluVmVydGljZXMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNoYXBlID0gU2VyaWFsaXplci5zZXJpYWxpemVBcnJheShWZWN0b3IyLCB0aGlzLnNoYXBlKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzID0gdGhpcy5sb25naXR1ZGVzO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGxldCBzaGFwZTogVmVjdG9yMltdID0gPFZlY3RvcjJbXT5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb24uc2hhcGUpO1xyXG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBfc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzO1xyXG4gICAgICB0aGlzLnJvdGF0ZShzaGFwZSwgdGhpcy5sb25naXR1ZGVzKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLnJvdGF0ZSh0aGlzLnNoYXBlLCB0aGlzLmxvbmdpdHVkZXMpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJvdGVjdGVkIHJvdGF0ZShfc2hhcGU6IFZlY3RvcjJbXSwgX2xvbmdpdHVkZXM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuc2hhcGUgPSA8TXV0YWJsZUFycmF5PFZlY3RvcjI+Pk11dGFibGVBcnJheS5mcm9tKF9zaGFwZS5tYXAoX3ZlcnRleCA9PiBfdmVydGV4LmNsb25lKSk7XHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IE1hdGgucm91bmQoX2xvbmdpdHVkZXMpO1xyXG4gICAgICBsZXQgYW5nbGU6IG51bWJlciA9IDM2MCAvIHRoaXMubG9uZ2l0dWRlcztcclxuICAgICAgbGV0IG10eFJvdGF0ZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1koYW5nbGUpO1xyXG4gICAgICAvLyBjb3B5IG9yaWdpbmFsIHBvbHlnb24gYXMgVmVjdG9yMyBhcnJheVxyXG4gICAgICBsZXQgcG9seWdvbjogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGxldCBkaXN0YW5jZXM6IG51bWJlcltdID0gWzBdO1xyXG4gICAgICBsZXQgdG90YWw6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnNoYXBlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcG9seWdvbi5wdXNoKHRoaXMuc2hhcGVbaV0udG9WZWN0b3IzKCkpO1xyXG4gICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgbGV0IGRpc3RhbmNlOiBudW1iZXIgPSBWZWN0b3IyLkRJRkZFUkVOQ0UodGhpcy5zaGFwZVtpXSwgdGhpcy5zaGFwZVtpIC0gMV0pLm1hZ25pdHVkZTtcclxuICAgICAgICAgIHRvdGFsICs9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgZGlzdGFuY2VzLnB1c2godG90YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBkaXN0YW5jZXMuZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiB7IGRpc3RhbmNlc1tpbmRleF0gPSBlbnRyeSAvIHRvdGFsOyB9KTtcclxuXHJcbiAgICAgIGxldCBuVmVydGljZXNQb2x5Z29uOiBudW1iZXIgPSBwb2x5Z29uLmxlbmd0aDtcclxuXHJcbiAgICAgIGxldCBjbG91ZDogVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgZm9yIChsZXQgbG9uZ2l0dWRlOiBudW1iZXIgPSAwOyBsb25naXR1ZGUgPD0gdGhpcy5sb25naXR1ZGVzOyBsb25naXR1ZGUrKykge1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuVmVydGljZXNQb2x5Z29uOyBpKyspIHtcclxuICAgICAgICAgIGxldCB1djogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKGxvbmdpdHVkZSAvIHRoaXMubG9uZ2l0dWRlcywgZGlzdGFuY2VzW2ldKTtcclxuICAgICAgICAgIC8vIFRPRE86IGxhc3Qgc2VjdG9yIHNob3VsZCBvbmx5IGJlIHJlZmVyZW5jZXMgdG8gdGhlIGZpcnN0IG1lcmlkaWFuXHJcbiAgICAgICAgICBpZiAobG9uZ2l0dWRlID09IHRoaXMubG9uZ2l0dWRlcylcclxuICAgICAgICAgICAgY2xvdWQucHVzaChuZXcgVmVydGV4KGksIHV2KSk7XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxvbmdpdHVkZSA+IDAgJiYgdGhpcy5zaGFwZVtpXS54ID09IDApIC8vIHVzZSBhIHNpbmdsZSB2ZXJ0ZXggd2hlbiBpdCdzIG9uIHRoZSByb3RhdGlvbiBheGlzXHJcbiAgICAgICAgICAgICAgY2xvdWQucHVzaChuZXcgVmVydGV4KGksIHV2KSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICBjbG91ZC5wdXNoKG5ldyBWZXJ0ZXgocG9seWdvbltpXS5jbG9uZSwgdXYpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKChfdmVjdG9yOiBWZWN0b3IzKSA9PiBfdmVjdG9yLnRyYW5zZm9ybShtdHhSb3RhdGUpKTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8vIGNvcHkgaW5kaWNlcyB0byBuZXcgaW5kZXggYXJyYXlcclxuICAgICAgbGV0IGZhY2VzOiBGYWNlW10gPSBbXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGxvbmdpdHVkZTogbnVtYmVyID0gMDsgbG9uZ2l0dWRlIDwgdGhpcy5sb25naXR1ZGVzOyBsb25naXR1ZGUrKykge1xyXG4gICAgICAgIGZvciAobGV0IGxhdGl0dWRlOiBudW1iZXIgPSAwOyBsYXRpdHVkZSA8IG5WZXJ0aWNlc1BvbHlnb24gLSAxOyBsYXRpdHVkZSsrKSB7XHJcbiAgICAgICAgICBsZXQgc3RhcnQ6IG51bWJlciA9IGxvbmdpdHVkZSAqIG5WZXJ0aWNlc1BvbHlnb24gKyBsYXRpdHVkZTtcclxuICAgICAgICAgIGxldCBxdWFkOiBRdWFkID0gbmV3IFF1YWQoY2xvdWQsIHN0YXJ0ICsgMSwgc3RhcnQgKyAxICsgblZlcnRpY2VzUG9seWdvbiwgc3RhcnQgKyBuVmVydGljZXNQb2x5Z29uLCBzdGFydCk7XHJcbiAgICAgICAgICBmYWNlcy5wdXNoKC4uLnF1YWQuZmFjZXMpO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2F0Y2ggaW52YWxpZCBmYWNlcyByaWdodCBoZXJlLi4uXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gY2xvdWQ7XHJcbiAgICAgIHRoaXMuZmFjZXMgPSBmYWNlcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JNZXNoU2tpbiBleHRlbmRzIFJlbmRlckluamVjdG9yTWVzaCB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcInVzZVJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2hTa2luLnVzZVJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImdldFJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2hTa2luLmdldFJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBcImRlbGV0ZVJlbmRlckJ1ZmZlcnNcIiwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2hTa2luLmRlbGV0ZVJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBnZXRSZW5kZXJCdWZmZXJzKHRoaXM6IE1lc2hTa2luLCBfc2hhZGVyOiB0eXBlb2YgU2hhZGVyKTogUmVuZGVyQnVmZmVycyB7XHJcbiAgICAgIGxldCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gc3VwZXIuZ2V0UmVuZGVyQnVmZmVycy5jYWxsKHRoaXMsIF9zaGFkZXIpO1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgbGV0IGlCb25lczogVWludDhBcnJheSA9IHRoaXMucmVuZGVyTWVzaC5pQm9uZXM7XHJcbiAgICAgIGxldCB3ZWlnaHRzOiBGbG9hdDMyQXJyYXkgPSB0aGlzLnJlbmRlck1lc2gud2VpZ2h0cztcclxuICAgICAgaWYgKF9zaGFkZXIuZGVmaW5lLmluY2x1ZGVzKFwiRkxBVFwiKSkge1xyXG4gICAgICAgIGlCb25lcyA9IHRoaXMucmVuZGVyTWVzaC5pQm9uZXNGbGF0O1xyXG4gICAgICAgIHdlaWdodHMgPSB0aGlzLnJlbmRlck1lc2gud2VpZ2h0c0ZsYXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmVuZGVyQnVmZmVycy5pQm9uZXMgPSBSZW5kZXJXZWJHTC5hc3NlcnQoY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgcmVuZGVyQnVmZmVycy5pQm9uZXMpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIGlCb25lcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICByZW5kZXJCdWZmZXJzLndlaWdodHMgPSBSZW5kZXJXZWJHTC5hc3NlcnQoY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgcmVuZGVyQnVmZmVycy53ZWlnaHRzKTtcclxuICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB3ZWlnaHRzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIHJldHVybiByZW5kZXJCdWZmZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoU2tpbiwgX3NoYWRlcjogdHlwZW9mIFNoYWRlciwgX210eE1lc2hUb1dvcmxkOiBNYXRyaXg0eDQsIF9tdHhNZXNoVG9WaWV3OiBNYXRyaXg0eDQsIF9pZD86IG51bWJlciwgX210eEJvbmVzPzogTWF0cml4NHg0W10pOiBSZW5kZXJCdWZmZXJzIHtcclxuICAgICAgbGV0IHJlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSBzdXBlci51c2VSZW5kZXJCdWZmZXJzLmNhbGwodGhpcywgX3NoYWRlciwgX210eE1lc2hUb1dvcmxkLCBfbXR4TWVzaFRvVmlldywgX2lkKTtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGNvbnN0IGFJQm9uZTogbnVtYmVyID0gX3NoYWRlci5hdHRyaWJ1dGVzW1wiYV9pQm9uZVwiXTtcclxuICAgICAgaWYgKGFJQm9uZSkge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgcmVuZGVyQnVmZmVycy5pQm9uZXMpO1xyXG4gICAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYUlCb25lKTtcclxuICAgICAgICBjcmMzLnZlcnRleEF0dHJpYklQb2ludGVyKGFJQm9uZSwgNCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLCAwLCAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYVdlaWdodDogbnVtYmVyID0gX3NoYWRlci5hdHRyaWJ1dGVzW1wiYV9mV2VpZ2h0XCJdO1xyXG4gICAgICBpZiAoYVdlaWdodCkge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgcmVuZGVyQnVmZmVycy53ZWlnaHRzKTtcclxuICAgICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFXZWlnaHQpO1xyXG4gICAgICAgIGNyYzMudmVydGV4QXR0cmliUG9pbnRlcihhV2VpZ2h0LCA0LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9tdHhCb25lcy5mb3JFYWNoKChtdHhCb25lLCBpQm9uZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVNdHhCb25lOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IF9zaGFkZXIudW5pZm9ybXNbYHVfYm9uZXNbJHtpQm9uZX1dLm1hdHJpeGBdO1xyXG4gICAgICAgIGlmICh1TXR4Qm9uZSlcclxuICAgICAgICAgIGNyYzMudW5pZm9ybU1hdHJpeDRmdih1TXR4Qm9uZSwgZmFsc2UsIG10eEJvbmUuZ2V0KCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiByZW5kZXJCdWZmZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVsZXRlUmVuZGVyQnVmZmVycyhfcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyk6IHZvaWQge1xyXG4gICAgICBzdXBlci5kZWxldGVSZW5kZXJCdWZmZXJzKF9yZW5kZXJCdWZmZXJzKTtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGlmIChfcmVuZGVyQnVmZmVycykge1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIoX3JlbmRlckJ1ZmZlcnMuaUJvbmVzKTtcclxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcihfcmVuZGVyQnVmZmVycy53ZWlnaHRzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLy4uL1JlbmRlci9SZW5kZXJJbmplY3Rvck1lc2hTa2luLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBNZXNoIGluZmx1ZW5jZWQgYnkgYSBza2VsZXRvblxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JNZXNoU2tpbi5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBNZXNoU2tpbiBleHRlbmRzIE1lc2hHTFRGIHtcclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfbG9hZGVyOiBHTFRGTG9hZGVyLCBfaU1lc2g6IG51bWJlcik6IFByb21pc2U8TWVzaFNraW4+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubG9hZChfbG9hZGVyLCBfaU1lc2gpO1xyXG4gICAgICBjb25zdCBnbHRmTWVzaDogR0xURi5NZXNoID0gX2xvYWRlci5nbHRmLm1lc2hlc1tfaU1lc2hdO1xyXG4gICAgICB0aGlzLnJlbmRlck1lc2ggPSBuZXcgUmVuZGVyTWVzaCh0aGlzKTtcclxuICAgICAgUmVmbGVjdC5zZXQodGhpcy5yZW5kZXJNZXNoLCBcIsaSaUJvbmVzXCIsIGF3YWl0IF9sb2FkZXIuZ2V0VWludDhBcnJheShnbHRmTWVzaC5wcmltaXRpdmVzWzBdLmF0dHJpYnV0ZXMuSk9JTlRTXzApKTtcclxuICAgICAgUmVmbGVjdC5zZXQodGhpcy5yZW5kZXJNZXNoLCBcIsaSd2VpZ2h0c1wiLCBhd2FpdCBfbG9hZGVyLmdldEZsb2F0MzJBcnJheShnbHRmTWVzaC5wcmltaXRpdmVzWzBdLmF0dHJpYnV0ZXMuV0VJR0hUU18wKSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXJzKF9zaGFkZXI6IHR5cGVvZiBTaGFkZXIsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfbXR4UHJvamVjdGlvbjogTWF0cml4NHg0LCBfaWQ/OiBudW1iZXIsIF9tdHhCb25lcz86IE1hdHJpeDR4NFtdKTogUmVuZGVyQnVmZmVycyB7IHJldHVybiBudWxsOyAvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIFVWIFNwaGVyZSB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIHNlY3RvcnMgYW5kIHN0YWNrcyAoY2xhbXBlZCBhdCAxMjgqMTI4KVxyXG4gICAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9zcGhlcmUuaHRtbFxyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hTcGhlcmUgZXh0ZW5kcyBNZXNoUm90YXRpb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoU3BoZXJlKTtcclxuICAgIHByaXZhdGUgbGF0aXR1ZGVzOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hTcGhlcmVcIiwgX2xvbmdpdHVkZXM6IG51bWJlciA9IDgsIF9sYXRpdHVkZXM6IG51bWJlciA9IDgpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfbG9uZ2l0dWRlcywgX2xhdGl0dWRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZShfbG9uZ2l0dWRlczogbnVtYmVyID0gMywgX2xhdGl0dWRlczogbnVtYmVyID0gMik6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIC8vQ2xhbXAgcmVzb2x1dGlvbiB0byBwcmV2ZW50IHBlcmZvcm1hbmNlIGlzc3Vlc1xyXG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKF9sb25naXR1ZGVzKSwgMTI4KTtcclxuICAgICAgdGhpcy5sYXRpdHVkZXMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKF9sYXRpdHVkZXMpLCAxMjgpO1xyXG5cclxuICAgICAgaWYgKF9sb25naXR1ZGVzIDwgMyB8fCBfbGF0aXR1ZGVzIDwgMikge1xyXG4gICAgICAgIERlYnVnLndhcm4oXCJVViBTcGhlcmUgbXVzdCBoYXZlIGF0IGxlYXN0IDMgbG9uZ2l0dWRlcyBhbmQgMiBsYXRpdHVkZXMgdG8gZm9ybSBhIDMtZGltZW5zaW9uYWwgc2hhcGUuXCIpO1xyXG4gICAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IE1hdGgubWF4KDMsIF9sb25naXR1ZGVzKTtcclxuICAgICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWF4KDIsIF9sYXRpdHVkZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IFtdO1xyXG4gICAgICBsZXQgc3RlcDogbnVtYmVyID0gTWF0aC5QSSAvIHRoaXMubGF0aXR1ZGVzO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDw9IHRoaXMubGF0aXR1ZGVzOyArK2kpIHtcclxuICAgICAgICBsZXQgYW5nbGU6IG51bWJlciA9IE1hdGguUEkgLyAyIC0gaSAqIHN0ZXA7XHJcbiAgICAgICAgbGV0IHg6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICBsZXQgeTogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgICBzaGFwZS5wdXNoKG5ldyBWZWN0b3IyKHggLyAyLCB5IC8gMikpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHBsYWNlIGZpcnN0IGFuZCBsYXN0IHZlcnRleCBleGFjdGx5IG9uIHJvdGF0aW9uIGF4aXNcclxuICAgICAgc2hhcGVbMF0ueCA9IDA7XHJcbiAgICAgIHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdLnggPSAwO1xyXG5cclxuICAgICAgc3VwZXIucm90YXRlKHNoYXBlLCBfbG9uZ2l0dWRlcyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMgPSB0aGlzLmxhdGl0dWRlcztcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzLCBfc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMubG9uZ2l0dWRlcywgdGhpcy5sYXRpdHVkZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2hhcGU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSB0d28gcXVhZHMgcGxhY2VkIGJhY2sgdG8gYmFjaywgdGhlIG9uZSBmYWNpbmcgaW4gbmVnYXRpdmUgWi1kaXJlY3Rpb24gaXMgdGV4dHVyZWQgcmV2ZXJzZWRcclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiAgICAgICAgMCBfXyAzXHJcbiAgICogICAgICAgICB8X198XHJcbiAgICogICAgICAgIDEgICAgMiAgICAgICAgICAgICBcclxuICAgKiBgYGAgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFNwcml0ZSBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoU3ByaXRlKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFNwcml0ZVwiKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyhcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIDAuNSwgMCksIG5ldyBWZWN0b3IyKDAsIDApKSxcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIC0wLjUsIDApLCBuZXcgVmVjdG9yMigwLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIC0wLjUsIDApLCBuZXcgVmVjdG9yMigxLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuNSwgMCksIG5ldyBWZWN0b3IyKDEsIDApKVxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLmZhY2VzID0gW1xyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDEsIDIsIDApLFxyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDIsIDMsIDApLFxyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDAsIDMsIDEpLFxyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDMsIDIsIDEpXHJcbiAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmxhdCBpcyBzdGFuZGFyZCBoZXJlXHJcbiAgICBwdWJsaWMgZ2V0IHZlcnRpY2VzRmxhdCgpOiBGbG9hdDMyQXJyYXkgeyByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLnZlcnRpY2VzOyB9XHJcbiAgICBwdWJsaWMgZ2V0IGluZGljZXNGbGF0KCk6IFVpbnQxNkFycmF5IHsgcmV0dXJuIHRoaXMucmVuZGVyTWVzaC5pbmRpY2VzOyB9XHJcblxyXG4gICAgLy8gaW5zdGVhZCwgc21vb3RoIHNoYWRpbmcgd291bGQgbmVlZCBleHRyYSBhdHRlbnRpb24gYnV0IGlzIG5vdCByZWxldmFudC4uLlxyXG5cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIFRvcnVzIHdpdGggYSBnaXZlbiB0aGlja25lc3MgYW5kIHRoZSBudW1iZXIgb2YgbWFqb3ItIGFuZCBtaW5vciBzZWdtZW50c1xyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hUb3J1cyBleHRlbmRzIE1lc2hSb3RhdGlvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hUb3J1cyk7XHJcbiAgICBwcml2YXRlIHNpemU6IG51bWJlciA9IDAuMjU7XHJcbiAgICBwcml2YXRlIGxhdGl0dWRlczogbnVtYmVyID0gMTI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hUb3J1c1wiLCBfc2l6ZTogbnVtYmVyID0gMC4yNSwgX2xvbmdpdHVkZXM6IG51bWJlciA9IDgsIF9sYXRpdHVkZXM6IG51bWJlciA9IDYpIHtcclxuICAgICAgc3VwZXIoX25hbWUsIE1lc2hUb3J1cy5nZXRTaGFwZShfc2l6ZSwgTWF0aC5tYXgoMywgX2xhdGl0dWRlcykpLCBfbG9uZ2l0dWRlcyk7XHJcbiAgICAgIHRoaXMuc2l6ZSA9IF9zaXplO1xyXG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBfbG9uZ2l0dWRlcztcclxuICAgICAgdGhpcy5sYXRpdHVkZXMgPSBNYXRoLm1heCgzLCBfbGF0aXR1ZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRTaGFwZShfc2l6ZTogbnVtYmVyLCBfbGF0aXR1ZGVzOiBudW1iZXIpOiBWZWN0b3IyW10ge1xyXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IFtdO1xyXG4gICAgICBsZXQgcmFkaXVzOiBudW1iZXIgPSBfc2l6ZSAvIDI7XHJcbiAgICAgIGxldCBjZW50ZXI6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMigwLjI1ICsgcmFkaXVzLCAwKTtcclxuICAgICAgZm9yIChsZXQgbGF0aXR1ZGU6IG51bWJlciA9IDA7IGxhdGl0dWRlIDw9IF9sYXRpdHVkZXM7IGxhdGl0dWRlKyspIHtcclxuICAgICAgICBsZXQgYW5nbGU6IG51bWJlciA9IDIgKiBNYXRoLlBJICogbGF0aXR1ZGUgLyBfbGF0aXR1ZGVzO1xyXG4gICAgICAgIHNoYXBlLnB1c2goVmVjdG9yMi5TVU0oY2VudGVyLCBuZXcgVmVjdG9yMihyYWRpdXMgKiAtTWF0aC5jb3MoYW5nbGUpLCByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkpKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGUoX3NpemU6IG51bWJlciA9IDAuMjUsIF9sb25naXR1ZGVzOiBudW1iZXIgPSA4LCBfbGF0aXR1ZGVzOiBudW1iZXIgPSA2KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2l6ZSA9IF9zaXplO1xyXG4gICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWF4KDMsIF9sYXRpdHVkZXMpO1xyXG4gICAgICBzdXBlci5yb3RhdGUoTWVzaFRvcnVzLmdldFNoYXBlKF9zaXplLCBfbGF0aXR1ZGVzKSwgX2xvbmdpdHVkZXMpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ubGF0aXR1ZGVzID0gdGhpcy5sYXRpdHVkZXM7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2l6ZSA9IHRoaXMuc2l6ZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfc2VyaWFsaXphdGlvbi5zaXplLCBfc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzLCBfc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMuc2l6ZSwgdGhpcy5sb25naXR1ZGVzLCB0aGlzLmxhdGl0dWRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaGFwZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBlbnVtIFFVQURTUExJVCB7XHJcbiAgICBQTEFOQVIsIEFUXzAsIEFUXzFcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3VyZmFjZSBjcmVhdGVkIHdpdGggZm91ciB2ZXJ0aWNlcyB3aGljaCBpbW1lZGlhdGVseSBjcmVhdGVzIG5vbmUsIG9uZSBvciB0d28ge0BsaW5rIEZhY2V9cyBkZXBlbmRpbmcgb24gdmVydGljZXMgYXQgaWRlbnRpY2FsIHBvc2l0aW9ucy5cclxuICAgKiBgYGBwbGFpbnRleHRcclxuICAgKiBRVUFEU1BMSVQ6ICBQTEFOQVIgICAgICAgICAgICAgICAgICBBVF8wICAgICAgICAgICAgICAgICAgICAgQVRfMVxyXG4gICAqICAgICAgICAgICAgIDAgXyAzICAgICAgICAgICAgICAgICAgIDAgXyAzICAgICAgICAgICAgICAgICAgICAwIF8gMyAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgKiAgICAgICAgICAgICAgfFxcfCAgICAgICAgICAgICAgICAgICAgIHxcXHwgICAgICAgICAgICAgICAgICAgICAgfC98ICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAqICAgICAgICAgICAgIDEg4oC+IDIgICAgICAgICAgICAgICAgICAgMSDigL4gMiAgICAgICAgICAgICAgICAgICAgMSDigL4gMiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAqICBzaGFyZWQgbGFzdCB2ZXJ0ZXggMiAgICAgIGxhc3QgdmVydGljZXMgMiArIDMgICAgICBsYXN0IHZlcnRpY2VzIDMgKyAwIFxyXG4gICAqICAgICAgXHJcbiAgICogYGBgIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFF1YWQge1xyXG4gICAgcHVibGljIGZhY2VzOiBGYWNlW107XHJcbiAgICAjc3BsaXQ6IFFVQURTUExJVDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfdmVydGljZXM6IFZlcnRpY2VzLCBfaW5kZXgwOiBudW1iZXIsIF9pbmRleDE6IG51bWJlciwgX2luZGV4MjogbnVtYmVyLCBfaW5kZXgzOiBudW1iZXIsIF9zcGxpdDogUVVBRFNQTElUID0gUVVBRFNQTElULlBMQU5BUikge1xyXG4gICAgICB0aGlzLmZhY2VzID0gW107XHJcbiAgICAgIHRoaXMuI3NwbGl0ID0gX3NwbGl0O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChfc3BsaXQgIT0gUVVBRFNQTElULkFUXzEpXHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UoX3ZlcnRpY2VzLCBfaW5kZXgwLCBfaW5kZXgxLCBfaW5kZXgyKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MSwgX2luZGV4MiwgX2luZGV4MykpO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikge1xyXG4gICAgICAgIERlYnVnLmZ1ZGdlKFwiRmFjZSBleGNsdWRlZFwiLCAoPEVycm9yPl9lKS5tZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChfc3BsaXQgPT0gUVVBRFNQTElULlBMQU5BUilcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDMsIF9pbmRleDAsIF9pbmRleDIpKTtcclxuICAgICAgICBlbHNlIGlmIChfc3BsaXQgPT0gUVVBRFNQTElULkFUXzApXHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UoX3ZlcnRpY2VzLCBfaW5kZXgwLCBfaW5kZXgyLCBfaW5kZXgzKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MSwgX2luZGV4MywgX2luZGV4MCkpO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikge1xyXG4gICAgICAgIERlYnVnLmZ1ZGdlKFwiRmFjZSBleGNsdWRlZFwiLCAoPEVycm9yPl9lKS5tZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgc3BsaXQoKTogUVVBRFNQTElUIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwbGl0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQm9uZSB7XHJcbiAgICBpbmRleDogbnVtYmVyO1xyXG4gICAgd2VpZ2h0OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgVmVydGV4IHtcclxuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyB1djogVmVjdG9yMjtcclxuICAgIHB1YmxpYyBub3JtYWw6IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgcmVmZXJUbzogbnVtYmVyO1xyXG4gICAgcHVibGljIGJvbmVzOiBCb25lW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgdmVydGV4IG9mIGEgbWVzaCB3aXRoIGV4dGVuZGVkIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHV2IGNvb3JkaW5hdGVzIGFuZCB0aGUgdmVydGV4IG5vcm1hbC5cclxuICAgICAqIEl0IG1heSByZWZlciB0byBhbm90aGVyIHZlcnRleCB2aWEgYW4gaW5kZXggaW50byBzb21lIGFycmF5LCBpbiB3aGljaCBjYXNlIHRoZSBwb3NpdGlvbiBhbmQgdGhlIG5vcm1hbCBhcmUgc3RvcmVkIHRoZXJlLlxyXG4gICAgICogVGhpcyB3YXksIHZlcnRleCBwb3NpdGlvbiBhbmQgbm9ybWFsIGlzIGEgMToxIGFzc29jaWF0aW9uLCB2ZXJ0ZXggdG8gdGV4dHVyZSBjb29yZGluYXRlcyBhIDE6biBhc3NvY2lhdGlvbi5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3Bvc2l0aW9uT3JJbmRleDogVmVjdG9yMyB8IG51bWJlciwgX3V2OiBWZWN0b3IyID0gbnVsbCwgX25vcm1hbDogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpKSB7XHJcbiAgICAgIGlmIChfcG9zaXRpb25PckluZGV4IGluc3RhbmNlb2YgVmVjdG9yMylcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gX3Bvc2l0aW9uT3JJbmRleDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMucmVmZXJUbyA9IF9wb3NpdGlvbk9ySW5kZXg7XHJcblxyXG4gICAgICB0aGlzLnV2ID0gX3V2O1xyXG4gICAgICB0aGlzLm5vcm1hbCA9IF9ub3JtYWw7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXJyYXkgd2l0aCBleHRlbmRlZCBmdW5jdGlvbmFsaXR5IHRvIHNlcnZlIGFzIGEge0BsaW5rIFZlcnRleH0tY2xvdWQuIFxyXG4gICAqIEFjY2Vzc29ycyB5aWVsZCBwb3NpdGlvbiBvciBub3JtYWwgYWxzbyBmb3IgdmVydGljZXMgcmVmZXJlbmNpbmcgb3RoZXIgdmVydGljZXNcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWZXJ0aWNlcyBleHRlbmRzIEFycmF5PFZlcnRleD4ge1xyXG4gICAgLy8gVE9ETzogdGhpcyBjbGFzcyBtYXkgYmVjb21lIG1vcmUgcG93ZXJmdWwgYnkgaGlkaW5nIHRoZSBhcnJheSBhbmQgYWRkIG1vcmUgc2VydmljZSBtZXRob2RzIGxpa2UgY2FsY3VsYXRpbmcgYm91bmRpbmcgYm94LCByYWRpdXMgZXRjLlxyXG4gICAgLy8gc2VlIGlmIGEgcHJveHkgb2YgdGhlIGFycmF5IGludGVyZmFjaW5nIFtdIHdvdWxkIGRvIGEgZ29vZCBqb2IgLT4gdGVzdGVkOiBwcm94eSBpcyBhYm91dCAyMCB0aW1lcyBzbG93ZXIhXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdWJzZXQgb2YgdmVydGljZXMgdGhhdCBkbyBub3QgcmVmZXIgdG8gb3RoZXIgdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBvcmlnaW5hbHMoKTogQXJyYXk8VmVydGV4PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihfdmVydGV4ID0+IF92ZXJ0ZXgucmVmZXJUbyA9PSB1bmRlZmluZWQpO1xyXG4gICAgfSAgIFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIHBvc2l0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZCwgcmVzb2x2aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiB2ZXJ0aWNlcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvc2l0aW9uKF9pbmRleDogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZXJ0ZXg6IFZlcnRleCA9IHRoaXNbX2luZGV4XTtcclxuICAgICAgcmV0dXJuICh2ZXJ0ZXgucmVmZXJUbyA9PSB1bmRlZmluZWQpID8gdmVydGV4LnBvc2l0aW9uIDogdGhpc1t2ZXJ0ZXgucmVmZXJUb10ucG9zaXRpb247XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgbm9ybWFsIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZCwgcmVzb2x2aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiB2ZXJ0aWNlcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbChfaW5kZXg6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVydGV4OiBWZXJ0ZXggPSB0aGlzW19pbmRleF07XHJcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5ub3JtYWwgOiB0aGlzW3ZlcnRleC5yZWZlclRvXS5ub3JtYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSB1di1jb29yZGluYXRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHV2KF9pbmRleDogbnVtYmVyKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiB0aGlzW19pbmRleF0udXY7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBwb3NpdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWQsIHJlc29sdmluZyByZWZlcmVuY2VzIGJldHdlZW4gdmVydGljZXMgXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMgYm9uZXMoX2luZGV4OiBudW1iZXIpOiBCb25lW10ge1xyXG4gICAgICBsZXQgdmVydGV4OiBWZXJ0ZXggPSB0aGlzW19pbmRleF07XHJcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5ib25lcyA6IHRoaXNbdmVydGV4LnJlZmVyVG9dLmJvbmVzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgYXV0b21hdGljIGFkanVzdG1lbnQgb2YgdGhlIGNvbGxpZGVyXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gQk9EWV9JTklUIHtcclxuICAgIC8qKiBDb2xsaWRlciB1c2VzIHRoZSBwaXZvdCBvZiB0aGUgbWVzaCBmb3IgaW5pdGlsaWFsaXphdGlvbiAqL1xyXG4gICAgVE9fTUVTSCxcclxuICAgIC8qKiBDb2xsaWRlciB1c2VzIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIG5vZGUgZm9yIGluaXRpbGlhbGl6YXRpb24gKi9cclxuICAgIFRPX05PREUsXHJcbiAgICAvKiogQ29sbGlkZXIgdXNlcyBpdHMgb3duIHBpdm90IGZvciBpbml0aWxpYWxpemF0aW9uICovXHJcbiAgICBUT19QSVZPVFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiBBY3RzIGFzIHRoZSBwaHlzaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIE5vZGV9IGl0J3MgYXR0YWNoZWQgdG8uXHJcbiAgICAgKiBJdCdzIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gdGhlIEZ1ZGdlIHJlbmRlcmVkIHdvcmxkIGFuZCB0aGUgUGh5c2ljcyB3b3JsZC5cclxuICAgICAqIEZvciB0aGUgcGh5c2ljcyB0byBjb3JyZWN0bHkgZ2V0IHRoZSB0cmFuc2Zvcm1hdGlvbnMgcm90YXRpb25zIG5lZWQgdG8gYmUgYXBwbGllZCB3aXRoIGZyb20gbGVmdCA9IHRydWUuXHJcbiAgICAgKiBPciByb3RhdGlvbnMgbmVlZCB0byBoYXBwZW4gYmVmb3JlIHNjYWxpbmcuXHJcbiAgICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50UmlnaWRib2R5IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRSaWdpZGJvZHkpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbWFwQm9keVR5cGU6IHsgW3R5cGU6IG51bWJlcl06IG51bWJlciB9ID0gKHR5cGVvZiBPSU1PID09IFwidW5kZWZpbmVkXCIpID9cclxuICAgICAge1xyXG4gICAgICAgIFtCT0RZX1RZUEUuRFlOQU1JQ106IEJPRFlfVFlQRS5EWU5BTUlDLCBbQk9EWV9UWVBFLlNUQVRJQ106IEJPRFlfVFlQRS5TVEFUSUMsIFtCT0RZX1RZUEUuS0lORU1BVElDXTogQk9EWV9UWVBFLktJTkVNQVRJQ1xyXG4gICAgICB9IDoge1xyXG4gICAgICAgIFtCT0RZX1RZUEUuRFlOQU1JQ106IE9JTU8uUmlnaWRCb2R5VHlwZS5EWU5BTUlDLCBbQk9EWV9UWVBFLlNUQVRJQ106IE9JTU8uUmlnaWRCb2R5VHlwZS5TVEFUSUMsIFtCT0RZX1RZUEUuS0lORU1BVElDXTogT0lNTy5SaWdpZEJvZHlUeXBlLktJTkVNQVRJQ1xyXG4gICAgICB9O1xyXG5cclxuICAgIC8qKiBUcmFuc2Zvcm1hdGlvbiBvZiB0aGUgY29sbGlkZXIgcmVsYXRpdmUgdG8gdGhlIG5vZGUncyB0cmFuc2Zvcm0uIE9uY2Ugc2V0IG1vc3RseSByZW1haW5zIGNvbnN0YW50LiBcclxuICAgICAqIElmIGFsdGVyZWQsIHtAbGluayBpc0luaXRpYWxpemVkfSBtdXN0IGJlIHJlc2V0IHRvIGZhbHNlIHRvIHJlY3JlYXRlIHRoZSBjb2xsaWRlciBpbiB0aGUgbmV4dCB7QGxpbmsgUmVuZGVyLnByZXBhcmV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVmVydGljZXMgdGhhdCBidWlsZCBhIGNvbnZleCBtZXNoIChmb3JtIHRoYXQgaXMgaW4gaXRzZWxmIGNsb3NlZCkuIE5lZWRzIHRvIHNldCBpbiB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSByYiBpZiBub25lIG9mIHRoZSBzdGFuZGFyZCBjb2xsaWRlcnMgaXMgdXNlZC4gXHJcbiAgICAgKiBVbnRlc3RlZCBhbmQgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQgYnkgc2VyaWFsaXphdGlvbiBhbmQgbXV0YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb252ZXhNZXNoOiBGbG9hdDMyQXJyYXkgPSBudWxsO1xyXG5cclxuICAgIC8qKiBDb2xsaXNpb25zIHdpdGggcmlnaWRib2RpZXMgaGFwcGVuaW5nIHRvIHRoaXMgYm9keSwgY2FuIGJlIHVzZWQgdG8gYnVpbGQgYSBjdXN0b20gb25Db2xsaXNpb25TdGF5IGZ1bmN0aW9uYWxpdHkuICovXHJcbiAgICBwdWJsaWMgY29sbGlzaW9uczogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuICAgIC8qKiBUcmlnZ2VycyB0aGF0IGFyZSBjdXJyZW50bHkgdHJpZ2dlcmluZyB0aGlzIGJvZHkgKi9cclxuICAgIHB1YmxpYyB0cmlnZ2VyaW5nczogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGUgZ3JvdXBzIHRoaXMgb2JqZWN0IGNvbGxpZGVzIHdpdGguIEdyb3VwcyBtdXN0IGJlIHdyaXRlbiBpbiBmb3JtIG9mXHJcbiAgICAgKiAgZS5nLiBjb2xsaXNpb25NYXNrID0ge0BsaW5rIENPTExJU0lPTl9HUk9VUC5ERUZBVUxUfSB8IHtAbGluayBDT0xMSVNJT05fR1JPVVB9Li4uLiBhbmQgc28gb24gdG8gY29sbGlkZSB3aXRoIG11bHRpcGxlIGdyb3Vwcy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb2xsaXNpb25NYXNrOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljIGFkanVzdG1lbnQgb2YgdGhlIHBpdm90IHdoZW4ge0BsaW5rIFJlbmRlci5wcmVwYXJlfSBpcyBjYWxsZWQgYWNjb3JkaW5nIHRvIHtAbGluayBCT0RZX0lOSVR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXphdGlvbjogQk9EWV9JTklUID0gQk9EWV9JTklULlRPX1BJVk9UO1xyXG4gICAgLyoqIE1hcmtzIGlmIGNvbGxpZGVyIHdhcyBpbml0aWFsaXplZC4gUmVzZXQgdG8gZmFsc2UgdG8gaW5pdGlhbGl6ZSBhZ2FpbiBlLmcuIGFmdGVyIG1hbmlwdWxhdGlvbiBvZiBtdHhQaXZvdCAqL1xyXG4gICAgcHVibGljIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKiogSUQgdG8gcmVmZXJlbmNlIHRoaXMgc3BlY2lmaWMgQ29tcG9uZW50UmlnaWRib2R5ICovXHJcbiAgICAjaWQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLy9Qcml2YXRlIGluZm9ybWF0aW9ucyAtIE1vc3RseSBPaW1vUGh5c2ljcyB2YXJpYWJsZXMgdGhhdCBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdGhlIEZ1ZGdlIFVzZXIgYW5kIG1hbmlwdWxhdGVkIGJ5IHRoZW1cclxuICAgICNjb2xsaWRlcjogT0lNTy5TaGFwZTtcclxuICAgICNjb2xsaWRlckluZm86IE9JTU8uU2hhcGVDb25maWc7XHJcbiAgICAjY29sbGlzaW9uR3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IENPTExJU0lPTl9HUk9VUC5ERUZBVUxUO1xyXG4gICAgI3R5cGVDb2xsaWRlcjogQ09MTElERVJfVFlQRSA9IENPTExJREVSX1RZUEUuQ1VCRTtcclxuXHJcbiAgICAjcmlnaWRib2R5OiBPSU1PLlJpZ2lkQm9keTtcclxuICAgICNyaWdpZGJvZHlJbmZvOiBPSU1PLlJpZ2lkQm9keUNvbmZpZyA9IG5ldyBPSU1PLlJpZ2lkQm9keUNvbmZpZygpO1xyXG4gICAgI3R5cGVCb2R5OiBCT0RZX1RZUEUgPSBCT0RZX1RZUEUuRFlOQU1JQztcclxuXHJcbiAgICAjbWFzc0RhdGE6IE9JTU8uTWFzc0RhdGEgPSBuZXcgT0lNTy5NYXNzRGF0YSgpO1xyXG4gICAgI3Jlc3RpdHV0aW9uOiBudW1iZXI7XHJcbiAgICAjZnJpY3Rpb246IG51bWJlcjtcclxuICAgICNkYW1waW5nTGluZWFyOiBudW1iZXIgPSAwLjE7XHJcbiAgICAjZGFtcGluZ0FuZ3VsYXI6IG51bWJlciA9IDAuMTtcclxuICAgICNlZmZlY3RSb3RhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKCk7XHJcbiAgICAjZWZmZWN0R3Jhdml0eTogbnVtYmVyID0gMTtcclxuICAgICNpc1RyaWdnZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICNtdHhQaXZvdFVuc2NhbGVkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICNtdHhQaXZvdEludmVyc2U6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgICNjYWxsYmFja3M6IE9JTU8uQ29udGFjdENhbGxiYWNrOyAvL0NhbGxiYWNrIE1ldGhvZHMgd2hlbiB3aXRoaW4gdGhlIG9pbW9TeXN0ZW0gYSBldmVudCBpcyBoYXBwZW5pbmdcclxuXHJcbiAgICAvLyAjcGh5c2ljczogUGh5c2ljczsgLy9UT0RPOiBrZWVwIGEgcG9pbnRlciB0byB0aGUgcGh5c2ljcyBpbnN0YW5jZSB1c2VkIGJ5IHRoaXMgY29tcG9uZW50XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgbmV3IHJpZ2lkYm9keSB3aXRoIGEgd2VpZ2h0IGluIGtnLCBhIHBoeXNpY3MgdHlwZSAoZGVmYXVsdCA9IGR5bmFtaWMpLCBhIGNvbGxpZGVyIHR5cGUgd2hhdCBwaHlzaWNhbCBmb3JtIGhhcyB0aGUgY29sbGlkZXIsIHRvIHdoYXQgZ3JvdXAgZG9lcyBpdCBiZWxvbmcsIGlzIHRoZXJlIGEgdHJhbnNmb3JtIE1hdHJpeCB0aGF0IHNob3VsZCBiZSB1c2VkLCBhbmQgaXMgdGhlIGNvbGxpZGVyIGRlZmluZWQgYXMgYSBncm91cCBvZiBwb2ludHMgdGhhdCByZXByZXNlbnQgYSBjb252ZXggbWVzaC4gKi9cclxuICAgIGNvbnN0cnVjdG9yKF9tYXNzOiBudW1iZXIgPSAxLCBfdHlwZTogQk9EWV9UWVBFID0gQk9EWV9UWVBFLkRZTkFNSUMsIF9jb2xsaWRlclR5cGU6IENPTExJREVSX1RZUEUgPSBDT0xMSURFUl9UWVBFLkNVQkUsIF9ncm91cDogQ09MTElTSU9OX0dST1VQID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0Q29sbGlzaW9uR3JvdXAsIF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IG51bGwsIF9jb252ZXhNZXNoOiBGbG9hdDMyQXJyYXkgPSBudWxsKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKF9tYXNzLCBfdHlwZSwgX2NvbGxpZGVyVHlwZSwgX2dyb3VwLCBfbXR4VHJhbnNmb3JtLCBfY29udmV4TWVzaCk7XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRFdmVudCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZEV2ZW50KTtcclxuICAgICAgLy8gdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCB0aGlzLmhuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBBY2Nlc3NvcnNcclxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBVc2VkIGZvciBjYWxjdWxhdGlvbiBvZiB0aGUgZ2VvbWV0cmljYWwgcmVsYXRpb25zaGlwIG9mIG5vZGUgYW5kIGNvbGxpZGVyIGJ5IHtAbGluayBSZW5kZXJ9Ki9cclxuICAgIHB1YmxpYyBnZXQgbXR4UGl2b3RJbnZlcnNlKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhQaXZvdEludmVyc2U7XHJcbiAgICB9XHJcbiAgICAvKiogVXNlZCBmb3IgY2FsY3VsYXRpb24gb2YgdGhlIGdlb21ldHJpY2FsIHJlbGF0aW9uc2hpcCBvZiBub2RlIGFuZCBjb2xsaWRlciBieSB7QGxpbmsgUmVuZGVyfSovXHJcbiAgICBwdWJsaWMgZ2V0IG10eFBpdm90VW5zY2FsZWQoKTogTWF0cml4NHg0IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI210eFBpdm90VW5zY2FsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHJpZXZlIHRoZSBib2R5IHR5cGUuIFNlZSB7QGxpbmsgQk9EWV9UWVBFfSAqL1xyXG4gICAgcHVibGljIGdldCB0eXBlQm9keSgpOiBCT0RZX1RZUEUge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdHlwZUJvZHk7XHJcbiAgICB9XHJcbiAgICAvKiogU2V0IHRoZSBib2R5IHR5cGUuIFNlZSB7QGxpbmsgQk9EWV9UWVBFfSAqL1xyXG4gICAgcHVibGljIHNldCB0eXBlQm9keShfdmFsdWU6IEJPRFlfVFlQRSkge1xyXG4gICAgICB0aGlzLiN0eXBlQm9keSA9IF92YWx1ZTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldFR5cGUoQ29tcG9uZW50UmlnaWRib2R5Lm1hcEJvZHlUeXBlW3RoaXMuI3R5cGVCb2R5XSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRNYXNzRGF0YSh0aGlzLiNtYXNzRGF0YSk7IC8vaGF2ZSB0byByZXNldCBtYXNzIGFmdGVyIGNoYW5naW5nIHRoZSB0eXBlLCBzaW5jZSBPaW1vIGlzIGhhbmRsaW5nIG1hc3MgaW50ZXJuYWxseSB3cm9uZyB3aGVuIHN3aXRjaGluZyB0eXBlc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgc2hhcGUgdGhhdCByZXByZXNlbnRzIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHdvcmxkLiBEZWZhdWx0IGlzIGEgQ3ViZS4gKi9cclxuICAgIHB1YmxpYyBnZXQgdHlwZUNvbGxpZGVyKCk6IENPTExJREVSX1RZUEUge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdHlwZUNvbGxpZGVyO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0eXBlQ29sbGlkZXIoX3ZhbHVlOiBDT0xMSURFUl9UWVBFKSB7XHJcbiAgICAgIGlmIChfdmFsdWUgIT0gdGhpcy4jdHlwZUNvbGxpZGVyICYmIHRoaXMuI3JpZ2lkYm9keSAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy4jdHlwZUNvbGxpZGVyID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBjb2xsaXNpb24gZ3JvdXAgdGhpcyB7QGxpbmsgTm9kZX0gYmVsb25ncyB0byBpdCdzIHRoZSBkZWZhdWx0IGdyb3VwIG5vcm1hbGx5IHdoaWNoIG1lYW5zIGl0IHBoeXNpY2FsbHkgY29sbGlkZXMgd2l0aCBldmVyeSBncm91cCBiZXNpZGVzIHRyaWdnZXIuICovXHJcbiAgICBwdWJsaWMgZ2V0IGNvbGxpc2lvbkdyb3VwKCk6IENPTExJU0lPTl9HUk9VUCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjb2xsaXNpb25Hcm91cDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgY29sbGlzaW9uR3JvdXAoX3ZhbHVlOiBDT0xMSVNJT05fR1JPVVApIHtcclxuICAgICAgdGhpcy4jY29sbGlzaW9uR3JvdXAgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkgIT0gbnVsbClcclxuICAgICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0Q29sbGlzaW9uR3JvdXAodGhpcy4jY29sbGlzaW9uR3JvdXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBNYXJraW5nIHRoZSBCb2R5IGFzIGEgdHJpZ2dlciB0aGVyZWZvcmUgbm90IGluZmx1ZW5jaW5nIHRoZSBjb2xsaXNpb24gc3lzdGVtIGJ1dCBvbmx5IHNlbmRpbmcgdHJpZ2dlckV2ZW50cyAqL1xyXG4gICAgcHVibGljIGdldCBpc1RyaWdnZXIoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNpc1RyaWdnZXI7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGlzVHJpZ2dlcihfdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy4jaXNUcmlnZ2VyID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5nZXRPaW1vUmlnaWRib2R5KCkgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZ2V0T2ltb1JpZ2lkYm9keSgpLl9pc1RyaWdnZXIgPSB0aGlzLiNpc1RyaWdnZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBoeXNpY2FsIHdlaWdodCBvZiB0aGUge0BsaW5rIE5vZGV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFzcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5LmdldE1hc3MoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0dGluZyB0aGUgcGh5c2ljYWwgd2VpZ2h0IG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4ga2dcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtYXNzKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21hc3NEYXRhLm1hc3MgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUgIT0gbnVsbClcclxuICAgICAgICBpZiAodGhpcy4jcmlnaWRib2R5ICE9IG51bGwpXHJcbiAgICAgICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TWFzc0RhdGEodGhpcy4jbWFzc0RhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEcmFnIG9mIGxpbmVhciBtb3ZlbWVudC4gQSBCb2R5IGRvZXMgc2xvdyBkb3duIGV2ZW4gb24gYSBzdXJmYWNlIHdpdGhvdXQgZnJpY3Rpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGRhbXBUcmFuc2xhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5LmdldExpbmVhckRhbXBpbmcoKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGFtcFRyYW5zbGF0aW9uKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2RhbXBpbmdMaW5lYXIgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRMaW5lYXJEYW1waW5nKF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERyYWcgb2Ygcm90YXRpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGRhbXBSb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5LmdldEFuZ3VsYXJEYW1waW5nKCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRhbXBSb3RhdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNkYW1waW5nQW5ndWxhciA9IF92YWx1ZTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEFuZ3VsYXJEYW1waW5nKF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBmYWN0b3IgdGhpcyByaWdpZGJvZHkgcmVhY3RzIHJvdGF0aW9ucyB0aGF0IGhhcHBlbiBpbiB0aGUgcGh5c2ljYWwgd29ybGQuIDAgdG8gbG9jayByb3RhdGlvbiB0aGlzIGF4aXMuICovXHJcbiAgICBwdWJsaWMgZ2V0IGVmZmVjdFJvdGF0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZWZmZWN0Um90YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGVmZmVjdFJvdGF0aW9uKF9lZmZlY3Q6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy4jZWZmZWN0Um90YXRpb24gPSBfZWZmZWN0O1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0Um90YXRpb25GYWN0b3IobmV3IE9JTU8uVmVjMyh0aGlzLiNlZmZlY3RSb3RhdGlvbi54LCB0aGlzLiNlZmZlY3RSb3RhdGlvbi55LCB0aGlzLiNlZmZlY3RSb3RhdGlvbi56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBmYWN0b3IgdGhpcyByaWdpZGJvZHkgcmVhY3RzIHRvIHdvcmxkIGdyYXZpdHkuIERlZmF1bHQgPSAxIGUuZy4gMSo5LjgxIG0vcy4gKi9cclxuICAgIHB1YmxpYyBnZXQgZWZmZWN0R3Jhdml0eSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZWZmZWN0R3Jhdml0eTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZWZmZWN0R3Jhdml0eShfZWZmZWN0OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jZWZmZWN0R3Jhdml0eSA9IF9lZmZlY3Q7XHJcbiAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkgIT0gbnVsbCkgdGhpcy4jcmlnaWRib2R5LnNldEdyYXZpdHlTY2FsZSh0aGlzLiNlZmZlY3RHcmF2aXR5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZnJpY3Rpb24gb2YgdGhlIHJpZ2lkYm9keSwgd2hpY2ggaXMgdGhlIGZhY3RvciBvZiBzbGlkaW5nIHJlc2lzdGFuY2Ugb2YgdGhpcyByaWdpZGJvZHkgb24gc3VyZmFjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBmcmljdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZnJpY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGZyaWN0aW9uIG9mIHRoZSByaWdpZGJvZHksIHdoaWNoIGlzIHRoZSBmYWN0b3Igb2YgIHNsaWRpbmcgcmVzaXN0YW5jZSBvZiB0aGlzIHJpZ2lkYm9keSBvbiBzdXJmYWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGZyaWN0aW9uKF9mcmljdGlvbjogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2ZyaWN0aW9uID0gX2ZyaWN0aW9uO1xyXG4gICAgICBpZiAodGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldEZyaWN0aW9uKHRoaXMuI2ZyaWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgcmVzdGl0dXRpb24gb2YgdGhlIHJpZ2lkYm9keSwgd2hpY2ggaXMgdGhlIGZhY3RvciBvZiBib3VuY2luZXNzIG9mIHRoaXMgcmlnaWRib2R5IG9uIHN1cmZhY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcmVzdGl0dXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3Jlc3RpdHV0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSByZXN0aXR1dGlvbiBvZiB0aGUgcmlnaWRib2R5LCB3aGljaCBpcyB0aGUgZmFjdG9yIG9mIGJvdW5jaW5lc3Mgb2YgdGhpcyByaWdpZGJvZHkgb24gc3VyZmFjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCByZXN0aXR1dGlvbihfcmVzdGl0dXRpb246IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyZXN0aXR1dGlvbiA9IF9yZXN0aXR1dGlvbjtcclxuICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKSAhPSBudWxsKVxyXG4gICAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRSZXN0aXR1dGlvbih0aGlzLiNyZXN0aXR1dGlvbik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyBBY3RpdmF0ZSB0aGUgZnVuY3Rpb25zIG9mIHRoaXMgY29tcG9uZW50IGFzIHJlc3BvbnNlIHRvIGV2ZW50c1xyXG4gICAgcHVibGljIGhuZEV2ZW50ID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRVZFTlQuQ09NUE9ORU5UX0FERDpcclxuICAgICAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQUNUSVZBVEUsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCk7XHJcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0RFQUNUSVZBVEUsIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkKTtcclxuICAgICAgICAgIC8vIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfQUNUSVZBVEUsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCwgdHJ1ZSk7IC8vIHVzZSBjYXB0dXJlIHRvIHJlYWN0IHRvIGJyb2FkY2FzdCFcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVBQ1RJVkFURSwgdGhpcy5yZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQsIHRydWUpO1xyXG4gICAgICAgICAgaWYgKCF0aGlzLm5vZGUuY21wVHJhbnNmb3JtKVxyXG4gICAgICAgICAgICBEZWJ1Zy53YXJuKGBDb21wb25lbnRSaWdpZGJvZHkgYXR0YWNoZWQgdG8gbm9kZSBtaXNzaW5nIENvbXBvbmVudFRyYW5zZm9ybWAsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9SRU1PVkU6XHJcbiAgICAgICAgICAvLyB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5hZGRSaWdpZGJvZHlUb1dvcmxkKTtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCk7XHJcbiAgICAgICAgICAvLyB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0FDVElWQVRFLCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQsIHRydWUpOyAvLyB1c2UgY2FwdHVyZSB0byByZWFjdCB0byBicm9hZGNhc3QhXHJcbiAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0RFQUNUSVZBVEUsIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkLCB0cnVlKTtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVWRU5ULk5PREVfREVTRVJJQUxJWkVEOlxyXG4gICAgICAgICAgaWYgKCF0aGlzLm5vZGUuY21wVHJhbnNmb3JtKVxyXG4gICAgICAgICAgICBEZWJ1Zy5lcnJvcihgQ29tcG9uZW50UmlnaWRib2R5IGF0dGFjaGVkIHRvIG5vZGUgbWlzc2luZyBDb21wb25lbnRUcmFuc2Zvcm1gLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmlnaWRib2R5IGluIHRoZSBmb3JtIHRoZSBwaHlzaWNzIGVuZ2luZSBpcyB1c2luZyBpdCwgc2hvdWxkIG5vdCBiZSB1c2VkIHVubGVzcyBhIGZ1bmN0aW9uYWxpdHlcclxuICAgICAqIGlzIG5vdCBwcm92aWRlZCB0aHJvdWdoIHRoZSBGVURHRSBJbnRlZ3JhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE9pbW9SaWdpZGJvZHkoKTogT0lNTy5SaWdpZEJvZHkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSb3RhdGluZyB0aGUgcmlnaWRib2R5IHRoZXJlZm9yZSBjaGFuZ2luZyBpdCdzIHJvdGF0aW9uIG92ZXIgdGltZSBkaXJlY3RseSBpbiBwaHlzaWNzLiBUaGlzIHdheSBwaHlzaWNzIGlzIGNoYW5naW5nIGluc3RlYWQgb2YgdHJhbnNmb3JtLiBcclxuICAgICAqICBCdXQgeW91IGFyZSBhYmxlIHRvIGluY3JlbWVudGFsIGNoYW5naW5nIGl0IGluc3RlYWQgb2YgYSBkaXJlY3Qgcm90YXRpb24uICBBbHRob3VnaCBpdCdzIGFsd2F5cyBwcmVmZXJlZCB0byB1c2UgZm9yY2VzIGluIHBoeXNpY3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVCb2R5KF9yb3RhdGlvbkNoYW5nZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkucm90YXRlWHl6KG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uQ2hhbmdlLnggKiBNYXRoLlBJIC8gMTgwLCBfcm90YXRpb25DaGFuZ2UueSAqIE1hdGguUEkgLyAxODAsIF9yb3RhdGlvbkNoYW5nZS56ICogTWF0aC5QSSAvIDE4MCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUcmFuc2xhdGluZyB0aGUgcmlnaWRib2R5IHRoZXJlZm9yZSBjaGFuZ2luZyBpdCdzIHBsYWNlIG92ZXIgdGltZSBkaXJlY3RseSBpbiBwaHlzaWNzLiBUaGlzIHdheSBwaHlzaWNzIGlzIGNoYW5naW5nIGluc3RlYWQgb2YgdHJhbnNmb3JtLiBcclxuICAgICAqICBCdXQgeW91IGFyZSBhYmxlIHRvIGluY3JlbWVudGFsbHkgY2hhbmdpbmcgaXQgaW5zdGVhZCBvZiBhIGRpcmVjdCBwb3NpdGlvbi4gQWx0aG91Z2ggaXQncyBhbHdheXMgcHJlZmVyZWQgdG8gdXNlIGZvcmNlcyBpbiBwaHlzaWNzLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZUJvZHkoX3RyYW5zbGF0aW9uQ2hhbmdlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS50cmFuc2xhdGUobmV3IE9JTU8uVmVjMyhfdHJhbnNsYXRpb25DaGFuZ2UueCwgX3RyYW5zbGF0aW9uQ2hhbmdlLnksIF90cmFuc2xhdGlvbkNoYW5nZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgUE9TSVRJT04gb2YgdGhlIHtAbGluayBOb2RlfSBpbiB0aGUgcGh5c2ljYWwgc3BhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBvc2l0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdG1wUG9zOiBPSU1PLlZlYzMgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0UG9zaXRpb24oKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRtcFBvcy54LCB0bXBQb3MueSwgdG1wUG9zLnopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBQT1NJVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UG9zaXRpb24oX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRQb3NpdGlvbihuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBST1RBVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZS4gTm90ZSB0aGlzIHJhbmdlIGZyb20gLXBpIHRvIHBpLCBzbyAtOTAgdG8gOTAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSb3RhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IG9yaWVudGF0aW9uOiBPSU1PLlF1YXQgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0T3JpZW50YXRpb24oKTtcclxuICAgICAgbGV0IHRtcFF1YXQ6IFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbihvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCBvcmllbnRhdGlvbi53KTtcclxuICAgICAgcmV0dXJuIHRtcFF1YXQudG9EZWdyZWVzKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBST1RBVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZSwgaW4gZGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Um90YXRpb24oX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCBxdWF0OiBPSU1PLlF1YXQgPSBuZXcgT0lNTy5RdWF0KCk7XHJcbiAgICAgIGxldCBtdHhSb3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICBtdHhSb3Qucm90YXRlKG5ldyBWZWN0b3IzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopKTtcclxuICAgICAgbGV0IGFycmF5OiBGbG9hdDMyQXJyYXkgPSBtdHhSb3QuZ2V0KCk7XHJcbiAgICAgIGxldCByb3Q6IE9JTU8uTWF0MyA9IG5ldyBPSU1PLk1hdDMoYXJyYXlbMF0sIGFycmF5WzRdLCBhcnJheVs4XSwgYXJyYXlbMV0sIGFycmF5WzVdLCBhcnJheVs5XSwgYXJyYXlbMl0sIGFycmF5WzZdLCBhcnJheVsxMF0pO1xyXG4gICAgICBxdWF0LmZyb21NYXQzKHJvdCk7XHJcbiAgICAgIC8vIHF1YXQubm9ybWFsaXplKCk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRPcmllbnRhdGlvbihxdWF0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqIEdldCB0aGUgY3VycmVudCBTQ0FMSU5HIGluIHRoZSBwaHlzaWNhbCBzcGFjZS4gKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsaW5nKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMubm9kZS5tdHhXb3JsZC5zY2FsaW5nLmNsb25lO1xyXG4gICAgICBzY2FsaW5nLnggKj0gdGhpcy5tdHhQaXZvdC5zY2FsaW5nLng7XHJcbiAgICAgIHNjYWxpbmcueSAqPSB0aGlzLm10eFBpdm90LnNjYWxpbmcueTtcclxuICAgICAgc2NhbGluZy56ICo9IHRoaXMubXR4UGl2b3Quc2NhbGluZy56O1xyXG4gICAgICByZXR1cm4gc2NhbGluZztcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2NhbGluZyByZXF1aXJlcyB0aGUgY29sbGlkZXIgdG8gYmUgY29tcGxldGVseSByZWNyZWF0ZWQgYW5ldyAqL1xyXG4gICAgcHVibGljIHNldFNjYWxpbmcoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIC8vIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gX3ZhbHVlLmNsb25lOyAgIFxyXG4gICAgICB0aGlzLmNyZWF0ZUNvbGxpZGVyKG5ldyBPSU1PLlZlYzMoX3ZhbHVlLnggLyAyLCBfdmFsdWUueSAvIDIsIF92YWx1ZS56IC8gMiksIHRoaXMuI3R5cGVDb2xsaWRlcik7IC8vcmVjcmVhdGUgdGhlIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyID0gbmV3IE9JTU8uU2hhcGUodGhpcy4jY29sbGlkZXJJbmZvKTtcclxuICAgICAgbGV0IG9sZENvbGxpZGVyOiBPSU1PLlNoYXBlID0gdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkU2hhcGUodGhpcy4jY29sbGlkZXIpOyAvL2FkZCBuZXcgY29sbGlkZXIsIGJlZm9yZSByZW1vdmluZyB0aGUgb2xkLCBzbyB0aGUgcmIgaXMgbmV2ZXIgYWN0aXZlIHdpdGggMCBjb2xsaWRlcnNcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnJlbW92ZVNoYXBlKG9sZENvbGxpZGVyKTsgLy9yZW1vdmUgdGhlIG9sZCBjb2xsaWRlclxyXG4gICAgICB0aGlzLiNjb2xsaWRlci51c2VyRGF0YSA9IHRoaXM7IC8vcmVzZXQgdGhlIGV4dHJhIGluZm9ybWF0aW9uIHNvIHRoYXQgdGhpcyBjb2xsaWRlciBrbm93cyB0byB3aGljaCBGdWRnZSBDb21wb25lbnQgaXQncyBjb25uZWN0ZWRcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0Q29sbGlzaW9uR3JvdXAodGhpcy5jb2xsaXNpb25Hcm91cCk7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldENvbGxpc2lvbk1hc2sodGhpcy5jb2xsaXNpb25NYXNrKTtcclxuXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldFJlc3RpdHV0aW9uKHRoaXMuI3Jlc3RpdHV0aW9uKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0RnJpY3Rpb24odGhpcy4jZnJpY3Rpb24pO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb250YWN0Q2FsbGJhY2sodGhpcy4jY2FsbGJhY2tzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSByaWdpZGJvZHkgYWNjb3JkaW5nIHRvIGl0cyBpbml0aWFsaXphdGlvbiBzZXR0aW5nIHRvIG1hdGNoIHRoZSBtZXNoLCB0aGUgbm9kZSBvciBpdHMgb3duIHBpdm90IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLm5vZGUpIC8vIGRlbGF5IGluaXRpYWxpemF0aW9uIHVudGlsIHRoaXMgcmlnaWRib2R5IGlzIGF0dGFjaGVkIHRvIGEgbm9kZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgc3dpdGNoIChOdW1iZXIodGhpcy5pbml0aWFsaXphdGlvbikpIHtcclxuICAgICAgICBjYXNlIEJPRFlfSU5JVC5UT19OT0RFOlxyXG4gICAgICAgICAgdGhpcy5tdHhQaXZvdCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCT0RZX0lOSVQuVE9fTUVTSDpcclxuICAgICAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgICAgIGlmIChjbXBNZXNoKVxyXG4gICAgICAgICAgICB0aGlzLm10eFBpdm90ID0gY21wTWVzaC5tdHhQaXZvdC5jbG9uZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9JTklULlRPX1BJVk9UOlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04odGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuXHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IG10eFdvcmxkLnRyYW5zbGF0aW9uOyAvL0FkZGluZyB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBwaXZvdFxyXG4gICAgICBsZXQgcm90YXRpb246IFZlY3RvcjMgPSBtdHhXb3JsZC5nZXRFdWxlckFuZ2xlcygpO1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IG10eFdvcmxkLnNjYWxpbmc7XHJcbiAgICAgIC8vc2NhbGluZyByZXF1aXJlcyBjb2xsaWRlciB0byBiZSByZWNyZWF0ZWRcclxuICAgICAgdGhpcy5zZXRTY2FsaW5nKHNjYWxpbmcpO1xyXG5cclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE1hc3NEYXRhKHRoaXMuI21hc3NEYXRhKTtcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7IC8vc2V0IHRoZSBhY3R1YWwgbmV3IHJvdGF0aW9uL3Bvc2l0aW9uIGZvciB0aGlzIFJiIGFnYWluIHNpbmNlIGl0J3Mgbm93IHVwZGF0ZWRcclxuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbik7XHJcblxyXG4gICAgICB0aGlzLiNtdHhQaXZvdFVuc2NhbGVkID0gTWF0cml4NHg0LkNPTlNUUlVDVElPTih7IHRyYW5zbGF0aW9uOiB0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLCByb3RhdGlvbjogdGhpcy5tdHhQaXZvdC5yb3RhdGlvbiwgc2NhbGluZzogVmVjdG9yMy5PTkUoKSB9KTtcclxuICAgICAgdGhpcy4jbXR4UGl2b3RJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLiNtdHhQaXZvdFVuc2NhbGVkKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCgpO1xyXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFZlbG9jaXR5IGFuZCBGb3JjZXNcclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGN1cnJlbnQgVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXRWZWxvY2l0eSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0TGluZWFyVmVsb2NpdHkoKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnopO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VmVsb2NpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWxvY2l0eTogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBBTkdVTEFSIC0gVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QW5ndWxhclZlbG9jaXR5KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVsb2NpdHk6IE9JTU8uVmVjMyA9IHRoaXMuI3JpZ2lkYm9keS5nZXRBbmd1bGFyVmVsb2NpdHkoKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnopO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgQU5HVUxBUiAtIFZFTE9DSVRZIG9mIHRoZSB7QGxpbmsgTm9kZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEFuZ3VsYXJWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QW5ndWxhclZlbG9jaXR5KHZlbG9jaXR5KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBjb250aW5vdXMgRk9SQ0UgYXQgdGhlIGNlbnRlciBvZiB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTUy5cclxuICAgICogVGhlIGZvcmNlIGlzIG1lYXN1cmVkIGluIG5ld3RvbiwgMWtnIG5lZWRzIGFib3V0IDEwIE5ld3RvbiB0byBmaWdodCBhZ2FpbnN0IGdyYXZpdHkuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5Rm9yY2UoX2ZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUZvcmNlVG9DZW50ZXIobmV3IE9JTU8uVmVjMyhfZm9yY2UueCwgX2ZvcmNlLnksIF9mb3JjZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBjb250aW5vdXMgRk9SQ0UgYXQgYSBzcGVjaWZpYyBwb2ludCBpbiB0aGUgd29ybGQgdG8gdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9keSdzIE1BU1NcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlGb3JjZUF0UG9pbnQoX2ZvcmNlOiBWZWN0b3IzLCBfd29ybGRQb2ludDogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlGb3JjZShuZXcgT0lNTy5WZWMzKF9mb3JjZS54LCBfZm9yY2UueSwgX2ZvcmNlLnopLCBuZXcgT0lNTy5WZWMzKF93b3JsZFBvaW50LngsIF93b3JsZFBvaW50LnksIF93b3JsZFBvaW50LnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQXBwbGllcyBhIGNvbnRpbm91cyBST1RBVElPTkFMIEZPUkNFIChUb3JxdWUpIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5VG9ycXVlKF9yb3RhdGlvbmFsRm9yY2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5VG9ycXVlKG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uYWxGb3JjZS54LCBfcm90YXRpb25hbEZvcmNlLnksIF9yb3RhdGlvbmFsRm9yY2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgaW5zdGFudCBGT1JDRSBhdCBhIHBvaW50L3JpZ2lkYm9keWNlbnRlciB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2QncyBNQVNTXHJcbiAgICAqIEluZmx1ZW5jaW5nIHRoZSBhbmd1bGFyIHNwZWVkIGFuZCB0aGUgbGluZWFyIHNwZWVkLiBcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlJbXB1bHNlQXRQb2ludChfaW1wdWxzZTogVmVjdG9yMywgX3dvcmxkUG9pbnQ6IFZlY3RvcjMgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIF93b3JsZFBvaW50ID0gX3dvcmxkUG9pbnQgIT0gbnVsbCA/IF93b3JsZFBvaW50IDogdGhpcy5nZXRQb3NpdGlvbigpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlJbXB1bHNlKG5ldyBPSU1PLlZlYzMoX2ltcHVsc2UueCwgX2ltcHVsc2UueSwgX2ltcHVsc2UueiksIG5ldyBPSU1PLlZlYzMoX3dvcmxkUG9pbnQueCwgX3dvcmxkUG9pbnQueSwgX3dvcmxkUG9pbnQueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgaW5zdGFudCBGT1JDRSB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTU1xyXG4gICAgKiBPbmx5IGluZmx1ZW5jaW5nIGl0J3Mgc3BlZWQgbm90IHJvdGF0aW9uLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUxpbmVhckltcHVsc2UoX2ltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5TGluZWFySW1wdWxzZShuZXcgT0lNTy5WZWMzKF9pbXB1bHNlLngsIF9pbXB1bHNlLnksIF9pbXB1bHNlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgKiBBcHBsaWVzIGEgaW5zdGFudCBST1RBVElPTkFMLUZPUkNFIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICogT25seSBpbmZsdWVuY2luZyBpdCdzIHJvdGF0aW9uLlxyXG4gICAqL1xyXG4gICAgcHVibGljIGFwcGx5QW5ndWxhckltcHVsc2UoX3JvdGF0aW9uYWxJbXB1bHNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUFuZ3VsYXJJbXB1bHNlKG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uYWxJbXB1bHNlLngsIF9yb3RhdGlvbmFsSW1wdWxzZS55LCBfcm90YXRpb25hbEltcHVsc2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAqIENoYW5naW5nIHRoZSBWRUxPQ0lUWSBvZiB0aGUgUklHSURCT0RZLiBPbmx5IGluZmx1ZW5jaW5nIHRoZSBsaW5lYXIgc3BlZWQgbm90IGFuZ3VsYXJcclxuICAgKi9cclxuICAgIHB1YmxpYyBhZGRWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFkZExpbmVhclZlbG9jaXR5KG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAqIENoYW5naW5nIHRoZSBWRUxPQ0lUWSBvZiB0aGUgUklHSURCT0RZLiBPbmx5IGluZmx1ZW5jaW5nIHRoZSBhbmd1bGFyIHNwZWVkIG5vdCB0aGUgbGluZWFyXHJcbiAgICovXHJcbiAgICBwdWJsaWMgYWRkQW5ndWxhclZlbG9jaXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkQW5ndWxhclZlbG9jaXR5KG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTdG9wcyB0aGUgcmlnaWRib2R5IGZyb20gc2xlZXBpbmcgd2hlbiBtb3ZlbWVudCBpcyB0b28gbWluaW1hbC4gRGVjcmVhc2luZyBwZXJmb3JtYW5jZSwgZm9yIHJhcmVseSBtb3JlIHByZWNpc2UgcGh5c2ljcyByZXN1bHRzICovXHJcbiAgICBwdWJsaWMgZGVhY3RpdmF0ZUF1dG9TbGVlcCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEF1dG9TbGVlcChmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFjdGl2YXRlQXV0b1NsZWVwKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QXV0b1NsZWVwKHRydWUpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIENvbGxpc2lvblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja2luZyBmb3IgQ29sbGlzaW9uIHdpdGggb3RoZXIgQ29sbGlkZXJzIGFuZCBkaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbGxpZGVyLlxyXG4gICAgICogQXV0b21hdGljYWxseSBjYWxsZWQgaW4gdGhlIFJlbmRlck1hbmFnZXIsIG5vIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNoZWNrQ29sbGlzaW9uRXZlbnRzKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgLy8gY2hlY2sgY29sbGlzaW9ucyBvbmx5IGlmIGludGlhbGl6YXRpb24gY29tcGxldGVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgbGlzdDogT0lNTy5Db250YWN0TGluayA9IHRoaXMuI3JpZ2lkYm9keS5nZXRDb250YWN0TGlua0xpc3QoKTsgLy9hbGwgcGh5c2ljYWwgY29udGFjdHMgYmV0d2VlbiBjb2xsaWRpbmcgYm9kaWVzIG9uIHRoaXMgcmJcclxuICAgICAgbGV0IG9iakhpdDogQ29tcG9uZW50UmlnaWRib2R5OyAvL2NvbGxpc2lvbiBjb25zaXN0aW5nIG9mIDIgYm9kaWVzLCBzbyBIaXQxLzJcclxuICAgICAgbGV0IG9iakhpdDI6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuICAgICAgbGV0IGV2ZW50OiBFdmVudFBoeXNpY3M7ICAvL1RoZSBldmVudCB0aGF0IHdpbGwgYmUgc2VuZCBhbmQgdGhlIGluZm9ybWF0aW9ucyBhZGRlZCB0byBpdFxyXG4gICAgICBsZXQgbm9ybWFsSW1wdWxzZTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGJpbm9ybWFsSW1wdWxzZTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRhbmdlbnRJbXB1bHNlOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgY29sUG9pbnQ6IFZlY3RvcjM7XHJcbiAgICAgIC8vQUREIE5FVyBDb2xsaXNpb24gLSBUaGF0IGp1c3QgaGFwcGVuZWRcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuI3JpZ2lkYm9keS5nZXROdW1Db250YWN0TGlua3MoKTsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGNvbGxpc2lvbk1hbmlmb2xkOiBPSU1PLk1hbmlmb2xkID0gbGlzdC5nZXRDb250YWN0KCkuZ2V0TWFuaWZvbGQoKTsgLy9NYW5pZm9sZCA9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBjb250YWN0XHJcbiAgICAgICAgb2JqSGl0ID0gbGlzdC5nZXRDb250YWN0KCkuZ2V0U2hhcGUxKCkudXNlckRhdGE7ICAvL1VzZXJkYXRhIGlzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIMaSLkNvbXBvbmVudFJpZ2lkYm9keSwgaXQncyBhbiBlbXB0eSBPaW1vUGh5c2ljcyBWYXJpYWJsZVxyXG4gICAgICAgIC8vT25seSByZWdpc3RlciB0aGUgY29sbGlzaW9uIG9uIHRoZSBhY3R1YWwgdG91Y2gsIG5vdCBvbiBcInNoYWRvd0NvbGxpZGVcIiwgdG8gcmVnaXN0ZXIgaW4gdGhlIG1vbWVudCBvZiBpbXB1bHNlIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgaWYgKCFvYmpIaXQuaXNJbml0aWFsaXplZClcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChvYmpIaXQgPT0gbnVsbCB8fCBsaXN0LmdldENvbnRhY3QoKS5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpIC8vIG9ubHkgYWN0IGlmIHRoZSBjb2xsaXNpb24gaXMgYWN0dWFsIHRvdWNoaW5nLCBzbyByaWdodCBhdCB0aGUgbW9tZW50IHdoZW4gYSBpbXB1bHNlIGlzIGhhcHBlbmluZywgbm90IHdoZW4gc2hhcGVzIG92ZXJsYXBcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBvYmpIaXQyID0gbGlzdC5nZXRDb250YWN0KCkuZ2V0U2hhcGUyKCkudXNlckRhdGE7XHJcbiAgICAgICAgaWYgKCFvYmpIaXQyLmlzSW5pdGlhbGl6ZWQpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAob2JqSGl0MiA9PSBudWxsIHx8IGxpc3QuZ2V0Q29udGFjdCgpLmlzVG91Y2hpbmcoKSA9PSBmYWxzZSlcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBsZXQgcG9pbnRzOiBPSU1PLk1hbmlmb2xkUG9pbnRbXSA9IGNvbGxpc2lvbk1hbmlmb2xkLmdldFBvaW50cygpOyAvL0FsbCBwb2ludHMgaW4gdGhlIGNvbGxpc2lvbiB3aGVyZSB0aGUgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIGltcGFjdFxyXG4gICAgICAgIGxldCBub3JtYWw6IE9JTU8uVmVjMyA9IGNvbGxpc2lvbk1hbmlmb2xkLmdldE5vcm1hbCgpO1xyXG4gICAgICAgIGlmIChvYmpIaXQuZ2V0T2ltb1JpZ2lkYm9keSgpICE9IHRoaXMuZ2V0T2ltb1JpZ2lkYm9keSgpICYmIHRoaXMuY29sbGlzaW9ucy5pbmRleE9mKG9iakhpdCkgPT0gLTEpIHsgLy9GaXJlLCBpZiB0aGUgaGl0IG9iamVjdCBpcyBub3QgdGhlIEJvZHkgaXRzZWxmIGJ1dCBhbm90aGVyIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGZpcmVkLlxyXG4gICAgICAgICAgbGV0IGNvbFBvczogT0lNTy5WZWMzID0gdGhpcy5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIGNvbGxpc2lvbk1hbmlmb2xkLmdldE51bVBvaW50cygpKTsgLy9USEUgcG9pbnQgb2YgY29sbGlzaW9uIGlzIHRoZSBmaXJzdCB0b3VjaGluZyBwb2ludCAoRVhURU5TSU9OOiBjb3VsZCBiZSB0aGUgY2VudGVyIG9mIGFsbCB0b3VjaGluZyBwb2ludHMgY29tYmluZWQpXHJcbiAgICAgICAgICBjb2xQb2ludCA9IG5ldyBWZWN0b3IzKGNvbFBvcy54LCBjb2xQb3MueSwgY29sUG9zLnopO1xyXG4gICAgICAgICAgcG9pbnRzLmZvckVhY2goKHZhbHVlOiBPSU1PLk1hbmlmb2xkUG9pbnQpOiB2b2lkID0+IHsgLy9UaGUgaW1wYWN0IG9mIHRoZSBjb2xsaXNpb24gaW52b2x2aW5nIGFsbCB0b3VjaGluZyBwb2ludHNcclxuICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSArPSB2YWx1ZS5nZXROb3JtYWxJbXB1bHNlKCk7XHJcbiAgICAgICAgICAgIGJpbm9ybWFsSW1wdWxzZSArPSB2YWx1ZS5nZXRCaW5vcm1hbEltcHVsc2UoKTtcclxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UgKz0gdmFsdWUuZ2V0VGFuZ2VudEltcHVsc2UoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25zLnB1c2gob2JqSGl0KTsgLy9UZWxsIHRoZSBvYmplY3QgdGhhdCB0aGUgZXZlbnQgZm9yIHRoaXMgb2JqZWN0IGRvZXMgbm90IG5lZWQgdG8gYmUgZmlyZWQgYWdhaW5cclxuICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FTlRFUiwgb2JqSGl0LCBub3JtYWxJbXB1bHNlLCB0YW5nZW50SW1wdWxzZSwgYmlub3JtYWxJbXB1bHNlLCBjb2xQb2ludCwgbmV3IFZlY3RvcjMobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueikpOyAvL0J1aWxkaW5nIHRoZSBhY3R1YWwgZXZlbnQsIHdpdGggd2hhdCBvYmplY3QgZGlkIGNvbGxpZGUgYW5kIGluZm9ybWF0aW9ucyBhYm91dCBpdFxyXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy9TZW5kaW5nIHRoZSBnaXZlbiBldmVudFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqSGl0MiAhPSB0aGlzICYmIHRoaXMuY29sbGlzaW9ucy5pbmRleE9mKG9iakhpdDIpID09IC0xKSB7IC8vU2FtZSBhcyB0aGUgYWJvdmUgYnV0IGZvciB0aGUgY2FzZSB0aGUgU0VDT05EIGhpdCBvYmplY3QgaXMgbm90IHRoZSBib2R5IGl0c2VsZlxyXG4gICAgICAgICAgbGV0IGNvbFBvczogT0lNTy5WZWMzID0gdGhpcy5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIGNvbGxpc2lvbk1hbmlmb2xkLmdldE51bVBvaW50cygpKTtcclxuICAgICAgICAgIGNvbFBvaW50ID0gbmV3IFZlY3RvcjMoY29sUG9zLngsIGNvbFBvcy55LCBjb2xQb3Mueik7XHJcbiAgICAgICAgICBwb2ludHMuZm9yRWFjaCgodmFsdWU6IE9JTU8uTWFuaWZvbGRQb2ludCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlICs9IHZhbHVlLmdldE5vcm1hbEltcHVsc2UoKTtcclxuICAgICAgICAgICAgYmlub3JtYWxJbXB1bHNlICs9IHZhbHVlLmdldEJpbm9ybWFsSW1wdWxzZSgpO1xyXG4gICAgICAgICAgICB0YW5nZW50SW1wdWxzZSArPSB2YWx1ZS5nZXRUYW5nZW50SW1wdWxzZSgpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25zLnB1c2gob2JqSGl0Mik7XHJcbiAgICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRU5URVIsIG9iakhpdDIsIG5vcm1hbEltcHVsc2UsIHRhbmdlbnRJbXB1bHNlLCBiaW5vcm1hbEltcHVsc2UsIGNvbFBvaW50LCBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KSk7XHJcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaXN0ID0gbGlzdC5nZXROZXh0KCk7IC8vU3RhcnQgdGhlIHNhbWUgcm91dGluZSB3aXRoIHRoZSBuZXh0IGNvbGxpc2lvbiBpbiB0aGUgbGlzdFxyXG4gICAgICB9XHJcbiAgICAgIC8vUkVNT1ZFIE9MRCBDb2xsaXNpb25zIC0gVGhhdCBkbyBub3QgaGFwcGVuIGFueW1vcmVcclxuICAgICAgdGhpcy5jb2xsaXNpb25zLmZvckVhY2goKHZhbHVlOiBDb21wb25lbnRSaWdpZGJvZHkpID0+IHsgLy9FdmVyeSBDb2xsaWRlciBpbiB0aGUgbGlzdCBpcyBjaGVja2VkIGlmIHRoZSBjb2xsaXNpb24gaXMgc3RpbGwgaGFwcGVuaW5nXHJcbiAgICAgICAgbGV0IGlzQ29sbGlkaW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgbGlzdCA9IHRoaXMuI3JpZ2lkYm9keS5nZXRDb250YWN0TGlua0xpc3QoKTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy4jcmlnaWRib2R5LmdldE51bUNvbnRhY3RMaW5rcygpOyBpKyspIHtcclxuICAgICAgICAgIG9iakhpdCA9IGxpc3QuZ2V0Q29udGFjdCgpLmdldFNoYXBlMSgpLnVzZXJEYXRhO1xyXG4gICAgICAgICAgb2JqSGl0MiA9IGxpc3QuZ2V0Q29udGFjdCgpLmdldFNoYXBlMigpLnVzZXJEYXRhO1xyXG4gICAgICAgICAgaWYgKHZhbHVlID09IG9iakhpdCB8fCB2YWx1ZSA9PSBvYmpIaXQyKSB7IC8vSWYgdGhlIGdpdmVuIG9iamVjdCBpbiB0aGUgY29sbGlzaW9ucyBsaXN0IGlzIHN0aWxsIG9uZSBvZiB0aGUgb2JqSGl0IHRoZSBjb2xsaXNpb24gaXMgbm90IENvbGxpc2lvbkVYSVRcclxuICAgICAgICAgICAgaXNDb2xsaWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGlzdCA9IGxpc3QuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNDb2xsaWRpbmcgPT0gZmFsc2UpIHsgLy9UaGUgY29sbGlzaW9uIGlzIGV4aXRpbmcgYnV0IHdhcyBpbiB0aGUgY29sbGlzaW9uIGxpc3QsIHRoZW4gRVhJVCBFdmVudCBuZWVkcyB0byBiZSBmaXJlZFxyXG4gICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSB0aGlzLmNvbGxpc2lvbnMuaW5kZXhPZih2YWx1ZSk7IC8vRmluZCBvYmplY3QgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICB0aGlzLmNvbGxpc2lvbnMuc3BsaWNlKGluZGV4KTsgLy9yZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXlcclxuICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FWElULCB2YWx1ZSwgMCwgMCwgMCk7XHJcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBhIHJheSB0aHJvdWdoIHRoaXMgc3BlY2lmaWMgYm9keSBpZ25vcmluZyB0aGUgcmVzdCBvZiB0aGUgd29ybGQgYW5kIGNoZWNrcyBpZiB0aGlzIGJvZHkgd2FzIGhpdCBieSB0aGUgcmF5LFxyXG4gICAgICogcmV0dXJuaW5nIGluZm8gYWJvdXQgdGhlIGhpdC4gUHJvdmlkZXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBhbmQgaW5mb3JtYXRpb24gYSByZWd1bGFyIHJheWNhc3QgZG9lcyBidXQgdGhlIHJheSBpcyBvbmx5IHRlc3RpbmcgYWdhaW5zdCB0aGlzIHNwZWNpZmljIGJvZHkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByYXljYXN0VGhpc0JvZHkoX29yaWdpbjogVmVjdG9yMywgX2RpcmVjdGlvbjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyLCBfZGVidWdEcmF3OiBib29sZWFuID0gZmFsc2UpOiBSYXlIaXRJbmZvIHtcclxuICAgICAgbGV0IGhpdEluZm86IFJheUhpdEluZm8gPSBuZXcgUmF5SGl0SW5mbygpO1xyXG4gICAgICBsZXQgZ2VvbWV0cnk6IE9JTU8uR2VvbWV0cnkgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuZ2V0R2VvbWV0cnkoKTtcclxuICAgICAgbGV0IHRyYW5zZm9ybTogT0lNTy5UcmFuc2Zvcm0gPSB0aGlzLiNyaWdpZGJvZHkuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgIGxldCBzY2FsZWREaXJlY3Rpb246IFZlY3RvcjMgPSBfZGlyZWN0aW9uLmNsb25lO1xyXG4gICAgICBzY2FsZWREaXJlY3Rpb24uc2NhbGUoX2xlbmd0aCk7XHJcbiAgICAgIGxldCBlbmRwb2ludDogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKHNjYWxlZERpcmVjdGlvbiwgX29yaWdpbi5jbG9uZSk7XHJcbiAgICAgIGxldCBvaW1vUmF5OiBPSU1PLlJheUNhc3RIaXQgPSBuZXcgT0lNTy5SYXlDYXN0SGl0KCk7XHJcbiAgICAgIGxldCBoaXQ6IGJvb2xlYW4gPSBnZW9tZXRyeS5yYXlDYXN0KG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueiksIG5ldyBPSU1PLlZlYzMoZW5kcG9pbnQueCwgZW5kcG9pbnQueSwgZW5kcG9pbnQueiksIHRyYW5zZm9ybSwgb2ltb1JheSk7IC8vdGhlIGFjdHVhbCBPaW1vUGh5c2ljcyBSYXljYXN0XHJcbiAgICAgIGlmIChoaXQpIHsgIC8vSWYgaGl0IHJldHVybiBhIGJ1bmNoIG9mIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgaGl0XHJcbiAgICAgICAgaGl0SW5mby5oaXQgPSB0cnVlO1xyXG4gICAgICAgIGhpdEluZm8uaGl0UG9pbnQgPSBuZXcgVmVjdG9yMyhvaW1vUmF5LnBvc2l0aW9uLngsIG9pbW9SYXkucG9zaXRpb24ueSwgb2ltb1JheS5wb3NpdGlvbi56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdE5vcm1hbCA9IG5ldyBWZWN0b3IzKG9pbW9SYXkubm9ybWFsLngsIG9pbW9SYXkubm9ybWFsLnksIG9pbW9SYXkubm9ybWFsLnopO1xyXG4gICAgICAgIGxldCBkeDogbnVtYmVyID0gX29yaWdpbi54IC0gaGl0SW5mby5oaXRQb2ludC54OyAgLy9jYWxjdWxhdGUgaGl0IGRpc3RhbmNlXHJcbiAgICAgICAgbGV0IGR5OiBudW1iZXIgPSBfb3JpZ2luLnkgLSBoaXRJbmZvLmhpdFBvaW50Lnk7XHJcbiAgICAgICAgbGV0IGR6OiBudW1iZXIgPSBfb3JpZ2luLnogLSBoaXRJbmZvLmhpdFBvaW50Lno7XHJcbiAgICAgICAgaGl0SW5mby5oaXREaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xyXG4gICAgICAgIGhpdEluZm8ucmlnaWRib2R5Q29tcG9uZW50ID0gdGhpcztcclxuICAgICAgICBoaXRJbmZvLnJheU9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgICAgaGl0SW5mby5yYXlFbmQgPSBlbmRwb2ludDtcclxuICAgICAgfSBlbHNlIHsgLy9Pbmx5IHRlbGwgdGhlIG9yaWdpbiwgYW5kIHRoZSBoaXQgcG9pbnQgaXMgdGhlIGVuZCBvZiB0aGUgcmF5LlxyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMoZW5kcG9pbnQueCwgZW5kcG9pbnQueSwgZW5kcG9pbnQueik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9kZWJ1Z0RyYXcpIHtcclxuICAgICAgICBQaHlzaWNzLmRlYnVnRHJhdy5kZWJ1Z1JheShoaXRJbmZvLnJheU9yaWdpbiwgaGl0SW5mby5oaXRQb2ludCwgbmV3IENvbG9yKDAsIDEsIDAsIDEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGl0SW5mbztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmcgLSBTb21lIHByb3BlcnRpZXMgbWlnaHQgYmUgbWlzc2luZywgZS5nLiBjb252ZXhNZXNoIChGbG9hdDMyQXJyYXkpXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG5cclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24ubXR4UGl2b3Q7XHJcbiAgICAgIGRlbGV0ZSBzZXJpYWxpemF0aW9uLmFjdGl2ZTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZUJvZHkgPSBCT0RZX1RZUEVbdGhpcy4jdHlwZUJvZHldO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnR5cGVDb2xsaWRlciA9IENPTExJREVSX1RZUEVbdGhpcy4jdHlwZUNvbGxpZGVyXTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pbml0aWFsaXphdGlvbiA9IEJPRFlfSU5JVFt0aGlzLmluaXRpYWxpemF0aW9uXTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWQgPSB0aGlzLiNpZDtcclxuICAgICAgc2VyaWFsaXphdGlvbi5waXZvdCA9IHRoaXMubXR4UGl2b3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgdGhpcy4jaWQgPSBfc2VyaWFsaXphdGlvbi5pZDtcclxuICAgICAgdGhpcy5tYXNzID0gaWZOdW1iZXIoX3NlcmlhbGl6YXRpb24ubWFzcywgdGhpcy5tYXNzKTtcclxuICAgICAgdGhpcy5kYW1wVHJhbnNsYXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5kYW1wVHJhbnNsYXRpb24sIHRoaXMuZGFtcFRyYW5zbGF0aW9uKTtcclxuICAgICAgdGhpcy5kYW1wUm90YXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5kYW1wUm90YXRpb24sIHRoaXMuZGFtcFJvdGF0aW9uKTtcclxuICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmNvbGxpc2lvbkdyb3VwLCB0aGlzLmNvbGxpc2lvbkdyb3VwKTtcclxuICAgICAgdGhpcy5lZmZlY3RSb3RhdGlvbiA9IF9zZXJpYWxpemF0aW9uLmVmZmVjdFJvdGF0aW9uIHx8IHRoaXMuZWZmZWN0Um90YXRpb247XHJcbiAgICAgIHRoaXMuZWZmZWN0R3Jhdml0eSA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmVmZmVjdEdyYXZpdHksIHRoaXMuZWZmZWN0R3Jhdml0eSk7XHJcbiAgICAgIHRoaXMuZnJpY3Rpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5mcmljdGlvbiwgdGhpcy5mcmljdGlvbik7XHJcbiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5yZXN0aXR1dGlvbiwgdGhpcy5yZXN0aXR1dGlvbik7XHJcbiAgICAgIHRoaXMuaXNUcmlnZ2VyID0gX3NlcmlhbGl6YXRpb24uaXNUcmlnZ2VyIHx8IHRoaXMuaXNUcmlnZ2VyO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb24uaW5pdGlhbGl6YXRpb247XHJcblxyXG4gICAgICB0aGlzLmluaXRpYWxpemF0aW9uID0gPG51bWJlcj48dW5rbm93bj5CT0RZX0lOSVRbX3NlcmlhbGl6YXRpb24uaW5pdGlhbGl6YXRpb25dO1xyXG4gICAgICB0aGlzLnR5cGVCb2R5ID0gPG51bWJlcj48dW5rbm93bj5CT0RZX1RZUEVbX3NlcmlhbGl6YXRpb24udHlwZUJvZHldO1xyXG4gICAgICB0aGlzLnR5cGVDb2xsaWRlciA9IDxudW1iZXI+PHVua25vd24+Q09MTElERVJfVFlQRVtfc2VyaWFsaXphdGlvbi50eXBlQ29sbGlkZXJdO1xyXG4gICAgICAvLyB0aGlzLmNyZWF0ZSh0aGlzLm1hc3MsIHRoaXMuI3R5cGVCb2R5LCB0aGlzLiN0eXBlQ29sbGlkZXIsIHRoaXMuY29sbGlzaW9uR3JvdXAsIG51bGwsIHRoaXMuY29udmV4TWVzaCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGFuZ2UgcHJvcGVydGllcyBieSBhbiBhc3NvY2lhdGl2ZSBhcnJheSAqL1xyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAoX211dGF0b3IudHlwZUJvZHkgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIF9tdXRhdG9yLnR5cGVCb2R5ID0gcGFyc2VJbnQoX211dGF0b3IudHlwZUJvZHkpO1xyXG4gICAgICBpZiAoX211dGF0b3IudHlwZUNvbGxpZGVyICE9IHVuZGVmaW5lZClcclxuICAgICAgICBfbXV0YXRvci50eXBlQ29sbGlkZXIgPSBwYXJzZUludChfbXV0YXRvci50eXBlQ29sbGlkZXIpO1xyXG4gICAgICBpZiAoX211dGF0b3IuaW5pdGlhbGl6YXRpb24gIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIF9tdXRhdG9yLmluaXRpYWxpemF0aW9uID0gcGFyc2VJbnQoX211dGF0b3IuaW5pdGlhbGl6YXRpb24pO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICBpZiAoX211dGF0b3IuaW5pdGlhbGl6YXRpb24gIT0gdW5kZWZpbmVkICYmIHRoaXMuaXNBY3RpdmUpXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICAgIC8vIFRPRE86IHNlZSBpZiB0aGlzIGFsdGVybmF0aXZlIHNob3VsZCBiZSwgYXQgbGVhc3QgcGFydGlhbGx5LCBkb25lIHdpdGggbXV0YXRlU2VsZWN0aW9uXHJcbiAgICAgIC8vIGxldCBjYWxsSWZFeGlzdDogRnVuY3Rpb24gPSAoX2tleTogc3RyaW5nLCBfc2V0dGVyOiBGdW5jdGlvbikgPT4ge1xyXG4gICAgICAvLyAgIGlmIChfbXV0YXRvcltfa2V5XSlcclxuICAgICAgLy8gICAgIF9zZXR0ZXIoX211dGF0b3JbX2tleV0pO1xyXG4gICAgICAvLyB9O1xyXG5cclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJmcmljdGlvblwiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMuZnJpY3Rpb24gPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcInJlc3RpdHV0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5yZXN0aXR1dGlvbiA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwibWFzc1wiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMubWFzcyA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwiZGFtcFRyYW5zbGF0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5kYW1wVHJhbnNsYXRpb24gPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcImRhbXBSb3RhdGlvblwiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMuZGFtcFJvdGF0aW9uID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJlZmZlY3RHcmF2aXR5XCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5lZmZlY3RHcmF2aXR5ID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJjb2xsaXNpb25Hcm91cFwiLCAoX3ZhbHVlOiBDT0xMSVNJT05fR1JPVVApID0+IHRoaXMuY29sbGlzaW9uR3JvdXAgPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcInR5cGVCb2R5XCIsIChfdmFsdWU6IHN0cmluZykgPT4gdGhpcy50eXBlQm9keSA9IHBhcnNlSW50KF92YWx1ZSkpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcInR5cGVDb2xsaWRlclwiLCAoX3ZhbHVlOiBzdHJpbmcpID0+IHRoaXMudHlwZUNvbGxpZGVyID0gcGFyc2VJbnQoX3ZhbHVlKSk7XHJcblxyXG4gICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcblxyXG4gICAgICBtdXRhdG9yLmZyaWN0aW9uID0gdGhpcy5mcmljdGlvbjtcclxuICAgICAgbXV0YXRvci5yZXN0aXR1dGlvbiA9IHRoaXMucmVzdGl0dXRpb247XHJcbiAgICAgIG11dGF0b3IubWFzcyA9IHRoaXMubWFzcztcclxuICAgICAgbXV0YXRvci5kYW1wVHJhbnNsYXRpb24gPSB0aGlzLmRhbXBUcmFuc2xhdGlvbjtcclxuICAgICAgbXV0YXRvci5kYW1wUm90YXRpb24gPSB0aGlzLmRhbXBSb3RhdGlvbjtcclxuICAgICAgbXV0YXRvci5lZmZlY3RHcmF2aXR5ID0gdGhpcy5lZmZlY3RHcmF2aXR5O1xyXG4gICAgICBtdXRhdG9yLnR5cGVCb2R5ID0gdGhpcy4jdHlwZUJvZHk7XHJcbiAgICAgIG11dGF0b3IudHlwZUNvbGxpZGVyID0gdGhpcy4jdHlwZUNvbGxpZGVyO1xyXG4gICAgICBtdXRhdG9yLmlzVHJpZ2dlciA9IHRoaXMuI2lzVHJpZ2dlcjtcclxuXHJcbiAgICAgIC8vIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhtdXRhdG9yKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLnR5cGVCb2R5KVxyXG4gICAgICAgIHR5cGVzLnR5cGVCb2R5ID0gQk9EWV9UWVBFO1xyXG4gICAgICBpZiAodHlwZXMudHlwZUNvbGxpZGVyKVxyXG4gICAgICAgIHR5cGVzLnR5cGVDb2xsaWRlciA9IENPTExJREVSX1RZUEU7XHJcbiAgICAgIGlmICh0eXBlcy5pbml0aWFsaXphdGlvbilcclxuICAgICAgICB0eXBlcy5pbml0aWFsaXphdGlvbiA9IEJPRFlfSU5JVDtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuY29udmV4TWVzaDsgLy9Db252ZXggTWVzaCBjYW4ndCBiZSBzaG93biBpbiB0aGUgZWRpdG9yIGJlY2F1c2UgZmxvYXQzMkFycmF5IGlzIG5vdCBhIHZpYWJsZSBtdXRhdG9yXHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5jb2xsaXNpb25NYXNrO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuaXNJbml0aWFsaXplZDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBDcmVhdGlvblxyXG4gICAgcHJpdmF0ZSBjcmVhdGUoX21hc3M6IG51bWJlciA9IDEsIF90eXBlOiBCT0RZX1RZUEUgPSBCT0RZX1RZUEUuRFlOQU1JQywgX2NvbGxpZGVyVHlwZTogQ09MTElERVJfVFlQRSA9IENPTExJREVSX1RZUEUuQ1VCRSwgX2dyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRDb2xsaXNpb25Hcm91cCwgX210eFRyYW5zZm9ybTogTWF0cml4NHg0ID0gbnVsbCwgX2NvbnZleE1lc2g6IEZsb2F0MzJBcnJheSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgLy9TZXR0aW5nIHVwIGFsbCBpbmNvbWluZyB2YWx1ZXMgdG8gYmUgaW50ZXJuYWwgdmFsdWVzXHJcbiAgICAgIHRoaXMuY29udmV4TWVzaCA9IF9jb252ZXhNZXNoO1xyXG4gICAgICB0aGlzLiN0eXBlQm9keSA9IF90eXBlO1xyXG4gICAgICB0aGlzLiNjb2xsaXNpb25Hcm91cCA9IF9ncm91cDtcclxuICAgICAgdGhpcy4jdHlwZUNvbGxpZGVyID0gX2NvbGxpZGVyVHlwZTtcclxuICAgICAgdGhpcy5tYXNzID0gX21hc3M7XHJcbiAgICAgIHRoaXMuI3Jlc3RpdHV0aW9uID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0UmVzdGl0dXRpb247XHJcbiAgICAgIHRoaXMuI2ZyaWN0aW9uID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0RnJpY3Rpb247XHJcbiAgICAgIHRoaXMuY29sbGlzaW9uTWFzayA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdENvbGxpc2lvbk1hc2s7XHJcbiAgICAgIC8vQ3JlYXRlIHRoZSBhY3R1YWwgcmlnaWRib2R5IGluIHRoZSBPaW1vUGh5c2ljcyBTcGFjZVxyXG4gICAgICB0aGlzLmNyZWF0ZVJpZ2lkYm9keShfbWFzcywgX3R5cGUsIHRoaXMuI3R5cGVDb2xsaWRlciwgX210eFRyYW5zZm9ybSwgdGhpcy4jY29sbGlzaW9uR3JvdXApO1xyXG4gICAgICB0aGlzLiNpZCA9IFBoeXNpY3MuZGlzdHJpYnV0ZUJvZHlJRCgpO1xyXG5cclxuICAgICAgLy8gRXZlbnQgQ2FsbGJhY2tzIGRpcmVjdGx5IGZyb20gT0lNTyBQaHlzaWNzXHJcbiAgICAgIHRoaXMuI2NhbGxiYWNrcyA9IG5ldyBPSU1PLkNvbnRhY3RDYWxsYmFjaygpOyAvL2ZlaG1cclxuICAgICAgdGhpcy4jY2FsbGJhY2tzLmJlZ2luVHJpZ2dlckNvbnRhY3QgPSB0aGlzLnRyaWdnZXJFbnRlcjtcclxuICAgICAgdGhpcy4jY2FsbGJhY2tzLmVuZFRyaWdnZXJDb250YWN0ID0gdGhpcy50cmlnZ2VyRXhpdDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlcyB0aGUgYWN0dWFsIE9pbW9QaHlzaWNzIFJpZ2lkYm9keSBvdXQgb2YgaW5mb3JtYXRpb25zIHRoZSBGdWRnZSBDb21wb25lbnQgaGFzLiAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVSaWdpZGJvZHkoX21hc3M6IG51bWJlciwgX3R5cGU6IEJPRFlfVFlQRSwgX2NvbGxpZGVyVHlwZTogQ09MTElERVJfVFlQRSwgX210eFRyYW5zZm9ybTogTWF0cml4NHg0LCBfY29sbGlzaW9uR3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IENPTExJU0lPTl9HUk9VUC5ERUZBVUxUKTogdm9pZCB7XHJcbiAgICAgIGxldCBvaW1vVHlwZTogbnVtYmVyOyAvL05lZWQgdGhlIGNvbnZlcnNpb24gZnJvbSBzaW1wbGUgZW51bSB0byBudW1iZXIgYmVjYXVzZSBpZiBlbnVtIGlzIGRlZmluZWQgYXMgT2ltby5SaWdpZHlCb2R5VHlwZSB5b3UgaGF2ZSB0byBpbmNsdWRlIE9pbW8gdG8gdXNlIEZVREdFIGF0IGFsbFxyXG4gICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgY2FzZSBCT0RZX1RZUEUuRFlOQU1JQzpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLkRZTkFNSUM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJPRFlfVFlQRS5TVEFUSUM6XHJcbiAgICAgICAgICBvaW1vVHlwZSA9IE9JTU8uUmlnaWRCb2R5VHlwZS5TVEFUSUM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJPRFlfVFlQRS5LSU5FTUFUSUM6XHJcbiAgICAgICAgICBvaW1vVHlwZSA9IE9JTU8uUmlnaWRCb2R5VHlwZS5LSU5FTUFUSUM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgb2ltb1R5cGUgPSBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZW1vdmUgYWxsIHByZXZpb3VzIHNoYXBlcyBmcm9tIHdvcmxkLiBOZWNlc3Nhcnk/XHJcbiAgICAgIC8vIHdoaWxlICh0aGlzLiNyaWdpZGJvZHkgJiYgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpICE9IG51bGwpXHJcbiAgICAgIC8vICAgdGhpcy4jcmlnaWRib2R5LnJlbW92ZVNoYXBlKHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKSk7XHJcblxyXG4gICAgICBsZXQgdG1wVHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBfbXR4VHJhbnNmb3JtID09IG51bGwgPyBzdXBlci5ub2RlICE9IG51bGwgPyBzdXBlci5ub2RlLm10eFdvcmxkIDogTWF0cml4NHg0LklERU5USVRZKCkgOiBfbXR4VHJhbnNmb3JtOyAvL0dldCB0cmFuc2Zvcm0gaW5mb3JtYXRpb25zIGZyb20gdGhlIHdvcmxkLCBzaW5jZSBwaHlzaWNzIGRvZXMgbm90IGNhcmUgYWJvdXQgaGllcmFyY2h5XHJcbiAgICAgIC8vQ29udmVydCBpbmZvcm1hdGlvbnMgZnJvbSBGdWRnZSB0byBPaW1vUGh5c2ljcyBhbmQgY3JlYXRpbmcgYSBjb2xsaWRlciB3aXRoIGl0LCB3aGlsZSBhbHNvIGFkZGluZyBhIHBpdm90IHRvIGRlcml2YXRlIGZyb20gdGhlIHRyYW5zZm9ybSBpbmZvcm1hdGlvbnMgaWYgbmVlZGVkXHJcbiAgICAgIGxldCBzY2FsZTogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMygodG1wVHJhbnNmb3JtLnNjYWxpbmcueCAqIHRoaXMubXR4UGl2b3Quc2NhbGluZy54KSAvIDIsICh0bXBUcmFuc2Zvcm0uc2NhbGluZy55ICogdGhpcy5tdHhQaXZvdC5zY2FsaW5nLnkpIC8gMiwgKHRtcFRyYW5zZm9ybS5zY2FsaW5nLnogKiB0aGlzLm10eFBpdm90LnNjYWxpbmcueikgLyAyKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKHRtcFRyYW5zZm9ybS50cmFuc2xhdGlvbi54ICsgdGhpcy5tdHhQaXZvdC50cmFuc2xhdGlvbi54LCB0bXBUcmFuc2Zvcm0udHJhbnNsYXRpb24ueSArIHRoaXMubXR4UGl2b3QudHJhbnNsYXRpb24ueSwgdG1wVHJhbnNmb3JtLnRyYW5zbGF0aW9uLnogKyB0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLnopO1xyXG4gICAgICBsZXQgcm90YXRpb246IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzModG1wVHJhbnNmb3JtLnJvdGF0aW9uLnggKyB0aGlzLm10eFBpdm90LnJvdGF0aW9uLngsIHRtcFRyYW5zZm9ybS5yb3RhdGlvbi55ICsgdGhpcy5tdHhQaXZvdC5yb3RhdGlvbi55LCB0bXBUcmFuc2Zvcm0ucm90YXRpb24ueiArIHRoaXMubXR4UGl2b3Qucm90YXRpb24ueik7XHJcbiAgICAgIHRoaXMuY3JlYXRlQ29sbGlkZXIoc2NhbGUsIF9jb2xsaWRlclR5cGUpO1xyXG4gICAgICAvL1NldHRpbmcgaW5mb3JtYXRpb25zIGFib3V0IG1hc3MsIHBvc2l0aW9uL3JvdGF0aW9uIGFuZCBwaHlzaWNhbCByZWFjdGlvbiB0eXBlXHJcbiAgICAgIHRoaXMuI21hc3NEYXRhLm1hc3MgPSBfbWFzczsgLy9fdHlwZSAhPSBQSFlTSUNTX1RZUEUuU1RBVElDID8gX21hc3MgOiAwOyAvL0lmIGEgb2JqZWN0IGlzIHN0YXRpYyBpdCBhY3RzIGFzIGlmIGl0IGhhcyBubyBtYXNzXHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keUluZm8udHlwZSA9IG9pbW9UeXBlO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHlJbmZvLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keUluZm8ucm90YXRpb24uZnJvbUV1bGVyWHl6KG5ldyBPSU1PLlZlYzMocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueikpOyAvL0NvbnZlcnQgZXVsZXJBbmdsZXMgaW4gZGVncmVlIHRvIHRoZSBpbnRlcm5hbGx5IHVzZWQgcXVhdGVybmlvbnNcclxuICAgICAgLy9DcmVhdGluZyB0aGUgYWN0dWFsIHJpZ2lkYm9keSBhbmQgaXQncyBjb2xsaWRlclxyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkgPSBuZXcgT0lNTy5SaWdpZEJvZHkodGhpcy4jcmlnaWRib2R5SW5mbyk7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyID0gbmV3IE9JTU8uU2hhcGUodGhpcy4jY29sbGlkZXJJbmZvKTtcclxuICAgICAgLy9GaWxsaW5nIHRoZSBhZGRpdGlvbmFsIHNldHRpbmdzIGFuZCBpbmZvcm1hdGlvbnMgdGhlIHJpZ2lkYm9keSBuZWVkcy4gV2hvIGlzIGNvbGxpZGluZywgaG93IGlzIHRoZSBjb2xsaXNpb24gaGFuZGxlZCAoZGFtcGluZywgaW5mbHVlbmNlIGZhY3RvcnMpXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnVzZXJEYXRhID0gdGhpcztcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0Q29sbGlzaW9uR3JvdXAoX2NvbGxpc2lvbkdyb3VwKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0Q29sbGlzaW9uTWFzayh0aGlzLmNvbGxpc2lvbk1hc2spO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkU2hhcGUodGhpcy4jY29sbGlkZXIpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TWFzc0RhdGEodGhpcy4jbWFzc0RhdGEpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0UmVzdGl0dXRpb24odGhpcy4jcmVzdGl0dXRpb24pO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0RnJpY3Rpb24odGhpcy4jZnJpY3Rpb24pO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0Q29udGFjdENhbGxiYWNrKHRoaXMuI2NhbGxiYWNrcyk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRMaW5lYXJEYW1waW5nKHRoaXMuI2RhbXBpbmdMaW5lYXIpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QW5ndWxhckRhbXBpbmcodGhpcy4jZGFtcGluZ0FuZ3VsYXIpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0R3Jhdml0eVNjYWxlKHRoaXMuI2VmZmVjdEdyYXZpdHkpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0Um90YXRpb25GYWN0b3IobmV3IE9JTU8uVmVjMyh0aGlzLiNlZmZlY3RSb3RhdGlvbi54LCB0aGlzLiNlZmZlY3RSb3RhdGlvbi55LCB0aGlzLiNlZmZlY3RSb3RhdGlvbi56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0ZXMgYSBjb2xsaWRlciBhIHNoYXBlIHRoYXQgcmVwcmVzZW50cyB0aGUgb2JqZWN0IGluIHRoZSBwaHlzaWNhbCB3b3JsZC4gICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZUNvbGxpZGVyKF9zY2FsZTogT0lNTy5WZWMzLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFKTogdm9pZCB7XHJcbiAgICAgIGxldCBzaGFwZUNvbmY6IE9JTU8uU2hhcGVDb25maWcgPSBuZXcgT0lNTy5TaGFwZUNvbmZpZygpOyAvL0NvbGxpZGVyIHdpdGggZ2VvbWV0cnkgYW5kIGluZm9zIGxpa2UgZnJpY3Rpb24vcmVzdGl0dXRpb24gYW5kIG1vcmVcclxuICAgICAgbGV0IGdlb21ldHJ5OiBPSU1PLkdlb21ldHJ5O1xyXG4gICAgICBpZiAodGhpcy50eXBlQ29sbGlkZXIgIT0gX2NvbGxpZGVyVHlwZSkgLy9JZiB0aGUgY29sbGlkZXIgdHlwZSB3YXMgY2hhbmdlZCBzZXQgdGhlIGludGVybmFsIG9uZSBuZXcsIGVsc2UgZG9uJ3Qgc28gdGhlcmUgaXMgbm90IGluZmluaXRlIHNldCBjYWxsc1xyXG4gICAgICAgIHRoaXMudHlwZUNvbGxpZGVyID0gX2NvbGxpZGVyVHlwZTtcclxuICAgICAgc3dpdGNoIChfY29sbGlkZXJUeXBlKSB7ICAvL0NyZWF0ZSBhIGRpZmZlcmVudCBPaW1vUGh5c2ljcyBnZW9tZXRyeSBiYXNlZCBvbiB0aGUgZ2l2ZW4gdHlwZS4gVGhhdCBpcyBvbmx5IHRoZSBtYXRoZW1hdGljYWwgc2hhcGUgb2YgdGhlIGNvbGxpZGVyXHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNVQkU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLkJveEdlb21ldHJ5KF9zY2FsZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuU1BIRVJFOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgT0lNTy5TcGhlcmVHZW9tZXRyeShfc2NhbGUueCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuQ0FQU1VMRTpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQ2Fwc3VsZUdlb21ldHJ5KF9zY2FsZS54LCBfc2NhbGUueSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuQ1lMSU5ERVI6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLkN5bGluZGVyR2VvbWV0cnkoX3NjYWxlLngsIF9zY2FsZS55KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DT05FOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgT0lNTy5Db25lR2VvbWV0cnkoX3NjYWxlLngsIF9zY2FsZS55KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5QWVJBTUlEOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSB0aGlzLmNyZWF0ZUNvbnZleEdlb21ldHJ5Q29sbGlkZXIodGhpcy5jcmVhdGVQeXJhbWlkVmVydGljZXMoKSwgX3NjYWxlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DT05WRVg6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IHRoaXMuY3JlYXRlQ29udmV4R2VvbWV0cnlDb2xsaWRlcih0aGlzLmNvbnZleE1lc2gsIF9zY2FsZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBzaGFwZUNvbmYuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuICAgICAgdGhpcy4jY29sbGlkZXJJbmZvID0gc2hhcGVDb25mOyAvL3RoZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9ucyB0aGF0IGFyZSB1c2VkIHRvIGFkZCBhbiBhY3R1YWwgY29sbGlkZXIgdG8gdGhlIHJpZ2lkYm9keSBpbiBjcmVhdGVSaWdpZGJvZHlcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRpbmcgYSBzaGFwZSB0aGF0IHJlcHJlc2VudHMgYSBpbiBpdHNlbGYgY2xvc2VkIGZvcm0sIG91dCBvZiB0aGUgZ2l2ZW4gdmVydGljZXMuICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZUNvbnZleEdlb21ldHJ5Q29sbGlkZXIoX3ZlcnRpY2VzOiBGbG9hdDMyQXJyYXksIF9zY2FsZTogT0lNTy5WZWMzKTogT0lNTy5Db252ZXhIdWxsR2VvbWV0cnkge1xyXG4gICAgICBsZXQgdmVydGljZXNBc1ZlYzM6IE9JTU8uVmVjM1tdID0gbmV3IEFycmF5KCk7IC8vQ29udmVydCBGdWRnZSBWZWN0b3IzIHRvIE9pbW9WZWMzXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfdmVydGljZXMubGVuZ3RoOyBpICs9IDMpIHsgLy8zIFZhbHVlcyBmb3Igb25lIHBvaW50XHJcbiAgICAgICAgdmVydGljZXNBc1ZlYzMucHVzaChuZXcgT0lNTy5WZWMzKF92ZXJ0aWNlc1tpXSAqIF9zY2FsZS54LCBfdmVydGljZXNbaSArIDFdICogX3NjYWxlLnksIF92ZXJ0aWNlc1tpICsgMl0gKiBfc2NhbGUueikpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgT0lNTy5Db252ZXhIdWxsR2VvbWV0cnkodmVydGljZXNBc1ZlYzMpOyAvL1RlbGwgT2ltb1BoeXNpY3MgdG8gY3JlYXRlIGEgaHVsbCB0aGF0IGludm9sdmVzIGFsbCBwb2ludHMgYnV0IGNsb3NlIGl0IG9mLiBBIGNvbnZleCBzaGFwZSBjYW4gbm90IGhhdmUgYSBob2xlIGluIGl0LlxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB2ZXJ0aWNlcyB0aGF0IGNvbnN0cnVjdCBhIHB5cmFtaWQuIFRoZSB2ZXJ0aWNlcyBvZiB0aGUgaW1wbGVtZW50ZWQgcHlyYW1pZCBtZXNoIGNhbiBiZSB1c2VkIHRvby4gQnV0IHRoZXkgYXJlIGhhbGZlZCBhbmQgZG91YmxlIHNpZGVkLCBzbyBpdCdzIG1vcmUgcGVyZm9ybWFudCB0byB1c2UgdGhpcy4gKi9cclxuICAgIHByaXZhdGUgY3JlYXRlUHlyYW1pZFZlcnRpY2VzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB2ZXJ0aWNlczogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgLyowKi8tMSwgMCwgMSwgLyoxKi8gMSwgMCwgMSwgIC8qMiovIDEsIDAsIC0xLCAvKjMqLyAtMSwgMCwgLTEsXHJcbiAgICAgICAgLyo0Ki8gMCwgMiwgMFxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBZGRpbmcgdGhpcyBDb21wb25lbnRSaWdpZGJvZHkgdG8gdGhlIFBoeXNpc2NzLndvcmxkIGdpdmluZyB0aGUgb2ltb1BoeXNpY3Mgc3lzdGVtIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgKi9cclxuICAgIHByaXZhdGUgYWRkUmlnaWRib2R5VG9Xb3JsZCA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKCF0aGlzLiNyaWdpZGJvZHkuX3dvcmxkKVxyXG4gICAgICAgIFBoeXNpY3MuYWRkUmlnaWRib2R5KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZW1vdmluZyB0aGlzIENvbXBvbmVudFJpZ2lkYm9keSBmcm9tIHRoZSBQaHlzaXNjcy53b3JsZCB0YWtpbmcgdGhlIGluZm9ybWF0aW9ucyBmcm9tIHRoZSBvaW1vUGh5c2ljcyBzeXN0ZW0gKi9cclxuICAgIHByaXZhdGUgcmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBQaHlzaWNzLnJlbW92ZVJpZ2lkYm9keSh0aGlzKTtcclxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBwcml2YXRlIEVWRU5UIGZ1bmN0aW9uc1xyXG4gICAgLy9DYWxjdWxhdGluZyB0aGUgY2VudGVyIG9mIGEgY29sbGlzaW9uIGFzIGEgc2luZ3VsYXIgcG9pbnQgLSBpbiBjYXNlIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcG9pbnQgLSBieSBnZXR0aW5nIHRoZSBnZW9tZXRyaWNhbCBjZW50ZXIgb2YgYWxsIGNvbGxpZGluZyBwb2ludHNcclxuICAgIHByaXZhdGUgY29sbGlzaW9uQ2VudGVyUG9pbnQoX2NvbFBvaW50czogT0lNTy5NYW5pZm9sZFBvaW50W10sIF9udW1Qb2ludHM6IG51bWJlcik6IE9JTU8uVmVjMyB7XHJcbiAgICAgIGxldCBjZW50ZXI6IE9JTU8uVmVjMztcclxuICAgICAgbGV0IHRvdGFsUG9pbnRzOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdG90YWxYOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdG90YWxZOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdG90YWxaOiBudW1iZXIgPSAwO1xyXG4gICAgICBfY29sUG9pbnRzLmZvckVhY2goKHZhbHVlOiBPSU1PLk1hbmlmb2xkUG9pbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAodG90YWxQb2ludHMgPCBfbnVtUG9pbnRzKSB7XHJcbiAgICAgICAgICB0b3RhbFBvaW50cysrO1xyXG4gICAgICAgICAgdG90YWxYICs9IHZhbHVlLmdldFBvc2l0aW9uMigpLng7XHJcbiAgICAgICAgICB0b3RhbFkgKz0gdmFsdWUuZ2V0UG9zaXRpb24yKCkueTtcclxuICAgICAgICAgIHRvdGFsWiArPSB2YWx1ZS5nZXRQb3NpdGlvbjIoKS56O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNlbnRlciA9IG5ldyBPSU1PLlZlYzModG90YWxYIC8gX251bVBvaW50cywgdG90YWxZIC8gX251bVBvaW50cywgdG90YWxaIC8gX251bVBvaW50cyk7XHJcbiAgICAgIHJldHVybiBjZW50ZXI7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXIgRW50ZXJpbmdFdmVudCBDYWxsYmFjaywgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgT0lNTyBQaHlzaWNzIHdpdGhpbiB0aGVpciBjYWxjdWxhdGlvbnMuXHJcbiAgICAqIFNpbmNlIHRoZSBldmVudCBkb2VzIG5vdCBrbm93IHdoaWNoIGJvZHkgaXMgdGhlIHRyaWdnZXIgaW5pYXRvciwgdGhlIGV2ZW50IGNhbiBiZSBsaXN0ZW5lZCB0b1xyXG4gICAgKiBvbiBlaXRoZXIgdGhlIHRyaWdnZXIgb3IgdGhlIHRyaWdnZXJlZC4gKFRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIHRoZSBGdWRnZSBPSU1PIEZvcmshKVxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgdHJpZ2dlckVudGVyKGNvbnRhY3Q6IE9JTU8uQ29udGFjdCk6IHZvaWQge1xyXG4gICAgICBsZXQgb2JqSGl0OiBDb21wb25lbnRSaWdpZGJvZHk7IC8vY29sbGlzaW9uIGNvbnNpc3Rpbmcgb2YgMiBib2RpZXMsIHNvIEhpdDEvMlxyXG4gICAgICBsZXQgb2JqSGl0MjogQ29tcG9uZW50UmlnaWRib2R5O1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50UGh5c2ljczsgIC8vVGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBzZW5kIGFuZCB0aGUgaW5mb3JtYXRpb25zIGFkZGVkIHRvIGl0XHJcbiAgICAgIGxldCBjb2xQb2ludDogVmVjdG9yMztcclxuXHJcbiAgICAgIC8vQUREIE5FVyBUcmlnZ2VyaW5nIC0gVGhhdCBqdXN0IGhhcHBlbmVkXHJcbiAgICAgIGxldCBjb2xsaXNpb25NYW5pZm9sZDogT0lNTy5NYW5pZm9sZCA9IGNvbnRhY3QuZ2V0TWFuaWZvbGQoKTsgLy9NYW5pZm9sZCA9IEFkZGl0aW9uYWwgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBjb250YWN0XHJcbiAgICAgIG9iakhpdCA9IGNvbnRhY3QuZ2V0U2hhcGUxKCkudXNlckRhdGE7ICAvL1VzZXJkYXRhIGlzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIMaSLkNvbXBvbmVudFJpZ2lkYm9keSwgaXQncyBhbiBlbXB0eSBPaW1vUGh5c2ljcyBWYXJpYWJsZVxyXG4gICAgICAvL09ubHkgcmVnaXN0ZXIgdGhlIGNvbGxpc2lvbiBvbiB0aGUgYWN0dWFsIHRvdWNoLCBub3Qgb24gXCJzaGFkb3dDb2xsaWRlXCIsIHRvIHJlZ2lzdGVyIGluIHRoZSBtb21lbnQgb2YgaW1wdWxzZSBjYWxjdWxhdGlvblxyXG4gICAgICBpZiAob2JqSGl0ID09IG51bGwgfHwgY29udGFjdC5pc1RvdWNoaW5nKCkgPT0gZmFsc2UpIC8vIG9ubHkgYWN0IGlmIHRoZSBjb2xsaXNpb24gaXMgYWN0dWFsIHRvdWNoaW5nLCBzbyByaWdodCBhdCB0aGUgbW9tZW50IHdoZW4gYSBpbXB1bHNlIGlzIGhhcHBlbmluZywgbm90IHdoZW4gc2hhcGVzIG92ZXJsYXBcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIG9iakhpdDIgPSBjb250YWN0LmdldFNoYXBlMigpLnVzZXJEYXRhO1xyXG4gICAgICBpZiAob2JqSGl0MiA9PSBudWxsIHx8IGNvbnRhY3QuaXNUb3VjaGluZygpID09IGZhbHNlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgbGV0IHBvaW50czogT0lNTy5NYW5pZm9sZFBvaW50W10gPSBjb2xsaXNpb25NYW5pZm9sZC5nZXRQb2ludHMoKTsgLy9BbGwgcG9pbnRzIGluIHRoZSBjb2xsaXNpb24gd2hlcmUgdGhlIHR3byBib2RpZXMgYXJlIHRvdWNoaW5nLCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgZnVsbCBpbXBhY3RcclxuICAgICAgbGV0IG5vcm1hbDogT0lNTy5WZWMzID0gY29sbGlzaW9uTWFuaWZvbGQuZ2V0Tm9ybWFsKCk7XHJcbiAgICAgIGlmIChvYmpIaXQyLnRyaWdnZXJpbmdzLmluZGV4T2Yob2JqSGl0KSA9PSAtMSkgeyAvL0ZpcmUsIGlmIHRoZSBoaXQgb2JqZWN0IGlzIG5vdCB0aGUgQm9keSBpdHNlbGYgYnV0IGFub3RoZXIgYW5kIGl0J3Mgbm90IGFscmVhZHkgZmlyZWQuXHJcbiAgICAgICAgbGV0IGNvbFBvczogT0lNTy5WZWMzID0gb2JqSGl0Mi5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIGNvbGxpc2lvbk1hbmlmb2xkLmdldE51bVBvaW50cygpKTsgLy9USEUgcG9pbnQgb2YgY29sbGlzaW9uIGlzIHRoZSBmaXJzdCB0b3VjaGluZyBwb2ludCAoRVhURU5TSU9OOiBjb3VsZCBiZSB0aGUgY2VudGVyIG9mIGFsbCB0b3VjaGluZyBwb2ludHMgY29tYmluZWQpXHJcbiAgICAgICAgY29sUG9pbnQgPSBuZXcgVmVjdG9yMyhjb2xQb3MueCwgY29sUG9zLnksIGNvbFBvcy56KTtcclxuICAgICAgICAvLyBJbXB1bHNlcyBhcmUgMCBzaW5jZSwgdGhlcmUgYXJlIG5vIGZvcmNlcy9pbXB1bHNlcyBhdCB3b3JrLCBlbHNlIHRoaXMgd291bGQgbm90IGJlIGEgdHJpZ2dlciwgYnV0IGEgY29sbGlzaW9uXHJcbiAgICAgICAgb2JqSGl0Mi50cmlnZ2VyaW5ncy5wdXNoKG9iakhpdCk7IC8vVGVsbCB0aGUgb2JqZWN0IHRoYXQgdGhlIGV2ZW50IGZvciB0aGlzIG9iamVjdCBkb2VzIG5vdCBuZWVkIHRvIGJlIGZpcmVkIGFnYWluXHJcbiAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuVFJJR0dFUl9FTlRFUiwgb2JqSGl0LCAwLCAwLCAwLCBjb2xQb2ludCwgbmV3IFZlY3RvcjMobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueikpOyAvL0J1aWxkaW5nIHRoZSBhY3R1YWwgZXZlbnQsIHdpdGggd2hhdCBvYmplY3QgZGlkIGNvbGxpZGUgYW5kIGluZm9ybWF0aW9ucyBhYm91dCBpdFxyXG4gICAgICAgIG9iakhpdDIuZGlzcGF0Y2hFdmVudChldmVudCk7IC8vU2VuZGluZyB0aGUgZ2l2ZW4gZXZlbnRcclxuICAgICAgfVxyXG4gICAgICBpZiAob2JqSGl0LnRyaWdnZXJpbmdzLmluZGV4T2Yob2JqSGl0MikgPT0gLTEpIHsgLy9TYW1lIGFzIHRoZSBhYm92ZSBidXQgZm9yIHRoZSBjYXNlIHRoZSBTRUNPTkQgaGl0IG9iamVjdCBpcyBub3QgdGhlIGJvZHkgaXRzZWxmXHJcbiAgICAgICAgbGV0IGNvbFBvczogT0lNTy5WZWMzID0gb2JqSGl0LmNvbGxpc2lvbkNlbnRlclBvaW50KHBvaW50cywgY29sbGlzaW9uTWFuaWZvbGQuZ2V0TnVtUG9pbnRzKCkpO1xyXG4gICAgICAgIGNvbFBvaW50ID0gbmV3IFZlY3RvcjMoY29sUG9zLngsIGNvbFBvcy55LCBjb2xQb3Mueik7XHJcbiAgICAgICAgLy8gSW1wdWxzZXMgYXJlIDAgc2luY2UsIHRoZXJlIGFyZSBubyBmb3JjZXMvaW1wdWxzZXMgYXQgd29yaywgZWxzZSB0aGlzIHdvdWxkIG5vdCBiZSBhIHRyaWdnZXIsIGJ1dCBhIGNvbGxpc2lvbixcclxuICAgICAgICAvLyBhbHNvIHRoZSBldmVudCBpcyBoYW5kbGVkIGJlZm9yZSB0aGUgYWN0dWFsIHNvbHZpbmcgaW1wdWxzZSBzdGVwIGluIE9JTU9cclxuICAgICAgICBvYmpIaXQudHJpZ2dlcmluZ3MucHVzaChvYmpIaXQyKTtcclxuICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5UUklHR0VSX0VOVEVSLCBvYmpIaXQyLCAwLCAwLCAwLCBjb2xQb2ludCwgbmV3IFZlY3RvcjMobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueikpO1xyXG4gICAgICAgIG9iakhpdC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUcmlnZ2VyIExlYXZpbmdFdmVudCBDYWxsYmFjaywgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgT0lNTyBQaHlzaWNzIHdpdGhpbiB0aGVpciBjYWxjdWxhdGlvbnMuXHJcbiAgICAqIFNpbmNlIHRoZSBldmVudCBkb2VzIG5vdCBrbm93IHdoaWNoIGJvZHkgaXMgdGhlIHRyaWdnZXIgaW5pYXRvciwgdGhlIGV2ZW50IGNhbiBiZSBsaXN0ZW5lZCB0b1xyXG4gICAgKiBvbiBlaXRoZXIgdGhlIHRyaWdnZXIgb3IgdGhlIHRyaWdnZXJlZC4gKFRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIHRoZSBGdWRnZSBPSU1PIEZvcmshKVxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgdHJpZ2dlckV4aXQoY29udGFjdDogT0lNTy5Db250YWN0KTogdm9pZCB7XHJcbiAgICAgIC8vUkVNT1ZFIE9MRCBUcmlnZ2VyaW5nIEJvZHlcclxuICAgICAgbGV0IG9iakhpdDogQ29tcG9uZW50UmlnaWRib2R5OyAvL2NvbGxpc2lvbiBjb25zaXN0aW5nIG9mIDIgYm9kaWVzLCBzbyBIaXQxLzJcclxuICAgICAgbGV0IG9iakhpdDI6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuICAgICAgbGV0IGV2ZW50OiBFdmVudFBoeXNpY3M7ICAvL1RoZSBldmVudCB0aGF0IHdpbGwgYmUgc2VuZCBhbmQgdGhlIGluZm9ybWF0aW9ucyBhZGRlZCB0byBpdFxyXG4gICAgICBvYmpIaXQgPSBjb250YWN0LmdldFNoYXBlMSgpLnVzZXJEYXRhO1xyXG4gICAgICBvYmpIaXQyID0gY29udGFjdC5nZXRTaGFwZTIoKS51c2VyRGF0YTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBib3RoIGJvZGllcyBpbiBib3RoIGNhc2VzLCBvZiBzZWxmIGFuZCBvdGhlclxyXG4gICAgICBsZXQgaW5kZXg6IG51bWJlciA9IG9iakhpdC50cmlnZ2VyaW5ncy5pbmRleE9mKG9iakhpdDIpOyAvL0ZpbmQgb2JqZWN0IGluIHRoZSBhcnJheVxyXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICBvYmpIaXQudHJpZ2dlcmluZ3Muc3BsaWNlKGluZGV4KTsgLy9yZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXlcclxuICAgICAgICBldmVudCA9IG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5UUklHR0VSX0VYSVQsIG9iakhpdDIsIDAsIDAsIDApO1xyXG4gICAgICAgIG9iakhpdC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgICBpbmRleCA9IG9iakhpdDIudHJpZ2dlcmluZ3MuaW5kZXhPZihvYmpIaXQpOyAvL0ZpbmQgb2JqZWN0IGluIHRoZSBhcnJheVxyXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICBvYmpIaXQyLnRyaWdnZXJpbmdzLnNwbGljZShpbmRleCk7IC8vcmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5XHJcbiAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuVFJJR0dFUl9FWElULCBvYmpIaXQsIDAsIDAsIDApO1xyXG4gICAgICAgIG9iakhpdDIuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIGhvbGRpbmcgZGF0YSBhYm91dCBwaHlzaWNzIGRlYnVnIHZlcnRpY2VzLiovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlciB7XHJcbiAgICBwdWJsaWMgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwdWJsaWMgbnVtVmVydGljZXM6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgYXR0cmliczogQXJyYXk8UGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlPjtcclxuICAgIHB1YmxpYyBpbmRpY2VzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIG9mZnNldHM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgc3RyaWRlOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYnVmZmVyOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBkYXRhTGVuZ3RoOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFNldHVwIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhpcyBidWZmZXIgYW5kIGNyZWF0ZSB0aGUgYWN0dWFsIGJ1ZmZlciBmb3IgdGhpcyBjb250ZXh0LiAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlbmRlcmluZ0NvbnRleHQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5nbCA9IF9yZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZpbGwgdGhlIGJvdW5kIGJ1ZmZlciB3aXRoIGRhdGEuIFVzZWQgYXQgYnVmZmVyIGluaXRpYWxpemF0aW9uICovXHJcbiAgICBwdWJsaWMgc2V0RGF0YShhcnJheTogQXJyYXk8bnVtYmVyPik6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5hdHRyaWJzID09IG51bGwpIHRocm93IFwic2V0IGF0dHJpYnV0ZXMgZmlyc3RcIjtcclxuICAgICAgdGhpcy5udW1WZXJ0aWNlcyA9IGFycmF5Lmxlbmd0aCAvICh0aGlzLnN0cmlkZSAvIDQpO1xyXG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KGFycmF5KSwgdGhpcy5nbC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgICAvL25vdCBuZWNlc3NhcnkgYW4gaW4gd2ViZ2wyIGFueW1vcmUgdG8gcmViaW5kIHRoZSBzYW1lIGxhc3QgYnVmZmVyICh3aGljaCBpcyBhY2hpZXZlZCBieSBnaXZpbmcgYSBudWxsIGJ1ZmZlciksIGFmdGVyIGJ1ZmZlciBpcyBjaGFuZ2VkLiBSZW1vdmVkIGl0IG9uIGFsbCBvdGhlciBvY2Nhc2lvbnNcclxuICAgICAgLy8gdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTsgXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNldCBTaGFkZXIgQXR0cmlidXRlcyBpbmZvcm1hdGlvbnMgYnkgZ2V0dGluZyB0aGVpciBwb3NpdGlvbiBpbiB0aGUgc2hhZGVyLCBzZXR0aW5nIHRoZSBvZmZzZXQsIHN0cmlkZSBhbmQgc2l6ZS4gRm9yIGxhdGVyIHVzZSBpbiB0aGUgYmluZGluZyBwcm9jZXNzICovXHJcbiAgICBwdWJsaWMgc2V0QXR0cmlicyhhdHRyaWJzOiBBcnJheTxQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGU+KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYXR0cmlicyA9IGF0dHJpYnM7XHJcbiAgICAgIHRoaXMub2Zmc2V0cyA9IFtdO1xyXG4gICAgICB0aGlzLnN0cmlkZSA9IDA7XHJcbiAgICAgIGxldCBuOiBudW1iZXIgPSBhdHRyaWJzLmxlbmd0aDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKHRoaXMuc3RyaWRlKTtcclxuICAgICAgICB0aGlzLnN0cmlkZSArPSBhdHRyaWJzW2ldLmZsb2F0MzJDb3VudCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsgLy8gMzJiaXQgZmxvYXQgQnl0ZXMgYXJlIGEgY29uc3RhbnQgb2YgNFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGF0dHJpYnV0ZSBpbiB0aGUgc2hhZGVyICovXHJcbiAgICBwdWJsaWMgbG9hZEF0dHJpYkluZGljZXMoX3Byb2dyYW06IFBoeXNpY3NEZWJ1Z1NoYWRlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmluZGljZXMgPSBfcHJvZ3JhbS5nZXRBdHRyaWJJbmRpY2VzKHRoaXMuYXR0cmlicyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEVuYWJsZSBhIGF0dHJpYnV0ZSBpbiBhIHNoYWRlciBmb3IgdGhpcyBjb250ZXh0LCAqL1xyXG4gICAgcHVibGljIGJpbmRBdHRyaWJzKCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5pbmRpY2VzID09IG51bGwpIHRocm93IFwiaW5kaWNlcyBhcmUgbm90IGxvYWRlZFwiO1xyXG4gICAgICBsZXQgbjogbnVtYmVyID0gdGhpcy5hdHRyaWJzLmxlbmd0aDtcclxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7IC8vbWFraW5nIHRoZSBidWZmZXIgb2YgdGhpcyBjbGFzcyB0aGUgY3VycmVudCBidWZmZXJcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5pbmRpY2VzW2ldKTsgLy9lbmFibGUgdGhlIEF0dHJpYnV0ZVxyXG4gICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmluZGljZXNbaV0sIHRoaXMuYXR0cmlic1tpXS5mbG9hdDMyQ291bnQsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCB0aGlzLnN0cmlkZSwgdGhpcy5vZmZzZXRzW2ldKTsgLy9jcmVhdGVzIGEgcG9pbnRlciBhbmQgc3RydWN0dXJlIGZvciB0aGlzIGF0dHJpYnV0ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIGhvbGRpbmcgZGF0YSBhYm91dCBQaHlzaWNzRGVidWdWZXJ0ZXhCdWZmZXJzICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyIHtcclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgIHB1YmxpYyBidWZmZXI6IFdlYkdMQnVmZmVyO1xyXG4gICAgcHVibGljIGNvdW50OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFNldHVwIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhpcyBidWZmZXIgYW5kIGNyZWF0ZSB0aGUgYWN0dWFsIGJ1ZmZlciBmb3IgdGhpcyBjb250ZXh0LiAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlbmRlcmluZ0NvbnRleHQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5nbCA9IF9yZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZpbGwgdGhlIGJvdW5kIGJ1ZmZlciB3aXRoIGRhdGEgYW1vdW50LiBVc2VkIGF0IGJ1ZmZlciBpbml0aWFsaXphdGlvbiAqL1xyXG4gICAgcHVibGljIHNldERhdGEoYXJyYXk6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KGFycmF5KSwgdGhpcy5nbC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgICB0aGlzLmNvdW50ID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgYWN0dWFsIERyYXdDYWxsIGZvciBwaHlzaWNzRGVidWdEcmF3IEJ1ZmZlcnMuIFRoaXMgaXMgd2hlcmUgdGhlIGluZm9ybWF0aW9uIGZyb20gdGhlIGRlYnVnIGlzIGFjdHVhbGx5IGRyYXduLiAqL1xyXG4gICAgcHVibGljIGRyYXcoX21vZGU6IG51bWJlciA9IHRoaXMuZ2wuVFJJQU5HTEVTLCBfY291bnQ6IG51bWJlciA9IC0xKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcbiAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzKF9tb2RlLCBfY291bnQgPj0gMCA/IF9jb3VudCA6IHRoaXMuY291bnQsIHRoaXMuZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEludGVybmFsIGNsYXNzIGZvciBtYW5hZ2luZyBkYXRhIGFib3V0IHdlYkdMIEF0dHJpYnV0ZXMgKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlIHtcclxuICAgIHB1YmxpYyBmbG9hdDMyQ291bnQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2Zsb2F0MzJDb3VudDogbnVtYmVyLCBfbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmZsb2F0MzJDb3VudCA9IF9mbG9hdDMyQ291bnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIFNoYWRlcnMgdXNlZCBvbmx5IGJ5IHRoZSBwaHlzaWNzIGRlYnVnRHJhdyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdTaGFkZXIge1xyXG4gICAgcHVibGljIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgcHVibGljIHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcclxuICAgIHB1YmxpYyB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG4gICAgcHVibGljIGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlcjtcclxuICAgIHB1YmxpYyB1bmlmb3JtTG9jYXRpb25NYXA6IE1hcDxzdHJpbmcsIFdlYkdMVW5pZm9ybUxvY2F0aW9uPjtcclxuXHJcbiAgICAvKiogSW50cm9kdWNlIHRoZSBGdWRnZSBSZW5kZXJpbmcgQ29udGV4dCB0byB0aGlzIGNsYXNzLCBjcmVhdGluZyBhIHByb2dyYW0gYW5kIHZlcnRleC9mcmFnbWVudCBzaGFkZXIgaW4gdGhpcyBjb250ZXh0ICovXHJcbiAgICBjb25zdHJ1Y3RvcihfcmVuZGVyaW5nQ29udGV4dDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xyXG4gICAgICB0aGlzLmdsID0gX3JlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgIHRoaXMucHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICB0aGlzLnZlcnRleFNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRha2UgZ2xzbCBzaGFkZXJzIGFzIHN0cmluZ3MgYW5kIGNvbXBpbGUgdGhlbSwgYXR0YWNoaW5nIHRoZSBjb21waWxlZCBzaGFkZXJzIHRvIGEgcHJvZ3JhbSB0aGF0cyB1c2VkIGJ5IHRoaXMgcmVuZGVyaW5nIGNvbnRleHQuICovXHJcbiAgICBwdWJsaWMgY29tcGlsZSh2ZXJ0ZXhTb3VyY2U6IHN0cmluZywgZnJhZ21lbnRTb3VyY2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBXZWJHTFVuaWZvcm1Mb2NhdGlvbj4oKTtcclxuICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyLCB2ZXJ0ZXhTb3VyY2UpO1xyXG4gICAgICB0aGlzLmNvbXBpbGVTaGFkZXIodGhpcy5mcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTb3VyY2UpO1xyXG4gICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHRoaXMudmVydGV4U2hhZGVyKTtcclxuICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCB0aGlzLmZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgdGhpcy5nbC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICBpZiAoIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKSB7ICAvL21ha2Ugc3VyZSB0aGUgbGlua2luZyB3b3JrZWQsIHNvIHRoZSBwcm9ncmFtIGlzIHZhbGlkLCBhbmQgc2hhZGVycyBhcmUgd29ya2luZ1xyXG4gICAgICAgIERlYnVnLmxvZyh0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMucHJvZ3JhbSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZ2wudmFsaWRhdGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5WQUxJREFURV9TVEFUVVMpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SIHZhbGlkYXRpbmcgcHJvZ3JhbSFcIiwgdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLnByb2dyYW0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IGluZGV4IG9mIGEgYXR0cmlidXRlIGluIGEgc2hhZGVyIGluIHRoaXMgcHJvZ3JhbSAqL1xyXG4gICAgcHVibGljIGdldEF0dHJpYkluZGV4KF9uYW1lOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIF9uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBsb2NhdGlvbiBvZiBhIHVuaWZvcm0gaW4gYSBzaGFkZXIgaW4gdGhpcyBwcm9ncmFtICovXHJcbiAgICBwdWJsaWMgZ2V0VW5pZm9ybUxvY2F0aW9uKF9uYW1lOiBzdHJpbmcpOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB7XHJcbiAgICAgIGlmICh0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcC5oYXMoX25hbWUpKSByZXR1cm4gdGhpcy51bmlmb3JtTG9jYXRpb25NYXAuZ2V0KF9uYW1lKTtcclxuICAgICAgbGV0IGxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgX25hbWUpO1xyXG4gICAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcC5zZXQoX25hbWUsIGxvY2F0aW9uKTtcclxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgYWxsIGluZGljZXMgZm9yIGV2ZXJ5IGF0dHJpYnV0ZSBpbiB0aGUgc2hhZGVycyBvZiB0aGlzIHByb2dyYW0gKi9cclxuICAgIHB1YmxpYyBnZXRBdHRyaWJJbmRpY2VzKF9hdHRyaWJzOiBBcnJheTxQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGU+KTogQXJyYXk8bnVtYmVyPiB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAgIF9hdHRyaWJzLmZvckVhY2godmFsdWUgPT4ge1xyXG4gICAgICAgIGluZGljZXMucHVzaCh0aGlzLmdldEF0dHJpYkluZGV4KHZhbHVlLm5hbWUpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBpbmRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUZWxsIHRoZSBGdWRnZSBSZW5kZXJpbmcgQ29udGV4dCB0byB1c2UgdGhpcyBwcm9ncmFtIHRvIGRyYXcuICovXHJcbiAgICBwdWJsaWMgdXNlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29tcGlsZSBhIHNoYWRlciBvdXQgb2YgYSBzdHJpbmcgYW5kIHZhbGlkYXRlIGl0LiAqL1xyXG4gICAgcHVibGljIGNvbXBpbGVTaGFkZXIoc2hhZGVyOiBXZWJHTFNoYWRlciwgc291cmNlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xyXG4gICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgICAgRGVidWcubG9nKHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEludGVybmFsIENsYXNzIHVzZWQgdG8gZHJhdyBkZWJ1Z0luZm9ybWF0aW9ucyBhYm91dCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uIG9udG8gdGhlIHJlbmRlckNvbnRleHQuIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSAyMDIwIC8vQmFzZWQgb24gT2ltb1BoeXNpY3MgSGF4ZSBEZWJ1Z0RyYXdEZW1vIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdEcmF3IGV4dGVuZHMgUmVuZGVyV2ViR0wge1xyXG4gICAgcHVibGljIG9pbW9EZWJ1Z0RyYXc6IE9JTU8uRGVidWdEcmF3OyAvL3RoZSBvcmlnaW5hbCBwaHlzaWNzIGVuZ2luZSBkZWJ1Z0RyYXcgY2xhc3MgcmVjZWl2aW5nIGNhbGxzIGZyb20gdGhlIG9pbW9QaHlzaWNzLldvcmxkLCBhbmQgcHJvdmlkaW5nIGluZm9ybWF0aW9ucyBpbiBmb3JtIG9mIHBvaW50cy9saW5lcy90cmlhbmdsZXMgd2hhdCB0aGUgcGh5c2ljcyB3b3JsZCBsb29rcyBsaWtlXHJcbiAgICBwdWJsaWMgc3R5bGU6IE9JTU8uRGVidWdEcmF3U3R5bGU7IC8vY29sb3JzIG9mIHRoZSBkZWJ1ZyBpbmZvcm1hdGlvbnMsIHVuY2hhbmdlZCBpbiBGdWRnZSBpbnRlZ3JhdGlvbiwgYmFzaWNhbGx5IGNvbG9yaW5nIHRoaW5ncyBsaWtlIHNsZWVwaW5nL2FjdGl2ZSByYidzIGRpZmZlcmVudGx5LCBqb2ludHMgd2hpdGUgYW5kIHN1Y2guIE5vIG5lZWQgdG8gaGF2ZSB1c2VycyBjaGFuZ2UgYW55dGhpbmcuXHJcbiAgICBwdWJsaWMgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcblxyXG4gICAgcHVibGljIHByb2dyYW06IFdlYkdMUHJvZ3JhbTsgLy9wcm9ncmFtIHRoYXQgaXMgdXNlZCBpbiB0aGUgRnVkZ2UgcmVuZGVyaW5nIGNvbnRleHQgY29udGFpbmluZyBzaGFkZXJzIGFuZCB1c2UgaW5mb3JtYXRpb25zIGZvciB0aGUgY29udGV4dCB0byBrbm93IGhvdyB0byBkcmF3XHJcbiAgICBwdWJsaWMgc2hhZGVyOiBQaHlzaWNzRGVidWdTaGFkZXI7XHJcblxyXG4gICAgLy9CdWZmZXJzIGZvciBwb2ludHMvbGluZXMvdHJpYW5nbGVzLiBJbmRleCBCdWZmZXIgZm9yIHRoZSBhbW91bnQgb2YgZHJhd0NhbGxzIGFuZCBWZXJ0ZXggQnVmZmVyIGZvciB0aGUgaW5mb3JtYXRpb25zXHJcbiAgICBwdWJsaWMgcG9pbnRWQk86IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBwb2ludElCTzogUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXI7XHJcblxyXG4gICAgcHVibGljIGxpbmVWQk86IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBsaW5lSUJPOiBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgdHJpVkJPOiBQaHlzaWNzRGVidWdWZXJ0ZXhCdWZmZXI7XHJcbiAgICBwdWJsaWMgdHJpSUJPOiBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgcG9pbnREYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIHBvaW50SWJvRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBudW1Qb2ludERhdGE6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgbGluZURhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgbGluZUlib0RhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgbnVtTGluZURhdGE6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgdHJpRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyB0cmlJYm9EYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIG51bVRyaURhdGE6IG51bWJlcjtcclxuXHJcbiAgICAvKiogQ3JlYXRpbmcgdGhlIGRlYnVnIGZvciBwaHlzaWNzIGluIEZ1ZGdlLiBUZWxsIGl0IHRvIGRyYXcgb25seSB3aXJlZnJhbWUgb2JqZWN0cywgc2luY2UgRnVkZ2UgaXMgaGFuZGxpbmcgcmVuZGVyaW5nIG9mIHRoZSBvYmplY3RzIGJlc2lkZXMgcGh5c2ljcy4gXHJcbiAgICAgKiBPdmVycmlkZSBPaW1vUGh5c2ljcyBGdW5jdGlvbnMgd2l0aCBvd24gcmVuZGVyaW5nLiBJbml0aWFsaXplIGJ1ZmZlcnMgYW5kIGNvbm5lY3QgdGhlbSB3aXRoIHRoZSBjb250ZXh0IGZvciBsYXRlciB1c2UuICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIHRoaXMuc3R5bGUgPSBuZXcgT0lNTy5EZWJ1Z0RyYXdTdHlsZSgpO1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcgPSBuZXcgT0lNTy5EZWJ1Z0RyYXcoKTtcclxuICAgICAgdGhpcy5vaW1vRGVidWdEcmF3LndpcmVmcmFtZSA9IHRydWU7IC8vVHJpYW5nbGUgUmVuZGVyaW5nIGlzIGhhbmRsZWQgYnkgRlVER0Ugc28sIG9ubHkgdGhlIHBoeXNpY3MgbGluZXMvcG9pbnRzIG5lZWQgdG8gYmUgcmVuZGVyZWQsIGFsdGhvdWdoIHRyaWFuZ2xlIGlzIHN0aWxsIGltcGxlbWVudGVkXHJcblxyXG4gICAgICB0aGlzLmdsID0gUmVuZGVyV2ViR0wuY3JjMztcclxuICAgICAgdGhpcy5pbml0aWFsaXplT3ZlcnJpZGUoKTtcclxuICAgICAgdGhpcy5zaGFkZXIgPSBuZXcgUGh5c2ljc0RlYnVnU2hhZGVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnNoYWRlci5jb21waWxlKHRoaXMudmVydGV4U2hhZGVyU291cmNlKCksIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UoKSk7XHJcblxyXG4gICAgICB0aGlzLmluaXRpYWxpemVCdWZmZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlY2VpdmUgdGhlIGN1cnJlbnQgRGVidWdNb2RlIGZyb20gdGhlIHBoeXNpY3Mgc2V0dGluZ3MgYW5kIHNldCB0aGUgT2ltb1BoeXNpY3MuRGVidWdEcmF3IGJvb2xlYW5zIHRvIHNob3cgb25seSBjZXJ0YWluIGluZm9ybWF0aW9ucy5cclxuICAgICAqIE5lZWRlZCBzaW5jZSBzb21lIGRlYnVnIGluZm9ybWF0aW9ucyBleGNsdWRlIG90aGVycywgYW5kIGNhbid0IGJlIGRyYXduIGF0IHRoZSBzYW1lIHRpbWUsIGJ5IE9pbW9QaHlzaWNzLiBBbmQgZm9yIHVzZXJzIGl0IHByb3ZpZGVzIG1vcmUgcmVhZGFiaWxpdHlcclxuICAgICAqIHRvIGRlYnVnIG9ubHkgd2hhdCB0aGV5IG5lZWQgYW5kIGlzIGNvbW1vbmx5IGRlYnVnZ2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RGVidWdNb2RlKF9tb2RlOiBQSFlTSUNTX0RFQlVHTU9ERSA9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkUpOiB2b2lkIHtcclxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgIGxldCBkcmF3ID0geyBkcmF3QWFiYnM6IGZhbHNlLCBkcmF3QmFzZXM6IGZhbHNlLCBkcmF3QnZoOiBmYWxzZSwgZHJhd0NvbnRhY3RCYXNlczogZmFsc2UsIGRyYXdDb250YWN0czogZmFsc2UsIGRyYXdKb2ludExpbWl0czogZmFsc2UsIGRyYXdKb2ludHM6IGZhbHNlLCBkcmF3UGFpcnM6IGZhbHNlLCBkcmF3U2hhcGVzOiBmYWxzZSB9O1xyXG5cclxuICAgICAgc3dpdGNoIChfbW9kZSkge1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuQ09MTElERVJTOiAvL0NvbGxpZGVycyBhbmQgQmFzZXNcclxuICAgICAgICAgIGRyYXcuZHJhd0Jhc2VzID0gZHJhdy5kcmF3U2hhcGVzID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuSk9JTlRTX0FORF9DT0xMSURFUjogLy9Db2xsaWRlcnMgYW5kIGpvaW50c1xyXG4gICAgICAgICAgZHJhdy5kcmF3Sm9pbnRzID0gZHJhdy5kcmF3Sm9pbnRMaW1pdHMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5QSFlTSUNfT0JKRUNUU19PTkxZOiAvL1BoeXNpY3MgT2JqZWN0cyBvbmx5LCBzaG93cyBzYW1lIGFzIENvbGxpZGVyIC8gSm9pbnRzIGJ1dCBhbHNvIGhpZGluZyBldmVyeSBvdGhlciBmdWRnZSBvYmplY3RcclxuICAgICAgICAgIGRyYXcuZHJhd0Jhc2VzID0gZHJhdy5kcmF3Sm9pbnRMaW1pdHMgPSBkcmF3LmRyYXdKb2ludHMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5DT05UQUNUUzogLy9Db250YWN0c1xyXG4gICAgICAgICAgZHJhdy5kcmF3QmFzZXMgPSBkcmF3LmRyYXdDb250YWN0QmFzZXMgPSBkcmF3LmRyYXdDb250YWN0cyA9IGRyYXcuZHJhd1BhaXJzID0gZHJhdy5kcmF3U2hhcGVzID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuQk9VTkRJTkdfQk9YRVM6IC8vQm91bmRpbmcgQm94IC8gQnJvYWRwaGFzZSBCdmggLyBCYXNlc1xyXG4gICAgICAgICAgZHJhdy5kcmF3QWFiYnMgPSBkcmF3LmRyYXdCYXNlcyA9IGRyYXcuZHJhd0J2aCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub2ltb0RlYnVnRHJhdywgZHJhdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIHRoZSBlbXB0eSByZW5kZXIgYnVmZmVycy4gRGVmaW5pbmcgdGhlIGF0dHJpYnV0ZXMgdXNlZCBpbiBzaGFkZXJzLlxyXG4gICAgICogTmVlZHMgdG8gY3JlYXRlIGVtcHR5IGJ1ZmZlcnMgdG8gYWxyZWFkeSBoYXZlIHRoZW0gcmVhZHkgdG8gZHJhdyBsYXRlciBvbiwgbGlua2luZyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggZXhpc3RpbmcgYnVmZmVycy4gKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplQnVmZmVycygpOiB2b2lkIHtcclxuICAgICAgbGV0IGF0dHJpYnM6IEFycmF5PFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZT4gPSBbXHJcbiAgICAgICAgbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZSgzLCBcImFQb3NpdGlvblwiKSxcclxuICAgICAgICBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlKDMsIFwiYU5vcm1hbFwiKSxcclxuICAgICAgICBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlKDMsIFwiYUNvbG9yXCIpXHJcbiAgICAgIF07XHJcblxyXG4gICAgICB0aGlzLnBvaW50VkJPID0gbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5wb2ludElCTyA9IG5ldyBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5wb2ludFZCTy5zZXRBdHRyaWJzKGF0dHJpYnMpO1xyXG4gICAgICB0aGlzLnBvaW50VkJPLmxvYWRBdHRyaWJJbmRpY2VzKHRoaXMuc2hhZGVyKTtcclxuICAgICAgdGhpcy5saW5lVkJPID0gbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5saW5lSUJPID0gbmV3IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLmxpbmVWQk8uc2V0QXR0cmlicyhhdHRyaWJzKTtcclxuICAgICAgdGhpcy5saW5lVkJPLmxvYWRBdHRyaWJJbmRpY2VzKHRoaXMuc2hhZGVyKTtcclxuICAgICAgdGhpcy50cmlWQk8gPSBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnRyaUlCTyA9IG5ldyBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy50cmlWQk8uc2V0QXR0cmlicyhhdHRyaWJzKTtcclxuICAgICAgdGhpcy50cmlWQk8ubG9hZEF0dHJpYkluZGljZXModGhpcy5zaGFkZXIpO1xyXG5cclxuICAgICAgdGhpcy5jbGVhckJ1ZmZlcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQmVmb3JlIE9pbW9QaHlzaWNzLndvcmxkIGlzIGZpbGxpbmcgdGhlIGRlYnVnLiBNYWtlIHN1cmUgdGhlIGJ1ZmZlcnMgYXJlIHJlc2V0LiBBbHNvIHJlY2VpdmluZyB0aGUgZGVidWdNb2RlIGZyb20gc2V0dGluZ3MgYW5kIHVwZGF0aW5nIHRoZSBjdXJyZW50IHByb2plY3Rpb24gZm9yIHRoZSB2ZXJ0ZXhTaGFkZXIuICovXHJcbiAgICBwdWJsaWMgY2xlYXJCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmdsLmxpbmVXaWR0aCgyLjApOyAvL0RvZXMgbm90IGFmZmVjdCBhbnl0aGluZyBiZWNhdXNlIGxpbmVXaWR0aCBpcyBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgTWljcm9zb2Z0IEVkZ2UgYW5kIEZ1ZGdlIGlzIG9wdGltaXplZCBmb3IgQ2hyb21lXHJcblxyXG4gICAgICB0aGlzLnBvaW50RGF0YSA9IFtdOyAvL1Jlc2V0dGluZyB0aGUgZGF0YSB0byBiZSBmaWxsZWQgYWdhaW5cclxuICAgICAgdGhpcy5saW5lRGF0YSA9IFtdO1xyXG4gICAgICB0aGlzLnRyaURhdGEgPSBbXTtcclxuXHJcbiAgICAgIHRoaXMubnVtUG9pbnREYXRhID0gMDsgLy9SZXNldHRpbmcgdGhlIGFtb3VudCBvZiBkYXRhIGNhbGxzXHJcbiAgICAgIHRoaXMubnVtTGluZURhdGEgPSAwO1xyXG4gICAgICB0aGlzLm51bVRyaURhdGEgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBZnRlciBPaW1vUGh5c2ljcy53b3JsZCBmaWxsZWQgdGhlIGRlYnVnLiBSZW5kZXJpbmcgY2FsbHMuIFNldHRpbmcgdGhpcyBwcm9ncmFtIHRvIGJlIHVzZWQgYnkgdGhlIEZ1ZGdlIHJlbmRlcmluZyBjb250ZXh0LiBBbmQgZHJhdyBlYWNoIHVwZGF0ZWQgYnVmZmVyIGFuZCByZXNldHRpbmcgdGhlbS4gKi9cclxuICAgIHB1YmxpYyBkcmF3QnVmZmVycygpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaGFkZXIudXNlKCk7XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uOiBGbG9hdDMyQXJyYXkgPSBQaHlzaWNzLm1haW5DYW0ubXR4V29ybGRUb1ZpZXcuZ2V0KCk7XHJcbiAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnNoYWRlci5nZXRVbmlmb3JtTG9jYXRpb24oXCJ1X210eE1lc2hUb1ZpZXdcIiksIGZhbHNlLCBwcm9qZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICBpZiAodGhpcy5udW1Qb2ludERhdGEgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludElib0RhdGEgPSBbXTsgIC8vQnVmZmVyIHNpemUgbWF0Y2hpbmcgdG8gd2hhdHMgbmVlZGVkXHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubnVtUG9pbnREYXRhOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMucG9pbnRJYm9EYXRhLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9pbnRJQk8uc2V0RGF0YSh0aGlzLnBvaW50SWJvRGF0YSk7IC8vU2V0IEluZGV4IGJ1ZmZlciB0byBjb3JyZWN0IHNpemVcclxuICAgICAgICB0aGlzLnBvaW50VkJPLnNldERhdGEodGhpcy5wb2ludERhdGEpOyAvL1NldCBWZXJ0ZXggQnVmZmVyIHRvIGN1cnJlbnQgRGF0YVxyXG4gICAgICAgIHRoaXMucG9pbnRWQk8uYmluZEF0dHJpYnMoKTtcclxuICAgICAgICB0aGlzLnBvaW50SUJPLmRyYXcodGhpcy5nbC5QT0lOVFMsIHRoaXMubnVtUG9pbnREYXRhKTsgLy9UaGUgYWN0dWFsIGRyYXcgY2FsbCBmb3IgZWFjaCBpbmRleCBpbiBpYm9cclxuICAgICAgICB0aGlzLm51bVBvaW50RGF0YSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubnVtTGluZURhdGEgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5saW5lSWJvRGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm51bUxpbmVEYXRhOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMubGluZUlib0RhdGEucHVzaChpICogMik7XHJcbiAgICAgICAgICB0aGlzLmxpbmVJYm9EYXRhLnB1c2goaSAqIDIgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saW5lSUJPLnNldERhdGEodGhpcy5saW5lSWJvRGF0YSk7XHJcbiAgICAgICAgdGhpcy5saW5lVkJPLnNldERhdGEodGhpcy5saW5lRGF0YSk7XHJcbiAgICAgICAgdGhpcy5saW5lVkJPLmJpbmRBdHRyaWJzKCk7XHJcbiAgICAgICAgdGhpcy5saW5lSUJPLmRyYXcodGhpcy5nbC5MSU5FUywgdGhpcy5udW1MaW5lRGF0YSAqIDIpO1xyXG4gICAgICAgIHRoaXMubnVtTGluZURhdGEgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm51bVRyaURhdGEgPiAwKSB7XHJcbiAgICAgICAgdGhpcy50cmlJYm9EYXRhID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubnVtVHJpRGF0YTsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnRyaUlib0RhdGEucHVzaChpICogMyk7XHJcbiAgICAgICAgICB0aGlzLnRyaUlib0RhdGEucHVzaChpICogMyArIDEpO1xyXG4gICAgICAgICAgdGhpcy50cmlJYm9EYXRhLnB1c2goaSAqIDMgKyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlJQk8uc2V0RGF0YSh0aGlzLnRyaUlib0RhdGEpO1xyXG4gICAgICAgIHRoaXMudHJpVkJPLnNldERhdGEodGhpcy50cmlEYXRhKTtcclxuICAgICAgICB0aGlzLnRyaVZCTy5iaW5kQXR0cmlicygpO1xyXG4gICAgICAgIHRoaXMudHJpSUJPLmRyYXcodGhpcy5nbC5UUklBTkdMRVMsIHRoaXMubnVtVHJpRGF0YSAqIDMpO1xyXG4gICAgICAgIHRoaXMubnVtVHJpRGF0YSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogRHJhd2luZyB0aGUgcmF5IGludG8gdGhlIGRlYnVnRHJhdyBDYWxsLiBCeSB1c2luZyB0aGUgb3ZlcndyaXR0ZW4gbGluZSByZW5kZXJpbmcgZnVuY3Rpb25zIGFuZCBkcmF3aW5nIGEgcG9pbnQgKHBvaW50U2l6ZSBkZWZpbmVkIGluIHRoZSBzaGFkZXIpIGF0IHRoZSBlbmQgb2YgdGhlIHJheS4gKi9cclxuICAgIHB1YmxpYyBkZWJ1Z1JheShfb3JpZ2luOiBWZWN0b3IzLCBfZW5kOiBWZWN0b3IzLCBfY29sb3I6IENvbG9yKTogdm9pZCB7XHJcbiAgICAgIHRoaXMub2ltb0RlYnVnRHJhdy5saW5lKG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueiksIG5ldyBPSU1PLlZlYzMoX2VuZC54LCBfZW5kLnksIF9lbmQueiksIG5ldyBPSU1PLlZlYzMoX2NvbG9yLnIsIF9jb2xvci5nLCBfY29sb3IuYikpO1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcucG9pbnQobmV3IE9JTU8uVmVjMyhfZW5kLngsIF9lbmQueSwgX2VuZC56KSwgbmV3IE9JTU8uVmVjMyhfY29sb3IuciwgX2NvbG9yLmcsIF9jb2xvci5iKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIE92ZXJyaWRpbmcgdGhlIGV4aXN0aW5nIGZ1bmN0aW9ucyBmcm9tIE9pbW9QaHlzaWNzLkRlYnVnRHJhdyB3aXRob3V0IGFjdHVhbGx5IGluaGVyaXQgZnJvbSB0aGUgY2xhc3MsIHRvIGF2b2lkIGNvbXBpbGVyIHByb2JsZW1zLiBcclxuICAgICAqIE92ZXJyaWRpbmcgdGhlbSB0byByZWNlaXZlIGRlYnVnSW5mb3JtYXRpb25zIGluIHRoZSBmb3JtYXQgdGhlIHBoeXNpYyBlbmdpbmUgcHJvdmlkZXMgdGhlbSBidXQgaGFuZGxpbmcgdGhlIHJlbmRlcmluZyBpbiB0aGUgZnVkZ2UgY29udGV4dC4gKi9cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZU92ZXJyaWRlKCk6IHZvaWQge1xyXG4gICAgICAvL092ZXJyaWRlIHBvaW50L2xpbmUvdHJpYW5nbGUgZnVuY3Rpb25zIG9mIE9pbW9QaHlzaWNzIHdoaWNoIGFyZSB1c2VkIHRvIGRyYXcgd2lyZWZyYW1lcyBvZiBvYmplY3RzLCBsaW5lcyBvZiByYXljYXN0cyBvciB0cmlhbmdsZXMgd2hlbiB0aGUgb2JqZWN0cyBhcmUgcmVuZGVyZWQgYnkgdGhlIHBoeXNpY3Mgbm90IEZVREdFICh1bnVzZWQpXHJcblxyXG4gICAgICBPSU1PLkRlYnVnRHJhdy5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiAoX3Y6IE9JTU8uVmVjMywgX2NvbG9yOiBPSU1PLlZlYzMpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZGVidWdXcmFwcGVyOiBQaHlzaWNzRGVidWdEcmF3ID0gUGh5c2ljcy5kZWJ1Z0RyYXc7IC8vR2V0IHRoZSBjdXN0b20gcGh5c2ljcyBkZWJ1ZyBjbGFzcyB0byBoYXZlIGFjY2VzcyB0byB0aGUgZGF0YS5cclxuICAgICAgICBpZiAoUGh5c2ljcy5tYWluQ2FtICE9IG51bGwpIHsgLy9vbmx5IGFjdCB3aGVuIHRoZXJlIGlzIGEgY2FtZXJhIHRoYXQgaXMgcmVuZGVyaW5nXHJcbiAgICAgICAgICBsZXQgZGF0YTogQXJyYXk8TnVtYmVyPiA9IGRlYnVnV3JhcHBlci5wb2ludERhdGE7IC8vZ2V0IHRoZSBhbHJlYWR5IHdyaXR0ZW4gYnVmZmVyIGluZm9ybWF0aW9uc1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92LngsIF92LnksIF92LnopOyAvL0Nvb3JkaW5hdGVzIG9mIHRoZSBwb2ludFxyXG4gICAgICAgICAgZGF0YS5wdXNoKDAsIDAsIDApOyAvL1BvaW50IE5vcm1hbHMgLSBFbXB0eSBzaW5jZSBpdCdzIG5vdCBhIHBvbHlnb25cclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTsgLy9Db2xvciBvZiB0aGUgcG9pbnRcclxuICAgICAgICAgIGRlYnVnV3JhcHBlci5udW1Qb2ludERhdGErKztcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBPSU1PLkRlYnVnRHJhdy5wcm90b3R5cGUubGluZSA9IGZ1bmN0aW9uIChfdjE6IE9JTU8uVmVjMywgX3YyOiBPSU1PLlZlYzMsIF9jb2xvcjogT0lNTy5WZWMzKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGRlYnVnV3JhcHBlcjogUGh5c2ljc0RlYnVnRHJhdyA9IFBoeXNpY3MuZGVidWdEcmF3O1xyXG4gICAgICAgIGlmIChQaHlzaWNzLm1haW5DYW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgbGV0IGRhdGE6IEFycmF5PG51bWJlcj4gPSBkZWJ1Z1dyYXBwZXIubGluZURhdGE7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YxLngsIF92MS55LCBfdjEueik7IC8vUG9pbnQgMSBDb29yZGluYXRlc1xyXG4gICAgICAgICAgZGF0YS5wdXNoKDAsIDAsIDApOyAvL1AxIE5vcm1hbHMgLSBFbXB0eSBzaW5jZSBpdCdzIG5vdCBhIHBvbHlnb25cclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTsgLy9QMSBDb2xvclxyXG4gICAgICAgICAgZGF0YS5wdXNoKF92Mi54LCBfdjIueSwgX3YyLnopOyAvL1BvaW50IDIgQ29vcmRpbmF0ZXNcclxuICAgICAgICAgIGRhdGEucHVzaCgwLCAwLCAwKTtcclxuICAgICAgICAgIGRhdGEucHVzaChfY29sb3IueCwgX2NvbG9yLnksIF9jb2xvci56KTtcclxuICAgICAgICAgIGRlYnVnV3JhcHBlci5udW1MaW5lRGF0YSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIE9JTU8uRGVidWdEcmF3LnByb3RvdHlwZS50cmlhbmdsZSA9IGZ1bmN0aW9uIChfdjE6IE9JTU8uVmVjMywgX3YyOiBPSU1PLlZlYzMsIF92MzogT0lNTy5WZWMzLCBfbjE6IE9JTU8uVmVjMywgX24yOiBPSU1PLlZlYzMsIF9uMzogT0lNTy5WZWMzLCBfY29sb3I6IE9JTU8uVmVjMyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBkZWJ1Z1dyYXBwZXI6IFBoeXNpY3NEZWJ1Z0RyYXcgPSBQaHlzaWNzLmRlYnVnRHJhdztcclxuICAgICAgICBpZiAoUGh5c2ljcy5tYWluQ2FtICE9IG51bGwpIHtcclxuICAgICAgICAgIGxldCBkYXRhOiBBcnJheTxudW1iZXI+ID0gZGVidWdXcmFwcGVyLnRyaURhdGE7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YxLngsIF92MS55LCBfdjEueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX24xLngsIF9uMS55LCBfbjEueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YyLngsIF92Mi55LCBfdjIueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX24yLngsIF9uMi55LCBfbjIueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX3YzLngsIF92My55LCBfdjMueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX24zLngsIF9uMy55LCBfbjMueik7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkZWJ1Z1dyYXBwZXIubnVtVHJpRGF0YSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNvdXJjZSBjb2RlIChzdHJpbmcpIG9mIHRoZSBpbiBwaHlzaWNzRGVidWcgdXNlZCB2ZXJ5IHNpbXBsZSB2ZXJ0ZXhTaGFkZXIuXHJcbiAgICAgKiAgSGFuZGxpbmcgdGhlIHByb2plY3Rpb24gKHdoaWNoIGluY2x1ZGVzLCB2aWV3L3dvcmxkW2lzIGFsd2F5cyBpZGVudGl0eSBpbiB0aGlzIGNhc2VdL3Byb2plY3Rpb24gaW4gRnVkZ2UpLiBJbmNyZWFzaW5nIHRoZSBzaXplIG9mIHNpbmdsZSBwb2ludHMgZHJhd24uXHJcbiAgICAgKiAgQW5kIHRyYW5zZmVyIHBvc2l0aW9uIGNvbG9yIHRvIHRoZSBmcmFnbWVudFNoYWRlci4gKi9cclxuICAgIHByaXZhdGUgdmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgXHJcblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjMyBhUG9zaXRpb247XHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFDb2xvcjtcclxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcblx0XHRcdHVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0dlBvc2l0aW9uID0gYVBvc2l0aW9uO1xyXG5cdFx0XHRcdHZDb2xvciA9IGFDb2xvcjtcclxuXHRcdFx0XHR2Tm9ybWFsID0gYU5vcm1hbDtcclxuXHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHVfbXR4TWVzaFRvVmlldyAqIHZlYzQoYVBvc2l0aW9uLDEuMCk7XHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gNi4wO1xyXG5cdFx0XHR9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNvdXJjZSBjb2RlIChzdHJpbmcpIG9mIHRoZSBpbiBwaHlzaWNzRGVidWcgdXNlZCBzdXBlciBzaW1wbGUgZnJhZ21lbnRTaGFkZXIuIFVubGl0IC0gb25seSBjb2xvcml6aW5nIHRoZSBkcmF3biBwaXhlbHMsIG5vcm1hbHMvcG9zaXRpb24gYXJlIGdpdmVuIHRvIG1ha2UgaXQgZXhwYW5kYWJsZSAqL1xyXG4gICAgcHJpdmF0ZSBmcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYFxyXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcblxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XHJcblx0XHRcdH1gO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJcclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIGEgZGVmaW5lZCBheGUgb2YgdHJhbnNsYXRpb24gYW5kIHJvdGF0aW9uLiBUd28gRGVncmVlcyBvZiBGcmVlZG9tIGluIHRoZSBkZWZpbmVkIGF4aXMuXHJcbiAgICogVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuIEEgbW90b3IgY2FuIGJlIGRlZmluZWQgZm9yIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGlvbiwgYWxvbmcgd2l0aCBzcHJpbmcgc2V0dGluZ3MuXHJcbiAgICogXHJcbiAgICogYGBgcGxhaW50ZXh0XHJcbiAgICogICAgICAgICAgSm9pbnRIb2xkZXIgLSBib2R5QW5jaG9yXHJcbiAgICogICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgICAgICAgICAgICDilIIgICDilIJcclxuICAgKiAgICAgICAgICAgPOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgIOKUguKUgOKUgOKUgOKUgOKUgOKUgD4gdGllZCBib2R5LCBzbGlkaW5nIG9uIGF4aXMgPSAxc3QgZGVncmVlIG9mIGZyZWVkb21cclxuICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAg4pSCICAgICAgICByb3RhdGluZyBhcm91bmQgYXhpcyA9IDJuZCBkZWdyZWUgb2YgZnJlZWRvbSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXHJcbiAgICogYGBgICBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50Q3lsaW5kcmljYWwgZXh0ZW5kcyBKb2ludEF4aWFsIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50Q3lsaW5kcmljYWwpO1xyXG4gICAgI3NwcmluZ0RhbXBpbmdSb3RhdGlvbjogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lSb3RhdGlvbjogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjbW90b3JGb3JjZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjbWF4Um90b3I6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Sb3RvcjogbnVtYmVyID0gMDtcclxuICAgICNyb3RvclRvcnF1ZTogbnVtYmVyID0gMDtcclxuICAgICNyb3RvclNwZWVkOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNyb3RvcjogT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcjtcclxuICAgICNyb3RvclNwcmluZ0RhbXBlcjogT0lNTy5TcHJpbmdEYW1wZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLkN5bGluZHJpY2FsSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLkN5bGluZHJpY2FsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5DeWxpbmRyaWNhbEpvaW50Q29uZmlnKCk7XHJcbiAgICBwcm90ZWN0ZWQgbW90b3I6IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3I7XHJcblxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIGN5bGluZHJpY2FsIGpvaW50IGJldHdlZW4gdHdvIENvbXBvbmVudFJpZ2lkYm9kaWVzIG1vdmluZyBvbiBvbmUgYXhpcyBhbmQgcm90YXRpbmcgYXJvdW5kIGFub3RoZXIgYm91bmQgb24gYSBsb2NhbCBhbmNob3Jwb2ludC4gKi9cclxuICAgIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQsIF9heGlzLCBfbG9jYWxBbmNob3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmcoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIuc3ByaW5nRGFtcGluZyA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsU3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLnNwcmluZ0ZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsU3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLiBJbmZsdWVuY2luZyBUT1JRVUUgLyBST1RBVElPTlxyXG4gICAgKi9cclxuICAgIGdldCBzcHJpbmdEYW1waW5nUm90YXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdSb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHNldCBzcHJpbmdEYW1waW5nUm90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1JvdGF0aW9uID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gSW5mbHVlbmNpbmcgVE9SUVVFIC8gUk9UQVRJT05cclxuICAgICovXHJcbiAgICBnZXQgc3ByaW5nRnJlcXVlbmN5Um90YXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzLUFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1heFJvdG9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhSb3RvcjtcclxuICAgIH1cclxuICAgIHNldCBtYXhSb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhSb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWluUm90b3IoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21pblJvdG9yO1xyXG4gICAgfVxyXG4gICAgc2V0IG1pblJvdG9yKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21pblJvdG9yID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXHJcbiAgICAgKi9cclxuICAgIGdldCByb3RvclNwZWVkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclNwZWVkO1xyXG4gICAgfVxyXG4gICAgc2V0IHJvdG9yU3BlZWQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIGdldCByb3RvclRvcnF1ZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JUb3JxdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgcm90b3JUb3JxdWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS5tb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWF4TW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubWF4TW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWluTW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubWluTW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBtb3RvclNwZWVkKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciBmb3JjZSBpbiBOZXd0b24uIGZvcmNlIDw9IDAgZXF1YWxzIGRpc2FibGVkLiBcclxuICAgICAqL1xyXG4gICAgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yRm9yY2U7XHJcbiAgICB9XHJcbiAgICBzZXQgbW90b3JGb3JjZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtb3RvckZvcmNlID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgT2JqZWN0LmFzc2lnbihtdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdSb3RhdGlvbjogdGhpcy5zcHJpbmdEYW1waW5nUm90YXRpb24sXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5Um90YXRpb246IHRoaXMuc3ByaW5nRnJlcXVlbmN5Um90YXRpb24sXHJcbiAgICAgICAgbWF4Um90b3I6IHRoaXMubWF4Um90b3IsXHJcbiAgICAgICAgbWluUm90b3I6IHRoaXMubWluUm90b3IsXHJcbiAgICAgICAgcm90b3JUb3JxdWU6IHRoaXMucm90b3JUb3JxdWUsXHJcbiAgICAgICAgcm90b3JTcGVlZDogdGhpcy5yb3RvclNwZWVkXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJtb3RvckZvcmNlXCIsIFwicm90b3JUb3JxdWVcIiwgXCJyb3RvclNwZWVkXCIsIFwibWF4Um90b3JcIiwgXCJtaW5Sb3RvclwiLCBcInNwcmluZ0RhbXBpbmdSb3RhdGlvblwiLCBcInNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uXCIsIFwic3ByaW5nRnJlcXVlbmN5XCJdKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcm90b3JTcHJpbmdEYW1wZXIgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3lSb3RhdGlvbiwgdGhpcy5zcHJpbmdEYW1waW5nUm90YXRpb24pO1xyXG5cclxuICAgICAgdGhpcy5tb3RvciA9IG5ldyBPSU1PLlRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkuc2V0TGltaXRzKHN1cGVyLm1pbk1vdG9yLCBzdXBlci5tYXhNb3Rvcik7XHJcbiAgICAgIHRoaXMubW90b3Iuc2V0TW90b3Ioc3VwZXIubW90b3JTcGVlZCwgdGhpcy5tb3RvckZvcmNlKTtcclxuICAgICAgdGhpcy4jcm90b3IgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLm1pblJvdG9yICogTWF0aC5QSSAvIDE4MCwgdGhpcy5tYXhSb3RvciAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICB0aGlzLiNyb3Rvci5zZXRNb3Rvcih0aGlzLnJvdG9yU3BlZWQsIHRoaXMucm90b3JUb3JxdWUpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5DeWxpbmRyaWNhbEpvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZy50cmFuc2xhdGlvbmFsU3ByaW5nRGFtcGVyID0gdGhpcy5zcHJpbmdEYW1wZXI7XHJcbiAgICAgIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yID0gdGhpcy5tb3RvcjtcclxuICAgICAgdGhpcy5jb25maWcucm90YXRpb25hbExpbWl0TW90b3IgPSB0aGlzLiNyb3RvcjtcclxuICAgICAgdGhpcy5jb25maWcucm90YXRpb25hbFNwcmluZ0RhbXBlciA9IHRoaXMuI3JvdG9yU3ByaW5nRGFtcGVyO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLkN5bGluZHJpY2FsSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggYSBkZWZpbmVkIGF4ZSBtb3ZlbWVudC5cclxuICAgICAqIFVzZWQgdG8gY3JlYXRlIGEgc2xpZGluZyBqb2ludCBhbG9uZyBvbmUgYXhpcy4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuXHJcbiAgICAgKiBBIG1vdG9yIGNhbiBiZSBkZWZpbmVkIHRvIG1vdmUgdGhlIGNvbm5lY3RlZCBhbG9uZyB0aGUgZGVmaW5lZCBheGlzLiBHcmVhdCB0byBjb25zdHJ1Y3Qgc3RhbmRhcmQgc3ByaW5ncyBvciBwaHlzaWNhbCBzbGlkZXJzLlxyXG4gICAgICogXHJcbiAgICAgKiBgYGBwbGFpbnRleHRcclxuICAgICAqICAgICAgICAgIEpvaW50SG9sZGVyIC0gYm9keUFuY2hvclxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxyXG4gICAgICogICAgICAgICAgIDzilIDilIDilIDilIDilIDilIDilIDilIDilIIgICDilILilIDilIDilIDilIDilIDilIA+IHRpZWQgYm9keSwgc2xpZGluZyBvbiBvbmUgQXhpcywgMSBEZWdyZWUgb2YgRnJlZWRvbVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmFxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRQcmlzbWF0aWMgZXh0ZW5kcyBKb2ludEF4aWFsIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50UHJpc21hdGljKTtcclxuXHJcbiAgICAjbW90b3JGb3JjZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uUHJpc21hdGljSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLlByaXNtYXRpY0pvaW50Q29uZmlnID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcoKTtcclxuICAgIHByb3RlY3RlZCBtb3RvcjogT0lNTy5UcmFuc2xhdGlvbmFsTGltaXRNb3RvcjtcclxuICAgIC8vSW50ZXJuYWxseSB1c2VkIHZhcmlhYmxlcyAtIEpvaW50IFByb3BlcnRpZXMgdGhhdCBhcmUgdXNlZCBldmVuIHdoZW4gbm8gYWN0dWFsIGpvaW50IGlzIGN1cnJlbnRseSBleGlzdGVuZFxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIHByaXNtYXRpYyBqb2ludCBiZXR3ZWVuIHR3byBDb21wb25lbnRSaWdpZGJvZGllcyBvbmx5IG1vdmluZyBvbiBvbmUgYXhpcyBib3VuZCBvbiBhIGxvY2FsIGFuY2hvcnBvaW50LiAqL1xyXG4gICAgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XHJcblxyXG4gICAgICB0aGlzLm1heE1vdG9yID0gMTA7XHJcbiAgICAgIHRoaXMubWluTW90b3IgPSAtMTA7XHJcbiAgICB9XHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgZm9yY2UgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gVGhpcyBpcyB0aGUgZm9yY2UgdGhhdCB0aGUgbW90b3IgaXMgdXNpbmcgdG8gaG9sZCB0aGUgcG9zaXRpb24sIG9yIHJlYWNoIGl0IGlmIGEgbW90b3JTcGVlZCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yRm9yY2U7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkubW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tb3RvckZvcmNlID0gX3NlcmlhbGl6YXRpb24ubW90b3JGb3JjZTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IubW90b3JGb3JjZSA9IHRoaXMubW90b3JGb3JjZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tb3RvckZvcmNlKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLm1vdG9yRm9yY2UgPSBfbXV0YXRvci5tb3RvckZvcmNlO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubW90b3JGb3JjZTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKiBBY3R1YWwgY3JlYXRpb24gb2YgYSBqb2ludCBpbiB0aGUgT2ltb1BoeXNpY3Mgc3lzdGVtICovXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubW90b3IgPSBuZXcgT0lNTy5UcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLm1pbk1vdG9yLCB0aGlzLm1heE1vdG9yKTsgLy9DcmVhdGUgbW90b3Igc2V0dGluZ3MsIHRvIGhvbGQgcG9zaXRpb25zLCBzZXQgY29uc3RyYWludCBtaW4vbWF4XHJcbiAgICAgIHRoaXMubW90b3Iuc2V0TW90b3IodGhpcy5tb3RvclNwZWVkLCB0aGlzLm1vdG9yRm9yY2UpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5QcmlzbWF0aWNKb2ludENvbmZpZygpOyAvL0NyZWF0ZSBhIHNwZWNpZmljIGNvbmZpZyBmb3IgdGhpcyBqb2ludCB0eXBlIHRoYXQgaXMgY2FsY3VsYXRpbmcgdGhlIGxvY2FsIGF4aXMgZm9yIGJvdGggYm9kaWVzXHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIgPSB0aGlzLnNwcmluZ0RhbXBlcjsgLy9UZWxsaW5nIHRoZSBjb25maWcgdG8gdXNlIHRoZSBtb3Rvci9zcHJpbmcgb2YgdGhlIEZ1ZGdlIENvbXBvbmVudFxyXG4gICAgICB0aGlzLmNvbmZpZy5saW1pdE1vdG9yID0gdGhpcy5tb3RvcjtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5QcmlzbWF0aWNKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuY29uZmlndXJlSm9pbnQoKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcywgZGVzaWduZWQgdG8gc2ltdWxhdGUgYmVoYXZpb3VyIHdpdGhpbiBhIHJlYWwgYm9keS4gSXQgaGFzIHR3byBheGlzLCBhIHN3aW5nIGFuZCB0d2lzdCBheGlzLCBhbmQgYWxzbyB0aGUgcGVycGVuZGljdWxhciBheGlzLCBcclxuICAgICogc2ltaWxhciB0byBhIFNwaGVyaWNhbCBqb2ludCwgYnV0IG1vcmUgcmVzdHJpY3RpdmUgaW4gaXQncyBhbmdsZXMgYW5kIG9ubHkgdHdvIGRlZ3JlZXMgb2YgZnJlZWRvbS4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuIE1vc3RseSB1c2VkIHRvIGNyZWF0ZSBodW1hbmxpa2Ugam9pbnRzIHRoYXQgYmVoYXZlIGxpa2UgYSBcclxuICAgICogbGlmZWxlc3MgYm9keS5cclxuICAgICogYGBgcGxhaW50ZXh0ICAgICAgICBcclxuICAgICogICAgICAgICAgICAgICAgICBcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgYW5jaG9yIC0gaXQgY2FuIHR3aXN0IG9uIG9uZSBheGlzIGFuZCBzd2luZyBvbiBhbm90aGVyXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAgKiAgICAgICAgIHogICAgICAgICAgICDilIzilIDilIDilIDilJAg4pSCIOKUjOKUgOKUgOKUgOKUkFxyXG4gICAgKiAgICAgICAgIOKGkSAgICAgICAgICAgIOKUgiAgIOKUgiDihpMg4pSCICAg4pSCICAgICAgICBlLmcuIHogPSBUd2lzdEF4aXMsIGl0IGNhbiByb3RhdGUgaW4taXRzZWxmIGFyb3VuZCB0aGlzIGF4aXMgXHJcbiAgICAqICAgIC14IOKGkOKUgOKUvOKUgOKGkiB4ICAgICAgICDilIIgICDilIIgeCDilIIgICDilIIgICAgICAgIGUuZy4geCA9IFN3aW5nQXhpcywgaXQgY2FuIHJvdGF0ZSBhbmNob3JlZCBhcm91bmQgdGhlIGJhc2Ugb24gdGhpcyBheGlzICAgXHJcbiAgICAqICAgICAgICAg4oaTICAgICAgICAgICAg4pSCICAg4pSCICAg4pSCICAg4pSCICAgICAgICAgICBcclxuICAgICogICAgICAgIC16ICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSYICAgICAgICAgZS5nLiB5b3UgY2FuIHR3aXN0IHRoZSBsZWcgaW4taXRzZWxmIHRvIGEgY2VydGFpbiBkZWdyZWUsXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXQgYWxzbyByb3RhdGUgaXQgZm9yd2FyZC9iYWNrd2FyZC9sZWZ0L3JpZ2h0IHRvIGEgY2VydGFpbiBkZWdyZWVcclxuICAgICogICAgICAgICAgICAgICAgYm9keUFuY2hvciAgICAgICAgICBib2R5VGllZFxyXG4gICAgKiAgICAgICAgICAgICAgKGUuZy4gcGVsdmlzKSAgICAgICAgIChlLmcuIHVwcGVyLWxlZylcclxuICAgICogXHJcbiAgICAqIGBgYFxyXG4gICAgKiBUd2lzdCBlcXVhbHMgYSByb3RhdGlvbiBhcm91bmQgYSBwb2ludCB3aXRob3V0IG1vdmluZyBvbiBhbiBheGlzLlxyXG4gICAgKiBTd2luZyBlcXVhbHMgYSByb3RhdGlvbiBvbiBhIHBvaW50IHdpdGggYSBtb3ZpbmcgbG9jYWwgYXhpcy5cclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICovXHJcblxyXG4gIGV4cG9ydCBjbGFzcyBKb2ludFJhZ2RvbGwgZXh0ZW5kcyBKb2ludCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludFJhZ2RvbGwpO1xyXG5cclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZ1R3aXN0OiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeVR3aXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nU3dpbmc6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5U3dpbmc6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heE1vdG9yVHdpc3Q6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Nb3RvclR3aXN0OiBudW1iZXIgPSAwO1xyXG4gICAgI21vdG9yVG9ycXVlVHdpc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjbW90b3JTcGVlZFR3aXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtb3RvclR3aXN0OiBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgI3NwcmluZ0RhbXBlclR3aXN0OiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNzcHJpbmdEYW1wZXJTd2luZzogT0lNTy5TcHJpbmdEYW1wZXI7XHJcbiAgICAjYXhpc0ZpcnN0OiBPSU1PLlZlYzM7XHJcbiAgICAjYXhpc1NlY29uZDogT0lNTy5WZWMzO1xyXG5cclxuXHJcbiAgICAjbWF4QW5nbGVGaXJzdDogbnVtYmVyID0gMDtcclxuICAgICNtYXhBbmdsZVNlY29uZDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uUmFnZG9sbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5SYWdkb2xsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnRDb25maWcoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpc0ZpcnN0OiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMCwgMCksIF9heGlzU2Vjb25kOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMSksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xyXG4gICAgICB0aGlzLmF4aXNGaXJzdCA9IF9heGlzRmlyc3Q7XHJcbiAgICAgIHRoaXMuYXhpc1NlY29uZCA9IF9heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLmFuY2hvciA9IF9sb2NhbEFuY2hvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXHJcbiAgICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGF4aXNGaXJzdCgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXNGaXJzdC54LCB0aGlzLiNheGlzRmlyc3QueSwgdGhpcy4jYXhpc0ZpcnN0LnopO1xyXG4gICAgfVxyXG4gICAgc2V0IGF4aXNGaXJzdChfdmFsdWU6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy4jYXhpc0ZpcnN0ID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxyXG4gICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICovXHJcbiAgICBnZXQgYXhpc1NlY29uZCgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXNTZWNvbmQueCwgdGhpcy4jYXhpc1NlY29uZC55LCB0aGlzLiNheGlzU2Vjb25kLnopO1xyXG4gICAgfVxyXG4gICAgc2V0IGF4aXNTZWNvbmQoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXNTZWNvbmQgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYW5nbGUgb2Ygcm90YXRpb24gYWxvbmcgdGhlIGZpcnN0IGF4aXMuIFZhbHVlIG5lZWRzIHRvIGJlIHBvc2l0aXZlLiBDaGFuZ2VzIGRvIHJlYnVpbGQgdGhlIGpvaW50XHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhBbmdsZUZpcnN0QXhpcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4QW5nbGVGaXJzdCAqIDE4MCAvIE1hdGguUEk7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4QW5nbGVGaXJzdEF4aXMoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4QW5nbGVGaXJzdCA9IF92YWx1ZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSBhbmdsZSBvZiByb3RhdGlvbiBhbG9uZyB0aGUgc2Vjb25kIGF4aXMuIFZhbHVlIG5lZWRzIHRvIGJlIHBvc2l0aXZlLiBDaGFuZ2VzIGRvIHJlYnVpbGQgdGhlIGpvaW50XHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhBbmdsZVNlY29uZEF4aXMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heEFuZ2xlU2Vjb25kICogMTgwIC8gTWF0aC5QSTtcclxuICAgIH1cclxuICAgIHNldCBtYXhBbmdsZVNlY29uZEF4aXMoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4QW5nbGVTZWNvbmQgPSBfdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0RhbXBpbmdUd2lzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1R3aXN0O1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcmluZ0RhbXBpbmdUd2lzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nVHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVR3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lUd2lzdDtcclxuICAgIH1cclxuICAgIHNldCBzcHJpbmdGcmVxdWVuY3lUd2lzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3lUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBzcHJpbmdEYW1waW5nU3dpbmcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdTd2luZztcclxuICAgIH1cclxuICAgIHNldCBzcHJpbmdEYW1waW5nU3dpbmcoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1N3aW5nID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFN3aW5nU3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIGdldCBzcHJpbmdGcmVxdWVuY3lTd2luZygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5U3dpbmc7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRnJlcXVlbmN5U3dpbmcoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5U3dpbmcgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3dpbmdTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4TW90b3JUd2lzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4TW90b3JUd2lzdCAqIDE4MCAvIE1hdGguUEk7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4TW90b3JUd2lzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBfdmFsdWUgKj0gTWF0aC5QSSAvIDE4MDtcclxuICAgICAgdGhpcy4jbWF4TW90b3JUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBtaW5Nb3RvclR3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtaW5Nb3RvclR3aXN0ICogMTgwIC8gTWF0aC5QSTtcclxuICAgIH1cclxuICAgIHNldCBtaW5Nb3RvclR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIF92YWx1ZSAqPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICB0aGlzLiNtaW5Nb3RvclR3aXN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFR3aXN0TGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXHJcbiAgICAgKi9cclxuICAgIGdldCBtb3RvclNwZWVkVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yU3BlZWRUd2lzdDtcclxuICAgIH1cclxuICAgIHNldCBtb3RvclNwZWVkVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JTcGVlZFR3aXN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFR3aXN0TGltaXRNb3RvcigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIGdldCBtb3RvclRvcnF1ZVR3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclRvcnF1ZVR3aXN0O1xyXG4gICAgfVxyXG4gICAgc2V0IG1vdG9yVG9ycXVlVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JUb3JxdWVUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS5tb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBJZiB0aGUgdHdvIGNvbm5lY3RlZCBSaWdpZEJvZGllcyBjb2xsaWRlIHdpdGggZWF0aCBvdGhlci4gKERlZmF1bHQgPSBmYWxzZSlcclxuICAgICAqL1xyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLiNnZXRNdXRhdG9yKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uYXhpc0ZpcnN0ID0gdGhpcy5heGlzRmlyc3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uYXhpc1NlY29uZCA9IHRoaXMuYXhpc1NlY29uZC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLmF4aXNGaXJzdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5heGlzRmlyc3QpO1xyXG4gICAgICBhd2FpdCB0aGlzLmF4aXNTZWNvbmQuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc1NlY29uZCk7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5heGlzRmlyc3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNGaXJzdCkpKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc1NlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5heGlzU2Vjb25kID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNTZWNvbmQpKSk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzRmlyc3Q7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgT2JqZWN0LmFzc2lnbihtdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBtdXRhdG9yLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LmdldE11dGF0b3IoKTtcclxuICAgICAgbXV0YXRvci5heGlzU2Vjb25kID0gdGhpcy5heGlzU2Vjb25kLmdldE11dGF0b3IoKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIG1heEFuZ2xlRmlyc3Q6IHRoaXMuI21heEFuZ2xlRmlyc3QsXHJcbiAgICAgICAgbWF4QW5nbGVTZWNvbmQ6IHRoaXMuI21heEFuZ2xlU2Vjb25kLFxyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdUd2lzdDogdGhpcy5zcHJpbmdEYW1waW5nVHdpc3QsXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5VHdpc3Q6IHRoaXMuc3ByaW5nRnJlcXVlbmN5VHdpc3QsXHJcbiAgICAgICAgc3ByaW5nRGFtcGluZ1N3aW5nOiB0aGlzLnNwcmluZ0RhbXBpbmdTd2luZyxcclxuICAgICAgICBzcHJpbmdGcmVxdWVuY3lTd2luZzogdGhpcy5zcHJpbmdGcmVxdWVuY3lTd2luZyxcclxuICAgICAgICBtYXhNb3RvclR3aXN0OiB0aGlzLiNtYXhNb3RvclR3aXN0LFxyXG4gICAgICAgIG1pbk1vdG9yVHdpc3Q6IHRoaXMuI21pbk1vdG9yVHdpc3QsXHJcbiAgICAgICAgbW90b3JTcGVlZFR3aXN0OiB0aGlzLm1vdG9yU3BlZWRUd2lzdCxcclxuICAgICAgICBtb3RvclRvcnF1ZVR3aXN0OiB0aGlzLm1vdG9yVG9ycXVlVHdpc3RcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgI211dGF0ZSA9IChfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tYXhBbmdsZUZpcnN0KSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLiNtYXhBbmdsZUZpcnN0ID0gX211dGF0b3IubWF4QW5nbGVGaXJzdDtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IubWF4QW5nbGVTZWNvbmQpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuI21heEFuZ2xlU2Vjb25kID0gX211dGF0b3IubWF4QW5nbGVTZWNvbmQ7XHJcbiAgICAgIHRoaXMubXV0YXRlQmFzZShfbXV0YXRvciwgW1xyXG4gICAgICAgIFwic3ByaW5nRGFtcGluZ1R3aXN0XCIsIFwic3ByaW5nRnJlcXVlbmN5VHdpc3RcIiwgXCJzcHJpbmdEYW1waW5nU3dpbmdcIiwgXCJzcHJpbmdGcmVxdWVuY3lTd2luZ1wiLCBcIm1heE1vdG9yVHdpc3RcIiwgXCJtaW5Nb3RvclR3aXN0XCIsIFwibW90b3JTcGVlZFR3aXN0XCIsIFwibW90b3JUb3JxdWVUd2lzdFwiXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXJUd2lzdCA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLnNwcmluZ0ZyZXF1ZW5jeVR3aXN0LCB0aGlzLnNwcmluZ0RhbXBpbmdUd2lzdCk7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBlclN3aW5nID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuc3ByaW5nRnJlcXVlbmN5U3dpbmcsIHRoaXMuc3ByaW5nRGFtcGluZ1N3aW5nKTtcclxuXHJcbiAgICAgIHRoaXMuI21vdG9yVHdpc3QgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLm1pbk1vdG9yVHdpc3QsIHRoaXMubWF4TW90b3JUd2lzdCk7XHJcbiAgICAgIHRoaXMuI21vdG9yVHdpc3Quc2V0TW90b3IodGhpcy5tb3RvclNwZWVkVHdpc3QsIHRoaXMubW90b3JUb3JxdWVUd2lzdCk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlJhZ2RvbGxKb2ludENvbmZpZygpO1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCh0aGlzLmF4aXNGaXJzdCwgdGhpcy5heGlzU2Vjb25kKTtcclxuICAgICAgdGhpcy5jb25maWcuc3dpbmdTcHJpbmdEYW1wZXIgPSB0aGlzLiNzcHJpbmdEYW1wZXJTd2luZztcclxuICAgICAgdGhpcy5jb25maWcudHdpc3RTcHJpbmdEYW1wZXIgPSB0aGlzLiNzcHJpbmdEYW1wZXJUd2lzdDtcclxuICAgICAgdGhpcy5jb25maWcudHdpc3RMaW1pdE1vdG9yID0gdGhpcy4jbW90b3JUd2lzdDtcclxuICAgICAgdGhpcy5jb25maWcubWF4U3dpbmdBbmdsZTEgPSB0aGlzLiNtYXhBbmdsZUZpcnN0O1xyXG4gICAgICB0aGlzLmNvbmZpZy5tYXhTd2luZ0FuZ2xlMiA9IHRoaXMuI21heEFuZ2xlU2Vjb25kO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLlJhZ2RvbGxKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHN1cGVyLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggYSBkZWZpbmVkIGF4ZSBvZiByb3RhdGlvbi4gQWxzbyBrbm93biBhcyBISU5HRSBqb2ludC5cclxuICAgICAqIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LiBBIG1vdG9yIGNhbiBiZSBkZWZpbmVkIHRvIHJvdGF0ZSB0aGUgY29ubmVjdGVkIGFsb25nIHRoZSBkZWZpbmVkIGF4aXMuXHJcbiAgICAgKiBcclxuICAgICAqIGBgYHBsYWludGV4dCAgICAgICAgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uIGF4aXMsIDFzdCBEZWdyZWUgb2YgZnJlZWRvbVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIOKGkVxyXG4gICAgICogICAgICAgICAgICAgICDilIzilIDilIDilIDilJDilILilIzilIDilIDilIDilIDilJAgICAgIFxyXG4gICAgICogICAgICAgICAgICAgICDilIIgICDilILilILilIIgICAg4pSCICBcclxuICAgICAqICAgICAgICAgICAgICAg4pSCICAg4pSC4pSC4pSCICAgIOKUgiBcclxuICAgICAqICAgICAgICAgICAgICAg4pSCICAg4pSC4pSC4pSCICAgIOKUgiBcclxuICAgICAqICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSY4pSC4pSU4pSA4pSA4pSA4pSA4pSYXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAgXHJcbiAgICAgKiAgICAgIGJvZHlBbmNob3IgICAgICAgICBib2R5VGllZFxyXG4gICAgICogICAoZS5nLiBEb29yaGluZ2UpICAgICAgIChlLmcuIERvb3IpXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBKb2ludFJldm9sdXRlIGV4dGVuZHMgSm9pbnRBeGlhbCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludFJldm9sdXRlKTtcclxuXHJcbiAgICAjbW90b3JUb3JxdWU6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3I6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcblxyXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLlJldm9sdXRlSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLlJldm9sdXRlSm9pbnRDb25maWcgPSBuZXcgT0lNTy5SZXZvbHV0ZUpvaW50Q29uZmlnKCk7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQsIF9heGlzLCBfbG9jYWxBbmNob3IpO1xyXG5cclxuICAgICAgdGhpcy5tYXhNb3RvciA9IDM2MDtcclxuICAgICAgdGhpcy5taW5Nb3RvciA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG1heE1vdG9yKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLm1heE1vdG9yID0gX3ZhbHVlO1xyXG4gICAgICBfdmFsdWUgKj0gTWF0aC5QSSAvIDE4MDtcclxuICAgICAgaWYgKHRoaXMuam9pbnQpXHJcbiAgICAgICAgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzIEFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtaW5Nb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5taW5Nb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQpXHJcbiAgICAgICAgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgZm9yY2UgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIGdldCBtb3RvclRvcnF1ZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbW90b3JUb3JxdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgbW90b3JUb3JxdWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIElmIHRoZSB0d28gY29ubmVjdGVkIFJpZ2lkQm9kaWVzIGNvbGxpZGUgd2l0aCBlYXRoIG90aGVyLiAoRGVmYXVsdCA9IGZhbHNlKVxyXG4gICAgICovXHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBtb3RvclRvcnF1ZTogdGhpcy5tb3RvclRvcnF1ZSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubW90b3JUb3JxdWUgPSBfc2VyaWFsaXphdGlvbi5tb3RvclRvcnF1ZTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IubW90b3JUb3JxdWUgPSB0aGlzLm1vdG9yVG9ycXVlO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLm1vdG9yVG9ycXVlKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLm1vdG9yVG9ycXVlID0gX211dGF0b3IubW90b3JUb3JxdWU7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tb3RvclRvcnF1ZTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcm90b3IgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyhzdXBlci5taW5Nb3RvciAqIE1hdGguUEkgLyAxODAsIHN1cGVyLm1heE1vdG9yICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgIHRoaXMuI3JvdG9yLnNldE1vdG9yKHRoaXMubW90b3JTcGVlZCwgdGhpcy5tb3RvclRvcnF1ZSk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlJldm9sdXRlSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQoKTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnLnNwcmluZ0RhbXBlciA9IHRoaXMuc3ByaW5nRGFtcGVyO1xyXG4gICAgICB0aGlzLmNvbmZpZy5saW1pdE1vdG9yID0gdGhpcy4jcm90b3I7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uUmV2b2x1dGVKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuY29uZmlndXJlSm9pbnQoKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMgd2l0aCB0aHJlZSBEZWdyZWVzIG9mIEZyZWVkb20sIGFsc28ga25vd24gYXMgYmFsbCBhbmQgc29ja2V0IGpvaW50LiBUd28gYm9kaWVzIGNvbm5lY3RlZCBhdCB0aGVpciBhbmNob3IgYnV0IGZyZWUgdG8gcm90YXRlLlxyXG4gICAgICogVXNlZCBmb3IgdGhpbmdzIGxpa2UgdGhlIGNvbm5lY3Rpb24gb2YgYm9uZXMgaW4gdGhlIGh1bWFuIHNob3VsZGVyIChpZiBzaW1wbGlmaWVkLCBlbHNlIGJldHRlciB1c2UgSm9pbnRSYWdkb2xsKS4gVHdvIFJpZ2lkQm9kaWVzIG5lZWQgdG8gYmUgZGVmaW5lZCB0byB1c2UgaXQuIE9ubHkgc3ByaW5nIHNldHRpbmdzIGNhbiBiZSBkZWZpbmVkLlxyXG4gICAgICogMyBEZWdyZWVzIGFyZSBzd2luZyBob3Jpem9udGFsLCBzd2luZyB2ZXJ0aWNhbCBhbmQgdHdpc3QuXHJcbiAgICAgKiBcclxuICAgICAqIGBgYHBsYWludGV4dFxyXG4gICAgICogICAgICAgICAgICAgIEpvaW50SG9sZGVyXHJcbiAgICAgKiAgICAgICAgIHogICAgICBib2R5QW5jaG9yIChlLmcuIEh1bWFuLVNob3VsZGVyKSAgICAgXHJcbiAgICAgKiAgICAgIHkgIOKGkSAgICAgICAgICBcclxuICAgICAqICAgICAgICBcXHwgICAgICAgICAg4pSA4pSA4pSAKOKXj+KUgOKUgOKUgFxyXG4gICAgICogIC14IDwtLS18LS0tPiB4ICAgICAgICAgICBib2R5VGllZCAgICAgICAgXHJcbiAgICAgKiAgICAgICAgIHxcXCAgICAgICAgICAgICAgICAoZS5nLiBVcHBlci1Bcm0pIFxyXG4gICAgICogICAgICAgICDihpMgLXkgICAgICAgXHJcbiAgICAgKiAgICAgICAgLXogICAgICAgICAgXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBKb2ludFNwaGVyaWNhbCBleHRlbmRzIEpvaW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50U3BoZXJpY2FsKTtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZzogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3k6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRGFtcGVyOiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uU3BoZXJpY2FsSm9pbnQ7XHJcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBPSU1PLlNwaGVyaWNhbEpvaW50Q29uZmlnID0gbmV3IE9JTU8uU3BoZXJpY2FsSm9pbnRDb25maWcoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcclxuICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyhfbG9jYWxBbmNob3IueCwgX2xvY2FsQW5jaG9yLnksIF9sb2NhbEFuY2hvci56KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0RhbXBpbmcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmc7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRGFtcGluZyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBnZXQgc3ByaW5nRnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3k7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRnJlcXVlbmN5KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHNwcmluZ0RhbXBpbmc6IHRoaXMuc3ByaW5nRGFtcGluZyxcclxuICAgICAgICBzcHJpbmdGcmVxdWVuY3k6IHRoaXMuc3ByaW5nRnJlcXVlbmN5LFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5zcHJpbmdEYW1waW5nID0gX3NlcmlhbGl6YXRpb24uc3ByaW5nRGFtcGluZztcclxuICAgICAgdGhpcy5zcHJpbmdGcmVxdWVuY3kgPSBfc2VyaWFsaXphdGlvbi5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLnNwcmluZ0RhbXBpbmcgPSB0aGlzLnNwcmluZ0RhbXBpbmc7XHJcbiAgICAgIG11dGF0b3Iuc3ByaW5nRnJlcXVlbmN5ID0gdGhpcy5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJzcHJpbmdEYW1waW5nXCIsIFwic3ByaW5nRnJlcXVlbmN5XCJdKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNwcmluZ0RhbXBpbmc7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBlciA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLnNwcmluZ0ZyZXF1ZW5jeSwgdGhpcy5zcHJpbmdEYW1waW5nKTtcclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5TcGhlcmljYWxKb2ludENvbmZpZygpO1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCgpO1xyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIgPSB0aGlzLiNzcHJpbmdEYW1wZXI7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uU3BoZXJpY2FsSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICBzdXBlci5jb25maWd1cmVKb2ludCgpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIHR3byBkZWZpbmVkIGF4aXMgKG5vcm1hbGx5IGUuZy4gKDAsMCwxKSBhbmQgcm90YXRpb24oMSwwLDApKSwgdGhleSBzaGFyZSB0aGUgc2FtZSBhbmNob3IgYW5kIGhhdmUgZnJlZSByb3RhdGlvbiwgYnV0IHRyYW5zZmVyIHRoZSB0d2lzdC5cclxuICAgICAqIEluIHJlYWxpdHkgdXNlZCBpbiBjYXJzIHRvIHRyYW5zZmVyIHRoZSBtb3JlIHN0YWJsZSBzdGF0aW9uYXJ5IGZvcmNlIG9uIHRoZSB2ZWxvY2l0eSBheGlzIHRvIHRoZSBidW1waW5nLCBkYW1wZWQgbW92aW5nIHdoZWVsLiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC5cclxuICAgICAqIFRoZSB0d28gbW90b3JzIGNhbiBiZSBkZWZpbmVkIGZvciB0aGUgdHdvIHJvdGF0aW9uIGF4aXMsIGFsb25nIHdpdGggc3ByaW5ncy4gXHJcbiAgICAgKiBgYGBwbGFpbnRleHQgICAgICAgIFxyXG4gICAgICogICAgICAgICAgICAgICAgICBcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciAtIHR3aXN0IGlzIHRyYW5zZmVyZWQgYmV0d2VlbiBib2RpZXNcclxuICAgICAqICAgICAgICAgeiAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgKiAgICAgICAgIOKGkSAgICAgICAgICAgIC0tLS0tICB8ICAtLS0tLS0tLS0tLS1cclxuICAgICAqICAgICAgICAgfCAgICAgICAgICAgfCAgICAgfCDihpMgfCAgICAgICAgICAgIHwgXHJcbiAgICAgKiAgLXggPC0tLXwtLS0+IHggICAgIHwgICAgIHwgeCB8ICAgICAgICAgICAgfCAgICAgICAgICAgZS5nLiB3aGVlbCBjYW4gc3RpbGwgdHVybiB1cC9kb3duLCBcclxuICAgICAqICAgICAgICAgfCAgICAgICAgICAgfCAgICAgfCAgIHwgICAgICAgICAgICB8ICAgICAgICAgICBsZWZ0IHJpZ2h0IGJ1dCB0cmFuc2ZlcmluZyBpdCdzIHJvdGF0aW9uIG9uIHRvIHRoZSB3aGVlbC1heGlzLlxyXG4gICAgICogICAgICAgICDihpMgICAgICAgICAgICAtLS0tLSAgICAgLS0tLS0tLS0tLS0tXHJcbiAgICAgKiAgICAgICAgLXogICAgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgYXR0YWNoZWRSQiAgICAgICAgICBjb25uZWN0ZWRSQlxyXG4gICAgICogICAgICAgICAgICAgICAgKGUuZy4gd2hlZWwpICAgICAgIChlLmcuIHdoZWVsLWF4aXMpXHJcbiAgICAgKiBgYGBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRVbml2ZXJzYWwgZXh0ZW5kcyBKb2ludCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludFVuaXZlcnNhbCk7XHJcblxyXG4gICAgI3NwcmluZ0RhbXBpbmdGaXJzdDogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lGaXJzdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZ1NlY29uZDogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lTZWNvbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heFJvdG9yRmlyc3Q6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Sb3RvckZpcnN0OiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yVG9ycXVlRmlyc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3JTcGVlZEZpcnN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtYXhSb3RvclNlY29uZDogbnVtYmVyID0gMzYwO1xyXG4gICAgI21pblJvdG9yU2Vjb25kOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yVG9ycXVlU2Vjb25kOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yU3BlZWRTZWNvbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21vdG9yRmlyc3Q6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjbW90b3JTZWNvbmQ6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjYXhpc1NwcmluZ0RhbXBlckZpcnN0OiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNheGlzU3ByaW5nRGFtcGVyU2Vjb25kOiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNheGlzRmlyc3Q6IE9JTU8uVmVjMztcclxuICAgICNheGlzU2Vjb25kOiBPSU1PLlZlYzM7XHJcblxyXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLlVuaXZlcnNhbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5Vbml2ZXJzYWxKb2ludENvbmZpZyA9IG5ldyBPSU1PLlVuaXZlcnNhbEpvaW50Q29uZmlnKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXNGaXJzdDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDEsIDAsIDApLCBfYXhpc1NlY29uZDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcclxuICAgICAgdGhpcy5heGlzRmlyc3QgPSBfYXhpc0ZpcnN0O1xyXG4gICAgICB0aGlzLmF4aXNTZWNvbmQgPSBfYXhpc1NlY29uZDtcclxuICAgICAgdGhpcy5hbmNob3IgPSBfbG9jYWxBbmNob3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEdldC9TZXQgdHJhbnNmb3Igb2YgZnVkZ2UgcHJvcGVydGllcyB0byB0aGUgcGh5c2ljcyBlbmdpbmVcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxyXG4gICAgICogIFdoZW4gY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiB0aGUgam9pbnQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldCBheGlzRmlyc3QoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzRmlyc3QueCwgdGhpcy4jYXhpc0ZpcnN0LnksIHRoaXMuI2F4aXNGaXJzdC56KTtcclxuICAgIH1cclxuICAgIHNldCBheGlzRmlyc3QoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXNGaXJzdCA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxyXG4gICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICovXHJcbiAgICBnZXQgYXhpc1NlY29uZCgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXNTZWNvbmQueCwgdGhpcy4jYXhpc1NlY29uZC55LCB0aGlzLiNheGlzU2Vjb25kLnopO1xyXG4gICAgfVxyXG4gICAgc2V0IGF4aXNTZWNvbmQoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXNTZWNvbmQgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNwcmluZ0RhbXBpbmdGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0O1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcmluZ0RhbXBpbmdGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nRmlyc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyMSgpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBnZXQgc3ByaW5nRnJlcXVlbmN5Rmlyc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0O1xyXG4gICAgfVxyXG4gICAgc2V0IHNwcmluZ0ZyZXF1ZW5jeUZpcnN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcjEoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBnZXQgc3ByaW5nRGFtcGluZ1NlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZDtcclxuICAgIH1cclxuICAgIHNldCBzcHJpbmdEYW1waW5nU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmdTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyMigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBnZXQgc3ByaW5nRnJlcXVlbmN5U2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaW5nRnJlcXVlbmN5U2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVNlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzLUFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IG1heFJvdG9yRmlyc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heFJvdG9yRmlyc3Q7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4Um90b3JGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhSb3RvckZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IxKCkudXBwZXJMaW1pdCA9IF92YWx1ZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBtaW5Sb3RvckZpcnN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtaW5Sb3RvckZpcnN0O1xyXG4gICAgfVxyXG4gICAgc2V0IG1pblJvdG9yRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWluUm90b3JGaXJzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLmxvd2VyTGltaXQgPSBfdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBtb3RvciBpbiBtL3MuIFxyXG4gICAgICovXHJcbiAgICBnZXQgcm90b3JTcGVlZEZpcnN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclNwZWVkRmlyc3Q7XHJcbiAgICB9XHJcbiAgICBzZXQgcm90b3JTcGVlZEZpcnN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3JvdG9yU3BlZWRGaXJzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIGdldCByb3RvclRvcnF1ZUZpcnN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0O1xyXG4gICAgfVxyXG4gICAgc2V0IHJvdG9yVG9ycXVlRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JUb3JxdWVGaXJzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICovXHJcbiAgICBnZXQgbWF4Um90b3JTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heFJvdG9yU2Vjb25kO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heFJvdG9yU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21heFJvdG9yU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IyKCkudXBwZXJMaW1pdCA9IF92YWx1ZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBtaW5Sb3RvclNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluUm90b3JTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBzZXQgbWluUm90b3JTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWluUm90b3JTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjIoKS5sb3dlckxpbWl0ID0gX3ZhbHVlICogTWF0aC5QSSAvIDE4MDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgbW90b3IgaW4gbS9zLiBcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdG9yU3BlZWRTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yU3BlZWRTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBzZXQgcm90b3JTcGVlZFNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclNwZWVkU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IyKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSBpbiBOZXd0b24uIGZvcmNlIDw9IDAgZXF1YWxzIGRpc2FibGVkLiBcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdG9yVG9ycXVlU2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclRvcnF1ZVNlY29uZDtcclxuICAgIH1cclxuICAgIHNldCByb3RvclRvcnF1ZVNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclRvcnF1ZVNlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIElmIHRoZSB0d28gY29ubmVjdGVkIFJpZ2lkQm9kaWVzIGNvbGxpZGUgd2l0aCBlYXRoIG90aGVyLiAoRGVmYXVsdCA9IGZhbHNlKVxyXG4gICAgICovXHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5maXJzdEF4aXMgPSB0aGlzLmF4aXNGaXJzdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zZWNvbmRBeGlzID0gdGhpcy5heGlzU2Vjb25kLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gYXdhaXQgbmV3IFZlY3RvcjMoKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5heGlzRmlyc3QpO1xyXG4gICAgICB0aGlzLmF4aXNTZWNvbmQgPSBhd2FpdCBuZXcgVmVjdG9yMygpLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc0ZpcnN0KSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLmF4aXNGaXJzdCA9IG5ldyBWZWN0b3IzKC4uLjxudW1iZXJbXT4oT2JqZWN0LnZhbHVlcyhfbXV0YXRvci5heGlzRmlyc3QpKSk7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLmF4aXNTZWNvbmQpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYXhpc1NlY29uZCA9IG5ldyBWZWN0b3IzKC4uLjxudW1iZXJbXT4oT2JqZWN0LnZhbHVlcyhfbXV0YXRvci5heGlzU2Vjb25kKSkpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuYXhpc0ZpcnN0O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuYXhpc1NlY29uZDtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5kZWxldGVGcm9tTXV0YXRvcihfbXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24obXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgbXV0YXRvci5heGlzRmlyc3QgPSB0aGlzLmF4aXNGaXJzdC5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IuYXhpc1NlY29uZCA9IHRoaXMuYXhpc1NlY29uZC5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgICNnZXRNdXRhdG9yID0gKCk6IE11dGF0b3IgPT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICBzcHJpbmdEYW1waW5nRmlyc3Q6IHRoaXMuI3NwcmluZ0RhbXBpbmdGaXJzdCxcclxuICAgICAgICBzcHJpbmdGcmVxdWVuY3lGaXJzdDogdGhpcy4jc3ByaW5nRnJlcXVlbmN5Rmlyc3QsXHJcbiAgICAgICAgc3ByaW5nRGFtcGluZ1NlY29uZDogdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCxcclxuICAgICAgICBzcHJpbmdGcmVxdWVuY3lTZWNvbmQ6IHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVNlY29uZCxcclxuICAgICAgICBtYXhSb3RvckZpcnN0OiB0aGlzLiNtYXhSb3RvckZpcnN0LFxyXG4gICAgICAgIG1pblJvdG9yRmlyc3Q6IHRoaXMuI21pblJvdG9yRmlyc3QsXHJcbiAgICAgICAgcm90b3JTcGVlZEZpcnN0OiB0aGlzLiNyb3RvclNwZWVkRmlyc3QsXHJcbiAgICAgICAgcm90b3JUb3JxdWVGaXJzdDogdGhpcy4jcm90b3JUb3JxdWVGaXJzdCxcclxuICAgICAgICBtYXhSb3RvclNlY29uZDogdGhpcy4jbWF4Um90b3JTZWNvbmQsXHJcbiAgICAgICAgbWluUm90b3JTZWNvbmQ6IHRoaXMuI21pblJvdG9yU2Vjb25kLFxyXG4gICAgICAgIHJvdG9yU3BlZWRTZWNvbmQ6IHRoaXMuI3JvdG9yU3BlZWRTZWNvbmQsXHJcbiAgICAgICAgcm90b3JUb3JxdWVTZWNvbmQ6IHRoaXMuI3JvdG9yVG9ycXVlU2Vjb25kXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXHJcbiAgICAgICAgXCJzcHJpbmdEYW1waW5nRmlyc3RcIiwgXCJzcHJpbmdGcmVxdWVuY3lGaXJzdFwiLCBcInNwcmluZ0RhbXBpbmdTZWNvbmRcIiwgXCJzcHJpbmdGcmVxdWVuY3lTZWNvbmRcIixcclxuICAgICAgICBcIm1heFJvdG9yRmlyc3RcIiwgXCJtaW5Sb3RvckZpcnN0XCIsIFwicm90b3JTcGVlZEZpcnN0XCIsIFwicm90b3JUb3JxdWVGaXJzdFwiLFxyXG4gICAgICAgIFwibWF4Um90b3JTZWNvbmRcIiwgXCJtaW5Sb3RvclNlY29uZFwiLCBcInJvdG9yU3BlZWRTZWNvbmRcIiwgXCIucm90b3JUb3JxdWVTZWNvbmRcIl1cclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jYXhpc1NwcmluZ0RhbXBlckZpcnN0ID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0LCB0aGlzLiNzcHJpbmdEYW1waW5nRmlyc3QpO1xyXG4gICAgICB0aGlzLiNheGlzU3ByaW5nRGFtcGVyU2Vjb25kID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVNlY29uZCwgdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCk7XHJcblxyXG4gICAgICB0aGlzLiNtb3RvckZpcnN0ID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy4jbWluUm90b3JGaXJzdCAqIE1hdGguUEkgLyAxODAsIHRoaXMuI21heFJvdG9yRmlyc3QgKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgdGhpcy4jbW90b3JGaXJzdC5zZXRNb3Rvcih0aGlzLiNyb3RvclNwZWVkRmlyc3QsIHRoaXMuI3JvdG9yVG9ycXVlRmlyc3QpO1xyXG4gICAgICB0aGlzLiNtb3RvclNlY29uZCA9IG5ldyBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yKCkuc2V0TGltaXRzKHRoaXMuI21pblJvdG9yRmlyc3QgKiBNYXRoLlBJIC8gMTgwLCB0aGlzLiNtYXhSb3RvckZpcnN0ICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgIHRoaXMuI21vdG9yU2Vjb25kLnNldE1vdG9yKHRoaXMuI3JvdG9yU3BlZWRGaXJzdCwgdGhpcy4jcm90b3JUb3JxdWVGaXJzdCk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlVuaXZlcnNhbEpvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KHRoaXMuI2F4aXNGaXJzdCwgdGhpcy4jYXhpc1NlY29uZCk7XHJcbiAgICAgIHRoaXMuY29uZmlnLmxpbWl0TW90b3IxID0gdGhpcy4jbW90b3JGaXJzdDtcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvcjIgPSB0aGlzLiNtb3RvclNlY29uZDtcclxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyMSA9IHRoaXMuI2F4aXNTcHJpbmdEYW1wZXJGaXJzdDtcclxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyMiA9IHRoaXMuI2F4aXNTcHJpbmdEYW1wZXJTZWNvbmQ7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uVW5pdmVyc2FsSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICBzdXBlci5jb25maWd1cmVKb2ludCgpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIG5vIG1vdmVtZW50LiBcclxuICAgICAqIEJlc3Qgd2F5IHRvIHNpbXVsYXRlIGNvbnZleCBvYmplY3RzIGxpa2UgYSBjaGFpciBzZWF0IGNvbm5lY3RlZCB0byBjaGFpciBsZWdzLlxyXG4gICAgICogVGhlIGFjdHVhbCBhbmNob3IgcG9pbnQgZG9lcyBub3QgbWF0dGVyIHRoYXQgbXVjaCwgb25seSBpbiB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZXMuXHJcbiAgICAgKiBCZWNhdXNlIHdlbGRpbmcgbWVhbnMgdGhleSBzaW1wbHkgZG8gbm90IGRpc2Nvbm5lY3QuICh1bmxlc3MgeW91IGFkZCBCcmVha2FiaWxpdHkpXHJcbiAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50V2VsZGluZyBleHRlbmRzIEpvaW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50V2VsZGluZyk7XHJcblxyXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLkdlbmVyaWNKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uR2VuZXJpY0pvaW50Q29uZmlnID0gbmV3IE9JTU8uR2VuZXJpY0pvaW50Q29uZmlnKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XHJcblxyXG4gICAgICB0aGlzLmFuY2hvciA9IG5ldyBWZWN0b3IzKF9sb2NhbEFuY2hvci54LCBfbG9jYWxBbmNob3IueSwgX2xvY2FsQW5jaG9yLnopO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5HZW5lcmljSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQobmV3IE9JTU8uTWF0MygpLCBuZXcgT0lNTy5NYXQzKCkpO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLkdlbmVyaWNKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy5pbnRlcm5hbENvbGxpc2lvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vUGh5c2ljcy9PSU1PUGh5c2ljcy5kLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIE1hbmFnZXMgdGhlIE9JTU8gcGh5c2ljcyBlbmdpbmUgZm9yIEZVREdFLiBNdWx0aXBsZSBpbnN0YW5jZXMgbWF5IGJlIGNyZWF0ZWQsIG9uZSBpcyBhY3RpdmUgYXQgYSB0aW1lLlxyXG4gICAgKiBBbGwgbWV0aG9kcyBhcmUgc3RhdGljIGFuZCB1c2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UuIEF0IHN0YXJ0dXAsIGEgZGVmYXVsdCBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBiZWNvbWUgdGhlIGFjdGl2ZSBpbnN0YW5jZVxyXG4gICAgKiBBdHRhY2hpbmcgYSB7QGxpbmsgQ29tcG9uZW50UmlnaWRib2R5fSB0byBhIHtAbGluayBOb2RlfSBwbGFjZXMgYSBwaHlzaWNzIGNvbGxpZGVyIGluIHRoZSBwaHlzaWNzIGluc3RhbmNlIGFjdGl2ZSBhdCB0aGF0IHRpbWUuXHJcbiAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjBcclxuICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3Mge1xyXG4gICAgLyoqIFRoZSBTRVRUSU5HUyB0aGF0IGFwcGx5IHRvIHRoZSBwaHlzaWNhbCB3b3JsZC4gUmFuZ2luZyBmcm9tIHRoaW5ncyBsaWtlIHNsZWVwaW5nLCBjb2xsaXNpb25TaGFwZVRoaWNrbmVzcyBhbmQgb3RoZXJzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldHRpbmdzOiBQaHlzaWNzU2V0dGluZ3MgPSBuZXcgUGh5c2ljc1NldHRpbmdzKENPTExJU0lPTl9HUk9VUC5ERUZBVUxULCAoQ09MTElTSU9OX0dST1VQLkRFRkFVTFQgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfMSB8IENPTExJU0lPTl9HUk9VUC5HUk9VUF8yIHwgQ09MTElTSU9OX0dST1VQLkdST1VQXzMgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfNCkpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJhY3RpdmU6IFBoeXNpY3MgPSBuZXcgUGh5c2ljcygpO1xyXG5cclxuICAgIC8qKiBUaGUgcmVuZGVyaW5nIG9mIHBoeXNpY2FsIGRlYnVnIGluZm9ybWF0aW9ucy4gVXNlZCBpbnRlcm5hbGx5IG5vIGludGVyYWN0aW9uIG5lZWRlZC4qL1xyXG4gICAgI2RlYnVnRHJhdzogUGh5c2ljc0RlYnVnRHJhdztcclxuICAgIC8qKiBUaGUgY2FtZXJhL3ZpZXdwb3J0IHRoZSBwaHlzaWNzIGFyZSBkZWJ1Z2dlZCB0by4gVXNlZCBpbnRlcm5hbGx5IG5vIGludGVyYWN0aW9uIG5lZWRlZC4gKi9cclxuICAgICNtYWluQ2FtOiBDb21wb25lbnRDYW1lcmE7XHJcblxyXG4gICAgcHJpdmF0ZSBvaW1vV29ybGQ6IE9JTU8uV29ybGQ7XHJcbiAgICBwcml2YXRlIGJvZHlMaXN0OiBDb21wb25lbnRSaWdpZGJvZHlbXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgcHJpdmF0ZSBqb2ludExpc3Q6IEpvaW50W10gPSBuZXcgQXJyYXkoKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgT0lNTyA9PSBcInVuZGVmaW5lZFwiKSB7Ly8gQ2hlY2sgaWYgT0lNTyBOYW1lc3BhY2Ugd2FzIGxvYWRlZCwgZWxzZSBkbyBub3QgdXNlIGFueSBwaHlzaWNzLiBDaGVjayBpcyBuZWVkZWQgdG8gZW5zdXJlIEZVREdFIGNhbiBiZSB1c2VkIHdpdGhvdXQgUGh5c2ljc1xyXG4gICAgICAgIERlYnVnLmVycm9yKFwiT0lNTyBwaHlzaWNzIGVuZ2luZSBub3QgY29ubmVjdGVkIVwiKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZCA9IG5ldyBPSU1PLldvcmxkKCk7XHJcbiAgICAgIHRoaXMuI2RlYnVnRHJhdyA9IG5ldyBQaHlzaWNzRGVidWdEcmF3KCk7ICAvL0NyZWF0ZSBhIEZ1ZGdlIFBoeXNpY3MgZGVidWdnaW5nIGhhbmRsaW5nIG9iamVjdFxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZC5zZXREZWJ1Z0RyYXcodGhpcy4jZGVidWdEcmF3Lm9pbW9EZWJ1Z0RyYXcpOyAvL1RlbGwgT2ltb1BoeXNpY3Mgd2hlcmUgdG8gZGVidWcgdG8gYW5kIGhvdyBpdCB3aWxsIGJlIGhhbmRsZWRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjdXJyZW50bHkgYWN0aXZlIFBoeXNpY3MgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXQgYWN0aXZlSW5zdGFuY2UoX3BoeXNpY3M6IFBoeXNpY3MpIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZSA9IF9waHlzaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgUGh5c2ljcyBpbnN0YW5jZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgYWN0aXZlSW5zdGFuY2UoKTogUGh5c2ljcyB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGRlYnVnRHJhdygpOiBQaHlzaWNzRGVidWdEcmF3IHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IG1haW5DYW0oKTogQ29tcG9uZW50Q2FtZXJhIHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI21haW5DYW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhc3QgYSBSQVkgaW50byB0aGUgcGh5c2ljYWwgd29ybGQgZnJvbSBhIG9yaWdpbiBwb2ludCBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBSZWNlaXZpbmcgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBoaXQgb2JqZWN0IGFuZCB0aGVcclxuICAgICogaGl0IHBvaW50LiBEbyBub3Qgc3BlY2lmeSBhIF9ncm91cCB0byByYXljYXN0IHRoZSB3aG9sZSB3b3JsZCwgZWxzZSBvbmx5IGJvZGllcyB3aXRoaW4gdGhlIHNwZWNpZmljIGdyb3VwIGNhbiBiZSBoaXQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByYXljYXN0KF9vcmlnaW46IFZlY3RvcjMsIF9kaXJlY3Rpb246IFZlY3RvcjMsIF9sZW5ndGg6IG51bWJlciA9IDEsIF9kZWJ1Z0RyYXc6IGJvb2xlYW4gPSBmYWxzZSwgX2dyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVCk6IFJheUhpdEluZm8ge1xyXG4gICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IG5ldyBSYXlIaXRJbmZvKCk7XHJcbiAgICAgIGxldCByYXk6IE9JTU8uUmF5Q2FzdENsb3Nlc3QgPSBuZXcgT0lNTy5SYXlDYXN0Q2xvc2VzdCgpO1xyXG4gICAgICBsZXQgYmVnaW46IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueik7XHJcbiAgICAgIGxldCBlbmQ6IE9JTU8uVmVjMyA9IHRoaXMuZ2V0UmF5RW5kUG9pbnQoYmVnaW4sIG5ldyBWZWN0b3IzKF9kaXJlY3Rpb24ueCwgX2RpcmVjdGlvbi55LCBfZGlyZWN0aW9uLnopLCBfbGVuZ3RoKTtcclxuICAgICAgcmF5LmNsZWFyKCk7XHJcbiAgICAgIGlmIChfZ3JvdXAgPT0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQpIHsgLy9DYXNlIDE6IFJheWNhc3RpbmcgdGhlIHdob2xlIHdvcmxkLCBub3JtYWwgbW9kZVxyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnJheUNhc3QoYmVnaW4sIGVuZCwgcmF5KTtcclxuICAgICAgfSBlbHNlIHsgLy9DYXNlMjogUmF5Y2FzdGluZyBvbiBlYWNoIGJvZHkgaW4gYSBzcGVjaWZpYyBncm91cFxyXG4gICAgICAgIGxldCBhbGxIaXRzOiBSYXlIaXRJbmZvW10gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkIHtcclxuICAgICAgICAgIGlmICh2YWx1ZS5jb2xsaXNpb25Hcm91cCA9PSBfZ3JvdXApIHtcclxuICAgICAgICAgICAgaGl0SW5mbyA9IHZhbHVlLnJheWNhc3RUaGlzQm9keShfb3JpZ2luLCBfZGlyZWN0aW9uLCBfbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKGhpdEluZm8uaGl0ID09IHRydWUpIHsgLy9FdmVyeSBoaXQgaXMgY291bGQgcG90ZW50aWFsbHkgYmUgdGhlIGNsb3Nlc3RcclxuICAgICAgICAgICAgICBhbGxIaXRzLnB1c2goaGl0SW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhbGxIaXRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlOiBSYXlIaXRJbmZvKTogdm9pZCB7IC8vZ2V0IHRoZSBjbG9zZXN0IGhpdEluZm9cclxuICAgICAgICAgIGlmICh2YWx1ZS5oaXREaXN0YW5jZSA8IGhpdEluZm8uaGl0RGlzdGFuY2UgfHwgaGl0SW5mby5oaXQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaGl0SW5mbyA9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyYXkuaGl0KSB7IC8vRmlsbCBpbiBpbmZvcm1hdGlvbnMgb24gdGhlIGhpdFxyXG4gICAgICAgIGhpdEluZm8uaGl0ID0gdHJ1ZTtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMocmF5LnBvc2l0aW9uLngsIHJheS5wb3NpdGlvbi55LCByYXkucG9zaXRpb24ueik7XHJcbiAgICAgICAgaGl0SW5mby5oaXROb3JtYWwgPSBuZXcgVmVjdG9yMyhyYXkubm9ybWFsLngsIHJheS5ub3JtYWwueSwgcmF5Lm5vcm1hbC56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdERpc3RhbmNlID0gdGhpcy5nZXRSYXlEaXN0YW5jZShfb3JpZ2luLCBoaXRJbmZvLmhpdFBvaW50KTtcclxuICAgICAgICBoaXRJbmZvLnJpZ2lkYm9keUNvbXBvbmVudCA9IHJheS5zaGFwZS51c2VyRGF0YTtcclxuICAgICAgICBoaXRJbmZvLnJheUVuZCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoaXRJbmZvLnJheU9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgICAgaGl0SW5mby5oaXRQb2ludCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfZGVidWdEcmF3KSB7IC8vSGFuZGxlIGRlYnVnZ2luZ1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdy5kZWJ1Z1JheShoaXRJbmZvLnJheU9yaWdpbiwgaGl0SW5mby5oaXRQb2ludCwgbmV3IENvbG9yKDAsIDEsIDAsIDEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGl0SW5mbztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNpbXVsYXRlcyB0aGUgcGh5c2ljYWwgd29ybGQuIF9kZWx0YVRpbWUgaXMgdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gcGh5c2ljYWwgc3RlcHMsIGRlZmF1bHQgaXMgNjAgZnJhbWVzIHBlciBzZWNvbmQgfjE3bXMuXHJcbiAgICAqIEEgZnJhbWUgdGltaW5nIGNhbid0IGJlIHNtYWxsZXIgdGhhbiAxLzMwIG9mIGEgc2Vjb25kLCBvciBlbHNlIGl0IHdpbGwgYmUgc2V0IHRvIDMwIGZyYW1lcywgdG8gaGF2ZSBtb3JlIGNvbnNpc3RlbnQgZnJhbWUgY2FsY3VsYXRpb25zLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2ltdWxhdGUoX2RlbHRhVGltZTogbnVtYmVyID0gMSAvIDYwKTogdm9pZCB7XHJcbiAgICAgIGlmIChQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgIFBoeXNpY3MuY29ubmVjdEpvaW50cygpOyAvL0Nvbm5lY3Qgam9pbnRzIGlmIGFueXRoaW5nIGhhcyBoYXBwZW5lZCBiZXR3ZWVuIHRoZSBsYXN0IGNhbGwgdG8gYW55IG9mIHRoZSB0d28gcGFpcmVkIHJpZ2lkYm9kaWVzXHJcbiAgICAgIGlmIChUaW1lLmdhbWUuZ2V0U2NhbGUoKSAhPSAwKSB7IC8vSWYgdGltZSBpcyBzdG9wcGVkIGRvIG5vdCBzaW11bGF0ZSB0byBhdm9pZCBtaXNiZWhhdmlvdXJcclxuICAgICAgICBfZGVsdGFUaW1lID0gX2RlbHRhVGltZSA+IDEgLyAzMCA/IDEgLyAzMCA6IF9kZWx0YVRpbWU7IC8vSWYgaW5zdGVhZCBvZiBhIGZpeGVkIHJhdGUgdGhlIGdhbWUgZnJhbWVyYXRlIGlzIHVzZWQsIG1ha2Ugc3VyZSBpcnJlZ3VsYXIgdGltaW5ncyBhcmUgZml4ZWQgdG8gMzBmcHNcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5zdGVwKF9kZWx0YVRpbWUgKiBUaW1lLmdhbWUuZ2V0U2NhbGUoKSk7ICAvL1VwZGF0ZSB0aGUgc2ltdWxhdGlvbiBieSB0aGUgZ2l2ZW4gZGVsdGFUaW1lIGFuZCB0aGUgRnVkZ2UgaW50ZXJuYWwgVGltZVNjYWxlXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UgdXNpbmcgdGhlIHtAbGluayBDb21wb25lbnRDYW1lcmF9IGdpdmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9tb2RlPzogUEhZU0lDU19ERUJVR01PREUpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3LnNldERlYnVnTW9kZShfbW9kZSk7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI21haW5DYW0gPSBfY21wQ2FtZXJhO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5kZWJ1Z0RyYXcoKTsgLy9GaWxsaW5nIHRoZSBwaHlzaWNzIHdvcmxkIGRlYnVnIGluZm9ybWF0aW9ucyBpbnRvIHRoZSBkZWJ1ZyByZW5kZXJpbmcgaGFuZGxlclxyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLiNkZWJ1Z0RyYXcuZHJhd0J1ZmZlcnMoKTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3LmNsZWFyQnVmZmVycygpOyAgLy9VcGRhdGVzIGluZm8gYWJvdXQgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiwgcmVzZXR0aW5nIHRoZSBwb2ludHMvbGluZXMvdHJpYW5nbGVzIHRoYXQgbmVlZCB0byBiZSBkcmF3biBmcm9tIGRlYnVnXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQWRqdXN0cyB0aGUgdHJhbnNmb3JtcyBvZiB0aGUge0BsaW5rIENvbXBvbmVudFJpZ2lkYm9keX1zIGluIHRoZSBnaXZlbiBicmFuY2ggdG8gbWF0Y2ggdGhlaXIgbm9kZXMgb3IgbWVzaGVzXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkanVzdFRyYW5zZm9ybXMoX2JyYW5jaDogTm9kZSwgX3RvTWVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlci5wcmVwYXJlKF9icmFuY2gsIHsgaWdub3JlUGh5c2ljczogdHJ1ZSB9KTtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBSZW5kZXIubm9kZXNQaHlzaWNzKVxyXG4gICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSkuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGFwcGxpZWQgZ3Jhdml0YXRpb25hbCBmb3JjZSBvZiB0aGUgYWN0aXZlIGluc3RhbmNlLiBEZWZhdWx0IGVhcnRoIGdyYXZpdHkgPSA5LjgxIG0vc1xyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0R3Jhdml0eSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHRtcFZlYzogT0lNTy5WZWMzID0gUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQuZ2V0R3Jhdml0eSgpO1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModG1wVmVjLngsIHRtcFZlYy55LCB0bXBWZWMueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldCB0aGUgYXBwbGllZCBncmF2aXRhdGlvbmFsIGZvcmNlIG9mIHRoZSBhY3RpdmUgaW5zdGFuY2UuIERlZmF1bHQgZWFydGggZ3Jhdml0eSA9IDkuODEgbS9zXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRHcmF2aXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgdG1wVmVjOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5zZXRHcmF2aXR5KHRtcFZlYyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFkZCBhIG5ldyBPSU1PIFJpZ2lkYm9keSB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiBhZGRpbmcgYSBGVURHRSBSaWdpZGJvZHkgQ29tcG9uZW50LlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkUmlnaWRib2R5KF9jbXBSQjogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QucHVzaChfY21wUkIpO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5hZGRSaWdpZEJvZHkoX2NtcFJCLmdldE9pbW9SaWdpZGJvZHkoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZSB0aGUgT0lNTyBSaWdpZGJvZHkgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZSwgaGFwcGVucyBhdXRvbWF0aWNhbGx5IHdoZW4gcmVtb3ZpbmcgYSBGVURHRSBSaWdpZGJvZHkgQ29tcG9uZW50XHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVSaWdpZGJvZHkoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogdHdvIGxpc3RzIGFyZSBiZWluZyBtYW5hZ2VkLCBpbmZvIG1pZ2h0IGRldmlhdGUuIENsZWFudXAhXHJcbiAgICAgIGxldCBvaW1vUmlnaWRCb2R5OiBPSU1PLlJpZ2lkQm9keSA9IF9jbXBSQi5nZXRPaW1vUmlnaWRib2R5KCk7XHJcbiAgICAgIGlmIChvaW1vUmlnaWRCb2R5Ll93b3JsZClcclxuICAgICAgICBvaW1vUmlnaWRCb2R5Ll93b3JsZC5yZW1vdmVSaWdpZEJvZHkob2ltb1JpZ2lkQm9keSk7XHJcbiAgICAgIC8vIHdoYXQgaWYgdGhlIHJpZ2lkYm9keXMgb2ltby13b3JsZCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZT9cclxuICAgICAgbGV0IGlkOiBudW1iZXIgPSBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmluZGV4T2YoX2NtcFJCKTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5zcGxpY2UoaWQsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBZGQgYSBuZXcgT0lNTyBKb2ludC9Db25zdHJhaW50IHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UsIGhhcHBlbnMgYXV0b21hdGljYWxseSB3aGVuIGFkZGluZyBhIEZVREdFIEpvaW50IENvbXBvbmVudFxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkSm9pbnQoX2NtcEpvaW50OiBKb2ludCk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5hZGRKb2ludChfY21wSm9pbnQuZ2V0T2ltb0pvaW50KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDYWxsZWQgaW50ZXJuYWxseSB0byBpbmZvcm0gdGhlIHBoeXNpY3Mgc3lzdGVtIHRoYXQgYSBqb2ludCBoYXMgYSBjaGFuZ2Ugb2YgY29yZSBwcm9wZXJ0aWVzIGFuZCBuZWVkcyB0byBiZSByZWNyZWF0ZWQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjaGFuZ2VKb2ludFN0YXR1cyhfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIGlmIChQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5pbmRleE9mKF9jbXBKb2ludCkgPCAwKVxyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0LnB1c2goX2NtcEpvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBSZW1vdmUgdGhlIE9JTU8gSm9pbnQvQ29uc3RyYWludCB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiByZW1vdmluZyBhIEZVREdFIEpvaW50IENvbXBvbmVudFxyXG4gICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVKb2ludChfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQucmVtb3ZlSm9pbnQoX2NtcEpvaW50LmdldE9pbW9Kb2ludCgpKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yOiB1bmtub3duKSB7XHJcbiAgICAgICAgRGVidWcuZnVkZ2UoX2Vycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGFsbCB0aGUgQ29tcG9uZW50UmlnaWRib2RpZXMgdGhhdCBhcmUga25vd24gdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZS4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Qm9keUxpc3QoKTogQ29tcG9uZW50UmlnaWRib2R5W10ge1xyXG4gICAgICByZXR1cm4gUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2l2aW5nIGEgQ29tcG9uZW50UmlnaWRib2R5IGEgc3BlY2lmaWMgaWRlbnRpZmljYXRpb24gbnVtYmVyIHNvIGl0IGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBsb2FkaW5nIHByb2Nlc3MuIEFuZCByZW1vdmVkIHJiJ3MgY2FuIHJlY2VpdmUgYSBuZXcgaWQuICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRpc3RyaWJ1dGVCb2R5SUQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGZyZWVJZDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGZyZWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5mb3JFYWNoKChfdmFsdWU6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChfdmFsdWUuaWQgIT0gZnJlZUlkKSB7XHJcbiAgICAgICAgICBmcmVlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZnJlZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZyZWUpIHtcclxuICAgICAgICAgIGZyZWVJZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZnJlZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIENvbm5lY3QgYWxsIGpvaW50cyB0aGF0IGFyZSBub3QgY29ubmVjdGVkIHlldC4gVXNlZCBpbnRlcm5hbGx5IG5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgY2FsbGVkIGFuZCBuZWVkZWQgdG8gbWFrZSBzdXJlIGpvaW50cyBjb25uZWN0L2Rpc2Nvbm5lY3RcclxuICAgICAqIGlmIGFueSBvZiB0aGUgdHdvIHBhaXJlZCBDb21wb25lbnRSaWdpZGJvZGllcyBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY29ubmVjdEpvaW50cygpOiB2b2lkIHsgLy9UcnkgdG8gY29ubmVjdCBkaXJ0eSBqb2ludHMgdW50aWwgdGhleSBhcmUgY29ubmVjdGVkXHJcbiAgICAgIGxldCBqb2ludHNUb0Nvbm5lY3Q6IEpvaW50W10gPSBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdDtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5qb2ludExpc3QgPSBbXTtcclxuICAgICAgam9pbnRzVG9Db25uZWN0LmZvckVhY2goKF9qb2ludDogSm9pbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoX2pvaW50LmlzQ29ubmVjdGVkKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgICBpZiAoX2pvaW50LmlzQWN0aXZlKVxyXG4gICAgICAgICAgICBfam9pbnQuY29ubmVjdCgpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5wdXNoKF9qb2ludCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZW1vdmUgYWxsIG9pbW8gam9pbnRzIGFuZCByaWdpZGJvZGllcywgc28gdGhhdCB0aGV5IGNhbiBiZSByZXVzZWQgaW4gYW5vdGhlciB3b3JsZCAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYW51cCgpOiB2b2lkIHtcclxuICAgICAgbGV0IG9pbW9Xb3JsZDogT0lNTy5Xb3JsZCA9IFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkO1xyXG4gICAgICBpZiAob2ltb1dvcmxkICE9IG51bGwpIHtcclxuICAgICAgICAvL1Jlc2V0dGluZyB0aGUgd29ybGQgc28gYSBuZXcgd29ybGQgY2FuIGJlIGNyZWF0ZWQsIGZpeCBmb3IgcmUtb3BlbmluZyBhIHByb2plY3QgaW4gZWRpdG9yLCBtYWtpbmcgc3VyZSB0aGVyZSBhcmUgbm8gb2xkIHRoaW5ncyBjYWxjdWxhdGVkXHJcbiAgICAgICAgbGV0IGpvaW50c1dvcmxkOiBudW1iZXIgPSBvaW1vV29ybGQuZ2V0TnVtSm9pbnRzKCk7XHJcbiAgICAgICAgbGV0IGJvZGllc1dvcmxkOiBudW1iZXIgPSBvaW1vV29ybGQuZ2V0TnVtUmlnaWRCb2RpZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBib2R5IG9mIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QpXHJcbiAgICAgICAgICBib2R5LmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdCA9IG5ldyBBcnJheSgpOyAvLyBUT0RPOiBzZWUgaWYgaXQgd291bGQgYmUgc21hcnRlciwgZG8gdXNlIHRoZXNlIGFycmF5cy4gRGVmaW5pdGVseSBtb3JlIGludHVpdGl2ZS4uLlxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBqb2ludHNXb3JsZDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgb2ltb0pvaW50OiBPSU1PLkpvaW50ID0gUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQuZ2V0Sm9pbnRMaXN0KCk7XHJcbiAgICAgICAgICBvaW1vV29ybGQucmVtb3ZlSm9pbnQob2ltb0pvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGJvZGllc1dvcmxkOyBpKyspIHtcclxuICAgICAgICAgIGxldCBvaW1vQm9keTogT0lNTy5SaWdpZEJvZHkgPSBvaW1vV29ybGQuZ2V0UmlnaWRCb2R5TGlzdCgpO1xyXG4gICAgICAgICAgb2ltb1dvcmxkLnJlbW92ZVJpZ2lkQm9keShvaW1vQm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLyoqIFJldHVybnMgdGhlIENvbXBvbmVudFJpZ2lkYm9keSB3aXRoIHRoZSBnaXZlbiBpZC4gVXNlZCBpbnRlcm5hbGx5IHRvIHJlY29ubmVjdCBqb2ludHMgb24gbG9hZGluZyBpbiB0aGUgZWRpdG9yLiAqL1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZ2V0Qm9keUJ5SUQoX2lkOiBudW1iZXIpOiBDb21wb25lbnRSaWdpZGJvZHkge1xyXG4gICAgLy8gICBsZXQgYm9keTogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbDtcclxuICAgIC8vICAgUGh5c2ljcy4jYWN0aXZlUGh5c2ljcy5ib2R5TGlzdC5mb3JFYWNoKCh2YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCA9PiB7XHJcbiAgICAvLyAgICAgaWYgKHZhbHVlLmlkID09IF9pZCkge1xyXG4gICAgLy8gICAgICAgYm9keSA9IHZhbHVlO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgfSk7XHJcbiAgICAvLyAgIHJldHVybiBib2R5O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGVuZHBvaW50IG9mIG1hdGhlbWF0aWNhbCByYXkuIEJ5IGFkZGluZyB0aGUgbXVsdGlwbGllZCBkaXJlY3Rpb24gdG8gdGhlIG9yaWdpbi4gXHJcbiAgICAgICAqIFVzZWQgYmVjYXVzZSBPaW1vUGh5c2ljcyBkZWZpbmVzIHJheSBieSBzdGFydC9lbmQuIEJ1dCBHYW1lRW5naW5lcyBjb21tb25seSB1c2Ugb3JpZ2luL2RpcmVjdGlvbi5cclxuICAgICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRSYXlFbmRQb2ludChzdGFydDogT0lNTy5WZWMzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGxlbmd0aDogbnVtYmVyKTogT0lNTy5WZWMzIHtcclxuICAgICAgbGV0IG9yaWdpbjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgb3JpZ2luLnNldChzdGFydC54LCBzdGFydC55LCBzdGFydC56KTtcclxuICAgICAgbGV0IHNjYWxlZERpcmVjdGlvbjogVmVjdG9yMyA9IGRpcmVjdGlvbi5jbG9uZTtcclxuICAgICAgc2NhbGVkRGlyZWN0aW9uLnNjYWxlKGxlbmd0aCk7XHJcbiAgICAgIGxldCBlbmRwb2ludDogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKHNjYWxlZERpcmVjdGlvbiwgb3JpZ2luKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoc2NhbGVkRGlyZWN0aW9uKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZW5kcG9pbnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShvcmlnaW4pO1xyXG4gICAgICByZXR1cm4gbmV3IE9JTU8uVmVjMyhlbmRwb2ludC54LCBlbmRwb2ludC55LCBlbmRwb2ludC56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2V0IHRoZSBkaXN0YW5jZSBpbiB3aGljaCBhIHJheSBoaXQgYnkgc3VidHJhY3RpbmcgcG9pbnRzIGZyb20gZWFjaCBvdGhlciBhbmQgZ2V0IHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgc3F1YXJlZCBwcm9kdWN0IG9mIGVhY2ggY29tcG9uZW50LiAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0UmF5RGlzdGFuY2Uob3JpZ2luOiBWZWN0b3IzLCBoaXRQb2ludDogVmVjdG9yMyk6IG51bWJlciB7XHJcbiAgICAgIGxldCBkeDogbnVtYmVyID0gb3JpZ2luLnggLSBoaXRQb2ludC54O1xyXG4gICAgICBsZXQgZHk6IG51bWJlciA9IG9yaWdpbi55IC0gaGl0UG9pbnQueTtcclxuICAgICAgbGV0IGR6OiBudW1iZXIgPSBvcmlnaW4ueiAtIGhpdFBvaW50Lno7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gLyoqIFJldHVybnMgdGhlIGFjdHVhbCB1c2VkIHdvcmxkIG9mIHRoZSBPSU1PIHBoeXNpY3MgZW5naW5lLiBObyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZCAtIE9ubHkgZm9yIGFkdmFuY2VkIHVzZXJzIHRoYXQgbmVlZCB0byBhY2Nlc3MgaXQgZGlyZWN0bHkgKi9cclxuICAgIHB1YmxpYyBnZXRPaW1vV29ybGQoKTogT0lNTy5Xb3JsZCB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAvKiogVXBkYXRlcyBhbGwge0BsaW5rIFJpZ2lkYm9kaWVzfSBrbm93biB0byB0aGUgUGh5c2ljcy53b3JsZCB0byBtYXRjaCB0aGVpciBjb250YWluZXJzIG9yIG1lc2hlcyB0cmFuc2Zvcm1hdGlvbnMgKi9cclxuICAgIC8vIHByaXZhdGUgdXBkYXRlV29ybGRGcm9tV29ybGRNYXRyaXgoX3RvTWVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAvLyAgIGZvciAobGV0IGJvZHkgb2YgdGhpcy5ib2R5TGlzdClcclxuICAgIC8vICAgICBib2R5LnVwZGF0ZUZyb21Xb3JsZChfdG9NZXNoKTtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICogU3RvcmluZyBhbmQgbWFuaXB1bGF0aW5nIHJvdGF0aW9ucyBpbiB0aGUgZm9ybSBvZiBxdWF0ZXJuaW9ucy5cclxuICAgICogQ29uc3RydWN0ZWQgb3V0IG9mIHRoZSA0IGNvbXBvbmVudHMgeCx5LHosdy4gQ29tbW9ubHkgdXNlZCB0byBjYWxjdWxhdGUgcm90YXRpb25zIGluIHBoeXNpY3MgZW5naW5lcy5cclxuICAgICogQ2xhc3MgbW9zdGx5IHVzZWQgaW50ZXJuYWxseSB0byBicmlkZ2UgdGhlIGluIEZVREdFIGNvbW1vbmx5IHVzZWQgYW5nbGVzIGluIGRlZ3JlZSB0byBPaW1vUGh5c2ljcyBxdWF0ZXJuaW9uIHN5c3RlbS5cclxuICAgICogQGF1dGhvcnMgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwXHJcbiAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBRdWF0ZXJuaW9uIGV4dGVuZHMgTXV0YWJsZSB7XHJcbiAgICBwcml2YXRlIHg6IG51bWJlcjtcclxuICAgIHByaXZhdGUgeTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB6OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHc6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCwgX3c6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy54ID0gX3g7XHJcbiAgICAgIHRoaXMueSA9IF95O1xyXG4gICAgICB0aGlzLnogPSBfejtcclxuICAgICAgdGhpcy53ID0gX3c7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldC9TZXQgdGhlIFggY29tcG9uZW50IG9mIHRoZSBRdWF0ZXJuaW9uLiBSZWFsIFBhcnQgKi9cclxuICAgIGdldCBYKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICB9XHJcbiAgICBzZXQgWChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMueCA9IF94O1xyXG4gICAgfVxyXG4gICAgLyoqIEdldC9TZXQgdGhlIFkgY29tcG9uZW50IG9mIHRoZSBRdWF0ZXJuaW9uLiBSZWFsIFBhcnQgKi9cclxuICAgIGdldCBZKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnk7XHJcbiAgICB9XHJcbiAgICBzZXQgWShfeTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMueSA9IF95O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQvU2V0IHRoZSBaIGNvbXBvbmVudCBvZiB0aGUgUXVhdGVybmlvbi4gUmVhbCBQYXJ0ICovXHJcbiAgICBnZXQgWigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy56O1xyXG4gICAgfVxyXG4gICAgc2V0IFooX3o6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnogPSBfejtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0L1NldCB0aGUgWSBjb21wb25lbnQgb2YgdGhlIFF1YXRlcm5pb24uIEltYWdpbmFyeSBQYXJ0ICovXHJcbiAgICBnZXQgVygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy53O1xyXG4gICAgfVxyXG4gICAgc2V0IFcoX3c6IG51bWJlcikge1xyXG4gICAgICB0aGlzLncgPSBfdztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBxdWF0ZXJuaW9uIGZyb20gdmVjdG9yMyBhbmdsZXMgaW4gZGVncmVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRGcm9tVmVjdG9yMyhyb2xsWDogbnVtYmVyLCBwaXRjaFk6IG51bWJlciwgeWF3WjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBjeTogbnVtYmVyID0gTWF0aC5jb3MoeWF3WiAqIDAuNSk7XHJcbiAgICAgIGxldCBzeTogbnVtYmVyID0gTWF0aC5zaW4oeWF3WiAqIDAuNSk7XHJcbiAgICAgIGxldCBjcDogbnVtYmVyID0gTWF0aC5jb3MocGl0Y2hZICogMC41KTtcclxuICAgICAgbGV0IHNwOiBudW1iZXIgPSBNYXRoLnNpbihwaXRjaFkgKiAwLjUpO1xyXG4gICAgICBsZXQgY3I6IG51bWJlciA9IE1hdGguY29zKHJvbGxYICogMC41KTtcclxuICAgICAgbGV0IHNyOiBudW1iZXIgPSBNYXRoLnNpbihyb2xsWCAqIDAuNSk7XHJcblxyXG4gICAgICB0aGlzLncgPSBjciAqIGNwICogY3kgKyBzciAqIHNwICogc3k7XHJcbiAgICAgIHRoaXMueCA9IHNyICogY3AgKiBjeSAtIGNyICogc3AgKiBzeTtcclxuICAgICAgdGhpcy55ID0gY3IgKiBzcCAqIGN5ICsgc3IgKiBjcCAqIHN5O1xyXG4gICAgICB0aGlzLnogPSBjciAqIGNwICogc3kgLSBzciAqIHNwICogY3k7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBldWxlciBhbmdsZXMgaW4gcmFkaWFucyBhcyBWZWN0b3IzIGZyb20gdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9FdWxlcmFuZ2xlcygpOiBWZWN0b3IzIHsgLy9TaW5ndWxhcml0aWVzIHBvc3NpYmxlXHJcbiAgICAgIGxldCBhbmdsZXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuICAgICAgLy8gcm9sbCAoeC1heGlzIHJvdGF0aW9uKVxyXG4gICAgICBsZXQgc2lucmNvc3A6IG51bWJlciA9IDIgKiAodGhpcy53ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy56KTtcclxuICAgICAgbGV0IGNvc3Jjb3NwOiBudW1iZXIgPSAxIC0gMiAqICh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xyXG4gICAgICBhbmdsZXMueCA9IE1hdGguYXRhbjIoc2lucmNvc3AsIGNvc3Jjb3NwKTtcclxuXHJcbiAgICAgIC8vIHBpdGNoICh5LWF4aXMgcm90YXRpb24pXHJcbiAgICAgIGxldCBzaW5wOiBudW1iZXIgPSAyICogKHRoaXMudyAqIHRoaXMueSAtIHRoaXMueiAqIHRoaXMueCk7XHJcbiAgICAgIGlmIChNYXRoLmFicyhzaW5wKSA+PSAxKVxyXG4gICAgICAgIGFuZ2xlcy55ID0gdGhpcy5jb3B5c2lnbihNYXRoLlBJIC8gMiwgc2lucCk7IC8vIHVzZSA5MCBkZWdyZWVzIGlmIG91dCBvZiByYW5nZVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgYW5nbGVzLnkgPSBNYXRoLmFzaW4oc2lucCk7XHJcblxyXG4gICAgICAvLyB5YXcgKHotYXhpcyByb3RhdGlvbilcclxuICAgICAgbGV0IHNpbnljb3NwOiBudW1iZXIgPSAyICogKHRoaXMudyAqIHRoaXMueiArIHRoaXMueCAqIHRoaXMueSk7XHJcbiAgICAgIGxldCBjb3N5Y29zcDogbnVtYmVyID0gMSAtIDIgKiAodGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56KTtcclxuICAgICAgYW5nbGVzLnogPSBNYXRoLmF0YW4yKHNpbnljb3NwLCBjb3N5Y29zcCk7XHJcblxyXG4gICAgICByZXR1cm4gYW5nbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuZ2xlcyBpbiBkZWdyZWVzIGFzIHZlY3RvcjMgZnJvbSB0aGlzLiBxdWF0ZXJpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvRGVncmVlcygpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGFuZ2xlczogVmVjdG9yMyA9IHRoaXMudG9FdWxlcmFuZ2xlcygpO1xyXG4gICAgICBhbmdsZXMueCA9IGFuZ2xlcy54ICogKDE4MCAvIE1hdGguUEkpO1xyXG4gICAgICBhbmdsZXMueSA9IGFuZ2xlcy55ICogKDE4MCAvIE1hdGguUEkpO1xyXG4gICAgICBhbmdsZXMueiA9IGFuZ2xlcy56ICogKDE4MCAvIE1hdGguUEkpO1xyXG4gICAgICByZXR1cm4gYW5nbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLngsIHk6IHRoaXMueSwgejogdGhpcy56LCB3OiB0aGlzLndcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcblxyXG4gICAgLyoqIENvcHlpbmcgdGhlIHNpZ24gb2YgYSB0byBiICovXHJcbiAgICBwcml2YXRlIGNvcHlzaWduKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIGIgPCAwID8gLU1hdGguYWJzKGEpIDogTWF0aC5hYnMoYSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIHRocmVlZGltZW5zaW9uYWwgYm94IGJ5IHR3byBjb3JuZXItcG9pbnRzLCBvbmUgd2l0aCBtaW5pbWFsIHZhbHVlcyBhbmQgb25lIHdpdGggbWF4aW11bSB2YWx1ZXNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQm94IGltcGxlbWVudHMgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyBtaW46IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgbWF4OiBWZWN0b3IzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9taW46IFZlY3RvcjMgPSBWZWN0b3IzLk9ORShJbmZpbml0eSksIF9tYXg6IFZlY3RvcjMgPSBWZWN0b3IzLk9ORSgtSW5maW5pdHkpKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9taW4sIF9tYXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjb3JuZXJzIG9mIHRoaXMgYm94LCBzdGFuZGFyZCB2YWx1ZXMgYXJlIEluZmluaXR5IGZvciBtaW4sIGFuZCAtSW5maW5pdHkgZm9yIG1heCwgXHJcbiAgICAgKiBjcmVhdGluZyBhbiBpbXBvc3NpYmxlIGludmVydGVkIGJveCB0aGF0IGNhbiBub3QgY29udGFpbiBhbnkgcG9pbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX21pbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKEluZmluaXR5KSwgX21heDogVmVjdG9yMyA9IFZlY3RvcjMuT05FKC1JbmZpbml0eSkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5taW4gPSBfbWluO1xyXG4gICAgICB0aGlzLm1heCA9IF9tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmQgdGhlIGJveCBpZiBuZWNlc3NhcnkgdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4cGFuZChfaW5jbHVkZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1pbi5taW4oX2luY2x1ZGUpO1xyXG4gICAgICB0aGlzLm1heC5tYXgoX2luY2x1ZGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5taW4uc2V0KEluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHkpO1xyXG4gICAgICB0aGlzLm1heC5zZXQoLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IHtAbGluayBSZW5kZXJ9LXBpY2tpbmcgZS5nLiB1c2luZyB7QGxpbmsgUGlja2VyfSBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZnVydGhlciBjYWxjdWxhdGlvbiBvZiBwb3NpdGlvbnMgYW5kIG5vcm1hbHMgZXRjLlxyXG4gICAqIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBpY2sge1xyXG4gICAgcHVibGljIG5vZGU6IE5vZGU7XHJcbiAgICBwdWJsaWMgekJ1ZmZlcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGNvbG9yOiBDb2xvcjtcclxuICAgIHB1YmxpYyB0ZXh0dXJlVVY6IFZlY3RvcjI7XHJcbiAgICAjbXR4Vmlld1RvV29ybGQ6IE1hdHJpeDR4NDtcclxuICAgICNwb3NXb3JsZDogVmVjdG9yMztcclxuICAgICNwb3NNZXNoOiBWZWN0b3IzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9ub2RlOiBOb2RlKSB7XHJcbiAgICAgIHRoaXMubm9kZSA9IF9ub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzb3IgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSB3b3JsZCBwb3NpdGlvbiBvZiBpbnRlcnNlY3Rpb24gb2Yge0BsaW5rIFJheX0gYW5kIHtAbGluayBNZXNofSBvbmx5IHdoZW4gdXNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBwb3NXb3JsZCgpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKHRoaXMuI3Bvc1dvcmxkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNwb3NXb3JsZDtcclxuICAgICAgbGV0IHBvaW50SW5DbGlwU3BhY2U6IFZlY3RvcjMgPSBWZWN0b3IzLloodGhpcy56QnVmZmVyKTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuI210eFZpZXdUb1dvcmxkLmdldCgpO1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihwb2ludEluQ2xpcFNwYWNlLCB0aGlzLiNtdHhWaWV3VG9Xb3JsZCwgdHJ1ZSk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogcG9pbnRJbkNsaXBTcGFjZS54ICsgbVs3XSAqIHBvaW50SW5DbGlwU3BhY2UueSArIG1bMTFdICogcG9pbnRJbkNsaXBTcGFjZS56ICsgbVsxNV07XHJcbiAgICAgIHJlc3VsdC5zY2FsZSgxIC8gdyk7XHJcblxyXG4gICAgICB0aGlzLiNwb3NXb3JsZCA9IHJlc3VsdDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjY2Vzc29yIHRvIGNhbGN1bGF0ZSBhbmQgc3RvcmUgcG9zaXRpb24gaW4gbWVzaC1zcGFjZSBvZiBpbnRlcnNlY3Rpb24gb2Yge0BsaW5rIFJheX0gYW5kIHtAbGluayBNZXNofSBvbmx5IHdoZW4gdXNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBwb3NNZXNoKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAodGhpcy4jcG9zTWVzaClcclxuICAgICAgICByZXR1cm4gdGhpcy4jcG9zTWVzaDtcclxuICAgICAgbGV0IG10eFdvcmxkVG9NZXNoOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTSU9OKHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubXR4V29ybGQpO1xyXG4gICAgICBsZXQgcG9zTWVzaDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5wb3NXb3JsZCwgbXR4V29ybGRUb01lc2gpO1xyXG4gICAgICB0aGlzLiNwb3NNZXNoID0gcG9zTWVzaDtcclxuICAgICAgcmV0dXJuIHBvc01lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3NvciB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHRoZSBmYWNlIG5vcm1hbCBpbiB3b3JsZC1zcGFjZSBhdCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIG9mIHtAbGluayBSYXl9IGFuZCB7QGxpbmsgTWVzaH0gb25seSB3aGVuIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbm9ybWFsKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjM7XHJcblxyXG4gICAgICBmb3IgKGxldCBmYWNlIG9mIGNtcE1lc2gubWVzaC5mYWNlcykge1xyXG4gICAgICAgIGlmIChmYWNlLmlzSW5zaWRlKHRoaXMucG9zTWVzaCkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGZhY2Uubm9ybWFsLmNsb25lO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXN1bHQudHJhbnNmb3JtKGNtcE1lc2gubXR4V29ybGQsIGZhbHNlKTtcclxuICAgICAgcmVzdWx0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHNvbGVseSBieSB0aGUgcmVuZGVyZXIgdG8gZW5hYmxlIGNhbGN1bGF0aW9uIG9mIHRoZSB3b3JsZCBjb29yZGluYXRlcyBvZiB0aGlzIHtAbGluayBQaWNrfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG10eFZpZXdUb1dvcmxkKF9tdHhWaWV3VG9Xb3JsZDogTWF0cml4NHg0KSB7XHJcbiAgICAgIHRoaXMuI210eFZpZXdUb1dvcmxkID0gX210eFZpZXdUb1dvcmxkO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFByb3ZpZGVzIHN0YXRpYyBtZXRob2RzIGZvciBwaWNraW5nIHVzaW5nIHtAbGluayBSZW5kZXJ9XHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUGlja2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSByYXkgcGx1cyBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmVzIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja1JheShfbm9kZXM6IE5vZGVbXSwgX3JheTogUmF5LCBfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IFBpY2tbXSB7XHJcbiAgICAgIGxldCBjbXBDYW1lcmFQaWNrOiBDb21wb25lbnRDYW1lcmEgPSBuZXcgQ29tcG9uZW50Q2FtZXJhKCk7XHJcbiAgICAgIGNtcENhbWVyYVBpY2subXR4UGl2b3QudHJhbnNsYXRpb24gPSBfcmF5Lm9yaWdpbjtcclxuICAgICAgY21wQ2FtZXJhUGljay5tdHhQaXZvdC5sb29rQXQoX3JheS5kaXJlY3Rpb24pO1xyXG4gICAgICBjbXBDYW1lcmFQaWNrLnByb2plY3RDZW50cmFsKDEsIDAuMDAxLCBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMLCBfbWluLCBfbWF4KTtcclxuXHJcbiAgICAgIGxldCBwaWNrczogUGlja1tdID0gUmVuZGVyLnBpY2tCcmFuY2goX25vZGVzLCBjbXBDYW1lcmFQaWNrKTtcclxuICAgICAgcmV0dXJuIHBpY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjYW1lcmEgYW5kIGEgcG9pbnQgb24gaXRzIHZpcnR1YWwgbm9ybWVkIHByb2plY3Rpb24gcGxhbmUgKGRpc3RhbmNlIDEpIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja0NhbWVyYShfbm9kZXM6IE5vZGVbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfcG9zUHJvamVjdGlvbjogVmVjdG9yMik6IFBpY2tbXSB7XHJcbiAgICAgIGxldCByYXk6IFJheSA9IG5ldyBSYXkobmV3IFZlY3RvcjMoLV9wb3NQcm9qZWN0aW9uLngsIF9wb3NQcm9qZWN0aW9uLnksIDEpKTtcclxuICAgICAgbGV0IGxlbmd0aDogbnVtYmVyID0gcmF5LmRpcmVjdGlvbi5tYWduaXR1ZGU7XHJcblxyXG4gICAgICBpZiAoX2NtcENhbWVyYS5ub2RlKSB7XHJcbiAgICAgICAgbGV0IG10eENhbWVyYTogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9jbXBDYW1lcmEubm9kZS5tdHhXb3JsZCwgX2NtcENhbWVyYS5tdHhQaXZvdCk7XHJcbiAgICAgICAgcmF5LnRyYW5zZm9ybShtdHhDYW1lcmEpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eENhbWVyYSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJheS50cmFuc2Zvcm0oX2NtcENhbWVyYS5tdHhQaXZvdCk7XHJcblxyXG5cclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBQaWNrZXIucGlja1JheShfbm9kZXMsIHJheSwgbGVuZ3RoICogX2NtcENhbWVyYS5nZXROZWFyKCksIGxlbmd0aCAqIF9jbXBDYW1lcmEuZ2V0RmFyKCkpO1xyXG4gICAgICByZXR1cm4gcGlja3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyB0aGUgY2FtZXJhIG9mIHRoZSBnaXZlbiB2aWV3cG9ydCBhbmQgYSBwb2ludCB0aGUgY2xpZW50IHN1cmZhY2UgdG8gY29uc3RydWN0IHRoZSBwaWNrZXItY2FtZXJhLFxyXG4gICAgICogdGhlbiByZW5kZXJzIHRoZSBwaWNrLXRleHR1cmUgYW5kIHJldHVybnMgYW4gdW5zb3J0ZWQge0BsaW5rIFBpY2t9LWFycmF5IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdHMgb2YgdGhlIHJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrVmlld3BvcnQoX3ZpZXdwb3J0OiBWaWV3cG9ydCwgX3Bvc0NsaWVudDogVmVjdG9yMik6IFBpY2tbXSB7XHJcbiAgICAgIGxldCBwb3NQcm9qZWN0aW9uOiBWZWN0b3IyID0gX3ZpZXdwb3J0LnBvaW50Q2xpZW50VG9Qcm9qZWN0aW9uKF9wb3NDbGllbnQpO1xyXG4gICAgICBsZXQgbm9kZXM6IE5vZGVbXSA9IEFycmF5LmZyb20oX3ZpZXdwb3J0LmdldEJyYW5jaCgpLmdldEl0ZXJhdG9yKHRydWUpKTtcclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBQaWNrZXIucGlja0NhbWVyYShub2RlcywgX3ZpZXdwb3J0LmNhbWVyYSwgcG9zUHJvamVjdGlvbik7XHJcbiAgICAgIHJldHVybiBwaWNrcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVkIGJ5IGFuIG9yaWdpbiBhbmQgYSBkaXJlY3Rpb24gb2YgdHlwZSB7QGxpbmsgUGlja30sIHJheXMgYXJlIHVzZWQgdG8gY2FsY3VsYXRlIHBpY2tpbmcgYW5kIGludGVyc2VjdGlvbnNcclxuICAgKiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSYXkge1xyXG4gICAgcHVibGljIG9yaWdpbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyBkaXJlY3Rpb246IFZlY3RvcjM7XHJcbiAgICAvKiogVE9ETzogc3VwcG9ydCBsZW5ndGggKi9cclxuICAgIHB1YmxpYyBsZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfZGlyZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKDEpLCBfb3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCksIF9sZW5ndGg6IG51bWJlciA9IDEpIHtcclxuICAgICAgdGhpcy5vcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgIHRoaXMubGVuZ3RoID0gX2xlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0aGlzIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSBcclxuICAgICAqIHRoZSBnaXZlbiBwb2ludCBvZiBvcmlnaW4gYW5kIHRoZSBwbGFuZXMgbm9ybWFsLiBBbGwgdmFsdWVzIGFuZCBjYWxjdWxhdGlvbnNcclxuICAgICAqIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnRlcnNlY3RQbGFuZShfb3JpZ2luOiBWZWN0b3IzLCBfbm9ybWFsOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9vcmlnaW4sIHRoaXMub3JpZ2luKTtcclxuICAgICAgbGV0IGZhY3RvcjogbnVtYmVyID0gVmVjdG9yMy5ET1QoZGlmZmVyZW5jZSwgX25vcm1hbCkgLyBWZWN0b3IzLkRPVCh0aGlzLmRpcmVjdGlvbiwgX25vcm1hbCk7XHJcbiAgICAgIGxldCBpbnRlcnNlY3Q6IFZlY3RvcjMgPSBWZWN0b3IzLlNVTSh0aGlzLm9yaWdpbiwgVmVjdG9yMy5TQ0FMRSh0aGlzLmRpcmVjdGlvbiwgZmFjdG9yKSk7XHJcbiAgICAgIHJldHVybiBpbnRlcnNlY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gb2YgdGhpcyByYXkgd2l0aCBhIHBsYW5lIGRlZmluZWQgYnkgdGhlIGZhY2UuIFxyXG4gICAgICogQWxsIHZhbHVlcyBhbmQgY2FsY3VsYXRpb25zIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnRlcnNlY3RGYWNlUGxhbmUoX2ZhY2U6IEZhY2UpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0UGxhbmUoX2ZhY2UuZ2V0UG9zaXRpb24oMCksIF9mYWNlLm5vcm1hbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBmcm9tIHRoZSByYXkgdG8gdGhlIGdpdmVuIHRhcmdldCBwb2ludC5cclxuICAgICAqIEFsbCB2YWx1ZXMgYW5kIGNhbGN1bGF0aW9ucyBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtLCBwcmVmZXJhYmx5IHRoZSB3b3JsZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERpc3RhbmNlKF90YXJnZXQ6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IG9yaWdpblRvVGFyZ2V0OiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHRoaXMub3JpZ2luKTtcclxuICAgICAgbGV0IHJheVNlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5kaXJlY3Rpb24sIDEpO1xyXG4gICAgICBsZXQgcHJvamVjdGVkTGVuZ3RoOiBudW1iZXIgPSBWZWN0b3IzLkRPVChvcmlnaW5Ub1RhcmdldCwgcmF5U2VjdGlvbik7XHJcbiAgICAgIHJheVNlY3Rpb24uc2NhbGUocHJvamVjdGVkTGVuZ3RoKTtcclxuICAgICAgcmF5U2VjdGlvbi5hZGQodGhpcy5vcmlnaW4pO1xyXG4gICAgICBsZXQgZGlzdGFuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgcmF5U2VjdGlvbik7XHJcbiAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSB0aGUgcmF5IGJ5IHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm0pO1xyXG4gICAgICB0aGlzLm9yaWdpbi50cmFuc2Zvcm0oX210eFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmVhZGFibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYG9yaWdpbjogJHt0aGlzLm9yaWdpbi50b1N0cmluZygpfSwgZGlyZWN0aW9uOiAke3RoaXMuZGlyZWN0aW9uLnRvU3RyaW5nKCl9LCBsZW5ndGg6ICR7dGhpcy5sZW5ndGgudG9QcmVjaXNpb24oNSl9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgdHlwZSBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IE1hcDxUeXBlT2ZMaWdodCwgQ29tcG9uZW50TGlnaHRbXT47XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyUHJlcGFyZU9wdGlvbnMge1xyXG4gICAgaWdub3JlUGh5c2ljcz86IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbWFpbiBpbnRlcmZhY2UgdG8gdGhlIHJlbmRlciBlbmdpbmUsIGhlcmUgV2ViR0wgKHNlZSBzdXBlcmNsYXNzIHtAbGluayBSZW5kZXJXZWJHTH0gYW5kIHRoZSBSZW5kZXJJbmplY3RvcnNcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyIGV4dGVuZHMgUmVuZGVyV2ViR0wge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWN0Q2xpcDogUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgtMSwgMSwgMiwgLTIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrQnVmZmVyOiBJbnQzMkFycmF5O1xyXG4gICAgcHVibGljIHN0YXRpYyBub2Rlc1BoeXNpY3M6IFJlY3ljYWJsZUFycmF5PE5vZGU+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XHJcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudHNQaWNrOiBSZWN5Y2FibGVBcnJheTxDb21wb25lbnRQaWNrPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbm9kZXNTaW1wbGU6IFJlY3ljYWJsZUFycmF5PE5vZGU+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBub2Rlc0FscGhhOiBSZWN5Y2FibGVBcnJheTxOb2RlPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXI7XHJcblxyXG4gICAgLy8gVE9ETzogcmVzZWFyY2ggaWYgcGlja2luZyBzaG91bGQgYmUgb3B0aW1pemVkIHVzaW5nIHJhZGl1cyBwaWNraW5nIHRvIGZpbHRlclxyXG5cclxuICAgIC8vI3JlZ2lvbiBQcmVwYXJlXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGl0ZXJhdGVzIG92ZXIgdGhlIGJyYW5jaCBzdGFydGluZyB3aXRoIHRoZSBub2RlIGdpdmVuLCByZWNhbGN1bGF0ZXMgYWxsIHdvcmxkIHRyYW5zZm9ybXMsIFxyXG4gICAgICogY29sbGVjdHMgYWxsIGxpZ2h0cyBhbmQgZmVlZHMgYWxsIHNoYWRlcnMgdXNlZCBpbiB0aGUgZ3JhcGggd2l0aCB0aGVzZSBsaWdodHMuIFNvcnRzIG5vZGVzIGZvciBkaWZmZXJlbnRcclxuICAgICAqIHJlbmRlciBwYXNzZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcHJlcGFyZShfYnJhbmNoOiBOb2RlLCBfb3B0aW9uczogUmVuZGVyUHJlcGFyZU9wdGlvbnMgPSB7fSwgX210eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSwgX2xpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QgPSBuZXcgTWFwKCksIF9zaGFkZXJzVXNlZDogKHR5cGVvZiBTaGFkZXIpW10gPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIGxldCBmaXJzdExldmVsOiBib29sZWFuID0gKF9zaGFkZXJzVXNlZCA9PSBudWxsKTtcclxuICAgICAgaWYgKGZpcnN0TGV2ZWwpIHtcclxuICAgICAgICBfc2hhZGVyc1VzZWQgPSBbXTtcclxuICAgICAgICBSZW5kZXIudGltZXN0YW1wVXBkYXRlID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgUmVuZGVyLm5vZGVzU2ltcGxlLnJlc2V0KCk7XHJcbiAgICAgICAgUmVuZGVyLm5vZGVzQWxwaGEucmVzZXQoKTtcclxuICAgICAgICBSZW5kZXIubm9kZXNQaHlzaWNzLnJlc2V0KCk7XHJcbiAgICAgICAgUmVuZGVyLmNvbXBvbmVudHNQaWNrLnJlc2V0KCk7XHJcbiAgICAgICAgUmVuZGVyLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULlJFTkRFUl9QUkVQQVJFX1NUQVJUKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghX2JyYW5jaC5pc0FjdGl2ZSlcclxuICAgICAgICByZXR1cm47IC8vIGRvbid0IGFkZCBicmFuY2ggdG8gcmVuZGVyIGxpc3QgaWYgbm90IGFjdGl2ZVxyXG5cclxuICAgICAgX2JyYW5jaC5uTm9kZXNJbkJyYW5jaCA9IDE7XHJcbiAgICAgIF9icmFuY2gucmFkaXVzID0gMDtcclxuXHJcbiAgICAgIF9icmFuY2guZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkUpKTtcclxuICAgICAgX2JyYW5jaC50aW1lc3RhbXBVcGRhdGUgPSBSZW5kZXIudGltZXN0YW1wVXBkYXRlO1xyXG5cclxuICAgICAgaWYgKF9icmFuY2guY21wVHJhbnNmb3JtICYmIF9icmFuY2guY21wVHJhbnNmb3JtLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgbGV0IG10eFdvcmxkQnJhbmNoOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX210eFdvcmxkLCBfYnJhbmNoLmNtcFRyYW5zZm9ybS5tdHhMb2NhbCk7XHJcbiAgICAgICAgX2JyYW5jaC5tdHhXb3JsZC5zZXQobXR4V29ybGRCcmFuY2gpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFdvcmxkQnJhbmNoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgX2JyYW5jaC5tdHhXb3JsZC5zZXQoX210eFdvcmxkKTsgLy8gb3ZlcndyaXRlIHJlYWRvbmx5IG10eFdvcmxkIG9mIHRoZSBjdXJyZW50IG5vZGVcclxuXHJcblxyXG4gICAgICBsZXQgY21wUmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRSaWdpZGJvZHkpO1xyXG4gICAgICBpZiAoY21wUmlnaWRib2R5ICYmIGNtcFJpZ2lkYm9keS5pc0FjdGl2ZSkgeyAvL1RPRE86IHN1cHBvcnQgZGUtL2FjdGl2YXRpb24gdGhyb3VnaG91dFxyXG4gICAgICAgIFJlbmRlci5ub2Rlc1BoeXNpY3MucHVzaChfYnJhbmNoKTsgLy8gYWRkIHRoaXMgbm9kZSB0byBwaHlzaWNzIGxpc3RcclxuICAgICAgICBpZiAoIV9vcHRpb25zPy5pZ25vcmVQaHlzaWNzKVxyXG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1CeVBoeXNpY3MoX2JyYW5jaCwgY21wUmlnaWRib2R5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgXHJcbiAgICAgIGxldCBjbXBQaWNrOiBDb21wb25lbnRQaWNrID0gX2JyYW5jaC5nZXRDb21wb25lbnQoQ29tcG9uZW50UGljayk7XHJcbiAgICAgIGlmIChjbXBQaWNrICYmIGNtcFBpY2suaXNBY3RpdmUpIHsgXHJcbiAgICAgICAgUmVuZGVyLmNvbXBvbmVudHNQaWNrLnB1c2goY21wUGljayk7IC8vIGFkZCB0aGlzIGNvbXBvbmVudCB0byBwaWNrIGxpc3RcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGxldCBjbXBMaWdodHM6IENvbXBvbmVudExpZ2h0W10gPSBfYnJhbmNoLmdldENvbXBvbmVudHMoQ29tcG9uZW50TGlnaHQpO1xyXG4gICAgICBmb3IgKGxldCBjbXBMaWdodCBvZiBjbXBMaWdodHMpIHtcclxuICAgICAgICBpZiAoIWNtcExpZ2h0LmlzQWN0aXZlKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbGV0IHR5cGU6IFR5cGVPZkxpZ2h0ID0gY21wTGlnaHQubGlnaHQuZ2V0VHlwZSgpO1xyXG4gICAgICAgIGxldCBsaWdodHNPZlR5cGU6IENvbXBvbmVudExpZ2h0W10gPSBfbGlnaHRzLmdldCh0eXBlKTtcclxuICAgICAgICBpZiAoIWxpZ2h0c09mVHlwZSkge1xyXG4gICAgICAgICAgbGlnaHRzT2ZUeXBlID0gW107XHJcbiAgICAgICAgICBfbGlnaHRzLnNldCh0eXBlLCBsaWdodHNPZlR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaWdodHNPZlR5cGUucHVzaChjbXBMaWdodCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gX2JyYW5jaC5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcbiAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgIGlmIChjbXBNZXNoICYmIGNtcE1lc2guaXNBY3RpdmUgJiYgY21wTWF0ZXJpYWwgJiYgY21wTWF0ZXJpYWwuaXNBY3RpdmUpIHtcclxuICAgICAgICAvLyBUT0RPOiBjYXJlZnVsIHdoZW4gdXNpbmcgcGFydGljbGVzeXN0ZW0sIHBpdm90IG11c3Qgbm90IGNoYW5nZSBub2RlIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IG10eFdvcmxkTWVzaDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9icmFuY2gubXR4V29ybGQsIGNtcE1lc2gubXR4UGl2b3QpO1xyXG4gICAgICAgIGNtcE1lc2gubXR4V29ybGQuc2V0KG10eFdvcmxkTWVzaCk7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4V29ybGRNZXNoKTsgLy8gVE9ETzogZXhhbWluZSwgd2h5IHJlY3ljbGluZyB0aGlzIGNhdXNlcyBtZXNoZXMgdG8gYmUgbWlzcGxhY2VkLi4uXHJcbiAgICAgICAgbGV0IHNoYWRlcjogdHlwZW9mIFNoYWRlciA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmdldFNoYWRlcigpO1xyXG4gICAgICAgIGlmIChfc2hhZGVyc1VzZWQuaW5kZXhPZihzaGFkZXIpIDwgMClcclxuICAgICAgICAgIF9zaGFkZXJzVXNlZC5wdXNoKHNoYWRlcik7XHJcblxyXG4gICAgICAgIF9icmFuY2gucmFkaXVzID0gY21wTWVzaC5yYWRpdXM7XHJcbiAgICAgICAgaWYgKGNtcE1hdGVyaWFsLnNvcnRGb3JBbHBoYSlcclxuICAgICAgICAgIFJlbmRlci5ub2Rlc0FscGhhLnB1c2goX2JyYW5jaCk7IC8vIGFkZCB0aGlzIG5vZGUgdG8gcmVuZGVyIGxpc3RcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBSZW5kZXIubm9kZXNTaW1wbGUucHVzaChfYnJhbmNoKTsgLy8gYWRkIHRoaXMgbm9kZSB0byByZW5kZXIgbGlzdFxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBfYnJhbmNoLmdldENoaWxkcmVuKCkpIHtcclxuICAgICAgICBSZW5kZXIucHJlcGFyZShjaGlsZCwgX29wdGlvbnMsIF9icmFuY2gubXR4V29ybGQsIF9saWdodHMsIF9zaGFkZXJzVXNlZCk7XHJcblxyXG4gICAgICAgIF9icmFuY2gubk5vZGVzSW5CcmFuY2ggKz0gY2hpbGQubk5vZGVzSW5CcmFuY2g7XHJcbiAgICAgICAgbGV0IGNtcE1lc2hDaGlsZDogQ29tcG9uZW50TWVzaCA9IGNoaWxkLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBjbXBNZXNoQ2hpbGQgPyBjbXBNZXNoQ2hpbGQubXR4V29ybGQudHJhbnNsYXRpb24gOiBjaGlsZC5tdHhXb3JsZC50cmFuc2xhdGlvbjtcclxuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lO1xyXG4gICAgICAgIF9icmFuY2gucmFkaXVzID0gTWF0aC5tYXgoX2JyYW5jaC5yYWRpdXMsIHBvc2l0aW9uLmdldERpc3RhbmNlKF9icmFuY2gubXR4V29ybGQudHJhbnNsYXRpb24pICsgY2hpbGQucmFkaXVzKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShwb3NpdGlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmaXJzdExldmVsKSB7XHJcbiAgICAgICAgUmVuZGVyLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULlJFTkRFUl9QUkVQQVJFX0VORCkpO1xyXG4gICAgICAgIGZvciAobGV0IHNoYWRlciBvZiBfc2hhZGVyc1VzZWQpXHJcbiAgICAgICAgICBSZW5kZXIuc2V0TGlnaHRzSW5TaGFkZXIoc2hhZGVyLCBfbGlnaHRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9DYWxjdWxhdGUgUGh5c2ljcyBiYXNlZCBvbiBhbGwgcHJldmlvdXMgY2FsY3VsYXRpb25zICAgIFxyXG4gICAgICAvLyBSZW5kZXIuc2V0dXBQaHlzaWNhbFRyYW5zZm9ybShfYnJhbmNoKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBQaWNraW5nXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgd2l0aCBhIHtAbGluayBQaWNrZXJ9LWNhbWVyYSwgdGhpcyBtZXRob2QgcmVuZGVycyBvbmUgcGl4ZWwgd2l0aCBwaWNraW5nIGluZm9ybWF0aW9uIFxyXG4gICAgICogZm9yIGVhY2ggbm9kZSBpbiB0aGUgbGluZSBvZiBzaWdodCBhbmQgcmV0dXJuIHRoYXQgYXMgYW4gdW5zb3J0ZWQge0BsaW5rIFBpY2t9LWFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja0JyYW5jaChfbm9kZXM6IE5vZGVbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja1tdIHsgLy8gVE9ETzogc2VlIGlmIHRoaXJkIHBhcmFtZXRlciBfd29ybGQ/OiBNYXRyaXg0eDQgd291bGQgYmUgdXNlZnVsbFxyXG4gICAgICBSZW5kZXIuxpJwaWNrZWQgPSBbXTtcclxuICAgICAgbGV0IHNpemU6IG51bWJlciA9IE1hdGguY2VpbChNYXRoLnNxcnQoX25vZGVzLmxlbmd0aCkpO1xyXG4gICAgICBSZW5kZXIuY3JlYXRlUGlja1RleHR1cmUoc2l6ZSk7XHJcbiAgICAgIFJlbmRlci5zZXRCbGVuZE1vZGUoQkxFTkQuT1BBUVVFKTtcclxuXHJcbiAgICAgIGZvciAobGV0IG5vZGUgb2YgX25vZGVzKSB7XHJcbiAgICAgICAgbGV0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgICBsZXQgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpO1xyXG4gICAgICAgIGlmIChjbXBNZXNoICYmIGNtcE1lc2guaXNBY3RpdmUgJiYgY21wTWF0ZXJpYWwgJiYgY21wTWF0ZXJpYWwuaXNBY3RpdmUpIHtcclxuICAgICAgICAgIGxldCBtdHhNZXNoVG9WaWV3OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTVVMVElQTElDQVRJT04oX2NtcENhbWVyYS5tdHhXb3JsZFRvVmlldywgY21wTWVzaC5tdHhXb3JsZCk7XHJcbiAgICAgICAgICBSZW5kZXIucGljayhub2RlLCBub2RlLm10eFdvcmxkLCBtdHhNZXNoVG9WaWV3KTtcclxuICAgICAgICAgIC8vIFJlbmRlclBhcnRpY2xlcy5kcmF3UGFydGljbGVzKCk7XHJcbiAgICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhNZXNoVG9WaWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlbmRlci5zZXRCbGVuZE1vZGUoQkxFTkQuVFJBTlNQQVJFTlQpO1xyXG5cclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBSZW5kZXIuZ2V0UGlja3Moc2l6ZSwgX2NtcENhbWVyYSk7XHJcbiAgICAgIFJlbmRlci5yZXNldEZyYW1lQnVmZmVyKCk7XHJcbiAgICAgIHJldHVybiBwaWNrcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBEcmF3aW5nXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXcoX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XHJcbiAgICAgIF9jbXBDYW1lcmEucmVzZXRXb3JsZFRvVmlldygpO1xyXG4gICAgICBSZW5kZXIuZHJhd0xpc3QoX2NtcENhbWVyYSwgdGhpcy5ub2Rlc1NpbXBsZSk7XHJcbiAgICAgIFJlbmRlci5kcmF3TGlzdEFscGhhKF9jbXBDYW1lcmEpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdMaXN0QWxwaGEoX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XHJcbiAgICAgIGZ1bmN0aW9uIHNvcnQoX2E6IE5vZGUsIF9iOiBOb2RlKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gKFJlZmxlY3QuZ2V0KF9hLCBcInpDYW1lcmFcIikgPCBSZWZsZWN0LmdldChfYiwgXCJ6Q2FtZXJhXCIpKSA/IDEgOiAtMTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIFJlbmRlci5ub2Rlc0FscGhhKVxyXG4gICAgICAgIFJlZmxlY3Quc2V0KG5vZGUsIFwiekNhbWVyYVwiLCBfY21wQ2FtZXJhLnBvaW50V29ybGRUb0NsaXAobm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubXR4V29ybGQudHJhbnNsYXRpb24pLnopO1xyXG5cclxuICAgICAgbGV0IHNvcnRlZDogTm9kZVtdID0gUmVuZGVyLm5vZGVzQWxwaGEuZ2V0U29ydGVkKHNvcnQpO1xyXG4gICAgICBSZW5kZXIuZHJhd0xpc3QoX2NtcENhbWVyYSwgc29ydGVkKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkcmF3TGlzdChfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9saXN0OiBSZWN5Y2FibGVBcnJheTxOb2RlPiB8IEFycmF5PE5vZGU+KTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IG5vZGUgb2YgX2xpc3QpIHtcclxuICAgICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgICAgUmVuZGVyLmRyYXdNZXNoKGNtcE1lc2gsIGNtcE1hdGVyaWFsLCBfY21wQ2FtZXJhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBQaHlzaWNzXHJcbiAgICBwcml2YXRlIHN0YXRpYyB0cmFuc2Zvcm1CeVBoeXNpY3MoX25vZGU6IE5vZGUsIF9jbXBSaWdpZGJvZHk6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQge1xyXG4gICAgICBpZiAoIV9jbXBSaWdpZGJvZHkuaXNJbml0aWFsaXplZCkgLy8gfHwgUHJvamVjdC5tb2RlID09IE1PREUuRURJVE9SKVxyXG4gICAgICAgIF9jbXBSaWdpZGJvZHkuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgaWYgKCFQaHlzaWNzLmdldEJvZHlMaXN0KCkubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGlmICghX25vZGUubXR4TG9jYWwpIHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiQ29tcG9uZW50UmlnaWRib2R5IHJlcXVpcmVzIENvbXBvbmVudFRyYW5zZm9ybSBhdCB0aGUgc2FtZSBOb2RlXCIpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX2NtcFJpZ2lkYm9keS5jaGVja0NvbGxpc2lvbkV2ZW50cygpO1xyXG5cclxuICAgICAgaWYgKF9jbXBSaWdpZGJvZHkudHlwZUJvZHkgPT0gQk9EWV9UWVBFLktJTkVNQVRJQyB8fCBQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IpIHsgLy9DYXNlIG9mIEtpbmVtYXRpYyBSaWdpZGJvZHlcclxuICAgICAgICBsZXQgbXR4UGl2b3RXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9ub2RlLm10eFdvcmxkLCBfY21wUmlnaWRib2R5Lm10eFBpdm90VW5zY2FsZWQpO1xyXG4gICAgICAgIF9jbXBSaWdpZGJvZHkuc2V0UG9zaXRpb24obXR4UGl2b3RXb3JsZC50cmFuc2xhdGlvbik7XHJcbiAgICAgICAgX2NtcFJpZ2lkYm9keS5zZXRSb3RhdGlvbihtdHhQaXZvdFdvcmxkLnJvdGF0aW9uKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhQaXZvdFdvcmxkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkNPTlNUUlVDVElPTihcclxuICAgICAgICB7IHRyYW5zbGF0aW9uOiBfY21wUmlnaWRib2R5LmdldFBvc2l0aW9uKCksIHJvdGF0aW9uOiBfY21wUmlnaWRib2R5LmdldFJvdGF0aW9uKCksIHNjYWxpbmc6IG51bGwgfVxyXG4gICAgICApO1xyXG4gICAgICBtdHhXb3JsZC5tdWx0aXBseShfY21wUmlnaWRib2R5Lm10eFBpdm90SW52ZXJzZSk7XHJcbiAgICAgIF9ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uID0gbXR4V29ybGQudHJhbnNsYXRpb247XHJcbiAgICAgIF9ub2RlLm10eFdvcmxkLnJvdGF0aW9uID0gbXR4V29ybGQucm90YXRpb247XHJcbiAgICAgIGxldCBtdHhMb2NhbDogTWF0cml4NHg0ID0gX25vZGUuZ2V0UGFyZW50KCkgPyBNYXRyaXg0eDQuUkVMQVRJVkUoX25vZGUubXR4V29ybGQsIF9ub2RlLmdldFBhcmVudCgpLm10eFdvcmxkKSA6IF9ub2RlLm10eFdvcmxkO1xyXG4gICAgICBfbm9kZS5tdHhMb2NhbC5zZXQobXR4TG9jYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhXb3JsZCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eExvY2FsKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8jZW5kcmVnaW9uXHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSW5zZXJ0ZWQgaW50byBhIHtAbGluayBNZXNofSwgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBjYWxjdWxhdGVzIGFuZCByZXByZXNlbnRzIHRoZSBtZXNoIGRhdGEgaW4gdGhlIGZvcm0gbmVlZGVkIGJ5IHRoZSByZW5kZXIgZW5naW5lXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBSZW5kZXJCdWZmZXJzIHtcclxuICAgIHZlcnRpY2VzPzogV2ViR0xCdWZmZXI7XHJcbiAgICBpbmRpY2VzPzogV2ViR0xCdWZmZXI7XHJcbiAgICB0ZXh0dXJlVVZzPzogV2ViR0xCdWZmZXI7XHJcbiAgICBub3JtYWxzPzogV2ViR0xCdWZmZXI7XHJcbiAgICBpQm9uZXM/OiBXZWJHTEJ1ZmZlcjtcclxuICAgIHdlaWdodHM/OiBXZWJHTEJ1ZmZlcjtcclxuICAgIG5JbmRpY2VzPzogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlck1lc2gge1xyXG4gICAgcHVibGljIHNtb290aDogUmVuZGVyQnVmZmVycyA9IG51bGw7XHJcbiAgICBwdWJsaWMgZmxhdDogUmVuZGVyQnVmZmVycyA9IG51bGw7XHJcbiAgICBwdWJsaWMgbWVzaDogTWVzaDtcclxuXHJcbiAgICAvKiogdmVydGljZXMgb2YgdGhlIGFjdHVhbCBwb2ludCBjbG91ZCwgc29tZSBwb2ludHMgbWlnaHQgYmUgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gb3JkZXIgdG8gcmVmZXIgdG8gZGlmZmVyZW50IHRleGVscyAqL1xyXG4gICAgcHJvdGVjdGVkIMaSdmVydGljZXM6IEZsb2F0MzJBcnJheTtcclxuICAgIC8qKiBpbmRpY2VzIHRvIGNyZWF0ZSBmYWNlcyBmcm9tIHRoZSB2ZXJ0aWNlcywgcm90YXRpb24gZGV0ZXJtaW5lcyBkaXJlY3Rpb24gb2YgZmFjZS1ub3JtYWwgKi9cclxuICAgIHByb3RlY3RlZCDGkmluZGljZXM6IFVpbnQxNkFycmF5O1xyXG4gICAgLyoqIHRleHR1cmUgY29vcmRpbmF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB2ZXJ0aWNlcyBieSB0aGUgcG9zaXRpb24gaW4gdGhlIGFycmF5ICovXHJcbiAgICBwcm90ZWN0ZWQgxpJ0ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXk7XHJcbiAgICAvKiogdmVydGV4IG5vcm1hbHMgZm9yIHNtb290aCBzaGFkaW5nLCBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB2ZXJ0aWNlcyBkdXJpbmcgcmVuZGVyaW5nICovXHJcbiAgICBwcm90ZWN0ZWQgxpJub3JtYWxzVmVydGV4OiBGbG9hdDMyQXJyYXk7XHJcbiAgICAvKiogYm9uZXMgKi9cclxuICAgIHByb3RlY3RlZCDGkmlCb25lczogVWludDhBcnJheTtcclxuICAgIHByb3RlY3RlZCDGkndlaWdodHM6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICAvKiogZmxhdC1zaGFkaW5nOiBub3JtYWxpemVkIGZhY2Ugbm9ybWFscywgZXZlcnkgdGhpcmQgZW50cnkgaXMgdXNlZCBvbmx5ICovXHJcbiAgICBwcm90ZWN0ZWQgxpJub3JtYWxzRmxhdDogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIGZsYXQtc2hhZGluZzogZXh0cmEgdmVydGV4IGFycmF5LCBzaW5jZSB1c2luZyB2ZXJ0aWNlcyB3aXRoIG11bHRpcGxlIGZhY2VzIGlzIHJhcmVseSBwb3NzaWJsZSBkdWUgdG8gdGhlIGxpbWl0YXRpb24gYWJvdmUgKi9cclxuICAgIHByb3RlY3RlZCDGknZlcnRpY2VzRmxhdDogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIGZsYXQtc2hhZGluZzogdGhlcmVmb3JlIGFuIGV4dHJhIGluZGljZXMtYXJyYXkgaXMgbmVlZGVkICovXHJcbiAgICBwcm90ZWN0ZWQgxpJpbmRpY2VzRmxhdDogVWludDE2QXJyYXk7XHJcbiAgICAvKiogZmxhdC1zaGFkaW5nOiBhbmQgYW4gZXh0cmEgdGV4dHVyZVVWLWFycmF5ICovXHJcbiAgICBwcm90ZWN0ZWQgxpJ0ZXh0dXJlVVZzRmxhdDogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIGJvbmVzICovXHJcbiAgICBwcm90ZWN0ZWQgxpJpQm9uZXNGbGF0OiBVaW50OEFycmF5O1xyXG4gICAgcHJvdGVjdGVkIMaSd2VpZ2h0c0ZsYXQ6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihfbWVzaDogTWVzaCkge1xyXG4gICAgICB0aGlzLm1lc2ggPSBfbWVzaDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlCb25lcygpOiBVaW50OEFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJpQm9uZXMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXHJcbiAgICAgICAgdGhpcy7GkmlCb25lcyA9IG5ldyBVaW50OEFycmF5KHRoaXMubWVzaC52ZXJ0aWNlcy5mbGF0TWFwKChfdmVydGV4OiBWZXJ0ZXgsIF9pbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gWy4uLnRoaXMubWVzaC52ZXJ0aWNlcy5ib25lcyhfaW5kZXgpLm1hcChfYm9uZSA9PiBfYm9uZS5pbmRleCldO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB3ZWlnaHRzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLsaSd2VpZ2h0cyB8fCAoIC8vIHJldHVybiBjYWNoZSBvciAuLi5cclxuICAgICAgICB0aGlzLsaSd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoKF92ZXJ0ZXg6IFZlcnRleCwgX2luZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIHJldHVybiBbLi4udGhpcy5tZXNoLnZlcnRpY2VzLmJvbmVzKF9pbmRleCkubWFwKF9ib25lID0+IF9ib25lLndlaWdodCldO1xyXG4gICAgICAgIH0pKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJ2ZXJ0aWNlcyB8fCAoIC8vIHJldHVybiBjYWNoZSBvciAuLi5cclxuICAgICAgICAvLyAuLi4gZmxhdHRlbiBhbGwgdmVydGV4IHBvc2l0aW9ucyBmcm9tIGNsb3VkIGludG8gYSB0eXBlZCBhcnJheVxyXG4gICAgICAgIHRoaXMuxpJ2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoKF92ZXJ0ZXg6IFZlcnRleCwgX2luZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIHJldHVybiBbLi4udGhpcy5tZXNoLnZlcnRpY2VzLnBvc2l0aW9uKF9pbmRleCkuZ2V0KCldO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJpbmRpY2VzIHx8ICggLy8gcmV0dXJuIGNhY2hlIG9yIC4uLlxyXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCBpbmRpY2VzIGZyb20gdGhlIGZhY2VzIGludG8gYSB0eXBlZCBhcnJheVxyXG4gICAgICAgIHRoaXMuxpJpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMubWVzaC5mYWNlcy5mbGF0TWFwKChfZmFjZTogRmFjZSkgPT4gWy4uLl9mYWNlLmluZGljZXNdKVxyXG4gICAgICAgICkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbm9ybWFsc1ZlcnRleCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBpZiAodGhpcy7Gkm5vcm1hbHNWZXJ0ZXggPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHN1bSB1cCBhbGwgdW5zY2FsZWQgbm9ybWFscyBvZiBmYWNlcyBjb25uZWN0ZWQgdG8gb25lIHZlcnRleC4uLlxyXG4gICAgICAgIHRoaXMubWVzaC52ZXJ0aWNlcy5mb3JFYWNoKF92ZXJ0ZXggPT4gX3ZlcnRleC5ub3JtYWwuc2V0KDAsIDAsIDApKTtcclxuICAgICAgICBmb3IgKGxldCBmYWNlIG9mIHRoaXMubWVzaC5mYWNlcylcclxuICAgICAgICAgIGZvciAobGV0IGluZGV4IG9mIGZhY2UuaW5kaWNlcykge1xyXG4gICAgICAgICAgICB0aGlzLm1lc2gudmVydGljZXMubm9ybWFsKGluZGV4KS5hZGQoZmFjZS5ub3JtYWxVbnNjYWxlZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgLy8gLi4uIGFuZCBub3JtYWxpemUgdGhlbVxyXG4gICAgICAgIHRoaXMubWVzaC52ZXJ0aWNlcy5mb3JFYWNoKF92ZXJ0ZXggPT4ge1xyXG4gICAgICAgICAgLy8gc29tZSB2ZXJ0aWNlcyBtaWdodCBiZSB1bnVzZWQgYW5kIHlpZWxkIGEgemVyby1ub3JtYWwuLi5cclxuICAgICAgICAgIGlmIChfdmVydGV4Lm5vcm1hbC5tYWduaXR1ZGVTcXVhcmVkID4gMClcclxuICAgICAgICAgICAgX3ZlcnRleC5ub3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMuxpJub3JtYWxzVmVydGV4ID0gbmV3IEZsb2F0MzJBcnJheShub3JtYWxzVmVydGV4LmZsYXRNYXAoKF9ub3JtYWw6IFZlY3RvcjMpID0+IFsuLi5fbm9ybWFsLmdldCgpXSkpO1xyXG5cclxuICAgICAgICB0aGlzLsaSbm9ybWFsc1ZlcnRleCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoKF92ZXJ0ZXg6IFZlcnRleCwgX2luZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIHJldHVybiBbLi4udGhpcy5tZXNoLnZlcnRpY2VzLm5vcm1hbChfaW5kZXgpLmdldCgpXTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaSbm9ybWFsc1ZlcnRleDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJ0ZXh0dXJlVVZzIHx8ICggLy8gcmV0dXJuIGNhY2hlIG9yIC4uLlxyXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCB1dnMgZnJvbSB0aGUgY2xvdXMgaW50byBhIHR5cGVkIGFycmF5XHJcbiAgICAgICAgdGhpcy7GknRleHR1cmVVVnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubWVzaC52ZXJ0aWNlcy5mbGF0TWFwKChfdmVydGV4OiBWZXJ0ZXgpID0+IFsuLi5fdmVydGV4LnV2LmdldCgpXSlcclxuICAgICAgICApKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGdldCB2ZXJ0aWNlc0ZsYXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJ2ZXJ0aWNlc0ZsYXQgfHwgKHRoaXMuxpJ2ZXJ0aWNlc0ZsYXQgPSB0aGlzLmNyZWF0ZVZlcnRpY2VzRmxhdCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGluZGljZXNGbGF0KCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJpbmRpY2VzRmxhdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG5vcm1hbHNGbGF0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLsaSbm9ybWFsc0ZsYXQgfHwgKHRoaXMuxpJub3JtYWxzRmxhdCA9IHRoaXMuY3JlYXRlTm9ybWFsc0ZsYXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0ZXh0dXJlVVZzRmxhdCgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy7GknRleHR1cmVVVnNGbGF0IHx8ICh0aGlzLsaSdGV4dHVyZVVWc0ZsYXQgPSB0aGlzLmNyZWF0ZVRleHR1cmVVVnNGbGF0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaUJvbmVzRmxhdCgpOiBVaW50OEFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJpQm9uZXNGbGF0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgd2VpZ2h0c0ZsYXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuxpJ3ZWlnaHRzRmxhdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNtb290aCA9IG51bGw7XHJcbiAgICAgIHRoaXMuZmxhdCA9IG51bGw7XHJcbiAgICAgIC8vIGJ1ZmZlcnMgZm9yIHNtb290aCBzaGFkaW5nXHJcbiAgICAgIHRoaXMuxpJ2ZXJ0aWNlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy7GkmluZGljZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuxpJ0ZXh0dXJlVVZzID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLsaSbm9ybWFsc1ZlcnRleCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIC8vIHNwZWNpYWwgYnVmZmVycyBmb3IgZmxhdCBzaGFkaW5nXHJcbiAgICAgIHRoaXMuxpJub3JtYWxzRmxhdCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy7GknZlcnRpY2VzRmxhdCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy7GkmluZGljZXNGbGF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLsaSdGV4dHVyZVVWc0ZsYXQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICB0aGlzLsaSaUJvbmVzID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLsaSd2VpZ2h0cyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXNGbGF0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBsZXQgYm9uZXM6IEJvbmVbXVtdID0gW107XHJcbiAgICAgIGxldCBpbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBsZXQgaTogbnVtYmVyID0gMDtcclxuICAgICAgZm9yIChsZXQgZmFjZSBvZiB0aGlzLm1lc2guZmFjZXMpXHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggb2YgZmFjZS5pbmRpY2VzKSB7XHJcbiAgICAgICAgICBpbmRpY2VzLnB1c2goaSsrKTtcclxuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHRoaXMubWVzaC52ZXJ0aWNlcy5wb3NpdGlvbihpbmRleCkpO1xyXG4gICAgICAgICAgbGV0IGJvbmU6IEJvbmVbXSA9IHRoaXMubWVzaC52ZXJ0aWNlcy5ib25lcyhpbmRleCk7XHJcbiAgICAgICAgICBpZiAoYm9uZSlcclxuICAgICAgICAgICAgYm9uZXMucHVzaChib25lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB0aGlzLsaSaW5kaWNlc0ZsYXQgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XHJcblxyXG4gICAgICB0aGlzLsaSaUJvbmVzRmxhdCA9IG5ldyBVaW50OEFycmF5KGJvbmVzLmZsYXRNYXAoKF9ib25lczogQm9uZVtdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi5fYm9uZXMubWFwKF9ib25lID0+IF9ib25lLmluZGV4KV07XHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHRoaXMuxpJ3ZWlnaHRzRmxhdCA9IG5ldyBGbG9hdDMyQXJyYXkoYm9uZXMuZmxhdE1hcCgoX2JvbmVzOiBCb25lW10pID0+IHtcclxuICAgICAgICByZXR1cm4gWy4uLl9ib25lcy5tYXAoX2JvbmUgPT4gX2JvbmUud2VpZ2h0KV07XHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucy5mbGF0TWFwKF92ID0+IFsuLi5fdi5nZXQoKV0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlTm9ybWFsc0ZsYXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IG5vcm1hbHM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBsZXQgemVybzogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICBmb3IgKGxldCBmYWNlIG9mIHRoaXMubWVzaC5mYWNlcykge1xyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBmYWNlIG5vcm1hbCBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIHRoaXJkIHZlcnRleFxyXG4gICAgICAgIG5vcm1hbHMucHVzaCh6ZXJvKTtcclxuICAgICAgICBub3JtYWxzLnB1c2goemVybyk7XHJcbiAgICAgICAgbm9ybWFscy5wdXNoKGZhY2Uubm9ybWFsKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLsaSbm9ybWFsc0ZsYXQgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbHMuZmxhdE1hcChfbiA9PiBbLi4uX24uZ2V0KCldKSk7XHJcbiAgICAgIHJldHVybiB0aGlzLsaSbm9ybWFsc0ZsYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRleHR1cmVVVnNGbGF0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGxldCB1djogbnVtYmVyW10gPSBbXTtcclxuICAgICAgLy8gY3JlYXRlIHVuaXF1ZSB2ZXJ0aWNlcyBmb3IgZWFjaCBmYWNlLCB0cmlwbGluZyB0aGUgbnVtYmVyXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgaW5kZXg6IG51bWJlciA9IHRoaXMuaW5kaWNlc1tpXSAqIDI7XHJcbiAgICAgICAgdXYucHVzaCh0aGlzLnRleHR1cmVVVnNbaW5kZXhdLCB0aGlzLnRleHR1cmVVVnNbaW5kZXggKyAxXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodXYpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJQYXJ0aWNsZXMgZXh0ZW5kcyBSZW5kZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3UGFydGljbGVzKCk6IHZvaWQge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhSZW5kZXJQYXJ0aWNsZXMuY3JjMyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQ29udHJvbHMgdGhlIHJlbmRlcmluZyBvZiBhIGJyYW5jaCwgdXNpbmcgdGhlIGdpdmVuIHtAbGluayBDb21wb25lbnRDYW1lcmF9LFxyXG4gICAqIGFuZCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHJlbmRlcmVkIGltYWdlIGZyb20gdGhlIG9mZnNjcmVlbiByZW5kZXJidWZmZXIgdG8gdGhlIHRhcmdldCBjYW52YXNcclxuICAgKiB0aHJvdWdoIGEgc2VyaWVzIG9mIHtAbGluayBGcmFtaW5nfSBvYmplY3RzLiBUaGUgc3RhZ2VzIGludm9sdmVkIGFyZSBpbiBvcmRlciBvZiByZW5kZXJpbmdcclxuICAgKiB7QGxpbmsgUmVuZGVyfS52aWV3cG9ydCAtPiB7QGxpbmsgVmlld3BvcnR9LnNvdXJjZSAtPiB7QGxpbmsgVmlld3BvcnR9LmRlc3RpbmF0aW9uIC0+IERPTS1DYW52YXMgLT4gQ2xpZW50KENTUylcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LTIwMjJcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vSmlya2FEZWxsT3JvL0ZVREdFL3dpa2kvVmlld3BvcnRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBFdmVudFRhcmdldMaSIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGZvY3VzOiBWaWV3cG9ydDtcclxuXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJWaWV3cG9ydFwiOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgdmlld3BvcnQgYnkuXHJcbiAgICBwdWJsaWMgY2FtZXJhOiBDb21wb25lbnRDYW1lcmEgPSBudWxsOyAvLyBUaGUgY2FtZXJhIHJlcHJlc2VudGluZyB0aGUgdmlldyBwYXJhbWV0ZXJzIHRvIHJlbmRlciB0aGUgYnJhbmNoLlxyXG5cclxuICAgIHB1YmxpYyByZWN0U291cmNlOiBSZWN0YW5nbGU7XHJcbiAgICBwdWJsaWMgcmVjdERlc3RpbmF0aW9uOiBSZWN0YW5nbGU7XHJcblxyXG4gICAgLy8gVE9ETzogdmVyaWZ5IGlmIGNsaWVudCB0byBjYW52YXMgc2hvdWxkIGJlIGluIFZpZXdwb3J0IG9yIHNvbWV3aGVyZSBlbHNlIChXaW5kb3csIENvbnRhaW5lcj8pXHJcbiAgICAvLyBNdWx0aXBsZSB2aWV3cG9ydHMgdXNpbmcgdGhlIHNhbWUgY2FudmFzIHNob3VsZG4ndCBkaWZmZXIgaGVyZS4uLlxyXG4gICAgLy8gZGlmZmVyZW50IGZyYW1pbmcgbWV0aG9kcyBjYW4gYmUgdXNlZCwgdGhpcyBpcyB0aGUgZGVmYXVsdFxyXG4gICAgcHVibGljIGZyYW1lQ2xpZW50VG9DYW52YXM6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG4gICAgcHVibGljIGZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbjogRnJhbWluZ0NvbXBsZXggPSBuZXcgRnJhbWluZ0NvbXBsZXgoKTtcclxuICAgIHB1YmxpYyBmcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2U6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG4gICAgcHVibGljIGZyYW1lU291cmNlVG9SZW5kZXI6IEZyYW1pbmdTY2FsZWQgPSBuZXcgRnJhbWluZ1NjYWxlZCgpO1xyXG5cclxuICAgIHB1YmxpYyBhZGp1c3RpbmdGcmFtZXM6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIGFkanVzdGluZ0NhbWVyYTogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBwdWJsaWMgcGh5c2ljc0RlYnVnTW9kZTogUEhZU0lDU19ERUJVR01PREUgPSBQSFlTSUNTX0RFQlVHTU9ERS5OT05FO1xyXG5cclxuICAgIHB1YmxpYyBjb21wb25lbnRzUGljazogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50UGljaz4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcclxuXHJcbiAgICAjYnJhbmNoOiBOb2RlID0gbnVsbDsgLy8gVGhlIHRvIHJlbmRlciB3aXRoIGFsbCBpdHMgZGVzY2VuZGFudHMuXHJcbiAgICAjY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gbnVsbDtcclxuICAgICNjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gbnVsbDtcclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gRXZlbnRzIChwYXNzaW5nIGZyb20gY2FudmFzIHRvIHZpZXdwb3J0IGFuZCBmcm9tIHRoZXJlIGludG8gYnJhbmNoKVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2aWV3cG9ydCBjdXJyZW50bHkgaGFzIGZvY3VzIGFuZCB0aHVzIHJlY2VpdmVzIGtleWJvYXJkIGV2ZW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKFZpZXdwb3J0LmZvY3VzID09IHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhlIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBjYW52YXMgdG8gcmVuZGVyIHRoZSBnaXZlbiBicmFuY2ggdG8gdXNpbmcgdGhlIGdpdmVuIGNhbWVyYS1jb21wb25lbnQsIGFuZCBuYW1lcyB0aGUgdmlld3BvcnQgYXMgZ2l2ZW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplKF9uYW1lOiBzdHJpbmcsIF9icmFuY2g6IE5vZGUsIF9jYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuY2FtZXJhID0gX2NhbWVyYTtcclxuICAgICAgdGhpcy4jY2FudmFzID0gX2NhbnZhcztcclxuICAgICAgdGhpcy4jY3JjMiA9IF9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgdGhpcy5yZWN0U291cmNlID0gUmVuZGVyLmdldENhbnZhc1JlY3QoKTtcclxuICAgICAgdGhpcy5yZWN0RGVzdGluYXRpb24gPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG5cclxuICAgICAgdGhpcy5zZXRCcmFuY2goX2JyYW5jaCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBkZXN0aW5hdGlvbiBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjYW52YXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSAyRC1jb250ZXh0IGF0dGFjaGVkIHRvIHRoZSBkZXN0aW5hdGlvbiBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbnRleHQoKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2NyYzI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBzaXplIG9mIHRoZSBkZXN0aW5hdGlvbiBjYW52YXMgYXMgYSByZWN0YW5nbGUsIHggYW5kIHkgYXJlIGFsd2F5cyAwIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2FudmFzUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMuI2NhbnZhcy53aWR0aCwgdGhpcy4jY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBjbGllbnQgcmVjdGFuZ2xlIHRoZSBjYW52YXMgaXMgZGlzcGxheWVkIGFuZCBmaXQgaW4sIHggYW5kIHkgYXJlIGFsd2F5cyAwIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2xpZW50UmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIC8vIEZVREdFIGRvZXNuJ3QgY2FyZSBhYm91dCB3aGVyZSB0aGUgY2xpZW50IHJlY3QgaXMsIG9ubHkgYWJvdXQgdGhlIHNpemUgbWF0dGVycy5cclxuICAgICAgLy8gcmV0dXJuIFJlY3RhbmdsZS5HRVQodGhpcy5jYW52YXMub2Zmc2V0TGVmdCwgdGhpcy5jYW52YXMub2Zmc2V0VG9wLCB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCwgdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy4jY2FudmFzLmNsaWVudFdpZHRoLCB0aGlzLiNjYW52YXMuY2xpZW50SGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYnJhbmNoIHRvIGJlIGRyYXduIGluIHRoZSB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEJyYW5jaChfYnJhbmNoOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2hhdCB0aGUgZXZlbnQgaGFuZGxpbmcgd2FzIGNyZWF0ZWQgZm9yLiBEb2Vzbid0IGhhdmUgYW5vdGhlciBlZmZlY3QgdGhhbiBpbmZvcm1hdGlvbiBvbiB0aGUgY29uc29sZSAoZGVhY3RpdmF0ZWQpXHJcbiAgICAgIGlmICh0aGlzLiNicmFuY2gpIHtcclxuICAgICAgICB0aGlzLiNicmFuY2gucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgICB0aGlzLiNicmFuY2gucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZENvbXBvbmVudEV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLiNicmFuY2ggPSBfYnJhbmNoO1xyXG4gICAgICBpZiAodGhpcy4jYnJhbmNoKSB7XHJcbiAgICAgICAgdGhpcy4jYnJhbmNoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRDb21wb25lbnRFdmVudCk7XHJcbiAgICAgICAgdGhpcy4jYnJhbmNoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5obmRDb21wb25lbnRFdmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBicmFuY2ggdGhpcyB2aWV3cG9ydCByZW5kZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRCcmFuY2goKTogTm9kZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNicmFuY2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIHRoaXMgdmlld3BvcnRzIHNjZW5lZ3JhcGggdG8gdGhlIGNvbnNvbGUuXHJcbiAgICAgKiBUT0RPOiByZW1vdmUgdGhpcyBtZXRob2QsIHNpbmNlIGl0J3MgaW1wbGVtZW50ZWQgaW4gRGVidWdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3dTY2VuZUdyYXBoKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5icmFuY2godGhpcy4jYnJhbmNoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjcmVnaW9uIERyYXdpbmdcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHZpZXdwb3J0IGRpc3BsYXlpbmcgaXRzIGJyYW5jaC4gQnkgZGVmYXVsdCwgdGhlIHRyYW5zZm9ybXMgaW4gdGhlIGJyYW5jaCBhcmUgcmVjYWxjdWxhdGVkIGZpcnN0LlxyXG4gICAgICogUGFzcyBgZmFsc2VgIGlmIGNhbGN1bGF0aW9uIHdhcyBhbHJlYWR5IGRvbmUgZm9yIHRoaXMgZnJhbWUgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkcmF3KF9jYWxjdWxhdGVUcmFuc2Zvcm1zOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMuI2JyYW5jaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIFJlbmRlci5yZXNldEZyYW1lQnVmZmVyKCk7XHJcbiAgICAgIGlmICghdGhpcy5jYW1lcmEuaXNBY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdGcmFtZXMpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RGcmFtZXMoKTtcclxuICAgICAgaWYgKHRoaXMuYWRqdXN0aW5nQ2FtZXJhKVxyXG4gICAgICAgIHRoaXMuYWRqdXN0Q2FtZXJhKCk7XHJcblxyXG4gICAgICBpZiAoX2NhbGN1bGF0ZVRyYW5zZm9ybXMpXHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUcmFuc2Zvcm1zKCk7XHJcblxyXG4gICAgICBSZW5kZXIuY2xlYXIodGhpcy5jYW1lcmEuY2xyQmFja2dyb3VuZCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5waHlzaWNzRGVidWdNb2RlICE9IFBIWVNJQ1NfREVCVUdNT0RFLlBIWVNJQ19PQkpFQ1RTX09OTFkpXHJcbiAgICAgICAgUmVuZGVyLmRyYXcodGhpcy5jYW1lcmEpO1xyXG4gICAgICBpZiAodGhpcy5waHlzaWNzRGVidWdNb2RlICE9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkUpIHtcclxuICAgICAgICBQaHlzaWNzLmRyYXcodGhpcy5jYW1lcmEsIHRoaXMucGh5c2ljc0RlYnVnTW9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuI2NyYzIuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuI2NyYzIuZHJhd0ltYWdlKFxyXG4gICAgICAgIFJlbmRlci5nZXRDYW52YXMoKSxcclxuICAgICAgICB0aGlzLnJlY3RTb3VyY2UueCwgdGhpcy5yZWN0U291cmNlLnksIHRoaXMucmVjdFNvdXJjZS53aWR0aCwgdGhpcy5yZWN0U291cmNlLmhlaWdodCxcclxuICAgICAgICB0aGlzLnJlY3REZXN0aW5hdGlvbi54LCB0aGlzLnJlY3REZXN0aW5hdGlvbi55LCB0aGlzLnJlY3REZXN0aW5hdGlvbi53aWR0aCwgdGhpcy5yZWN0RGVzdGluYXRpb24uaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNhc2NhZGUgb2YgdHJhbnNmb3JtcyBpbiB0aGlzIGJyYW5jaCBhbmQgc3RvcmUgdGhlIHJlc3VsdHMgYXMgbXR4V29ybGQgaW4gdGhlIHtAbGluayBOb2RlfXMgYW5kIHtAbGluayBDb21wb25lbnRNZXNofWVzIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlVHJhbnNmb3JtcygpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJvb3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICBpZiAodGhpcy4jYnJhbmNoLmdldFBhcmVudCgpKVxyXG4gICAgICAgIG10eFJvb3QgPSB0aGlzLiNicmFuY2guZ2V0UGFyZW50KCkubXR4V29ybGQ7XHJcbiAgICAgIFJlbmRlci5wcmVwYXJlKHRoaXMuI2JyYW5jaCwgbnVsbCwgbXR4Um9vdCk7XHJcbiAgICAgIHRoaXMuY29tcG9uZW50c1BpY2sgPSBSZW5kZXIuY29tcG9uZW50c1BpY2s7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRpc3BhdGNoUG9pbnRlckV2ZW50KF9ldmVudDogUG9pbnRlckV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGxldCBwb3NDbGllbnQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihfZXZlbnQuY2xpZW50WCwgX2V2ZW50LmNsaWVudFkpO1xyXG4gICAgICBsZXQgcmF5OiBSYXkgPSB0aGlzLmdldFJheUZyb21DbGllbnQocG9zQ2xpZW50KTtcclxuICAgICAgLy8gbGV0IGNhbWVyYVBpY2tzOiBSZWN5Y2FibGVBcnJheTxOb2RlPiA9IFJlY3ljbGVyLmdldChSZWN5Y2FibGVBcnJheSk7IC8vVE9ETzogdGhpbmsgYWJvdXQgb3B0aW1pemF0aW9uIGxhdGVyXHJcbiAgICAgIGxldCBjYW1lcmFQaWNrczogTm9kZVtdID0gW107XHJcbiAgICAgIGxldCBvdGhlclBpY2tzOiBDb21wb25lbnRQaWNrW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgY21wUGljayBvZiB0aGlzLmNvbXBvbmVudHNQaWNrKVxyXG4gICAgICAgIGNtcFBpY2sucGljayA9PSBQSUNLLkNBTUVSQSA/IGNhbWVyYVBpY2tzLnB1c2goY21wUGljay5ub2RlKSA6IG90aGVyUGlja3MucHVzaChjbXBQaWNrKTtcclxuXHJcbiAgICAgIGlmIChjYW1lcmFQaWNrcy5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFBpY2tlci5waWNrQ2FtZXJhKGNhbWVyYVBpY2tzLCB0aGlzLmNhbWVyYSwgdGhpcy5wb2ludENsaWVudFRvUHJvamVjdGlvbihwb3NDbGllbnQpKTtcclxuICAgICAgICBmb3IgKGxldCBwaWNrIG9mIHBpY2tzKVxyXG4gICAgICAgICAgcGljay5ub2RlLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgY21wUGljayBvZiBvdGhlclBpY2tzKSB7XHJcbiAgICAgICAgY21wUGljay5waWNrQW5kRGlzcGF0Y2gocmF5LCBfZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3QgYWxsIGZyYW1lcyBpbnZvbHZlZCBpbiB0aGUgcmVuZGVyaW5nIHByb2Nlc3MgZnJvbSB0aGUgZGlzcGxheSBhcmVhIGluIHRoZSBjbGllbnQgdXAgdG8gdGhlIHJlbmRlcmVyIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0RnJhbWVzKCk6IHZvaWQge1xyXG4gICAgICAvLyBnZXQgdGhlIHJlY3RhbmdsZSBvZiB0aGUgY2FudmFzIGFyZWEgYXMgZGlzcGxheWVkIChjb25zaWRlciBjc3MpXHJcbiAgICAgIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGNhbnZhcyBzaXplIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnJhbWluZyBhcHBsaWVkIHRvIGNsaWVudFxyXG4gICAgICBsZXQgcmVjdENhbnZhczogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFJlY3QocmVjdENsaWVudCk7XHJcbiAgICAgIHRoaXMuI2NhbnZhcy53aWR0aCA9IHJlY3RDYW52YXMud2lkdGg7XHJcbiAgICAgIHRoaXMuI2NhbnZhcy5oZWlnaHQgPSByZWN0Q2FudmFzLmhlaWdodDtcclxuXHJcbiAgICAgIGxldCByZWN0VGVtcDogUmVjdGFuZ2xlO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGRlc3RpbmF0aW9uIGFyZWEgb24gdGhlIHRhcmdldC1jYW52YXMgdG8gcmVuZGVyIHRvIGJ5IGFwcGx5aW5nIHRoZSBmcmFtaW5nIHRvIGNhbnZhc1xyXG4gICAgICByZWN0VGVtcCA9IHRoaXMuZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uLmdldFJlY3QocmVjdENhbnZhcyk7XHJcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLmNvcHkocmVjdFRlbXApO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0VGVtcCk7XHJcbiAgICAgIC8vIGFkanVzdCB0aGUgYXJlYSBvbiB0aGUgc291cmNlLWNhbnZhcyB0byByZW5kZXIgZnJvbSBieSBhcHBseWluZyB0aGUgZnJhbWluZyB0byBkZXN0aW5hdGlvbiBhcmVhXHJcbiAgICAgIHJlY3RUZW1wID0gdGhpcy5mcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2UuZ2V0UmVjdCh0aGlzLnJlY3REZXN0aW5hdGlvbik7XHJcbiAgICAgIHRoaXMucmVjdFNvdXJjZS5jb3B5KHJlY3RUZW1wKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdFRlbXApO1xyXG5cclxuICAgICAgLy8gaGF2aW5nIGFuIG9mZnNldCBzb3VyY2UgZG9lcyBtYWtlIHNlbnNlIG9ubHkgd2hlbiBtdWx0aXBsZSB2aWV3cG9ydHMgZGlzcGxheSBwYXJ0cyBvZiB0aGUgc2FtZSByZW5kZXJpbmcuIEZvciBub3c6IHNoaWZ0IGl0IHRvIDAsMFxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UueCA9IHRoaXMucmVjdFNvdXJjZS55ID0gMDtcclxuICAgICAgLy8gc3RpbGwsIGEgcGFydGlhbCBpbWFnZSBvZiB0aGUgcmVuZGVyaW5nIG1heSBiZSByZXRyaWV2ZWQgYnkgbW92aW5nIGFuZCByZXNpemluZyB0aGUgcmVuZGVyIHZpZXdwb3J0LiBGb3Igbm93LCBpdCdzIGFsd2F5cyBhZGp1c3RlZCB0byB0aGUgY3VycmVudCB2aWV3cG9ydFxyXG4gICAgICBsZXQgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgUmVuZGVyLnNldFJlbmRlclJlY3RhbmdsZShyZWN0UmVuZGVyKTtcclxuICAgICAgLy8gbm8gbW9yZSB0cmFuc2Zvcm1hdGlvbiBhZnRlciB0aGlzIGZvciBub3csIG9mZnNjcmVlbiBjYW52YXMgYW5kIHJlbmRlci12aWV3cG9ydCBoYXZlIHRoZSBzYW1lIHNpemVcclxuICAgICAgUmVuZGVyLnNldENhbnZhc1NpemUocmVjdFJlbmRlci53aWR0aCwgcmVjdFJlbmRlci5oZWlnaHQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdENsaWVudCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlY3RDYW52YXMpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0UmVuZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IHRoZSBjYW1lcmEgcGFyYW1ldGVycyB0byBmaXQgdGhlIHJlbmRlcmluZyBpbnRvIHRoZSByZW5kZXIgdmllcG9ydFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0Q2FtZXJhKCk6IHZvaWQge1xyXG4gICAgICBsZXQgcmVjdDogUmVjdGFuZ2xlID0gUmVuZGVyLmdldFJlbmRlclJlY3RhbmdsZSgpO1xyXG4gICAgICB0aGlzLmNhbWVyYS5wcm9qZWN0Q2VudHJhbChcclxuICAgICAgICByZWN0LndpZHRoIC8gcmVjdC5oZWlnaHQsIHRoaXMuY2FtZXJhLmdldEZpZWxkT2ZWaWV3KCksIHRoaXMuY2FtZXJhLmdldERpcmVjdGlvbigpLCB0aGlzLmNhbWVyYS5nZXROZWFyKCksIHRoaXMuY2FtZXJhLmdldEZhcigpKTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUG9pbnRzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgUmF5fSBpbiB3b3JsZCBjb29yZGluYXRlcyBmcm9tIHRoaXMgY2FtZXJhIHRocm91Z2ggdGhlIHBvaW50IGdpdmVuIGluIGNsaWVudCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmF5RnJvbUNsaWVudChfcG9pbnQ6IFZlY3RvcjIpOiBSYXkge1xyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX3BvaW50KTtcclxuICAgICAgbGV0IHJheTogUmF5ID0gbmV3IFJheShuZXcgVmVjdG9yMygtcG9zUHJvamVjdGlvbi54LCBwb3NQcm9qZWN0aW9uLnksIDEpKTtcclxuXHJcbiAgICAgIC8vIHJheS5kaXJlY3Rpb24uc2NhbGUoY2FtZXJhLmRpc3RhbmNlKTtcclxuICAgICAgcmF5Lm9yaWdpbi50cmFuc2Zvcm0odGhpcy5jYW1lcmEubXR4UGl2b3QpO1xyXG4gICAgICByYXkuZGlyZWN0aW9uLnRyYW5zZm9ybSh0aGlzLmNhbWVyYS5tdHhQaXZvdCwgZmFsc2UpO1xyXG4gICAgICBsZXQgY2FtZXJhTm9kZTogTm9kZSA9IHRoaXMuY2FtZXJhLm5vZGU7XHJcbiAgICAgIGlmIChjYW1lcmFOb2RlKSB7XHJcbiAgICAgICAgcmF5Lm9yaWdpbi50cmFuc2Zvcm0oY2FtZXJhTm9kZS5tdHhXb3JsZCk7XHJcbiAgICAgICAgcmF5LmRpcmVjdGlvbi50cmFuc2Zvcm0oY2FtZXJhTm9kZS5tdHhXb3JsZCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIHByb2plY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFdvcmxkVG9DbGllbnQoX3Bvc2l0aW9uOiBWZWN0b3IzKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uOiBWZWN0b3IzID0gdGhpcy5jYW1lcmEucG9pbnRXb3JsZFRvQ2xpcChfcG9zaXRpb24pO1xyXG4gICAgICBsZXQgcG9zQ2xpZW50OiBWZWN0b3IyID0gdGhpcy5wb2ludENsaXBUb0NsaWVudChwcm9qZWN0aW9uLnRvVmVjdG9yMigpKTtcclxuICAgICAgcmV0dXJuIHBvc0NsaWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgc291cmNlLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9Tb3VyY2UoX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFBvaW50KF9jbGllbnQsIHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbi5nZXRQb2ludChyZXN1bHQsIHRoaXMuZ2V0Q2FudmFzUmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZS5nZXRQb2ludChyZXN1bHQsIHRoaXMucmVjdFNvdXJjZSk7XHJcbiAgICAgIC8vVE9ETzogd2hlbiBTb3VyY2UsIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBzb3VyY2UgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFNvdXJjZVRvUmVuZGVyKF9zb3VyY2U6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHByb2plY3Rpb25SZWN0YW5nbGU6IFJlY3RhbmdsZSA9IHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb25SZWN0YW5nbGUoKTtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFBvaW50KF9zb3VyY2UsIHByb2plY3Rpb25SZWN0YW5nbGUpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwcm9qZWN0aW9uUmVjdGFuZ2xlLnRvU3RyaW5nKCkpO1xyXG4gICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQ6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvU291cmNlKF9jbGllbnQpO1xyXG4gICAgICBwb2ludCA9IHRoaXMucG9pbnRTb3VyY2VUb1JlbmRlcihwb2ludCk7XHJcbiAgICAgIC8vVE9ETzogd2hlbiBSZW5kZXIgYW5kIFJlbmRlclZpZXdwb3J0IGRldmlhdGUsIGNvbnRpbnVlIHRyYW5zZm9ybWF0aW9uIFxyXG4gICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gYSBwcm9qZWN0aW9uIHN1cmZhY2UgaW4gdGhlIGh5cG90aGV0aWNhbCBkaXN0YW5jZSBvZiAxIHRvIHRoZSBjYW1lcmEgIFxyXG4gICAgICogbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGNhbWVyYS1tZXRob2QuIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXMgZm9yIGNlbnRyYWwtcHJvamVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9zUmVuZGVyOiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQpO1xyXG4gICAgICBsZXQgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgbGV0IHJlY3RQcm9qZWN0aW9uOiBSZWN0YW5nbGUgPSB0aGlzLmNhbWVyYS5nZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLndpZHRoICogcG9zUmVuZGVyLnggLyByZWN0UmVuZGVyLndpZHRoLFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAqIHBvc1JlbmRlci55IC8gcmVjdFJlbmRlci5oZWlnaHRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHBvc1Byb2plY3Rpb24uc3VidHJhY3QobmV3IFZlY3RvcjIocmVjdFByb2plY3Rpb24ud2lkdGggLyAyLCByZWN0UHJvamVjdGlvbi5oZWlnaHQgLyAyKSk7XHJcbiAgICAgIHBvc1Byb2plY3Rpb24ueSAqPSAtMTtcclxuXHJcbiAgICAgIHJldHVybiBwb3NQcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DbGllbnQoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICAvLyBsZXQgcmVjdENsaWVudDogUmVjdGFuZ2xlID0gdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKTtcclxuICAgICAgLy8gbGV0IHJlc3VsdDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDAuNSk7XHJcbiAgICAgIC8vIHJlc3VsdC54ICo9IChfbm9ybWVkLnggKyAxKSAqIHJlY3RDbGllbnQud2lkdGg7XHJcbiAgICAgIC8vIHJlc3VsdC55ICo9ICgxIC0gX25vcm1lZC55KSAqIHJlY3RDbGllbnQuaGVpZ2h0O1xyXG4gICAgICAvLyByZXN1bHQuYWRkKHJlY3RDbGllbnQucG9zaXRpb24pO1xyXG4gICAgICAvL1RPRE86IGNoZWNrIGlmIHJlY3REZXN0aW5hdGlvbiBjYW4gc2FmZWx5IChhbmQgbW9yZSBwZXJmb21hbnQpIGJlIHVzZWQgaW5zdGVhZCBnZXRDbGllbnRSZWN0YW5nbGVcclxuICAgICAgbGV0IHBvaW50Q2xpZW50OiBWZWN0b3IyID0gUmVuZGVyLnJlY3RDbGlwLnBvaW50VG9SZWN0KF9ub3JtZWQsIHRoaXMucmVjdERlc3RpbmF0aW9uKTtcclxuICAgICAgcmV0dXJuIHBvaW50Q2xpZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DYW52YXMoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9pbnRDYW52YXM6IFZlY3RvcjIgPSBSZW5kZXIucmVjdENsaXAucG9pbnRUb1JlY3QoX25vcm1lZCwgdGhpcy5nZXRDYW52YXNSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJldHVybiBwb2ludENhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBpbiB0aGUgYnJvd3NlciBwYWdlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9TY3JlZW4oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgc2NyZWVuOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIodGhpcy4jY2FudmFzLm9mZnNldExlZnQgKyBfY2xpZW50LngsIHRoaXMuI2NhbnZhcy5vZmZzZXRUb3AgKyBfY2xpZW50LnkpO1xyXG4gICAgICByZXR1cm4gc2NyZWVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoIHRoZSB2aWV3cG9ydHMgZm9jdXMgb24gb3Igb2ZmLiBPbmx5IG9uZSB2aWV3cG9ydCBpbiBvbmUgRlVER0UgaW5zdGFuY2UgY2FuIGhhdmUgdGhlIGZvY3VzLCB0aHVzIHJlY2VpdmluZyBrZXlib2FyZCBldmVudHMuIFxyXG4gICAgICogU28gYSB2aWV3cG9ydCBjdXJyZW50bHkgaGF2aW5nIHRoZSBmb2N1cyB3aWxsIGxvc2UgaXQsIHdoZW4gYW5vdGhlciBvbmUgcmVjZWl2ZXMgaXQuIFRoZSB2aWV3cG9ydHMgZmlyZSB7QGxpbmsgRXZlbnTGkn1zIGFjY29yZGluZ2x5LlxyXG4gICAgICogLy8gVE9ETzogZXhhbWluZSwgaWYgdGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmVndWxhciBET00tRm9jdXMgYW5kIHRhYmluZGV4PTBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEZvY3VzKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKSB7XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzID09IHRoaXMpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKFZpZXdwb3J0LmZvY3VzKVxyXG4gICAgICAgICAgVmlld3BvcnQuZm9jdXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfT1VUKSk7XHJcbiAgICAgICAgVmlld3BvcnQuZm9jdXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuRk9DVVNfSU4pKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZiAoVmlld3BvcnQuZm9jdXMgIT0gdGhpcylcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5GT0NVU19PVVQpKTtcclxuICAgICAgICBWaWV3cG9ydC5mb2N1cyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlcyB0aGUgZ2l2ZW4gcG9pbnRlciBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVQb2ludGVyRXZlbnQoX3R5cGU6IEVWRU5UX1BPSU5URVIsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy4jY2FudmFzLCBfdHlwZSwgdGhpcy5obmRQb2ludGVyRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZXMgdGhlIGdpdmVuIGtleWJvYXJkIGV2ZW50IHRvIGJlIHByb3BhZ2F0ZWQgaW50byB0aGUgdmlld3BvcnQgYXMgRlVER0UtRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlS2V5Ym9hcmRFdmVudChfdHlwZTogRVZFTlRfS0VZQk9BUkQsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy4jY2FudmFzLm93bmVyRG9jdW1lbnQsIF90eXBlLCB0aGlzLmhuZEtleWJvYXJkRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZXMgdGhlIGdpdmVuIGRyYWctZHJvcCBldmVudCB0byBiZSBwcm9wYWdhdGVkIGludG8gdGhlIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhY3RpdmF0ZURyYWdEcm9wRXZlbnQoX3R5cGU6IEVWRU5UX0RSQUdEUk9QLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF90eXBlID09IEVWRU5UX0RSQUdEUk9QLlNUQVJUKVxyXG4gICAgICAgIHRoaXMuI2NhbnZhcy5kcmFnZ2FibGUgPSBfb247XHJcbiAgICAgIHRoaXMuYWN0aXZhdGVFdmVudCh0aGlzLiNjYW52YXMsIF90eXBlLCB0aGlzLmhuZERyYWdEcm9wRXZlbnQsIF9vbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZXMgdGhlIHdoZWVsIGV2ZW50IHRvIGJlIHByb3BhZ2F0ZWQgaW50byB0aGUgdmlld3BvcnQgYXMgRlVER0UtRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlV2hlZWxFdmVudChfdHlwZTogRVZFTlRfV0hFRUwsIF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlRXZlbnQodGhpcy4jY2FudmFzLCBfdHlwZSwgdGhpcy5obmRXaGVlbEV2ZW50LCBfb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGRyYWctZHJvcCBldmVudHMgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kRHJhZ0Ryb3BFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGxldCBfZHJhZ2V2ZW50OiBFdmVudERyYWdEcm9wID0gPEV2ZW50RHJhZ0Ryb3A+X2V2ZW50O1xyXG4gICAgICBzd2l0Y2ggKF9kcmFnZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJkcmFnb3ZlclwiOlxyXG4gICAgICAgIGNhc2UgXCJkcm9wXCI6XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJub25lXCI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZHJhZ3N0YXJ0XCI6XHJcbiAgICAgICAgICAvLyBqdXN0IGR1bW15IGRhdGEsICB2YWxpZCBkYXRhIHNob3VsZCBiZSBzZXQgaW4gaGFuZGxlciByZWdpc3RlcmVkIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICBfZHJhZ2V2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dFwiLCBcIkhhbGxvXCIpO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSBiZXR0ZXIgc29sdXRpb24gdG8gaGlkZSB0aGUgZ2hvc3QgaW1hZ2Ugb2YgdGhlIGRyYWdnYWJsZSBvYmplY3RcclxuICAgICAgICAgIF9kcmFnZXZlbnQuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShuZXcgSW1hZ2UoKSwgMCwgMCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50RHJhZ0Ryb3AgPSBuZXcgRXZlbnREcmFnRHJvcChcIsaSXCIgKyBfZXZlbnQudHlwZSwgX2RyYWdldmVudCk7XHJcbiAgICAgIHRoaXMuYWRkQ2FudmFzUG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG1hcHBlZCB0byBjYW52YXMtY29vcmRpbmF0ZXMgYXMgY2FudmFzWCwgY2FudmFzWSB0byB0aGUgZXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhZGRDYW52YXNQb3NpdGlvbihldmVudDogRXZlbnRQb2ludGVyIHwgRXZlbnREcmFnRHJvcCk6IHZvaWQge1xyXG4gICAgICBldmVudC5jYW52YXNYID0gdGhpcy4jY2FudmFzLndpZHRoICogZXZlbnQucG9pbnRlclggLyBldmVudC5jbGllbnRSZWN0LndpZHRoO1xyXG4gICAgICBldmVudC5jYW52YXNZID0gdGhpcy4jY2FudmFzLmhlaWdodCAqIGV2ZW50LnBvaW50ZXJZIC8gZXZlbnQuY2xpZW50UmVjdC5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgcG9pbnRlciBldmVudHMgYW5kIGRpc3BhdGNoIHRvIHZpZXdwb3J0IGFzIEZVREdFLUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kUG9pbnRlckV2ZW50OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgbGV0IGV2ZW50OiBFdmVudFBvaW50ZXIgPSBuZXcgRXZlbnRQb2ludGVyKFwixpJcIiArIF9ldmVudC50eXBlLCA8RXZlbnRQb2ludGVyPl9ldmVudCk7XHJcbiAgICAgIHRoaXMuYWRkQ2FudmFzUG9zaXRpb24oZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIGtleWJvYXJkIGV2ZW50cyBhbmQgZGlzcGF0Y2ggdG8gdmlld3BvcnQgYXMgRlVER0UtRXZlbnQsIGlmIHRoZSB2aWV3cG9ydCBoYXMgdGhlIGZvY3VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kS2V5Ym9hcmRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNGb2N1cylcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBldmVudDogRXZlbnRLZXlib2FyZCA9IG5ldyBFdmVudEtleWJvYXJkKFwixpJcIiArIF9ldmVudC50eXBlLCA8RXZlbnRLZXlib2FyZD5fZXZlbnQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHdoZWVsIGV2ZW50IGFuZCBkaXNwYXRjaCB0byB2aWV3cG9ydCBhcyBGVURHRS1FdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZFdoZWVsRXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50V2hlZWwgPSBuZXcgRXZlbnRXaGVlbChcIsaSXCIgKyBfZXZlbnQudHlwZSwgPEV2ZW50V2hlZWw+X2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFjdGl2YXRlRXZlbnQoX3RhcmdldDogRXZlbnRUYXJnZXQsIF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyLCBfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgX3R5cGUgPSBfdHlwZS5zbGljZSgxKTsgLy8gY2hpcCB0aGUgxpJsb3JpblxyXG4gICAgICBpZiAoX29uKVxyXG4gICAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRDb21wb25lbnRFdmVudChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIC8vIFRPRE86IGZpbmQgb3V0IHdoYXQgdGhlIGlkZWEgd2FzIGhlcmUuLi5cclxuICAgICAgLy8gRGVidWcuZnVkZ2UoX2V2ZW50KTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBGaWxlbmFtZVRvQ29udGVudCB7XHJcbiAgICBbZmlsZW5hbWU6IHN0cmluZ106IHN0cmluZztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBmaWxlIHRyYW5zZmVyIGZyb20gYSBGdWRnZS1Ccm93c2VyYXBwIHRvIHRoZSBsb2NhbCBmaWxlc3lzdGVtIHdpdGhvdXQgYSBsb2NhbCBzZXJ2ZXIuICBcclxuICAgKiBTYXZlcyB0byB0aGUgZG93bmxvYWQtcGF0aCBnaXZlbiBieSB0aGUgYnJvd3NlciwgbG9hZHMgZnJvbSB0aGUgcGxheWVyJ3MgY2hvaWNlLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGaWxlSW9Ccm93c2VyTG9jYWwgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBzZWxlY3RvcjogSFRNTElucHV0RWxlbWVudDtcclxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfbXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcclxuICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IudHlwZSA9IFwiZmlsZVwiO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IubXVsdGlwbGUgPSBfbXVsdGlwbGU7XHJcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBGaWxlSW9Ccm93c2VyTG9jYWwuaGFuZGxlRmlsZVNlbGVjdCk7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxNYXBGaWxlbmFtZVRvQ29udGVudD4oX3Jlc29sdmUgPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhuZExvYWRlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX0xPQURFRCwgaG5kTG9hZGVkKTtcclxuICAgICAgICAgIF9yZXNvbHZlKCg8Q3VzdG9tRXZlbnQ+X2V2ZW50KS5kZXRhaWwubWFwRmlsZW5hbWVUb0NvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9MT0FERUQsIGhuZExvYWRlZCk7XHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmNsaWNrKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgIHB1YmxpYyBzdGF0aWMgc2F2ZShfdG9TYXZlOiBNYXBGaWxlbmFtZVRvQ29udGVudCwgX3R5cGU6IHN0cmluZyA9IFwidGV4dC9wbGFpblwiICk6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcclxuICAgICAgZm9yIChsZXQgZmlsZW5hbWUgaW4gX3RvU2F2ZSkge1xyXG4gICAgICAgIGxldCBjb250ZW50OiBzdHJpbmcgPSBfdG9TYXZlW2ZpbGVuYW1lXTtcclxuICAgICAgICBsZXQgYmxvYjogQmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwgeyB0eXBlOiBfdHlwZSB9KTtcclxuICAgICAgICBsZXQgdXJsOiBzdHJpbmcgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAvLyovIHVzaW5nIGFuY2hvciBlbGVtZW50IGZvciBkb3dubG9hZFxyXG4gICAgICAgIGxldCBkb3dubG9hZGVyOiBIVE1MQW5jaG9yRWxlbWVudDtcclxuICAgICAgICBkb3dubG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgZG93bmxvYWRlci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHVybCk7XHJcbiAgICAgICAgZG93bmxvYWRlci5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb3dubG9hZGVyKTtcclxuICAgICAgICBkb3dubG9hZGVyLmNsaWNrKCk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb3dubG9hZGVyKTtcclxuICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+KF9yZXNvbHZlID0+IHtcclxuICAgICAgICBfcmVzb2x2ZShfdG9TYXZlKTtcclxuICAgICAgICAvLyBmdW5jdGlvbiBobmRTYXZlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgLy8gICBGaWxlSW9Ccm93c2VyTG9jYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX1NBVkVELCBobmRTYXZlZCk7XHJcbiAgICAgICAgLy8gICBfcmVzb2x2ZSgoPEN1c3RvbUV2ZW50Pl9ldmVudCkuZGV0YWlsKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8vIEZpbGVJb0Jyb3dzZXJMb2NhbC5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkZJTEVfU0FWRUQsIGhuZFNhdmVkKTtcclxuICAgICAgICAvLyBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfU0FWRUQsIHsgZGV0YWlsOiB7IG1hcEZpbGVuYW1lVG9Db250ZW50OiBfdG9TYXZlIH0gfSk7XHJcbiAgICAgICAgLy8gRmlsZUlvQnJvd3NlckxvY2FsLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBoYW5kbGVGaWxlU2VsZWN0KF9ldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgRGVidWcuZnVkZ2UoXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoYW5kbGVGaWxlU2VsZWN0XCIpO1xyXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvcik7XHJcbiAgICAgIGxldCBmaWxlTGlzdDogRmlsZUxpc3QgPSAoPEhUTUxJbnB1dEVsZW1lbnQ+X2V2ZW50LnRhcmdldCkuZmlsZXM7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKGZpbGVMaXN0LCBmaWxlTGlzdC5sZW5ndGgpO1xyXG4gICAgICBpZiAoZmlsZUxpc3QubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGxvYWRlZDogTWFwRmlsZW5hbWVUb0NvbnRlbnQgPSB7fTtcclxuICAgICAgYXdhaXQgRmlsZUlvQnJvd3NlckxvY2FsLmxvYWRGaWxlcyhmaWxlTGlzdCwgbG9hZGVkKTtcclxuXHJcbiAgICAgIGxldCBldmVudDogQ3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuRklMRV9MT0FERUQsIHsgZGV0YWlsOiB7IG1hcEZpbGVuYW1lVG9Db250ZW50OiBsb2FkZWQgfSB9KTtcclxuICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRGaWxlcyhfZmlsZUxpc3Q6IEZpbGVMaXN0LCBfbG9hZGVkOiBNYXBGaWxlbmFtZVRvQ29udGVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBmb3IgKGxldCBmaWxlIG9mIF9maWxlTGlzdCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQ6IHN0cmluZyA9IGF3YWl0IG5ldyBSZXNwb25zZShmaWxlKS50ZXh0KCk7XHJcbiAgICAgICAgX2xvYWRlZFtmaWxlLm5hbWVdID0gY29udGVudDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSAiLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBNdXRhYmxlIGFycmF5IG9mIHtAbGluayBNdXRhYmxlfXMuIFRoZSB7QGxpbmsgTXV0YXRvcn1zIG9mIHRoZSBlbnRyaWVzIGFyZSBpbmNsdWRlZCBhcyBhcnJheSBpbiB0aGUge0BsaW5rIE11dGF0b3J9XHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNdXRhYmxlQXJyYXk8VCBleHRlbmRzIE11dGFibGU+IGV4dGVuZHMgQXJyYXk8VD4ge1xyXG4gICAgcHVibGljIHJlYXJyYW5nZShfc2VxdWVuY2U6IG51bWJlcltdKTogdm9pZCB7XHJcbiAgICAgIGxldCBsZW5ndGg6IG51bWJlciA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICBmb3IgKGxldCBpbmRleCBvZiBfc2VxdWVuY2UpIHtcclxuICAgICAgICBsZXQgb3JpZ2luYWw6IFQgPSB0aGlzW2luZGV4XTtcclxuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSwgY29weSBvbmx5IGRvdWJsZSBlbnRyaWVzXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IGNvcHk6IFQgPSBuZXcgb3JpZ2luYWwuY29uc3RydWN0b3IoKTtcclxuICAgICAgICBjb3B5Lm11dGF0ZShvcmlnaW5hbC5nZXRNdXRhdG9yKCkpO1xyXG4gICAgICAgIHRoaXMucHVzaChjb3B5KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNwbGljZSgwLCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpXHJcbiAgICAgICAgdHlwZXNbZW50cnldID0gdGhpc1tlbnRyeV0uY29uc3RydWN0b3IubmFtZTtcclxuXHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gdGhpcy5tYXAoKF92YWx1ZSkgPT4gX3ZhbHVlLmdldE11dGF0b3IoKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgZm9yIChsZXQgZW50cnkgaW4gdGhpcylcclxuICAgICAgICBhd2FpdCB0aGlzW2VudHJ5XS5tdXRhdGUoX211dGF0b3JbZW50cnldKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbXV0YXRvciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpIHtcclxuICAgICAgICBsZXQgbXV0YXRvclZhbHVlOiBPYmplY3QgPSBfbXV0YXRvcltlbnRyeV07XHJcbiAgICAgICAgaWYgKCFtdXRhdG9yVmFsdWUpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAodGhpc1tlbnRyeV0gaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgX211dGF0b3JbZW50cnldID0gdGhpc1tlbnRyeV0uZ2V0TXV0YXRvcigpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIF9tdXRhdG9yW2VudHJ5XSA9IHRoaXNbZW50cnldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gTU9ERSB7XHJcbiAgICBFRElUT1IsIFJVTlRJTUVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphYmxlUmVzb3VyY2UgZXh0ZW5kcyBTZXJpYWxpemFibGUge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG4gICAgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZXMge1xyXG4gICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IFNlcmlhbGl6YWJsZVJlc291cmNlO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMge1xyXG4gICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IFNlcmlhbGl6YXRpb247XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFNjcmlwdE5hbWVzcGFjZXMge1xyXG4gICAgW25hbWU6IHN0cmluZ106IE9iamVjdDtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50U2NyaXB0cyB7XHJcbiAgICBbbmFtZXNwYWNlOiBzdHJpbmddOiBDb21wb25lbnRTY3JpcHRbXTtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBHcmFwaEluc3RhbmNlc1RvUmVzeW5jIHtcclxuICAgIFtpZFJlc291cmNlOiBzdHJpbmddOiBHcmFwaEluc3RhbmNlW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGF0aWMgY2xhc3MgaGFuZGxpbmcgdGhlIHJlc291cmNlcyB1c2VkIHdpdGggdGhlIGN1cnJlbnQgRlVER0UtaW5zdGFuY2UuICBcclxuICAgKiBLZWVwcyBhIGxpc3Qgb2YgdGhlIHJlc291cmNlcyBhbmQgZ2VuZXJhdGVzIGlkcyB0byByZXRyaWV2ZSB0aGVtLiAgXHJcbiAgICogUmVzb3VyY2VzIGFyZSBvYmplY3RzIHJlZmVyZW5jZWQgbXVsdGlwbGUgdGltZXMgYnV0IHN1cHBvc2VkIHRvIGJlIHN0b3JlZCBvbmx5IG9uY2VcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUHJvamVjdCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlc291cmNlczogUmVzb3VyY2VzID0ge307XHJcbiAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyA9IHt9O1xyXG4gICAgcHVibGljIHN0YXRpYyBzY3JpcHROYW1lc3BhY2VzOiBTY3JpcHROYW1lc3BhY2VzID0ge307XHJcbiAgICBwdWJsaWMgc3RhdGljIGJhc2VVUkw6IFVSTCA9IG5ldyBVUkwobG9jYXRpb24udG9TdHJpbmcoKSk7XHJcbiAgICBwdWJsaWMgc3RhdGljIG1vZGU6IE1PREUgPSBNT0RFLlJVTlRJTUU7XHJcbiAgICBwdWJsaWMgc3RhdGljIGdyYXBoSW5zdGFuY2VzVG9SZXN5bmM6IEdyYXBoSW5zdGFuY2VzVG9SZXN5bmMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyB0aGUgcmVzb3VyY2UgYW5kIGdlbmVyYXRlcyBhbiBpZCBmb3IgaXQgYnkgZGVmYXVsdC4gIFxyXG4gICAgICogSWYgdGhlIHJlc291cmNlIGFscmVhZHkgaGFzIGFuIGlkLCB0aHVzIGhhdmluZyBiZWVuIHJlZ2lzdGVyZWQsIGl0cyBkZWxldGVkIGZyb20gdGhlIGxpc3QgYW5kIHJlZ2lzdGVyZWQgYW5ldy5cclxuICAgICAqIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbiBpZCwgYnV0IHNob3VsZCBub3QgYmUgZG9uZSBleGNlcHQgYnkgdGhlIFNlcmlhbGl6ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXIoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSwgX2lkUmVzb3VyY2U/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgaWYgKF9yZXNvdXJjZS5pZFJlc291cmNlKVxyXG4gICAgICAgIGlmIChfcmVzb3VyY2UuaWRSZXNvdXJjZSA9PSBfaWRSZXNvdXJjZSlcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLmRlcmVnaXN0ZXIoX3Jlc291cmNlKTtcclxuICAgICAgX3Jlc291cmNlLmlkUmVzb3VyY2UgPSBfaWRSZXNvdXJjZSB8fCBQcm9qZWN0LmdlbmVyYXRlSWQoX3Jlc291cmNlKTtcclxuICAgICAgUHJvamVjdC5yZXNvdXJjZXNbX3Jlc291cmNlLmlkUmVzb3VyY2VdID0gX3Jlc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVyZWdpc3RlcihfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSAoUHJvamVjdC5yZXNvdXJjZXNbX3Jlc291cmNlLmlkUmVzb3VyY2VdKTtcclxuICAgICAgZGVsZXRlIChQcm9qZWN0LnNlcmlhbGl6YXRpb25bX3Jlc291cmNlLmlkUmVzb3VyY2VdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICBQcm9qZWN0LnJlc291cmNlcyA9IHt9O1xyXG4gICAgICBQcm9qZWN0LnNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUW10ge1xyXG4gICAgLy8gICByZXR1cm4gPFRbXT4odGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXSB8fCBbXSkuc2xpY2UoMCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZXNvdXJjZXNPZlR5cGU8VD4oX3R5cGU6IG5ldyAoX2FyZ3M6IEdlbmVyYWwpID0+IFQpOiBSZXNvdXJjZXMge1xyXG4gICAgICBsZXQgZm91bmQ6IFJlc291cmNlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCByZXNvdXJjZUlkIGluIFByb2plY3QucmVzb3VyY2VzKSB7XHJcbiAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFByb2plY3QucmVzb3VyY2VzW3Jlc291cmNlSWRdO1xyXG4gICAgICAgIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIF90eXBlKVxyXG4gICAgICAgICAgZm91bmRbcmVzb3VyY2VJZF0gPSByZXNvdXJjZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSB1c2VyIHJlYWRhYmxlIGFuZCB1bmlxdWUgaWQgdXNpbmcgdGhlIHR5cGUgb2YgdGhlIHJlc291cmNlLCB0aGUgZGF0ZSBhbmQgcmFuZG9tIG51bWJlcnNcclxuICAgICAqIEBwYXJhbSBfcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZW5lcmF0ZUlkKF9yZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UpOiBzdHJpbmcge1xyXG4gICAgICAvLyBUT0RPOiBidWlsZCBpZCBhbmQgaW50ZWdyYXRlIGluZm8gZnJvbSByZXNvdXJjZSwgbm90IGp1c3QgZGF0ZVxyXG4gICAgICBsZXQgaWRSZXNvdXJjZTogc3RyaW5nO1xyXG4gICAgICBkb1xyXG4gICAgICAgIGlkUmVzb3VyY2UgPSBfcmVzb3VyY2UuY29uc3RydWN0b3IubmFtZSArIFwifFwiICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgXCJ8XCIgKyBNYXRoLnJhbmRvbSgpLnRvUHJlY2lzaW9uKDUpLnN1YnN0cigyLCA1KTtcclxuICAgICAgd2hpbGUgKFByb2plY3QucmVzb3VyY2VzW2lkUmVzb3VyY2VdKTtcclxuICAgICAgcmV0dXJuIGlkUmVzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cywgaWYgYW4gb2JqZWN0IGlzIGEge0BsaW5rIFNlcmlhbGl6YWJsZVJlc291cmNlfVxyXG4gICAgICogQHBhcmFtIF9vYmplY3QgVGhlIG9iamVjdCB0byBleGFtaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNSZXNvdXJjZShfb2JqZWN0OiBTZXJpYWxpemFibGUpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChSZWZsZWN0Lmhhcyhfb2JqZWN0LCBcImlkUmVzb3VyY2VcIikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSByZXNvdXJjZSBzdG9yZWQgd2l0aCB0aGUgZ2l2ZW4gaWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBnZXRSZXNvdXJjZShfaWRSZXNvdXJjZTogc3RyaW5nKTogUHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZT4ge1xyXG4gICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gUHJvamVjdC5yZXNvdXJjZXNbX2lkUmVzb3VyY2VdO1xyXG4gICAgICBpZiAoIXJlc291cmNlKSB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBQcm9qZWN0LnNlcmlhbGl6YXRpb25bX2lkUmVzb3VyY2VdO1xyXG4gICAgICAgIGlmICghc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgRGVidWcuZXJyb3IoXCJSZXNvdXJjZSBub3QgZm91bmRcIiwgX2lkUmVzb3VyY2UpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc291cmNlID0gYXdhaXQgUHJvamVjdC5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIHJlc291cmNlIGZyb20gYSB7QGxpbmsgTm9kZX0sIGNvcHlpbmcgdGhlIGNvbXBsZXRlIGdyYXBoIHN0YXJ0aW5nIHdpdGggaXRcclxuICAgICAqIEBwYXJhbSBfbm9kZSBBIG5vZGUgdG8gY3JlYXRlIHRoZSByZXNvdXJjZSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gX3JlcGxhY2VXaXRoSW5zdGFuY2UgaWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSBub2RlIHVzZWQgYXMgb3JpZ2luIGlzIHJlcGxhY2VkIGJ5IGEge0BsaW5rIEdyYXBoSW5zdGFuY2V9IG9mIHRoZSB7QGxpbmsgR3JhcGh9IGNyZWF0ZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyByZWdpc3RlckFzR3JhcGgoX25vZGU6IE5vZGUsIF9yZXBsYWNlV2l0aEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8R3JhcGg+IHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBfbm9kZS5zZXJpYWxpemUoKTtcclxuICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IG5ldyBHcmFwaChfbm9kZS5uYW1lKTtcclxuICAgICAgYXdhaXQgZ3JhcGguZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIoZ3JhcGgpO1xyXG5cclxuICAgICAgaWYgKF9yZXBsYWNlV2l0aEluc3RhbmNlICYmIF9ub2RlLmdldFBhcmVudCgpKSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlOiBHcmFwaEluc3RhbmNlID0gYXdhaXQgUHJvamVjdC5jcmVhdGVHcmFwaEluc3RhbmNlKGdyYXBoKTtcclxuICAgICAgICBfbm9kZS5nZXRQYXJlbnQoKS5yZXBsYWNlQ2hpbGQoX25vZGUsIGluc3RhbmNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlR3JhcGhJbnN0YW5jZShfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTxHcmFwaEluc3RhbmNlPiB7XHJcbiAgICAgIGxldCBpbnN0YW5jZTogR3JhcGhJbnN0YW5jZSA9IG5ldyBHcmFwaEluc3RhbmNlKCk7IC8vIFRPRE86IGNsZWFudXAgc2luY2UgY3JlYXRpb24gbW92ZWQgaGVyZVxyXG4gICAgICBhd2FpdCBpbnN0YW5jZS5zZXQoX2dyYXBoKTtcclxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJHcmFwaEluc3RhbmNlRm9yUmVzeW5jKF9pbnN0YW5jZTogR3JhcGhJbnN0YW5jZSk6IHZvaWQge1xyXG4gICAgICBsZXQgaW5zdGFuY2VzOiBHcmFwaEluc3RhbmNlW10gPSBQcm9qZWN0LmdyYXBoSW5zdGFuY2VzVG9SZXN5bmNbX2luc3RhbmNlLmlkU291cmNlXSB8fCBbXTtcclxuICAgICAgaW5zdGFuY2VzLnB1c2goX2luc3RhbmNlKTtcclxuICAgICAgUHJvamVjdC5ncmFwaEluc3RhbmNlc1RvUmVzeW5jW19pbnN0YW5jZS5pZFNvdXJjZV0gPSBpbnN0YW5jZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyByZXN5bmNHcmFwaEluc3RhbmNlcyhfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCBpbnN0YW5jZXM6IEdyYXBoSW5zdGFuY2VbXSA9IFByb2plY3QuZ3JhcGhJbnN0YW5jZXNUb1Jlc3luY1tfZ3JhcGguaWRSZXNvdXJjZV07XHJcbiAgICAgIGlmICghaW5zdGFuY2VzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgZm9yIChsZXQgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKVxyXG4gICAgICAgIGF3YWl0IGluc3RhbmNlLmNvbm5lY3RUb0dyYXBoKCk7XHJcbiAgICAgIGRlbGV0ZShQcm9qZWN0LmdyYXBoSW5zdGFuY2VzVG9SZXN5bmNbX2dyYXBoLmlkUmVzb3VyY2VdKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyU2NyaXB0TmFtZXNwYWNlKF9uYW1lc3BhY2U6IE9iamVjdCk6IHZvaWQge1xyXG4gICAgICBsZXQgbmFtZTogc3RyaW5nID0gU2VyaWFsaXplci5yZWdpc3Rlck5hbWVzcGFjZShfbmFtZXNwYWNlKTtcclxuICAgICAgaWYgKCFQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZV0pXHJcbiAgICAgICAgUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzW25hbWVdID0gX25hbWVzcGFjZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvbXBvbmVudFNjcmlwdHMoKTogQ29tcG9uZW50U2NyaXB0cyB7XHJcbiAgICAgIGxldCBjb21wb21lbnRzOiBDb21wb25lbnRTY3JpcHRzID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWVzcGFjZSBpbiBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXMpIHtcclxuICAgICAgICBjb21wb21lbnRzW25hbWVzcGFjZV0gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lc3BhY2VdKSB7XHJcbiAgICAgICAgICBsZXQgc2NyaXB0OiBDb21wb25lbnRTY3JpcHQgPSBSZWZsZWN0LmdldChQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZXNwYWNlXSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgLy8gaXMgc2NyaXB0IGEgc3ViY2xhc3Mgb2YgQ29tcG9uZW50U2NyaXB0PyBpbnN0YW5jZW9mIGRvZXNuJ3Qgd29yaywgc2luY2Ugbm8gaW5zdGFuY2UgaXMgY3JlYXRlZFxyXG5cclxuICAgICAgICAgIC8vIGxldCBzdXBlcmNsYXNzOiBPYmplY3QgPSBzY3JpcHQ7XHJcbiAgICAgICAgICAvLyB3aGlsZSAoc3VwZXJjbGFzcykge1xyXG4gICAgICAgICAgLy8gICBzdXBlcmNsYXNzID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzdXBlcmNsYXNzKTtcclxuICAgICAgICAgIC8vICAgaWYgKHN1cGVyY2xhc3MgPT0gQ29tcG9uZW50U2NyaXB0KSB7XHJcbiAgICAgICAgICAvLyAgICAgc2NyaXB0cy5wdXNoKHNjcmlwdCk7XHJcbiAgICAgICAgICAvLyAgICAgYnJlYWs7XHJcbiAgICAgICAgICAvLyAgIH1cclxuICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgICAvLyBVc2luZyBPYmplY3QuY3JlYXRlIGRvZXNuJ3QgY2FsbCB0aGUgY29uc3RydWN0b3IsIGJ1dCBpbnN0YW5jZW9mIGNhbiBiZSB1c2VkLiBNb3JlIGVsZWdhbnQgdGhhbiB0aGUgbG9vcCBhYm92ZSwgdGhvdWdoIG1heWJlIG5vdCBhcyBwZXJmb3JtYW50LiBcclxuICAgICAgICAgIGxldCBvOiBHZW5lcmFsID0gT2JqZWN0LmNyZWF0ZShzY3JpcHQpO1xyXG4gICAgICAgICAgaWYgKG8ucHJvdG90eXBlIGluc3RhbmNlb2YgQ29tcG9uZW50U2NyaXB0KVxyXG4gICAgICAgICAgICBjb21wb21lbnRzW25hbWVzcGFjZV0ucHVzaChzY3JpcHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29tcG9tZW50cztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRTY3JpcHQoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IHNjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcbiAgICAgIC8vIHNjcmlwdC50eXBlID0gXCJtb2R1bGVcIjtcclxuICAgICAgc2NyaXB0LmFzeW5jID0gZmFsc2U7XHJcbiAgICAgIC8vIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBoYW5kbGVMb2FkZWRTY3JpcHQpXHJcbiAgICAgIGxldCBoZWFkOiBIVE1MSGVhZEVsZW1lbnQgPSBkb2N1bWVudC5oZWFkO1xyXG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICAgIERlYnVnLmxvZyhcIkxvYWRpbmc6IFwiLCBfdXJsKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHJlc29sdmUoKSk7XHJcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihcIkxvYWRpbmcgc2NyaXB0XCIsIF91cmwpO1xyXG4gICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2NyaXB0LnNyYyA9IF91cmwudG9TdHJpbmcoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkUmVzb3VyY2VzKF91cmw6IFJlcXVlc3RJbmZvKTogUHJvbWlzZTxSZXNvdXJjZXM+IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goX3VybCk7XHJcbiAgICAgIGNvbnN0IHJlc291cmNlRmlsZUNvbnRlbnQ6IHN0cmluZyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gU2VyaWFsaXplci5wYXJzZShyZXNvdXJjZUZpbGVDb250ZW50KTtcclxuICAgICAgbGV0IHJlY29uc3RydWN0aW9uOiBSZXNvdXJjZXMgPSBhd2FpdCBQcm9qZWN0LmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gcmVjb25zdHJ1Y3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkUmVzb3VyY2VzRnJvbUhUTUwoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGNvbnN0IGhlYWQ6IEhUTUxIZWFkRWxlbWVudCA9IGRvY3VtZW50LmhlYWQ7XHJcbiAgICAgIGxldCBsaW5rczogTm9kZUxpc3RPZjxIVE1MTGlua0VsZW1lbnQ+ID0gaGVhZC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1t0eXBlPXJlc291cmNlc11cIik7XHJcbiAgICAgIGZvciAobGV0IGxpbmsgb2YgbGlua3MpIHtcclxuICAgICAgICBsZXQgdXJsOiBSZXF1ZXN0SW5mbyA9IGxpbmsuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xyXG4gICAgICAgIGF3YWl0IFByb2plY3QubG9hZFJlc291cmNlcyh1cmwpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJpYWxpemUgYWxsIHJlc291cmNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzID0ge307XHJcbiAgICAgIGZvciAobGV0IGlkUmVzb3VyY2UgaW4gUHJvamVjdC5yZXNvdXJjZXMpIHtcclxuICAgICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gUHJvamVjdC5yZXNvdXJjZXNbaWRSZXNvdXJjZV07XHJcbiAgICAgICAgaWYgKGlkUmVzb3VyY2UgIT0gcmVzb3VyY2UuaWRSZXNvdXJjZSlcclxuICAgICAgICAgIERlYnVnLmVycm9yKFwiUmVzb3VyY2UtaWQgbWlzbWF0Y2hcIiwgcmVzb3VyY2UpO1xyXG4gICAgICAgIHNlcmlhbGl6YXRpb25baWRSZXNvdXJjZV0gPSBTZXJpYWxpemVyLnNlcmlhbGl6ZShyZXNvdXJjZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgcmVzb3VyY2VzIGZyb20gYSBzZXJpYWxpemF0aW9uLCBkZWxldGluZyBhbGwgcmVzb3VyY2VzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZFxyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMpOiBQcm9taXNlPFJlc291cmNlcz4ge1xyXG4gICAgICBQcm9qZWN0LnNlcmlhbGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbjtcclxuICAgICAgUHJvamVjdC5yZXNvdXJjZXMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgaWRSZXNvdXJjZSBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb25baWRSZXNvdXJjZV07XHJcbiAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IGF3YWl0IFByb2plY3QuZGVzZXJpYWxpemVSZXNvdXJjZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICBpZiAocmVzb3VyY2UpXHJcbiAgICAgICAgICBQcm9qZWN0LnJlc291cmNlc1tpZFJlc291cmNlXSA9IHJlc291cmNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBQcm9qZWN0LnJlc291cmNlcztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZVJlc291cmNlKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZT4ge1xyXG4gICAgICByZXR1cm4gPFByb21pc2U8U2VyaWFsaXphYmxlUmVzb3VyY2U+PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBHTFRGIHtcclxuICBleHBvcnQgdHlwZSBHbFRmSWQgPSBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogQW4gb2JqZWN0IHBvaW50aW5nIHRvIGEgYnVmZmVyIHZpZXcgY29udGFpbmluZyB0aGUgaW5kaWNlcyBvZiBkZXZpYXRpbmcgYWNjZXNzb3IgdmFsdWVzLiBUaGUgbnVtYmVyIG9mIGluZGljZXMgaXMgZXF1YWwgdG8gYGFjY2Vzc29yLnNwYXJzZS5jb3VudGAuIEluZGljZXMgKipNVVNUKiogc3RyaWN0bHkgaW5jcmVhc2UuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBY2Nlc3NvclNwYXJzZUluZGljZXMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGJ1ZmZlciB2aWV3IHdpdGggc3BhcnNlIGluZGljZXMuIFRoZSByZWZlcmVuY2VkIGJ1ZmZlciB2aWV3ICoqTVVTVCBOT1QqKiBoYXZlIGl0cyBgdGFyZ2V0YCBvciBgYnl0ZVN0cmlkZWAgcHJvcGVydGllcyBkZWZpbmVkLiBUaGUgYnVmZmVyIHZpZXcgYW5kIHRoZSBvcHRpb25hbCBgYnl0ZU9mZnNldGAgKipNVVNUKiogYmUgYWxpZ25lZCB0byB0aGUgYGNvbXBvbmVudFR5cGVgIGJ5dGUgbGVuZ3RoLlxyXG4gICAgICovXHJcbiAgICBcImJ1ZmZlclZpZXdcIjogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIHZpZXcgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIFwiYnl0ZU9mZnNldFwiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kaWNlcyBkYXRhIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIFwiY29tcG9uZW50VHlwZVwiOiBudW1iZXIgfCBudW1iZXIgfCBudW1iZXIgfCBudW1iZXI7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBbiBvYmplY3QgcG9pbnRpbmcgdG8gYSBidWZmZXIgdmlldyBjb250YWluaW5nIHRoZSBkZXZpYXRpbmcgYWNjZXNzb3IgdmFsdWVzLiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIGVxdWFsIHRvIGBhY2Nlc3Nvci5zcGFyc2UuY291bnRgIHRpbWVzIG51bWJlciBvZiBjb21wb25lbnRzLiBUaGUgZWxlbWVudHMgaGF2ZSB0aGUgc2FtZSBjb21wb25lbnQgdHlwZSBhcyB0aGUgYmFzZSBhY2Nlc3Nvci4gVGhlIGVsZW1lbnRzIGFyZSB0aWdodGx5IHBhY2tlZC4gRGF0YSAqKk1VU1QqKiBiZSBhbGlnbmVkIGZvbGxvd2luZyB0aGUgc2FtZSBydWxlcyBhcyB0aGUgYmFzZSBhY2Nlc3Nvci5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yU3BhcnNlVmFsdWVzIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXJWaWV3IHdpdGggc3BhcnNlIHZhbHVlcy4gVGhlIHJlZmVyZW5jZWQgYnVmZmVyIHZpZXcgKipNVVNUIE5PVCoqIGhhdmUgaXRzIGB0YXJnZXRgIG9yIGBieXRlU3RyaWRlYCBwcm9wZXJ0aWVzIGRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwiYnVmZmVyVmlld1wiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXJWaWV3IGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVPZmZzZXRcIj86IG51bWJlcjtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNwYXJzZSBzdG9yYWdlIG9mIGFjY2Vzc29yIHZhbHVlcyB0aGF0IGRldmlhdGUgZnJvbSB0aGVpciBpbml0aWFsaXphdGlvbiB2YWx1ZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yU3BhcnNlIHtcclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMgc3RvcmVkIGluIHRoZSBzcGFyc2UgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIFwiY291bnRcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgcG9pbnRpbmcgdG8gYSBidWZmZXIgdmlldyBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuIFRoZSBudW1iZXIgb2YgaW5kaWNlcyBpcyBlcXVhbCB0byBgY291bnRgLiBJbmRpY2VzICoqTVVTVCoqIHN0cmljdGx5IGluY3JlYXNlLlxyXG4gICAgICovXHJcbiAgICBcImluZGljZXNcIjogQWNjZXNzb3JTcGFyc2VJbmRpY2VzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgcG9pbnRpbmcgdG8gYSBidWZmZXIgdmlldyBjb250YWluaW5nIHRoZSBkZXZpYXRpbmcgYWNjZXNzb3IgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBcInZhbHVlc1wiOiBBY2Nlc3NvclNwYXJzZVZhbHVlcztcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgdHlwZWQgdmlldyBpbnRvIGEgYnVmZmVyIHZpZXcgdGhhdCBjb250YWlucyByYXcgYmluYXJ5IGRhdGEuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBY2Nlc3NvciB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYnVmZmVyVmlldy5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3XCI/OiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgdmlldyBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgXCJieXRlT2Zmc2V0XCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYXRhdHlwZSBvZiB0aGUgYWNjZXNzb3IncyBjb21wb25lbnRzLlxyXG4gICAgICovXHJcbiAgICBcImNvbXBvbmVudFR5cGVcIjogbnVtYmVyIHwgbnVtYmVyIHwgbnVtYmVyIHwgbnVtYmVyIHwgbnVtYmVyIHwgbnVtYmVyIHwgbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBpbnRlZ2VyIGRhdGEgdmFsdWVzIGFyZSBub3JtYWxpemVkIGJlZm9yZSB1c2FnZS5cclxuICAgICAqL1xyXG4gICAgXCJub3JtYWxpemVkXCI/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlZmVyZW5jZWQgYnkgdGhpcyBhY2Nlc3Nvci5cclxuICAgICAqL1xyXG4gICAgXCJjb3VudFwiOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBpZiB0aGUgYWNjZXNzb3IncyBlbGVtZW50cyBhcmUgc2NhbGFycywgdmVjdG9ycywgb3IgbWF0cmljZXMuXHJcbiAgICAgKi9cclxuICAgIFwidHlwZVwiOiBhbnkgfCBhbnkgfCBhbnkgfCBhbnkgfCBhbnkgfCBhbnkgfCBhbnkgfCBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gdmFsdWUgb2YgZWFjaCBjb21wb25lbnQgaW4gdGhpcyBhY2Nlc3Nvci5cclxuICAgICAqL1xyXG4gICAgXCJtYXhcIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNaW5pbXVtIHZhbHVlIG9mIGVhY2ggY29tcG9uZW50IGluIHRoaXMgYWNjZXNzb3IuXHJcbiAgICAgKi9cclxuICAgIFwibWluXCI/OiBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICogU3BhcnNlIHN0b3JhZ2Ugb2YgZWxlbWVudHMgdGhhdCBkZXZpYXRlIGZyb20gdGhlaXIgaW5pdGlhbGl6YXRpb24gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIFwic3BhcnNlXCI/OiBBY2Nlc3NvclNwYXJzZTtcclxuICAgIFwibmFtZVwiPzogYW55O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhlIGRlc2NyaXB0b3Igb2YgdGhlIGFuaW1hdGVkIHByb3BlcnR5LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uQ2hhbm5lbFRhcmdldCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBhbmltYXRlLiBXaGVuIHVuZGVmaW5lZCwgdGhlIGFuaW1hdGVkIG9iamVjdCAqKk1BWSoqIGJlIGRlZmluZWQgYnkgYW4gZXh0ZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBcIm5vZGVcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG5vZGUncyBUUlMgcHJvcGVydHkgdG8gYW5pbWF0ZSwgb3IgdGhlIGBcIndlaWdodHNcImAgb2YgdGhlIE1vcnBoIFRhcmdldHMgaXQgaW5zdGFudGlhdGVzLiBGb3IgdGhlIGBcInRyYW5zbGF0aW9uXCJgIHByb3BlcnR5LCB0aGUgdmFsdWVzIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSBzYW1wbGVyIGFyZSB0aGUgdHJhbnNsYXRpb24gYWxvbmcgdGhlIFgsIFksIGFuZCBaIGF4ZXMuIEZvciB0aGUgYFwicm90YXRpb25cImAgcHJvcGVydHksIHRoZSB2YWx1ZXMgYXJlIGEgcXVhdGVybmlvbiBpbiB0aGUgb3JkZXIgKHgsIHksIHosIHcpLCB3aGVyZSB3IGlzIHRoZSBzY2FsYXIuIEZvciB0aGUgYFwic2NhbGVcImAgcHJvcGVydHksIHRoZSB2YWx1ZXMgYXJlIHRoZSBzY2FsaW5nIGZhY3RvcnMgYWxvbmcgdGhlIFgsIFksIGFuZCBaIGF4ZXMuXHJcbiAgICAgKi9cclxuICAgIFwicGF0aFwiOiBhbnkgfCBhbnkgfCBhbnkgfCBhbnkgfCBzdHJpbmc7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBbiBhbmltYXRpb24gY2hhbm5lbCBjb21iaW5lcyBhbiBhbmltYXRpb24gc2FtcGxlciB3aXRoIGEgdGFyZ2V0IHByb3BlcnR5IGJlaW5nIGFuaW1hdGVkLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uQ2hhbm5lbCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiBhIHNhbXBsZXIgaW4gdGhpcyBhbmltYXRpb24gdXNlZCB0byBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgXCJzYW1wbGVyXCI6IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlc2NyaXB0b3Igb2YgdGhlIGFuaW1hdGVkIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBcInRhcmdldFwiOiBBbmltYXRpb25DaGFubmVsVGFyZ2V0O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQW4gYW5pbWF0aW9uIHNhbXBsZXIgY29tYmluZXMgdGltZXN0YW1wcyB3aXRoIGEgc2VxdWVuY2Ugb2Ygb3V0cHV0IHZhbHVlcyBhbmQgZGVmaW5lcyBhbiBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblNhbXBsZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgYW4gYWNjZXNzb3IgY29udGFpbmluZyBrZXlmcmFtZSB0aW1lc3RhbXBzLlxyXG4gICAgICovXHJcbiAgICBcImlucHV0XCI6IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJwb2xhdGlvbiBhbGdvcml0aG0uXHJcbiAgICAgKi9cclxuICAgIFwiaW50ZXJwb2xhdGlvblwiPzogYW55IHwgYW55IHwgYW55IHwgc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgYW4gYWNjZXNzb3IsIGNvbnRhaW5pbmcga2V5ZnJhbWUgb3V0cHV0IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgXCJvdXRwdXRcIjogR2xUZklkO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBrZXlmcmFtZSBhbmltYXRpb24uXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBhbmltYXRpb24gY2hhbm5lbHMuIEFuIGFuaW1hdGlvbiBjaGFubmVsIGNvbWJpbmVzIGFuIGFuaW1hdGlvbiBzYW1wbGVyIHdpdGggYSB0YXJnZXQgcHJvcGVydHkgYmVpbmcgYW5pbWF0ZWQuIERpZmZlcmVudCBjaGFubmVscyBvZiB0aGUgc2FtZSBhbmltYXRpb24gKipNVVNUIE5PVCoqIGhhdmUgdGhlIHNhbWUgdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgXCJjaGFubmVsc1wiOiBBbmltYXRpb25DaGFubmVsW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGFuaW1hdGlvbiBzYW1wbGVycy4gQW4gYW5pbWF0aW9uIHNhbXBsZXIgY29tYmluZXMgdGltZXN0YW1wcyB3aXRoIGEgc2VxdWVuY2Ugb2Ygb3V0cHV0IHZhbHVlcyBhbmQgZGVmaW5lcyBhbiBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobS5cclxuICAgICAqL1xyXG4gICAgXCJzYW1wbGVyc1wiOiBBbmltYXRpb25TYW1wbGVyW107XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE1ldGFkYXRhIGFib3V0IHRoZSBnbFRGIGFzc2V0LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQXNzZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvcHlyaWdodCBtZXNzYWdlIHN1aXRhYmxlIGZvciBkaXNwbGF5IHRvIGNyZWRpdCB0aGUgY29udGVudCBjcmVhdG9yLlxyXG4gICAgICovXHJcbiAgICBcImNvcHlyaWdodFwiPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUb29sIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZ2xURiBtb2RlbC4gIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxyXG4gICAgICovXHJcbiAgICBcImdlbmVyYXRvclwiPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ2xURiB2ZXJzaW9uIGluIHRoZSBmb3JtIG9mIGA8bWFqb3I+LjxtaW5vcj5gIHRoYXQgdGhpcyBhc3NldCB0YXJnZXRzLlxyXG4gICAgICovXHJcbiAgICBcInZlcnNpb25cIjogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWluaW11bSBnbFRGIHZlcnNpb24gaW4gdGhlIGZvcm0gb2YgYDxtYWpvcj4uPG1pbm9yPmAgdGhhdCB0aGlzIGFzc2V0IHRhcmdldHMuIFRoaXMgcHJvcGVydHkgKipNVVNUIE5PVCoqIGJlIGdyZWF0ZXIgdGhhbiB0aGUgYXNzZXQgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgXCJtaW5WZXJzaW9uXCI/OiBzdHJpbmc7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIGJ1ZmZlciBwb2ludHMgdG8gYmluYXJ5IGdlb21ldHJ5LCBhbmltYXRpb24sIG9yIHNraW5zLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFVSSSAob3IgSVJJKSBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBcInVyaVwiPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIFwiYnl0ZUxlbmd0aFwiOiBudW1iZXI7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgdmlldyBpbnRvIGEgYnVmZmVyIGdlbmVyYWxseSByZXByZXNlbnRpbmcgYSBzdWJzZXQgb2YgdGhlIGJ1ZmZlci5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEJ1ZmZlclZpZXcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJcIjogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb2Zmc2V0IGludG8gdGhlIGJ1ZmZlciBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgXCJieXRlT2Zmc2V0XCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlclZpZXcgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIFwiYnl0ZUxlbmd0aFwiOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJpZGUsIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVTdHJpZGVcIj86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhpbnQgcmVwcmVzZW50aW5nIHRoZSBpbnRlbmRlZCBHUFUgYnVmZmVyIHR5cGUgdG8gdXNlIHdpdGggdGhpcyBidWZmZXIgdmlldy5cclxuICAgICAqL1xyXG4gICAgXCJ0YXJnZXRcIj86IG51bWJlciB8IG51bWJlciB8IG51bWJlcjtcclxuICAgIFwibmFtZVwiPzogYW55O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQW4gb3J0aG9ncmFwaGljIGNhbWVyYSBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY3JlYXRlIGFuIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIENhbWVyYU9ydGhvZ3JhcGhpYyB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCBob3Jpem9udGFsIG1hZ25pZmljYXRpb24gb2YgdGhlIHZpZXcuIFRoaXMgdmFsdWUgKipNVVNUIE5PVCoqIGJlIGVxdWFsIHRvIHplcm8uIFRoaXMgdmFsdWUgKipTSE9VTEQgTk9UKiogYmUgbmVnYXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFwieG1hZ1wiOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCB2ZXJ0aWNhbCBtYWduaWZpY2F0aW9uIG9mIHRoZSB2aWV3LiBUaGlzIHZhbHVlICoqTVVTVCBOT1QqKiBiZSBlcXVhbCB0byB6ZXJvLiBUaGlzIHZhbHVlICoqU0hPVUxEIE5PVCoqIGJlIG5lZ2F0aXZlLlxyXG4gICAgICovXHJcbiAgICBcInltYWdcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgZGlzdGFuY2UgdG8gdGhlIGZhciBjbGlwcGluZyBwbGFuZS4gVGhpcyB2YWx1ZSAqKk1VU1QgTk9UKiogYmUgZXF1YWwgdG8gemVyby4gYHpmYXJgICoqTVVTVCoqIGJlIGdyZWF0ZXIgdGhhbiBgem5lYXJgLlxyXG4gICAgICovXHJcbiAgICBcInpmYXJcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgZGlzdGFuY2UgdG8gdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXHJcbiAgICAgKi9cclxuICAgIFwiem5lYXJcIjogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBwZXJzcGVjdGl2ZSBjYW1lcmEgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2FtZXJhUGVyc3BlY3RpdmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgYXNwZWN0IHJhdGlvIG9mIHRoZSBmaWVsZCBvZiB2aWV3LlxyXG4gICAgICovXHJcbiAgICBcImFzcGVjdFJhdGlvXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnMuIFRoaXMgdmFsdWUgKipTSE9VTEQqKiBiZSBsZXNzIHRoYW4gz4AuXHJcbiAgICAgKi9cclxuICAgIFwieWZvdlwiOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCBkaXN0YW5jZSB0byB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxyXG4gICAgICovXHJcbiAgICBcInpmYXJcIj86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGRpc3RhbmNlIHRvIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxyXG4gICAgICovXHJcbiAgICBcInpuZWFyXCI6IG51bWJlcjtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgY2FtZXJhJ3MgcHJvamVjdGlvbi4gIEEgbm9kZSAqKk1BWSoqIHJlZmVyZW5jZSBhIGNhbWVyYSB0byBhcHBseSBhIHRyYW5zZm9ybSB0byBwbGFjZSB0aGUgY2FtZXJhIGluIHRoZSBzY2VuZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIENhbWVyYSB7XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9ydGhvZ3JhcGhpYyBjYW1lcmEgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhbiBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguIFRoaXMgcHJvcGVydHkgKipNVVNUIE5PVCoqIGJlIGRlZmluZWQgd2hlbiBgcGVyc3BlY3RpdmVgIGlzIGRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwib3J0aG9ncmFwaGljXCI/OiBDYW1lcmFPcnRob2dyYXBoaWM7XHJcbiAgICAvKipcclxuICAgICAqIEEgcGVyc3BlY3RpdmUgY2FtZXJhIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjcmVhdGUgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC4gVGhpcyBwcm9wZXJ0eSAqKk1VU1QgTk9UKiogYmUgZGVmaW5lZCB3aGVuIGBvcnRob2dyYXBoaWNgIGlzIGRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwicGVyc3BlY3RpdmVcIj86IENhbWVyYVBlcnNwZWN0aXZlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGNhbWVyYSB1c2VzIGEgcGVyc3BlY3RpdmUgb3Igb3J0aG9ncmFwaGljIHByb2plY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIFwidHlwZVwiOiBhbnkgfCBhbnkgfCBzdHJpbmc7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEltYWdlIGRhdGEgdXNlZCB0byBjcmVhdGUgYSB0ZXh0dXJlLiBJbWFnZSAqKk1BWSoqIGJlIHJlZmVyZW5jZWQgYnkgYW4gVVJJIChvciBJUkkpIG9yIGEgYnVmZmVyIHZpZXcgaW5kZXguXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBVUkkgKG9yIElSSSkgb2YgdGhlIGltYWdlLlxyXG4gICAgICovXHJcbiAgICBcInVyaVwiPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW1hZ2UncyBtZWRpYSB0eXBlLiBUaGlzIGZpZWxkICoqTVVTVCoqIGJlIGRlZmluZWQgd2hlbiBgYnVmZmVyVmlld2AgaXMgZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgXCJtaW1lVHlwZVwiPzogYW55IHwgYW55IHwgc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGJ1ZmZlclZpZXcgdGhhdCBjb250YWlucyB0aGUgaW1hZ2UuIFRoaXMgZmllbGQgKipNVVNUIE5PVCoqIGJlIGRlZmluZWQgd2hlbiBgdXJpYCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcImJ1ZmZlclZpZXdcIj86IEdsVGZJZDtcclxuICAgIFwibmFtZVwiPzogYW55O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVmZXJlbmNlIHRvIGEgdGV4dHVyZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFRleHR1cmVJbmZvIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcImluZGV4XCI6IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBpbmRleCBvZiB0ZXh0dXJlJ3MgVEVYQ09PUkQgYXR0cmlidXRlIHVzZWQgZm9yIHRleHR1cmUgY29vcmRpbmF0ZSBtYXBwaW5nLlxyXG4gICAgICovXHJcbiAgICBcInRleENvb3JkXCI/OiBudW1iZXI7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gZGVmaW5lIHRoZSBtZXRhbGxpYy1yb3VnaG5lc3MgbWF0ZXJpYWwgbW9kZWwgZnJvbSBQaHlzaWNhbGx5LUJhc2VkIFJlbmRlcmluZyAoUEJSKSBtZXRob2RvbG9neS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE1hdGVyaWFsUGJyTWV0YWxsaWNSb3VnaG5lc3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmFjdG9ycyBmb3IgdGhlIGJhc2UgY29sb3Igb2YgdGhlIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBcImJhc2VDb2xvckZhY3RvclwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYXNlIGNvbG9yIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIFwiYmFzZUNvbG9yVGV4dHVyZVwiPzogVGV4dHVyZUluZm87XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmYWN0b3IgZm9yIHRoZSBtZXRhbG5lc3Mgb2YgdGhlIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBcIm1ldGFsbGljRmFjdG9yXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmYWN0b3IgZm9yIHRoZSByb3VnaG5lc3Mgb2YgdGhlIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBcInJvdWdobmVzc0ZhY3RvclwiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWV0YWxsaWMtcm91Z2huZXNzIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIFwibWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlXCI/OiBUZXh0dXJlSW5mbztcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWF0ZXJpYWxOb3JtYWxUZXh0dXJlSW5mbyB7XHJcbiAgICBcImluZGV4XCI/OiBhbnk7XHJcbiAgICBcInRleENvb3JkXCI/OiBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsYXIgcGFyYW1ldGVyIGFwcGxpZWQgdG8gZWFjaCBub3JtYWwgdmVjdG9yIG9mIHRoZSBub3JtYWwgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgXCJzY2FsZVwiPzogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbE9jY2x1c2lvblRleHR1cmVJbmZvIHtcclxuICAgIFwiaW5kZXhcIj86IGFueTtcclxuICAgIFwidGV4Q29vcmRcIj86IGFueTtcclxuICAgIC8qKlxyXG4gICAgICogQSBzY2FsYXIgbXVsdGlwbGllciBjb250cm9sbGluZyB0aGUgYW1vdW50IG9mIG9jY2x1c2lvbiBhcHBsaWVkLlxyXG4gICAgICovXHJcbiAgICBcInN0cmVuZ3RoXCI/OiBudW1iZXI7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGUgbWF0ZXJpYWwgYXBwZWFyYW5jZSBvZiBhIHByaW1pdGl2ZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE1hdGVyaWFsIHtcclxuICAgIFwibmFtZVwiPzogYW55O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gZGVmaW5lIHRoZSBtZXRhbGxpYy1yb3VnaG5lc3MgbWF0ZXJpYWwgbW9kZWwgZnJvbSBQaHlzaWNhbGx5IEJhc2VkIFJlbmRlcmluZyAoUEJSKSBtZXRob2RvbG9neS4gV2hlbiB1bmRlZmluZWQsIGFsbCB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgYHBick1ldGFsbGljUm91Z2huZXNzYCAqKk1VU1QqKiBhcHBseS5cclxuICAgICAqL1xyXG4gICAgXCJwYnJNZXRhbGxpY1JvdWdobmVzc1wiPzogTWF0ZXJpYWxQYnJNZXRhbGxpY1JvdWdobmVzcztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhbmdlbnQgc3BhY2Ugbm9ybWFsIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIFwibm9ybWFsVGV4dHVyZVwiPzogTWF0ZXJpYWxOb3JtYWxUZXh0dXJlSW5mbztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9jY2x1c2lvbiB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcIm9jY2x1c2lvblRleHR1cmVcIj86IE1hdGVyaWFsT2NjbHVzaW9uVGV4dHVyZUluZm87XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlbWlzc2l2ZSB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcImVtaXNzaXZlVGV4dHVyZVwiPzogVGV4dHVyZUluZm87XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmYWN0b3JzIGZvciB0aGUgZW1pc3NpdmUgY29sb3Igb2YgdGhlIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBcImVtaXNzaXZlRmFjdG9yXCI/OiBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFscGhhIHJlbmRlcmluZyBtb2RlIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJhbHBoYU1vZGVcIj86IGFueSB8IGFueSB8IGFueSB8IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFscGhhIGN1dG9mZiB2YWx1ZSBvZiB0aGUgbWF0ZXJpYWwuXHJcbiAgICAgKi9cclxuICAgIFwiYWxwaGFDdXRvZmZcIj86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1hdGVyaWFsIGlzIGRvdWJsZSBzaWRlZC5cclxuICAgICAqL1xyXG4gICAgXCJkb3VibGVTaWRlZFwiPzogYm9vbGVhbjtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdlb21ldHJ5IHRvIGJlIHJlbmRlcmVkIHdpdGggdGhlIGdpdmVuIG1hdGVyaWFsLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzaFByaW1pdGl2ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEEgcGxhaW4gSlNPTiBvYmplY3QsIHdoZXJlIGVhY2gga2V5IGNvcnJlc3BvbmRzIHRvIGEgbWVzaCBhdHRyaWJ1dGUgc2VtYW50aWMgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIGluZGV4IG9mIHRoZSBhY2Nlc3NvciBjb250YWluaW5nIGF0dHJpYnV0ZSdzIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIFwiYXR0cmlidXRlc1wiOiB7XHJcbiAgICAgIFtrOiBzdHJpbmddOiBHbFRmSWQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGFjY2Vzc29yIHRoYXQgY29udGFpbnMgdGhlIHZlcnRleCBpbmRpY2VzLlxyXG4gICAgICovXHJcbiAgICBcImluZGljZXNcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBtYXRlcmlhbCB0byBhcHBseSB0byB0aGlzIHByaW1pdGl2ZSB3aGVuIHJlbmRlcmluZy5cclxuICAgICAqL1xyXG4gICAgXCJtYXRlcmlhbFwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdG9wb2xvZ3kgdHlwZSBvZiBwcmltaXRpdmVzIHRvIHJlbmRlci5cclxuICAgICAqL1xyXG4gICAgXCJtb2RlXCI/OiBudW1iZXIgfCBudW1iZXIgfCBudW1iZXIgfCBudW1iZXIgfCBudW1iZXIgfCBudW1iZXIgfCBudW1iZXIgfCBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIG1vcnBoIHRhcmdldHMuXHJcbiAgICAgKi9cclxuICAgIFwidGFyZ2V0c1wiPzoge1xyXG4gICAgICBbazogc3RyaW5nXTogR2xUZklkO1xyXG4gICAgfVtdO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBzZXQgb2YgcHJpbWl0aXZlcyB0byBiZSByZW5kZXJlZC4gIEl0cyBnbG9iYWwgdHJhbnNmb3JtIGlzIGRlZmluZWQgYnkgYSBub2RlIHRoYXQgcmVmZXJlbmNlcyBpdC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE1lc2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBwcmltaXRpdmVzLCBlYWNoIGRlZmluaW5nIGdlb21ldHJ5IHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICovXHJcbiAgICBcInByaW1pdGl2ZXNcIjogTWVzaFByaW1pdGl2ZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiB3ZWlnaHRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG1vcnBoIHRhcmdldHMuIFRoZSBudW1iZXIgb2YgYXJyYXkgZWxlbWVudHMgKipNVVNUKiogbWF0Y2ggdGhlIG51bWJlciBvZiBtb3JwaCB0YXJnZXRzLlxyXG4gICAgICovXHJcbiAgICBcIndlaWdodHNcIj86IG51bWJlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIG5vZGUgaW4gdGhlIG5vZGUgaGllcmFyY2h5LiAgV2hlbiB0aGUgbm9kZSBjb250YWlucyBgc2tpbmAsIGFsbCBgbWVzaC5wcmltaXRpdmVzYCAqKk1VU1QqKiBjb250YWluIGBKT0lOVFNfMGAgYW5kIGBXRUlHSFRTXzBgIGF0dHJpYnV0ZXMuICBBIG5vZGUgKipNQVkqKiBoYXZlIGVpdGhlciBhIGBtYXRyaXhgIG9yIGFueSBjb21iaW5hdGlvbiBvZiBgdHJhbnNsYXRpb25gL2Byb3RhdGlvbmAvYHNjYWxlYCAoVFJTKSBwcm9wZXJ0aWVzLiBUUlMgcHJvcGVydGllcyBhcmUgY29udmVydGVkIHRvIG1hdHJpY2VzIGFuZCBwb3N0bXVsdGlwbGllZCBpbiB0aGUgYFQgKiBSICogU2Agb3JkZXIgdG8gY29tcG9zZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4OyBmaXJzdCB0aGUgc2NhbGUgaXMgYXBwbGllZCB0byB0aGUgdmVydGljZXMsIHRoZW4gdGhlIHJvdGF0aW9uLCBhbmQgdGhlbiB0aGUgdHJhbnNsYXRpb24uIElmIG5vbmUgYXJlIHByb3ZpZGVkLCB0aGUgdHJhbnNmb3JtIGlzIHRoZSBpZGVudGl0eS4gV2hlbiBhIG5vZGUgaXMgdGFyZ2V0ZWQgZm9yIGFuaW1hdGlvbiAocmVmZXJlbmNlZCBieSBhbiBhbmltYXRpb24uY2hhbm5lbC50YXJnZXQpLCBgbWF0cml4YCAqKk1VU1QgTk9UKiogYmUgcHJlc2VudC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNhbWVyYSByZWZlcmVuY2VkIGJ5IHRoaXMgbm9kZS5cclxuICAgICAqL1xyXG4gICAgXCJjYW1lcmFcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGljZXMgb2YgdGhpcyBub2RlJ3MgY2hpbGRyZW4uXHJcbiAgICAgKi9cclxuICAgIFwiY2hpbGRyZW5cIj86IEdsVGZJZFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHNraW4gcmVmZXJlbmNlZCBieSB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIFwic2tpblwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsb2F0aW5nLXBvaW50IDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggc3RvcmVkIGluIGNvbHVtbi1tYWpvciBvcmRlci5cclxuICAgICAqL1xyXG4gICAgXCJtYXRyaXhcIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIG1lc2ggaW4gdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBcIm1lc2hcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5vZGUncyB1bml0IHF1YXRlcm5pb24gcm90YXRpb24gaW4gdGhlIG9yZGVyICh4LCB5LCB6LCB3KSwgd2hlcmUgdyBpcyB0aGUgc2NhbGFyLlxyXG4gICAgICovXHJcbiAgICBcInJvdGF0aW9uXCI/OiBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5vZGUncyBub24tdW5pZm9ybSBzY2FsZSwgZ2l2ZW4gYXMgdGhlIHNjYWxpbmcgZmFjdG9ycyBhbG9uZyB0aGUgeCwgeSwgYW5kIHogYXhlcy5cclxuICAgICAqL1xyXG4gICAgXCJzY2FsZVwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub2RlJ3MgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgsIHksIGFuZCB6IGF4ZXMuXHJcbiAgICAgKi9cclxuICAgIFwidHJhbnNsYXRpb25cIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2VpZ2h0cyBvZiB0aGUgaW5zdGFudGlhdGVkIG1vcnBoIHRhcmdldC4gVGhlIG51bWJlciBvZiBhcnJheSBlbGVtZW50cyAqKk1VU1QqKiBtYXRjaCB0aGUgbnVtYmVyIG9mIG1vcnBoIHRhcmdldHMgb2YgdGhlIHJlZmVyZW5jZWQgbWVzaC4gV2hlbiBkZWZpbmVkLCBgbWVzaGAgKipNVVNUKiogYWxzbyBiZSBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcIndlaWdodHNcIj86IG51bWJlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIHNhbXBsZXIgcHJvcGVydGllcyBmb3IgZmlsdGVyaW5nIGFuZCB3cmFwcGluZyBtb2Rlcy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFNhbXBsZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWduaWZpY2F0aW9uIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgXCJtYWdGaWx0ZXJcIj86IG51bWJlciB8IG51bWJlciB8IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogTWluaWZpY2F0aW9uIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgXCJtaW5GaWx0ZXJcIj86IG51bWJlciB8IG51bWJlciB8IG51bWJlciB8IG51bWJlciB8IG51bWJlciB8IG51bWJlciB8IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogUyAoVSkgd3JhcHBpbmcgbW9kZS5cclxuICAgICAqL1xyXG4gICAgXCJ3cmFwU1wiPzogbnVtYmVyIHwgbnVtYmVyIHwgbnVtYmVyIHwgbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUIChWKSB3cmFwcGluZyBtb2RlLlxyXG4gICAgICovXHJcbiAgICBcIndyYXBUXCI/OiBudW1iZXIgfCBudW1iZXIgfCBudW1iZXIgfCBudW1iZXI7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoZSByb290IG5vZGVzIG9mIGEgc2NlbmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTY2VuZSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRpY2VzIG9mIGVhY2ggcm9vdCBub2RlLlxyXG4gICAgICovXHJcbiAgICBcIm5vZGVzXCI/OiBHbFRmSWRbXTtcclxuICAgIFwibmFtZVwiPzogYW55O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSm9pbnRzIGFuZCBtYXRyaWNlcyBkZWZpbmluZyBhIHNraW4uXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTa2luIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBhY2Nlc3NvciBjb250YWluaW5nIHRoZSBmbG9hdGluZy1wb2ludCA0eDQgaW52ZXJzZS1iaW5kIG1hdHJpY2VzLlxyXG4gICAgICovXHJcbiAgICBcImludmVyc2VCaW5kTWF0cmljZXNcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBub2RlIHVzZWQgYXMgYSBza2VsZXRvbiByb290LlxyXG4gICAgICovXHJcbiAgICBcInNrZWxldG9uXCI/OiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljZXMgb2Ygc2tlbGV0b24gbm9kZXMsIHVzZWQgYXMgam9pbnRzIGluIHRoaXMgc2tpbi5cclxuICAgICAqL1xyXG4gICAgXCJqb2ludHNcIjogR2xUZklkW107XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgdGV4dHVyZSBhbmQgaXRzIHNhbXBsZXIuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBzYW1wbGVyIHVzZWQgYnkgdGhpcyB0ZXh0dXJlLiBXaGVuIHVuZGVmaW5lZCwgYSBzYW1wbGVyIHdpdGggcmVwZWF0IHdyYXBwaW5nIGFuZCBhdXRvIGZpbHRlcmluZyAqKlNIT1VMRCoqIGJlIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIFwic2FtcGxlclwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGltYWdlIHVzZWQgYnkgdGhpcyB0ZXh0dXJlLiBXaGVuIHVuZGVmaW5lZCwgYW4gZXh0ZW5zaW9uIG9yIG90aGVyIG1lY2hhbmlzbSAqKlNIT1VMRCoqIHN1cHBseSBhbiBhbHRlcm5hdGUgdGV4dHVyZSBzb3VyY2UsIG90aGVyd2lzZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwic291cmNlXCI/OiBHbFRmSWQ7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoZSByb290IG9iamVjdCBmb3IgYSBnbFRGIGFzc2V0LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgR2xUZiB7XHJcbiAgICAvKipcclxuICAgICAqIE5hbWVzIG9mIGdsVEYgZXh0ZW5zaW9ucyB1c2VkIGluIHRoaXMgYXNzZXQuXHJcbiAgICAgKi9cclxuICAgIFwiZXh0ZW5zaW9uc1VzZWRcIj86IHN0cmluZ1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lcyBvZiBnbFRGIGV4dGVuc2lvbnMgcmVxdWlyZWQgdG8gcHJvcGVybHkgbG9hZCB0aGlzIGFzc2V0LlxyXG4gICAgICovXHJcbiAgICBcImV4dGVuc2lvbnNSZXF1aXJlZFwiPzogc3RyaW5nW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGFjY2Vzc29ycy5cclxuICAgICAqL1xyXG4gICAgXCJhY2Nlc3NvcnNcIj86IEFjY2Vzc29yW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGtleWZyYW1lIGFuaW1hdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIFwiYW5pbWF0aW9uc1wiPzogQW5pbWF0aW9uW107XHJcbiAgICAvKipcclxuICAgICAqIE1ldGFkYXRhIGFib3V0IHRoZSBnbFRGIGFzc2V0LlxyXG4gICAgICovXHJcbiAgICBcImFzc2V0XCI6IEFzc2V0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBcImJ1ZmZlcnNcIj86IEJ1ZmZlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBidWZmZXJWaWV3cy5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3c1wiPzogQnVmZmVyVmlld1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBjYW1lcmFzLlxyXG4gICAgICovXHJcbiAgICBcImNhbWVyYXNcIj86IENhbWVyYVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBpbWFnZXMuXHJcbiAgICAgKi9cclxuICAgIFwiaW1hZ2VzXCI/OiBJbWFnZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBtYXRlcmlhbHMuXHJcbiAgICAgKi9cclxuICAgIFwibWF0ZXJpYWxzXCI/OiBNYXRlcmlhbFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBtZXNoZXMuXHJcbiAgICAgKi9cclxuICAgIFwibWVzaGVzXCI/OiBNZXNoW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBcIm5vZGVzXCI/OiBOb2RlW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHNhbXBsZXJzLlxyXG4gICAgICovXHJcbiAgICBcInNhbXBsZXJzXCI/OiBTYW1wbGVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgZGVmYXVsdCBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgXCJzY2VuZVwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBzY2VuZXMuXHJcbiAgICAgKi9cclxuICAgIFwic2NlbmVzXCI/OiBTY2VuZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBza2lucy5cclxuICAgICAqL1xyXG4gICAgXCJza2luc1wiPzogU2tpbltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB0ZXh0dXJlcy5cclxuICAgICAqL1xyXG4gICAgXCJ0ZXh0dXJlc1wiPzogVGV4dHVyZVtdO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBlbnVtIENvbXBvbmVudFR5cGUge1xyXG4gICAgQllURSA9IDUxMjAsXHJcbiAgICBVTlNJR05FRF9CWVRFID0gNTEyMSxcclxuICAgIFNIT1JUID0gNTEyMixcclxuICAgIFVOU0lHTkVEX1NIT1JUID0gNTEyMyxcclxuICAgIElOVCA9IDUxMjQsXHJcbiAgICBVTlNJR05FRF9JTlQgPSA1MTI1LFxyXG4gICAgRkxPQVQgPSA1MTI2XHJcbiAgfVxyXG5cclxuICB0eXBlIFR5cGVkQXJyYXkgPSBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDhBcnJheSB8IEludDE2QXJyYXkgfCBJbnQzMkFycmF5IHwgRmxvYXQzMkFycmF5IHwgRmxvYXQ2NEFycmF5O1xyXG5cclxuICBpbnRlcmZhY2UgR0xURkxvYWRlckxpc3Qge1xyXG4gICAgW3VyaTogc3RyaW5nXTogR0xURkxvYWRlcjtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBBbmltYXRpb25TdHJ1Y3R1cmVWZWN0b3IzIHtcclxuICAgIHg6IEFuaW1hdGlvblNlcXVlbmNlO1xyXG4gICAgeTogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgICB6OiBBbmltYXRpb25TZXF1ZW5jZTtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBBbmltYXRpb25TdHJ1Y3R1cmVNYXRyaXg0eDQge1xyXG4gICAgcm90YXRpb24/OiBBbmltYXRpb25TdHJ1Y3R1cmVWZWN0b3IzO1xyXG4gICAgc2NhbGU/OiBBbmltYXRpb25TdHJ1Y3R1cmVWZWN0b3IzO1xyXG4gICAgdHJhbnNsYXRpb24/OiBBbmltYXRpb25TdHJ1Y3R1cmVWZWN0b3IzO1xyXG4gIH1cclxuXHJcbiAgdHlwZSBUcmFuc2Zvcm1hdGlvblR5cGUgPSBcInJvdGF0aW9uXCIgfCBcInNjYWxlXCIgfCBcInRyYW5zbGF0aW9uXCI7XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBHTFRGTG9hZGVyIHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkZXJzOiBHTFRGTG9hZGVyTGlzdDtcclxuICAgIHByaXZhdGUgc3RhdGljIGRlZmF1bHRNYXRlcmlhbDogTWF0ZXJpYWw7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZWZhdWx0U2tpbk1hdGVyaWFsOiBNYXRlcmlhbDtcclxuXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZ2x0ZjogR0xURi5HbFRmO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IHVyaTogc3RyaW5nO1xyXG5cclxuICAgICNzY2VuZXM6IEdyYXBoW107XHJcbiAgICAjbm9kZXM6IE5vZGVbXTtcclxuICAgICNjYW1lcmFzOiBDb21wb25lbnRDYW1lcmFbXTtcclxuICAgICNhbmltYXRpb25zOiBBbmltYXRpb25bXTtcclxuICAgICNtZXNoZXM6IE1lc2hHTFRGW107XHJcbiAgICAjc2tlbGV0b25zOiBTa2VsZXRvbltdO1xyXG4gICAgI2J1ZmZlcnM6IEFycmF5QnVmZmVyW107XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihfZ2x0ZjogR0xURi5HbFRmLCBfdXJpOiBzdHJpbmcpIHtcclxuICAgICAgdGhpcy5nbHRmID0gX2dsdGY7XHJcbiAgICAgIHRoaXMudXJpID0gX3VyaTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIExPQUQoX3VyaTogc3RyaW5nKTogUHJvbWlzZTxHTFRGTG9hZGVyPiB7XHJcbiAgICAgIGlmICghdGhpcy5sb2FkZXJzKVxyXG4gICAgICAgIHRoaXMubG9hZGVycyA9IHt9O1xyXG4gICAgICBpZiAoIXRoaXMubG9hZGVyc1tfdXJpXSkgeyAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IGZldGNoKF91cmkpO1xyXG4gICAgICAgIGNvbnN0IGdsdGY6IEdMVEYuR2xUZiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB0aGlzLmxvYWRlcnNbX3VyaV0gPSBuZXcgR0xURkxvYWRlcihnbHRmLCBfdXJpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5sb2FkZXJzW191cmldO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRTY2VuZShfbmFtZT86IHN0cmluZyk6IFByb21pc2U8R3JhcGhJbnN0YW5jZT4ge1xyXG4gICAgICBjb25zdCBpU2NlbmU6IG51bWJlciA9IF9uYW1lID8gdGhpcy5nbHRmLnNjZW5lcy5maW5kSW5kZXgoc2NlbmUgPT4gc2NlbmUubmFtZSA9PSBfbmFtZSkgOiB0aGlzLmdsdGYuc2NlbmU7XHJcbiAgICAgIGlmIChpU2NlbmUgPT0gLTEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIG5hbWUgJHtfbmFtZX0gaW4gZ2x0ZiBzY2VuZXMuYCk7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFNjZW5lQnlJbmRleChpU2NlbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRTY2VuZUJ5SW5kZXgoX2lTY2VuZTogbnVtYmVyID0gdGhpcy5nbHRmLnNjZW5lKTogUHJvbWlzZTxHcmFwaEluc3RhbmNlPiB7XHJcbiAgICAgIGlmICghdGhpcy4jc2NlbmVzKVxyXG4gICAgICAgIHRoaXMuI3NjZW5lcyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI3NjZW5lc1tfaVNjZW5lXSkge1xyXG4gICAgICAgIGNvbnN0IGdsdGZTY2VuZTogR0xURi5TY2VuZSA9IHRoaXMuZ2x0Zi5zY2VuZXNbX2lTY2VuZV07XHJcbiAgICAgICAgY29uc3Qgc2NlbmU6IEdyYXBoID0gbmV3IEdyYXBoKGdsdGZTY2VuZS5uYW1lKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGlOb2RlIG9mIGdsdGZTY2VuZS5ub2RlcylcclxuICAgICAgICAgIHNjZW5lLmFkZENoaWxkKGF3YWl0IHRoaXMuZ2V0Tm9kZUJ5SW5kZXgoaU5vZGUpKTtcclxuICAgICAgICBQcm9qZWN0LnJlZ2lzdGVyKHNjZW5lKTtcclxuICAgICAgICB0aGlzLiNzY2VuZXNbX2lTY2VuZV0gPSBzY2VuZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUHJvamVjdC5jcmVhdGVHcmFwaEluc3RhbmNlKHRoaXMuI3NjZW5lc1tfaVNjZW5lXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldE5vZGUoX25hbWU6IHN0cmluZyk6IFByb21pc2U8Tm9kZT4ge1xyXG4gICAgICBjb25zdCBpTm9kZTogbnVtYmVyID0gdGhpcy5nbHRmLm5vZGVzLmZpbmRJbmRleChub2RlID0+IG5vZGUubmFtZSA9PSBfbmFtZSk7XHJcbiAgICAgIGlmIChpTm9kZSA9PSAtMSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgbmFtZSAke19uYW1lfSBpbiBnbHRmIG5vZGVzLmApO1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROb2RlQnlJbmRleChpTm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldE5vZGVCeUluZGV4KF9pTm9kZTogbnVtYmVyKTogUHJvbWlzZTxOb2RlPiB7XHJcbiAgICAgIGlmICghdGhpcy4jbm9kZXMpXHJcbiAgICAgICAgdGhpcy4jbm9kZXMgPSBbXTtcclxuICAgICAgaWYgKCF0aGlzLiNub2Rlc1tfaU5vZGVdKSB7XHJcbiAgICAgICAgY29uc3QgZ2x0Zk5vZGU6IEdMVEYuTm9kZSA9IHRoaXMuZ2x0Zi5ub2Rlc1tfaU5vZGVdO1xyXG4gICAgICAgIGNvbnN0IG5vZGU6IE5vZGUgPSBuZXcgTm9kZShnbHRmTm9kZS5uYW1lKTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKGdsdGZOb2RlLmNoaWxkcmVuKVxyXG4gICAgICAgICAgZm9yIChjb25zdCBpTm9kZSBvZiBnbHRmTm9kZS5jaGlsZHJlbilcclxuICAgICAgICAgICAgbm9kZS5hZGRDaGlsZChhd2FpdCB0aGlzLmdldE5vZGVCeUluZGV4KGlOb2RlKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgaWYgKGdsdGZOb2RlLm1hdHJpeCB8fCBnbHRmTm9kZS5yb3RhdGlvbiB8fCBnbHRmTm9kZS5zY2FsZSB8fCBnbHRmTm9kZS50cmFuc2xhdGlvbikge1xyXG4gICAgICAgICAgaWYgKCFub2RlLmdldENvbXBvbmVudChDb21wb25lbnRUcmFuc2Zvcm0pKSBcclxuICAgICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudFRyYW5zZm9ybSgpKTtcclxuICAgICAgICAgIGlmIChnbHRmTm9kZS5tYXRyaXgpIHtcclxuICAgICAgICAgICAgbm9kZS5tdHhMb2NhbC5zZXQoRmxvYXQzMkFycmF5LmZyb20oZ2x0Zk5vZGUubWF0cml4KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGdsdGZOb2RlLnJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgIG5vZGUubXR4TG9jYWwucm90YXRlKG5ldyBWZWN0b3IzKC4uLmdsdGZOb2RlLnJvdGF0aW9uLm1hcChyb3RhdGlvbiA9PiByb3RhdGlvbiAqIDE4MCAvIE1hdGguUEkpKSk7XHJcbiAgICAgICAgICAgIGlmIChnbHRmTm9kZS5zY2FsZSlcclxuICAgICAgICAgICAgICBub2RlLm10eExvY2FsLnNjYWxlKG5ldyBWZWN0b3IzKC4uLmdsdGZOb2RlLnNjYWxlKSk7XHJcbiAgICAgICAgICAgIGlmIChnbHRmTm9kZS50cmFuc2xhdGlvbilcclxuICAgICAgICAgICAgICBub2RlLm10eExvY2FsLnRyYW5zbGF0ZShuZXcgVmVjdG9yMyguLi5nbHRmTm9kZS50cmFuc2xhdGlvbikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNhbWVyYVxyXG4gICAgICAgIGlmIChnbHRmTm9kZS5jYW1lcmEgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChhd2FpdCB0aGlzLmdldENhbWVyYUJ5SW5kZXgoZ2x0Zk5vZGUuY2FtZXJhKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBmb3IgbWVzaFxyXG4gICAgICAgIGlmIChnbHRmTm9kZS5tZXNoICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudE1lc2goYXdhaXQgdGhpcy5nZXRNZXNoQnlJbmRleChnbHRmTm9kZS5tZXNoKSkpO1xyXG4gICAgICAgICAgaWYgKG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpLm1lc2ggaW5zdGFuY2VvZiBNZXNoU2tpbikge1xyXG4gICAgICAgICAgICBpZiAoIUdMVEZMb2FkZXIuZGVmYXVsdFNraW5NYXRlcmlhbClcclxuICAgICAgICAgICAgICBHTFRGTG9hZGVyLmRlZmF1bHRTa2luTWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoXCJHTFRGRGVmYXVsdFNraW5NYXRlcmlhbFwiLCBTaGFkZXJHb3VyYXVkU2tpbiwgbmV3IENvYXRSZW1pc3NpdmUoQ29sb3IuQ1NTKFwid2hpdGVcIikpKTtcclxuICAgICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudE1hdGVyaWFsKEdMVEZMb2FkZXIuZGVmYXVsdFNraW5NYXRlcmlhbCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghR0xURkxvYWRlci5kZWZhdWx0TWF0ZXJpYWwpXHJcbiAgICAgICAgICAgICAgR0xURkxvYWRlci5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoXCJHTFRGRGVmYXVsdE1hdGVyaWFsXCIsIFNoYWRlckdvdXJhdWQsIG5ldyBDb2F0UmVtaXNzaXZlKENvbG9yLkNTUyhcIndoaXRlXCIpKSk7XHJcbiAgICAgICAgICAgIG5vZGUuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnRNYXRlcmlhbChHTFRGTG9hZGVyLmRlZmF1bHRNYXRlcmlhbCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNrZWxldG9uICAgICAgICBcclxuICAgICAgICBpZiAoZ2x0Zk5vZGUuc2tpbiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IHNrZWxldG9uOiBTa2VsZXRvbkluc3RhbmNlID0gYXdhaXQgdGhpcy5nZXRTa2VsZXRvbkJ5SW5kZXgoZ2x0Zk5vZGUuc2tpbik7XHJcbiAgICAgICAgICBub2RlLmFkZENoaWxkKHNrZWxldG9uKTtcclxuICAgICAgICAgIGlmIChub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKSlcclxuICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkuYmluZFNrZWxldG9uKHNrZWxldG9uKTtcclxuICAgICAgICAgIGZvciAoY29uc3QgaUFuaW1hdGlvbiBvZiB0aGlzLmZpbmRTa2VsZXRhbEFuaW1hdGlvbkluZGljZXMoZ2x0Zk5vZGUuc2tpbikpIHtcclxuICAgICAgICAgICAgc2tlbGV0b24uYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnRBbmltYXRvcihhd2FpdCB0aGlzLmdldEFuaW1hdGlvbkJ5SW5kZXgoaUFuaW1hdGlvbikpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuI25vZGVzW19pTm9kZV0gPSBub2RlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNub2Rlc1tfaU5vZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRDYW1lcmEoX25hbWU6IHN0cmluZyk6IFByb21pc2U8Q29tcG9uZW50Q2FtZXJhPiB7XHJcbiAgICAgIGNvbnN0IGlDYW1lcmE6IG51bWJlciA9IHRoaXMuZ2x0Zi5jYW1lcmFzLmZpbmRJbmRleChjYW1lcmEgPT4gY2FtZXJhLm5hbWUgPT0gX25hbWUpO1xyXG4gICAgICBpZiAoaUNhbWVyYSA9PSAtMSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgbmFtZSAke19uYW1lfSBpbiBnbHRmIGNhbWVyYXMuYCk7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldENhbWVyYUJ5SW5kZXgoaUNhbWVyYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldENhbWVyYUJ5SW5kZXgoX2lDYW1lcmE6IG51bWJlcik6IFByb21pc2U8Q29tcG9uZW50Q2FtZXJhPiB7XHJcbiAgICAgIGlmICghdGhpcy4jY2FtZXJhcylcclxuICAgICAgICB0aGlzLiNjYW1lcmFzID0gW107XHJcbiAgICAgIGlmICghdGhpcy4jY2FtZXJhc1tfaUNhbWVyYV0pIHtcclxuICAgICAgICBjb25zdCBnbHRmQ2FtZXJhOiBHTFRGLkNhbWVyYSA9IHRoaXMuZ2x0Zi5jYW1lcmFzW19pQ2FtZXJhXTtcclxuICAgICAgICBjb25zdCBjYW1lcmE6IENvbXBvbmVudENhbWVyYSA9IG5ldyBDb21wb25lbnRDYW1lcmEoKTtcclxuXHJcbiAgICAgICAgaWYgKGdsdGZDYW1lcmEucGVyc3BlY3RpdmUpXHJcbiAgICAgICAgICBjYW1lcmEucHJvamVjdENlbnRyYWwoXHJcbiAgICAgICAgICAgIGdsdGZDYW1lcmEucGVyc3BlY3RpdmUuYXNwZWN0UmF0aW8sXHJcbiAgICAgICAgICAgIGdsdGZDYW1lcmEucGVyc3BlY3RpdmUueWZvdiAqIDE4MCAvIE1hdGguUEksXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIGdsdGZDYW1lcmEucGVyc3BlY3RpdmUuem5lYXIsXHJcbiAgICAgICAgICAgIGdsdGZDYW1lcmEucGVyc3BlY3RpdmUuemZhclxyXG4gICAgICAgICAgKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBjYW1lcmEucHJvamVjdE9ydGhvZ3JhcGhpYyhcclxuICAgICAgICAgICAgLWdsdGZDYW1lcmEub3J0aG9ncmFwaGljLnhtYWcsXHJcbiAgICAgICAgICAgIGdsdGZDYW1lcmEub3J0aG9ncmFwaGljLnhtYWcsXHJcbiAgICAgICAgICAgIC1nbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy55bWFnLFxyXG4gICAgICAgICAgICBnbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy55bWFnXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FtZXJhO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNjYW1lcmFzW19pQ2FtZXJhXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QW5pbWF0aW9uKF9uYW1lOiBzdHJpbmcpOiBQcm9taXNlPEFuaW1hdGlvbj4ge1xyXG4gICAgICBjb25zdCBpQW5pbWF0aW9uOiBudW1iZXIgPSB0aGlzLmdsdGYuYW5pbWF0aW9ucy5maW5kSW5kZXgoYW5pbWF0aW9uID0+IGFuaW1hdGlvbi5uYW1lID09IF9uYW1lKTtcclxuICAgICAgaWYgKGlBbmltYXRpb24gPT0gLTEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIG5hbWUgJHtfbmFtZX0gaW4gZ2x0ZiBhbmltYXRpb25zLmApO1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBbmltYXRpb25CeUluZGV4KGlBbmltYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBbmltYXRpb25CeUluZGV4KF9pQW5pbWF0aW9uOiBudW1iZXIpOiBQcm9taXNlPEFuaW1hdGlvbj4ge1xyXG4gICAgICBpZiAoIXRoaXMuI2FuaW1hdGlvbnMpXHJcbiAgICAgICAgdGhpcy4jYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI2FuaW1hdGlvbnNbX2lBbmltYXRpb25dKSB7XHJcbiAgICAgICAgY29uc3QgZ2x0ZkFuaW1hdGlvbjogR0xURi5BbmltYXRpb24gPSB0aGlzLmdsdGYuYW5pbWF0aW9uc1tfaUFuaW1hdGlvbl07XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzU2tlbGV0YWxBbmltYXRpb24oZ2x0ZkFuaW1hdGlvbikpIHtcclxuICAgICAgICAgIC8vIG1hcCBjaGFubmVscyB0byBhbiBhbmltYXRpb24gc3RydWN0dXJlIGZvciBhbmltYXRpbmcgdGhlIGxvY2FsIGJvbmUgbWF0cmljZXNcclxuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvblN0cnVjdHVyZToge1xyXG4gICAgICAgICAgICBtdHhCb25lTG9jYWxzOiB7XHJcbiAgICAgICAgICAgICAgW2JvbmVOYW1lOiBzdHJpbmddOiBBbmltYXRpb25TdHJ1Y3R1cmVNYXRyaXg0eDRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSA9IHsgbXR4Qm9uZUxvY2Fsczoge30gfTtcclxuICAgICAgICAgIGZvciAoY29uc3QgZ2x0ZkNoYW5uZWwgb2YgZ2x0ZkFuaW1hdGlvbi5jaGFubmVscykge1xyXG4gICAgICAgICAgICBjb25zdCBib25lTmFtZTogc3RyaW5nID0gdGhpcy4jbm9kZXNbZ2x0ZkNoYW5uZWwudGFyZ2V0Lm5vZGVdLm5hbWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IDQgYnkgNCBtYXRyaXggYW5pbWF0aW9uIHN0cnVjdHVyZSBpZiB0aGVyZSBpcyBubyBlbnRyeSBmb3IgdGhlIGJvbmUgbmFtZVxyXG4gICAgICAgICAgICBpZiAoIWFuaW1hdGlvblN0cnVjdHVyZS5tdHhCb25lTG9jYWxzW2JvbmVOYW1lXSkgYW5pbWF0aW9uU3RydWN0dXJlLm10eEJvbmVMb2NhbHNbYm9uZU5hbWVdID0ge307XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHZlY3RvciAzIGFuaW1hdGlvbiBzdHJ1Y3R1cmUgb2YgdGhlIGVudHJ5IHJlZmVyZWQgYnkgdGhlIGNoYW5uZWwgdGFyZ2V0IHBhdGhcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb25UeXBlOiBUcmFuc2Zvcm1hdGlvblR5cGUgPSBnbHRmQ2hhbm5lbC50YXJnZXQucGF0aCBhcyBUcmFuc2Zvcm1hdGlvblR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1hdGlvblR5cGUpXHJcbiAgICAgICAgICAgICAgYW5pbWF0aW9uU3RydWN0dXJlLm10eEJvbmVMb2NhbHNbYm9uZU5hbWVdW3RyYW5zZm9ybWF0aW9uVHlwZV0gPVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjMoZ2x0ZkFuaW1hdGlvbi5zYW1wbGVyc1tnbHRmQ2hhbm5lbC5zYW1wbGVyXSwgdHJhbnNmb3JtYXRpb25UeXBlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLiNhbmltYXRpb25zW19pQW5pbWF0aW9uXSA9IG5ldyBBbmltYXRpb24oZ2x0ZkFuaW1hdGlvbi5uYW1lLCBhbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24tc2tlbGV0YWwgYW5pbWF0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNhbmltYXRpb25zW19pQW5pbWF0aW9uXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWVzaChfbmFtZTogc3RyaW5nKTogUHJvbWlzZTxNZXNoR0xURj4ge1xyXG4gICAgICBjb25zdCBpTWVzaDogbnVtYmVyID0gdGhpcy5nbHRmLm1lc2hlcy5maW5kSW5kZXgobWVzaCA9PiBtZXNoLm5hbWUgPT0gX25hbWUpO1xyXG4gICAgICBpZiAoaU1lc2ggPT0gLTEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIG5hbWUgJHtfbmFtZX0gaW4gZ2x0ZiBtZXNoZXMuYCk7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE1lc2hCeUluZGV4KGlNZXNoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWVzaEJ5SW5kZXgoX2lNZXNoOiBudW1iZXIpOiBQcm9taXNlPE1lc2hHTFRGPiB7XHJcbiAgICAgIGlmICghdGhpcy4jbWVzaGVzKVxyXG4gICAgICAgIHRoaXMuI21lc2hlcyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI21lc2hlc1tfaU1lc2hdKSB7XHJcbiAgICAgICAgY29uc3QgZ2x0Zk1lc2g6IEdMVEYuTWVzaCA9IHRoaXMuZ2x0Zi5tZXNoZXNbX2lNZXNoXTtcclxuICAgICAgICB0aGlzLiNtZXNoZXNbX2lNZXNoXSA9IGF3YWl0IChcclxuICAgICAgICAgIGdsdGZNZXNoLnByaW1pdGl2ZXNbMF0uYXR0cmlidXRlcy5KT0lOVFNfMCAhPSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgbmV3IE1lc2hTa2luKCkubG9hZCh0aGlzLCBfaU1lc2gpIDpcclxuICAgICAgICAgIG5ldyBNZXNoR0xURigpLmxvYWQodGhpcywgX2lNZXNoKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuI21lc2hlc1tfaU1lc2hdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRTa2VsZXRvbihfbmFtZTogc3RyaW5nKTogUHJvbWlzZTxTa2VsZXRvbkluc3RhbmNlPiB7XHJcbiAgICAgIGNvbnN0IGlTa2VsZXRvbjogbnVtYmVyID0gdGhpcy5nbHRmLnNraW5zLmZpbmRJbmRleChza2VsZXRvbiA9PiBza2VsZXRvbi5uYW1lID09IF9uYW1lKTtcclxuICAgICAgaWYgKGlTa2VsZXRvbiA9PSAtMSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgbmFtZSAke19uYW1lfSBpbiBnbHRmIHNraW5zLmApO1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRTa2VsZXRvbkJ5SW5kZXgoaVNrZWxldG9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2tlbGV0b25CeUluZGV4KF9pU2tlbGV0b246IG51bWJlcik6IFByb21pc2U8U2tlbGV0b25JbnN0YW5jZT4ge1xyXG4gICAgICBpZiAoIXRoaXMuI3NrZWxldG9ucylcclxuICAgICAgICB0aGlzLiNza2VsZXRvbnMgPSBbXTtcclxuICAgICAgaWYgKCF0aGlzLiNza2VsZXRvbnNbX2lTa2VsZXRvbl0pIHtcclxuICAgICAgICBjb25zdCBnbHRmU2tlbGV0b246IEdMVEYuU2tpbiA9IHRoaXMuZ2x0Zi5za2luc1tfaVNrZWxldG9uXTtcclxuICAgICAgICBjb25zdCBza2VsZXRvbjogU2tlbGV0b24gPSBuZXcgU2tlbGV0b24oZ2x0ZlNrZWxldG9uLm5hbWUpO1xyXG5cclxuICAgICAgICAvLyBhZGQgYWxsIGJvbmVzIGFzIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIGJ5IGFkZGluZyB0aGUgcm9vdCBib25lXHJcbiAgICAgICAgc2tlbGV0b24uYWRkQ2hpbGQoYXdhaXQgdGhpcy5nZXROb2RlQnlJbmRleChnbHRmU2tlbGV0b24uam9pbnRzWzBdKSk7XHJcblxyXG4gICAgICAgIC8vIGNvbnZlcnQgZmxvYXQgYXJyYXkgdG8gYXJyYXkgb2YgbWF0cmljZXMgYW5kIHJlZ2lzdGVyIGJvbmVzXHJcbiAgICAgICAgY29uc3QgZmxvYXRBcnJheTogRmxvYXQzMkFycmF5ID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlNrZWxldG9uLmludmVyc2VCaW5kTWF0cmljZXMpO1xyXG4gICAgICAgIGNvbnN0IHNwYW46IG51bWJlciA9IDE2O1xyXG4gICAgICAgIGZvciAobGV0IGlGbG9hdDogbnVtYmVyID0gMCwgaUJvbmU6IG51bWJlciA9IDA7IGlGbG9hdCA8IGZsb2F0QXJyYXkubGVuZ3RoOyBpRmxvYXQgKz0gc3BhbiwgaUJvbmUrKykge1xyXG4gICAgICAgICAgY29uc3QgbXR4QmluZEludmVyc2U6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcclxuICAgICAgICAgIG10eEJpbmRJbnZlcnNlLnNldChmbG9hdEFycmF5LnN1YmFycmF5KGlGbG9hdCwgaUZsb2F0ICsgc3BhbikpO1xyXG4gICAgICAgICAgc2tlbGV0b24ucmVnaXN0ZXJCb25lKHRoaXMuI25vZGVzW2dsdGZTa2VsZXRvbi5qb2ludHNbaUJvbmVdXSwgbXR4QmluZEludmVyc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQcm9qZWN0LnJlZ2lzdGVyKHNrZWxldG9uKTtcclxuICAgICAgICB0aGlzLiNza2VsZXRvbnNbX2lTa2VsZXRvbl0gPSBza2VsZXRvbjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXdhaXQgU2tlbGV0b25JbnN0YW5jZS5DUkVBVEUodGhpcy4jc2tlbGV0b25zW19pU2tlbGV0b25dKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VWludDhBcnJheShfaUFjY2Vzc29yOiBudW1iZXIpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgICAgY29uc3QgYXJyYXk6IFR5cGVkQXJyYXkgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckRhdGEoX2lBY2Nlc3Nvcik7XHJcbiAgICAgIGlmICh0aGlzLmdsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdPy5jb21wb25lbnRUeXBlID09IENvbXBvbmVudFR5cGUuVU5TSUdORURfQllURSlcclxuICAgICAgICByZXR1cm4gYXJyYXkgYXMgVWludDhBcnJheTtcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBFeHBlY3RlZCBjb21wb25lbnQgdHlwZSBVTlNJR05FRF9CWVRFIGJ1dCB3YXMgJHtDb21wb25lbnRUeXBlW3RoaXMuZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl0/LmNvbXBvbmVudFR5cGVdfS5gKTtcclxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFycmF5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRVaW50MTZBcnJheShfaUFjY2Vzc29yOiBudW1iZXIpOiBQcm9taXNlPFVpbnQxNkFycmF5PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5OiBUeXBlZEFycmF5ID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJEYXRhKF9pQWNjZXNzb3IpO1xyXG4gICAgICBpZiAodGhpcy5nbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXT8uY29tcG9uZW50VHlwZSA9PSBDb21wb25lbnRUeXBlLlVOU0lHTkVEX1NIT1JUKVxyXG4gICAgICAgIHJldHVybiBhcnJheSBhcyBVaW50MTZBcnJheTtcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBFeHBlY3RlZCBjb21wb25lbnQgdHlwZSBVTlNJR05FRF9TSE9SVCBidXQgd2FzICR7Q29tcG9uZW50VHlwZVt0aGlzLmdsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdPy5jb21wb25lbnRUeXBlXX0uYCk7XHJcbiAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5LmZyb20oYXJyYXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFVpbnQzMkFycmF5KF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8VWludDMyQXJyYXk+IHtcclxuICAgICAgY29uc3QgYXJyYXk6IFR5cGVkQXJyYXkgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckRhdGEoX2lBY2Nlc3Nvcik7XHJcbiAgICAgIGlmICh0aGlzLmdsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdPy5jb21wb25lbnRUeXBlID09IENvbXBvbmVudFR5cGUuVU5TSUdORURfSU5UKVxyXG4gICAgICAgIHJldHVybiBhcnJheSBhcyBVaW50MzJBcnJheTtcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBFeHBlY3RlZCBjb21wb25lbnQgdHlwZSBVTlNJR05FRF9JTlQgYnV0IHdhcyAke0NvbXBvbmVudFR5cGVbdGhpcy5nbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXT8uY29tcG9uZW50VHlwZV19LmApO1xyXG4gICAgICAgIHJldHVybiBVaW50MzJBcnJheS5mcm9tKGFycmF5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRGbG9hdDMyQXJyYXkoX2lBY2Nlc3NvcjogbnVtYmVyKTogUHJvbWlzZTxGbG9hdDMyQXJyYXk+IHtcclxuICAgICAgY29uc3QgYXJyYXk6IFR5cGVkQXJyYXkgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckRhdGEoX2lBY2Nlc3Nvcik7XHJcbiAgICAgIGlmICh0aGlzLmdsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdPy5jb21wb25lbnRUeXBlID09IENvbXBvbmVudFR5cGUuRkxPQVQpXHJcbiAgICAgICAgcmV0dXJuIGFycmF5IGFzIEZsb2F0MzJBcnJheTtcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBFeHBlY3RlZCBjb21wb25lbnQgdHlwZSBGTE9BVCBidXQgd2FzICR7Q29tcG9uZW50VHlwZVt0aGlzLmdsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdPy5jb21wb25lbnRUeXBlXX0uYCk7XHJcbiAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0QnVmZmVyRGF0YShfaUFjY2Vzc29yOiBudW1iZXIpOiBQcm9taXNlPFR5cGVkQXJyYXk+IHtcclxuICAgICAgY29uc3QgZ2x0ZkFjY2Vzc29yOiBHTFRGLkFjY2Vzc29yID0gdGhpcy5nbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXTtcclxuICAgICAgaWYgKCFnbHRmQWNjZXNzb3IpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhY2Nlc3NvclwiKTtcclxuXHJcbiAgICAgIGNvbnN0IGdsdGZCdWZmZXJWaWV3OiBHTFRGLkJ1ZmZlclZpZXcgPSB0aGlzLmdsdGYuYnVmZmVyVmlld3NbZ2x0ZkFjY2Vzc29yLmJ1ZmZlclZpZXddO1xyXG4gICAgICBpZiAoIWdsdGZCdWZmZXJWaWV3KVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYnVmZmVyIHZpZXdcIik7XHJcblxyXG4gICAgICBjb25zdCBnbHRmQnVmZmVyOiBHTFRGLkJ1ZmZlciA9IHRoaXMuZ2x0Zi5idWZmZXJzW2dsdGZCdWZmZXJWaWV3LmJ1ZmZlcl07XHJcbiAgICAgIGlmICghZ2x0ZkJ1ZmZlcilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGJ1ZmZlclwiKTtcclxuXHJcbiAgICAgIGlmICghdGhpcy4jYnVmZmVycylcclxuICAgICAgICB0aGlzLiNidWZmZXJzID0gW107XHJcbiAgICAgIGlmICghdGhpcy4jYnVmZmVyc1tnbHRmQnVmZmVyVmlldy5idWZmZXJdKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZ2x0ZkJ1ZmZlci51cmkpO1xyXG4gICAgICAgIGNvbnN0IGJsb2I6IEJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XHJcbiAgICAgICAgdGhpcy4jYnVmZmVyc1tnbHRmQnVmZmVyVmlldy5idWZmZXJdID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBidWZmZXI6IEFycmF5QnVmZmVyID0gdGhpcy4jYnVmZmVyc1tnbHRmQnVmZmVyVmlldy5idWZmZXJdO1xyXG4gICAgICBjb25zdCBieXRlT2Zmc2V0OiBudW1iZXIgPSBnbHRmQnVmZmVyVmlldy5ieXRlT2Zmc2V0IHx8IDA7XHJcbiAgICAgIGNvbnN0IGJ5dGVMZW5ndGg6IG51bWJlciA9IGdsdGZCdWZmZXJWaWV3LmJ5dGVMZW5ndGggfHwgMDtcclxuXHJcbiAgICAgIHN3aXRjaCAoZ2x0ZkFjY2Vzc29yLmNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICBjYXNlIENvbXBvbmVudFR5cGUuVU5TSUdORURfQllURTpcclxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggLyBVaW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcclxuXHJcbiAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLkJZVEU6XHJcbiAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggLyBJbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xyXG5cclxuICAgICAgICBjYXNlIENvbXBvbmVudFR5cGUuVU5TSUdORURfU0hPUlQ6XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCAvIFVpbnQxNkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcclxuXHJcbiAgICAgICAgY2FzZSBDb21wb25lbnRUeXBlLlNIT1JUOlxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCAvIEludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xyXG5cclxuICAgICAgICBjYXNlIENvbXBvbmVudFR5cGUuVU5TSUdORURfSU5UOlxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XHJcblxyXG4gICAgICAgIGNhc2UgQ29tcG9uZW50VHlwZS5JTlQ6XHJcbiAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIC8gSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XHJcblxyXG4gICAgICAgIGNhc2UgQ29tcG9uZW50VHlwZS5GTE9BVDpcclxuICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudCB0eXBlOiAke2dsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlfS5gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaXNTa2VsZXRhbEFuaW1hdGlvbihfYW5pbWF0aW9uOiBHTFRGLkFuaW1hdGlvbik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gX2FuaW1hdGlvbi5jaGFubmVscy5ldmVyeShjaGFubmVsID0+IHRoaXMuaXNCb25lSW5kZXgoY2hhbm5lbC50YXJnZXQubm9kZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZmluZFNrZWxldGFsQW5pbWF0aW9uSW5kaWNlcyhfaVNrZWxldG9uOiBudW1iZXIpOiBudW1iZXJbXSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdsdGYuYW5pbWF0aW9uc1xyXG4gICAgICAgIC5maWx0ZXIoYW5pbWF0aW9uID0+IGFuaW1hdGlvbi5jaGFubmVscy5ldmVyeShjaGFubmVsID0+IHRoaXMuZ2x0Zi5za2luc1tfaVNrZWxldG9uXS5qb2ludHMuaW5jbHVkZXMoY2hhbm5lbC50YXJnZXQubm9kZSkpKVxyXG4gICAgICAgIC5tYXAoKF8sIGlBbmltYXRpb24pID0+IGlBbmltYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaXNCb25lSW5kZXgoX2lOb2RlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2x0Zi5za2lucz8uZmxhdE1hcChnbHRmU2tpbiA9PiBnbHRmU2tpbi5qb2ludHMpLmluY2x1ZGVzKF9pTm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjMoX3NhbXBsZXI6IEdMVEYuU2FtcGxlciwgX3RyYW5zZm9ybWF0aW9uVHlwZTogVHJhbnNmb3JtYXRpb25UeXBlKTogUHJvbWlzZTxBbmltYXRpb25TdHJ1Y3R1cmVWZWN0b3IzPiB7XHJcbiAgICAgIGNvbnN0IGlucHV0OiBGbG9hdDMyQXJyYXkgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShfc2FtcGxlci5pbnB1dCk7XHJcbiAgICAgIGNvbnN0IG91dHB1dDogRmxvYXQzMkFycmF5ID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoX3NhbXBsZXIub3V0cHV0KTtcclxuICAgICAgY29uc3QgbWlsbGlzUGVyU2Vjb25kOiBudW1iZXIgPSAxMDAwO1xyXG5cclxuICAgICAgY29uc3Qgc2VxdWVuY2VYOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBjb25zdCBzZXF1ZW5jZVk6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKCk7XHJcbiAgICAgIGNvbnN0IHNlcXVlbmNlWjogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHZlY3RvcjogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyIH0gPVxyXG4gICAgICAgICAgX3RyYW5zZm9ybWF0aW9uVHlwZSA9PSBcInJvdGF0aW9uXCIgP1xyXG4gICAgICAgICAgbmV3IFF1YXRlcm5pb24ob3V0cHV0W2kgKiA0ICsgMF0sIG91dHB1dFtpICogNCArIDFdLCBvdXRwdXRbaSAqIDQgKyAyXSwgb3V0cHV0W2kgKiA0ICsgM10pLnRvRGVncmVlcygpIDpcclxuICAgICAgICAgIHsgeDogb3V0cHV0W2kgKiAzICsgMF0sIHk6IG91dHB1dFtpICogMyArIDFdLCB6OiBvdXRwdXRbaSAqIDMgKyAyXSB9O1xyXG5cclxuICAgICAgICBzZXF1ZW5jZVguYWRkS2V5KG5ldyBBbmltYXRpb25LZXkobWlsbGlzUGVyU2Vjb25kICogaW5wdXRbaV0sIHZlY3Rvci54KSk7XHJcbiAgICAgICAgc2VxdWVuY2VZLmFkZEtleShuZXcgQW5pbWF0aW9uS2V5KG1pbGxpc1BlclNlY29uZCAqIGlucHV0W2ldLCB2ZWN0b3IueSkpO1xyXG4gICAgICAgIHNlcXVlbmNlWi5hZGRLZXkobmV3IEFuaW1hdGlvbktleShtaWxsaXNQZXJTZWNvbmQgKiBpbnB1dFtpXSwgdmVjdG9yLnopKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBzZXF1ZW5jZVgsXHJcbiAgICAgICAgeTogc2VxdWVuY2VZLFxyXG4gICAgICAgIHo6IHNlcXVlbmNlWlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0NvYXQvQ29hdC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU3RhdGljIHN1cGVyY2xhc3MgZm9yIHRoZSByZXByZXNlbnRhdGlvbiBvZiBXZWJHbCBzaGFkZXJwcm9ncmFtcy4gXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG5cclxuICAvLyBUT0RPOiBkZWZpbmUgYXR0cmlidXRlL3VuaWZvcm1zIGFzIGxheW91dCBhbmQgdXNlIHRob3NlIGNvbnNpc3RlbnRseSBpbiBzaGFkZXJzXHJcbiAgQFJlbmRlckluamVjdG9yU2hhZGVyLmRlY29yYXRlXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlciB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBTaGFkZXIgPSBTaGFkZXI7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBTaGFkZXJbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgdmVydGV4U2hhZGVyU291cmNlOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgc3RhdGljIGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmc7XHJcbiAgICBcclxuICAgIHB1YmxpYyBzdGF0aWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgcHVibGljIHN0YXRpYyBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcclxuICAgIHB1YmxpYyBzdGF0aWMgdW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH07XHJcblxyXG4gICAgLyoqIFRoZSB0eXBlIG9mIGNvYXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoaXMgc2hhZGVyIHRvIGNyZWF0ZSBhIG1hdGVyaWFsICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdENvbG9yZWQ7IH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLnZlcnRleFNoYWRlclNvdXJjZTsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZTsgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgdXNlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH0gXHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBTaGFkZXIpOiBudW1iZXIgeyByZXR1cm4gU2hhZGVyLnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdCBleHRlbmRzIFNoYWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJGbGF0KTtcblxuICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgXCJMSUdIVFwiLFxuICAgIFwiRkxBVFwiLFxuICAgIFwiQ0FNRVJBXCJcbl07XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmU7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIEZMQVRcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgMjAyMSwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogYnVmZmVycyBmb3IgdHJhbnNmb3JtYXRpb25cclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5cclxuICAvLyBMSUdIVDogb2ZmZXIgYnVmZmVycyBmb3IgbGlnaHRpbmcgdmVydGljZXMgd2l0aCBkaWZmZXJlbnQgbGlnaHQgdHlwZXNcclxuICAjaWYgZGVmaW5lZChMSUdIVClcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbmluIHZlYzMgYV92Y3ROb3JtYWw7XHJcbnVuaWZvcm0gZmxvYXQgdV9mRGlmZnVzZTtcclxuXHJcbnN0cnVjdCBMaWdodEFtYmllbnQge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG4gIHZlYzMgdmN0RGlyZWN0aW9uO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTAwdTtcclxuXHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAjZW5kaWYgXHJcblxyXG4gIC8vIFRFWFRVUkU6IG9mZmVyIGJ1ZmZlcnMgZm9yIFVWcyBhbmQgcGl2b3QgbWF0cml4XHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxudW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7XHJcbmluIHZlYzIgYV92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBDQU1FUkE6IG9mZmVyIGJ1ZmZlciBhbmQgZnVuY3Rpb25hbGl0eSBmb3Igc3BlY3VsYXIgcmVmbGVjdGlvbiBkZXBlbmRpbmcgb24gdGhlIGNhbWVyYS1wb3NpdGlvblxyXG4gICNpZiBkZWZpbmVkKENBTUVSQSlcclxudW5pZm9ybSBmbG9hdCB1X2ZTcGVjdWxhcjtcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbnVuaWZvcm0gbWF0NCB1X210eFdvcmxkVG9WaWV3O1xyXG51bmlmb3JtIHZlYzMgdV92Y3RDYW1lcmE7XHJcblxyXG5mbG9hdCBjYWxjdWxhdGVSZWZsZWN0aW9uKHZlYzMgX3ZjdExpZ2h0LCB2ZWMzIF92Y3RWaWV3LCB2ZWMzIF92Y3ROb3JtYWwsIGZsb2F0IF9mU3BlY3VsYXIpIHtcclxuICBpZihfZlNwZWN1bGFyIDw9IDAuMClcclxuICAgIHJldHVybiAwLjA7XHJcbiAgdmVjMyB2Y3RSZWZsZWN0aW9uID0gbm9ybWFsaXplKHJlZmxlY3QoLV92Y3RMaWdodCwgX3ZjdE5vcm1hbCkpO1xyXG4gIGZsb2F0IGZIaXRDYW1lcmEgPSBkb3QodmN0UmVmbGVjdGlvbiwgX3ZjdFZpZXcpO1xyXG4gIHJldHVybiBwb3cobWF4KGZIaXRDYW1lcmEsIDAuMCksIF9mU3BlY3VsYXIgKiAxMC4wKSAqIF9mU3BlY3VsYXI7IC8vIDEwLjAgPSBtYWdpYyBudW1iZXIsIGxvb2tzIGdvb2QuLi4gXHJcbn1cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoU0tJTilcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbi8vIEJvbmVzXHJcbnN0cnVjdCBCb25lIHtcclxuICBtYXQ0IG1hdHJpeDtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0JPTkVTID0gMTB1O1xyXG5cclxuaW4gdXZlYzQgYV9pQm9uZTtcclxuaW4gdmVjNCBhX2ZXZWlnaHQ7XHJcblxyXG51bmlmb3JtIEJvbmUgdV9ib25lc1tNQVhfQk9ORVNdO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBGTEFUOiBvdXRidWZmZXIgaXMgZmxhdFxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcbmZsYXQgb3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZWxzZVxyXG4gIC8vIHJlZ3VsYXIgaWYgbm90IEZMQVRcclxub3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICB2ZWM0IHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gIG1hdDQgbXR4TWVzaFRvVmlldyA9IHVfbXR4TWVzaFRvVmlldztcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVCkgfHwgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBhX3ZjdE5vcm1hbDtcclxuICBtYXQ0IG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuICAgICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgdl92Y3RDb2xvciA9IHVfZkRpZmZ1c2UgKiB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgICAgICNlbmRpZlxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoU0tJTilcclxuICBtYXQ0IG10eFNraW4gPSBhX2ZXZWlnaHQueCAqIHVfYm9uZXNbYV9pQm9uZS54XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LnkgKiB1X2JvbmVzW2FfaUJvbmUueV0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC56ICogdV9ib25lc1thX2lCb25lLnpdLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQudyAqIHVfYm9uZXNbYV9pQm9uZS53XS5tYXRyaXg7XHJcblxyXG4gIG10eE1lc2hUb1ZpZXcgKj0gbXR4U2tpbjtcclxuICBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHRyYW5zcG9zZShpbnZlcnNlKHVfbXR4TWVzaFRvV29ybGQgKiBtdHhTa2luKSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb24gYW5kIG5vcm1hbCBhY2NvcmRpbmcgdG8gaW5wdXQgYW5kIGRlZmluZXNcclxuICBnbF9Qb3NpdGlvbiA9IG10eE1lc2hUb1ZpZXcgKiB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgLy8gdmlldyB2ZWN0b3IgbmVlZGVkXHJcbiAgLy8gdmVjNCBwb3NXb3JsZDQgPSB1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb247XHJcbiAgLy8gdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHBvc1dvcmxkNC54eXovcG9zV29ybGQ0LncgLSB1X3ZjdENhbWVyYSk7XHJcbiAgdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHZlYzModV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uKSAtIHVfdmN0Q2FtZXJhKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKG10eE5vcm1hbE1lc2hUb1dvcmxkKSAqIHZjdE5vcm1hbCk7XHJcbiAgLy8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25hbCBsaWdodGluZyBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdCh2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbGx1bWluYXRpb24gPiAwLjBmKSB7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gdV9mRGlmZnVzZSAqIGZJbGx1bWluYXRpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAgICAgZmxvYXQgZlJlZmxlY3Rpb24gPSBjYWxjdWxhdGVSZWZsZWN0aW9uKHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfZlNwZWN1bGFyKTtcclxuICAgICAgdl92Y3RDb2xvciArPSBmUmVmbGVjdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICB9XHJcbiAgfVxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogdHJhbnNmb3JtIFVWc1xyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChNQVRDQVApXHJcbiAgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbCk7XHJcbiAgdmN0Tm9ybWFsID0gbWF0Myh1X210eFdvcmxkVG9WaWV3KSAqIHZjdE5vcm1hbDtcclxuICB2X3ZjdFRleHR1cmUgPSAwLjUgKiB2Y3ROb3JtYWwueHkgLyBsZW5ndGgodmN0Tm9ybWFsKSArIDAuNTtcclxuICB2X3ZjdFRleHR1cmUueSAqPSAtMS4wO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gYWx3YXlzIGZ1bGwgb3BhY2l0eSBmb3Igbm93Li4uXHJcbiAgdl92Y3RDb2xvci5hID0gMS4wO1xyXG59XG5gOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIEZMQVRcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdFNraW4gZXh0ZW5kcyBTaGFkZXIge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyRmxhdFNraW4pO1xuXG4gIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcbiAgICBcIkxJR0hUXCIsXG4gICAgXCJGTEFUXCIsXG4gICAgXCJTS0lOXCJcbl07XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmU7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIEZMQVRcbiNkZWZpbmUgU0tJTlxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIDIwMjEsIEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxuXHJcbiAgLy8gTElHSFQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGxpZ2h0aW5nIHZlcnRpY2VzIHdpdGggZGlmZmVyZW50IGxpZ2h0IHR5cGVzXHJcbiAgI2lmIGRlZmluZWQoTElHSFQpXHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG51bmlmb3JtIGZsb2F0IHVfZkRpZmZ1c2U7XHJcblxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG59O1xyXG5zdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICB2ZWMzIHZjdERpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcblxyXG51bmlmb3JtIExpZ2h0QW1iaWVudCB1X2FtYmllbnQ7XHJcbnVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxudW5pZm9ybSBMaWdodERpcmVjdGlvbmFsIHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgI2VuZGlmIFxyXG5cclxuICAvLyBURVhUVVJFOiBvZmZlciBidWZmZXJzIGZvciBVVnMgYW5kIHBpdm90IG1hdHJpeFxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xyXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChNQVRDQVApIC8vIE1hdENhcC1zaGFkZXIgZ2VuZXJhdGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSBzdXJmYWNlIG5vcm1hbHNcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gQ0FNRVJBOiBvZmZlciBidWZmZXIgYW5kIGZ1bmN0aW9uYWxpdHkgZm9yIHNwZWN1bGFyIHJlZmxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjYW1lcmEtcG9zaXRpb25cclxuICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbnVuaWZvcm0gZmxvYXQgdV9mU3BlY3VsYXI7XHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxuZmxvYXQgY2FsY3VsYXRlUmVmbGVjdGlvbih2ZWMzIF92Y3RMaWdodCwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCBmbG9hdCBfZlNwZWN1bGFyKSB7XHJcbiAgaWYoX2ZTcGVjdWxhciA8PSAwLjApXHJcbiAgICByZXR1cm4gMC4wO1xyXG4gIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1fdmN0TGlnaHQsIF92Y3ROb3JtYWwpKTtcclxuICBmbG9hdCBmSGl0Q2FtZXJhID0gZG90KHZjdFJlZmxlY3Rpb24sIF92Y3RWaWV3KTtcclxuICByZXR1cm4gcG93KG1heChmSGl0Q2FtZXJhLCAwLjApLCBfZlNwZWN1bGFyICogMTAuMCkgKiBfZlNwZWN1bGFyOyAvLyAxMC4wID0gbWFnaWMgbnVtYmVyLCBsb29rcyBnb29kLi4uIFxyXG59XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKFNLSU4pXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG4vLyBCb25lc1xyXG5zdHJ1Y3QgQm9uZSB7XHJcbiAgbWF0NCBtYXRyaXg7XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9CT05FUyA9IDEwdTtcclxuXHJcbmluIHV2ZWM0IGFfaUJvbmU7XHJcbmluIHZlYzQgYV9mV2VpZ2h0O1xyXG5cclxudW5pZm9ybSBCb25lIHVfYm9uZXNbTUFYX0JPTkVTXTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gRkxBVDogb3V0YnVmZmVyIGlzIGZsYXRcclxuICAjaWYgZGVmaW5lZChGTEFUKVxyXG5mbGF0IG91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2Vsc2VcclxuICAvLyByZWd1bGFyIGlmIG5vdCBGTEFUXHJcbm91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjNCB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICBtYXQ0IG10eE1lc2hUb1ZpZXcgPSB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzMgdmN0Tm9ybWFsID0gYV92Y3ROb3JtYWw7XHJcbiAgbWF0NCBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbiAgICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIHZfdmN0Q29sb3IgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gICAgICAjZW5kaWZcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKFNLSU4pXHJcbiAgbWF0NCBtdHhTa2luID0gYV9mV2VpZ2h0LnggKiB1X2JvbmVzW2FfaUJvbmUueF0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC55ICogdV9ib25lc1thX2lCb25lLnldLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQueiAqIHVfYm9uZXNbYV9pQm9uZS56XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LncgKiB1X2JvbmVzW2FfaUJvbmUud10ubWF0cml4O1xyXG5cclxuICBtdHhNZXNoVG9WaWV3ICo9IG10eFNraW47XHJcbiAgbXR4Tm9ybWFsTWVzaFRvV29ybGQgPSB0cmFuc3Bvc2UoaW52ZXJzZSh1X210eE1lc2hUb1dvcmxkICogbXR4U2tpbikpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uIGFuZCBub3JtYWwgYWNjb3JkaW5nIHRvIGlucHV0IGFuZCBkZWZpbmVzXHJcbiAgZ2xfUG9zaXRpb24gPSBtdHhNZXNoVG9WaWV3ICogdmN0UG9zaXRpb247XHJcblxyXG4gICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gIC8vIHZpZXcgdmVjdG9yIG5lZWRlZFxyXG4gIC8vIHZlYzQgcG9zV29ybGQ0ID0gdV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uO1xyXG4gIC8vIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZShwb3NXb3JsZDQueHl6L3Bvc1dvcmxkNC53IC0gdV92Y3RDYW1lcmEpO1xyXG4gIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2ZWMzKHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbikgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0MyhtdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiB2Y3ROb3JtYWwpO1xyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uYWwgbGlnaHRpbmcgZWZmZWN0XHJcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QodmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbik7XHJcbiAgICBpZihmSWxsdW1pbmF0aW9uID4gMC4wZikge1xyXG4gICAgICB2X3ZjdENvbG9yICs9IHVfZkRpZmZ1c2UgKiBmSWxsdW1pbmF0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgICAgIGZsb2F0IGZSZWZsZWN0aW9uID0gY2FsY3VsYXRlUmVmbGVjdGlvbih1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbiwgdmN0VmlldywgdmN0Tm9ybWFsLCB1X2ZTcGVjdWxhcik7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZlJlZmxlY3Rpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNlbmRpZlxyXG4gICAgfVxyXG4gIH1cclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IHRyYW5zZm9ybSBVVnNcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbiAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWwpO1xyXG4gIHZjdE5vcm1hbCA9IG1hdDModV9tdHhXb3JsZFRvVmlldykgKiB2Y3ROb3JtYWw7XHJcbiAgdl92Y3RUZXh0dXJlID0gMC41ICogdmN0Tm9ybWFsLnh5IC8gbGVuZ3RoKHZjdE5vcm1hbCkgKyAwLjU7XHJcbiAgdl92Y3RUZXh0dXJlLnkgKj0gLTEuMDtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGFsd2F5cyBmdWxsIG9wYWNpdHkgZm9yIG5vdy4uLlxyXG4gIHZfdmN0Q29sb3IuYSA9IDEuMDtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBMSUdIVFxuI2RlZmluZSBGTEFUXG4jZGVmaW5lIFNLSU5cblxyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBpbmNsdWRlIGJhc2UgY29sb3JcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcblxyXG4gIC8vIEZMQVQ6IGlucHV0IHZlcnRleCBjb2xvcnMgZmxhdCwgc28gdGhlIHRoaXJkIG9mIGEgdHJpYW5nbGUgZGV0ZXJtaW5lcyB0aGUgY29sb3JcclxuICAjaWYgZGVmaW5lZChGTEFUKSBcclxuZmxhdCBpbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgLy8gTElHSFQ6IGlucHV0IHZlcnRleCBjb2xvcnMgZm9yIGVhY2ggdmVydGV4IGZvciBpbnRlcnBvbGF0aW9uIG92ZXIgdGhlIGZhY2VcclxuICAjZWxpZiBkZWZpbmVkKExJR0hUKVxyXG5pbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIFRFWFRVUkU6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG5pbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxub3V0IHZlYzQgdmN0RnJhZztcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAgIC8vIE1JTklNQUw6IHNldCB0aGUgYmFzZSBjb2xvclxyXG4gIHZjdEZyYWcgPSB1X3ZjdENvbG9yO1xyXG5cclxuICAgIC8vIFZFUlRFWDogbXVsdGlwbHkgd2l0aCB2ZXJ0ZXggY29sb3JcclxuICAgICNpZiBkZWZpbmVkKEZMQVQpIHx8IGRlZmluZWQoTElHSFQpXHJcbiAgdmN0RnJhZyAqPSB2X3ZjdENvbG9yO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogbXVsdGlwbHkgd2l0aCB0ZXhlbCBjb2xvclxyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjNCB2Y3RDb2xvclRleHR1cmUgPSB0ZXh0dXJlKHVfdGV4dHVyZSwgdl92Y3RUZXh0dXJlKTtcclxuICB2Y3RGcmFnICo9IHZjdENvbG9yVGV4dHVyZTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGRpc2NhcmQgcGl4ZWwgYWxsdG9nZXRoZXIgd2hlbiB0cmFuc3BhcmVudDogZG9uJ3Qgc2hvdyBpbiBaLUJ1ZmZlclxyXG4gIGlmKHZjdEZyYWcuYSA8IDAuMDEpXHJcbiAgICBkaXNjYXJkO1xyXG59XG5gOyB9XG59XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4vKiogQ29kZSBnZW5lcmF0ZWQgYnkgQ29tcGlsZVNoYWRlcnMubWpzIHVzaW5nIHRoZSBpbmZvcm1hdGlvbiBpbiBDb21waWxlU2hhZGVycy5qc29uICovXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0VGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyRmxhdFRleHR1cmVkKTtcblxuICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgXCJMSUdIVFwiLFxuICAgIFwiRkxBVFwiLFxuICAgIFwiVEVYVFVSRVwiLFxuICAgIFwiQ0FNRVJBXCJcbl07XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgTElHSFRcbiNkZWZpbmUgRkxBVFxuI2RlZmluZSBURVhUVVJFXG4jZGVmaW5lIENBTUVSQVxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIDIwMjEsIEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxuXHJcbiAgLy8gTElHSFQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGxpZ2h0aW5nIHZlcnRpY2VzIHdpdGggZGlmZmVyZW50IGxpZ2h0IHR5cGVzXHJcbiAgI2lmIGRlZmluZWQoTElHSFQpXHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG51bmlmb3JtIGZsb2F0IHVfZkRpZmZ1c2U7XHJcblxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG59O1xyXG5zdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICB2ZWMzIHZjdERpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcblxyXG51bmlmb3JtIExpZ2h0QW1iaWVudCB1X2FtYmllbnQ7XHJcbnVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxudW5pZm9ybSBMaWdodERpcmVjdGlvbmFsIHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgI2VuZGlmIFxyXG5cclxuICAvLyBURVhUVVJFOiBvZmZlciBidWZmZXJzIGZvciBVVnMgYW5kIHBpdm90IG1hdHJpeFxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xyXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChNQVRDQVApIC8vIE1hdENhcC1zaGFkZXIgZ2VuZXJhdGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSBzdXJmYWNlIG5vcm1hbHNcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gQ0FNRVJBOiBvZmZlciBidWZmZXIgYW5kIGZ1bmN0aW9uYWxpdHkgZm9yIHNwZWN1bGFyIHJlZmxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjYW1lcmEtcG9zaXRpb25cclxuICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbnVuaWZvcm0gZmxvYXQgdV9mU3BlY3VsYXI7XHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxuZmxvYXQgY2FsY3VsYXRlUmVmbGVjdGlvbih2ZWMzIF92Y3RMaWdodCwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCBmbG9hdCBfZlNwZWN1bGFyKSB7XHJcbiAgaWYoX2ZTcGVjdWxhciA8PSAwLjApXHJcbiAgICByZXR1cm4gMC4wO1xyXG4gIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1fdmN0TGlnaHQsIF92Y3ROb3JtYWwpKTtcclxuICBmbG9hdCBmSGl0Q2FtZXJhID0gZG90KHZjdFJlZmxlY3Rpb24sIF92Y3RWaWV3KTtcclxuICByZXR1cm4gcG93KG1heChmSGl0Q2FtZXJhLCAwLjApLCBfZlNwZWN1bGFyICogMTAuMCkgKiBfZlNwZWN1bGFyOyAvLyAxMC4wID0gbWFnaWMgbnVtYmVyLCBsb29rcyBnb29kLi4uIFxyXG59XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKFNLSU4pXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG4vLyBCb25lc1xyXG5zdHJ1Y3QgQm9uZSB7XHJcbiAgbWF0NCBtYXRyaXg7XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9CT05FUyA9IDEwdTtcclxuXHJcbmluIHV2ZWM0IGFfaUJvbmU7XHJcbmluIHZlYzQgYV9mV2VpZ2h0O1xyXG5cclxudW5pZm9ybSBCb25lIHVfYm9uZXNbTUFYX0JPTkVTXTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gRkxBVDogb3V0YnVmZmVyIGlzIGZsYXRcclxuICAjaWYgZGVmaW5lZChGTEFUKVxyXG5mbGF0IG91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2Vsc2VcclxuICAvLyByZWd1bGFyIGlmIG5vdCBGTEFUXHJcbm91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjNCB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICBtYXQ0IG10eE1lc2hUb1ZpZXcgPSB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzMgdmN0Tm9ybWFsID0gYV92Y3ROb3JtYWw7XHJcbiAgbWF0NCBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbiAgICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIHZfdmN0Q29sb3IgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gICAgICAjZW5kaWZcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKFNLSU4pXHJcbiAgbWF0NCBtdHhTa2luID0gYV9mV2VpZ2h0LnggKiB1X2JvbmVzW2FfaUJvbmUueF0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC55ICogdV9ib25lc1thX2lCb25lLnldLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQueiAqIHVfYm9uZXNbYV9pQm9uZS56XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LncgKiB1X2JvbmVzW2FfaUJvbmUud10ubWF0cml4O1xyXG5cclxuICBtdHhNZXNoVG9WaWV3ICo9IG10eFNraW47XHJcbiAgbXR4Tm9ybWFsTWVzaFRvV29ybGQgPSB0cmFuc3Bvc2UoaW52ZXJzZSh1X210eE1lc2hUb1dvcmxkICogbXR4U2tpbikpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uIGFuZCBub3JtYWwgYWNjb3JkaW5nIHRvIGlucHV0IGFuZCBkZWZpbmVzXHJcbiAgZ2xfUG9zaXRpb24gPSBtdHhNZXNoVG9WaWV3ICogdmN0UG9zaXRpb247XHJcblxyXG4gICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gIC8vIHZpZXcgdmVjdG9yIG5lZWRlZFxyXG4gIC8vIHZlYzQgcG9zV29ybGQ0ID0gdV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uO1xyXG4gIC8vIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZShwb3NXb3JsZDQueHl6L3Bvc1dvcmxkNC53IC0gdV92Y3RDYW1lcmEpO1xyXG4gIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2ZWMzKHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbikgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0MyhtdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiB2Y3ROb3JtYWwpO1xyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uYWwgbGlnaHRpbmcgZWZmZWN0XHJcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QodmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbik7XHJcbiAgICBpZihmSWxsdW1pbmF0aW9uID4gMC4wZikge1xyXG4gICAgICB2X3ZjdENvbG9yICs9IHVfZkRpZmZ1c2UgKiBmSWxsdW1pbmF0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgICAgIGZsb2F0IGZSZWZsZWN0aW9uID0gY2FsY3VsYXRlUmVmbGVjdGlvbih1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbiwgdmN0VmlldywgdmN0Tm9ybWFsLCB1X2ZTcGVjdWxhcik7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZlJlZmxlY3Rpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNlbmRpZlxyXG4gICAgfVxyXG4gIH1cclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IHRyYW5zZm9ybSBVVnNcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbiAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWwpO1xyXG4gIHZjdE5vcm1hbCA9IG1hdDModV9tdHhXb3JsZFRvVmlldykgKiB2Y3ROb3JtYWw7XHJcbiAgdl92Y3RUZXh0dXJlID0gMC41ICogdmN0Tm9ybWFsLnh5IC8gbGVuZ3RoKHZjdE5vcm1hbCkgKyAwLjU7XHJcbiAgdl92Y3RUZXh0dXJlLnkgKj0gLTEuMDtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGFsd2F5cyBmdWxsIG9wYWNpdHkgZm9yIG5vdy4uLlxyXG4gIHZfdmN0Q29sb3IuYSA9IDEuMDtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBMSUdIVFxuI2RlZmluZSBGTEFUXG4jZGVmaW5lIFRFWFRVUkVcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyR291cmF1ZCBleHRlbmRzIFNoYWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJHb3VyYXVkKTtcblxuICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgXCJMSUdIVFwiLFxuICAgIFwiQ0FNRVJBXCJcbl07XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmU7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIENBTUVSQVxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIDIwMjEsIEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxuXHJcbiAgLy8gTElHSFQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGxpZ2h0aW5nIHZlcnRpY2VzIHdpdGggZGlmZmVyZW50IGxpZ2h0IHR5cGVzXHJcbiAgI2lmIGRlZmluZWQoTElHSFQpXHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG51bmlmb3JtIGZsb2F0IHVfZkRpZmZ1c2U7XHJcblxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG59O1xyXG5zdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICB2ZWMzIHZjdERpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcblxyXG51bmlmb3JtIExpZ2h0QW1iaWVudCB1X2FtYmllbnQ7XHJcbnVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxudW5pZm9ybSBMaWdodERpcmVjdGlvbmFsIHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgI2VuZGlmIFxyXG5cclxuICAvLyBURVhUVVJFOiBvZmZlciBidWZmZXJzIGZvciBVVnMgYW5kIHBpdm90IG1hdHJpeFxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xyXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChNQVRDQVApIC8vIE1hdENhcC1zaGFkZXIgZ2VuZXJhdGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSBzdXJmYWNlIG5vcm1hbHNcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gQ0FNRVJBOiBvZmZlciBidWZmZXIgYW5kIGZ1bmN0aW9uYWxpdHkgZm9yIHNwZWN1bGFyIHJlZmxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjYW1lcmEtcG9zaXRpb25cclxuICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbnVuaWZvcm0gZmxvYXQgdV9mU3BlY3VsYXI7XHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxuZmxvYXQgY2FsY3VsYXRlUmVmbGVjdGlvbih2ZWMzIF92Y3RMaWdodCwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCBmbG9hdCBfZlNwZWN1bGFyKSB7XHJcbiAgaWYoX2ZTcGVjdWxhciA8PSAwLjApXHJcbiAgICByZXR1cm4gMC4wO1xyXG4gIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1fdmN0TGlnaHQsIF92Y3ROb3JtYWwpKTtcclxuICBmbG9hdCBmSGl0Q2FtZXJhID0gZG90KHZjdFJlZmxlY3Rpb24sIF92Y3RWaWV3KTtcclxuICByZXR1cm4gcG93KG1heChmSGl0Q2FtZXJhLCAwLjApLCBfZlNwZWN1bGFyICogMTAuMCkgKiBfZlNwZWN1bGFyOyAvLyAxMC4wID0gbWFnaWMgbnVtYmVyLCBsb29rcyBnb29kLi4uIFxyXG59XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKFNLSU4pXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG4vLyBCb25lc1xyXG5zdHJ1Y3QgQm9uZSB7XHJcbiAgbWF0NCBtYXRyaXg7XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9CT05FUyA9IDEwdTtcclxuXHJcbmluIHV2ZWM0IGFfaUJvbmU7XHJcbmluIHZlYzQgYV9mV2VpZ2h0O1xyXG5cclxudW5pZm9ybSBCb25lIHVfYm9uZXNbTUFYX0JPTkVTXTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gRkxBVDogb3V0YnVmZmVyIGlzIGZsYXRcclxuICAjaWYgZGVmaW5lZChGTEFUKVxyXG5mbGF0IG91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2Vsc2VcclxuICAvLyByZWd1bGFyIGlmIG5vdCBGTEFUXHJcbm91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjNCB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICBtYXQ0IG10eE1lc2hUb1ZpZXcgPSB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzMgdmN0Tm9ybWFsID0gYV92Y3ROb3JtYWw7XHJcbiAgbWF0NCBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbiAgICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIHZfdmN0Q29sb3IgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gICAgICAjZW5kaWZcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKFNLSU4pXHJcbiAgbWF0NCBtdHhTa2luID0gYV9mV2VpZ2h0LnggKiB1X2JvbmVzW2FfaUJvbmUueF0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC55ICogdV9ib25lc1thX2lCb25lLnldLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQueiAqIHVfYm9uZXNbYV9pQm9uZS56XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LncgKiB1X2JvbmVzW2FfaUJvbmUud10ubWF0cml4O1xyXG5cclxuICBtdHhNZXNoVG9WaWV3ICo9IG10eFNraW47XHJcbiAgbXR4Tm9ybWFsTWVzaFRvV29ybGQgPSB0cmFuc3Bvc2UoaW52ZXJzZSh1X210eE1lc2hUb1dvcmxkICogbXR4U2tpbikpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uIGFuZCBub3JtYWwgYWNjb3JkaW5nIHRvIGlucHV0IGFuZCBkZWZpbmVzXHJcbiAgZ2xfUG9zaXRpb24gPSBtdHhNZXNoVG9WaWV3ICogdmN0UG9zaXRpb247XHJcblxyXG4gICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gIC8vIHZpZXcgdmVjdG9yIG5lZWRlZFxyXG4gIC8vIHZlYzQgcG9zV29ybGQ0ID0gdV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uO1xyXG4gIC8vIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZShwb3NXb3JsZDQueHl6L3Bvc1dvcmxkNC53IC0gdV92Y3RDYW1lcmEpO1xyXG4gIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2ZWMzKHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbikgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0MyhtdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiB2Y3ROb3JtYWwpO1xyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uYWwgbGlnaHRpbmcgZWZmZWN0XHJcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QodmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbik7XHJcbiAgICBpZihmSWxsdW1pbmF0aW9uID4gMC4wZikge1xyXG4gICAgICB2X3ZjdENvbG9yICs9IHVfZkRpZmZ1c2UgKiBmSWxsdW1pbmF0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgICAgIGZsb2F0IGZSZWZsZWN0aW9uID0gY2FsY3VsYXRlUmVmbGVjdGlvbih1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbiwgdmN0VmlldywgdmN0Tm9ybWFsLCB1X2ZTcGVjdWxhcik7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZlJlZmxlY3Rpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNlbmRpZlxyXG4gICAgfVxyXG4gIH1cclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IHRyYW5zZm9ybSBVVnNcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbiAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWwpO1xyXG4gIHZjdE5vcm1hbCA9IG1hdDModV9tdHhXb3JsZFRvVmlldykgKiB2Y3ROb3JtYWw7XHJcbiAgdl92Y3RUZXh0dXJlID0gMC41ICogdmN0Tm9ybWFsLnh5IC8gbGVuZ3RoKHZjdE5vcm1hbCkgKyAwLjU7XHJcbiAgdl92Y3RUZXh0dXJlLnkgKj0gLTEuMDtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGFsd2F5cyBmdWxsIG9wYWNpdHkgZm9yIG5vdy4uLlxyXG4gIHZfdmN0Q29sb3IuYSA9IDEuMDtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBMSUdIVFxuI2RlZmluZSBDQU1FUkFcblxyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBpbmNsdWRlIGJhc2UgY29sb3JcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcblxyXG4gIC8vIEZMQVQ6IGlucHV0IHZlcnRleCBjb2xvcnMgZmxhdCwgc28gdGhlIHRoaXJkIG9mIGEgdHJpYW5nbGUgZGV0ZXJtaW5lcyB0aGUgY29sb3JcclxuICAjaWYgZGVmaW5lZChGTEFUKSBcclxuZmxhdCBpbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgLy8gTElHSFQ6IGlucHV0IHZlcnRleCBjb2xvcnMgZm9yIGVhY2ggdmVydGV4IGZvciBpbnRlcnBvbGF0aW9uIG92ZXIgdGhlIGZhY2VcclxuICAjZWxpZiBkZWZpbmVkKExJR0hUKVxyXG5pbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIFRFWFRVUkU6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG5pbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxub3V0IHZlYzQgdmN0RnJhZztcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAgIC8vIE1JTklNQUw6IHNldCB0aGUgYmFzZSBjb2xvclxyXG4gIHZjdEZyYWcgPSB1X3ZjdENvbG9yO1xyXG5cclxuICAgIC8vIFZFUlRFWDogbXVsdGlwbHkgd2l0aCB2ZXJ0ZXggY29sb3JcclxuICAgICNpZiBkZWZpbmVkKEZMQVQpIHx8IGRlZmluZWQoTElHSFQpXHJcbiAgdmN0RnJhZyAqPSB2X3ZjdENvbG9yO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogbXVsdGlwbHkgd2l0aCB0ZXhlbCBjb2xvclxyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjNCB2Y3RDb2xvclRleHR1cmUgPSB0ZXh0dXJlKHVfdGV4dHVyZSwgdl92Y3RUZXh0dXJlKTtcclxuICB2Y3RGcmFnICo9IHZjdENvbG9yVGV4dHVyZTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGRpc2NhcmQgcGl4ZWwgYWxsdG9nZXRoZXIgd2hlbiB0cmFuc3BhcmVudDogZG9uJ3Qgc2hvdyBpbiBaLUJ1ZmZlclxyXG4gIGlmKHZjdEZyYWcuYSA8IDAuMDEpXHJcbiAgICBkaXNjYXJkO1xyXG59XG5gOyB9XG59XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4vKiogQ29kZSBnZW5lcmF0ZWQgYnkgQ29tcGlsZVNoYWRlcnMubWpzIHVzaW5nIHRoZSBpbmZvcm1hdGlvbiBpbiBDb21waWxlU2hhZGVycy5qc29uICovXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJHb3VyYXVkU2tpbiBleHRlbmRzIFNoYWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJHb3VyYXVkU2tpbik7XG5cbiAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgIFwiTElHSFRcIixcbiAgICBcIlNLSU5cIlxuXTtcblxuICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgTElHSFRcbiNkZWZpbmUgU0tJTlxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIDIwMjEsIEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGJ1ZmZlcnMgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxuXHJcbiAgLy8gTElHSFQ6IG9mZmVyIGJ1ZmZlcnMgZm9yIGxpZ2h0aW5nIHZlcnRpY2VzIHdpdGggZGlmZmVyZW50IGxpZ2h0IHR5cGVzXHJcbiAgI2lmIGRlZmluZWQoTElHSFQpXHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG51bmlmb3JtIGZsb2F0IHVfZkRpZmZ1c2U7XHJcblxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG59O1xyXG5zdHJ1Y3QgTGlnaHREaXJlY3Rpb25hbCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICB2ZWMzIHZjdERpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcblxyXG51bmlmb3JtIExpZ2h0QW1iaWVudCB1X2FtYmllbnQ7XHJcbnVuaWZvcm0gdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxudW5pZm9ybSBMaWdodERpcmVjdGlvbmFsIHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgI2VuZGlmIFxyXG5cclxuICAvLyBURVhUVVJFOiBvZmZlciBidWZmZXJzIGZvciBVVnMgYW5kIHBpdm90IG1hdHJpeFxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xyXG5pbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChNQVRDQVApIC8vIE1hdENhcC1zaGFkZXIgZ2VuZXJhdGVzIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSBzdXJmYWNlIG5vcm1hbHNcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gQ0FNRVJBOiBvZmZlciBidWZmZXIgYW5kIGZ1bmN0aW9uYWxpdHkgZm9yIHNwZWN1bGFyIHJlZmxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjYW1lcmEtcG9zaXRpb25cclxuICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbnVuaWZvcm0gZmxvYXQgdV9mU3BlY3VsYXI7XHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxuZmxvYXQgY2FsY3VsYXRlUmVmbGVjdGlvbih2ZWMzIF92Y3RMaWdodCwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCBmbG9hdCBfZlNwZWN1bGFyKSB7XHJcbiAgaWYoX2ZTcGVjdWxhciA8PSAwLjApXHJcbiAgICByZXR1cm4gMC4wO1xyXG4gIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShyZWZsZWN0KC1fdmN0TGlnaHQsIF92Y3ROb3JtYWwpKTtcclxuICBmbG9hdCBmSGl0Q2FtZXJhID0gZG90KHZjdFJlZmxlY3Rpb24sIF92Y3RWaWV3KTtcclxuICByZXR1cm4gcG93KG1heChmSGl0Q2FtZXJhLCAwLjApLCBfZlNwZWN1bGFyICogMTAuMCkgKiBfZlNwZWN1bGFyOyAvLyAxMC4wID0gbWFnaWMgbnVtYmVyLCBsb29rcyBnb29kLi4uIFxyXG59XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKFNLSU4pXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkO1xyXG4vLyBCb25lc1xyXG5zdHJ1Y3QgQm9uZSB7XHJcbiAgbWF0NCBtYXRyaXg7XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9CT05FUyA9IDEwdTtcclxuXHJcbmluIHV2ZWM0IGFfaUJvbmU7XHJcbmluIHZlYzQgYV9mV2VpZ2h0O1xyXG5cclxudW5pZm9ybSBCb25lIHVfYm9uZXNbTUFYX0JPTkVTXTtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gRkxBVDogb3V0YnVmZmVyIGlzIGZsYXRcclxuICAjaWYgZGVmaW5lZChGTEFUKVxyXG5mbGF0IG91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2Vsc2VcclxuICAvLyByZWd1bGFyIGlmIG5vdCBGTEFUXHJcbm91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjNCB2Y3RQb3NpdGlvbiA9IHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuICBtYXQ0IG10eE1lc2hUb1ZpZXcgPSB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzMgdmN0Tm9ybWFsID0gYV92Y3ROb3JtYWw7XHJcbiAgbWF0NCBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbiAgICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIHZfdmN0Q29sb3IgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yO1xyXG4gICAgICAjZW5kaWZcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKFNLSU4pXHJcbiAgbWF0NCBtdHhTa2luID0gYV9mV2VpZ2h0LnggKiB1X2JvbmVzW2FfaUJvbmUueF0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC55ICogdV9ib25lc1thX2lCb25lLnldLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQueiAqIHVfYm9uZXNbYV9pQm9uZS56XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LncgKiB1X2JvbmVzW2FfaUJvbmUud10ubWF0cml4O1xyXG5cclxuICBtdHhNZXNoVG9WaWV3ICo9IG10eFNraW47XHJcbiAgbXR4Tm9ybWFsTWVzaFRvV29ybGQgPSB0cmFuc3Bvc2UoaW52ZXJzZSh1X210eE1lc2hUb1dvcmxkICogbXR4U2tpbikpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHBvc2l0aW9uIGFuZCBub3JtYWwgYWNjb3JkaW5nIHRvIGlucHV0IGFuZCBkZWZpbmVzXHJcbiAgZ2xfUG9zaXRpb24gPSBtdHhNZXNoVG9WaWV3ICogdmN0UG9zaXRpb247XHJcblxyXG4gICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gIC8vIHZpZXcgdmVjdG9yIG5lZWRlZFxyXG4gIC8vIHZlYzQgcG9zV29ybGQ0ID0gdV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uO1xyXG4gIC8vIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZShwb3NXb3JsZDQueHl6L3Bvc1dvcmxkNC53IC0gdV92Y3RDYW1lcmEpO1xyXG4gIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2ZWMzKHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbikgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0MyhtdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiB2Y3ROb3JtYWwpO1xyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGlyZWN0aW9uYWwgbGlnaHRpbmcgZWZmZWN0XHJcbiAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgZmxvYXQgZklsbHVtaW5hdGlvbiA9IC1kb3QodmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbik7XHJcbiAgICBpZihmSWxsdW1pbmF0aW9uID4gMC4wZikge1xyXG4gICAgICB2X3ZjdENvbG9yICs9IHVfZkRpZmZ1c2UgKiBmSWxsdW1pbmF0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgICAgIGZsb2F0IGZSZWZsZWN0aW9uID0gY2FsY3VsYXRlUmVmbGVjdGlvbih1X2RpcmVjdGlvbmFsW2ldLnZjdERpcmVjdGlvbiwgdmN0VmlldywgdmN0Tm9ybWFsLCB1X2ZTcGVjdWxhcik7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gZlJlZmxlY3Rpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNlbmRpZlxyXG4gICAgfVxyXG4gIH1cclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IHRyYW5zZm9ybSBVVnNcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcbiAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWwpO1xyXG4gIHZjdE5vcm1hbCA9IG1hdDModV9tdHhXb3JsZFRvVmlldykgKiB2Y3ROb3JtYWw7XHJcbiAgdl92Y3RUZXh0dXJlID0gMC41ICogdmN0Tm9ybWFsLnh5IC8gbGVuZ3RoKHZjdE5vcm1hbCkgKyAwLjU7XHJcbiAgdl92Y3RUZXh0dXJlLnkgKj0gLTEuMDtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGFsd2F5cyBmdWxsIG9wYWNpdHkgZm9yIG5vdy4uLlxyXG4gIHZfdmN0Q29sb3IuYSA9IDEuMDtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBMSUdIVFxuI2RlZmluZSBTS0lOXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyR291cmF1ZFRleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckdvdXJhdWRUZXh0dXJlZCk7XG5cbiAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xuICAgIFwiTElHSFRcIixcbiAgICBcIlRFWFRVUkVcIixcbiAgICBcIkNBTUVSQVwiXG5dO1xuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlVGV4dHVyZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIFRFWFRVUkVcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgMjAyMSwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogYnVmZmVycyBmb3IgdHJhbnNmb3JtYXRpb25cclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5cclxuICAvLyBMSUdIVDogb2ZmZXIgYnVmZmVycyBmb3IgbGlnaHRpbmcgdmVydGljZXMgd2l0aCBkaWZmZXJlbnQgbGlnaHQgdHlwZXNcclxuICAjaWYgZGVmaW5lZChMSUdIVClcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbmluIHZlYzMgYV92Y3ROb3JtYWw7XHJcbnVuaWZvcm0gZmxvYXQgdV9mRGlmZnVzZTtcclxuXHJcbnN0cnVjdCBMaWdodEFtYmllbnQge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG4gIHZlYzMgdmN0RGlyZWN0aW9uO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTAwdTtcclxuXHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAjZW5kaWYgXHJcblxyXG4gIC8vIFRFWFRVUkU6IG9mZmVyIGJ1ZmZlcnMgZm9yIFVWcyBhbmQgcGl2b3QgbWF0cml4XHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxudW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7XHJcbmluIHZlYzIgYV92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBDQU1FUkE6IG9mZmVyIGJ1ZmZlciBhbmQgZnVuY3Rpb25hbGl0eSBmb3Igc3BlY3VsYXIgcmVmbGVjdGlvbiBkZXBlbmRpbmcgb24gdGhlIGNhbWVyYS1wb3NpdGlvblxyXG4gICNpZiBkZWZpbmVkKENBTUVSQSlcclxudW5pZm9ybSBmbG9hdCB1X2ZTcGVjdWxhcjtcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbnVuaWZvcm0gbWF0NCB1X210eFdvcmxkVG9WaWV3O1xyXG51bmlmb3JtIHZlYzMgdV92Y3RDYW1lcmE7XHJcblxyXG5mbG9hdCBjYWxjdWxhdGVSZWZsZWN0aW9uKHZlYzMgX3ZjdExpZ2h0LCB2ZWMzIF92Y3RWaWV3LCB2ZWMzIF92Y3ROb3JtYWwsIGZsb2F0IF9mU3BlY3VsYXIpIHtcclxuICBpZihfZlNwZWN1bGFyIDw9IDAuMClcclxuICAgIHJldHVybiAwLjA7XHJcbiAgdmVjMyB2Y3RSZWZsZWN0aW9uID0gbm9ybWFsaXplKHJlZmxlY3QoLV92Y3RMaWdodCwgX3ZjdE5vcm1hbCkpO1xyXG4gIGZsb2F0IGZIaXRDYW1lcmEgPSBkb3QodmN0UmVmbGVjdGlvbiwgX3ZjdFZpZXcpO1xyXG4gIHJldHVybiBwb3cobWF4KGZIaXRDYW1lcmEsIDAuMCksIF9mU3BlY3VsYXIgKiAxMC4wKSAqIF9mU3BlY3VsYXI7IC8vIDEwLjAgPSBtYWdpYyBudW1iZXIsIGxvb2tzIGdvb2QuLi4gXHJcbn1cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoU0tJTilcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbi8vIEJvbmVzXHJcbnN0cnVjdCBCb25lIHtcclxuICBtYXQ0IG1hdHJpeDtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0JPTkVTID0gMTB1O1xyXG5cclxuaW4gdXZlYzQgYV9pQm9uZTtcclxuaW4gdmVjNCBhX2ZXZWlnaHQ7XHJcblxyXG51bmlmb3JtIEJvbmUgdV9ib25lc1tNQVhfQk9ORVNdO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBGTEFUOiBvdXRidWZmZXIgaXMgZmxhdFxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcbmZsYXQgb3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZWxzZVxyXG4gIC8vIHJlZ3VsYXIgaWYgbm90IEZMQVRcclxub3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICB2ZWM0IHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gIG1hdDQgbXR4TWVzaFRvVmlldyA9IHVfbXR4TWVzaFRvVmlldztcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVCkgfHwgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBhX3ZjdE5vcm1hbDtcclxuICBtYXQ0IG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuICAgICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgdl92Y3RDb2xvciA9IHVfZkRpZmZ1c2UgKiB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgICAgICNlbmRpZlxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoU0tJTilcclxuICBtYXQ0IG10eFNraW4gPSBhX2ZXZWlnaHQueCAqIHVfYm9uZXNbYV9pQm9uZS54XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LnkgKiB1X2JvbmVzW2FfaUJvbmUueV0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC56ICogdV9ib25lc1thX2lCb25lLnpdLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQudyAqIHVfYm9uZXNbYV9pQm9uZS53XS5tYXRyaXg7XHJcblxyXG4gIG10eE1lc2hUb1ZpZXcgKj0gbXR4U2tpbjtcclxuICBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHRyYW5zcG9zZShpbnZlcnNlKHVfbXR4TWVzaFRvV29ybGQgKiBtdHhTa2luKSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb24gYW5kIG5vcm1hbCBhY2NvcmRpbmcgdG8gaW5wdXQgYW5kIGRlZmluZXNcclxuICBnbF9Qb3NpdGlvbiA9IG10eE1lc2hUb1ZpZXcgKiB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgLy8gdmlldyB2ZWN0b3IgbmVlZGVkXHJcbiAgLy8gdmVjNCBwb3NXb3JsZDQgPSB1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb247XHJcbiAgLy8gdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHBvc1dvcmxkNC54eXovcG9zV29ybGQ0LncgLSB1X3ZjdENhbWVyYSk7XHJcbiAgdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHZlYzModV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uKSAtIHVfdmN0Q2FtZXJhKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKG10eE5vcm1hbE1lc2hUb1dvcmxkKSAqIHZjdE5vcm1hbCk7XHJcbiAgLy8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25hbCBsaWdodGluZyBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdCh2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbGx1bWluYXRpb24gPiAwLjBmKSB7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gdV9mRGlmZnVzZSAqIGZJbGx1bWluYXRpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAgICAgZmxvYXQgZlJlZmxlY3Rpb24gPSBjYWxjdWxhdGVSZWZsZWN0aW9uKHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfZlNwZWN1bGFyKTtcclxuICAgICAgdl92Y3RDb2xvciArPSBmUmVmbGVjdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICB9XHJcbiAgfVxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogdHJhbnNmb3JtIFVWc1xyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChNQVRDQVApXHJcbiAgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbCk7XHJcbiAgdmN0Tm9ybWFsID0gbWF0Myh1X210eFdvcmxkVG9WaWV3KSAqIHZjdE5vcm1hbDtcclxuICB2X3ZjdFRleHR1cmUgPSAwLjUgKiB2Y3ROb3JtYWwueHkgLyBsZW5ndGgodmN0Tm9ybWFsKSArIDAuNTtcclxuICB2X3ZjdFRleHR1cmUueSAqPSAtMS4wO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gYWx3YXlzIGZ1bGwgb3BhY2l0eSBmb3Igbm93Li4uXHJcbiAgdl92Y3RDb2xvci5hID0gMS4wO1xyXG59XG5gOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIExJR0hUXG4jZGVmaW5lIFRFWFRVUkVcbiNkZWZpbmUgQ0FNRVJBXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyTGl0IGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckxpdCk7XG5cbiAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW107XG5cbiAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRDb2xvcmVkOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyAyMDIxLCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBidWZmZXJzIGZvciB0cmFuc2Zvcm1hdGlvblxyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9WaWV3O1xyXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb247XHJcblxyXG4gIC8vIExJR0hUOiBvZmZlciBidWZmZXJzIGZvciBsaWdodGluZyB2ZXJ0aWNlcyB3aXRoIGRpZmZlcmVudCBsaWdodCB0eXBlc1xyXG4gICNpZiBkZWZpbmVkKExJR0hUKVxyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbDtcclxudW5pZm9ybSBmbG9hdCB1X2ZEaWZmdXNlO1xyXG5cclxuc3RydWN0IExpZ2h0QW1iaWVudCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxufTtcclxuc3RydWN0IExpZ2h0RGlyZWN0aW9uYWwge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbiAgdmVjMyB2Y3REaXJlY3Rpb247XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgPSAxMDB1O1xyXG5cclxudW5pZm9ybSBMaWdodEFtYmllbnQgdV9hbWJpZW50O1xyXG51bmlmb3JtIHVpbnQgdV9uTGlnaHRzRGlyZWN0aW9uYWw7XHJcbnVuaWZvcm0gTGlnaHREaXJlY3Rpb25hbCB1X2RpcmVjdGlvbmFsW01BWF9MSUdIVFNfRElSRUNUSU9OQUxdO1xyXG4gICNlbmRpZiBcclxuXHJcbiAgLy8gVEVYVFVSRTogb2ZmZXIgYnVmZmVycyBmb3IgVVZzIGFuZCBwaXZvdCBtYXRyaXhcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG51bmlmb3JtIG1hdDMgdV9tdHhQaXZvdDtcclxuaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoTUFUQ0FQKSAvLyBNYXRDYXAtc2hhZGVyIGdlbmVyYXRlcyB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZyb20gc3VyZmFjZSBub3JtYWxzXHJcbmluIHZlYzMgYV92Y3ROb3JtYWw7XHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIENBTUVSQTogb2ZmZXIgYnVmZmVyIGFuZCBmdW5jdGlvbmFsaXR5IGZvciBzcGVjdWxhciByZWZsZWN0aW9uIGRlcGVuZGluZyBvbiB0aGUgY2FtZXJhLXBvc2l0aW9uXHJcbiAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG51bmlmb3JtIGZsb2F0IHVfZlNwZWN1bGFyO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7XHJcbnVuaWZvcm0gdmVjMyB1X3ZjdENhbWVyYTtcclxuXHJcbmZsb2F0IGNhbGN1bGF0ZVJlZmxlY3Rpb24odmVjMyBfdmN0TGlnaHQsIHZlYzMgX3ZjdFZpZXcsIHZlYzMgX3ZjdE5vcm1hbCwgZmxvYXQgX2ZTcGVjdWxhcikge1xyXG4gIGlmKF9mU3BlY3VsYXIgPD0gMC4wKVxyXG4gICAgcmV0dXJuIDAuMDtcclxuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdCgtX3ZjdExpZ2h0LCBfdmN0Tm9ybWFsKSk7XHJcbiAgZmxvYXQgZkhpdENhbWVyYSA9IGRvdCh2Y3RSZWZsZWN0aW9uLCBfdmN0Vmlldyk7XHJcbiAgcmV0dXJuIHBvdyhtYXgoZkhpdENhbWVyYSwgMC4wKSwgX2ZTcGVjdWxhciAqIDEwLjApICogX2ZTcGVjdWxhcjsgLy8gMTAuMCA9IG1hZ2ljIG51bWJlciwgbG9va3MgZ29vZC4uLiBcclxufVxyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChTS0lOKVxyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxuLy8gQm9uZXNcclxuc3RydWN0IEJvbmUge1xyXG4gIG1hdDQgbWF0cml4O1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfQk9ORVMgPSAxMHU7XHJcblxyXG5pbiB1dmVjNCBhX2lCb25lO1xyXG5pbiB2ZWM0IGFfZldlaWdodDtcclxuXHJcbnVuaWZvcm0gQm9uZSB1X2JvbmVzW01BWF9CT05FU107XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIEZMQVQ6IG91dGJ1ZmZlciBpcyBmbGF0XHJcbiAgI2lmIGRlZmluZWQoRkxBVClcclxuZmxhdCBvdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbHNlXHJcbiAgLy8gcmVndWxhciBpZiBub3QgRkxBVFxyXG5vdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHZlYzQgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XHJcbiAgbWF0NCBtdHhNZXNoVG9WaWV3ID0gdV9tdHhNZXNoVG9WaWV3O1xyXG5cclxuICAgICNpZiBkZWZpbmVkKExJR0hUKSB8fCBkZWZpbmVkKE1BVENBUClcclxuICB2ZWMzIHZjdE5vcm1hbCA9IGFfdmN0Tm9ybWFsO1xyXG4gIG1hdDQgbXR4Tm9ybWFsTWVzaFRvV29ybGQgPSB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG4gICAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICB2X3ZjdENvbG9yID0gdV9mRGlmZnVzZSAqIHVfYW1iaWVudC52Y3RDb2xvcjtcclxuICAgICAgI2VuZGlmXHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChTS0lOKVxyXG4gIG1hdDQgbXR4U2tpbiA9IGFfZldlaWdodC54ICogdV9ib25lc1thX2lCb25lLnhdLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQueSAqIHVfYm9uZXNbYV9pQm9uZS55XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LnogKiB1X2JvbmVzW2FfaUJvbmUuel0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC53ICogdV9ib25lc1thX2lCb25lLnddLm1hdHJpeDtcclxuXHJcbiAgbXR4TWVzaFRvVmlldyAqPSBtdHhTa2luO1xyXG4gIG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdHJhbnNwb3NlKGludmVyc2UodV9tdHhNZXNoVG9Xb3JsZCAqIG10eFNraW4pKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBhbmQgbm9ybWFsIGFjY29yZGluZyB0byBpbnB1dCBhbmQgZGVmaW5lc1xyXG4gIGdsX1Bvc2l0aW9uID0gbXR4TWVzaFRvVmlldyAqIHZjdFBvc2l0aW9uO1xyXG5cclxuICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAvLyB2aWV3IHZlY3RvciBuZWVkZWRcclxuICAvLyB2ZWM0IHBvc1dvcmxkNCA9IHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbjtcclxuICAvLyB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUocG9zV29ybGQ0Lnh5ei9wb3NXb3JsZDQudyAtIHVfdmN0Q2FtZXJhKTtcclxuICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodmVjMyh1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb24pIC0gdV92Y3RDYW1lcmEpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDMobXR4Tm9ybWFsTWVzaFRvV29ybGQpICogdmN0Tm9ybWFsKTtcclxuICAvLyBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvbmFsIGxpZ2h0aW5nIGVmZmVjdFxyXG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgIGZsb2F0IGZJbGx1bWluYXRpb24gPSAtZG90KHZjdE5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24pO1xyXG4gICAgaWYoZklsbHVtaW5hdGlvbiA+IDAuMGYpIHtcclxuICAgICAgdl92Y3RDb2xvciArPSB1X2ZEaWZmdXNlICogZklsbHVtaW5hdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gICAgICBmbG9hdCBmUmVmbGVjdGlvbiA9IGNhbGN1bGF0ZVJlZmxlY3Rpb24odV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9mU3BlY3VsYXIpO1xyXG4gICAgICB2X3ZjdENvbG9yICs9IGZSZWZsZWN0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjZW5kaWZcclxuICAgIH1cclxuICB9XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiB0cmFuc2Zvcm0gVVZzXHJcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG4gIHZfdmN0VGV4dHVyZSA9IHZlYzIodV9tdHhQaXZvdCAqIHZlYzMoYV92Y3RUZXh0dXJlLCAxLjApKS54eTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKE1BVENBUClcclxuICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsKTtcclxuICB2Y3ROb3JtYWwgPSBtYXQzKHVfbXR4V29ybGRUb1ZpZXcpICogdmN0Tm9ybWFsO1xyXG4gIHZfdmN0VGV4dHVyZSA9IDAuNSAqIHZjdE5vcm1hbC54eSAvIGxlbmd0aCh2Y3ROb3JtYWwpICsgMC41O1xyXG4gIHZfdmN0VGV4dHVyZS55ICo9IC0xLjA7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBhbHdheXMgZnVsbCBvcGFjaXR5IGZvciBub3cuLi5cclxuICB2X3ZjdENvbG9yLmEgPSAxLjA7XHJcbn1cbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuKi9cclxuXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogaW5jbHVkZSBiYXNlIGNvbG9yXHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICAvLyBGTEFUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZsYXQsIHNvIHRoZSB0aGlyZCBvZiBhIHRyaWFuZ2xlIGRldGVybWluZXMgdGhlIGNvbG9yXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgXHJcbmZsYXQgaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gIC8vIExJR0hUOiBpbnB1dCB2ZXJ0ZXggY29sb3JzIGZvciBlYWNoIHZlcnRleCBmb3IgaW50ZXJwb2xhdGlvbiBvdmVyIHRoZSBmYWNlXHJcbiAgI2VsaWYgZGVmaW5lZChMSUdIVClcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBURVhUVVJFOiBpbnB1dCBVVnMgYW5kIHRleHR1cmVcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICAvLyBNSU5JTUFMOiBzZXQgdGhlIGJhc2UgY29sb3JcclxuICB2Y3RGcmFnID0gdV92Y3RDb2xvcjtcclxuXHJcbiAgICAvLyBWRVJURVg6IG11bHRpcGx5IHdpdGggdmVydGV4IGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdEZyYWcgKj0gdl92Y3RDb2xvcjtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG4gIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCAwLjAxKVxyXG4gICAgZGlzY2FyZDtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyTGl0VGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTGl0VGV4dHVyZWQpO1xuXG4gIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcbiAgICBcIlRFWFRVUkVcIlxuXTtcblxuICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFRleHR1cmVkOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xuI2RlZmluZSBURVhUVVJFXG5cclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgMjAyMSwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxuICAvLyBNSU5JTUFMIChubyBkZWZpbmUgbmVlZGVkKTogYnVmZmVycyBmb3IgdHJhbnNmb3JtYXRpb25cclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5cclxuICAvLyBMSUdIVDogb2ZmZXIgYnVmZmVycyBmb3IgbGlnaHRpbmcgdmVydGljZXMgd2l0aCBkaWZmZXJlbnQgbGlnaHQgdHlwZXNcclxuICAjaWYgZGVmaW5lZChMSUdIVClcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcbmluIHZlYzMgYV92Y3ROb3JtYWw7XHJcbnVuaWZvcm0gZmxvYXQgdV9mRGlmZnVzZTtcclxuXHJcbnN0cnVjdCBMaWdodEFtYmllbnQge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICB2ZWM0IHZjdENvbG9yO1xyXG4gIHZlYzMgdmN0RGlyZWN0aW9uO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTAwdTtcclxuXHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAjZW5kaWYgXHJcblxyXG4gIC8vIFRFWFRVUkU6IG9mZmVyIGJ1ZmZlcnMgZm9yIFVWcyBhbmQgcGl2b3QgbWF0cml4XHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxudW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7XHJcbmluIHZlYzIgYV92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBDQU1FUkE6IG9mZmVyIGJ1ZmZlciBhbmQgZnVuY3Rpb25hbGl0eSBmb3Igc3BlY3VsYXIgcmVmbGVjdGlvbiBkZXBlbmRpbmcgb24gdGhlIGNhbWVyYS1wb3NpdGlvblxyXG4gICNpZiBkZWZpbmVkKENBTUVSQSlcclxudW5pZm9ybSBmbG9hdCB1X2ZTcGVjdWxhcjtcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbnVuaWZvcm0gbWF0NCB1X210eFdvcmxkVG9WaWV3O1xyXG51bmlmb3JtIHZlYzMgdV92Y3RDYW1lcmE7XHJcblxyXG5mbG9hdCBjYWxjdWxhdGVSZWZsZWN0aW9uKHZlYzMgX3ZjdExpZ2h0LCB2ZWMzIF92Y3RWaWV3LCB2ZWMzIF92Y3ROb3JtYWwsIGZsb2F0IF9mU3BlY3VsYXIpIHtcclxuICBpZihfZlNwZWN1bGFyIDw9IDAuMClcclxuICAgIHJldHVybiAwLjA7XHJcbiAgdmVjMyB2Y3RSZWZsZWN0aW9uID0gbm9ybWFsaXplKHJlZmxlY3QoLV92Y3RMaWdodCwgX3ZjdE5vcm1hbCkpO1xyXG4gIGZsb2F0IGZIaXRDYW1lcmEgPSBkb3QodmN0UmVmbGVjdGlvbiwgX3ZjdFZpZXcpO1xyXG4gIHJldHVybiBwb3cobWF4KGZIaXRDYW1lcmEsIDAuMCksIF9mU3BlY3VsYXIgKiAxMC4wKSAqIF9mU3BlY3VsYXI7IC8vIDEwLjAgPSBtYWdpYyBudW1iZXIsIGxvb2tzIGdvb2QuLi4gXHJcbn1cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoU0tJTilcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7XHJcbi8vIEJvbmVzXHJcbnN0cnVjdCBCb25lIHtcclxuICBtYXQ0IG1hdHJpeDtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0JPTkVTID0gMTB1O1xyXG5cclxuaW4gdXZlYzQgYV9pQm9uZTtcclxuaW4gdmVjNCBhX2ZXZWlnaHQ7XHJcblxyXG51bmlmb3JtIEJvbmUgdV9ib25lc1tNQVhfQk9ORVNdO1xyXG4gICNlbmRpZlxyXG5cclxuICAvLyBGTEFUOiBvdXRidWZmZXIgaXMgZmxhdFxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcbmZsYXQgb3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZWxzZVxyXG4gIC8vIHJlZ3VsYXIgaWYgbm90IEZMQVRcclxub3V0IHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICB2ZWM0IHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gIG1hdDQgbXR4TWVzaFRvVmlldyA9IHVfbXR4TWVzaFRvVmlldztcclxuXHJcbiAgICAjaWYgZGVmaW5lZChMSUdIVCkgfHwgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSBhX3ZjdE5vcm1hbDtcclxuICBtYXQ0IG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuICAgICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgdl92Y3RDb2xvciA9IHVfZkRpZmZ1c2UgKiB1X2FtYmllbnQudmN0Q29sb3I7XHJcbiAgICAgICNlbmRpZlxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoU0tJTilcclxuICBtYXQ0IG10eFNraW4gPSBhX2ZXZWlnaHQueCAqIHVfYm9uZXNbYV9pQm9uZS54XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LnkgKiB1X2JvbmVzW2FfaUJvbmUueV0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC56ICogdV9ib25lc1thX2lCb25lLnpdLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQudyAqIHVfYm9uZXNbYV9pQm9uZS53XS5tYXRyaXg7XHJcblxyXG4gIG10eE1lc2hUb1ZpZXcgKj0gbXR4U2tpbjtcclxuICBtdHhOb3JtYWxNZXNoVG9Xb3JsZCA9IHRyYW5zcG9zZShpbnZlcnNlKHVfbXR4TWVzaFRvV29ybGQgKiBtdHhTa2luKSk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb24gYW5kIG5vcm1hbCBhY2NvcmRpbmcgdG8gaW5wdXQgYW5kIGRlZmluZXNcclxuICBnbF9Qb3NpdGlvbiA9IG10eE1lc2hUb1ZpZXcgKiB2Y3RQb3NpdGlvbjtcclxuXHJcbiAgICAjaWYgZGVmaW5lZChDQU1FUkEpXHJcbiAgLy8gdmlldyB2ZWN0b3IgbmVlZGVkXHJcbiAgLy8gdmVjNCBwb3NXb3JsZDQgPSB1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb247XHJcbiAgLy8gdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHBvc1dvcmxkNC54eXovcG9zV29ybGQ0LncgLSB1X3ZjdENhbWVyYSk7XHJcbiAgdmVjMyB2Y3RWaWV3ID0gbm9ybWFsaXplKHZlYzModV9tdHhNZXNoVG9Xb3JsZCAqIHZjdFBvc2l0aW9uKSAtIHVfdmN0Q2FtZXJhKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKExJR0hUKVxyXG4gIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKG10eE5vcm1hbE1lc2hUb1dvcmxkKSAqIHZjdE5vcm1hbCk7XHJcbiAgLy8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb25hbCBsaWdodGluZyBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNEaXJlY3Rpb25hbDsgaSsrKSB7XHJcbiAgICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdCh2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbGx1bWluYXRpb24gPiAwLjBmKSB7XHJcbiAgICAgIHZfdmN0Q29sb3IgKz0gdV9mRGlmZnVzZSAqIGZJbGx1bWluYXRpb24gKiB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yO1xyXG4gICAgICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAgICAgZmxvYXQgZlJlZmxlY3Rpb24gPSBjYWxjdWxhdGVSZWZsZWN0aW9uKHVfZGlyZWN0aW9uYWxbaV0udmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfZlNwZWN1bGFyKTtcclxuICAgICAgdl92Y3RDb2xvciArPSBmUmVmbGVjdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2VuZGlmXHJcbiAgICB9XHJcbiAgfVxyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogdHJhbnNmb3JtIFVWc1xyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChNQVRDQVApXHJcbiAgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbCk7XHJcbiAgdmN0Tm9ybWFsID0gbWF0Myh1X210eFdvcmxkVG9WaWV3KSAqIHZjdE5vcm1hbDtcclxuICB2X3ZjdFRleHR1cmUgPSAwLjUgKiB2Y3ROb3JtYWwueHkgLyBsZW5ndGgodmN0Tm9ybWFsKSArIDAuNTtcclxuICB2X3ZjdFRleHR1cmUueSAqPSAtMS4wO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gYWx3YXlzIGZ1bGwgb3BhY2l0eSBmb3Igbm93Li4uXHJcbiAgdl92Y3RDb2xvci5hID0gMS4wO1xyXG59XG5gOyB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIFRFWFRVUkVcblxyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4qL1xyXG5cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBpbmNsdWRlIGJhc2UgY29sb3JcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcblxyXG4gIC8vIEZMQVQ6IGlucHV0IHZlcnRleCBjb2xvcnMgZmxhdCwgc28gdGhlIHRoaXJkIG9mIGEgdHJpYW5nbGUgZGV0ZXJtaW5lcyB0aGUgY29sb3JcclxuICAjaWYgZGVmaW5lZChGTEFUKSBcclxuZmxhdCBpbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgLy8gTElHSFQ6IGlucHV0IHZlcnRleCBjb2xvcnMgZm9yIGVhY2ggdmVydGV4IGZvciBpbnRlcnBvbGF0aW9uIG92ZXIgdGhlIGZhY2VcclxuICAjZWxpZiBkZWZpbmVkKExJR0hUKVxyXG5pbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIFRFWFRVUkU6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxyXG4gICNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG5pbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xyXG4gICNlbmRpZlxyXG5cclxub3V0IHZlYzQgdmN0RnJhZztcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAgIC8vIE1JTklNQUw6IHNldCB0aGUgYmFzZSBjb2xvclxyXG4gIHZjdEZyYWcgPSB1X3ZjdENvbG9yO1xyXG5cclxuICAgIC8vIFZFUlRFWDogbXVsdGlwbHkgd2l0aCB2ZXJ0ZXggY29sb3JcclxuICAgICNpZiBkZWZpbmVkKEZMQVQpIHx8IGRlZmluZWQoTElHSFQpXHJcbiAgdmN0RnJhZyAqPSB2X3ZjdENvbG9yO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gVEVYVFVSRTogbXVsdGlwbHkgd2l0aCB0ZXhlbCBjb2xvclxyXG4gICAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXHJcbiAgdmVjNCB2Y3RDb2xvclRleHR1cmUgPSB0ZXh0dXJlKHVfdGV4dHVyZSwgdl92Y3RUZXh0dXJlKTtcclxuICB2Y3RGcmFnICo9IHZjdENvbG9yVGV4dHVyZTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGRpc2NhcmQgcGl4ZWwgYWxsdG9nZXRoZXIgd2hlbiB0cmFuc3BhcmVudDogZG9uJ3Qgc2hvdyBpbiBaLUJ1ZmZlclxyXG4gIGlmKHZjdEZyYWcuYSA8IDAuMDEpXHJcbiAgICBkaXNjYXJkO1xyXG59XG5gOyB9XG59XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4vKiogQ29kZSBnZW5lcmF0ZWQgYnkgQ29tcGlsZVNoYWRlcnMubWpzIHVzaW5nIHRoZSBpbmZvcm1hdGlvbiBpbiBDb21waWxlU2hhZGVycy5qc29uICovXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJNYXRDYXAgZXh0ZW5kcyBTaGFkZXIge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTWF0Q2FwKTtcblxuICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXG4gICAgXCJDQU1FUkFcIixcbiAgICBcIk1BVENBUFwiXG5dO1xuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0VGV4dHVyZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXG4jZGVmaW5lIENBTUVSQVxuI2RlZmluZSBNQVRDQVBcblxyXG4vKipcclxuKiBVbml2ZXJzYWwgU2hhZGVyIGFzIGJhc2UgZm9yIG1hbnkgb3RoZXJzLiBDb250cm9sbGVkIGJ5IGNvbXBpbGVyIGRpcmVjdGl2ZXNcclxuKiBAYXV0aG9ycyAyMDIxLCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG4gIC8vIE1JTklNQUwgKG5vIGRlZmluZSBuZWVkZWQpOiBidWZmZXJzIGZvciB0cmFuc2Zvcm1hdGlvblxyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9WaWV3O1xyXG5pbiB2ZWMzIGFfdmN0UG9zaXRpb247XHJcblxyXG4gIC8vIExJR0hUOiBvZmZlciBidWZmZXJzIGZvciBsaWdodGluZyB2ZXJ0aWNlcyB3aXRoIGRpZmZlcmVudCBsaWdodCB0eXBlc1xyXG4gICNpZiBkZWZpbmVkKExJR0hUKVxyXG51bmlmb3JtIG1hdDQgdV9tdHhOb3JtYWxNZXNoVG9Xb3JsZDtcclxuaW4gdmVjMyBhX3ZjdE5vcm1hbDtcclxudW5pZm9ybSBmbG9hdCB1X2ZEaWZmdXNlO1xyXG5cclxuc3RydWN0IExpZ2h0QW1iaWVudCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxufTtcclxuc3RydWN0IExpZ2h0RGlyZWN0aW9uYWwge1xyXG4gIHZlYzQgdmN0Q29sb3I7XHJcbiAgdmVjMyB2Y3REaXJlY3Rpb247XHJcbn07XHJcblxyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgPSAxMDB1O1xyXG5cclxudW5pZm9ybSBMaWdodEFtYmllbnQgdV9hbWJpZW50O1xyXG51bmlmb3JtIHVpbnQgdV9uTGlnaHRzRGlyZWN0aW9uYWw7XHJcbnVuaWZvcm0gTGlnaHREaXJlY3Rpb25hbCB1X2RpcmVjdGlvbmFsW01BWF9MSUdIVFNfRElSRUNUSU9OQUxdO1xyXG4gICNlbmRpZiBcclxuXHJcbiAgLy8gVEVYVFVSRTogb2ZmZXIgYnVmZmVycyBmb3IgVVZzIGFuZCBwaXZvdCBtYXRyaXhcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG51bmlmb3JtIG1hdDMgdV9tdHhQaXZvdDtcclxuaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbm91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoTUFUQ0FQKSAvLyBNYXRDYXAtc2hhZGVyIGdlbmVyYXRlcyB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZyb20gc3VyZmFjZSBub3JtYWxzXHJcbmluIHZlYzMgYV92Y3ROb3JtYWw7XHJcbnVuaWZvcm0gbWF0NCB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG5vdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIENBTUVSQTogb2ZmZXIgYnVmZmVyIGFuZCBmdW5jdGlvbmFsaXR5IGZvciBzcGVjdWxhciByZWZsZWN0aW9uIGRlcGVuZGluZyBvbiB0aGUgY2FtZXJhLXBvc2l0aW9uXHJcbiAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG51bmlmb3JtIGZsb2F0IHVfZlNwZWN1bGFyO1xyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7XHJcbnVuaWZvcm0gdmVjMyB1X3ZjdENhbWVyYTtcclxuXHJcbmZsb2F0IGNhbGN1bGF0ZVJlZmxlY3Rpb24odmVjMyBfdmN0TGlnaHQsIHZlYzMgX3ZjdFZpZXcsIHZlYzMgX3ZjdE5vcm1hbCwgZmxvYXQgX2ZTcGVjdWxhcikge1xyXG4gIGlmKF9mU3BlY3VsYXIgPD0gMC4wKVxyXG4gICAgcmV0dXJuIDAuMDtcclxuICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdCgtX3ZjdExpZ2h0LCBfdmN0Tm9ybWFsKSk7XHJcbiAgZmxvYXQgZkhpdENhbWVyYSA9IGRvdCh2Y3RSZWZsZWN0aW9uLCBfdmN0Vmlldyk7XHJcbiAgcmV0dXJuIHBvdyhtYXgoZkhpdENhbWVyYSwgMC4wKSwgX2ZTcGVjdWxhciAqIDEwLjApICogX2ZTcGVjdWxhcjsgLy8gMTAuMCA9IG1hZ2ljIG51bWJlciwgbG9va3MgZ29vZC4uLiBcclxufVxyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChTS0lOKVxyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxuLy8gQm9uZXNcclxuc3RydWN0IEJvbmUge1xyXG4gIG1hdDQgbWF0cml4O1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfQk9ORVMgPSAxMHU7XHJcblxyXG5pbiB1dmVjNCBhX2lCb25lO1xyXG5pbiB2ZWM0IGFfZldlaWdodDtcclxuXHJcbnVuaWZvcm0gQm9uZSB1X2JvbmVzW01BWF9CT05FU107XHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIEZMQVQ6IG91dGJ1ZmZlciBpcyBmbGF0XHJcbiAgI2lmIGRlZmluZWQoRkxBVClcclxuZmxhdCBvdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbHNlXHJcbiAgLy8gcmVndWxhciBpZiBub3QgRkxBVFxyXG5vdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG4gICNlbmRpZlxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHZlYzQgdmN0UG9zaXRpb24gPSB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XHJcbiAgbWF0NCBtdHhNZXNoVG9WaWV3ID0gdV9tdHhNZXNoVG9WaWV3O1xyXG5cclxuICAgICNpZiBkZWZpbmVkKExJR0hUKSB8fCBkZWZpbmVkKE1BVENBUClcclxuICB2ZWMzIHZjdE5vcm1hbCA9IGFfdmN0Tm9ybWFsO1xyXG4gIG1hdDQgbXR4Tm9ybWFsTWVzaFRvV29ybGQgPSB1X210eE5vcm1hbE1lc2hUb1dvcmxkO1xyXG4gICAgICAjaWYgZGVmaW5lZChMSUdIVClcclxuICB2X3ZjdENvbG9yID0gdV9mRGlmZnVzZSAqIHVfYW1iaWVudC52Y3RDb2xvcjtcclxuICAgICAgI2VuZGlmXHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAjaWYgZGVmaW5lZChTS0lOKVxyXG4gIG1hdDQgbXR4U2tpbiA9IGFfZldlaWdodC54ICogdV9ib25lc1thX2lCb25lLnhdLm1hdHJpeCArXHJcbiAgICBhX2ZXZWlnaHQueSAqIHVfYm9uZXNbYV9pQm9uZS55XS5tYXRyaXggK1xyXG4gICAgYV9mV2VpZ2h0LnogKiB1X2JvbmVzW2FfaUJvbmUuel0ubWF0cml4ICtcclxuICAgIGFfZldlaWdodC53ICogdV9ib25lc1thX2lCb25lLnddLm1hdHJpeDtcclxuXHJcbiAgbXR4TWVzaFRvVmlldyAqPSBtdHhTa2luO1xyXG4gIG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdHJhbnNwb3NlKGludmVyc2UodV9tdHhNZXNoVG9Xb3JsZCAqIG10eFNraW4pKTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBhbmQgbm9ybWFsIGFjY29yZGluZyB0byBpbnB1dCBhbmQgZGVmaW5lc1xyXG4gIGdsX1Bvc2l0aW9uID0gbXR4TWVzaFRvVmlldyAqIHZjdFBvc2l0aW9uO1xyXG5cclxuICAgICNpZiBkZWZpbmVkKENBTUVSQSlcclxuICAvLyB2aWV3IHZlY3RvciBuZWVkZWRcclxuICAvLyB2ZWM0IHBvc1dvcmxkNCA9IHVfbXR4TWVzaFRvV29ybGQgKiB2Y3RQb3NpdGlvbjtcclxuICAvLyB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUocG9zV29ybGQ0Lnh5ei9wb3NXb3JsZDQudyAtIHVfdmN0Q2FtZXJhKTtcclxuICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodmVjMyh1X210eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb24pIC0gdV92Y3RDYW1lcmEpO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgI2lmIGRlZmluZWQoTElHSFQpXHJcbiAgdmN0Tm9ybWFsID0gbm9ybWFsaXplKG1hdDMobXR4Tm9ybWFsTWVzaFRvV29ybGQpICogdmN0Tm9ybWFsKTtcclxuICAvLyBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvbmFsIGxpZ2h0aW5nIGVmZmVjdFxyXG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgIGZsb2F0IGZJbGx1bWluYXRpb24gPSAtZG90KHZjdE5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24pO1xyXG4gICAgaWYoZklsbHVtaW5hdGlvbiA+IDAuMGYpIHtcclxuICAgICAgdl92Y3RDb2xvciArPSB1X2ZEaWZmdXNlICogZklsbHVtaW5hdGlvbiAqIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3I7XHJcbiAgICAgICAgI2lmIGRlZmluZWQoQ0FNRVJBKVxyXG4gICAgICBmbG9hdCBmUmVmbGVjdGlvbiA9IGNhbGN1bGF0ZVJlZmxlY3Rpb24odV9kaXJlY3Rpb25hbFtpXS52Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9mU3BlY3VsYXIpO1xyXG4gICAgICB2X3ZjdENvbG9yICs9IGZSZWZsZWN0aW9uICogdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvcjtcclxuICAgICAgICAjZW5kaWZcclxuICAgIH1cclxuICB9XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiB0cmFuc2Zvcm0gVVZzXHJcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG4gIHZfdmN0VGV4dHVyZSA9IHZlYzIodV9tdHhQaXZvdCAqIHZlYzMoYV92Y3RUZXh0dXJlLCAxLjApKS54eTtcclxuICAgICNlbmRpZlxyXG5cclxuICAgICNpZiBkZWZpbmVkKE1BVENBUClcclxuICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobWF0Myh1X210eE5vcm1hbE1lc2hUb1dvcmxkKSAqIGFfdmN0Tm9ybWFsKTtcclxuICB2Y3ROb3JtYWwgPSBtYXQzKHVfbXR4V29ybGRUb1ZpZXcpICogdmN0Tm9ybWFsO1xyXG4gIHZfdmN0VGV4dHVyZSA9IDAuNSAqIHZjdE5vcm1hbC54eSAvIGxlbmd0aCh2Y3ROb3JtYWwpICsgMC41O1xyXG4gIHZfdmN0VGV4dHVyZS55ICo9IC0xLjA7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBhbHdheXMgZnVsbCBvcGFjaXR5IGZvciBub3cuLi5cclxuICB2X3ZjdENvbG9yLmEgPSAxLjA7XHJcbn1cbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcbiNkZWZpbmUgQ0FNRVJBXG4jZGVmaW5lIE1BVENBUFxuXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiovXHJcblxyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHJcbiAgLy8gTUlOSU1BTCAobm8gZGVmaW5lIG5lZWRlZCk6IGluY2x1ZGUgYmFzZSBjb2xvclxyXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcclxuXHJcbiAgLy8gRkxBVDogaW5wdXQgdmVydGV4IGNvbG9ycyBmbGF0LCBzbyB0aGUgdGhpcmQgb2YgYSB0cmlhbmdsZSBkZXRlcm1pbmVzIHRoZSBjb2xvclxyXG4gICNpZiBkZWZpbmVkKEZMQVQpIFxyXG5mbGF0IGluIHZlYzQgdl92Y3RDb2xvcjtcclxuICAvLyBMSUdIVDogaW5wdXQgdmVydGV4IGNvbG9ycyBmb3IgZWFjaCB2ZXJ0ZXggZm9yIGludGVycG9sYXRpb24gb3ZlciB0aGUgZmFjZVxyXG4gICNlbGlmIGRlZmluZWQoTElHSFQpXHJcbmluIHZlYzQgdl92Y3RDb2xvcjtcclxuICAjZW5kaWZcclxuXHJcbiAgLy8gVEVYVFVSRTogaW5wdXQgVVZzIGFuZCB0ZXh0dXJlXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXHJcbmluIHZlYzIgdl92Y3RUZXh0dXJlO1xyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcbiAgI2VuZGlmXHJcblxyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG4gICAgLy8gTUlOSU1BTDogc2V0IHRoZSBiYXNlIGNvbG9yXHJcbiAgdmN0RnJhZyA9IHVfdmN0Q29sb3I7XHJcblxyXG4gICAgLy8gVkVSVEVYOiBtdWx0aXBseSB3aXRoIHZlcnRleCBjb2xvclxyXG4gICAgI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChMSUdIVClcclxuICB2Y3RGcmFnICo9IHZfdmN0Q29sb3I7XHJcbiAgICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiBtdWx0aXBseSB3aXRoIHRleGVsIGNvbG9yXHJcbiAgICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuICB2ZWM0IHZjdENvbG9yVGV4dHVyZSA9IHRleHR1cmUodV90ZXh0dXJlLCB2X3ZjdFRleHR1cmUpO1xyXG4gIHZjdEZyYWcgKj0gdmN0Q29sb3JUZXh0dXJlO1xyXG4gICAgI2VuZGlmXHJcblxyXG4gICAgLy8gZGlzY2FyZCBwaXhlbCBhbGx0b2dldGhlciB3aGVuIHRyYW5zcGFyZW50OiBkb24ndCBzaG93IGluIFotQnVmZmVyXHJcbiAgaWYodmN0RnJhZy5hIDwgMC4wMSlcclxuICAgIGRpc2NhcmQ7XHJcbn1cbmA7IH1cbn1cbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcbi8qKiBDb2RlIGdlbmVyYXRlZCBieSBDb21waWxlU2hhZGVycy5tanMgdXNpbmcgdGhlIGluZm9ybWF0aW9uIGluIENvbXBpbGVTaGFkZXJzLmpzb24gKi9cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nIGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclBob25nKTtcblxuICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXTtcblxuICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdENvbG9yZWQ7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyBcbnJldHVybiBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIFBob25nIHNoYWRpbmdcclxuKiBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL3d3dy5nc24tbGliLm9yZy9kb2NzL25vZGVzL1NoYWRlclBsdWdpbk5vZGUucGhwXHJcbiogQGF1dGhvcnMgTHVpcyBLZWNrLCBIRlUsIDIwMjFcclxuKi9cclxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5pbiB2ZWMzIGFfdmN0Tm9ybWFsVmVydGV4O1xyXG51bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDtcclxudW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvVmlldztcclxudW5pZm9ybSBtYXQ0IHVfbXR4Tm9ybWFsTWVzaFRvV29ybGQ7XHJcblxyXG5vdXQgdmVjMyBmX25vcm1hbDtcclxub3V0IHZlYzMgdl9wb3NpdGlvbjtcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICBmX25vcm1hbCA9IHZlYzModV9tdHhOb3JtYWxNZXNoVG9Xb3JsZCAqIHZlYzQoYV92Y3ROb3JtYWxWZXJ0ZXgsIDAuMCkpO1xyXG4gIHZlYzQgdl9wb3NpdGlvbjQgPSB1X210eE1lc2hUb1dvcmxkICogdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gIHZfcG9zaXRpb24gPSB2ZWMzKHZfcG9zaXRpb240KSAvIHZfcG9zaXRpb240Lnc7XHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eE1lc2hUb1ZpZXcgKiB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XHJcbn1cclxuICAgICAgICBcbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUGhvbmcgc2hhZGluZ1xyXG4qIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vd3d3Lmdzbi1saWIub3JnL2RvY3Mvbm9kZXMvU2hhZGVyUGx1Z2luTm9kZS5waHBcclxuKiBAYXV0aG9ycyBMdWlzIEtlY2ssIEhGVSwgMjAyMVxyXG4qL1xyXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblxyXG5zdHJ1Y3QgTGlnaHRBbWJpZW50IHtcclxuICAgIHZlYzQgY29sb3I7XHJcbn07XHJcbnN0cnVjdCBMaWdodERpcmVjdGlvbmFsIHtcclxuICAgIHZlYzQgY29sb3I7XHJcbiAgICB2ZWMzIGRpcmVjdGlvbjtcclxufTtcclxuXHJcbmNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDEwMHU7XHJcbnVuaWZvcm0gTGlnaHRBbWJpZW50IHVfYW1iaWVudDtcclxudW5pZm9ybSB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG51bmlmb3JtIExpZ2h0RGlyZWN0aW9uYWwgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuXHJcbmluIHZlYzMgZl9ub3JtYWw7XHJcbmluIHZlYzMgdl9wb3NpdGlvbjtcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcbnVuaWZvcm0gZmxvYXQgdV9mU3BlY3VsYXI7XHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG52ZWMzIGNhbGN1bGF0ZVJlZmxlY3Rpb24odmVjMyBsaWdodF9kaXIsIHZlYzMgdmlld19kaXIsIHZlYzMgbm9ybWFsLCBmbG9hdCBzaGluaW5lc3MpIHtcclxuICAgIHZlYzMgY29sb3IgPSB2ZWMzKDEpO1xyXG4gICAgdmVjMyBSID0gcmVmbGVjdCgtbGlnaHRfZGlyLCBub3JtYWwpO1xyXG4gICAgZmxvYXQgc3BlY19kb3QgPSBtYXgoZG90KFIsIHZpZXdfZGlyKSwgMC4wKTtcclxuICAgIGNvbG9yICs9IHBvdyhzcGVjX2RvdCwgc2hpbmluZXNzKTtcclxuICAgIHJldHVybiBjb2xvcjtcclxufVxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gICAgdmN0RnJhZyA9IHVfYW1iaWVudC5jb2xvcjtcclxuICAgIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgICAgICB2ZWMzIGxpZ2h0X2RpciA9IG5vcm1hbGl6ZSgtdV9kaXJlY3Rpb25hbFtpXS5kaXJlY3Rpb24pO1xyXG4gICAgICAgIHZlYzMgdmlld19kaXIgPSBub3JtYWxpemUodl9wb3NpdGlvbik7XHJcbiAgICAgICAgdmVjMyBOID0gbm9ybWFsaXplKGZfbm9ybWFsKTtcclxuXHJcbiAgICAgICAgZmxvYXQgaWxsdW1pbmFuY2UgPSBkb3QobGlnaHRfZGlyLCBOKTtcclxuICAgICAgICBpZihpbGx1bWluYW5jZSA+IDAuMCkge1xyXG4gICAgICAgICAgICB2ZWMzIHJlZmxlY3Rpb24gPSBjYWxjdWxhdGVSZWZsZWN0aW9uKGxpZ2h0X2Rpciwgdmlld19kaXIsIE4sIHVfZlNwZWN1bGFyKTtcclxuICAgICAgICAgICAgdmN0RnJhZyArPSB2ZWM0KHJlZmxlY3Rpb24sIDEuMCkgKiBpbGx1bWluYW5jZSAqIHVfZGlyZWN0aW9uYWxbaV0uY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmN0RnJhZyAqPSB1X3ZjdENvbG9yO1xyXG4gICAgdmN0RnJhZy5hID0gMS4wO1xyXG59ICAgICAgIFxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGljayBleHRlbmRzIFNoYWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtdO1xuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUmVuZGVycyBmb3IgUmF5Y2FzdGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiovXHJcbmluIHZlYzMgYV92Y3RQb3NpdGlvbjsgICAgICAgXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcblxyXG52b2lkIG1haW4oKSB7ICAgXHJcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbXR4TWVzaFRvVmlldyAqIHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxufVxuYDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuKiBSZW5kZXJzIGZvciBSYXljYXN0aW5nXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuKi9cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcblxyXG51bmlmb3JtIGludCB1X2lkO1xyXG51bmlmb3JtIHZlYzIgdV92Y3RTaXplO1xyXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcclxub3V0IGl2ZWM0IHZjdEZyYWc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgICBmbG9hdCBpZCA9IGZsb2F0KHVfaWQpOyBcclxuICAgIGZsb2F0IHBpeGVsID0gdHJ1bmMoZ2xfRnJhZ0Nvb3JkLngpICsgdV92Y3RTaXplLnggKiB0cnVuYyhnbF9GcmFnQ29vcmQueSk7XHJcblxyXG4gICAgaWYgKHBpeGVsICE9IGlkKVxyXG4gICAgICBkaXNjYXJkO1xyXG5cclxuICAgIHVpbnQgaWNvbG9yID0gdWludCh1X3ZjdENvbG9yLnIgKiAyNTUuMCkgPDwgMjQgfCB1aW50KHVfdmN0Q29sb3IuZyAqIDI1NS4wKSA8PCAxNiB8IHVpbnQodV92Y3RDb2xvci5iICogMjU1LjApIDw8IDggfCB1aW50KHVfdmN0Q29sb3IuYSAqIDI1NS4wKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgdmN0RnJhZyA9IGl2ZWM0KGZsb2F0Qml0c1RvSW50KGdsX0ZyYWdDb29yZC56KSwgaWNvbG9yLCAwLCAwKTtcclxufVxuYDsgfVxufVxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xuLyoqIENvZGUgZ2VuZXJhdGVkIGJ5IENvbXBpbGVTaGFkZXJzLm1qcyB1c2luZyB0aGUgaW5mb3JtYXRpb24gaW4gQ29tcGlsZVNoYWRlcnMuanNvbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGlja1RleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcbiAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW107XG5cbiAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgXG5yZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuKiBSZW5kZXJzIGZvciBSYXljYXN0aW5nXHJcbiogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuKi9cclxuaW4gdmVjMyBhX3ZjdFBvc2l0aW9uOyAgICAgICBcclxuaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1ZpZXc7XHJcbnVuaWZvcm0gbWF0MyB1X210eFBpdm90O1xyXG5cclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxudm9pZCBtYWluKCkgeyAgIFxyXG4gICAgZ2xfUG9zaXRpb24gPSB1X210eE1lc2hUb1ZpZXcgKiB2ZWM0KGFfdmN0UG9zaXRpb24sIDEuMCk7XHJcbiAgICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcbn1cbmA7IH1cblxuICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IFxucmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUmVuZGVycyBmb3IgUmF5Y2FzdGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxudW5pZm9ybSBpbnQgdV9pZDtcclxudW5pZm9ybSB2ZWMyIHVfdmN0U2l6ZTtcclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XHJcblxyXG5vdXQgaXZlYzQgdmN0RnJhZztcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAgIGZsb2F0IGlkID0gZmxvYXQodV9pZCk7IFxyXG4gICAgZmxvYXQgcGl4ZWwgPSB0cnVuYyhnbF9GcmFnQ29vcmQueCkgKyB1X3ZjdFNpemUueCAqIHRydW5jKGdsX0ZyYWdDb29yZC55KTtcclxuXHJcbiAgICBpZiAocGl4ZWwgIT0gaWQpXHJcbiAgICAgIGRpc2NhcmQ7XHJcbiAgICBcclxuICAgIHZlYzQgdmN0Q29sb3IgPSB1X3ZjdENvbG9yICogdGV4dHVyZSh1X3RleHR1cmUsIHZfdmN0VGV4dHVyZSk7XHJcbiAgICB1aW50IGljb2xvciA9IHVpbnQodmN0Q29sb3IuciAqIDI1NS4wKSA8PCAyNCB8IHVpbnQodmN0Q29sb3IuZyAqIDI1NS4wKSA8PCAxNiB8IHVpbnQodmN0Q29sb3IuYiAqIDI1NS4wKSA8PCA4IHwgdWludCh2Y3RDb2xvci5hICogMjU1LjApO1xyXG4gIFxyXG4gIHZjdEZyYWcgPSBpdmVjNChmbG9hdEJpdHNUb0ludChnbF9GcmFnQ29vcmQueiksIGljb2xvciwgZmxvYXRCaXRzVG9JbnQodl92Y3RUZXh0dXJlLngpLCBmbG9hdEJpdHNUb0ludCh2X3ZjdFRleHR1cmUueSkpO1xyXG59XG5gOyB9XG59XG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBCb25lTGlzdCB7XHJcbiAgICBbYm9uZU5hbWU6IHN0cmluZ106IE5vZGU7XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBCb25lTWF0cml4TGlzdCB7XHJcbiAgICBbYm9uZU5hbWU6IHN0cmluZ106IE1hdHJpeDR4NDtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY2xhc3MgU2tlbGV0b24gZXh0ZW5kcyBHcmFwaCB7XHJcblxyXG4gICAgcHVibGljIHJlYWRvbmx5IGJvbmVzOiBCb25lTGlzdCA9IHt9O1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG10eEJpbmRJbnZlcnNlczogQm9uZU1hdHJpeExpc3QgPSB7fTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNrZWxldG9uIHdpdGggYSBuYW1lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIlNrZWxldG9uXCIpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ0hJTERfUkVNT1ZFLCB0aGlzLmhuZENoaWxkUmVtb3ZlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgYSBub2RlIHRvIHRoaXMgc2tlbGV0b24gb3IgdGhlIGdpdmVuIHBhcmVudCBhbmQgcmVnaXN0ZXJzIGl0IGFzIGEgYm9uZVxyXG4gICAgICogQHBhcmFtIF9tdHhJbml0IGluaXRpYWwgbG9jYWwgbWF0cml4XHJcbiAgICAgKiBAcGFyYW0gX3BhcmVudE5hbWUgbmFtZSBvZiB0aGUgcGFyZW50IG5vZGUsIHRoYXQgbXVzdCBiZSByZWdpc3RlcmVkIGFzIGEgYm9uZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQm9uZShfYm9uZTogTm9kZSwgX210eEluaXQ/OiBNYXRyaXg0eDQsIF9wYXJlbnROYW1lPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGlmIChfcGFyZW50TmFtZSlcclxuICAgICAgICB0aGlzLmJvbmVzW19wYXJlbnROYW1lXS5hZGRDaGlsZChfYm9uZSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmFkZENoaWxkKF9ib25lKTtcclxuICAgICAgaWYgKCFfYm9uZS5jbXBUcmFuc2Zvcm0pXHJcbiAgICAgICAgX2JvbmUuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnRUcmFuc2Zvcm0oKSk7XHJcbiAgICAgIGlmIChfbXR4SW5pdClcclxuICAgICAgICBfYm9uZS5tdHhMb2NhbC5zZXQoX210eEluaXQpO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZU10eFdvcmxkKF9ib25lKTtcclxuICAgICAgdGhpcy5yZWdpc3RlckJvbmUoX2JvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbm9kZSBhcyBhIGJvbmUgd2l0aCBpdHMgYmluZCBpbnZlcnNlIG1hdHJpeFxyXG4gICAgICogQHBhcmFtIF9ib25lIHRoZSBub2RlIHRvIGJlIHJlZ2lzdGVyZWQsIHRoYXQgc2hvdWxkIGJlIGEgZGVzY2VuZGFudCBvZiB0aGlzIHNrZWxldG9uXHJcbiAgICAgKiBAcGFyYW0gX210eEJpbmRJbnZlcnNlIGEgcHJlY2FsY3VsYXRlZCBpbnZlcnNlIG1hdHJpeCBvZiB0aGUgYmluZCBwb3NlIGZyb20gdGhlIGJvbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZ2lzdGVyQm9uZShfYm9uZTogTm9kZSwgX210eEJpbmRJbnZlcnNlOiBNYXRyaXg0eDQgPSBfYm9uZS5tdHhXb3JsZEludmVyc2UpOiB2b2lkIHtcclxuICAgICAgdGhpcy5ib25lc1tfYm9uZS5uYW1lXSA9IF9ib25lO1xyXG4gICAgICB0aGlzLm10eEJpbmRJbnZlcnNlc1tfYm9uZS5uYW1lXSA9IF9tdHhCaW5kSW52ZXJzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBza2VsZXRvbiBhcyB0aGUgZGVmYXVsdCBwb3NlXHJcbiAgICAgKiBieSB1cGRhdGluZyB0aGUgaW52ZXJzZSBiaW5kIG1hdHJpY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXREZWZhdWx0UG9zZSgpOiB2b2lkIHtcclxuICAgICAgZm9yIChjb25zdCBib25lTmFtZSBpbiB0aGlzLmJvbmVzKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVNdHhXb3JsZCh0aGlzLmJvbmVzW2JvbmVOYW1lXSk7XHJcbiAgICAgICAgdGhpcy5tdHhCaW5kSW52ZXJzZXNbYm9uZU5hbWVdID0gdGhpcy5ib25lc1tib25lTmFtZV0ubXR4V29ybGRJbnZlcnNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluZGV4T2ZCb25lKF9ib25lTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGNvbnN0IGJvbmVOYW1lIGluIHRoaXMuYm9uZXMpIHtcclxuICAgICAgICBpZiAoX2JvbmVOYW1lID09IGJvbmVOYW1lKVxyXG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5tdHhCaW5kSW52ZXJzZXMgPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBib25lTmFtZSBpbiB0aGlzLm10eEJpbmRJbnZlcnNlcylcclxuICAgICAgICBzZXJpYWxpemF0aW9uLm10eEJpbmRJbnZlcnNlc1tib25lTmFtZV0gPSB0aGlzLm10eEJpbmRJbnZlcnNlc1tib25lTmFtZV0uc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpIGlmIChfc2VyaWFsaXphdGlvbi5tdHhCaW5kSW52ZXJzZXNbbm9kZS5uYW1lXSlcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyQm9uZShub2RlLCBhd2FpdCBuZXcgTWF0cml4NHg0KCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubXR4QmluZEludmVyc2VzW25vZGUubmFtZV0pIGFzIE1hdHJpeDR4NCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgc2V0cyB0aGUgd29ybGQgbWF0cml4IG9mIGEgYm9uZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlTXR4V29ybGQoX25vZGU6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgX25vZGUubXR4V29ybGQuc2V0KFxyXG4gICAgICAgIF9ub2RlLmNtcFRyYW5zZm9ybSA/XHJcbiAgICAgICAgTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKF9ub2RlLmdldFBhcmVudCgpLm10eFdvcmxkLCBfbm9kZS5tdHhMb2NhbCkgOlxyXG4gICAgICAgIF9ub2RlLmdldFBhcmVudCgpLm10eFdvcmxkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXJlZ2lzdGVycyBhbGwgYm9uZXMgb2YgYSByZW1vdmVkIG5vZGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBobmRDaGlsZFJlbW92ZSA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChfZXZlbnQuY3VycmVudFRhcmdldCAhPSB0aGlzKSByZXR1cm47XHJcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBfZXZlbnQudGFyZ2V0IGFzIE5vZGUpIGlmICh0aGlzLmJvbmVzW25vZGUubmFtZV0pIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5ib25lc1tub2RlLm5hbWVdO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm10eEJpbmRJbnZlcnNlc1tub2RlLm5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBTa2VsZXRvbkluc3RhbmNlIGV4dGVuZHMgR3JhcGhJbnN0YW5jZSB7XHJcblxyXG4gICAgI2JvbmVzOiBCb25lTGlzdDtcclxuICAgICNtdHhCb25lTG9jYWxzOiBCb25lTWF0cml4TGlzdDtcclxuICAgICNtdHhCb25lczogTWF0cml4NHg0W107XHJcbiAgICAjbXR4Qm9uZXNVcGRhdGVkOiBudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBza2VsZXRvblNvdXJjZTogU2tlbGV0b247XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBDUkVBVEUoX3NrZWxldG9uOiBTa2VsZXRvbik6IFByb21pc2U8U2tlbGV0b25JbnN0YW5jZT4ge1xyXG4gICAgICBjb25zdCBza2VsZXRvbjogU2tlbGV0b25JbnN0YW5jZSA9IG5ldyBTa2VsZXRvbkluc3RhbmNlKCk7XHJcbiAgICAgIGF3YWl0IHNrZWxldG9uLnNldChfc2tlbGV0b24pO1xyXG4gICAgICByZXR1cm4gc2tlbGV0b247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBib25lcygpOiBCb25lTGlzdCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNib25lcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG10eEJvbmVMb2NhbHMoKTogQm9uZU1hdHJpeExpc3Qge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4Qm9uZUxvY2FscztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGJvbmUgdHJhbnNmb3JtYXRpb25zIGZvciBhIHZlcnRleFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eEJvbmVzKCk6IE1hdHJpeDR4NFtdIHtcclxuICAgICAgaWYgKHRoaXMuI210eEJvbmVzVXBkYXRlZCAhPSB0aGlzLnRpbWVzdGFtcFVwZGF0ZSkge1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTXR4Qm9uZXMoKTtcclxuICAgICAgICB0aGlzLiNtdHhCb25lc1VwZGF0ZWQgPSB0aGlzLnRpbWVzdGFtcFVwZGF0ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4Qm9uZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhpcyBza2VsZXRvbiBpbnN0YW5jZSB0byBiZSBhIHJlY3JlYXRpb24gb2YgdGhlIHtAbGluayBTa2VsZXRvbn0gZ2l2ZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNldChfc2tlbGV0b246IFNrZWxldG9uKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLnNldChfc2tlbGV0b24pO1xyXG4gICAgICB0aGlzLnNrZWxldG9uU291cmNlID0gX3NrZWxldG9uO1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyQm9uZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHRoaXMuc2tlbGV0b25Tb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tfc2VyaWFsaXphdGlvbi5pZFNvdXJjZSB8fCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlXSBhcyBTa2VsZXRvbjtcclxuICAgICAgdGhpcy5yZWdpc3RlckJvbmVzKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoaXMgc2tlbGV0b24gaW5zdGFuY2UgdG8gaXRzIGRlZmF1bHQgcG9zZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzZXRQb3NlKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGNvbnN0IGJvbmVOYW1lIGluIHRoaXMuYm9uZXMpXHJcbiAgICAgICAgdGhpcy5ib25lc1tib25lTmFtZV0ubXR4TG9jYWwuc2V0KE1hdHJpeDR4NC5JTlZFUlNJT04odGhpcy5za2VsZXRvblNvdXJjZS5tdHhCaW5kSW52ZXJzZXNbYm9uZU5hbWVdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFwcGx5QW5pbWF0aW9uKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLmFwcGx5QW5pbWF0aW9uKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKF9tdXRhdG9yLm10eEJvbmVMb2NhbHMpXHJcbiAgICAgICAgZm9yIChjb25zdCBib25lTmFtZSBpbiBfbXV0YXRvci5tdHhCb25lTG9jYWxzKVxyXG4gICAgICAgICAgdGhpcy5tdHhCb25lTG9jYWxzW2JvbmVOYW1lXT8ubXV0YXRlKF9tdXRhdG9yLm10eEJvbmVMb2NhbHNbYm9uZU5hbWVdKTtcclxuICAgICAgaWYgKF9tdXRhdG9yLmJvbmVzKVxyXG4gICAgICAgIGZvciAoY29uc3QgYm9uZU5hbWUgaW4gX211dGF0b3IuYm9uZXMpXHJcbiAgICAgICAgICB0aGlzLmJvbmVzW2JvbmVOYW1lXT8uYXBwbHlBbmltYXRpb24oX211dGF0b3IuYm9uZXNbYm9uZU5hbWVdKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZU10eEJvbmVzKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNtdHhCb25lcyA9IFtdO1xyXG4gICAgICBmb3IgKGNvbnN0IGJvbmVOYW1lIGluIHRoaXMuYm9uZXMpIHtcclxuICAgICAgICAvLyBib25lIG1hdHJpeCBUID0gTl4tMSAqIEJfZGVsdGEgKiBCXzBeLTEgKiBTXHJcbiAgICAgICAgY29uc3QgbXR4Qm9uZTogTWF0cml4NHg0ID0gdGhpcy5nZXRQYXJlbnQoKT8ubXR4V29ybGRJbnZlcnNlLmNsb25lIHx8IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgIG10eEJvbmUubXVsdGlwbHkodGhpcy5ib25lc1tib25lTmFtZV0ubXR4V29ybGQpO1xyXG4gICAgICAgIG10eEJvbmUubXVsdGlwbHkodGhpcy5za2VsZXRvblNvdXJjZS5tdHhCaW5kSW52ZXJzZXNbYm9uZU5hbWVdKTtcclxuICAgICAgICBpZiAodGhpcy5jbXBUcmFuc2Zvcm0pIG10eEJvbmUubXVsdGlwbHkoTWF0cml4NHg0LklOVkVSU0lPTih0aGlzLm10eExvY2FsKSk7XHJcblxyXG4gICAgICAgIHRoaXMuI210eEJvbmVzLnB1c2gobXR4Qm9uZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlZ2lzdGVyQm9uZXMoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI2JvbmVzID0ge307XHJcbiAgICAgIHRoaXMuI210eEJvbmVMb2NhbHMgPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpIGlmICh0aGlzLnNrZWxldG9uU291cmNlLm10eEJpbmRJbnZlcnNlc1tub2RlLm5hbWVdKSB7XHJcbiAgICAgICAgdGhpcy5ib25lc1tub2RlLm5hbWVdID0gbm9kZTtcclxuICAgICAgICB0aGlzLm10eEJvbmVMb2NhbHNbbm9kZS5uYW1lXSA9IG5vZGUubXR4TG9jYWw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBlbnVtIE1JUE1BUCB7XHJcbiAgICBDUklTUCwgTUVESVVNLCBCTFVSUllcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQmFzZWNsYXNzIGZvciBkaWZmZXJlbnQga2luZHMgb2YgdGV4dHVyZXMuIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yVGV4dHVyZS5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUZXh0dXJlIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIG1pcG1hcDogTUlQTUFQID0gTUlQTUFQLkNSSVNQO1xyXG4gICAgcHJvdGVjdGVkIHJlbmRlckRhdGE6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIlRleHR1cmVcIikge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IHRleEltYWdlU291cmNlKCk6IFRleEltYWdlU291cmNlO1xyXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcblxyXG4gICAgcHVibGljIHJlZnJlc2goKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucmVuZGVyRGF0YSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIG1pcG1hcDogTUlQTUFQW3RoaXMubWlwbWFwXVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHRoaXMubWlwbWFwID0gPG51bWJlcj48dW5rbm93bj5NSVBNQVBbX3NlcmlhbGl6YXRpb24ubWlwbWFwXTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLm1pcG1hcClcclxuICAgICAgICB0eXBlcy5taXBtYXAgPSBNSVBNQVA7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuaWRSZXNvdXJjZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGFuIGV4aXN0aW5nIGltYWdlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVJbWFnZSBleHRlbmRzIFRleHR1cmUge1xyXG4gICAgcHVibGljIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50ID0gbnVsbDtcclxuICAgIHB1YmxpYyB1cmw6IFJlcXVlc3RJbmZvO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF91cmw/OiBSZXF1ZXN0SW5mbykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICBpZiAoX3VybCkge1xyXG4gICAgICAgIHRoaXMubG9hZChfdXJsKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBfdXJsLnRvU3RyaW5nKCkuc3BsaXQoXCIvXCIpLnBvcCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogVGV4SW1hZ2VTb3VyY2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbWFnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBpbWFnZSBmcm9tIHRoZSBnaXZlbiB1cmxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG4gICAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgIC8vIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaCh0aGlzLnVybCk7XHJcbiAgICAgIC8vIGNvbnN0IGJsb2I6IEJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XHJcbiAgICAgIC8vIGxldCBvYmplY3RVUkw6IHN0cmluZyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgIC8vIHRoaXMuaW1hZ2Uuc3JjID0gb2JqZWN0VVJMO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcclxuICAgICAgICAgIHRoaXMucmVuZGVyRGF0YSA9IG51bGw7IC8vIHJlZnJlc2ggcmVuZGVyIGRhdGEgb24gbmV4dCBkcmF3IGNhbGxcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiByZWplY3QoKSk7XHJcbiAgICAgICAgdGhpcy5pbWFnZS5zcmMgPSBuZXcgVVJMKHRoaXMudXJsLnRvU3RyaW5nKCksIFByb2plY3QuYmFzZVVSTCkudG9TdHJpbmcoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHVybDogdGhpcy51cmwsXHJcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLCAvLyBzZXJpYWxpemUgZm9yIGVkaXRvciB2aWV3c1xyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkKF9zZXJpYWxpemF0aW9uLnVybCk7XHJcbiAgICAgIC8vIHRoaXMudHlwZSBpcyBhbiBhY2Nlc3NvciBvZiBNdXRhYmxlIGRvZXNuJ3QgbmVlZCB0byBiZSBkZXNlcmlhbGl6ZWRcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAoX211dGF0b3IudXJsICE9IHRoaXMudXJsLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkKF9tdXRhdG9yLnVybCk7XHJcbiAgICAgIC8vIGV4Y2VwdCB1cmwgZnJvbSBtdXRhdG9yIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmdcclxuICAgICAgZGVsZXRlIChfbXV0YXRvci51cmwpO1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIG5lY2Vzc2l0eSB0byByZWNvbnN0cnVjdCwgaWYgbXV0YXRvciBpcyBrZXB0IGJ5IGNhbGxlclxyXG4gICAgICAvLyBfbXV0YXRvci51cmwgPSB0aGlzLnVybDsgXHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgY2FudmFzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVCYXNlNjQgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICAgIHB1YmxpYyBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9iYXNlNjQ6IHN0cmluZywgX21pcG1hcDogTUlQTUFQID0gTUlQTUFQLkNSSVNQKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5pbWFnZS5zcmMgPSBfYmFzZTY0O1xyXG4gICAgICB0aGlzLm1pcG1hcCA9IF9taXBtYXA7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IFRleEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgY2FudmFzXHJcbiAgICovXHJcbiAgLy8gVE9ETzogcmVtb3ZlIHR5cGUgZml4ZXMgd2hlbiBleHBlcmltZW50YWwgdGVjaG5vbG9neSBpcyBzdGFuZGFyZFxyXG4gIHR5cGUgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gR2VuZXJhbDtcclxuICB0eXBlIE9mZnNjcmVlbkNhbnZhcyA9IEdlbmVyYWw7XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlQ2FudmFzIGV4dGVuZHMgVGV4dHVyZSB7XHJcbiAgICBwdWJsaWMgY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9jcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmNyYzIgPSBfY3JjMjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogVGV4SW1hZ2VTb3VyY2Uge1xyXG4gICAgICByZXR1cm4gPE9mZnNjcmVlbkNhbnZhcz50aGlzLmNyYzIuY2FudmFzO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIEZVREdFLVNrZXRjaFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlU2tldGNoIGV4dGVuZHMgVGV4dHVyZUNhbnZhcyB7XHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IFRleEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGFuIEhUTUwtcGFnZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlSFRNTCBleHRlbmRzIFRleHR1cmVDYW52YXMge1xyXG4gICAgcHVibGljIGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBUZXhJbWFnZVNvdXJjZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlRGVmYXVsdCBleHRlbmRzIFRleHR1cmVCYXNlNjQge1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXh0dXJlOiBUZXh0dXJlQmFzZTY0ID0gbmV3IFRleHR1cmVEZWZhdWx0KFwiVGV4dHVyZURlZmF1bHRcIiwgVGV4dHVyZURlZmF1bHQuZ2V0KCksIE1JUE1BUC5NRURJVU0pO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0KCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBWkFBQUFHUUNBWUFBQUNBdnpiTUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQURXTFNVUkJWSGhlN2QwSG5GVGx2Zi94SDl1WFpZR2w5eXJTUkpwRVVleFlzSkliYThSZTQ5OFdOY1pFYis0MWVwT0lzV3MwTml5eG0yZzBkdXdhZXdPN29xSkNBR25TdDdILzgzMDRCNGRsZHBrNVozYjN6TzduemV1ODVwd3pNOHZNczdQUGIzNVBPNjFxUEJaanJWcTE4dmZpS2ViRlIvbEZSUGxGUS9sRkUvZnl5L0Z2QVFCSUN3RUVBQkFLQVFRQUVBcDlJQkhSaGhvTjVSY041UmROU3lnLy9ZekN3a0pyM2JxMU8xNjllclhiTW9FQUVoRi93TkZRZnRGUWZ0RTA5L0xMemMyMUxsMjYyRTkrOGhNYlAzNjhWVmRYMit1dnYyN1RwMDkzUVNUcSt5ZUFSTVFmY0RTVVh6U1VYelROdGZ4eWNuS3NwS1RFQmcwYVpFY2VlYVFkZXVpaHRtTEZDdnZzczg5czNyeDU5dmpqajl2RER6OGNPUk9KSEVDcXFxcHM5dXpadG16Wk1sdTVjcVZMbGRxMWEyZDkrL1oxKzFIeEFZeUc4b3VHOG91Rzhvc21UUG5sNStkYjkrN2RiZmZkZDdkVFR6M1YxY1h2dnZ1dXZmenl5eTREa1ZXclZ0bU5OOTVvUzVZc2NjZGhoUTRnNWVYbDl1eXp6OXFNR1ROc3pabzEvdGtmS1FJcSt1Mjk5OTVXV2xycW4wMGZIOEJvS0w5b0tMOW9LTDlvMGlrL1BiWk5temEyeFJaYjJISEhIV2VUSjArMmhRc1gycE5QUG1tTEZ5LzJIN1hPZi83ekg3djExbHRkUFI1RnFBQ3lZTUVDdStlZWUxS0tYbXZYcnJYOTl0dlBSbzhlN1lKS3V2Z0FSa1A1UlJPVW56NjcraUtVbDVkbmxaV1Z0bno1OGxpOGRqNS8wVFNuOGxPVDFiNzc3bXNYWEhDQmRlN2MyVjU3N1RWNzg4MDNrNzdIYjcvOTF1NjQ0dzZycUtqd3o0U1RkZ0JSdHFIVUo0aG9DaENmZlBLSmZmWFZWNjQ5clgzNzlqWmd3QUMzQlpRdVRabzB5YmJiYmp1WFhxV0REMkEwbEY4MFFmbDE3TmpSampubUdPdlVxWk45ODgwMzlzQUREN2d2VWszOSt2bjhSZE9jeXE5cjE2NDJkZXBVMjNycnJlM1JSeDkxWDNKRWRiU2FzSXFMaTIzWXNHSHVYS1lDU05vcGdYcnZnK0NoL28vNzdydlB2Vmk5K0ovLy9PZDI5TkZIMjlDaFE5MExER2o0bU5JbEJabTQvOExRc3N5Y09kTTF4Yjc2NnF0Sm0ySkYyVWZQbmozdDE3Lyt0VTJZTU1GMjNYVlhPL2JZWTExUVFmTTFmLzU4dSttbW0xemZnZnA0NDA3MXNWNnpQc3RCOEZBOXJDLzhUejMxbE9zWHliUzBNcEFmZnZqQnJyNzY2dlVkTVVFZmlGS20vZmZmMzhyS3l0YW4rTXBHVlBqQlkvWEhxZXpqckxQT2NwM3NxZUliVERTVVgvMys4SWMvdU0rcjZFdlFUMy82VXpmc01TZzMzU3FBcUYzNW1XZWVzV3V2dmRhZGw0Y2Vlc2plZSs4OS82aHA4UG1McHI3eTA2aWxLNis4MGxYTTByOS9meHM1Y3FUN2dseFFVT0RPTmJSMHlpLzRvblBFRVVlNFk0MjBldWVkZDl4Z3BxT09Pc3AyM0hGSE53cExtaVFEK2VDRER6Ym94WC83N2JkZHhuSGdnUWRhbno1OXJHM2J0aTdiVUlEbzFxMmI2MEFQRkJVVjJYUFBQUmVMdEI5SVJuOVFMNzMwVXNvZGk3VTdKdEc4cUVONmwxMTI4WS9NdnY3NmEvdm5QLzlwZi83em4rM0JCeCswTDcvOE1sWjFtWnFxNXM2ZDZ6N0grcUtqWml2UisxRGdDeVlTWmxKYUFlU0xMNzd3OTh3Ky8veHo5OElVN2ZUTkxWbWtIREZpeEFZZDUzcTgzbFRVbm4rZ0lTakQxbEQwVkN1RjRNc1VtaS8xSjZoeldwK0pZRlBHcXFaUFZkU1hYbnFweTB3MTJpa085SmxVZHJGMDZkTDFuMk5OSm15b2pDbmxBS0lYODkxMzMvbEg1aUtkMm9QVnJwWVlKQktwT1V1akFRTHFnSHpycmJmcWJHc0dnRGhSM1RadTNMaU42cmlnY3RZWGpsZGVlY1Y5NDcvKyt1dnRqVGZlY0swelRTbDRiWTBoNVFDaWIyZEJXNkJvQ0srRzVxcG52ejdLVGdKcTJ2cjAwMC9KUUFCa0RUWC8xRmNwQi9lcEExdjlEbXJpdXZ2dXUrM2pqejl1OWxscXlnR2s5cHdQUlZrTjFkM1VzRndONncyb2owUkRJSU5PU3dDSU85Vmg2VXlHVmtCUkUvKzk5OTVyRjE5OGNTejdTeklsNVFCU095MVQ3NzBLVnUxcjlVa01NTnBYbEtidEdFQTI2ZDI3ZDUxTjlja29XS2hmV0YrV1AvendROWRmY3RWVlY3bEJHbXJOYVM1U0hzYXI0WW9hZ1JDNC9QTEwzV0pjMjI2N3JldnJxSXRXZm56aWlTZjhJN01ycnJqQ0RTM1RrTGhVMU82Y1YyZVFSbnpGeFdPUFBlYnZ4ZE5lZSszbDc4VlRVNVdmdnN6MDZ0WExUYndLTW1MTmFkS293ajMzM0hQOU9tNHFQMVVjbTIrK3VkMTIyMjF1R0h0QTQrczE4a1dkckUyRnoxODBxWmFmUnB4cUNHelVMQ0tvejNyMDZPRzZBRFE4dkw0MUE5TVp4bHNYRFV2WGNIWDFRUWZEempNMWpEZmxBS0lwOFltRnJYYStGMTU0d1VhTkdsVnZaRmF3ZU9TUlIveWpkWUZISFUzNmcweEY3UUpVbjhvdmZ2RUwvd2dJcDBPSERpNVk2RnRoRUVEVTVEQjgrSEFiUEhqd0JwbXpQb1A2STV3eVpZb2JkUk80NVpaYjNFQ1NWRC9MUUcyYTN2Q3JYLzJxempxMDJRU1Eyb0hnc3NzdWN6TWVOYW1tdmpkWk8vQmNjc2tsYm8wV1JkNVUxUDdaYWpaTG5GL1MxUFJ0TmM0U3M3ODRhcXJ5VTMvY2JydnQ1cjdRQkFGRTY3dHAzUC9Zc1dQWEQzdFUrZW1QV3hPMHpqMzNYSmRCQnpSUmRyUE5OblAzTlJVK2Y5R2tXbjZMRmkxeVEyTXpTYXZrYW9TWHZyVFVwZGtFRU0wNFYyZFFRRE0wbFlFb0VOVDNKaFZrTkkxZTFQZWhBS0kzb1c5NXFjaEVBVGFrRkl1dnlWQis5VXVjaWY3M3YvL2RyWlJ3MEVFSHJSOWRxUEpUUDUrYUcxUVpYblBOTmU2OHFBbHJ6cHc1L2xIVDRQTVhUYXJscCtaNjFWdGh5MXVmSWRWL1dxMWp6Smd4dHVXV1c3b3ZNWnVTaWZKcnlBQ1NjcTlRN1lrb210V29QN3hORldqaWtOMWdPWlBFNWdHZ0tTWDIzNmt2UTBQVkV6L1QrZ1BXOEhObEplbDBvcUo1MFVXWTFOK1ZqcUR5VngrSGdvYVdXRC90dE5OY3MyY3F3U01icFB3WFVYc1ltMmFWYThHdVRSVnE0aUprV3ZwQlAyZFRJN2VBeHBMWWdha0FvaEV5aWFNRTlZMVJGK1pSODFWY1podWpjZWxMaFFKSU90bUFIanR3NEVDM3pKUDZPRFNZb0NtYk9odEt5Z0VrY1Q2SDZQajc3Ny9mWUhKaE1vbnJCV2t1aVVhKzFEZHFDMmhNaVN2cXFqOURRU0x4TTYzbXJELzk2VTh1KzBoc3drWExvVGtkbTJwcENZS0xWdVpRc0ZEUU9PeXd3OXp5NmMzNUMzUEtBVVJ0d29tTGNhbWd0TFJKZlFGRVRWeGE4aVNnOW1JTndhVUpDM0doanN5QVB0TWFxcGs0NSttUGYveWphNFpWQjN2VTYwY2pPMmtxUXJMc0kyalNWTDJvenZDVFRqckpUampoQkxlL3FSVTZHb3RlZHpxWlU3cFNEaUFxck1TNUc1cUZycW42OWExcnBkbVhRUWVsYURWTGRSNXA2Qm9RQjFxbUlwRkd4R2craUJiTDB3U3dwNTkrZW4zd1VJZGpwa2ZpSU43MEpYbjI3Tm5yTTVDZ1FsWXJpaGFMMVdLeVo1OTl0cnRnWHVLeVRVMUJyMHRkQzVyMHFDL3F3YWFtczJSemxkU3ZyZnYwZUhXd2g1RnlBSkVoUTRiNGUrdUdRZW9DVVhVdEhLWUMxeUpqQWYwUzFMNDhmdno0MkVSblFKL2piYmJaeGo5YTkwVkovWGIvK01jLzNGVUhQL3JvSS9kWjFxSjV0OTkrZTFaY1dBaVpvZjVkamI1S3BDL1J1dGI0T2VlYzQyNTEzSkRmOE5PaFRFaVh0TDN6emp2ZG5LWmd1K0dHRzJ5SEhYYlk0SFVHQ1lFV2dOVGp6ei8vZkxmd2JicnZKYTBBb2prZmlmMFhta1NvSWJxMVUzdjl3V21KWXcwVkMyanVoeDZ2U1ZjMFlTRk9KazZjNkVaYUpjdW1WWWtvRzlId1hWM0xSa01pQXl6SjA3eHAzVDcxODJyU3FUNGp2L3psTCszd3d3OTNyU2h4ck1QVXNxTTZWdjNUR3E2clMyZG8vcDRtYm1zVkVWMTZQS0Jnb1N0cnFwVkkxM2xTUDgzSko1K2M5cW9LYVYyUlVQU0NGSldEU0tVbUtuVSticlhWVmk0Q3FxTmNMejV4NlhjZGF3eTlKaDhxNVV2blJjWWx1dGNsemVKcmRKUmZhblQxT2EyZ3FtOXNDZ3o2b3FTTVdYOTB3ZVZCZFU3emw5Uk1vTTkzVTg4QkVUNS8wZFJYZnJwUDlaa0NTRk5KcC94VXJ5b3Iwa1RyNE1xRDZkSThQV1hicVVvN2dJald2bGRrVHVYTmFRU0RMdjI1eHg1N3VGbS9hbTlMcDFDb0FLT2gvRktuSUtMaG1sbzlZZGFzV2E2NVNrdjJKTDVHcGY0cVU1MUxkMTVBUStEekYwMXpLejk5dVRuNDRJUGRhRmYxMmFYei9qUmlWczFkNlFnVlFOVHZvV3dpU08rU1VXZWovaEMxQ0prV1hOVGpOV3M5M1NGdGZBQ2pvZnpTcHlaWlpkWUtFSm9IRW1kOC9xSnBidVdueHlzVFVYTlc3VGxObTZLeVNMYzhRZ1VRMGJleko1OTgwaTBvcHpSUHpWZDY4Zm9XcDBpbUZGL1hSVC9ra0VQY29uVWF0UlZtL2djZndHZ292MmdvdjJnb3YyamlYbjZoQTRqb201cUNoWWJ6NmtxRFN2ODFMMFNUc3pSOFRCMDY2blRVU0pkZ3pIUzYrQUJHUS9sRlEvbEZRL2xGMDZ3RFNFRHB2dHJiRkR6MDQ5Uk1wVkVLV2lZaWFnSHdBWXlHOG91RzhvdUc4b3NtN3VXWGtRRFNrUGdBUmtQNVJVUDVSVVA1UlJQMzhndlhyZ1FBYVBFSUlBQ0FVQWdnQUlCUTFNQVc3MGJBZGE4UklZMGRPemJ1djk5WWUrdnR0LzA5aE5FcTVuME1jUmYzMGlNREFRQ0VRZ0FCQUlSQ0FBRUFoRUlBQVFDRVFnQUJBSVJDQUFFQWhKS1JBS0tyRE9wS1hWdHZ2YlYvQmdEUTNHVWtnT2h5b0FNSERneDlZWFlBUVBhaENRc0FFRXBHQWtqY1Y3UUVBR1FlR1FnQUlCUUNDQUFnRkFJSUFDQ1VqQWFRdUY4OUN3Q1FPV1FnQUlCUUNDQUFnRkF5RWtBWXhnc0FMUThaQ0FBZ0ZBSUlBQ0NVakFZUVJtRUJRTXRCQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkN5V2dBWVJndkFMUWNaQ0FBZ0ZBSUlBQ0FVQWdnQUlCUU1oSkFHTVlMQUMwUEdRZ0FJQlFDQ0FBZ2xJd0dFSWJ4QWtETFFRWUNBQWlGQUFJQUNJVUFBZ0FJSlNNQmhHRzhBTkR5a0lFQUFFTEpVZllRZFpzMmJacjdZVWNkZFZUUys2TnNBTkJTYVdScm5MZU1aQ0Q2UVFDQWxvVW1MQUJBS0FRUUFFQW9HUTBnOUZrQVFNdEJCZ0lBQ0lVQUFnQUloUUFDQUFnbEl3R0VZYndBMFBLUWdRQUFRaUdBQUFCQ3lXZ0FZUmd2QUxRY1pDQUFnRkFJSUFDQVVBZ2dBSUJRTWhKQUdNWUxBQzBQR1FnQUlCUUNDQUFnbEl3R0VJYnhBa0RMUVFZQ0FBaUZBQUlBQ0lVQUFnQUlKU01CaEdHOEFORHlrSUVBQUVJaGdBQUFRc2xvQUdFWUx3QzBIR1FnQUlCUUNDQUFnRkF5RWtBWWhRVUFMUThaQ0FBZ0ZBSUlBQ0FVQWdnQUlKU01CaENHOFFKQXkwRUdBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkNJWUFBQUVMSmFBQmhHQzhBdEJ6cS9ZNWM2dzhiTnN3T091Z2crL0RERCszKysrLzN6MmFHRjVSMjluY1J3b2tubnZpY3Y0c1FidmpyRGY0ZXdxaHB4WmZLU0dKZWZEUmhBUUJDeVVnQUNacXVHTTRMQUMwSEdRZ0FJQlFDQ0FBZ0ZBSUlBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQ1VqQVFRaHZFQ1FNdERCZ0lBQ0lVQUFnQUloUUFDQUFpRkFBSUFDSVVBQWdBSWhRQUNBQWdsSXdHRVlid0EwUEtRZ1FBQVFpR0FBQUJDSVlBQUFFSWhnQUFBUWlHQUFBQkNJWUFBQUVMSlNBQmhHQzhBdER4a0lBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQVVBZ2dBSUJRTWhKQUdJVUZBQzBQR1FnQUlCUUNDQUFnRkFJSUFDQVVBZ2dBSUJRQ0NBQWdGQUlJQUNDVWpBUVFodkVDUU10REJnSUFDSVVBQWdBSWhRQUNBQWdsUi8wWFViZkhIMy9jL2JBOTk5d3o2ZjFSTmdCb3FkU3ZIT2VOREFRQUVBb0JCQUFRQ2dFRUFCQUtBUVFBRUFvQkJBQVFDZ0VFQUJCS1JnS0lobk1KdzI0Qm9PVWdBd0VBaEVJQUFRQ0VRZ0FCQUlSQ0FBRUFoRUlBQVFDRWtwRUF3aWdzQUdoNXlFQUFBS0VRUUFBQW9SQkFBQUNoRUVBQUFLRVFRQUFBb1JCQUFBQ2haQ1NBTUl3WEFGb2VNaEFBUUNnRUVBQkFLQVFRQUVBb0JCQUFRQ2dFRUFCQUtBUVFBRUFvR1FrZ0RPTUZnSmFIREFRQUVFcEdBa2h1YnE2N3JhNnVkcmNBZ09ZdjVRQ3lZc1VLdStPT08rekdHMiswZSs2NXg1WXZYKzdmVTc4MzNuakRwazJiWmpmZmZMTjkvUEhIL2xrQVFMWkxPWUFveTVnOWU3Yk5uVHZYUHYzMFU3dnd3Z3Z0ODg4L3Q3VnIxL3FQMkpneWttZWZmZGErK2VZYisrNjc3K3lxcTY3eTd3RUFaTHVVQTBoeGNiSDE3OS9mUHpKYnZYcTEzWC8vL1M0ekNRU2Q2WUV2dnZqQ3lzdkwzYjZDeWNNUFArejJBUURaTDYwK2tGR2pSdmw3WnAwNmRiTG5ubnV1M3Fhc21UTm4rbnRtWDM3NXBTMWJ0c3cvQWdCa3U3UUN5T0RCZzlkM21JdjJQL3ZzTTZ1cXF2TFAvRWpubElFRVB2cm9JeHMzYnB4L0JBRElkbWtGa0x5OFBCc3laSWgvdEM2Z1BQUE1NN1pxMVNyL3pJL1VQeEkwWDFWVVZMaGdNbW5TSkhjTUFNaCthUVVRR1RObWpMOW4xcUZEQjN2dHRkZldCNURFUHBBUFAvelEzelBYNlY1UVVHQVRKMDcwendBQXNsM2FBYVJmdjM1V1dGam9INW5ibnpWcmx1c2tWNUNReXNwSzE3UVZVRERaZnZ2dHJVZVBIdjRaQUVDMlN6dUE1T1RrMkpaYmJ1a2ZtV3ZTZXZIRkYxMmZoNXE0Uk1GRFFVUTBTa3ZEZVBmZWUyOHJMUzExNXdBQTJTL3RBQ0pqeDQ3MTk4emF0bTFyTTJiTWNQTkIyclJwNDg0bE5sK3A4N3lzck15MjIyNDdOeFFZQU5BOHFOTWlyUlVRMjdkdmI2ZWNjb29MSEVIZng1dHZ2bW05ZXZXeW5YYmF5WGJmZlhlNzdycnIxby9NdXVHR0cyeisvUG1obHptcHFhbTV3TjlGQ0Y3NS80Ky9peEJPUFBFRWZ3OWgxTlJzT0RjTTZZcjNBclZwWnlCcWtwbytmYm9OSHo3Y1AyTTJkT2hRTjB1OVQ1OCticjVIRUR5Ky8vNTdOM09kTmJJQW9QbEpPNEFvT0doWmtzUWxUTlIwdFdUSkVtdlhycDBiY1JYUVJNTGFzOU1CQU0xRHFENFF6U2gvNnFtbjNHejBRUGZ1M2UyRER6NndyNy8rMmgzcjJpRHFHd0VBTkUraEFvaWFzVFR5YXRDZ1FmNFpzODAzMzl5dHZCczBYNmxKYStuU3BWeGtDZ0NhcVZBQlJNMVhDeFlzc0lVTEY2NXZvbXJkdXJYbDUrZTdmVkUya3Jqc0NRQ2dlUWtWUUNSb3h1clpzNmQvWnQyS3ZhSXNSRU41eVQ0QW9Qa0tIVUEwaEZmTldJbXowZ09hU0tqbDN1dTdWZ2dBSUx1RkRpREtMdFRQY2RGRkY3bkZFb05nb2Y0UjlZVm94bm95ZFowSEFHU1h0Q2NTMXFaK2poRWpScmlBb2lHOGE5YXM4ZTlKVG85UFoxNkk5M09aU0JnQkV3bWpZU0poTkV3a2pLcVpUU1NzVGNGQW82MDBBMzJmZmZieHo5YU5TWVVBMER5a0ZFRFV6NkhPY2kxWDByVnIxL1dMSmdZVUZFcEtTdHhFd29DYXFyVGN1NTZqVlhnMVNnc0EwSHlrRkVCMFlhZzVjK2E0R2VoYTF5cVk2MUVmOVlrc1hyellQVWZMbVNTNzZCUUFJSHZSb3cwQUNDVWpBWVQ1SGdEUThwQ0JBQUJDSVlBQUFFSWhnQUFBUXNsb0FPSGFId0RRY3BDQkFBQkNJWUFBQUVMSlNBQmhHQzhBdER4a0lBQ0FVQWdnQUlCUUNDQUFnRkF5R2tBWXhnc0FMUWNaQ0FBZ0ZBSUlBQ0NVakFRUWh2RUNRTXREQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xvd0dFWWJ3QTBIS1FnUUFBUWlHQUFBQkN5VWdBWVJndkFMUThaQ0FBZ0ZBSUlBQ0FVRExhaE1Vb0xBQm9PY2hBQUFDaDVDaDdpTHE5ODg0NzdvZU5IajA2NmYxUk5nQm9xZFNxRStlTkRBUUFFRXBHQW9naWtaQXhBRURMUVFZQ0FBaUZBQUlBQ0lVQUFnQUloUUFDQUFpRkFBSUFDSVVBQWdBSUpTTUJoR0c4QU5EeWtJRUFBRUloZ0FBQVFpR0FBQUJDSVlBQUFFSWhnQUFBUWlHQUFBQkN5VWdBWVJndkFMUThaQ0FBZ0ZBSUlBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQVVESVNRQmlGQlFBdER4a0lBQ0FVQWdnQUlCUUNDQUFnbEl6MmdRQUFXZzR5RUFCQUtBUVFBRUFvR1EwZ0RPTUZnSmFEREFRQUVBb0JCQUFRQ2dFRUFCQktSZ0lJdzNnQm9PVWhBd0VBaEVJQUFRQ0VrdEVBd2pCZUFHZzV5RUFBQUtFUVFBQUFvV1FrZ0RBS0N3QmFIdFg4a1RzdU9uYnNhS2VlZXFvdFdyVElycjc2YXY5c1p0VFUxTHpnN3lLRXQ5OStlMGQvRnlHTUhUdlczMXVuOXBlbDJ2MStUWDEvYmJVZlgxdERQeC9ORzAxWUFJQlFDQ0FBV2h4bFRtNWJ1M2I5UHRLWGtRQkM0UU9JTTlWUlZaV1Z0bURlZDNiam44Nnh2WVlVZUZ1KzdUWFV2L1cyc3cvYnlUNTY5MVdycUNpM3RWNWd3YWFSZ1FEMVVCOUE0aFo4V3cyMnByNGZkVk1RV0xKb2diM3k5RU4yMGo0amJkOHRpdTNJSGZ2WlA2WmQ1dDI3Y2RsOStOYkxkdFloMjl2K0kwcnNvSzI3MkQ5dnY4WVd6WjlyMWRWVi9pTlFHd0VFUUxPaG9QSDE1eC9hdlgrOTJBV0JuMi9id3k0NjVRRDc1b3VQL0Vla1p1V3lwWGI5LzUxaFUzYm9ZejhiMjlGdW52b2JtL1h4ZTE0d3FmWWZBY2xvRTVhK0lRRkFZMUkveGdkZTluRG5OUmZaejhhVTJTKzhiT1BXeTg1elFTQVR5bGV2dEFkdXZzUk9tYnlWKy9sL3UvcjM5c0diTC9uM3RteGtJQUN5UnRCMHQzWnR0YzE4ODBXYmR1bDV0dCtJRXZ2VllUdDVGZnYvMmhxdnNtOUk1V3RXZVlIcTkvYXJLVHZidnQ3L2UrYzFGOXBuTTk5eW1VOUxiRkpVeWhENVhaZVZsZG5wcDU5dWl4Y3Z0cXV1dXNvL214bmVMNFY1SUJFd0R5U2F1TThEMlpUYXo2OXRVeit2b1orZkt2MmM2cW9xbS8zRlJ6Yjl3ZHZ0eVFlbTJlcVZ5L3g3bTE1WnAyNjI2K1REYmU5RFQ3RE8zWHRiVGs1dTJyK3JiRVFHQWlDV2dxQXg1K3ZQN2RvTFRyVmpkeDlpcDB3ZWF3L2RkbVdzZ29jc1dUalBIcmpwRWp0NjEwRjIrcysyc1R1dnZjZ1dmei9QMWxaWFp5eUl4aEVCQkVDc3FLUDZoeVVMN2I0YnB0cnBCNHkzNC9ZWWFvL2VmYjB0bUR2YmYwUzhxYlA5enFzdnNDTjI2bWZuSHJXN1BmK3ZlMnpsOGgrYVpTQWhnQUNJaFZVcmx0a0xqOTFuWngyNmcwM1p2cmZyQ0ovMThidit2UTBuSjZlVjVlWGx1dmI4VEZMMk5QT05GMnpxMlllN3pPU0NYMHkyVDk5L3c4clhyUFlma2YxVVpwSERJbjBnOFVVZlNEUmJiYldWdjdkTzdXK1I2ZlpaTlBUOXRkVitmRzFOL1h6TnNWZ3c1eHU3NjlxTDdNMFhIbk9aUjBNb0xDaXdmbjE3MkU0VHhsbEpTWkU3cDVkZVhGeHNuVHVWV1Y1dXJwVlhWTmlzcjc2MUJ4NmFidk1YTEhLUHlUU1ZsL3BJZHZ1dm8yM1BnNDZ4amwxNmJMSU00MHl2dlA3ZmNBcmF0Mjl2WjV4eGhpMVpzc1N1dlBKSy8yeG1lQjlBQWtnRUJKQm9DQ0FOOC96S2luSTM5UGE2QzArM09iTS9kMzBGRGFWM3o2NzIyN09QZDRGaVU2OVgxSVEyNDhQUDdmSnI3N0NWS3hzdVc4Z3ZLTFMrZzRiYktmOTdyVzAyYkxUbDV1WDU5MlFQbXJBQU5DcjFaUnl6MjJENzdkRjcyTGRmZnRLZ3dTTS9QOC9PK2VVeDFxVnpoNVNDaCtSNjJjaW9FWVB0N0ZPUDlNODBEQVhSTHo1OHg4NDRjRnM3WXVmKzl2RjdyL24zWkE4Q0NJQkdOZlBaaDJ6TjkzUDhvNGJWeXZ0WFZWVzF5VXlxTmdXYkZTdFgrVWNOcmNiV0xKcG5qMTc1Ry84NGV4QkFnSHFvNGtuY1ZMRWtibkc3di9aVysvRzF0MlRQU2R5U1BTZHhTL2FjeEMyWlpRdm5XWTgyaGRhM3BNQ0tjMVBMQ3NLcXFLeTBzMzU3cWQxMjF5UDIzc3hQYmVrUHl6ZTVVS0plOThMRlMrM08reDcxenpRY3ZmOStKZm5XeXlzUFZjWjFsVmxjNmJjWCtSWFRCeEpmOUlGRXd3V2xvajAvbVFjdU9jdGV1dit2L3BIWm1xcHFXN2lteWxaVnAvK3p3aWd1S3JSUld3NjJ6cDA2V052U0Vpc295SGZuU2xvWHU4NXpCWnIzUC9qTWYzVERLTWxyWlowSzg2d3dMOWMvWTlacnlHZzc2OVlYTENjbmU3N1hrNEVBYUZSVmxSWCszanBGWGlXcWIrQjl2Vy9pcFY3RjJ0QldyeW0zVjkrWVlROC85cno5N2Q1SDdaWTdIckpyYjd6WHBsNTVxOTEyOXlNTkdqemE1dWRZdnpZRjFyT2tjSVBnSVRWYTlUZEVRRzVLQkJBQWphcTZzdExmMjVBcTFPNWV4ZHJmcTJBN0ZHeFl1V1l6aGNST2hiazJvTFRBdXJVdXNJTGM1Tld1Um4rRnllaWFVa1lEeUtiU1hTRGI2RE9kdU9rUFBIRnI2dnV6VWUwTXBMWjhyNEx0V0pSbkEwc0xyWXQzbTYwVUFyc1ZlKytqYmFHVkZlWlozaWFhcHJKeDJSTXlFQUNOcXJxcS9nQWlDcGE1T2Eyc3ZWZnhidVpWd0QxYjUxdCtsbncvTGZaZWQrL1dlVGJBZTkxdEMvSXN4dy8rbTFLelZzT1pDU0FBVUtkV3JkS3JkbFFCbCtUbldqOHZJMUgvUVp1OEhOY3NGQ2Q2UjJYNU9kYS90TUI2ZTYrek9EOHZwYUN4Z1N4c3dNbElBTW5XVkJwQTQ4dk56L2YzMHFNS1dmMEgzYjFzUkJWMXA0SmNhNFErOTNvVmVEVm85K0k4Ny9VVVd1ZldCWllmWVFSVnVvRTFEckx2RlFPTktMRy9RWnNxc2NTdHFlL2YxRmI3K2JXM1pNOUozSkk5SjNGTDlwekVMWm5jdkhBQkpLQ2ZxLzZFc3FJOGw1WDA5Z0pLNjF6di8vUHZiMmlxTk50NldaQTYrL3UyS2JUU2dqelgzQlpWSys5bjFGVm1jVVVBQWRDb29nYVFnQ3BiTlc4VjUrZGF6NUlDZi9SV1RvUDFsUlI1Rlh4WEwyZ3ArK21xUGhrdkc4cGtoYjh1QXlHQUFFQ2RrZ1dRYmoyNjJlbm5uVzdIbjM2Y2pkbDZ0QlVVRlBqM3BNWmxKVzcwVnI2WEZSUllMNitDYjVNWFBTdFJFMWw3THlpcDc2VzN0N1V0eVBXeWpjd0dqb0FMSU5rVlB6SWJRTEl0L1FMUStKTDFnUnh3K00rOElOTFZCbXcrd05zL3dNNmZlcDV0dit2Mi9yMnBjMW1KVjhHMzlyS1M3cTBMM055TExrVzVWcFRta2ltYThLY2dwTURSMlF0SzZudlJ6MjdJT3E2VkFoTVpDTkI4QkpWR3NHMnFENkN4Nzg5R3lUS1E3ajI3KzN2cnlqemZDektUZnJxbi9mellRLzJ6NmRQUFViYlF2akRmZXZ0TlhKclFwNDd2Wk5wNVFhTmJVWjV0NWsvNFV4QlNNTkxQaWFwenQ4NjI1K1E5WFlDc1N5YituOFpHQUFIUXFKSUZrRVVMTjc2QWt5clVMVVp2WVdQSGI3Z2VXUmd1S0hsWlJBY3ZtK2hYV21RRHZTRFJvempmdW5tYk91RVZOTHA2UWFOdFlWN0cxNkthZk1oa08rTzhNMnpIM1hhd1kwODl4cjJuWkZybDVHWmRFTWxJU1dYck55RUFqUzlaQVBsazVpZiszb1pVb1U3Y2ExZi9LSE9VbWJRcHlIVjlHdXFFYjRnRkRQUHk4dXlZVTQ2Mm4wd1k1LzM4ZFlGQi84OUJSeDdvN3F2TlhWQ3FKUVlRQUVoVnNnRHl6T1BQdXJXZ2ttbFgxczdhbExieGo3SkRVWEdSbmZrL3Y3UkJRd2R0bEZXb2VhNW4zNTcrVWFKMXpaVFpoQUFDMUtOMm40UCt3Qk8zdU4xZmU2djkrTnBic3Vja2JzbWVrN2dsZTA3aWxreE9rZ0JTdnFiYzNuemxyYVRQMGYvVHRuMWIveWc3SEhiOFlWYldvY3cvMnBEZTQvSWZsdnRIMlkwQUFxQlJGUlMxOXZjMjlNOTcvMm16WjgzZUtJam9lRldqWFIwd09tVkxBd2ZWM1ZtK2N2bEtXN3h3c1grVTNUTGFCNkp2Q2dCUW42S1NVbjl2WTMrOS9BYWIvdWgwVzdsaTVmcDZaZmFYMzlqU3hVdmRmallZc3NWZ042czhHVjBOOFpFSC91VWZaVDh5RUFDTnFxaWsvdWFvWng5L3ppNzY5Zi9aZjUvK08vdmRMLy9IL25yWmoxY3ZqRDB2Ym96NnlTai9ZR1BQUGZHOHpYaDdobitVL1FnZ1FEMFMyL3UxNlZ0eDR0YlU5MmVqMGxhcnJYMUJsYmRYLzdYSjFhbGVXWkg4NGxOeGxadVR1OEdjbG9CK1Y3Ty9uTzJ5cTQydHRUS3ZQSWEzTC9lUHN3Y0JCRUNqcWx3NjE2c3NLMjE0dXdvcnpNbSthMkRVcDNwdHRjMzVkcTUvdEM1d3FObnFxVWVldHVzdnJaMUoxVmhwWHJXTjlBTEhNSzg4Y2x0bFh6a1FRQUEwcXZKbDZ5WU50aStzc1RFZEsyeEFTWVhsdW15a0dRUVM3eTFvTU1DeUg1YTV3TEZ3L2tLYmR1MnQ5dnlUei9zUGtCb3I4Z0xuMExibE5xS3N3dHFrdCt4WHJCQkFBRFNxdFFtWHRGVmZjL2VTdGJaVnAzTHIwN3JTV2pXRFFMSm93U0s3NUhlWDJNWC9QZFV1dStoeSsrS1RML3g3YWl5LzFWb2JWRnBob3p0VVdJY2lOVkg2ZC9teXJWa3lKMmhMamJMTm1UUEgvYkFlUFhva3ZUL0tCalNsNERPWStGbFVYMFJ3MjlUM0I3U2Y3RmpQUzN4dTdlTkFRejAvbWJYVkcxL1NOcy83S3R1N1RiVnQxYkhjdWhWVmVZRms0LzhqbTFSVlZkdXlwY3U4QXROUmpaZGgxZGlBTmhVMjFudC9YWXJYV3JLSjd6VmV4dUkvWWIyZ0hPTzZaU1FEMFE4Q21pTjl0bFZoeHZVMkc2MnRxcnRqdkNEWGJHRGJLdThiK2hwcmw2ZU85dXdPSkRuZTYrL3RaVlpqTzY2eGJsN2d5SzJueGwxYldlNEhrZXhCRXhaUWoxUXE4YWE4RFRZZEo1Nkx5M0V5TlFsTldIVXB6ak1iWGxacG84dldXRWx1OW5XMGV5VmdYUXZYQlk3ZUpkV1c3d1ZHcjFqcVZiUFdlNTkxbEZsY0VVQ0FlZ1NWWVZ4dnM5SGE2dFNHNW5wdjBWcm5tNDNzVUdGanZJeEVIYzk1K1huV3FVc242OUNwZy8rb09OSHZvOGJhNTFmWk9DOXdLSk5TUnFYM2tZcWFtdXpLUGlTakFTUmJQOUJBWGVxcnZPTnlHK3pIOFRpWitwcXdrdEdQVVVhaUVWdG4vdW80Ty9OM3Y3U3ovL2NzTy9hMFk5TytjbUhEcWJFMmVkVzJkYWMxYmtodUtobEhiV3ErOGtyUFA4b09aQ0JBUFlKS01hNjMyV2h0MWFhYnNKSnBYZGJCeW5yMmNlOWQyMmFEQjlxdkx6ckhpbG9YK1k5b0NtdmRYSTZ4WG9ZMHNrT2xHd3pndmJSd2FtakNBcHFWVkNyeHByd05OaDBubm92TGNUS3BObUhWVnJscXBadGJrYWgxU1dzNzRvVEQvYVBHRkV3Q3JMQXRPMVJZMGNhWDkwaGJ0bldnQ3dFRXFFZFFHY2IxTmh1bDI0UVZxS29vdHprejN2S1BmdFM1WTZrTmJSZDB0amUwR211YlgyVmJ0bC9qQWtlYmdzejlEbHdBeWJMZktRRUVxRWNxbFhoVDN3YjdjVHhPcGlaa0JpSXpIcm5YbHMzL2Nha1FaU1R2UFhTWGRTaXNjWjN0dzd4QTBycUJBb21HRlk5b1gyNWJ0SyswMGdicGVzbStMd1FwQlpBMWE5Yll5cFVyL2FQd0ZpMWFWT2RWeDRBNENpckZ1TjVtbzV5ODhMV3Z2cVgvZTlyVk52L3pqNnhpeldwNysvNWJiZW0zWDduN3ZDS3hNaStRak5vZ2tFUXRJelZWcmNzNE5LeTRyWmR4NlA5cENMb21lb1A5OEFhU1VnQjU5dGxuN1lvcnJyQlhYbmxsb3piSVZLeGF0Y29lZXVnaHUrYWFhK3lUVDVKZit4aUlvMVFxOGFhOERUWWRKNTZMeTNFeU9mblJPcjJyeXRmWW0zZmRhRTlkL0Z1Yi84bE0vK3lQdlA5K2ZTQlJ4dEJtL1lURVZJUEp1c2UyZFlGRDYxVXA0OUI3VzNkdlE4bkp6WGRsbDAxU0NpQURCdzYwcXFvcW16NTl1Z3NrTDcvOHNxMVlzY0svZDkyM05LbjlnVkhHOGNRVFQ3am52UC8rKys1eC9mdjM5KzhGNGkrb0RPTjZtNDF5Q3hwbjFKUlhSQzVqMk5JTEFDUEx5cTE5ZnJXL1JFcGQ1ZWFWcTdkcEhzY283L0ZiTkZMZ0NMVEtWVTk4ZGdXUVZ0NkhjSk9mUW1VZGwxeHlpV3ZLa3VERDI2bFRKK3ZidDY4VkZSVzU3S1N3c05ER2p4OXZpeGN2dHErKytzcVdMMTl1T1RrNTd2bTYzV3l6emV6UVF3OTFQeU1OTC9pM0NPSHR0OS9lMGQ5RkNHUEhqdDJvMG83YnJXaGY0bnFjNk0yclRyQ3ZucnJaUDJvOGVpbHJxczNtcmM2MTc5ZmtXV1dOWHFNMkxYSllZNTJMcXF4YmNiVVZOVkZMVXJ2K0kyMjNLOTcwTWhIdkJmaUNjb3lybERJUVZmNWJicm1sNWZwdkxQaFFMRnk0ME41OTkxMTc5ZFZYM2JFQ3pJc3Z2bWd6Wjg1MHdVT0NKaS8xZll3Y09kTHRBOWxDZjhENnZNZjFOaHRGYmNJS3l5c3lOeUd4ZjJtMWplbFlic1BhbFZ2WG9rcDNxK04rYmFyZC9YcGNVOGoxeXFWVnNsVVdZeXpsVnp0cTFLaWtIZUFLRUVHUTBJZGErOGsrMk1wT0JnOGU3QjhCMmFHK3lqc090OEdtNDhSemNUbE9wckJ0UjMrdjZXakNuL3BKTm10YjVXNGpUUURNRk8vL1Y5bGxrNVFEU1BmdTNhMWp4L1IvOGZvUUtYTkp6R0NBYkJGVWhuRzl6VVlkTmgvbjd5RlI2ODU5L0wzc2tWYStOSHIwYVBmQlRZY2VUL01Wc2xVcWxYaFQzd2I3Y1R4T3B0dVkzYTNYOWdmNlI5bWhiYmVlMW52MDF0WjNxKzBzdHdIVzMyby9ZTFNOTysxRy95aDdwQlZBbEVYb3c1RU9QYjVkdTNiV3MyZFAvd3lRUFlKS01hNjMyU2duTjgvR24zTzNiWEg0UlY0QnAxVUZOYnFpMG5ZMjd1ZkgyNFRqejdTUit4MWlJL1krd0hiNmY3LzE3ODJNbnR2OXpIYjk4OHVXMzdyVVA1TTkwdnJ0bFphV3VtRzQrdkNtU2gzd1lUSVhJQTVTcWNTYjhqYllkSng0TGk3SGRkRmpoaDM4Rzl2cEQ4OVlibkZtSzg3ODRoSnJsWUhtY21VZE81M3lHK3M2YUppcnh3S0ZyVXN5RnZpR1Q3bkF0djMxM1kwMnREblQwaTRGQllPZzB6d1YraEFwY3dHeVVWQVp4dlUyMjNVWnNZUHRmZE5uMW1YVVJQOU1OTnNjL2d2YjQ1eUxiTkp2cDlyNG8wNnhqZ00yOSs5Smo1cXBmbkxZQ1paWFVPaWYrVkg1cXBWZXhaYitoT3BFdVVVbHR2UEZMOWp3UTg1Zk53TTlTNlVkUUlZT0hacldHdnk5ZXZXeXNySXkvd2pJTHFsVTRrMTlHK3pIOFRnVlJlMjYySTYvZjl6R25QSlgvMHc0SGZvTXNFNSt3RkRHMExIdlFOdG15a2xlRnZGYkt5aEpMOHZwUFhxOEZkYnhuTXJ5MWY1ZU9GMUdUclI5Yi8zR09nK2Y0Si9KWG1rSGtMeThQQnMrZkxqN0JlbURzaW5LV0lCc0ZWU0tjYjF0TGpUL1liTTlqN1A5N3BocmVjVnQvYlBwNlRseTQ5RmRLcWMySFR2YjFsTk9UUG1idmg0M2VPYzkzWE9US1M1dDUrK2xiOXdadDlpT0Z6NXVCVzNhKzJleVc2aUdQTTBKVVROV1hRVWNVSkFaTm15WWZ3UmtuMVFxOGFhOERUWWRKNTZMeTNHNmlzcTYydVM3RjlqUWc4L3pqdExyTjYxdmRGVGJyajFzMkc3NytVZjFLKzNhUFduVDFZL1M3ODh0N1RYRTlyMWpqdldmZUtRTGxzMUZxSGZTcDA4Zk43S3FQdm9RRFJreXhDMXpBbVNyb0RLTTYyMXpsSk9YYjF0TXVjQW0zZmlwRlhWSWZmVG0zSm52K25zYlUzbDE3TDlaU3BWM2FlZnU3dkhKVkphdnNWZHV2dHcvMnJSV3VmbXVvM3lQYTk2M292WmQvYlBOUjZnQW9zTFZ2STY2Q2xuMDRXYnVCN0pkZlpWM1hHNkQvVGdlaDZYbnR1azJ3UGErWlpZTm1IU2lmN1orUzc3NzJ0YldjN21JVkpkTFg3Rm92bnNQaWJTTS9QZGZmVzVQWC9MZnRtTGhBdjlzL1VwN0Q3VkpmLzNFaG5uWlZFNWVYcVR5aUt2UXVaU0NRKzFDVHFUTVE0c25BdGtzcUJUamV0dWM2VDNtZXRuSTJKT3Z0WWxYdkdHdHU5Vy9rbmZscWhYMjluM1Q2aXlYdk1KQ3kwbWhIK1NIT2QvWWR6UGVzdXFxU3ZlemxzejUxcDY1OHZmMit1MS84UUtVbG9hdm43S09RZnVmN21VZDczbEJzSjk3SDgxVlNxdngxdVhHRzIrMHVYTi92RHBZUUV1V2pCczN6dmJZWXcvL1RDU3N4aHNCcS9GR0UvZlZlQU02bHVCY1hJNHpxV1p0dGIxMzh6bjIrYit1TWE5Mjk4OXVyUHV3VVRaOHo4bHVFbUNpbFlzWDJndlhYV3hycXpZZEJFVExxK2NYRmxtRkY1aFMxVzdBS052NjdEdXNuWmQ5QkdVUlJTWitSa09LMUpzelpzd1lmMjlEV3JxRXVSOW9EdlFIck1vd3JyY3RpWnFnUmgzM1o1dDQ2V3ZXdHQ4Vy90bU4vZWVqOTJ6NkZiKzNMMTUrMXFvcjExMCtWMDFicy83OVhNckJRMnE4SUpWcThOQUt3eU9PL3BQdGZ1VmIxcjdQTVBmN2FRa2laU0RsNWVVMmRlclVqU1lXZHVqUXdVNDk5VlQvS0RJeWtBaklRS0xoZWlDWk9jNDBOU1Y5OXRBVk51TzI4N3lEdW9OQ2JrR2h0ZTNleThxWC8yQ3J2QXlrSVhRY3RwMXRmZVp0MW1ZVFRXeGhCT1VZVjVFeUVDM1Jyb21GaVc5UyszVmxKa0MyMGVkWmxXQmNiMXNxcmFjMStML09za2szZkd4bG00MzF6MjZzdXFMY2xzeWUxU0RCUTlkMjMrYWN1MnlYaTU5dmtPQ1JEU0lGRUttOXdLTDJSNHdZNFI4QjJTMVpwUjJuMjJEVGNlSzV1QnczSlAwL3BkMEcySzZYL3R1Mk9mY2UxM25kV0hwdGY1RHQrN2U1MW1lSGc3M1hFYmthelZxUjM3bEdXaVhPOVJnd1lJQzFiUnR1SmlrUU4wRmxHTmRick10RytrdzQwUGEvYTRIMTJla3c3MHpETmZ2a0ZaZmF4Q3Zmc3ZGZTVsSFloaVdhSWdjUXpUYlh6SFI5b0xVeDl3UE5TU3FWZUZQZkJ2dHhQRzVNQlNWdGJadXpiN2M5L2pMVDhrczcrR2N6UTgxVlkwNjV6aWJmL2IxMUdNanE0b0dNNUY3Qm5CQUZFODArQjVxTG9GS002eTAyMXE3UFVOdi96bmsyK0lCZnU0by9FcStjMnc4Y2EvdmZ2ZEFHN25HOG15V1BIMlVrZ0hUcjFzMjZkdTNxK2o3U1dha1hpTHRVS3ZHbXZBMDJIU2VlaTh0eFU5R0V3WkZIL2NIMjh3Skp4MkVUWENCSWx5NHh1OHNsTDl0dVY3eSs3aG9qSVg1R2N4ZHBHRzhpRGVuVlNyME5jTjF6aHZGR3dERGVhTGJhYXF2MUZXTmNiMFg3RXJmanVKajMzalAyOWpVbjJjcDVYL3BuNnBiWHVxMWJ2MnJ6ZlUveDNrL1RkcEFINVJsWEdTc2REZWx0Z09BQk5DbFZoUG9qanZOdHNCL0g0N2pvTm1wWG0zVDlSMTVnK0wzbEZyWHh6OWJpdmQ1K0U0KzIvZjgyendidmQ1cDMyTFRCSXh0UVFrQTlna294cnJkSW5mb3ZoaDl5bnJ2bXlLRDl6L0RQcnJQWjNpZmI1SHNXMlUvT3VNbE5Qa1JxTXRhRTFZQm93b3FBSnF4b1dBc3IybkdjVmE1ZWJuTmUvYWYxbW5DQTVjWDBtdVJCZWNZVkdRaFFELzBCcXpLTTZ5M0N5eTh1dFg2N1RJbHQ4TWdHQ20reC9oVEcvWTlFZjhoeFJ2bEZRL2xGUS9sRkUvZnlJd01CQUlSQ0FBR0FGa0RaeklvVks5eFduNHFLQ2x1NmRLbFZwYkQwUFUxWUVaRUNSMFA1UlVQNVJkT2N5dS94eHgrM045NTR3enAzN213bm4zeXlmM2Fkano3NnlKNTg4a2xidG15Wk85WWxOL2JaWngvcjMvL0hWWVJYclZwbC8vclh2K3lUVHo1eC82K21aV2lacWttVEp0VTVSWU1NQkFDeTNILys4eDk3ODgwM3JheXN6R1VRaVdiUG5tMFBQUENBOWUzYjEwNDg4VVE3L1BERDNhVHZ1KysrMjM3NDRRZi9VV2IzM1hlZmUreUJCeDVvSjUxMGtrMllNRUdqT0czNjlPbitJellXT1lBb01uWHMyTkg2OU9uak5yMEJBRURqVUxidzZLT1AyckJodzZ4WHIxNysyUis5K09LTDFxNWRPNXM4ZWJKYmRrb3Jwdi8wcHorMXlzcEtlK2VkZDl4anZ2NzZheGM4ZHQ5OWQzZU5KeTFOdGROT085bWdRWVBzcmJmZXFyTTVLM1FBVWVwWFVsSmlXMnl4aFoxenpqbDJ6ejMzMkoxMzNtbW5uSEtLUzQvaW5ob0NRSFB3L3Z2djI0SUZDMXpsWDV1dUZxdmdNSERnUUxmWWJVQ0JSSmZkK082Nzc5enhsMSt1VytKRkFTUFI1cHR2N29LSGZuNHlvUUtJMHA4ZVBYcTRpSGJERFRlNHRFalI3SU1QUG5BWnlISEhIZWNpSGdDZzRXZ05RalV4N2JERERrbXZ3NlFPY3dVUnRSTFZwcnA2NWNxVmJsOTlJOFhGeGRhNmRXdDNIQWhhbE9ycWVFOHJnQ2lDNlVYcWtyWG5uMysrWFhIRkZhN0RSbTFwenozM25NMmZQOSs5RUwycDZ1cHEvMWtBZ0lhZ2VsZnJFSTRmUDk0L3M2RWdRT2d4dGVtY09zNUZqNnZyTWJKNjlXcDNXMXZLQVVUQlEyblBsQ2xUYk5xMGFYYnd3UWZidSsrKzY1cXRGRGdTNlVVcGlBQUFHc2IzMzMvdk9zNzMzSFBQVFM1a3F5d2ttY1RuMWZlbFAvSW9MR1VlUng1NXBGMTQ0WVV1bU54MjIyMzI3My8vMi8ybjZzUlpzMmFOLzhoMW5UcnBERDhEQUtSSHczTFYyZDJtVFJzM0NrdWJNZ1hWeWRwWG5SdzBTU1hXendHZFV6KzJxUG1xcnNkSThMamFVZzRndWxDVXJuLys0WWNmMnIzMzNydCsrTmVpUll0Y0U1Yk9Bd0FheDd4NTgxeWdVRDkwc0gzeHhSZXV2MEw3cjczMm1nc2dHdEMwY09GQy8xbnI2QXUrenJWdjM5NGRLd2lwSHp1WUp4SlEvUzUxOVdtbkhFQVVpVFJKWmNhTUdlNVlUVlJQUC8yMC9lVXZmN0hseTVmYnR0dHU2ODREQUJxZTVtcWNkdHBwRzJ5REJ3KzIwdEpTdDY5NUhQbjUrZGF6WjA4WFdCS0g0czZhTmN0MU5XaVVsV2lPaUh6NjZhZnVWaFJrVk45MzZ0VEpqYXhOSnVVQW9zaWtvYnFhMGZqdHQ5KzZ3UEhLSzYrNFRwYmpqei9lWlNjQWdNYWhyRUdqcEJJM3RSU3BpMEg3R2kwcjIyKy92ZXNrRDFxS1huLzlkWHZ3d1FkZG43YW1ZWWdDaVk0MW91dlZWMTkxajlQRXdybHo1OXJFaVJQZFk1TFJaSTJVT3l1VUNnV3BUdEJKcnVGaEYxMTBrWFh2M3QxMXFvdkdGcXVQUkkrTEt1NTlLYzFwS1lTbVFQbEZRL2xGMDl6S1R3RkFsZjRSUnh6aG4xbEhVeXhlZXVrbDF5UlZWRlRrQW9ZQ1ErS3dYVFY5UGZYVVV5NWJVZDNkcFVzWEYzeUdEQm5pUDJKamFRV1FaUFNmcUdOZDBZc0FFaitVWHpTVVh6U1VYelJ4TDcrVW03QUFBRWhFQUFHQVprN05VcGRmZnJucmVsQldjOHN0dDJSazVDd0JCQUNhT1ExeVVqLzE4ODgvN3haUVZFZTdGbCtNaWdBQ0FDM0FYbnZ0WmUrOTk1NWIvbVMvL2ZiTFNQOFBBUVFBV2dBTjhkV21tZXJCRU4rb0NDQUEwQUpvaU82SUVTTnM1TWlSN3VxRm1VQUFBWUJtVHRjRTBleHpMZnUrODg0N3U2a1d1blJ0VkFRUUFHam10Qmp1VVVjZDVacXd0SHJJMFVjZjdTN0ZFUlVCQkFDYUFmVnRMRm15WlAwMVBoSnBMU3ZOT3RjeVZOcTBYbGF5aTB5Smxvbi82cXV2YlBIaXhmNlp1cWtiUHRKVVIyYWlNNU0xQ3Nvdkdzb3ZtdVpVZmxvbFhjMVNXZ2RMaXlrbTBxVTNOUG9xV0ZCUm1jZysrK3pqK2tRQ0NoajMzMysvVytVM29FdmhIbmpnZ1Vrdk5pVmtJQUNRNVRSUlVDdnA2Z3Q5N2FDakJYQzFjdm8yMjJ4ajU1NTdycDE2NnFudWt1UVBQZlRRK21YZWRjRXBMWlpiVVZIaExsSCttOS84eGwyeVhOZEtmK0tKSjl4amtrazdnR2dDU3JEcEtsVzZyU3VLYitwK0FFQTBhcnBTSlQ5dTNEZ1hRR3BUOXFIK2psMTIyY1ZsRW1yTzJuZmZmVjNRQ0ZxTlB2LzhjOWQwdGZ2dXU3dldKR1VvR3EybHlZWmEwbDJCSlptVUE0Z0NnZGFGSHpWcTFBYWJsZ05PMXBhbUsxZ05IejdjdlFpbFFYbytBQ0N6ZE9Fb1hZbFFvNnRxVTVQVm5EbHpYQjJjK0VWZVFVUVhrOUlGcVdUMjdObnUvbjc5K3JuandJQUJBMXlnVVhCSkp1VmFYYjM0eHg1N3JFdUZIbnZzc2ZYYlhYZmRaVHZ1dUtPTGdnRk5VaGs2ZEtqZGZ2dnQ5c2dqajdpclkya3FQVUVFQURKSDEybDY0WVVYM05Mc1dxYTlOaTNSTHNHVkJ4UHBuSzRUSW5xY090bHI5M1VFVnlJTUhsZGJXaG1Jc29yMzMzL2Zyci8rZXJkZGQ5MTE3c0pTMTF4enpmb3JGWXBTb0QzMjJNTzFzZDEwMDAzMjRvc3YycFFwVTF6UFB3QWdNL1NGWHMxV2FnMUtKcWo0azNXQzYycUZ5bHhFajFPelZXM0I4NExIMVpaeUFGR0VVc2J4OGNjZisyZlNvelFvdUFnVkFDQ2FiNzc1eHEyb08yblNwQTJhcHhJRnJUNkpsN01OcUxOZFFVVDB1TG9lSThIamFrczVnS2dUUlIwdUR6endnQzFZc01CbXpwenBqbFBkTklSTTExVUhBRVNucFVtNmR1MXFQL3p3Z3h0cHBVMzdxcXUxdjNUcDB2VlhIRXhXOXlxclVLdVNGQmNYSjMxTU1LZEVWNkpOUm1FcnJZSGFTblBVMXBadU5xRU1KTXk4RU1hUlIwUDVSVVA1UlVQNVJWTmYrVjEyMldXMmZQbHkvMmhqdSs2NnF4dTYrOGMvL3RIMVNSOXd3QUgrUGV2cTQ2bFRwN3JMMVdxNHJpNkYrOG9ycjdqNUk1cEhFdEJsY0o5OTlsazc4OHd6azNaQnBCMUFHaHNmd0dnb3YyZ292MmdvdjJqU0xiKy8vLzN2YmlMMzZhZWY3cDh4TjZsYmt3TjFMdWhvVjUvMWd3OCthSWNjY29nTkhqell6VHpYb0NjRm5Ra1RKcmpIYUdDVStyaVZuUngzM0hIdVhHME1pd0tBWmt6elA5U3NOVzNhTkpkbGFDWGVoeDkrMkEzdDNYenp6ZDFqTkh5M2YvLytycXRCOTcvODhzdDI4ODAzdXlZeERZaXFDeGxJUkh3RGpJYnlpNGJ5aTZhNWxkK3JyNzdxNW16b2dsR0oxT0d1Q1lXTEZpMXlXWWdDeDdiYmJ1c21ld2ZVeGFBbUs2M2FxMzJON3RwdXUrM2NsUXpyUWdDSmlEL2dhQ2kvYUNpL2FDaS9hR2pDQWdDRVFnQUJBSVJnOXY4QjRoTU9wSStYbHRzQUFBQUFTVVZPUks1Q1lJST1cIjtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnQudHNcIi8+XHJcbi8vIC88cmVmZXJlbmNlIHBhdGg9XCIuLi9UaW1lL1RpbWUudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIG1vZGUgYSBsb29wIHJ1bnMgaW5cclxuICAgKi9cclxuICBleHBvcnQgZW51bSBMT09QX01PREUge1xyXG4gICAgLyoqIExvb3AgY3ljbGVzIGNvbnRyb2xsZWQgYnkgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xyXG4gICAgRlJBTUVfUkVRVUVTVCA9IFwiZnJhbWVSZXF1ZXN0XCIsXHJcbiAgICAvKiogTG9vcCBjeWNsZXMgd2l0aCB0aGUgZ2l2ZW4gZnJhbWVyYXRlIGluIHtAbGluayBUaW1lLmdhbWV9ICovXHJcbiAgICBUSU1FX0dBTUUgPSBcInRpbWVHYW1lXCIsXHJcbiAgICAvKiogTG9vcCBjeWNsZXMgd2l0aCB0aGUgZ2l2ZW4gZnJhbWVyYXRlIGluIHJlYWx0aW1lLCBpbmRlcGVuZGVudCBvZiB7QGxpbmsgVGltZS5nYW1lfSAqL1xyXG4gICAgVElNRV9SRUFMID0gXCJ0aW1lUmVhbFwiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3JlIGxvb3Agb2YgYSBGdWRnZSBhcHBsaWNhdGlvbi4gSW5pdGlhbGl6ZXMgYXV0b21hdGljYWxseSBhbmQgbXVzdCBiZSBzdGFydGVkIGV4cGxpY2l0bHkuXHJcbiAgICogSXQgdGhlbiBmaXJlcyB7QGxpbmsgRVZFTlQuTE9PUF9GUkFNRX0gdG8gYWxsIGFkZGVkIGxpc3RlbmVycyBhdCBlYWNoIGZyYW1lXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBMb29wIGV4dGVuZHMgRXZlbnRUYXJnZXRTdGF0aWMge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lU3RhcnRHYW1lOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lU3RhcnRSZWFsOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lRnJhbWVHYW1lOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lRnJhbWVSZWFsOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lRnJhbWVTdGFydEdhbWU6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVGcmFtZVN0YXJ0UmVhbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUxhc3RGcmFtZUdhbWVBdmc6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVMYXN0RnJhbWVSZWFsQXZnOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJGcmFtZXM6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBydW5uaW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBtb2RlOiBMT09QX01PREUgPSBMT09QX01PREUuRlJBTUVfUkVRVUVTVDtcclxuICAgIHByaXZhdGUgc3RhdGljIGlkSW50ZXJ2YWxsOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaWRSZXF1ZXN0OiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZnBzRGVzaXJlZDogbnVtYmVyID0gMzA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBmcmFtZXNUb0F2ZXJhZ2U6IG51bWJlciA9IDMwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc3luY1dpdGhBbmltYXRpb25GcmFtZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVTdGFydEdhbWUoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lU3RhcnRHYW1lOyB9XHJcbiAgICAvKiogVGhlIHJlYWx0aW1lIHRoZSBsb29wIHdhcyBzdGFydGVkLCBvdmVyd3JpdHRlbiBhdCBlYWNoIHN0YXJ0ICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lU3RhcnRSZWFsKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZVN0YXJ0UmVhbDsgfVxyXG4gICAgLyoqIFRoZSBnYW1ldGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGxvb3AgY3ljbGUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZUdhbWUoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVHYW1lOyB9XHJcbiAgICAvKiogVGhlIHJlYWx0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgbG9vcCBjeWNsZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZUZyYW1lUmVhbCgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVGcmFtZVJlYWw7IH1cclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgdGhlIGxhc3QgbG9vcCBjeWNsZSBzdGFydGVkKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZVN0YXJ0R2FtZSgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZTsgfVxyXG4gICAgLyoqIFRoZSByZWFsdGltZSB0aGUgbGFzdCBsb29wIGN5Y2xlIHN0YXJ0ZWQqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZUZyYW1lU3RhcnRSZWFsKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZUZyYW1lU3RhcnRSZWFsOyB9XHJcbiAgICAvKiogVGhlIGF2ZXJhZ2UgbnVtYmVyIG9mIGZyYW1lcyBwZXIgc2Vjb25kIGluIGdhbWV0aW1lICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCBmcHNHYW1lQXZlcmFnZSgpOiBudW1iZXIgeyByZXR1cm4gMTAwMCAvIExvb3AuxpJUaW1lTGFzdEZyYW1lR2FtZUF2ZzsgfVxyXG4gICAgLyoqIFRoZSBhdmVyYWdlIG51bWJlciBvZiBmcmFtZXMgcGVyIHNlY29uZCBpbiByZWFsdGltZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZnBzUmVhbEF2ZXJhZ2UoKTogbnVtYmVyIHsgcmV0dXJuIDEwMDAgLyBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmc7IH1cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGZyYW1lcyB0cmlnZ2VyZWQgc28gZmFyICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCBmcmFtZXMoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJGcmFtZXM7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgbG9vcCB3aXRoIHRoZSBnaXZlbiBtb2RlIGFuZCBmcHMuICBcclxuICAgICAqIFRoZSBkZWZhdWx0IGZvciBfbW9kZSBpcyBGUkFNRV9SRVFVRVNULCBzZWUge0BsaW5rIExPT1BfTU9ERX0sIGhvb2tpbmcgdGhlIGxvb3AgdG8gdGhlIGJyb3dzZXIncyBhbmltYXRpb24gZnJhbWUuXHJcbiAgICAgKiBJcyBvbmx5IGFwcGxpY2FibGUgaW4gVElNRS1tb2Rlcy5cclxuICAgICAqIF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lIGlzIGV4cGVyaW1lbnRhbCBhbmQgb25seSBhcHBsaWNhYmxlIGluIFRJTUUtbW9kZXMsIGRlZmVycmluZyB0aGUgbG9vcC1jeWNsZSB1bnRpbCB0aGUgbmV4dCBwb3NzaWJsZSBhbmltYXRpb24gZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RhcnQoX21vZGU6IExPT1BfTU9ERSA9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNULCBfZnBzOiBudW1iZXIgPSA2MCwgX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWU6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBMb29wLnN0b3AoKTtcclxuXHJcbiAgICAgIExvb3AuxpJUaW1lU3RhcnRHYW1lID0gVGltZS5nYW1lLmdldCgpO1xyXG4gICAgICBMb29wLsaSVGltZVN0YXJ0UmVhbCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRHYW1lID0gTG9vcC7GklRpbWVTdGFydEdhbWU7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWwgPSBMb29wLsaSVGltZVN0YXJ0UmVhbDtcclxuICAgICAgTG9vcC5mcHNEZXNpcmVkID0gKF9tb2RlID09IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUKSA/IDYwIDogX2ZwcztcclxuICAgICAgTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgPSBMb29wLmZwc0Rlc2lyZWQ7XHJcbiAgICAgIExvb3AuxpJUaW1lTGFzdEZyYW1lR2FtZUF2ZyA9IExvb3AuxpJUaW1lTGFzdEZyYW1lUmVhbEF2ZyA9IDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQ7XHJcbiAgICAgIExvb3AubW9kZSA9IF9tb2RlO1xyXG4gICAgICBMb29wLnN5bmNXaXRoQW5pbWF0aW9uRnJhbWUgPSBfc3luY1dpdGhBbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICAgIGxldCBsb2c6IHN0cmluZyA9IGBMb29wIHN0YXJ0aW5nIGluIG1vZGUgJHtMb29wLm1vZGV9YDtcclxuICAgICAgaWYgKExvb3AubW9kZSAhPSBMT09QX01PREUuRlJBTUVfUkVRVUVTVClcclxuICAgICAgICBsb2cgKz0gYCB3aXRoIGF0dGVtcHRlZCAke19mcHN9IGZwc2A7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKGxvZyk7XHJcblxyXG4gICAgICBzd2l0Y2ggKF9tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuRlJBTUVfUkVRVUVTVDpcclxuICAgICAgICAgIExvb3AubG9vcEZyYW1lKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX1JFQUw6XHJcbiAgICAgICAgICBMb29wLmlkSW50ZXJ2YWxsID0gd2luZG93LnNldEludGVydmFsKExvb3AubG9vcFRpbWUsIDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQpO1xyXG4gICAgICAgICAgTG9vcC5sb29wVGltZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9HQU1FOlxyXG4gICAgICAgICAgTG9vcC5pZEludGVydmFsbCA9IFRpbWUuZ2FtZS5zZXRUaW1lcigxMDAwIC8gTG9vcC5mcHNEZXNpcmVkLCAwLCBMb29wLmxvb3BUaW1lKTtcclxuICAgICAgICAgIExvb3AubG9vcFRpbWUoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgTG9vcC5ydW5uaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSBsb29wXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RvcCgpOiB2b2lkIHtcclxuICAgICAgaWYgKCFMb29wLnJ1bm5pbmcpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgc3dpdGNoIChMb29wLm1vZGUpIHtcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUOlxyXG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfUkVBTDpcclxuICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKExvb3AuaWRJbnRlcnZhbGwpO1xyXG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfR0FNRTpcclxuICAgICAgICAgIFRpbWUuZ2FtZS5kZWxldGVUaW1lcihMb29wLmlkSW50ZXJ2YWxsKTtcclxuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIExvb3AucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkxvb3Agc3RvcHBlZCFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjb250aW51ZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKExvb3AucnVubmluZylcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBMb29wLnN0YXJ0KExvb3AubW9kZSwgTG9vcC5mcHNEZXNpcmVkLCBMb29wLnN5bmNXaXRoQW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGxvb3AoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0aW1lOiBudW1iZXI7XHJcbiAgICAgIHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZVJlYWwgPSB0aW1lIC0gTG9vcC7GklRpbWVGcmFtZVN0YXJ0UmVhbDtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZVN0YXJ0UmVhbCA9IHRpbWU7XHJcblxyXG4gICAgICB0aW1lID0gVGltZS5nYW1lLmdldCgpO1xyXG4gICAgICBMb29wLsaSVGltZUZyYW1lR2FtZSA9IHRpbWUgLSBMb29wLsaSVGltZUZyYW1lU3RhcnRHYW1lO1xyXG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRHYW1lID0gdGltZTtcclxuXHJcbiAgICAgIExvb3AuxpJUaW1lTGFzdEZyYW1lR2FtZUF2ZyA9ICgoTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgLSAxKSAqIExvb3AuxpJUaW1lTGFzdEZyYW1lR2FtZUF2ZyArIExvb3AuxpJUaW1lRnJhbWVHYW1lKSAvIExvb3AuZnJhbWVzVG9BdmVyYWdlO1xyXG4gICAgICBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmcgPSAoKExvb3AuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmcgKyBMb29wLsaSVGltZUZyYW1lUmVhbCkgLyBMb29wLmZyYW1lc1RvQXZlcmFnZTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIExvb3BFdmVudCB3aGljaCBjb252ZXlzIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGltZUVsYXBzZWQgZXRjLi4uXHJcbiAgICAgIExvb3AuxpJGcmFtZXMrKztcclxuICAgICAgbGV0IGV2ZW50OiBFdmVudCA9IG5ldyBFdmVudChFVkVOVC5MT09QX0ZSQU1FKTtcclxuICAgICAgTG9vcC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcEZyYW1lKCk6IHZvaWQge1xyXG4gICAgICBMb29wLmxvb3AoKTtcclxuICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcEZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wVGltZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSlcclxuICAgICAgICBMb29wLmlkUmVxdWVzdCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoTG9vcC5sb29wKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIExvb3AubG9vcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVVbml0cyB7XHJcbiAgICBob3Vycz86IG51bWJlcjtcclxuICAgIG1pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBzZWNvbmRzPzogbnVtYmVyO1xyXG4gICAgdGVudGhzPzogbnVtYmVyO1xyXG4gICAgaHVuZHJlZHM/OiBudW1iZXI7XHJcbiAgICB0aG91c2FuZHM/OiBudW1iZXI7XHJcbiAgICBmcmFjdGlvbj86IG51bWJlcjtcclxuICAgIGFzSG91cnM/OiBudW1iZXI7XHJcbiAgICBhc01pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBhc1NlY29uZHM/OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVycyBleHRlbmRzIE9iamVjdCB7XHJcbiAgICBbaWQ6IG51bWJlcl06IFRpbWVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgZ2VuZXJhdGUgYSB0aW1lc3RhbXAgdGhhdCBjb3JyZWxhdGVzIHdpdGggdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYnV0IGFsbG93cyBmb3IgcmVzZXR0aW5nIGFuZCBzY2FsaW5nLiAgXHJcbiAgICogU3VwcG9ydHMge0BsaW5rIFRpbWVyfXMgc2ltaWxhciB0byB3aW5kb3cuc2V0SW50ZXJ2YWwgYnV0IHdpdGggcmVzcGVjdCB0byB0aGUgc2NhbGVkIHRpbWUuXHJcbiAgICogQWxsIHRpbWUgdmFsdWVzIGFyZSBnaXZlbiBpbiBtaWxsaXNlY29uZHNcclxuICAgKiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUaW1lIGV4dGVuZHMgRXZlbnRUYXJnZXTGkiB7XHJcbiAgICAvKiogU3RhbmRhcmQgZ2FtZSB0aW1lIHN0YXJ0aW5nIGF1dG9tYXRpY2FsbHkgd2l0aCB0aGUgYXBwbGljYXRpb24gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZ2FtZTogVGltZSA9IG5ldyBUaW1lKCk7XHJcbiAgICBwcml2YXRlIHN0YXJ0OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHNjYWxlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIG9mZnNldDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsYXN0Q2FsbFRvRWxhcHNlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lcnM6IFRpbWVycyA9IHt9O1xyXG4gICAgcHJpdmF0ZSBpZFRpbWVyQWRkZWRMYXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSAxLjA7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gMC4wO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gMC4wO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2FtZS10aW1lLW9iamVjdCB3aGljaCBzdGFydHMgYXV0b21hdGljYWxseSBhbmQgc2VydmVzIGFzIGJhc2UgZm9yIHZhcmlvdXMgaW50ZXJuYWwgb3BlcmF0aW9ucy4gXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZ2V0IGdhbWUoKTogVGltZSB7XHJcbiAgICAvLyAgIHJldHVybiBUaW1lLmdhbWVUaW1lO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VW5pdHMoX21pbGxpc2Vjb25kczogbnVtYmVyKTogVGltZVVuaXRzIHtcclxuICAgICAgbGV0IHVuaXRzOiBUaW1lVW5pdHMgPSB7fTtcclxuXHJcbiAgICAgIHVuaXRzLmFzU2Vjb25kcyA9IF9taWxsaXNlY29uZHMgLyAxMDAwO1xyXG4gICAgICB1bml0cy5hc01pbnV0ZXMgPSB1bml0cy5hc1NlY29uZHMgLyA2MDtcclxuICAgICAgdW5pdHMuYXNIb3VycyA9IHVuaXRzLmFzTWludXRlcyAvIDYwO1xyXG5cclxuICAgICAgdW5pdHMuaG91cnMgPSBNYXRoLmZsb29yKHVuaXRzLmFzSG91cnMpO1xyXG4gICAgICB1bml0cy5taW51dGVzID0gTWF0aC5mbG9vcih1bml0cy5hc01pbnV0ZXMpICUgNjA7XHJcbiAgICAgIHVuaXRzLnNlY29uZHMgPSBNYXRoLmZsb29yKHVuaXRzLmFzU2Vjb25kcykgJSA2MDtcclxuXHJcbiAgICAgIHVuaXRzLmZyYWN0aW9uID0gX21pbGxpc2Vjb25kcyAlIDEwMDA7XHJcbiAgICAgIHVuaXRzLnRob3VzYW5kcyA9IF9taWxsaXNlY29uZHMgJSAxMDtcclxuICAgICAgdW5pdHMuaHVuZHJlZHMgPSBfbWlsbGlzZWNvbmRzICUgMTAwIC0gdW5pdHMudGhvdXNhbmRzO1xyXG4gICAgICB1bml0cy50ZW50aHMgPSB1bml0cy5mcmFjdGlvbiAtIHVuaXRzLmh1bmRyZWRzIC0gdW5pdHMudGhvdXNhbmRzO1xyXG5cclxuICAgICAgcmV0dXJuIHVuaXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRpbWUgYW5kIHNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHNjYWxlZCB0aW1lc3RhbXAgb2YgdGhpcyBpbnN0YW5jZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLnNjYWxlICogKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZW1haW5pbmcgdGltZSB0byB0aGUgZ2l2ZW4gcG9pbnQgb2YgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmVtYWluZGVyKF90bzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF90byAtIHRoaXMuZ2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoUmUtKSBTZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhpcyBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lc3RhbXAgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHRpbWUgKGRlZmF1bHQgMC4wKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF90aW1lOiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgdGhpcy5nZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjYWxpbmcgb2YgdGhpcyB0aW1lLCBhbGxvd2luZyBmb3Igc2xvd21vdGlvbiAoPDEpIG9yIGZhc3Rmb3J3YXJkICg+MSkgXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBkZXNpcmVkIHNjYWxpbmcgKGRlZmF1bHQgMS4wKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUoX3NjYWxlOiBudW1iZXIgPSAxLjApOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQodGhpcy5nZXQoKSk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSBfc2NhbGU7XHJcbiAgICAgIC8vVE9ETzogY2F0Y2ggc2NhbGU9MFxyXG4gICAgICB0aGlzLnJlc2NhbGVBbGxUaW1lcnMoKTtcclxuICAgICAgdGhpcy5nZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5USU1FX1NDQUxFRCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHNjYWxpbmcgb2YgdGhpcyB0aW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgb2Zmc2V0IG9mIHRoaXMgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2Zmc2V0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgc2NhbGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IHJlc2V0IGF0IGV2ZXJ5IGNhbGwgdG8gc2V0KC4uLikgYW5kIHNldFNjYWxlKC4uLilcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgY3VycmVudDogbnVtYmVyID0gdGhpcy5nZXQoKTtcclxuICAgICAgbGV0IGVsYXBzZWQ6IG51bWJlciA9IGN1cnJlbnQgLSB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gY3VycmVudDtcclxuICAgICAgcmV0dXJuIGVsYXBzZWQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRpbWVyc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZTx2b2lkPiB0byBiZSByZXNvbHZlZCBhZnRlciB0aGUgdGltZSBnaXZlbi4gVG8gYmUgdXNlZCB3aXRoIGFzeW5jL2F3YWl0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxheShfbGFwc2U6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoX3Jlc29sdmUgPT4gdGhpcy5zZXRUaW1lcihfbGFwc2UsIDEsICgpID0+IF9yZXNvbHZlKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lIGlmIHdlYi13b3JrZXJzIHdvdWxkIGVuaGFuY2UgcGVyZm9ybWFuY2UgaGVyZSFcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYW5kIGRlbGV0ZXMgYWxsIHtAbGluayBUaW1lcn1zIGF0dGFjaGVkLiBTaG91bGQgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIFRpbWUtb2JqZWN0IGxlYXZlcyBzY29wZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXJBbGxUaW1lcnMoKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudGltZXJzKSB7XHJcbiAgICAgICAgdGhpcy5kZWxldGVUaW1lcihOdW1iZXIoaWQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB7QGxpbmsgVGltZXJ9IGZvdW5kIHVzaW5nIHRoZSBpbnRlcm5hbCBpZCBvZiB0aGUgY29ubmVjdGVkIGludGVydmFsLW9iamVjdFxyXG4gICAgICogQHBhcmFtIF9pZCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGV0ZVRpbWVyQnlJdHNJbnRlcm5hbElkKF9pZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudGltZXJzKSB7XHJcbiAgICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW2lkXTtcclxuICAgICAgICBpZiAodGltZXIuaWQgPT0gX2lkKSB7XHJcbiAgICAgICAgICB0aW1lci5jbGVhcigpO1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMudGltZXJzW2lkXTtcclxuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIGFuIGVhcmx5IG91dCBpcyBPSyBoZXJlLi4uIHNob3VsZCBiZSFcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbGxzIGEgdGltZXIgYXQgdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICogQHBhcmFtIF9sYXBzZSBUaGUgb2JqZWN0LXRpbWUgdG8gZWxhcHNlIGJldHdlZW4gdGhlIGNhbGxzIHRvIF9jYWxsYmFja1xyXG4gICAgICogQHBhcmFtIF9jb3VudCBUaGUgbnVtYmVyIG9mIGNhbGxzIGRlc2lyZWQsIDAgPSBJbmZpbml0ZVxyXG4gICAgICogQHBhcmFtIF9oYW5kbGVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIGVhY2ggdGhlIGdpdmVuIGxhcHNlIGhhcyBlbGFwc2VkXHJcbiAgICAgKiBAcGFyYW0gX2FyZ3VtZW50cyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gcGFzcyB0byBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VGltZXIoX2xhcHNlOiBudW1iZXIsIF9jb3VudDogbnVtYmVyLCBfaGFuZGxlcjogVGltZXJIYW5kbGVyLCAuLi5fYXJndW1lbnRzOiBPYmplY3RbXSk6IG51bWJlciB7XHJcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW51c2VkLWV4cHJlc3Npb25cclxuICAgICAgbmV3IFRpbWVyKHRoaXMsIF9sYXBzZSwgX2NvdW50LCBfaGFuZGxlciwgX2FyZ3VtZW50cyk7XHJcbiAgICAgIC8vdGhpcy5hZGRUaW1lcih0aW1lcik7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkVGltZXJBZGRlZExhc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgVGltZX0gYW5kIHtAbGluayBUaW1lcn0gYW5kIG11c3Qgbm90IGJlIGNhbGxlZCBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFRpbWVyKF90aW1lcjogVGltZXIpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLnRpbWVyc1srK3RoaXMuaWRUaW1lckFkZGVkTGFzdF0gPSBfdGltZXI7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkVGltZXJBZGRlZExhc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSB0aW1lciB3aXRoIHRoZSBpZCBnaXZlbiBieSB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lcihfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lcnNbX2lkXTtcclxuICAgICAgaWYgKCF0aW1lcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tfaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdGltZXIgd2l0aCB0aGUgZ2l2ZW4gaWQgb3IgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaW1lcihfaWQ6IG51bWJlcik6IFRpbWVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXJzW19pZF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCBvZiB0aW1lcnMgY3VycmVudGx5IGluc3RhbGxlZCBvbiB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaW1lcnMoKTogVGltZXJzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVGltZXJzID0ge307XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdGhpcy50aW1lcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSB7QGxpbmsgVGltZXJzfSBpbnN0YWxsZWQgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGFzVGltZXJzKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKE9iamVjdC5rZXlzKHRoaXMudGltZXJzKS5sZW5ndGggPiAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlcyB7QGxpbmsgVGltZXJ9cyB3aGVuIHNjYWxpbmcgY2hhbmdlc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2NhbGVBbGxUaW1lcnMoKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudGltZXJzKSB7XHJcbiAgICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW2lkXTtcclxuICAgICAgICB0aW1lci5jbGVhcigpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjYWxlKVxyXG4gICAgICAgICAgLy8gVGltZSBoYXMgc3RvcHBlZCwgbm8gbmVlZCB0byByZXBsYWNlIGNsZWFyZWQgdGltZXJzXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgLyogdGhpcy50aW1lcnNbaWRdID0gICovXHJcbiAgICAgICAgdGltZXIgPSB0aW1lci5pbnN0YWxsQ29weSgpOyAvLyB0aGUgdGltZXIgaXMgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGlzIHRpbWUgaW5zdGFuY2VcclxuICAgICAgICBkZWxldGUgdGhpcy50aW1lcnNbdGhpcy5pZFRpbWVyQWRkZWRMYXN0XTsgLy8gcmVtb3ZlIHRoZSBjb3B5IGFnYWluIC4uLlxyXG4gICAgICAgIHRoaXMudGltZXJzW2lkXSA9IHRpbWVyOyAvLyAuLi4gYW5kIHBsYWNlIGl0IGF0IHRoZSBpZCBvZiB0aGUgb3JpZ2luYWxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgdGhlIHNpZ25hdHVyZSBvZiBoYW5kbGVyIGZ1bmN0aW9ucyBmb3Ige0BsaW5rIEV2ZW50VGltZXJ9cywgdmVyeSBzaW1pbGFyIHRvIHVzdWFsIGV2ZW50IGhhbmRsZXJcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBUaW1lckhhbmRsZXIgPSAoX2V2ZW50OiBFdmVudFRpbWVyKSA9PiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBBIHtAbGluayBUaW1lcn0taW5zdGFuY2UgaW50ZXJuYWxseSB1c2VzIHdpbmRvdy5zZXRJbnRlcnZhbCB0byBjYWxsIGEgZ2l2ZW4gaGFuZGxlciB3aXRoIGEgZ2l2ZW4gZnJlcXVlbmN5IGEgZ2l2ZW4gbnVtYmVyIG9mIHRpbWVzLFxyXG4gICAqIHBhc3NpbmcgYW4ge0BsaW5rIEV2ZW50VGltZXJ9LWluc3RhbmNlIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhbmQgZ2l2ZW4gYXJndW1lbnRzLiBcclxuICAgKiBUaGUgZnJlcXVlbmN5IHNjYWxlcyB3aXRoIHRoZSB7QGxpbmsgVGltZX0taW5zdGFuY2UgdGhlIHtAbGluayBUaW1lcn0taW5zdGFuY2UgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUaW1lciB7XHJcbiAgICBwdWJsaWMgYWN0aXZlOiBib29sZWFuO1xyXG4gICAgcHVibGljIGNvdW50OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGhhbmRsZXI6IFRpbWVySGFuZGxlcjtcclxuICAgIHByaXZhdGUgdGltZTogVGltZTtcclxuICAgIHByaXZhdGUgZWxhcHNlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGV2ZW50OiBFdmVudFRpbWVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lb3V0UmVhbDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBpZFdpbmRvdzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBUaW1lcn0gaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHtAbGluayBUaW1lfSBpbnN0YW5jZSwgdGhlIHRpbWVyIGF0dGFjaGVzIHRvXHJcbiAgICAgKiBAcGFyYW0gX2VsYXBzZSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZWxhcHNlLCB0byB0aGUgbmV4dCBjYWxsIG9mIF9oYW5kbGVyLCBtZWFzdXJlZCBpbiBfdGltZVxyXG4gICAgICogQHBhcmFtIF9jb3VudCBUaGUgZGVzaXJlZCBudW1iZXIgb2YgY2FsbHMgdG8gX2hhbmRsZXIsIFRpbWVyIGRlaW5zdGFsbHMgYXV0b21hdGljYWxseSBhZnRlciBsYXN0IGNhbGwuIFBhc3NpbmcgMCBpbnZva2VzIGluZmluaXRlIGNhbGxzXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIHtAbGluayBUaW1lckhhbmRsZXJ9IGluc3RhbmNlIHRvIGNhbGxcclxuICAgICAqIEBwYXJhbSBfYXJndW1lbnRzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gX2hhbmRsZXJcclxuICAgICAqIFxyXG4gICAgICogVE9ETzogZm9yIHByb3BlciBoYW5kbGluZyBhbmQgZGVsZXRpb24sIHVzZSBUaW1lLnNldFRpbWVyIGluc3RlYWQgb2YgaW5zdGFudGlhdGluZyB0aW1lcnMgeW91cnNlbGYuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF90aW1lOiBUaW1lLCBfZWxhcHNlOiBudW1iZXIsIF9jb3VudDogbnVtYmVyLCBfaGFuZGxlcjogVGltZXJIYW5kbGVyLCAuLi5fYXJndW1lbnRzOiBPYmplY3RbXSkge1xyXG4gICAgICB0aGlzLnRpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy5lbGFwc2UgPSBfZWxhcHNlO1xyXG4gICAgICB0aGlzLmV2ZW50ID0gbmV3IEV2ZW50VGltZXIodGhpcywgX2FyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMuaGFuZGxlciA9IF9oYW5kbGVyO1xyXG4gICAgICB0aGlzLmNvdW50ID0gX2NvdW50O1xyXG5cclxuICAgICAgbGV0IHNjYWxlOiBudW1iZXIgPSBNYXRoLmFicyhfdGltZS5nZXRTY2FsZSgpKTtcclxuXHJcbiAgICAgIGlmICghc2NhbGUpIHtcclxuICAgICAgICAvLyBUaW1lIGlzIHN0b3BwZWQsIHRpbWVyIHdvbid0IGJlIGFjdGl2ZVxyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnRpbWVvdXRSZWFsID0gdGhpcy5lbGFwc2UgLyBzY2FsZTtcclxuXHJcbiAgICAgIGxldCBjYWxsYmFjazogRnVuY3Rpb24gPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIFxyXG4gICAgICAgIHRoaXMuZXZlbnQuY291bnQgPSB0aGlzLmNvdW50O1xyXG4gICAgICAgIHRoaXMuZXZlbnQubGFzdENhbGwgPSAodGhpcy5jb3VudCA9PSAxKTtcclxuICAgICAgICBfaGFuZGxlcih0aGlzLmV2ZW50KTtcclxuICAgICAgICB0aGlzLmV2ZW50LmZpcnN0Q2FsbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jb3VudCA+IDApXHJcbiAgICAgICAgICBpZiAoLS10aGlzLmNvdW50ID09IDApXHJcbiAgICAgICAgICAgIF90aW1lLmRlbGV0ZVRpbWVyQnlJdHNJbnRlcm5hbElkKHRoaXMuaWRXaW5kb3cpO1xyXG5cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuaWRXaW5kb3cgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIHRoaXMudGltZW91dFJlYWwsIF9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgIF90aW1lLmFkZFRpbWVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93LWlkIG9mIHRoZSB0aW1lciwgd2hpY2ggd2FzIHJldHVybmVkIGJ5IHNldEludGVydmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaWRXaW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lLWludGVydmFsbCBmb3IgY2FsbHMgdG8gdGhlIGhhbmRsZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBsYXBzZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5lbGFwc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyBhIGNvcHkgb2YgdGhpcyBhdCBpdHMgY3VycmVudCBzdGF0ZSB0byB0aGUgc2FtZSB7QGxpbmsgVGltZX0taW5zdGFuY2UuIFVzZWQgaW50ZXJuYWxseSB3aGVuIHJlc2NhbGluZyB7QGxpbmsgVGltZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluc3RhbGxDb3B5KCk6IFRpbWVyIHtcclxuICAgICAgcmV0dXJuIG5ldyBUaW1lcih0aGlzLnRpbWUsIHRoaXMuZWxhcHNlLCB0aGlzLmNvdW50LCB0aGlzLmhhbmRsZXIsIHRoaXMuZXZlbnQuYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgdGltZXIsIHJlbW92aW5nIGl0IGZyb20gdGhlIGludGVydmFsLXRpbWVycyBoYW5kbGVkIGJ5IHdpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIC8vIGlmICh0aGlzLnR5cGUgPT0gVElNRVJfVFlQRS5USU1FT1VUKSB7XHJcbiAgICAgIC8vICAgICBpZiAodGhpcy5hY3RpdmUpXHJcbiAgICAgIC8vICAgICAgICAgLy8gc2F2ZSByZW1haW5pbmcgdGltZSB0byB0aW1lb3V0IGFzIG5ldyB0aW1lb3V0IGZvciByZXN0YXJ0XHJcbiAgICAgIC8vICAgICAgICAgdGhpcy50aW1lb3V0ID0gdGhpcy50aW1lb3V0ICogKDEgLSAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZVJlYWwpIC8gdGhpcy50aW1lb3V0UmVhbCk7XHJcbiAgICAgIC8vICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGVsc2VcclxuICAgICAgLy8gVE9ETzogcmV1c2luZyB0aW1lciBzdGFydHMgaW50ZXJ2YWwgYW5ldy4gU2hvdWxkIGJlIHJlbWFpbmluZyBpbnRlcnZhbCBhcyB0aW1lb3V0LCB0aGVuIHN0YXJ0aW5nIGludGVydmFsIGFuZXcgXHJcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaWRXaW5kb3cpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxufSJdfQ==